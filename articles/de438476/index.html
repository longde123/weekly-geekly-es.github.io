<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚óÄÔ∏è üòÆ üéª Zur Frage der Puffer (Ring) üéä ‚õπüèΩ üôåüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Wenn Sie die Entwicklungskosten der Architektur als √ºberm√§√üig empfinden, √ºberlegen Sie, wie viel Sie die falsche Architektur kosten kann." 
 - Ich ka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zur Frage der Puffer (Ring)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438476/"><h3>  "Wenn Sie die Entwicklungskosten der Architektur als √ºberm√§√üig empfinden, √ºberlegen Sie, wie viel Sie die falsche Architektur kosten kann." </h3><br>  - Ich kann mich nicht genau an die Quelle erinnern <br><br>  Einmal, "vor langer Zeit, in einer fernen Galaxie", kaufte ich Charles Weatherlys wundervolles Buch Etudes for Programmers, in dessen Einleitung der Autor die Notwendigkeit begr√ºndete, p√§dagogische Beispiele und Aufgaben zu studieren, bevor er mit der unabh√§ngigen Programmierung begann.  Ich empfehle Ihnen dringend, dieses Buch zu finden, das Vorwort zu lesen (und ohne anzuhalten, den Rest zu lesen und die darin angegebenen Probleme zu l√∂sen), da ich die Notwendigkeit einer solchen Praxis nicht besser begr√ºnden kann.  Selbst wenn Sie meiner Empfehlung folgen und beim Lesen des Buches viel Wissen und praktische F√§higkeiten erwerben, k√∂nnen Sie diesen Beitrag noch einmal lesen, da er mehreren anderen Themen gewidmet ist.  Und wenn Sie meinen Empfehlungen nicht folgen, sollten Sie umso mehr unter die Katze gehen. <br><a name="habracut"></a><br>  Vor nicht allzu langer Zeit habe ich in einem Beitrag, in dem ich schimpfte, meine Meinung zu einem inl√§ndischen RTOS ge√§u√üert, dass die Implementierung des Ringpuffers in der bekannten (und in bestimmten Aspekten absolut wunderbaren) mcucpp-Bibliothek nicht als ideal angesehen werden kann.  Ich werde versuchen, meinen Standpunkt zu erkl√§ren und mir die ideale (soweit in der realen Welt m√∂glich) Implementierung vorzustellen.  Hinweis - Der Text, der Ihnen zur Kenntnis gebracht wurde, lag einige Zeit im "unvollendeten" Text, und dann tauchte ein so praktischer Fall auf. <br><br>  Wir entwickeln weiterhin eine Bibliothek f√ºr die Arbeit mit einem Peripherieger√§t und stehen als n√§chstes f√ºr die Speicherverwaltung und -pufferung an (ja, wir setzen die vorbereitenden Vorg√§nge fort, jedoch ohne sie in irgendeiner Weise).  Woher kommt die Notwendigkeit, Puffer zu organisieren, und was f√ºr ein Tier ist das?  Tatsache ist, dass ein erheblicher Teil der Peripherie eine begrenzte Geschwindigkeit aufweist und der √úbertragungsprozess, der auf die eine oder andere Weise gestartet wird, eine bestimmte und manchmal sehr wichtige Zeit ben√∂tigt, verglichen mit der Erstellung eines anderen Teils der Informationen f√ºr die √úbertragung.  Nat√ºrlich kann vor Ablauf dieser Zeit die n√§chste √úbertragung nicht durchgef√ºhrt und dementsprechend nicht gestartet werden. <br><br>  Wir haben einen klassischen Fall eines Writer-Reader-Paares mit unterschiedlichen Geschwindigkeiten.  Es ist einfach unm√∂glich, dieses Problem in einer allgemeinen Form zu l√∂sen, da ‚Äûbei einem willk√ºrlich kleinen, aber nicht Null-√úberschuss des Anforderungsflusses √ºber den Servicefluss die Warteschlangengr√∂√üe gegen unendlich tendiert‚Äú und unendlich grunds√§tzlich unm√∂glich ist.  Ein Sonderfall des Problems ist jedoch, dass ein Pufferspeicher mit ausreichender Kapazit√§t gel√∂st werden kann, wenn lokale Anforderungsbursts vorliegen, der Servicefluss jedoch im Durchschnitt die Last bew√§ltigen kann.  Achten wir auf den Ausdruck ‚Äûausreichende Kapazit√§t‚Äú, wir werden sp√§ter lernen, wie man ihn berechnet, solange uns die Tatsache, dass dies grunds√§tzlich m√∂glich ist, ausreicht. <br><br>  Ob Pufferspeicher eine absolute Voraussetzung ist, ist nat√ºrlich nicht.  F√ºr die √ºbertragenen Informationen k√∂nnen Sie einen Sperrdatensatz verwenden. Bei den empfangenen Informationen ist dies jedoch etwas schlimmer. Sie m√ºssen irgendwo vor der Verarbeitung hinzugef√ºgt werden, wenn Sie im Protokoll der obersten Ebene keine geeigneten Ma√ünahmen ergreifen (der magische Ausdruck xon / xoff wurde nicht von Grund auf neu geboren), was nicht immer m√∂glich ist und f√ºhrt in jedem Fall normalerweise zu einer signifikanten Begrenzung der √úbertragungsrate.  Es gibt auch eine Hardware-Implementierung von internen Puffern in Peripherieger√§ten (mindestens f√ºr ein Element), dies wird jedoch nicht immer durchgef√ºhrt und die Puffergr√∂√üe wird von oben streng begrenzt. <br><br>  Daher werden wir weiterhin den Programmpuffer implementieren, f√ºr den es selbstverst√§ndlich w√§re, die FIFO-Methode (dh die Warteschlange) zum Organisieren eines solchen Puffers zu verwenden, und die Warteschlange wiederum wird am besten in einem Ringpuffer mit zwei Zeigern implementiert.  Wenn ich "best" schreibe, bedeutet dies √ºberhaupt nicht, dass andere Implementierungen (z. B. eine Referenzwarteschlange) unm√∂glich sind oder andere schwerwiegende Fehler als schwerwiegende aufweisen.  Dieser Ausdruck bedeutet nur, dass die Implementierung nicht zu kompliziert und recht effektiv sein wird, obwohl andere m√∂glicherweise unbestreitbare Vorteile gegen√ºber dieser haben, f√ºr die sie etwas bezahlen m√ºssen, weil DarZaNeBy. <br><br>  Da es sehr unwahrscheinlich ist, dass Ihr MK-Modell √ºber eine Hardware-Implementierung eines solchen Allzweckger√§ts verf√ºgt (einzelne Peripheriemodule k√∂nnen ihre eigenen Ringpuffer haben, haben aber nichts mit dem Thema dieses Beitrags zu tun), m√ºssen wir einen Ringpuffer im linearen Speicher erstellen (implementieren auf Vektor, dies ist im Allgemeinen das einzige nat√ºrliche Objekt im adressierbaren Speicher), und daf√ºr wird ein Pufferindex (oder vielleicht sogar zwei Indizes, aber dazu sp√§ter mehr) ben√∂tigt.  Meiner Meinung nach ist ein kreisf√∂rmiger Puffer mit zwei Zeigern (Indizes) der einzig akzeptable Weg, um eine Warteschlange in einem Vektor zu implementieren, aber es gibt unterschiedliche Sichtweisen zu diesem Thema, und ich habe mit eigenen Augen eine Implementierung im Stil von ‚Äûx1 = x2;  x2 = x3; ... x8 = neues Symbol ", wenn Sie so wollen, werde ich solche Exoten nicht in Betracht ziehen.  Die Tatsache, dass das gegebene Fragment das Recht hat, in einer bestimmten, sehr begrenzten Situation zu existieren, macht es im Allgemeinen nicht akzeptabel. <br><br>  Wir werden die korrekte Implementierung des Programmmoduls zum Organisieren des Zeigers betrachten und zun√§chst auf das erste Wort in der Definition achten.  Der Unterschied zwischen einem korrekten und einem falschen Code besteht nicht nur darin, dass der richtige Code keine Fehler enth√§lt, obwohl dies eine absolute Voraussetzung ist.  Sogar der Code, der seine Funktionen vollst√§ndig ausf√ºhrt, kann falsch sein, wenn er unverst√§ndlich ist oder wenn es eine Option gibt, die nicht weniger klar ist, aber schneller ausgef√ºhrt wird oder so schnell ausgef√ºhrt wird, aber klarer geschrieben ist, sodass das Konzept der Korrektheit etwas relativ ist.  Wir setzen unsere Betrachtung unseres Beispiels f√ºr die Pufferimplementierung fort, um den Unterschied zwischen verschiedenen Korrektheitsgraden aufzuzeigen. <br><br>  Bevor wir uns der Essenz zuwenden, ein wichtiger Punkt zur weiteren Diskussion.  Ich meine, Ihr Compiler ist immer auf einer Otpimierungsstufe ungleich Null (-O2) eingeschaltet, sodass wir nicht √ºber geringf√ºgige Verbesserungen nachdenken m√ºssen, wie 1) Pr√§fix√§nderung gegen√ºber Postfix oder 2) Verwendung der Ergebnisse der vorherigen Operation oder 3) Differenz zwischen Inkrement und Addition Einheiten und so weiter - wir gehen davon aus, dass der Compiler viel f√ºr uns tun wird.  Nat√ºrlich ist dies keine strenge Annahme, aber sonst m√ºssen wir uns in den Darm des Assemblers st√ºrzen, der in unserer Zeit nicht der Mainstream ist. <br><br>  Ich m√∂chte Sie daran erinnern, dass wir angewiesen wurden, den Index (Zeiger) des Ringpuffers zu implementieren. Das hei√üt, wir m√ºssen das Verhalten einer Variablen erstellen, die <b>nacheinander eine Reihe von Werten durchl√§uft, von einem Anfang bis zu einem Ende</b> .  Nehmen Sie sofort an, dass der Anfangswert Null ist, andernfalls m√ºssen wir sofort einen mehr oder weniger korrekten Code schreiben. Dies widerspricht den Bildungszielen und wir haben es nicht eilig und der letzte ist Max. <br><br>  Dieses Verhalten der Variablen kann mit der folgenden Konstruktion implementiert werden: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; Counter = (++Counter) % (Max+<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  und genau diesen Code k√∂nnen wir in vielen (dh sehr oft) F√§llen sehen.  Was ist falsch? Erstens ist unsere Variable f√ºr einige Zeit (von der Durchf√ºhrung der Inkrementierungsoperation bis zur Zuweisung des Ergebnisses) gr√∂√üer als der maximal zul√§ssige Wert. Wenn in diesem Moment ein Interrupt auftritt, der den Wert dieser Variablen ber√ºcksichtigen muss, dann sage ich pers√∂nlich voraus Ich gehe nicht von den Ergebnissen aus.  Deshalb schreiben wir das Programm neu: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Counter=<span class="hljs-number"><span class="hljs-number">0</span></span>; Counter = (Counter + <span class="hljs-number"><span class="hljs-number">1</span></span>) % (Max + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Wir haben einen Fehler beseitigt, und der Code (im Folgenden meine ich den Code "ausf√ºhrbar" bedeutet den vom Compiler generierten ausf√ºhrbaren Code) ist nicht l√§nger geworden und wird nicht mehr ausgef√ºhrt (tats√§chlich wird er schneller ausgef√ºhrt, sondern nur, weil in der ersten Version Das Wort fl√ºchtig wird in diesem Fall v√∂llig √ºberfl√ºssig verwendet) und ist nicht weniger klar geworden (eher noch klarer, aber dies ist Geschmackssache). <br><br>  Notwendiger Hinweis zu volatile - Diese Direktive wird ben√∂tigt, um eine Codeoptimierung zu vermeiden, die zu einer fehlerhaften Ausf√ºhrung f√ºhrt, und in diesem speziellen Fall (wenn sich der Wert der Variablen au√üerhalb des Bereichs des Moduls nicht √§ndert und keine sequentiellen Eintr√§ge darin enthalten sind) (Direktive ) v√∂llig √ºberfl√ºssig.  Ich empfehle dringend, dass Sie sich den generierten Code f√ºr beide Optionen auf godbolt.org ansehen.  Warum Sie die fl√ºchtige Direktive nicht missbrauchen sollten, im Gegensatz zum statischen Schl√ºsselwort, das nach M√∂glichkeit empfohlen wird.  Nun, erstens verbieten wir die Optimierung, das hei√üt, der Code wird definitiv nicht schneller (h√∂chstwahrscheinlich wird er gr√∂√üer und langsamer, aber wir bevorzugen strenge Formulierungen).  Und zweitens ist dieses Wort in diesem speziellen Fall irref√ºhrend, da sich der Wert des Z√§hlers in Bezug auf unser Programm in keiner Weise au√üerhalb unserer Kontrolle √§ndern kann.  In einem Programm, das seinen Wert liest, dh in der Implementierung des Ringpuffers selbst, k√∂nnen Sie den Z√§hler au√üerhalb des Moduls als ver√§nderbar betrachten, und dort ist er fraglich, daher ist dieses Attribut einfach nicht auf den Z√§hler anwendbar.  Wenn eine Variable in verschiedenen Modulen unterschiedlich interpretiert werden soll, sollten unsere Services kombiniert werden. Wenn wir √ºber die Organisation eines kritischen Abschnitts sprechen, beispielsweise bei der Implementierung einer Transaktion oder von atomaren Operationen, dann gibt diese Direktive √ºberhaupt nichts. <br><br>  Wir kehren zum Code zur√ºck und sehen, dass das Programm immer noch falsch ist - was ist los - und dass es nicht das tut, was wir brauchen (siehe Beschreibung der Aufgabe), sondern etwas anderes (berechnet den Rest der Division), nur die Ergebnisse zusammenpassen.  Nun, wir denken so (ich glaube nicht, aber die Autoren des Codes sicherlich), dass die Ergebnisse tats√§chlich √ºbereinstimmen, im allgemeinen Fall stimmen sie nicht √ºberein, wir hatten nur Gl√ºck mit dem Bereich der Variablen (positive Werte).  Dar√ºber hinaus ist der Prozess der Ausf√ºhrung des Codes l√§nger als m√∂glich, da wir im besten Fall die Ganzzahldivision durchf√ºhren (wenn sie Teil der Befehle unserer Architektur ist) und sie keinesfalls in einem Prozessorzyklus ausgef√ºhrt wird (ein charakteristischer Wert von 10 Zyklen) f√ºr eine 8-Bit-Architektur), und im schlimmsten Fall wird der Aufruf der Teilungsprozedur aus der Standardbibliothek angezeigt (und wenn eine kurze Teilung erfolgt), betr√§gt die Ausf√ºhrungszeit zehn Taktzyklen. <br><br>  Warum ist es also immer noch m√∂glich, einen so v√∂llig falschen Ansatz sehr oft zu treffen?  Hier vom Publikum sagen sie mir, dass der Compiler mit dem Wert von Max + 1, der eine Zweierpotenz ist, anstelle der Divisionsoperation die Operation der bitweisen Multiplikation auf die entsprechende Maske (gleich Max) setzen wird, die sehr schnell ausgef√ºhrt wird und alles in Ordnung ist. <br><br>  Ich w√ºrde dieser Aussage zustimmen und diesen Ansatz verfolgen, wenn nicht unter folgenden Umst√§nden: <br><br><ul><li>  Dies ist nur f√ºr Mach m√∂glich, der in der Kompilierungsphase statisch definiert wurde. </li><li>  Dies geschieht nur, wenn die Optimierung aktiviert ist. </li><li>  Dies geschieht nur, wenn Mach diese Bedingung erf√ºllt. </li><li>  Dies tritt nicht bei allen Kardinaltypen auf. </li></ul><br>  Dar√ºber hinaus wird in diesem speziellen Fall (wenn die Variable als Vorzeichen definiert ist) zus√§tzlich zum Befehl zum Multiplizieren (logisch) mit der Maske ein Vergleichsbefehl mit Null und eine Verzweigung f√ºr negative Werte generiert, und obwohl diese Verzweigung niemals f√ºr unseren Bereich gilt Es wird ausgef√ºhrt, es nimmt Speicherplatz im Speicher ein (und im Fall einer austauschbaren Funktion dauert es mehrere Male) und es wird einige Zeit dauern, um die Vergleichsoperation durchzuf√ºhren. Wenn Sie es nicht glauben, folgen wir erneut der angegebenen Site und √ºberzeugen uns selbst.  Ein weiteres Argument zugunsten der nicht unterzeichneten Kardin√§le, denen ich k√ºrzlich einen ganzen Beitrag gewidmet habe. <br><br>  Wenn wir daher die logische Multiplikation mit einer Maske verwenden m√∂chten (erhalten durch Optimieren der Berechnung des Restes), sollten wir das Modul entsprechend umschreiben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Counter_t; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> sCounter_t; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Counter_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextCounter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Counter_t Counter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> IS_POWER2(Max + 1) return (Counter + 1) &amp; Max #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> return (Counter + 1) % (Max + 1); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> };</span></span></code> </pre> <br>  In dieser Version ist alles vollkommen klar und kontrollierbar und alles ist wahr (obwohl eine Reihe von M√§ngeln bestehen geblieben sind, aber sie sind jetzt offensichtlich und nicht maskiert), daher ist es richtig, obwohl es korrekter ist und wir werden sie jetzt suchen.  Der Hauptnachteil ist meiner Meinung nach eine Verletzung des KISS-Prinzips, da die Verwendung der Restoperation durch Division dieses Prinzip v√∂llig vernachl√§ssigt.  Daher werden wir jetzt alle M√§ngel mit einem Schlag beseitigen (keine Sorge um ihr Schicksal, sie werden 100.500 Mal wiedergeboren, da nicht alle Programmierer f√ºr Arduino meine Beitr√§ge lesen). <br><br>  Aber zuerst eine leichte Abweichung zur Seite.  Wie k√∂nnen wir eine √úberpr√ºfung der Zweierpotenz (eine Bin√§rzahl kann als {0} 1 {0} dargestellt werden) implementieren, die wir gerade verwendet haben? <br><br><div class="spoiler">  <b class="spoiler_title">Spioniere nicht aus</b> <div class="spoiler_text">  #define IS_POWER2 (N) (((((N) - 1) &amp; (N)) == 0) <br></div></div><br>  Und wie k√∂nnen wir die √úberpr√ºfung implementieren, dass eine Zahl eine richtige Folge von Einheiten {0} 1 {1} in bin√§rer Notation ist - eine Option liegt auf der Hand <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IsRightSequence(N) IsPower2 ((N) + 1)</span></span></code> </pre> <br>  und der zweite ist trivial <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IsRightSequence(N) ( (((N) + 1) &amp; (N)) == 0)</span></span></code> </pre> <br>  Anmerkung: Ich kann nicht anders, als mich an den gro√üartigen Satz zu erinnern: "Eine transzendentale Zahl in einem transzendentalen Grad ist immer transzendent, es sei denn, das Gegenteil ist offensichtlich oder trivial." <br><br>  Und wie k√∂nnen wir √ºberpr√ºfen, ob eine Zahl eine Folge von Einheiten {0} 1 {1} {0} ist? <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IsSequence(N) IsPower2( (N) ^ ((N) &lt;&lt; 1))</span></span></code> </pre> <br>  Und schlie√ülich - wie man das niedrigstwertige Bit einer Zahl ausw√§hlt (ich wei√ü nicht, warum dies notwendig sein k√∂nnte, aber es wird n√ºtzlich sein) <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LowerBit(N) ((((N) - 1) ^ (N)) &amp; (N)).</span></span></code> </pre> <br><br>  Aber er hat sich ausgedacht, was n√ºtzlich sein kann <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IsRightSequence(N) (IsSequence(N) &amp;&amp; (LowerBit(N) == 1))</span></span></code> </pre> <br>  Eine merkw√ºrdige Beobachtung - diese Makros sind nicht ganz korrekt. Es stellt sich heraus, dass 0 sowohl eine Zweierpotenz als auch eine richtige Sequenz ist (nat√ºrlich auch eine Sequenz), was etwas seltsam ist.  Aber 1 ist all diese Objekte zu Recht, so dass Null anscheinend nur separat betrachtet werden muss.  Eine weitere interessante Eigenschaft dieser Makros ist, dass wir keine Annahmen √ºber die L√§nge des Arguments treffen, dh, sie funktionieren mit jedem Kardinaltyp korrekt. <br><br>  Es gibt ein wundervolles Buch, "Tricks for Programmers", in dem Sie die genannten Makros und viele andere ebenso unterhaltsame und lehrreiche Aufgaben finden. Ich empfehle es dringend, es zu lesen, zumal es nicht zu viele Buchstaben enth√§lt. <br><br>  Aber zur√ºck zu unserem Ringpufferindex.  Wir haben die richtige L√∂sung gegeben, aber noch korrekter versprochen, was bedeutet, dass unsere letzte L√∂sung M√§ngel aufweist (wer w√ºrde daran zweifeln).  Eine davon - die L√§nge des Puffers sollte in der Kompilierungsphase statisch bestimmt werden, die zweite - im Falle einer erfolglosen L√§nge ist die Ausf√ºhrungszeit sehr lang und es gibt immer noch eine bestimmte Anzahl von Fehlern in einem relativ kleinen Teil des Programms, was uns an einen Witz √ºber 4 Fehler beim Schreiben des Wortes "mehr" erinnert.  Wir werden sie alle beseitigen (einige werden f√ºr sp√§ter √ºbrig bleiben) und sofort, wof√ºr wir schlie√ülich die L√∂sung f√ºr das urspr√ºngliche Problem schreiben werden, wie es ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Counter_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextCounter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Counter_t Counter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Counter + <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt; Max) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Counter + <span class="hljs-number"><span class="hljs-number">1</span></span>; }; };</code> </pre> <br>  (Wie Sie bereits verstanden haben, bin ich ein Anh√§nger der √§gyptischen Klammern und es gibt nichts zu tun). <br><br>  Lassen Sie uns darauf achten, dass wir den Zustand des Problems einfach aus einer nat√ºrlichen Sprache in der gew√§hlten Programmiersprache umgeschrieben haben, sodass es sich als √§u√üerst klar und verst√§ndlich herausstellt.  Ist es m√∂glich, es zu verbessern - zweifellos, aber nur unter dem Gesichtspunkt der Geschwindigkeit des Codes, da es einfach keine anderen M√§ngel f√ºr diese L√∂sung gibt (es gibt keine offensichtlichen M√§ngel, tats√§chlich existieren sie und wir werden sie erfolgreich beseitigen). <br><br>  Bewerten wir die rechnerische Komplexit√§t dieser L√∂sung - Addition mit Einheit (1) und Vergleich (2) immer, dann Zuweisung von Null (1) (selten) oder Addition (1) (fast immer) -, was 1 + 2 + 1 + Œî ~ 4 Elementar ergibt Operationen und Nullspeicher.  Es ist m√∂glich, dass ein guter Compiler im richtigen Modus bestimmte Optimierungen vornimmt und die Ausf√ºhrungszeit des Codes verk√ºrzt. Es ist jedoch besser, dies explizit zu tun.  Hier ist die folgende Option: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Counter_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextCouner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Counter_t Counter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> sCounter_t Tmp; Tmp = (Counter + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Tmp &gt; Max) { Tmp = <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Tmp; };</code> </pre> <br>  Wir bewerten die Komplexit√§t - Addition und Vergleich immer, weisen null (selten) zu - ungef√§hr 3 Operationen und ein Speicherelement.  Tats√§chlich hatte die vorherige Version auch ein Speicherelement (implizit), so dass wir einen Nettogewinn in einer Elementaroperation haben.  Dar√ºber hinaus hatte die vorherige Version zwei weitere Nachteile - 1) verstie√ü gegen das DRY-Prinzip (berechnete den Anstieg zweimal um eins) und 2) hatte mehr als einen Austrittspunkt, was nicht gut ist.  Wir haben auch nicht das Verst√§ndnis verloren, das hei√üt, wir haben es geschafft, ein paar Kaninchen mit einem Schuss zu t√∂ten, und wir haben auch keine Patronen ausgegeben - es ist nur eine Geschichte im Stil von Baron M√ºnchhausen. <br><br>  Beachten Sie, dass ich das Konstrukt <code>if ( (Tmp = Counter + 1) &gt; Max)</code> verwendet habe, obwohl es eine explizite Anweisung an den Compiler enth√§lt, zu versuchen, keine redundanten √úbertragungen vorzunehmen.  Dies ist ein Aroma in der offensichtlichsten Form. Ich mag den vom Zuweisungsoperator zur√ºckgegebenen Wert einfach nicht und versuche, ihn nicht zu verwenden.  Ich kann den Grund f√ºr dieses starke Gef√ºhl nicht erkl√§ren, laut Freud ist dies h√∂chstwahrscheinlich ein psychologisches Trauma in der Kindheit.  Moderne Compiler sind durchaus in der Lage, einfache Optimierungen selbst durchzuf√ºhren, und au√üerdem habe ich ein Registerqualifikationsmerkmal hinzugef√ºgt, damit der Code f√ºr meine Version und der richtige (aus Sicht der C-Sprache) √ºbereinstimmen.  Trotzdem schr√§nke ich Ihre Freiheit, die Ihnen vorzuziehende Methode anzuwenden, keineswegs ein. <br><br>  Wir verbessern uns weiter, weil der Perfektion keine Grenzen gesetzt sind und wir sie noch nicht erreicht haben.  Um dies zu erreichen, formulieren wir das urspr√ºngliche Problem etwas neu und lassen nur die Anforderung der Variablen im Wertebereich, ohne die Richtung der √Ñnderung anzugeben.  Mit diesem Ansatz k√∂nnen Sie das Programm wie folgt umschreiben <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Counter_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextCouner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Counter_t Counter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> Counter_t Tmp; Tmp = (Counter - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Tmp &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Tmp = ; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Tmp; };</code> </pre> <br>  Auf den ersten Blick hat sich nicht viel ge√§ndert, aber wir bekommen trotzdem einen Zeitgewinn.  Nat√ºrlich nicht aufgrund der Tatsache, dass der Vorgang des Verringerns um eins schneller funktioniert als der Vorgang des Erh√∂hens um ihn (obwohl ich eine √§hnliche Version geh√∂rt habe), sondern aufgrund der Besonderheiten des Vergleichs.  Wenn ich in den vorherigen Versionen den Vergleich als zwei Elementaroperationen betrachtet habe (zuerst subtrahieren wir und treffen dann eine Entscheidung), wird in diesem Fall das Ergebnis der vorherigen Operation verwendet, um eine Entscheidung direkt zu treffen, und der Vergleich erfordert eine Elementaroperation, die immer zu zwei Operationen und einer Zuordnung f√ºhrt (selten) und wir haben eine Operation gespeichert (ohne etwas zu verlieren), wie das Sprichwort sagt: "Eine Kleinigkeit, aber nett."  Ist die resultierende L√∂sung ideal - leider nein.  Es ist der L√∂sung mit einer Maske (die genau 2 Elementaroperationen erfordert) in Bezug auf die Geschwindigkeit etwas unterlegen, und dies ist m√∂glicherweise der einzige Nachteil. <br><br>  Es gibt eine noch schnellere L√∂sung: Erh√∂hen (verringern) Sie einfach den Z√§hlerwert und tun Sie nichts anderes. Dies ist jedoch nur dann m√∂glich, wenn der Maximalwert mit dem Wert √ºbereinstimmt, der f√ºr den akzeptierten Typ am repr√§sentativsten ist.  F√ºr einen 8-Bit-Z√§hler (dh vom Typ uint8_t) ist es 255. Dann schreiben wir einfach Counter = Counter + 1 und nehmen mein Wort daf√ºr, dass das Schreiben von Counter + = 1 oder ++ Counter v√∂llig optional ist, obwohl es viele sind und sie werden schreiben und absolut richtig sein.  Wenn wir die Version √ºber die Notwendigkeit, Zeichen zu speichern, nicht ernsthaft in Betracht ziehen (da die erste Option die l√§ngste ist), macht dies keinen Sinn, zumindest wenn wir ein Programm f√ºr die ARM- oder AVR-Architektur schreiben (f√ºr andere, die ich gerade nicht √ºberpr√ºft habe, vermute ich, dass das Ergebnis sein wird das gleiche) unter dem GCC-Compiler (der Autor versteht, dass sie das Programm im Editor der integrierten Programmierumgebung schreiben, dies ist nur eine Sprachrevolution aus der Vergangenheit, als Computer gro√ü und Speicher klein waren) und mit auf jeder Ebene aktivierter Optimierung, weil  Der angegebene Code ist absolut identisch. <br><br>  Moderne Compiler sind in Bezug auf die Optimierung sehr, sehr fortgeschritten und generieren nat√ºrlich wirklich sehr guten Code, wenn Sie den entsprechenden Modus aktiviert haben.  Obwohl ich bereit bin zuzustimmen, dass solche Sprachkonstrukte keinen Schaden anrichten und unter bestimmten Bedingungen n√ºtzlich sein k√∂nnen, stelle ich nur fest, dass Counter ++ - Ausdr√ºcke (in diesem speziellen Fall nat√ºrlich) eindeutig vermieden werden sollten, da sie f√ºr v√∂llig andere Situationen gedacht sind und dazu f√ºhren k√∂nnen langsamerer Code, obwohl optional. <br><br>  Eine andere Frage ist, dass ein Puffer mit 256 Elementen nicht immer akzeptabel ist. Wenn Sie jedoch √ºber gen√ºgend Speicher verf√ºgen, warum nicht?  Wenn Sie bei dieser Implementierung den Puffer am Seitenrand ausrichten k√∂nnen, kann der Zugriff auf die Elemente sehr schnell erfolgen, da Sie nicht mehr von Index zu Index wechseln m√ºssen (das Schl√ºsselwort union zeigt Ihnen die Implementierung einer solchen Funktion an. Ich werde sie nicht einbringen, um nicht zu lernen schlecht), aber dies ist bereits eine sehr, sehr spezifische Entscheidung mit einer starken Bindung an die Architektur, die im schlimmsten Sinne des Wortes gef√§hrlich nahe an Tricks liegt, und dies ist nicht unser Stil. <br><br>  Nat√ºrlich verbietet uns niemand, einen Wrapper zu schreiben, der diese oder jene Methode abh√§ngig vom Wert der maximalen (und minimalen, da viele Methoden einfach nicht mit einem Minimum ungleich Null arbeiten) Z√§hlerwerte aufruft. Ich habe daher bereits die Grundprinzipien einer solchen L√∂sung vorgeschlagen Wir werden dies als √úbung anbieten. <br><br>  Zusammenfassend l√§sst sich sagen, dass wir verschiedene Implementierungen von Arbeiten mit einem Ringindex zusammenf√ºhren und ihre Eigenschaften bewerten werden. <br><div class="scrollable-table"><table><tbody><tr><th>  Methode </th><th>  Vielseitigkeit </th><th>  Vorlaufzeit </th></tr><tr><td>  ¬± </td><td>  0 (1) </td><td>  1 </td></tr><tr><td>  ¬±% </td><td>  1 (7) </td><td>  2 </td></tr><tr><td>  + wenn </td><td>  3 (beliebig) </td><td>  3.x. </td></tr><tr><td>  - wenn </td><td>  3 (beliebig) </td><td>  2.x. </td></tr></tbody></table></div><br>  Die zweite Zeile in Klammern zeigt die Anzahl der Puffergr√∂√üenwerte (nicht mehr als 256), f√ºr die diese Implementierung verf√ºgbar ist. Wir meinen jedoch, dass ein Puffer der Gr√∂√üe 0 uns nicht interessiert. <br><br>  Wie Sie aus dieser Tabelle ersehen k√∂nnen, DarZaNeBy (mein Lieblingsausdruck, wie Sie vielleicht bemerkt haben) und die Vorteile auf Kosten der Nachteile gekauft werden, kann nur eindeutig festgestellt werden, dass das Inkrement mit der Verifikation einen erfolgreicheren Konkurrenten in Form einer Dekrementierung mit Verifikation hat und nicht in die n√§chste Runde geht unter keinen Umst√§nden. <br><br>  Ein notwendiger Hinweis - es gibt Programmiersprachen, in denen wir √ºberhaupt nicht √ºber die Implementierung des Index nachdenken m√ºssten, sondern einfach den Intervalltyp verwenden k√∂nnten.  Leider kann ich die Implementierung dieser Konstrukte im Code nicht als optimal bezeichnen, da diese Konstrukte (und diese Sprachen) nicht zur Optimierung zur Laufzeit vorgesehen sind, aber es ist schade. <br><br>  Also haben wir das richtige Modul (was f√ºr ein starker Name f√ºr die Inline-Funktion) f√ºr die Arbeit mit dem Index erstellt, und jetzt k√∂nnen wir mit der Implementierung des Ringpuffers selbst beginnen. <br><br>  Und f√ºr den Anfang sollten wir entscheiden, was genau wir von diesem Programmobjekt wollen.  Es ist absolut notwendig, ein Datenelement in einen Puffer einf√ºgen und extrahieren zu k√∂nnen - zwei Hauptmethoden, eine Art Getter und Setter.  Es ist theoretisch m√∂glich, sich einen Puffer ohne eine dieser Methoden oder sogar ohne beide vorzustellen (wenig kann rein theoretisch vorgestellt werden), aber der praktische Wert einer solchen Implementierung ist eine gro√üe Frage.  Die n√§chste notwendige Funktionalit√§t - das √úberpr√ºfen auf Informationen - kann entweder als separate Methode oder als spezieller Wert (oder Attribut) implementiert werden, der durch Lesen zur√ºckgegeben wird.  Normalerweise bevorzugen sie die erste Methode, da sie verst√§ndlicher und nicht zu teuer ist. <br>  Die √úberpr√ºfung des Puffers auf Vollst√§ndigkeit ist jedoch bereits eine gro√üe Frage - dieser Vorgang erfordert zus√§tzliche Zeit, die immer f√ºr die Aufzeichnung aufgewendet wird, obwohl uns niemand zwingt, ihn zu verwenden - also lass es sein.  Wir brauchen nichts anderes aus dem Puffer. Erinnern wir uns an diesen Satz f√ºr die Zukunft. <br><br>  Zur√ºck zur Implementierung.  Wir brauchen einen Platz zum Speichern der Elemente der Warteschlange und zwei Indizes - einen zum Schreiben in den Puffer und einen zum Lesen daraus.  Wie genau wir diesen Ort (und diese Hinweise) erhalten, ist ein Thema f√ºr eine separate Diskussion. Lassen Sie uns diesen Moment vorerst in Klammern lassen und glauben, dass wir sie einfach haben.  Einige (einschlie√ülich der Autoren des Buches "Programmieren f√ºr Mathematiker", das ich respektiere, ich empfehle es zu lesen) verwenden ebenfalls den Z√§hler f√ºr ausgef√ºllte Stellen, aber wir werden dies nicht tun und ich werde versuchen zu zeigen, warum dies b√∂se ist. <br><br>  Erstens √ºber die Indizes - wir bemerken sofort, dass dies Indizes sind, keine Zeiger, obwohl ich es mir manchmal erlaubt habe, so genannt zu werden.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum Indizes (Speichern von Informationen √ºber die Nummer des Warteschlangenelements) und nicht Zeiger (Speichern von Informationen √ºber die Position im Speicher des Warteschlangenelements) eine sehr schwierige Frage sind, gibt es Situationen, in denen Zeiger rentabler sind, aber dies ist eindeutig nicht unser Fall. </font><font style="vertical-align: inherit;">Unsere Warteschlangen sind kurz (selbst bei 256 sehen wir vorsichtig aus), sodass Indizes weniger Platz beanspruchen, elementare Operationen f√ºr sie schneller sind und es keine Probleme mit der Atomizit√§t von Operationen gibt (in einer normalen Architektur sollte es keine mit Zeigern geben, aber mit 8-Bit-Indizes werden nat√ºrlich nie passieren, wenn Sie keinen 4-Bit-Controller haben. Die zus√§tzlichen Kosten f√ºr den Wechsel vom Index zum Zeiger sind nicht zu hoch (vorausgesetzt, die Elemente der Warteschlange sind klein).</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Randnotizen</font></font></b> <div class="spoiler_text"> ,       51 (   )    2 (    )   3  ( ),   ,             ,      . ,   ,  GCC     x51,       AVR  . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dar√ºber hinaus sind viele Tricks, die die Geschwindigkeit zum Erhalten des n√§chsten Werts erh√∂hen, bei Verwendung des Zeigers nicht mehr verf√ºgbar. Und wenn Sie auch die Meinung ber√ºcksichtigen, dass Zeiger schwieriger zu verstehen sind (nicht, dass mir diese Meinung richtig erschien, aber existiert), dann ist die Wahl klar - Indizes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber was genau Indizes zeigen sollten - hier ist der Vorstellungsspielraum innerhalb der Gr√∂√üe des Max-Puffers (und sogar mehr als dieser) unbegrenzt, aber ein sehr kleiner Satz von Optionen hat praktische Bedeutung. F√ºr den Aufzeichnungsindex gibt es zwei M√∂glichkeiten: 1) Geben Sie den Ort an, an dem das letzte Element aufgezeichnet wurde, und 2) Geben Sie den Ort an, an dem das n√§chste Element aufgezeichnet wird. Da die erste Option unmittelbar nach dem Erstellen der Warteschlange etwas seltsam aussieht, w√§hlen wir die zweite, zumal dies uns in Zukunft einen sp√ºrbaren Gewinn verspricht. F√ºr den Leseindex nehmen wir sofort an, dass er auf das Element zeigt, das beim n√§chsten Lesen gelesen wird. Sofort gibt es ein einfaches (im Sinne der √úberpr√ºfung) Kriterium, dass die Warteschlange nicht leer ist - die Indizes sind nicht gleich. Aber das zweite Problem tritt auf - wenn wir genau Mach-Elemente in die Warteschlange stellen,dann stimmen die Indizes √ºberein und wir k√∂nnen diese Situation nicht von einer leeren Warteschlange unterscheiden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste L√∂sung f√ºr dieses Problem (‚Äûoffensichtliche, verst√§ndliche und einfache falsche L√∂sung‚Äú) wurde oft verwendet und besteht darin, einen Z√§hler f√ºr die Anzahl der im Puffer platzierten Elemente oder im fortgeschrittenen Fall das Flag der Vollst√§ndigkeit einzurichten. Warum lehne ich es ab - dies ist 1) zus√§tzlicher Speicherplatz, 2) die Zeit, die f√ºr die Arbeit damit aufgewendet wurde (sie sind klein, aber es gibt) 3) bis der Index √ºbereinstimmt, ist der Z√§hlerwert redundant, da er mit der Indexdifferenz √ºbereinstimmt, 4) Bei einer Puffergr√∂√üe von 256 Elementen sollte der Z√§hler l√§nger als die Indizes sein und darf kein nativer Typ sein. 5) Es gibt einen weiteren Nachteil (fast fatal), aber dazu sp√§ter mehr. Wie oben erw√§hnt, ist es teilweise m√∂glich, diese M√§ngel zu beheben, indem nicht ein Z√§hler, sondern eine vollst√§ndige Flagge organisiert wird, aber es gibt eine viel bessere L√∂sung.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir m√ºssen nur eine Situation vermeiden, in der die Indizes nach dem n√§chsten Datensatz zusammenfallen k√∂nnen (die Tatsache, dass sie nach dem Lesen zusammenfallen k√∂nnen, ist offensichtlich), und daf√ºr m√ºssen wir die m√∂gliche Anzahl von Elementen im Puffer auf 1 weniger als m√∂glich begrenzen. </font><font style="vertical-align: inherit;">Hier ist seine Implementierung:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NeedOverflowControl YES typedef uint8_t Data_t; static Data_t BufferData[Max]; static Counter_t BufferWriteCounter=0, BufferReadCounter=BufferWriteCounter; void BufferWrite(const data_t Data) { BufferData[BuffWriteCounter] = Data; register counter_t Tmp = NextCount(BufferWriteCounter); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (NeedOverflowControl == YES) </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (Tmp == BufferReadCounter) {BufferOverflow();} </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> { BufferWriteCounter = Tmp; } };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es gibt eine leichte Unrichtigkeit in der vorherigen Funktion, ich schlage vor, sie zu finden und selbst zu beheben, obwohl ... es immer noch gibt, aber wir werden fortfahren: </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferIsEmpty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( BufferReadCounter == BufferWriteCounter ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferIsFull</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( BufferReadCounter == NextCounter(BufferWriteCounter) ); }; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DataSizeIsSmaller (sizeof(data_t) &lt; sizeof(counter_t)) data_t BufferRead(void) { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> DataSizeIsSmaller register data_t Tmp = BufferData[BufferReadCounter]; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> register counter_t Tmp = BufferReadCounter; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> BufferReadCounter = NextCount(BufferReadCounter); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> DataSizeIsSmaller return Tmp; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> return BufferData[Tmp]; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Achten wir auf die Situation, in der wir die √úberlaufverarbeitungsprozedur aufgerufen haben (wenn wir das Flag f√ºr den Verarbeitungsbedarf gesetzt haben). Als wir versuchten, das letzte nicht belegte Byte des Puffers zu schreiben, haben wir dies nicht durch Verschieben des Schreibindex gemeldet. Wir k√∂nnen es nicht lesen - wie ich und Mit der ausgew√§hlten Implementierungsoption wird die Pufferkapazit√§t um eins reduziert. Beachten Sie auch, dass wir zuerst das n√§chste Element in die Warteschlange stellen und erst dann durch Verschieben des Index dar√ºber informieren. Die umgekehrte Reihenfolge kann zu sehr unangenehmen Konsequenzen f√ºhren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor wir uns den Code mit dem Flag ansehen, lassen Sie uns ein wenig √ºber den √úberlauf sprechen. Er tritt auf, wenn wir das n√§chste Element nicht in den Puffer einf√ºgen k√∂nnen, und wir haben verschiedene M√∂glichkeiten, das Problem zu l√∂sen, darunter gute und so weiter.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuallererst die (richtige und gute) Methode Nummer </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1), um diese Situation im Prinzip durch Auswahl der richtigen Puffergr√∂√üe zu verhindern (es gibt eine Unteroption dieser Methode - erh√∂hen Sie die Puffergr√∂√üe, falls erforderlich, aber in der Welt der eingebetteten Programmierung hat sie keine Wurzeln geschlagen, und tats√§chlich sieht es zweifelhaft aus - Mal mussten wir den Puffer vergr√∂√üern, wo es eine Garantie gibt, dass wir es nicht immer wieder tun m√ºssen). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die n√§chste Methode (richtig, aber schlechter, obwohl immer noch gut) Nummer </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2), um das Auftreten eines √úberlaufs mit einem R√ºckgabewert zu melden und das Schreiben in den Puffer anzuhalten - der sogenannte Blockierungsdatensatz, der jedoch nicht immer implementiert ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und hier sind zwei falsche und schlechte Wege:</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3) und 4) ignorieren das Problem und tun so, als w√§re alles in Ordnung (‚ÄûL√§cheln und Winken‚Äú). Warum sind sie schlecht - weil wir nur so tun, als w√§re alles in Ordnung, kann das Dirichlet-Prinzip (das Problem von N-Zellen und N + 1-V√∂geln) nicht verletzt werden und wir verlieren das Datenelement, und warum gibt es zwei M√∂glichkeiten? dass wir </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3) das zuletzt aufgezeichnete Datenelement </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verlieren </font><font style="vertical-align: inherit;">k√∂nnen und </font><font style="vertical-align: inherit;">4) das erste der noch nicht √ºbertragenen Elemente verlieren </font><font style="vertical-align: inherit;">k√∂nnen </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Welche dieser Methoden ist schlechter - ‚Äûbeide sind schlechter‚Äú, obwohl sich einige f√ºr eine bestimmte Aufgabe als akzeptabler herausstellen, aber der Hauptnachteil ist nicht zu beseitigen - wir sind gezwungen, Informationen zu verlieren. Daher wird am h√§ufigsten Methode 3 verwendet, da die Implementierung einfacher ist (hierf√ºr reicht es aus, den Datensatzindex unver√§ndert zu lassen), was ich im vorherigen Beispiel getan habe, wenn die √úberlaufverarbeitung leer ist.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt einen anderen Weg - kontrollieren Sie die Situation √ºberhaupt nicht (in unserem Beispiel kommentieren Sie die Zeile mit der Definition aus, aber nicht die Zeile mit der tats√§chlichen Pr√ºfung), w√§hrend wir </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5) den gesamten gef√ºllten Puffer verlieren - auf den ersten Blick scheint es die schlimmste zu sein, da die Verluste am gr√∂√üten sind gro√ü, in der Tat ist dies nicht ganz richtig, da jeder Datenverlust b√∂se ist, aber es hat einen klaren Vorteil - diese Methode ist schneller, da der √úberlauf √ºberhaupt nicht kontrolliert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine interessante Beobachtung: Bei einer schnellen Suche im Internet wurde kein Algorithmus f√ºr die Datenwiederherstellung bei einem Elementverlust gefunden, im Gegensatz zu einer Elementverzerrung, bei der Blockcodes einwandfrei funktionieren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Option mit dem √úberlauf-Flag verliert √ºberraschenderweise nur sehr wenig an Geschwindigkeit, wenn sie richtig geschrieben ist, verliert aber dennoch, und aus dem Speicher gewinnen wir nat√ºrlich ein Element, aber wir m√ºssen Platz f√ºr das Flag nehmen, damit die Einsparungen in Frage kommen . Wir werden die Option mit dem Z√§hler einfach nicht in Betracht ziehen, da ich bereits 4 seiner M√§ngel aufgelistet habe und es an der Zeit ist, die f√ºnfte, wie ich versprochen habe, zus√§tzlich zu der t√∂dlichen zu erinnern. In der zuvor vorgeschlagenen Implementierung haben Indizes die Eigenschaften von MRSW (Multi-Reader Single-Writer) gem√§√ü der Klassifizierung von ‚ÄûDie Kunst der Mulpiprozessor-Programmierung‚Äú (ich empfehle das Lesen, absolut erstaunliche Arbeit) und bei atomaren Operationen ist es nicht erforderlich, die Indizes (f√ºr den nativen Typ) zu √§ndern keine Mittel zur Synchronisation.Ein notwendiger und sehr wichtiger Hinweis: Die Synchronisation ist nicht nur unter dem Gesichtspunkt des Zusammenspiels von Schreiben und Lesen erforderlich, beide Funktionen sind unter diesem Gesichtspunkt in keiner Weise wiederverwendbar und unsicher, was wichtig ist, sich daran zu erinnern.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Z√§hler verf√ºgt jedoch √ºber die MRMW-Eigenschaft, und ohne Synchronisierung k√∂nnen Sie einfach nicht mit dem Wort "vollst√§ndig" arbeiten (es sei denn, Ihr Ziel ist es nat√ºrlich, ein "pl√∂tzlich fehlerhaftes" Programm zu erstellen). Wenn wir die Tatsache ber√ºcksichtigen, dass wir ein Modul f√ºr die Arbeit mit Peripherieger√§ten schreiben und dementsprechend das Schreiben oder Lesen von einem Interrupt aus aufgerufen werden kann, ist das Problem der Synchronisation unbedingt zu ber√ºcksichtigen. Interessanterweise erlaubt das Flag, das √§hnliche Eigenschaften zu haben scheint, dennoch das Arbeiten ohne Synchronisationswerkzeuge (lustig, nicht wahr, aber es hat eine vollst√§ndig wissenschaftliche Erkl√§rung - die √Ñnderungsoperation wird atomar, und die Logik des Flags erlaubt und sogar √úberschneidungen Datens√§tze), was durch das folgende Fragment des Programms veranschaulicht wird.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitte beachten Sie, dass ein solcher Ansatz (ein Flag ohne Synchronisationstools) nur m√∂glich ist, wenn bestimmte Bedingungen erf√ºllt sind, die in Ihrem Fall sorgf√§ltig gepr√ºft werden sollten. Details finden sich in der Literatur, ich werde sie nicht geben, weil ich diese Methode zur Organisation des Puffers f√ºr nicht allzu gut halte, und ich zitiere sie nur, um zu zeigen, dass nicht die erfolgreichste L√∂sung ordentlich implementiert werden kann, und um ein anderes Konzept zu demonstrieren, das ich in Betracht ziehe sehr n√ºtzlich und an die ich mich halten m√∂chte.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data_t</span></span> BufferData[Max]; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">counter_t</span></span> BufferWriteCounter=<span class="hljs-number"><span class="hljs-number">0</span></span>, BufferReadCounter=WriteCounter; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> BufferHaveData = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferWrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((BufferWriteCounter == BufferReadCounter) &amp;&amp; (BufferHaveDataFlag == <span class="hljs-number"><span class="hljs-number">1</span></span>)) {BufferOverflow();} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { BufferData[BufferWriteCounter] = Data; BufferHaveDataFlag = <span class="hljs-number"><span class="hljs-number">1</span></span>; BufferWriteCounter = NextCounter(BufferWriteCounter); }; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferIsEmpty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((BufferReadCounter==BufferWriteCounter) &amp;&amp; (BufferHaveDataFlag == <span class="hljs-number"><span class="hljs-number">0</span></span>));}; <span class="hljs-keyword"><span class="hljs-keyword">data_t</span></span> BufferRead(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">counter_t</span></span> Tmp; Tmp = BufferReadCounter; BufferReadCounter = NextCount(BufferReadCounter); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (BufferReadCount == BufferWriteCounter) { BufferHaveDataFlag = <span class="hljs-number"><span class="hljs-number">1</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BufferData[Tmp]; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie erneut, dass wir beim Schreiben zuerst das Flag setzen und dann den Index √§ndern und beim Lesen zuerst die Indizes √ºberpr√ºfen und dann das Flag steuern, was uns wiederum vor Problemen bewahrt und etwas mit dem Umgang mit Ressourcen gemeinsam hat, um das gegenseitige Blockieren zu beseitigen . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Allgemeinen sollte dieses Fragment im richtigen Stil umgeschrieben werden (mit Ausnahme der magischen Konstanten 0 und 1, wenn Sie denken, dass dies keine magischen Konstanten sind, dann irren Sie sich), und wenn Sie es verwenden, dann tun Sie es, ich verstecke das korrigierte Code im Spoiler, nicht weil es mir peinlich ist, aber um keine weitere Runde des Heiligen Krieges (bedeutungslos und gnadenlos), Hasser von Transfers, anzuregen, sollten Sie diesen Button nicht √∂ffnen,</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Rest - du kannst</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> (NoBufferHaveData= <span class="hljs-number"><span class="hljs-number">0</span></span>, BufferHaveData =<span class="hljs-number"><span class="hljs-number">1</span></span>) BufferHave DataFlag_t; BufferHaveData_t BufferYaveDataFlag; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferHaveDataFlagSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{BufferHaveDataFlag = NoBufferHaveData;}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferHaveDataFlagClr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{BufferHaveDataFlag = BufferHaveData;}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferHaveDataFlagIsSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(BufferHaveDataFlag == BufferHaveData);};</code> </pre> <br></div></div><br>  ,        ,      0  1,             . ,     ,        ,        0  1.   , ,    ,      ,    BufferFullFlag      ,          BufferIsNotEmptyFlag         .   ,  KISS      ,   ,   ,        ,    , ¬´   ¬ª. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf jeden Fall denke ich nicht, dass die Implementierung mit dem Flag gut ist. Ich empfehle daher dringend, sich mit dem Puffer abzustimmen, der nicht vollst√§ndig verwendet wird, und die Implementierung mit zwei Indizes und ohne zus√§tzliche Felder zu akzeptieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigentlich stellte sich ein unerwartet umfangreicher Beitrag f√ºr ein so einfaches Thema heraus, dass ich dar√ºber nachdachte, mehr √ºber Synchronisation und kritische Abschnitte zu schreiben, aber dies ist das n√§chste Mal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS Und abschlie√üend, was genau hat mir in der genannten Bibliothek nicht gefallen, aber gleichzeitig haben die Autoren des inl√§ndischen RTOS dies ohne den geringsten Zweifel in ihren Code aufgenommen:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es werden zwei Implementierungen des Puffers angegeben - eine f√ºr die Gr√∂√üe der Zweierpotenz (ich hoffe, ich habe gezeigt, dass dies v√∂llig unn√∂tig ist) und die zweite f√ºr die verbleibenden F√§lle, aber Sie m√ºssen die Version mit Stiften ausw√§hlen, nat√ºrlich machen sie keinen Fehler, es gibt √ºberall √úberpr√ºfungen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es wurden v√∂llig unn√∂tige Methoden durchgef√ºhrt, wie das L√∂schen des letzten Elements oder der direkte Zugriff aus dem Pufferelement. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Datenpuffer ist auf eine Ganzzahl ausgerichtet. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bei der Umsetzung von Grad 2 ein Fehler bei der √úberpr√ºfung der Belegungsrate. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bei der Implementierung einer beliebigen Gr√∂√üe wird ein Z√§hler verwendet </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kritische Abschnitte sind √ºberhaupt nicht organisiert, was in der richtigen Implementierung (mit zwei Indizes) einfach nicht ben√∂tigt wird, aber man kann nicht ohne sie auskommen, die Verwendung von atomaren Operationen ist eindeutig nicht ausreichend. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einige Stil Nachl√§ssigkeit, Art von Linien </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((_writeCount - Atomic::Fetch(&amp;_readCount)) &amp; (size_type)~(_mask)) != <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vor allem die zweite H√§lfte - genau daf√ºr wird C verantwortlich gemacht, und die Sprache selbst ist nicht schuld, sie erlaubt Ihnen nur, dies zu schreiben, anstatt die verst√§ndlicheren </font></font><br><br><pre> <code class="cpp hljs">size_type(~(_mask))</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aber nicht zwingen, es zu tun. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PPS Ich hoffe, der Autor der Bibliothek erkl√§rt sich damit einverstanden, diese Kritik als konstruktiv zu betrachten und entsprechende Korrekturen vorzunehmen. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438476/">https://habr.com/ru/post/de438476/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438466/index.html">Kr√ºcke f√ºr einen chinesischen Laser</a></li>
<li><a href="../de438468/index.html">Kolonie. Kapitel 23: Probefahrt</a></li>
<li><a href="../de438470/index.html">Weltweiter Umsatz im Dezember und 2018: 2 Millionen verkaufte Plug-in-Elektrofahrzeuge</a></li>
<li><a href="../de438472/index.html">Anspruchsvolle modulare Architekturumgebung in UE4</a></li>
<li><a href="../de438474/index.html">Kurier: Dropbox-Migration zu gRPC</a></li>
<li><a href="../de438478/index.html">GitLab 11.7 wurde mit Releases, mehrstufigen verschachtelten Epen und der Registrierung von NPM-Paketen ver√∂ffentlicht</a></li>
<li><a href="../de438480/index.html">Platzieren Sie es richtig: 7 ideale Orte zum Platzieren von Videoinhalten</a></li>
<li><a href="../de438482/index.html">Reputation, Arbeit und Auswanderung: Verwendung von Tools zur Unternehmensf√∂rderung zur L√∂sung pers√∂nlicher Probleme</a></li>
<li><a href="../de438486/index.html">Undurchdringliche Speicherkarte - Kingston microSD High Endurance ertrinken, einfrieren und in Brand setzen</a></li>
<li><a href="../de438490/index.html">Beta-Version von Unity 2019.1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>