<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🏫 🦐 🚍 Lerne OpenGL. Lektion 7.1 - Debuggen 🖼️ 😼 👩🏻‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Grafische Programmierung ist nicht nur eine Quelle des Spaßes, sondern auch der Frustration, wenn etwas nicht wie beabsichtigt angezeigt wird oder übe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lerne OpenGL. Lektion 7.1 - Debuggen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462897/"><p><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="Bild" align="left" width="300">  Grafische Programmierung ist nicht nur eine Quelle des Spaßes, sondern auch der Frustration, wenn etwas nicht wie beabsichtigt angezeigt wird oder überhaupt nichts auf dem Bildschirm angezeigt wird.  Angesichts der Tatsache, dass das meiste, was wir tun, mit der Manipulation von Pixeln zusammenhängt, kann es schwierig sein, die Ursache des Fehlers herauszufinden, wenn etwas nicht so funktioniert, wie es sollte.  Das Debuggen dieser Art von Fehler ist schwieriger als das Debuggen von Fehlern auf der CPU.  Wir haben keine Konsole, auf der wir den Text ausgeben können, wir können keinen Haltepunkt in den Shader setzen und wir können nicht einfach den Status des Programms auf der GPU übernehmen und überprüfen. </p><br><p>  In diesem Tutorial werden wir Ihnen einige der Debugging-Methoden und -Techniken für Ihr OpenGL-Programm vorstellen.  Das Debuggen in OpenGL ist nicht so schwierig, und das Erlernen einiger Tricks wird sich definitiv auszahlen. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Inhalt</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">Teil 1. Erste Schritte</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fenstererstellung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hallo Fenster</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hallo Dreieck</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Texturen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Transformationen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Koordinatensysteme</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kamera</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Teil 2. Grundbeleuchtung</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Farben</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grundlagen der Beleuchtung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Material</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Texturkarten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lichtquellen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mehrere Lichtquellen</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Teil 3. Laden Sie 3D-Modelle herunter</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Assimp-Bibliothek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mesh-Polygon-Klasse</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3D-Modellklasse</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Teil 4. Erweiterte OpenGL-Funktionen</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tiefentest</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schablonentest</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Farbmischung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gesichter schneiden</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bildpuffer</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubische Karten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterte Datenverarbeitung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterte GLSL</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geometrischer Shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Instanz</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Glätten</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Teil 5. Erweiterte Beleuchtung</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterte Beleuchtung.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blinn Fong Modell</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gammakorrektur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schattenkarten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Omnidirektionale Schattenkarten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Normale Zuordnung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Parallaxenabbildung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HDR</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blüte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgeschobenes Rendern</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SSAO</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Teil 6. Züchterrechte</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Theorie</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Analytische Lichtquellen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diffuse Bestrahlung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spiegelexposition</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Teil 7. Übung</b> <div class="spoiler_text"><ol><li>  <b>Debuggen</b> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Textwiedergabe</a> </li></ol></div></div></div></div><br><h1 id="glgeterror">  glGetError () </h1><br><p> Wenn Sie OpenGL falsch verwenden (z. B. wenn Sie einen Puffer einrichten und vergessen, ihn zu binden), bemerkt OpenGL hinter den Kulissen ein oder mehrere benutzerdefinierte Fehlerflags und erstellt diese.  Wir können diese Fehler verfolgen, indem <code>glGetError()</code> Funktion <code>glGetError()</code> aufrufen, die einfach die gesetzten <code>glGetError()</code> überprüft und den Fehlerwert zurückgibt, wenn Fehler auftreten. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">GLenum </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glGetError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><p>  Diese Funktion gibt ein Fehlerflag oder gar keinen Fehler zurück.  Liste der Rückgabewerte: </p><br><div class="scrollable-table"><table><thead><tr><th>  Flagge </th><th>  Code </th><th>  Beschreibung </th></tr></thead><tbody><tr><td> <code>GL_NO_ERROR</code> </td> <td>  0 </td><td>  Seit dem letzten Aufruf von glGetError wurde kein Fehler generiert </td></tr><tr><td> <code>GL_INVALID_ENUM</code> </td> <td>  1280 </td><td>  Wird festgelegt, wenn ein Aufzählungsparameter ungültig ist </td></tr><tr><td> <code>GL_INVALID_VALUE</code> </td> <td>  1281 </td><td>  Wird festgelegt, wenn der Wert ungültig ist </td></tr><tr><td> <code>GL_INVALID_OPERATION</code> </td> <td>  1282 </td><td>  Wird festgelegt, wenn ein Befehl mit angegebenen Parametern ungültig ist </td></tr><tr><td> <code>GL_STACK_OVERFLOW</code> </td> <td>  1283 </td><td>  Es wird festgelegt, wenn das Verschieben von Daten auf den Stapel (Push) einen Stapelüberlauf verursacht. </td></tr><tr><td> <code>GL_STACK_UNDERFLOW</code> </td> <td>  1284 </td><td>  Es wird festgelegt, wenn die Operation zum Poppen von Daten vom Stapel (Pop) vom kleinsten Punkt auf dem Stapel aus erfolgt. </td></tr><tr><td> <code>GL_OUT_OF_MEMORY</code> </td> <td>  1285 </td><td>  Wird festgelegt, wenn eine Speicherzuweisungsoperation nicht genügend Speicher zuweisen kann. </td></tr><tr><td> <code>GL_INVALID_FRAMEBUFFER_OPERATION</code> </td> <td>  1286 </td><td>  Wird beim Lesen / Schreiben in / aus einem Framebuffer festgelegt, der nicht abgeschlossen ist </td></tr></tbody></table></div><br><p>  In der Dokumentation zu OpenGL-Funktionen finden Sie Fehlercodes, die von falsch verwendeten Funktionen generiert werden.  Wenn Sie sich beispielsweise die Dokumentation zur Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>glBindTexture()</code></a> , finden Sie die von dieser Funktion generierten Fehlercodes im Abschnitt Fehler. <br>  Wenn das Fehlerflag gesetzt ist, werden keine weiteren Fehlerflags generiert.  Wenn <code>glGetError</code> aufgerufen wird, löscht die Funktion außerdem alle <code>glGetError</code> (oder nur eines auf einem verteilten System, siehe unten).  Dies bedeutet, dass wenn Sie <code>glGetError</code> nach jedem Frame einmal aufrufen und einen Fehler erhalten, dies nicht bedeutet, dass dies der einzige Fehler ist und Sie immer noch nicht wissen, wo dieser Fehler aufgetreten ist. </p><br><blockquote>  Beachten Sie, dass, wenn OpenGL auf verteilte Weise arbeitet, wie dies häufig bei Systemen mit X11 der Fall ist, andere Fehler generiert werden können, wenn sie unterschiedliche Codes haben.  <code>glGetError</code> Sie <code>glGetError</code> wird einfach nur eines der Fehlercode-Flags anstelle von allen <code>glGetError</code> .  Aus diesem Grund empfehlen sie, diese Funktion in einer Schleife aufzurufen. </blockquote><br><pre> <code class="cpp hljs">glBindTexture(GL_TEXTURE_2D, tex); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; glGetError() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  0 ( ) glTexImage2D(GL_TEXTURE_3D, 0, GL_RGB, 512, 512, 0, GL_RGB, GL_UNSIGNED_BYTE, data); std::cout &lt;&lt; glGetError() &lt;&lt; std::endl; //  1280 ( ) glGenTextures(-5, textures); std::cout &lt;&lt; glGetError() &lt;&lt; std::endl; //  1281 (  std::cout &lt;&lt; glGetError() &lt;&lt; std::endl; //  0 ( )</span></span></code> </pre> <br><p>  Eine Besonderheit von <code>glGetError</code> besteht darin, dass es relativ einfach ist, festzustellen, wo Fehler auftreten können, und zu überprüfen, ob OpenGL korrekt verwendet wird.  Angenommen, Sie zeichnen nichts und wissen nicht, was der Grund ist: Der Frame-Puffer ist falsch eingestellt?  Vergessen, die Textur einzustellen?  Wenn Sie <code>glGetError</code> überall aufrufen, können Sie schnell herausfinden, wo der erste Fehler auftritt. <br>  Standardmäßig meldet <code>glGetError</code> nur die Fehlernummer, die erst dann leicht zu verstehen ist, wenn Sie sich die Codenummern merken.  Oft ist es sinnvoll, eine kleine Funktion zu schreiben, um eine Fehlerzeichenfolge zusammen mit der Position zu drucken, von der aus die Funktion aufgerufen wird. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">GLenum </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glCheckError_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> line)</span></span></span><span class="hljs-function"> </span></span>{ GLenum errorCode; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((errorCode = glGetError()) != GL_NO_ERROR) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> error; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (errorCode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_INVALID_ENUM: error = <span class="hljs-string"><span class="hljs-string">"INVALID_ENUM"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_INVALID_VALUE: error = <span class="hljs-string"><span class="hljs-string">"INVALID_VALUE"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_INVALID_OPERATION: error = <span class="hljs-string"><span class="hljs-string">"INVALID_OPERATION"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_STACK_OVERFLOW: error = <span class="hljs-string"><span class="hljs-string">"STACK_OVERFLOW"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_STACK_UNDERFLOW: error = <span class="hljs-string"><span class="hljs-string">"STACK_UNDERFLOW"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_OUT_OF_MEMORY: error = <span class="hljs-string"><span class="hljs-string">"OUT_OF_MEMORY"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_INVALID_FRAMEBUFFER_OPERATION: error = <span class="hljs-string"><span class="hljs-string">"INVALID_FRAMEBUFFER_OPERATION"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; error &lt;&lt; <span class="hljs-string"><span class="hljs-string">" | "</span></span> &lt;&lt; file &lt;&lt; <span class="hljs-string"><span class="hljs-string">" ("</span></span> &lt;&lt; line &lt;&lt; <span class="hljs-string"><span class="hljs-string">")"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorCode; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> glCheckError() glCheckError_(__FILE__, __LINE__)</span></span></code> </pre> <br><p>  Wenn Sie weitere Aufrufe von <code>glCheckError</code> tätigen <code>glCheckError</code> , ist es hilfreich zu wissen, wo der Fehler aufgetreten ist. </p><br><pre> <code class="cpp hljs">glBindBuffer(GL_VERTEX_ARRAY, vbo); glCheckError();</code> </pre> <br><p>  Fazit: </p><br><p><img src="https://habrastorage.org/webt/3h/yo/dn/3hyodngllw6-koljhvkkee3_lzi.png"><br>  Eine wichtige Sache bleibt: Es gibt einen langjährigen Fehler in GLEW: <code>glewInit()</code> setzt immer das Flag <code>GL_INVALID_ENUM</code> .  Um dies zu beheben, rufen <code>glGetError</code> einfach <code>glGetError</code> nach <code>glewInit</code> auf, um das Flag zu löschen: </p><br><pre> <code class="cpp hljs">glewInit(); glGetError();</code> </pre> <br><p>  <code>glGetError</code> hilft nicht viel, da die zurückgegebenen Informationen relativ einfach sind, aber es hilft oft, Tippfehler zu erkennen oder die Stelle zu ermitteln, an der der Fehler aufgetreten ist.  Dies ist ein einfaches, aber effektives Debugging-Tool. </p><br><h1 id="otladochnyy-vyvod">  Debug-Ausgabe </h1><br><p>  Das Tool ist weniger bekannt, aber nützlicher als <code>glCheckError</code> , die OpenGL-Erweiterung "Debug-Ausgabe", die im OpenGL 4.3- <code>glCheckError</code> enthalten war.  Mit dieser Erweiterung sendet OpenGL eine Fehlermeldung mit den Details des Fehlers an den Benutzer.  Diese Erweiterung bietet nicht nur weitere Informationen, sondern ermöglicht es Ihnen auch, Fehler mit dem Debugger abzufangen, wo sie auftreten. </p><br><blockquote>  Die Debug-Ausgabe ist in OpenGL ab Version 4.3 enthalten. Dies bedeutet, dass Sie diese Funktionalität auf jedem Computer finden, der OpenGL 4.3 und höher unterstützt.  Wenn diese Version nicht verfügbar ist, können Sie die Erweiterungen <code>ARB_debug_output</code> und <code>AMD_debug_output</code> .  Es gibt auch nicht überprüfte Informationen darüber, dass die Debugging-Ausgabe unter OS X nicht unterstützt wird (der Autor des Originals und der Übersetzer haben nicht getestet. Bitte informieren Sie den Autor des Originals oder mich in privaten Nachrichten über den Fehlerkorrekturmechanismus, wenn Sie eine Bestätigung oder Widerlegung dieser Tatsache finden. <strong>UPD:</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Jeka178RUS</a> hat dies überprüft Tatsache: Standardmäßig funktioniert die Debug-Ausgabe nicht, er hat die Erweiterungen nicht überprüft. </blockquote><p>  Um die Debug-Ausgabe verwenden zu können, müssen wir während des Initialisierungsprozesses den OpenGL-Debug-Kontext anfordern.  Dieser Prozess ist auf verschiedenen Fenstersystemen unterschiedlich, aber hier werden wir nur GLFW diskutieren, aber am Ende des Artikels im Abschnitt "Zusätzliche Materialien" finden Sie Informationen zu anderen Fenstersystemen. </p><br><h4 id="otladochnyy-vyvod-v-glfw">  Debug-Ausgabe in GLFW </h4><br><p>  Das Anfordern von Debugging-Kontexten in GLFW ist überraschend einfach: Sie müssen GLFW lediglich einen Hinweis geben, dass wir einen Kontext wünschen, der die Debugging-Ausgabe unterstützt.  Wir müssen dies tun, bevor <code>glfwCreateWindow</code> aufrufen: </p><br><pre> <code class="cpp hljs">glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GL_TRUE);</code> </pre> <br><p>  Sobald wir GLFW initialisiert haben, sollten wir einen Debugging-Kontext haben, wenn wir OpenGL 4.3 oder höher verwenden. Andernfalls müssen wir unser Glück versuchen und hoffen, dass das System weiterhin einen Debugging-Kontext erstellen kann.  Im Fehlerfall müssen wir die Debug-Ausgabe über den OpenGL-Erweiterungsmechanismus anfordern. </p><br><blockquote>  Der OpenGL-Debugging-Kontext kann langsamer als normal sein. Sie sollten diese Zeile daher entfernen oder auskommentieren, während Sie an Optimierungen arbeiten oder vor der Veröffentlichung. </blockquote><p>  Um das Ergebnis der Initialisierung des Debug-Kontexts zu überprüfen, reicht es aus, den folgenden Code auszuführen: </p><br><pre> <code class="cpp hljs">GLint flags; glGetIntegerv(GL_CONTEXT_FLAGS, &amp;flags); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flags &amp; GL_CONTEXT_FLAG_DEBUG_BIT) { <span class="hljs-comment"><span class="hljs-comment">//  } else { //   }</span></span></code> </pre> <br><p>  Wie funktioniert die Debug-Ausgabe?  Wir übergeben eine Rückruffunktion an einen Nachrichtenhandler in OpenGL (ähnlich wie Rückrufe in GLFW) und können in dieser Funktion OpenGL-Daten nach Belieben verarbeiten und in unserem Fall nützliche Fehlermeldungen an die Konsole senden.  Der Prototyp dieser Funktion: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> APIENTRY </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glDebugOutput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GLchar *message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *userParam)</span></span></span></span>;</code> </pre> <br><p>  Beachten Sie, dass unter einigen Betriebssystemen der Typ des letzten Parameters möglicherweise <code>const void*</code> . <br>  Angesichts des großen Datensatzes können wir ein nützliches Fehlerdruckwerkzeug erstellen, wie unten gezeigt: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> APIENTRY </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glDebugOutput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GLchar *message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *userParam)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ignore non-significant error/warning codes if(id == 131169 || id == 131185 || id == 131218 || id == 131204) return; std::cout &lt;&lt; "---------------" &lt;&lt; std::endl; std::cout &lt;&lt; "Debug message (" &lt;&lt; id &lt;&lt; "): " &lt;&lt; message &lt;&lt; std::endl; switch (source) { case GL_DEBUG_SOURCE_API: std::cout &lt;&lt; "Source: API"; break; case GL_DEBUG_SOURCE_WINDOW_SYSTEM: std::cout &lt;&lt; "Source: Window System"; break; case GL_DEBUG_SOURCE_SHADER_COMPILER: std::cout &lt;&lt; "Source: Shader Compiler"; break; case GL_DEBUG_SOURCE_THIRD_PARTY: std::cout &lt;&lt; "Source: Third Party"; break; case GL_DEBUG_SOURCE_APPLICATION: std::cout &lt;&lt; "Source: Application"; break; case GL_DEBUG_SOURCE_OTHER: std::cout &lt;&lt; "Source: Other"; break; } std::cout &lt;&lt; std::endl; switch (type) { case GL_DEBUG_TYPE_ERROR: std::cout &lt;&lt; "Type: Error"; break; case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: std::cout &lt;&lt; "Type: Deprecated Behaviour"; break; case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: std::cout &lt;&lt; "Type: Undefined Behaviour"; break; case GL_DEBUG_TYPE_PORTABILITY: std::cout &lt;&lt; "Type: Portability"; break; case GL_DEBUG_TYPE_PERFORMANCE: std::cout &lt;&lt; "Type: Performance"; break; case GL_DEBUG_TYPE_MARKER: std::cout &lt;&lt; "Type: Marker"; break; case GL_DEBUG_TYPE_PUSH_GROUP: std::cout &lt;&lt; "Type: Push Group"; break; case GL_DEBUG_TYPE_POP_GROUP: std::cout &lt;&lt; "Type: Pop Group"; break; case GL_DEBUG_TYPE_OTHER: std::cout &lt;&lt; "Type: Other"; break; } std::cout &lt;&lt; std::endl; switch (severity) { case GL_DEBUG_SEVERITY_HIGH: std::cout &lt;&lt; "Severity: high"; break; case GL_DEBUG_SEVERITY_MEDIUM: std::cout &lt;&lt; "Severity: medium"; break; case GL_DEBUG_SEVERITY_LOW: std::cout &lt;&lt; "Severity: low"; break; case GL_DEBUG_SEVERITY_NOTIFICATION: std::cout &lt;&lt; "Severity: notification"; break; } std::cout &lt;&lt; std::endl; std::cout &lt;&lt; std::endl; }</span></span></code> </pre> <br><p>  Wenn die Erweiterung einen OpenGL-Fehler erkennt, ruft sie diese Funktion auf und wir können eine große Menge an Fehlerinformationen drucken.  Beachten Sie, dass wir einige Fehler ignoriert haben, da sie unbrauchbar sind (z. B. 131185 in den NVidia-Treibern zeigt an, dass der Puffer erfolgreich erstellt wurde). <br>  Nachdem wir den gewünschten Rückruf erhalten haben, ist es Zeit, die Debug-Ausgabe zu initialisieren: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flags &amp; GL_CONTEXT_FLAG_DEBUG_BIT) { glEnable(GL_DEBUG_OUTPUT); glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS); glDebugMessageCallback(glDebugOutput, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, GL_TRUE); }</code> </pre> <br><p>  Deshalb teilen wir OpenGL mit, dass wir die Debug-Ausgabe aktivieren möchten.  Der Aufruf von <code>glEnable(GL_DEBUG_SYNCRHONOUS)</code> teilt OpenGL mit, dass eine Fehlermeldung <code>glEnable(GL_DEBUG_SYNCRHONOUS)</code> werden soll, wenn dies gerade passiert ist. </p><br><h4 id="filtraciya-otladochnogo-vyvoda">  Debug-Ausgabefilterung </h4><br><p>  Mit der Funktion <code>glDebugMessageControl</code> können Sie die Arten von Fehlern auswählen, die Sie erhalten möchten.  In unserem Fall erhalten wir alle Arten von Fehlern.  Wenn wir nur die OpenGL-API-Fehler wie Fehler und das Signifikanzniveau Hoch haben wollten, würden wir den folgenden Code schreiben: </p><br><pre> <code class="cpp hljs">glDebugMessageControl(GL_DEBUG_SOURCE_API, GL_DEBUG_TYPE_ERROR, GL_DEBUG_SEVERITY_HIGH, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, GL_TRUE);</code> </pre> <br><p>  In diesem Konfigurations- und Debugging-Kontext sendet jeder falsche OpenGL-Befehl viele nützliche Informationen: </p><br><p><img src="https://habrastorage.org/webt/4r/su/ir/4rsuirzossc_jpcoldwi-t4s0ny.png"></p><br><h4 id="nahodim-istochnik-oshibki-cherez-stek-vyzovov">  Suchen Sie die Fehlerquelle über den Aufrufstapel </h4><br><p>  Ein weiterer Trick beim Debuggen der Ausgabe besteht darin, dass Sie den genauen Ort des Fehlers in Ihrem Code relativ einfach ermitteln können.  Durch Festlegen eines Haltepunkts in der <code>DebugOutput</code> Funktion für den gewünschten Fehlertyp (oder am Anfang der Funktion, wenn Sie alle Fehler abfangen möchten) erkennt der Debugger den Fehler und Sie können im Aufrufstapel navigieren, um herauszufinden, wo der Fehler aufgetreten ist: </p><br><p><img src="https://habrastorage.org/webt/fw/sm/0s/fwsm0sr9tzjyl36kg0maj_rthz0.png"><br>  Dies erfordert einige manuelle Eingriffe. Wenn Sie jedoch ungefähr wissen, wonach Sie suchen, ist es unglaublich nützlich, schnell festzustellen, welcher Anruf den Fehler verursacht. </p><br><h4 id="svoi-oshibki">  Eigene Fehler </h4><br><p>  Zusammen mit Lesefehlern können wir sie mit <code>glDebugMessageInsert</code> an das Debug-Ausgabesystem <code>glDebugMessageInsert</code> : </p><br><pre> <code class="cpp hljs">glDebugMessageInsert(GL_DEBUG_SOURCE_APPLICATION, GL_DEBUG_TYPE_ERROR, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_DEBUG_SEVERITY_MEDIUM, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-string"><span class="hljs-string">"error message here"</span></span>);</code> </pre> <br><p>  Dies ist sehr nützlich, wenn Sie eine Verbindung zu einer anderen Anwendung oder einem anderen OpenGL-Code herstellen, der einen Debugging-Kontext verwendet.  Andere Entwickler können schnell alle gemeldeten Fehler in Ihrem benutzerdefinierten OpenGL-Code herausfinden. <br>  Im Allgemeinen ist das Debuggen der Ausgabe (falls verfügbar) sehr nützlich, um Fehler schnell zu erkennen, und es lohnt sich auf jeden Fall, sich für die Optimierung einzusetzen, da dies erhebliche Entwicklungszeit spart.  Eine Kopie des Quellcodes finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> mit <code>glGetError</code> und Debug-Ausgabe.  Es gibt Fehler, versuchen Sie sie zu beheben. </p><br><h1 id="otladochnyy-vyvod-sheydera">  Shader-Debug-Ausgabe </h1><br><p>  Wenn es um GLSL geht, haben wir keinen Zugriff auf Funktionen wie <code>glGetError</code> oder die Möglichkeit, den Code <code>glGetError</code> im Debugger <code>glGetError</code> .  Wenn Sie auf einen schwarzen Bildschirm oder eine völlig falsche Anzeige stoßen, kann es sehr schwierig sein zu verstehen, was passiert, wenn das Problem im Shader liegt.  Ja, Kompilierungsfehler melden Syntaxfehler, aber das Abfangen semantischer Fehler ist dieses Lied. <br>  Eine der häufig verwendeten Methoden, um herauszufinden, was mit einem Shader nicht stimmt, besteht darin, alle relevanten Variablen im Shader-Programm direkt an den Ausgabekanal des Fragment-Shaders zu senden.  Indem wir Shader-Variablen mit Farbe direkt auf den Ausgabekanal ausgeben, können wir interessante Informationen herausfinden, indem wir das Bild am Ausgang überprüfen.  Zum Beispiel müssen wir herausfinden, ob die Normalen für das Modell korrekt sind.  Wir können sie (transformiert oder nicht) vom Scheitelpunkt an den Fragment-Shader senden, wo wir die Normalen wie folgt ableiten: <br>  (Hinweis: Warum gibt es keine Syntaxhervorhebung für GLSL?) </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; in vec3 Normal; [...] void main() { [...] FragColor.rgb = Normal; FragColor.a = 1.0f; }</span></span></code> </pre> <br><p>  Durch die Ausgabe einer nicht farbigen Variablen an den Ausgabekanal mit der aktuellen Farbe können wir den Wert der Variablen schnell überprüfen.  Wenn das Ergebnis beispielsweise ein schwarzer Bildschirm ist, ist es klar, dass die Normalen falsch auf die Shader übertragen werden, und wenn sie angezeigt werden, ist es relativ einfach, sie auf Richtigkeit zu überprüfen: </p><br><p><img src="https://habrastorage.org/webt/ga/5c/eq/ga5ceqfkwfcszqm75y6szggge-e.png"></p><br><p>  Aus den visuellen Ergebnissen können wir erkennen, dass die Normalen korrekt sind, da die rechte Seite des Anzugs überwiegend rot ist (was bedeutet, dass die Normalen ungefähr in Richtung der x-Spülachse angezeigt werden) und auch die Vorderseite des Anzugs in Richtung der positiven z-Achse (blau) gefärbt ist. </p><br><p>  Dieser Ansatz kann auf jede Variable erweitert werden, die Sie testen möchten.  Versuchen Sie jedes Mal, wenn Sie nicht weiterkommen und davon ausgehen, dass der Fehler in den Shadern liegt, einige Variablen oder Zwischenergebnisse zu zeichnen und herauszufinden, in welchem ​​Teil des Algorithmus ein Fehler vorliegt. </p><br><h1 id="opengl-glsl-reference-compiler">  OpenGL GLSL Referenzcompiler </h1><br><p>  Jeder Grafiktreiber hat seine eigenen Macken.  Zum Beispiel machen NVIDIA-Treiber die Anforderungen der Spezifikation etwas weicher, und AMD-Treiber erfüllen die Spezifikationen besser (was meiner Meinung nach besser ist).  Das Problem ist, dass Shader, die auf einem Computer ausgeführt werden, aufgrund unterschiedlicher Treiber möglicherweise kein Geld auf einem anderen Computer verdienen. </p><br><p>  Nach mehrjähriger Erfahrung können Sie alle Unterschiede zwischen verschiedenen GPUs kennenlernen. Wenn Sie jedoch sicherstellen möchten, dass Ihre Shader überall funktionieren, können Sie Ihren Code mithilfe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GLSL-Referenz-Compilers</a> anhand der offiziellen Spezifikation überprüfen.  Den sogenannten <em>GLSL lang validator können Sie</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> herunterladen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a> ). </p><br><p>  Mit diesem Programm können Sie Ihre Shader testen, indem Sie sie als erstes Argument an das Programm übergeben.  Denken Sie daran, dass das Programm den Shadertyp durch Erweiterung bestimmt: </p><br><ul><li>  <code>.vert</code> : Vertex-Shader </li><li>  <code>.frag</code> : Fragment-Shader </li><li>  <code>.geom</code> : geometrischer Shader </li><li>  <code>.tesc</code> : Shader zur Steuerung der Tessellation </li><li>  <code>.tese</code> : Tessellation Computing Shader </li><li>  <code>.comp</code> : Compute Shader </li></ul><br><p>  Das Programm auszuführen ist einfach: </p><br><pre> <code class="bash hljs">glslangValidator shader.vert</code> </pre> <br><p>  Beachten Sie, dass das Programm nichts ausgibt, wenn keine Fehler vorliegen.  Bei einem fehlerhaften Vertex-Shader sieht die Ausgabe folgendermaßen aus: </p><br><p><img src="https://habrastorage.org/webt/-l/x-/yi/-lx-yijcoqk4ehnnc5xentnjl5m.png"></p><br><p>  Das Programm zeigt nicht die Unterschiede zwischen den GLSL-Compilern von AMD, NVidia oder Intel an und kann nicht einmal alle Fehler im Shader melden, überprüft jedoch zumindest die Shader auf Übereinstimmung mit den Standards. </p><br><h1 id="vyvod-bufera-kadra">  Bildpufferausgabe </h1><br><p>  Eine andere Methode für Ihr Toolkit besteht darin, den Inhalt des Bildpuffers in einem bestimmten Teil des Bildschirms anzuzeigen.  Höchstwahrscheinlich verwenden Sie häufig Framebuffer, und da die ganze Magie hinter den Kulissen geschieht, kann es schwierig sein, festzustellen, was passiert.  Die Ausgabe des Inhalts des Bildpuffers ist ein nützlicher Trick, um die Richtigkeit zu überprüfen. </p><br><blockquote>  Beachten Sie, dass der Inhalt des Bildpuffers, wie hier erläutert, mit Texturen und nicht mit Objekten in den Zeichenpuffern funktioniert </blockquote><p>  Mit einem einfachen Shader, der eine einzelne Textur zeichnet, können wir eine kleine Funktion schreiben, die schnell jede Textur in der oberen rechten Ecke des Bildschirms zeichnet: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// vertex shader #version 330 core layout (location = 0) in vec2 position; layout (location = 1) in vec2 texCoords; out vec2 TexCoords; void main() { gl_Position = vec4(position, 0.0f, 1.0f); TexCoords = texCoords; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//fragment shader #version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D fboAttachment; void main() { FragColor = texture(fboAttachment, TexCoords); }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//main.cpp void DisplayFramebufferTexture(GLuint textureID) { if(!notInitialized) { // initialize shader and vao w/ NDC vertex coordinates at top-right of the screen [...] } glActiveTexture(GL_TEXTURE0); glUseProgram(shaderDisplayFBOOutput); glBindTexture(GL_TEXTURE_2D, textureID); glBindVertexArray(vaoDebugTexturedRect); glDrawArrays(GL_TRIANGLES, 0, 6); glBindVertexArray(0); glUseProgram(0); } int main() { [...] while (!glfwWindowShouldClose(window)) { [...] DisplayFramebufferTexture(fboAttachment0); glfwSwapBuffers(window); } }</span></span></code> </pre> <br><p>  Dadurch erhalten Sie in der Ecke des Bildschirms ein kleines Fenster zum Debuggen der Ausgabe des Bildpuffers.  Dies ist beispielsweise nützlich, wenn Sie versuchen, die Richtigkeit von Normalen zu überprüfen: </p><br><p><img src="https://habrastorage.org/webt/zi/uw/ap/ziuwapmnertjaocm6cexhv8q5c8.png"></p><br><p>  Sie können diese Funktion auch so erweitern, dass mehr als eine Textur gerendert wird.  Dies ist eine schnelle Möglichkeit, um kontinuierliches Feedback von allen Elementen in Frame-Puffern zu erhalten. </p><br><h1 id="vneshnie-programmy-otladchiki">  Externe Debugger-Programme </h1><br><p>  Wenn alles andere fehlschlägt, gibt es noch einen Trick: Programme von Drittanbietern zu verwenden.  Sie sind in den OpenGL-Treiber integriert und können alle OpenGL-Aufrufe abfangen, um Ihnen viele interessante Daten über Ihre Anwendung zu liefern.  Diese Anwendungen können die Verwendung von OpenGL-Funktionen profilieren, nach Engpässen suchen und Frame-Puffer, Texturen und Speicher überwachen.  Während der Arbeit an (großem) Code können diese Tools von unschätzbarem Wert sein. </p><br><p>  Ich habe einige beliebte Tools aufgelistet.  Probieren Sie jeden aus und wählen Sie den, der am besten zu Ihnen passt. </p><br><h4 id="renderdoc">  Renderderoc </h4><br><p>  RenderDoc ist ein gutes (vollständig <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">geöffnetes</a> ) separates Debugging-Tool.  Wählen Sie zum Starten der Erfassung die ausführbare Datei und das Arbeitsverzeichnis aus.  Ihre Anwendung funktioniert wie gewohnt. Wenn Sie ein einzelnes Bild anzeigen möchten, können Sie mit RenderDoc mehrere Bilder Ihrer Anwendung erfassen.  Unter den erfassten Frames können Sie den Status der Pipeline, alle OpenGL-Befehle, den Pufferspeicher und die verwendeten Texturen anzeigen. </p><br><p><img src="https://habrastorage.org/webt/oe/wj/zn/oewjznqytsjpfi6jbordzvph_ym.png"></p><br><h4 id="codexl">  Codexl </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CodeXL</a> - GPU-Debugging-Tool, funktioniert als eigenständige Anwendung und Plugin für Visual Studio.  CodeXL Bietet viele Informationen und eignet sich hervorragend zum Profilieren grafischer Anwendungen.  CodeXL läuft auch auf Grafikkarten von NVidia und Intel, jedoch ohne OpenCL-Debugging-Unterstützung. </p><br><p><img src="https://habrastorage.org/webt/zk/ap/jw/zkapjwplwxnqm5z65qchaxdjd34.png"></p><br><p>  Ich habe CodeXL nicht viel verwendet, weil mir RenderDoc einfacher erschien, aber ich habe CodeXL in diese Liste aufgenommen, weil es wie ein ziemlich zuverlässiges Tool aussieht und hauptsächlich von einem der größten Hersteller von GPUs entwickelt wird. </p><br><h4 id="nvidia-nsight">  NVIDIA Nsight </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nsight</a> ist ein beliebtes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NUIDIA</a> GPU-Debugging-Tool.  Es ist nicht nur ein Plug-In für Visual Studio und Eclipse, sondern auch eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">separate Anwendung</a> .  Das Nsight-Plugin ist eine sehr nützliche Sache für Grafikentwickler, da es viele Echtzeitstatistiken zur GPU-Nutzung und zum Frame-für-Frame-Status der GPU sammelt. </p><br><p>  Sobald Sie Ihre Anwendung über Visual Studio oder Eclipse mit den Debug-Befehlen oder der Nsight-Profilerstellung starten, wird sie in der Anwendung selbst gestartet.  Eine gute Sache in Nsight: Rendern eines GUI-Systems (GUI, grafische Benutzeroberfläche) über einer laufenden Anwendung, mit dem alle Arten von Informationen über Ihre Anwendung in Echtzeit oder Frame-für-Frame-Analyse gesammelt werden können. </p><br><p><img src="https://habrastorage.org/webt/rx/1m/al/rx1malqwzriz6lhd8oxquerturu.png"></p><br><p>  Nsight ist ein sehr nützliches Tool, das meiner Meinung nach die oben genannten Tools übertrifft, aber einen schwerwiegenden Nachteil hat: Es funktioniert <em>nur</em> auf NVIDIA-Grafikkarten.  Wenn Sie NVIDIA-Grafikkarten und Visual Studio verwenden, ist Nsight auf jeden Fall einen Versuch wert. </p><br><p>  ,         ( , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VOGL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">APItrace</a> ),   ,          .      ,     ,    ()          (  ,     ). </p><br><h1 id="dopolnitelnye-materialy">  Zusätzliche Materialien </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    ?</a> —           Reto Koradi. </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=http://web.archive.org/web/20150225171555/"> </a> —            Vallentin Source. </li></ul><br><p> <strong>PS</strong> :    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">-</a>   .       ,   ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462897/">https://habr.com/ru/post/de462897/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462885/index.html">Fehlertolerantes IPoE-Netzwerk zur Hand</a></li>
<li><a href="../de462887/index.html">Die Erfahrung der Personalisierung eines Online-Shops am Beispiel einer dynamischen Empfehlung</a></li>
<li><a href="../de462889/index.html">Fortsetzung Story: Pascals eigener Compiler für Windows von Grund auf neu</a></li>
<li><a href="../de462893/index.html">Gesichtserkennung in Städten: Sicherheit vs. Datenschutz</a></li>
<li><a href="../de462895/index.html">Lösen eines Jobs mit pwnable.kr 17 - memcpy. Datenausrichtung</a></li>
<li><a href="../de462903/index.html">Wie wir das neue Netzwerk auf Huawei im Moskauer Büro entworfen und implementiert haben, Teil 3: Server Factory</a></li>
<li><a href="../de462905/index.html">Schreiben eines Telegrammbots in Python mit der Telebot-Bibliothek Teil 2</a></li>
<li><a href="../de462907/index.html">ngFanatic wöchentlich</a></li>
<li><a href="../de462909/index.html">Die Früchte der ASIC-Evolution: über Hersteller, Bergleute für SHA-256 und die Kuriositäten des astronomischen Hashrats</a></li>
<li><a href="../de462911/index.html">Ein Jahr am Steuer eines Elektroautos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>