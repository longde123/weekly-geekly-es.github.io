<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüè´ ü¶ê üöç Lerne OpenGL. Lektion 7.1 - Debuggen üñºÔ∏è üòº üë©üèª‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Grafische Programmierung ist nicht nur eine Quelle des Spa√ües, sondern auch der Frustration, wenn etwas nicht wie beabsichtigt angezeigt wird oder √ºbe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lerne OpenGL. Lektion 7.1 - Debuggen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462897/"><p><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="Bild" align="left" width="300">  Grafische Programmierung ist nicht nur eine Quelle des Spa√ües, sondern auch der Frustration, wenn etwas nicht wie beabsichtigt angezeigt wird oder √ºberhaupt nichts auf dem Bildschirm angezeigt wird.  Angesichts der Tatsache, dass das meiste, was wir tun, mit der Manipulation von Pixeln zusammenh√§ngt, kann es schwierig sein, die Ursache des Fehlers herauszufinden, wenn etwas nicht so funktioniert, wie es sollte.  Das Debuggen dieser Art von Fehler ist schwieriger als das Debuggen von Fehlern auf der CPU.  Wir haben keine Konsole, auf der wir den Text ausgeben k√∂nnen, wir k√∂nnen keinen Haltepunkt in den Shader setzen und wir k√∂nnen nicht einfach den Status des Programms auf der GPU √ºbernehmen und √ºberpr√ºfen. </p><br><p>  In diesem Tutorial werden wir Ihnen einige der Debugging-Methoden und -Techniken f√ºr Ihr OpenGL-Programm vorstellen.  Das Debuggen in OpenGL ist nicht so schwierig, und das Erlernen einiger Tricks wird sich definitiv auszahlen. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Inhalt</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">Teil 1. Erste Schritte</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fenstererstellung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hallo Fenster</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hallo Dreieck</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Texturen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Transformationen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Koordinatensysteme</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kamera</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Teil 2. Grundbeleuchtung</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Farben</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grundlagen der Beleuchtung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Material</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Texturkarten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lichtquellen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mehrere Lichtquellen</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Teil 3. Laden Sie 3D-Modelle herunter</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Assimp-Bibliothek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mesh-Polygon-Klasse</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3D-Modellklasse</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Teil 4. Erweiterte OpenGL-Funktionen</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tiefentest</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schablonentest</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Farbmischung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gesichter schneiden</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bildpuffer</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubische Karten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterte Datenverarbeitung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterte GLSL</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geometrischer Shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Instanz</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gl√§tten</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Teil 5. Erweiterte Beleuchtung</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterte Beleuchtung.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blinn Fong Modell</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gammakorrektur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schattenkarten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Omnidirektionale Schattenkarten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Normale Zuordnung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Parallaxenabbildung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HDR</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bl√ºte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgeschobenes Rendern</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SSAO</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Teil 6. Z√ºchterrechte</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Theorie</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Analytische Lichtquellen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diffuse Bestrahlung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spiegelexposition</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Teil 7. √úbung</b> <div class="spoiler_text"><ol><li>  <b>Debuggen</b> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Textwiedergabe</a> </li></ol></div></div></div></div><br><h1 id="glgeterror">  glGetError () </h1><br><p> Wenn Sie OpenGL falsch verwenden (z. B. wenn Sie einen Puffer einrichten und vergessen, ihn zu binden), bemerkt OpenGL hinter den Kulissen ein oder mehrere benutzerdefinierte Fehlerflags und erstellt diese.  Wir k√∂nnen diese Fehler verfolgen, indem <code>glGetError()</code> Funktion <code>glGetError()</code> aufrufen, die einfach die gesetzten <code>glGetError()</code> √ºberpr√ºft und den Fehlerwert zur√ºckgibt, wenn Fehler auftreten. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">GLenum </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glGetError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><p>  Diese Funktion gibt ein Fehlerflag oder gar keinen Fehler zur√ºck.  Liste der R√ºckgabewerte: </p><br><div class="scrollable-table"><table><thead><tr><th>  Flagge </th><th>  Code </th><th>  Beschreibung </th></tr></thead><tbody><tr><td> <code>GL_NO_ERROR</code> </td> <td>  0 </td><td>  Seit dem letzten Aufruf von glGetError wurde kein Fehler generiert </td></tr><tr><td> <code>GL_INVALID_ENUM</code> </td> <td>  1280 </td><td>  Wird festgelegt, wenn ein Aufz√§hlungsparameter ung√ºltig ist </td></tr><tr><td> <code>GL_INVALID_VALUE</code> </td> <td>  1281 </td><td>  Wird festgelegt, wenn der Wert ung√ºltig ist </td></tr><tr><td> <code>GL_INVALID_OPERATION</code> </td> <td>  1282 </td><td>  Wird festgelegt, wenn ein Befehl mit angegebenen Parametern ung√ºltig ist </td></tr><tr><td> <code>GL_STACK_OVERFLOW</code> </td> <td>  1283 </td><td>  Es wird festgelegt, wenn das Verschieben von Daten auf den Stapel (Push) einen Stapel√ºberlauf verursacht. </td></tr><tr><td> <code>GL_STACK_UNDERFLOW</code> </td> <td>  1284 </td><td>  Es wird festgelegt, wenn die Operation zum Poppen von Daten vom Stapel (Pop) vom kleinsten Punkt auf dem Stapel aus erfolgt. </td></tr><tr><td> <code>GL_OUT_OF_MEMORY</code> </td> <td>  1285 </td><td>  Wird festgelegt, wenn eine Speicherzuweisungsoperation nicht gen√ºgend Speicher zuweisen kann. </td></tr><tr><td> <code>GL_INVALID_FRAMEBUFFER_OPERATION</code> </td> <td>  1286 </td><td>  Wird beim Lesen / Schreiben in / aus einem Framebuffer festgelegt, der nicht abgeschlossen ist </td></tr></tbody></table></div><br><p>  In der Dokumentation zu OpenGL-Funktionen finden Sie Fehlercodes, die von falsch verwendeten Funktionen generiert werden.  Wenn Sie sich beispielsweise die Dokumentation zur Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>glBindTexture()</code></a> , finden Sie die von dieser Funktion generierten Fehlercodes im Abschnitt Fehler. <br>  Wenn das Fehlerflag gesetzt ist, werden keine weiteren Fehlerflags generiert.  Wenn <code>glGetError</code> aufgerufen wird, l√∂scht die Funktion au√üerdem alle <code>glGetError</code> (oder nur eines auf einem verteilten System, siehe unten).  Dies bedeutet, dass wenn Sie <code>glGetError</code> nach jedem Frame einmal aufrufen und einen Fehler erhalten, dies nicht bedeutet, dass dies der einzige Fehler ist und Sie immer noch nicht wissen, wo dieser Fehler aufgetreten ist. </p><br><blockquote>  Beachten Sie, dass, wenn OpenGL auf verteilte Weise arbeitet, wie dies h√§ufig bei Systemen mit X11 der Fall ist, andere Fehler generiert werden k√∂nnen, wenn sie unterschiedliche Codes haben.  <code>glGetError</code> Sie <code>glGetError</code> wird einfach nur eines der Fehlercode-Flags anstelle von allen <code>glGetError</code> .  Aus diesem Grund empfehlen sie, diese Funktion in einer Schleife aufzurufen. </blockquote><br><pre> <code class="cpp hljs">glBindTexture(GL_TEXTURE_2D, tex); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; glGetError() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  0 ( ) glTexImage2D(GL_TEXTURE_3D, 0, GL_RGB, 512, 512, 0, GL_RGB, GL_UNSIGNED_BYTE, data); std::cout &lt;&lt; glGetError() &lt;&lt; std::endl; //  1280 ( ) glGenTextures(-5, textures); std::cout &lt;&lt; glGetError() &lt;&lt; std::endl; //  1281 (  std::cout &lt;&lt; glGetError() &lt;&lt; std::endl; //  0 ( )</span></span></code> </pre> <br><p>  Eine Besonderheit von <code>glGetError</code> besteht darin, dass es relativ einfach ist, festzustellen, wo Fehler auftreten k√∂nnen, und zu √ºberpr√ºfen, ob OpenGL korrekt verwendet wird.  Angenommen, Sie zeichnen nichts und wissen nicht, was der Grund ist: Der Frame-Puffer ist falsch eingestellt?  Vergessen, die Textur einzustellen?  Wenn Sie <code>glGetError</code> √ºberall aufrufen, k√∂nnen Sie schnell herausfinden, wo der erste Fehler auftritt. <br>  Standardm√§√üig meldet <code>glGetError</code> nur die Fehlernummer, die erst dann leicht zu verstehen ist, wenn Sie sich die Codenummern merken.  Oft ist es sinnvoll, eine kleine Funktion zu schreiben, um eine Fehlerzeichenfolge zusammen mit der Position zu drucken, von der aus die Funktion aufgerufen wird. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">GLenum </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glCheckError_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> line)</span></span></span><span class="hljs-function"> </span></span>{ GLenum errorCode; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((errorCode = glGetError()) != GL_NO_ERROR) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> error; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (errorCode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_INVALID_ENUM: error = <span class="hljs-string"><span class="hljs-string">"INVALID_ENUM"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_INVALID_VALUE: error = <span class="hljs-string"><span class="hljs-string">"INVALID_VALUE"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_INVALID_OPERATION: error = <span class="hljs-string"><span class="hljs-string">"INVALID_OPERATION"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_STACK_OVERFLOW: error = <span class="hljs-string"><span class="hljs-string">"STACK_OVERFLOW"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_STACK_UNDERFLOW: error = <span class="hljs-string"><span class="hljs-string">"STACK_UNDERFLOW"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_OUT_OF_MEMORY: error = <span class="hljs-string"><span class="hljs-string">"OUT_OF_MEMORY"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_INVALID_FRAMEBUFFER_OPERATION: error = <span class="hljs-string"><span class="hljs-string">"INVALID_FRAMEBUFFER_OPERATION"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; error &lt;&lt; <span class="hljs-string"><span class="hljs-string">" | "</span></span> &lt;&lt; file &lt;&lt; <span class="hljs-string"><span class="hljs-string">" ("</span></span> &lt;&lt; line &lt;&lt; <span class="hljs-string"><span class="hljs-string">")"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorCode; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> glCheckError() glCheckError_(__FILE__, __LINE__)</span></span></code> </pre> <br><p>  Wenn Sie weitere Aufrufe von <code>glCheckError</code> t√§tigen <code>glCheckError</code> , ist es hilfreich zu wissen, wo der Fehler aufgetreten ist. </p><br><pre> <code class="cpp hljs">glBindBuffer(GL_VERTEX_ARRAY, vbo); glCheckError();</code> </pre> <br><p>  Fazit: </p><br><p><img src="https://habrastorage.org/webt/3h/yo/dn/3hyodngllw6-koljhvkkee3_lzi.png"><br>  Eine wichtige Sache bleibt: Es gibt einen langj√§hrigen Fehler in GLEW: <code>glewInit()</code> setzt immer das Flag <code>GL_INVALID_ENUM</code> .  Um dies zu beheben, rufen <code>glGetError</code> einfach <code>glGetError</code> nach <code>glewInit</code> auf, um das Flag zu l√∂schen: </p><br><pre> <code class="cpp hljs">glewInit(); glGetError();</code> </pre> <br><p>  <code>glGetError</code> hilft nicht viel, da die zur√ºckgegebenen Informationen relativ einfach sind, aber es hilft oft, Tippfehler zu erkennen oder die Stelle zu ermitteln, an der der Fehler aufgetreten ist.  Dies ist ein einfaches, aber effektives Debugging-Tool. </p><br><h1 id="otladochnyy-vyvod">  Debug-Ausgabe </h1><br><p>  Das Tool ist weniger bekannt, aber n√ºtzlicher als <code>glCheckError</code> , die OpenGL-Erweiterung "Debug-Ausgabe", die im OpenGL 4.3- <code>glCheckError</code> enthalten war.  Mit dieser Erweiterung sendet OpenGL eine Fehlermeldung mit den Details des Fehlers an den Benutzer.  Diese Erweiterung bietet nicht nur weitere Informationen, sondern erm√∂glicht es Ihnen auch, Fehler mit dem Debugger abzufangen, wo sie auftreten. </p><br><blockquote>  Die Debug-Ausgabe ist in OpenGL ab Version 4.3 enthalten. Dies bedeutet, dass Sie diese Funktionalit√§t auf jedem Computer finden, der OpenGL 4.3 und h√∂her unterst√ºtzt.  Wenn diese Version nicht verf√ºgbar ist, k√∂nnen Sie die Erweiterungen <code>ARB_debug_output</code> und <code>AMD_debug_output</code> .  Es gibt auch nicht √ºberpr√ºfte Informationen dar√ºber, dass die Debugging-Ausgabe unter OS X nicht unterst√ºtzt wird (der Autor des Originals und der √úbersetzer haben nicht getestet. Bitte informieren Sie den Autor des Originals oder mich in privaten Nachrichten √ºber den Fehlerkorrekturmechanismus, wenn Sie eine Best√§tigung oder Widerlegung dieser Tatsache finden. <strong>UPD:</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Jeka178RUS</a> hat dies √ºberpr√ºft Tatsache: Standardm√§√üig funktioniert die Debug-Ausgabe nicht, er hat die Erweiterungen nicht √ºberpr√ºft. </blockquote><p>  Um die Debug-Ausgabe verwenden zu k√∂nnen, m√ºssen wir w√§hrend des Initialisierungsprozesses den OpenGL-Debug-Kontext anfordern.  Dieser Prozess ist auf verschiedenen Fenstersystemen unterschiedlich, aber hier werden wir nur GLFW diskutieren, aber am Ende des Artikels im Abschnitt "Zus√§tzliche Materialien" finden Sie Informationen zu anderen Fenstersystemen. </p><br><h4 id="otladochnyy-vyvod-v-glfw">  Debug-Ausgabe in GLFW </h4><br><p>  Das Anfordern von Debugging-Kontexten in GLFW ist √ºberraschend einfach: Sie m√ºssen GLFW lediglich einen Hinweis geben, dass wir einen Kontext w√ºnschen, der die Debugging-Ausgabe unterst√ºtzt.  Wir m√ºssen dies tun, bevor <code>glfwCreateWindow</code> aufrufen: </p><br><pre> <code class="cpp hljs">glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GL_TRUE);</code> </pre> <br><p>  Sobald wir GLFW initialisiert haben, sollten wir einen Debugging-Kontext haben, wenn wir OpenGL 4.3 oder h√∂her verwenden. Andernfalls m√ºssen wir unser Gl√ºck versuchen und hoffen, dass das System weiterhin einen Debugging-Kontext erstellen kann.  Im Fehlerfall m√ºssen wir die Debug-Ausgabe √ºber den OpenGL-Erweiterungsmechanismus anfordern. </p><br><blockquote>  Der OpenGL-Debugging-Kontext kann langsamer als normal sein. Sie sollten diese Zeile daher entfernen oder auskommentieren, w√§hrend Sie an Optimierungen arbeiten oder vor der Ver√∂ffentlichung. </blockquote><p>  Um das Ergebnis der Initialisierung des Debug-Kontexts zu √ºberpr√ºfen, reicht es aus, den folgenden Code auszuf√ºhren: </p><br><pre> <code class="cpp hljs">GLint flags; glGetIntegerv(GL_CONTEXT_FLAGS, &amp;flags); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flags &amp; GL_CONTEXT_FLAG_DEBUG_BIT) { <span class="hljs-comment"><span class="hljs-comment">//  } else { //   }</span></span></code> </pre> <br><p>  Wie funktioniert die Debug-Ausgabe?  Wir √ºbergeben eine R√ºckruffunktion an einen Nachrichtenhandler in OpenGL (√§hnlich wie R√ºckrufe in GLFW) und k√∂nnen in dieser Funktion OpenGL-Daten nach Belieben verarbeiten und in unserem Fall n√ºtzliche Fehlermeldungen an die Konsole senden.  Der Prototyp dieser Funktion: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> APIENTRY </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glDebugOutput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GLchar *message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *userParam)</span></span></span></span>;</code> </pre> <br><p>  Beachten Sie, dass unter einigen Betriebssystemen der Typ des letzten Parameters m√∂glicherweise <code>const void*</code> . <br>  Angesichts des gro√üen Datensatzes k√∂nnen wir ein n√ºtzliches Fehlerdruckwerkzeug erstellen, wie unten gezeigt: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> APIENTRY </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glDebugOutput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GLchar *message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *userParam)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ignore non-significant error/warning codes if(id == 131169 || id == 131185 || id == 131218 || id == 131204) return; std::cout &lt;&lt; "---------------" &lt;&lt; std::endl; std::cout &lt;&lt; "Debug message (" &lt;&lt; id &lt;&lt; "): " &lt;&lt; message &lt;&lt; std::endl; switch (source) { case GL_DEBUG_SOURCE_API: std::cout &lt;&lt; "Source: API"; break; case GL_DEBUG_SOURCE_WINDOW_SYSTEM: std::cout &lt;&lt; "Source: Window System"; break; case GL_DEBUG_SOURCE_SHADER_COMPILER: std::cout &lt;&lt; "Source: Shader Compiler"; break; case GL_DEBUG_SOURCE_THIRD_PARTY: std::cout &lt;&lt; "Source: Third Party"; break; case GL_DEBUG_SOURCE_APPLICATION: std::cout &lt;&lt; "Source: Application"; break; case GL_DEBUG_SOURCE_OTHER: std::cout &lt;&lt; "Source: Other"; break; } std::cout &lt;&lt; std::endl; switch (type) { case GL_DEBUG_TYPE_ERROR: std::cout &lt;&lt; "Type: Error"; break; case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: std::cout &lt;&lt; "Type: Deprecated Behaviour"; break; case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: std::cout &lt;&lt; "Type: Undefined Behaviour"; break; case GL_DEBUG_TYPE_PORTABILITY: std::cout &lt;&lt; "Type: Portability"; break; case GL_DEBUG_TYPE_PERFORMANCE: std::cout &lt;&lt; "Type: Performance"; break; case GL_DEBUG_TYPE_MARKER: std::cout &lt;&lt; "Type: Marker"; break; case GL_DEBUG_TYPE_PUSH_GROUP: std::cout &lt;&lt; "Type: Push Group"; break; case GL_DEBUG_TYPE_POP_GROUP: std::cout &lt;&lt; "Type: Pop Group"; break; case GL_DEBUG_TYPE_OTHER: std::cout &lt;&lt; "Type: Other"; break; } std::cout &lt;&lt; std::endl; switch (severity) { case GL_DEBUG_SEVERITY_HIGH: std::cout &lt;&lt; "Severity: high"; break; case GL_DEBUG_SEVERITY_MEDIUM: std::cout &lt;&lt; "Severity: medium"; break; case GL_DEBUG_SEVERITY_LOW: std::cout &lt;&lt; "Severity: low"; break; case GL_DEBUG_SEVERITY_NOTIFICATION: std::cout &lt;&lt; "Severity: notification"; break; } std::cout &lt;&lt; std::endl; std::cout &lt;&lt; std::endl; }</span></span></code> </pre> <br><p>  Wenn die Erweiterung einen OpenGL-Fehler erkennt, ruft sie diese Funktion auf und wir k√∂nnen eine gro√üe Menge an Fehlerinformationen drucken.  Beachten Sie, dass wir einige Fehler ignoriert haben, da sie unbrauchbar sind (z. B. 131185 in den NVidia-Treibern zeigt an, dass der Puffer erfolgreich erstellt wurde). <br>  Nachdem wir den gew√ºnschten R√ºckruf erhalten haben, ist es Zeit, die Debug-Ausgabe zu initialisieren: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flags &amp; GL_CONTEXT_FLAG_DEBUG_BIT) { glEnable(GL_DEBUG_OUTPUT); glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS); glDebugMessageCallback(glDebugOutput, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, GL_TRUE); }</code> </pre> <br><p>  Deshalb teilen wir OpenGL mit, dass wir die Debug-Ausgabe aktivieren m√∂chten.  Der Aufruf von <code>glEnable(GL_DEBUG_SYNCRHONOUS)</code> teilt OpenGL mit, dass eine Fehlermeldung <code>glEnable(GL_DEBUG_SYNCRHONOUS)</code> werden soll, wenn dies gerade passiert ist. </p><br><h4 id="filtraciya-otladochnogo-vyvoda">  Debug-Ausgabefilterung </h4><br><p>  Mit der Funktion <code>glDebugMessageControl</code> k√∂nnen Sie die Arten von Fehlern ausw√§hlen, die Sie erhalten m√∂chten.  In unserem Fall erhalten wir alle Arten von Fehlern.  Wenn wir nur die OpenGL-API-Fehler wie Fehler und das Signifikanzniveau Hoch haben wollten, w√ºrden wir den folgenden Code schreiben: </p><br><pre> <code class="cpp hljs">glDebugMessageControl(GL_DEBUG_SOURCE_API, GL_DEBUG_TYPE_ERROR, GL_DEBUG_SEVERITY_HIGH, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, GL_TRUE);</code> </pre> <br><p>  In diesem Konfigurations- und Debugging-Kontext sendet jeder falsche OpenGL-Befehl viele n√ºtzliche Informationen: </p><br><p><img src="https://habrastorage.org/webt/4r/su/ir/4rsuirzossc_jpcoldwi-t4s0ny.png"></p><br><h4 id="nahodim-istochnik-oshibki-cherez-stek-vyzovov">  Suchen Sie die Fehlerquelle √ºber den Aufrufstapel </h4><br><p>  Ein weiterer Trick beim Debuggen der Ausgabe besteht darin, dass Sie den genauen Ort des Fehlers in Ihrem Code relativ einfach ermitteln k√∂nnen.  Durch Festlegen eines Haltepunkts in der <code>DebugOutput</code> Funktion f√ºr den gew√ºnschten Fehlertyp (oder am Anfang der Funktion, wenn Sie alle Fehler abfangen m√∂chten) erkennt der Debugger den Fehler und Sie k√∂nnen im Aufrufstapel navigieren, um herauszufinden, wo der Fehler aufgetreten ist: </p><br><p><img src="https://habrastorage.org/webt/fw/sm/0s/fwsm0sr9tzjyl36kg0maj_rthz0.png"><br>  Dies erfordert einige manuelle Eingriffe. Wenn Sie jedoch ungef√§hr wissen, wonach Sie suchen, ist es unglaublich n√ºtzlich, schnell festzustellen, welcher Anruf den Fehler verursacht. </p><br><h4 id="svoi-oshibki">  Eigene Fehler </h4><br><p>  Zusammen mit Lesefehlern k√∂nnen wir sie mit <code>glDebugMessageInsert</code> an das Debug-Ausgabesystem <code>glDebugMessageInsert</code> : </p><br><pre> <code class="cpp hljs">glDebugMessageInsert(GL_DEBUG_SOURCE_APPLICATION, GL_DEBUG_TYPE_ERROR, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_DEBUG_SEVERITY_MEDIUM, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-string"><span class="hljs-string">"error message here"</span></span>);</code> </pre> <br><p>  Dies ist sehr n√ºtzlich, wenn Sie eine Verbindung zu einer anderen Anwendung oder einem anderen OpenGL-Code herstellen, der einen Debugging-Kontext verwendet.  Andere Entwickler k√∂nnen schnell alle gemeldeten Fehler in Ihrem benutzerdefinierten OpenGL-Code herausfinden. <br>  Im Allgemeinen ist das Debuggen der Ausgabe (falls verf√ºgbar) sehr n√ºtzlich, um Fehler schnell zu erkennen, und es lohnt sich auf jeden Fall, sich f√ºr die Optimierung einzusetzen, da dies erhebliche Entwicklungszeit spart.  Eine Kopie des Quellcodes finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> mit <code>glGetError</code> und Debug-Ausgabe.  Es gibt Fehler, versuchen Sie sie zu beheben. </p><br><h1 id="otladochnyy-vyvod-sheydera">  Shader-Debug-Ausgabe </h1><br><p>  Wenn es um GLSL geht, haben wir keinen Zugriff auf Funktionen wie <code>glGetError</code> oder die M√∂glichkeit, den Code <code>glGetError</code> im Debugger <code>glGetError</code> .  Wenn Sie auf einen schwarzen Bildschirm oder eine v√∂llig falsche Anzeige sto√üen, kann es sehr schwierig sein zu verstehen, was passiert, wenn das Problem im Shader liegt.  Ja, Kompilierungsfehler melden Syntaxfehler, aber das Abfangen semantischer Fehler ist dieses Lied. <br>  Eine der h√§ufig verwendeten Methoden, um herauszufinden, was mit einem Shader nicht stimmt, besteht darin, alle relevanten Variablen im Shader-Programm direkt an den Ausgabekanal des Fragment-Shaders zu senden.  Indem wir Shader-Variablen mit Farbe direkt auf den Ausgabekanal ausgeben, k√∂nnen wir interessante Informationen herausfinden, indem wir das Bild am Ausgang √ºberpr√ºfen.  Zum Beispiel m√ºssen wir herausfinden, ob die Normalen f√ºr das Modell korrekt sind.  Wir k√∂nnen sie (transformiert oder nicht) vom Scheitelpunkt an den Fragment-Shader senden, wo wir die Normalen wie folgt ableiten: <br>  (Hinweis: Warum gibt es keine Syntaxhervorhebung f√ºr GLSL?) </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; in vec3 Normal; [...] void main() { [...] FragColor.rgb = Normal; FragColor.a = 1.0f; }</span></span></code> </pre> <br><p>  Durch die Ausgabe einer nicht farbigen Variablen an den Ausgabekanal mit der aktuellen Farbe k√∂nnen wir den Wert der Variablen schnell √ºberpr√ºfen.  Wenn das Ergebnis beispielsweise ein schwarzer Bildschirm ist, ist es klar, dass die Normalen falsch auf die Shader √ºbertragen werden, und wenn sie angezeigt werden, ist es relativ einfach, sie auf Richtigkeit zu √ºberpr√ºfen: </p><br><p><img src="https://habrastorage.org/webt/ga/5c/eq/ga5ceqfkwfcszqm75y6szggge-e.png"></p><br><p>  Aus den visuellen Ergebnissen k√∂nnen wir erkennen, dass die Normalen korrekt sind, da die rechte Seite des Anzugs √ºberwiegend rot ist (was bedeutet, dass die Normalen ungef√§hr in Richtung der x-Sp√ºlachse angezeigt werden) und auch die Vorderseite des Anzugs in Richtung der positiven z-Achse (blau) gef√§rbt ist. </p><br><p>  Dieser Ansatz kann auf jede Variable erweitert werden, die Sie testen m√∂chten.  Versuchen Sie jedes Mal, wenn Sie nicht weiterkommen und davon ausgehen, dass der Fehler in den Shadern liegt, einige Variablen oder Zwischenergebnisse zu zeichnen und herauszufinden, in welchem ‚Äã‚ÄãTeil des Algorithmus ein Fehler vorliegt. </p><br><h1 id="opengl-glsl-reference-compiler">  OpenGL GLSL Referenzcompiler </h1><br><p>  Jeder Grafiktreiber hat seine eigenen Macken.  Zum Beispiel machen NVIDIA-Treiber die Anforderungen der Spezifikation etwas weicher, und AMD-Treiber erf√ºllen die Spezifikationen besser (was meiner Meinung nach besser ist).  Das Problem ist, dass Shader, die auf einem Computer ausgef√ºhrt werden, aufgrund unterschiedlicher Treiber m√∂glicherweise kein Geld auf einem anderen Computer verdienen. </p><br><p>  Nach mehrj√§hriger Erfahrung k√∂nnen Sie alle Unterschiede zwischen verschiedenen GPUs kennenlernen. Wenn Sie jedoch sicherstellen m√∂chten, dass Ihre Shader √ºberall funktionieren, k√∂nnen Sie Ihren Code mithilfe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GLSL-Referenz-Compilers</a> anhand der offiziellen Spezifikation √ºberpr√ºfen.  Den sogenannten <em>GLSL lang validator k√∂nnen Sie</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> herunterladen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a> ). </p><br><p>  Mit diesem Programm k√∂nnen Sie Ihre Shader testen, indem Sie sie als erstes Argument an das Programm √ºbergeben.  Denken Sie daran, dass das Programm den Shadertyp durch Erweiterung bestimmt: </p><br><ul><li>  <code>.vert</code> : Vertex-Shader </li><li>  <code>.frag</code> : Fragment-Shader </li><li>  <code>.geom</code> : geometrischer Shader </li><li>  <code>.tesc</code> : Shader zur Steuerung der Tessellation </li><li>  <code>.tese</code> : Tessellation Computing Shader </li><li>  <code>.comp</code> : Compute Shader </li></ul><br><p>  Das Programm auszuf√ºhren ist einfach: </p><br><pre> <code class="bash hljs">glslangValidator shader.vert</code> </pre> <br><p>  Beachten Sie, dass das Programm nichts ausgibt, wenn keine Fehler vorliegen.  Bei einem fehlerhaften Vertex-Shader sieht die Ausgabe folgenderma√üen aus: </p><br><p><img src="https://habrastorage.org/webt/-l/x-/yi/-lx-yijcoqk4ehnnc5xentnjl5m.png"></p><br><p>  Das Programm zeigt nicht die Unterschiede zwischen den GLSL-Compilern von AMD, NVidia oder Intel an und kann nicht einmal alle Fehler im Shader melden, √ºberpr√ºft jedoch zumindest die Shader auf √úbereinstimmung mit den Standards. </p><br><h1 id="vyvod-bufera-kadra">  Bildpufferausgabe </h1><br><p>  Eine andere Methode f√ºr Ihr Toolkit besteht darin, den Inhalt des Bildpuffers in einem bestimmten Teil des Bildschirms anzuzeigen.  H√∂chstwahrscheinlich verwenden Sie h√§ufig Framebuffer, und da die ganze Magie hinter den Kulissen geschieht, kann es schwierig sein, festzustellen, was passiert.  Die Ausgabe des Inhalts des Bildpuffers ist ein n√ºtzlicher Trick, um die Richtigkeit zu √ºberpr√ºfen. </p><br><blockquote>  Beachten Sie, dass der Inhalt des Bildpuffers, wie hier erl√§utert, mit Texturen und nicht mit Objekten in den Zeichenpuffern funktioniert </blockquote><p>  Mit einem einfachen Shader, der eine einzelne Textur zeichnet, k√∂nnen wir eine kleine Funktion schreiben, die schnell jede Textur in der oberen rechten Ecke des Bildschirms zeichnet: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// vertex shader #version 330 core layout (location = 0) in vec2 position; layout (location = 1) in vec2 texCoords; out vec2 TexCoords; void main() { gl_Position = vec4(position, 0.0f, 1.0f); TexCoords = texCoords; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//fragment shader #version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D fboAttachment; void main() { FragColor = texture(fboAttachment, TexCoords); }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//main.cpp void DisplayFramebufferTexture(GLuint textureID) { if(!notInitialized) { // initialize shader and vao w/ NDC vertex coordinates at top-right of the screen [...] } glActiveTexture(GL_TEXTURE0); glUseProgram(shaderDisplayFBOOutput); glBindTexture(GL_TEXTURE_2D, textureID); glBindVertexArray(vaoDebugTexturedRect); glDrawArrays(GL_TRIANGLES, 0, 6); glBindVertexArray(0); glUseProgram(0); } int main() { [...] while (!glfwWindowShouldClose(window)) { [...] DisplayFramebufferTexture(fboAttachment0); glfwSwapBuffers(window); } }</span></span></code> </pre> <br><p>  Dadurch erhalten Sie in der Ecke des Bildschirms ein kleines Fenster zum Debuggen der Ausgabe des Bildpuffers.  Dies ist beispielsweise n√ºtzlich, wenn Sie versuchen, die Richtigkeit von Normalen zu √ºberpr√ºfen: </p><br><p><img src="https://habrastorage.org/webt/zi/uw/ap/ziuwapmnertjaocm6cexhv8q5c8.png"></p><br><p>  Sie k√∂nnen diese Funktion auch so erweitern, dass mehr als eine Textur gerendert wird.  Dies ist eine schnelle M√∂glichkeit, um kontinuierliches Feedback von allen Elementen in Frame-Puffern zu erhalten. </p><br><h1 id="vneshnie-programmy-otladchiki">  Externe Debugger-Programme </h1><br><p>  Wenn alles andere fehlschl√§gt, gibt es noch einen Trick: Programme von Drittanbietern zu verwenden.  Sie sind in den OpenGL-Treiber integriert und k√∂nnen alle OpenGL-Aufrufe abfangen, um Ihnen viele interessante Daten √ºber Ihre Anwendung zu liefern.  Diese Anwendungen k√∂nnen die Verwendung von OpenGL-Funktionen profilieren, nach Engp√§ssen suchen und Frame-Puffer, Texturen und Speicher √ºberwachen.  W√§hrend der Arbeit an (gro√üem) Code k√∂nnen diese Tools von unsch√§tzbarem Wert sein. </p><br><p>  Ich habe einige beliebte Tools aufgelistet.  Probieren Sie jeden aus und w√§hlen Sie den, der am besten zu Ihnen passt. </p><br><h4 id="renderdoc">  Renderderoc </h4><br><p>  RenderDoc ist ein gutes (vollst√§ndig <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ge√∂ffnetes</a> ) separates Debugging-Tool.  W√§hlen Sie zum Starten der Erfassung die ausf√ºhrbare Datei und das Arbeitsverzeichnis aus.  Ihre Anwendung funktioniert wie gewohnt. Wenn Sie ein einzelnes Bild anzeigen m√∂chten, k√∂nnen Sie mit RenderDoc mehrere Bilder Ihrer Anwendung erfassen.  Unter den erfassten Frames k√∂nnen Sie den Status der Pipeline, alle OpenGL-Befehle, den Pufferspeicher und die verwendeten Texturen anzeigen. </p><br><p><img src="https://habrastorage.org/webt/oe/wj/zn/oewjznqytsjpfi6jbordzvph_ym.png"></p><br><h4 id="codexl">  Codexl </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CodeXL</a> - GPU-Debugging-Tool, funktioniert als eigenst√§ndige Anwendung und Plugin f√ºr Visual Studio.  CodeXL Bietet viele Informationen und eignet sich hervorragend zum Profilieren grafischer Anwendungen.  CodeXL l√§uft auch auf Grafikkarten von NVidia und Intel, jedoch ohne OpenCL-Debugging-Unterst√ºtzung. </p><br><p><img src="https://habrastorage.org/webt/zk/ap/jw/zkapjwplwxnqm5z65qchaxdjd34.png"></p><br><p>  Ich habe CodeXL nicht viel verwendet, weil mir RenderDoc einfacher erschien, aber ich habe CodeXL in diese Liste aufgenommen, weil es wie ein ziemlich zuverl√§ssiges Tool aussieht und haupts√§chlich von einem der gr√∂√üten Hersteller von GPUs entwickelt wird. </p><br><h4 id="nvidia-nsight">  NVIDIA Nsight </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nsight</a> ist ein beliebtes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NUIDIA</a> GPU-Debugging-Tool.  Es ist nicht nur ein Plug-In f√ºr Visual Studio und Eclipse, sondern auch eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">separate Anwendung</a> .  Das Nsight-Plugin ist eine sehr n√ºtzliche Sache f√ºr Grafikentwickler, da es viele Echtzeitstatistiken zur GPU-Nutzung und zum Frame-f√ºr-Frame-Status der GPU sammelt. </p><br><p>  Sobald Sie Ihre Anwendung √ºber Visual Studio oder Eclipse mit den Debug-Befehlen oder der Nsight-Profilerstellung starten, wird sie in der Anwendung selbst gestartet.  Eine gute Sache in Nsight: Rendern eines GUI-Systems (GUI, grafische Benutzeroberfl√§che) √ºber einer laufenden Anwendung, mit dem alle Arten von Informationen √ºber Ihre Anwendung in Echtzeit oder Frame-f√ºr-Frame-Analyse gesammelt werden k√∂nnen. </p><br><p><img src="https://habrastorage.org/webt/rx/1m/al/rx1malqwzriz6lhd8oxquerturu.png"></p><br><p>  Nsight ist ein sehr n√ºtzliches Tool, das meiner Meinung nach die oben genannten Tools √ºbertrifft, aber einen schwerwiegenden Nachteil hat: Es funktioniert <em>nur</em> auf NVIDIA-Grafikkarten.  Wenn Sie NVIDIA-Grafikkarten und Visual Studio verwenden, ist Nsight auf jeden Fall einen Versuch wert. </p><br><p>  ,         ( , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VOGL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">APItrace</a> ),   ,          .      ,     ,    ()          (  ,     ). </p><br><h1 id="dopolnitelnye-materialy">  Zus√§tzliche Materialien </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    ?</a> ‚Äî           Reto Koradi. </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=http://web.archive.org/web/20150225171555/"> </a> ‚Äî            Vallentin Source. </li></ul><br><p> <strong>PS</strong> :    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">-</a>   .       ,   ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462897/">https://habr.com/ru/post/de462897/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462885/index.html">Fehlertolerantes IPoE-Netzwerk zur Hand</a></li>
<li><a href="../de462887/index.html">Die Erfahrung der Personalisierung eines Online-Shops am Beispiel einer dynamischen Empfehlung</a></li>
<li><a href="../de462889/index.html">Fortsetzung Story: Pascals eigener Compiler f√ºr Windows von Grund auf neu</a></li>
<li><a href="../de462893/index.html">Gesichtserkennung in St√§dten: Sicherheit vs. Datenschutz</a></li>
<li><a href="../de462895/index.html">L√∂sen eines Jobs mit pwnable.kr 17 - memcpy. Datenausrichtung</a></li>
<li><a href="../de462903/index.html">Wie wir das neue Netzwerk auf Huawei im Moskauer B√ºro entworfen und implementiert haben, Teil 3: Server Factory</a></li>
<li><a href="../de462905/index.html">Schreiben eines Telegrammbots in Python mit der Telebot-Bibliothek Teil 2</a></li>
<li><a href="../de462907/index.html">ngFanatic w√∂chentlich</a></li>
<li><a href="../de462909/index.html">Die Fr√ºchte der ASIC-Evolution: √ºber Hersteller, Bergleute f√ºr SHA-256 und die Kuriosit√§ten des astronomischen Hashrats</a></li>
<li><a href="../de462911/index.html">Ein Jahr am Steuer eines Elektroautos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>