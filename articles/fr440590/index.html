<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéå ü¶á üë©üèΩ‚Äç‚öïÔ∏è O√π sont les jambes du mod√®le de m√©moire Java üì≠ ü¶à üëßüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le mat√©riel et les compilateurs modernes sont pr√™ts √† bouleverser notre code, si seulement cela fonctionne plus rapidement. Et leurs fabricants cachen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O√π sont les jambes du mod√®le de m√©moire Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440590/"> Le mat√©riel et les compilateurs modernes sont pr√™ts √† bouleverser notre code, si seulement cela fonctionne plus rapidement.  Et leurs fabricants cachent soigneusement leur cuisine int√©rieure.  Et tout va bien tant que le code est ex√©cut√© dans un seul thread. <br><br>  Dans un environnement multi-thread, vous pouvez forc√©ment observer des choses int√©ressantes.  Par exemple, l'ex√©cution des instructions de programme n'est pas dans l'ordre qui est √©crit dans le code source.  D'accord, il est d√©sagr√©able de r√©aliser que l'ex√©cution du code source ligne par ligne n'est que notre imagination. <br><br>  Mais tout le monde s'est d√©j√† rendu compte, car il faut en quelque sorte vivre avec.  Et les programmeurs Java vivent m√™me bien.  Parce que Java a un mod√®le de m√©moire - le mod√®le de m√©moire Java (JMM), qui fournit des r√®gles assez simples pour √©crire le code multithread correct. <br><br>  Et ces r√®gles sont suffisantes pour la plupart des programmes.  Si vous ne les connaissez pas, mais que vous √©crivez ou souhaitez √©crire des programmes multithreads en Java, il est pr√©f√©rable de vous familiariser avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">eux</a> d√®s que possible.  Et si vous le savez, mais que vous n'avez pas assez de contexte ou qu'il est int√©ressant de savoir d'o√π viennent les jambes de JMM, cet article peut vous aider. <br><a name="habracut"></a><br><h2>  Et chasser l'abstraction </h2><br>  √Ä mon avis, il y a une tarte, ou, mieux, un iceberg.  JMM est la pointe de l'iceberg.  L'iceberg lui-m√™me est une th√©orie de la programmation multi-thread sous l'eau.  Sous l'iceberg est l'enfer. <br><br><img src="https://habrastorage.org/webt/ub/jg/rf/ubjgrfe8bec3-ix9qgnkik3avoy.png"><br><br>  Un iceberg est une abstraction; s'il fuit, nous verrons certainement l'enfer.  Bien que beaucoup de choses int√©ressantes se produisent l√†-bas, dans l'article de revue, nous n'y arriverons pas. <br><br>  Dans l'article, je m'int√©resse plus aux sujets suivants: <br><br><ul><li>  Th√©orie et terminologie </li><li>  Comment la th√©orie de la programmation multithread se refl√®te-t-elle dans JMM </li><li>  Mod√®les de programmation comp√©titifs </li></ul><br>  La th√©orie de la programmation multi-thread vous permet de vous √©loigner de la complexit√© des processeurs et compilateurs modernes, elle vous permet de simuler l'ex√©cution de programmes multi-thread et d'√©tudier leurs propri√©t√©s.  Roman Elizarov a fait un excellent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapport</a> , dont le but est de fournir une base th√©orique pour comprendre JMM.  Je recommande le rapport √† tous ceux qui s'int√©ressent √† ce sujet. <br><br>  Pourquoi est-il important de conna√Ætre la th√©orie?  √Ä mon avis, j'esp√®re que pour le mien, certains programmeurs ont une opinion que JMM est une complication du langage et des correctifs de certains probl√®mes de plate-forme avec le multithreading.  La th√©orie montre que Java n'a pas compliqu√©, mais simplifi√© et rendu plus pr√©visible une programmation multithread tr√®s complexe. <br><br><h2>  Concurrence et concurrence </h2><br>  Voyons d'abord la terminologie.  Malheureusement, il n'y a pas de consensus dans la terminologie - lorsque vous √©tudiez diff√©rents mat√©riaux, vous pouvez rencontrer diff√©rentes d√©finitions de la concurrence et de la concurrence. <br><br>  Le probl√®me est que m√™me si nous allons au fond de la v√©rit√© et trouvons les d√©finitions exactes de ces concepts, cela ne vaut pas la peine d'attendre que tout le monde signifiera la m√™me chose avec ces concepts.  Vous ne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trouverez</a> pas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les</a> fins ici. <br><br>  Roman Elizarov, dans un rapport, la th√©orie de la programmation parall√®le pour les praticiens sugg√®re que parfois ces concepts sont m√©lang√©s.  La programmation parall√®le se distingue parfois comme un concept g√©n√©ral divis√© en comp√©titif et distribu√©. <br><br>  Il me semble que dans le contexte de JMM, il faut encore s√©parer comp√©tition et parall√©lisme, ou plut√¥t comprendre qu'il existe deux paradigmes diff√©rents, quel que soit leur nom. <br><br>  Souvent cit√© par Rob Pike, qui distingue les concepts comme suit: <br><br><ul><li>  La concurrence est un moyen de r√©soudre simultan√©ment de nombreux probl√®mes </li><li>  La concurrence est un moyen d'ex√©cuter diff√©rentes parties d'une m√™me t√¢che. </li></ul><br>  L'opinion de Rob Pike n'est pas une norme, mais √† mon avis, il est commode de s'en inspirer pour approfondir la question.  En savoir plus sur les diff√©rences <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Tr√®s probablement, une meilleure compr√©hension de la question appara√Ætra si nous mettons en √©vidence les principales caract√©ristiques d'un programme concurrentiel et parall√®le.  Il y a beaucoup de signes, consid√©rez les plus importants. <br><br>  Signes de comp√©tition. <br><br><ul><li>  La pr√©sence de plusieurs flux de contr√¥le (par exemple, Thread en Java, coroutine dans Kotlin), s'il n'y a qu'un seul flux de contr√¥le, il ne peut y avoir aucune ex√©cution comp√©titive </li><li>  R√©sultat non d√©terministe.  Le r√©sultat d√©pend des √©v√©nements al√©atoires, de l'impl√©mentation et de la mani√®re dont la synchronisation a √©t√© effectu√©e.  M√™me si chaque flux est compl√®tement d√©terministe, le r√©sultat final sera non d√©terministe </li></ul><br>  Un programme parall√®le aura un ensemble diff√©rent de fonctionnalit√©s. <br><br><ul><li>  Facultatif a plusieurs flux de contr√¥le </li><li>  Cela peut conduire √† un r√©sultat d√©terministe, par exemple, le r√©sultat de la multiplication de chaque √©l√©ment du tableau par un nombre ne changera pas si vous le multipliez en plusieurs parties en parall√®le </li></ul><br>  Curieusement, l'ex√©cution parall√®le est possible sur un seul flux de contr√¥le, et m√™me sur une architecture monoc≈ìur.  Le fait est que le parall√©lisme au niveau des t√¢ches (ou des flux de contr√¥le) auquel nous sommes habitu√©s n'est pas le seul moyen d'effectuer des calculs en parall√®le. <br><br>  La concurrence est possible au niveau de: <br><br><ul><li>  bits (par exemple, sur les machines 32 bits, l'addition a lieu en une seule action, en traitant les 4 octets d'un nombre 32 bits en parall√®le) </li><li>  instructions (sur un c≈ìur, dans un thread, le processeur peut ex√©cuter des instructions en parall√®le, malgr√© le fait que le code soit s√©quentiel) </li><li>  donn√©es (il existe des architectures avec traitement parall√®le des donn√©es (Single Instruction Multiple Data) qui peuvent ex√©cuter une instruction sur un grand ensemble de donn√©es) </li><li>  t√¢ches (implique la pr√©sence de plusieurs processeurs ou c≈ìurs) </li></ul><br>  La concurrence au niveau de l'instruction est un exemple d'optimisations qui se produisent avec l'ex√©cution de code qui sont cach√©es au programmeur. <br><br>  Il est garanti que le code optimis√© sera √©quivalent √† l'original dans le cadre d'un thread, car il est impossible d'√©crire du code ad√©quat et pr√©visible s'il ne fait pas ce que le programmeur avait pr√©vu. <br><br>  Tout ce qui fonctionne en parall√®le n'a pas d'importance pour JMM.  L'ex√©cution simultan√©e au niveau de l'instruction dans un seul thread n'est pas prise en compte dans JMM. <br><br>  La terminologie est tr√®s fragile, avec une pr√©sentation de Roman Elizarov intitul√©e ¬´Th√©orie de la programmation <b>parall√®le</b> pour les praticiens¬ª, bien qu'il y ait plus sur la programmation comp√©titive, si vous vous en tenez √† ce qui pr√©c√®de. <br><br>  Dans le contexte de JMM, dans l'article, je m'en tiendrai au terme de concurrence, car la concurrence concerne souvent l'√©tat g√©n√©ral.  Mais ici, vous devez faire attention √† ne pas vous accrocher aux termes, mais √† comprendre qu'il existe diff√©rents paradigmes. <br><br><h2>  Mod√®les avec un √©tat commun: ¬´rotation des op√©rations¬ª et ¬´arriv√© avant¬ª </h2><br>  Dans son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article,</a> Maurice Herlichi (auteur de la programmation The Art Of Multiprocessor) √©crit qu'un syst√®me concurrentiel contient une collection de processus s√©quentiels (dans les travaux th√©oriques, cela signifie la m√™me chose qu'un fil) qui communiquent via la m√©moire partag√©e. <br><br>  Le mod√®le d'√©tat g√©n√©ral comprend des calculs avec messagerie, o√π l'√©tat partag√© est une file d'attente de messages et des calculs avec m√©moire partag√©e, o√π l'√©tat commun sont des structures en m√©moire. <br><br>  Chacun des calculs peut √™tre simul√©. <br><br>  Le mod√®le est bas√© sur une machine √† √©tats finis.  Le mod√®le se concentre exclusivement sur l'√©tat partag√© et les donn√©es locales de chacun des flux sont compl√®tement ignor√©es.  Chaque action de flux sur un √©tat partag√© est fonction de la transition vers un nouvel √©tat. <br><br>  Ainsi, par exemple, si 4 threads √©crivent des donn√©es dans une variable partag√©e, alors il y aura 4 fonctions pour la transition vers un nouvel √©tat.  Laquelle de ces fonctions sera appliqu√©e d√©pend de la chronologie des √©v√©nements dans le syst√®me. <br><br>  Les calculs de passage de messages sont mod√©lis√©s de mani√®re similaire, seules les fonctions d'√©tat et de transition d√©pendent de l'envoi ou de la r√©ception de messages. <br><br>  Si le mod√®le vous a sembl√© compliqu√©, alors dans l'exemple, nous le corrigerons.  C'est vraiment tr√®s simple et intuitif.  √Ä tel point que sans conna√Ætre l'existence de ce mod√®le, la plupart des gens continueront d'analyser le programme comme le sugg√®re le mod√®le. <br><br>  Un tel mod√®le est appel√© mod√®le de <b>performance par l'alternance des op√©rations</b> (le nom a √©t√© entendu dans un rapport de Roman Elizarov). <br><br>  Dans l'intuitivit√© et le naturel, vous pouvez √©crire en toute s√©curit√© les avantages du mod√®le.  Vous pouvez entrer dans la nature avec les mots-cl√©s <b>coh√©rence s√©quentielle</b> et le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">travail de</a> Leslie Lamport. <br><br>  Cependant, il existe une clarification importante sur ce mod√®le.  Le mod√®le a la limitation que toutes les actions sur un √©tat partag√© doivent √™tre instantan√©es et en m√™me temps, les actions ne peuvent pas se produire simultan√©ment.  Ils disent qu'un tel syst√®me a un <b>ordre lin√©aire</b> - toutes les actions du syst√®me sont ordonn√©es. <br><br>  En pratique, cela ne se produit pas.  L'op√©ration ne se produit pas instantan√©ment, mais est effectu√©e dans un intervalle; sur les syst√®mes multic≈ìurs, ces intervalles peuvent se croiser.  Bien s√ªr, cela ne signifie pas que le mod√®le est inutile dans la pratique, il vous suffit de cr√©er certaines conditions pour son utilisation. <br><br>  En attendant, consid√©rons un autre <b>mod√®le - ¬´arriv√© avant¬ª,</b> qui ne se concentre pas sur l'√©tat, mais sur l'ensemble des cellules de m√©moire en lecture et en √©criture pendant l'ex√©cution (historique) et leurs relations. <br><br>  Le mod√®le dit que les √©v√©nements dans diff√©rents flux ne sont pas instantan√©s et atomiques, mais en parall√®le, et il n'est pas possible de cr√©er de l'ordre entre eux.  Les √©v√©nements (√©criture et lecture de donn√©es partag√©es) dans des flux sur une architecture multiprocesseur ou multic≈ìur se produisent vraiment en parall√®le.  Il n'y a pas de notion d'heure globale dans le syst√®me, nous ne pouvons pas comprendre quand une op√©ration s'est termin√©e et une autre a commenc√©. <br><br>  En pratique, cela signifie que nous pouvons √©crire une valeur dans une variable dans un thread et le faire, disons le matin, et lire la valeur de cette variable dans un autre thread le soir, et nous ne pouvons pas dire que nous lirons la valeur √©crite le matin avec certitude.  En th√©orie, ces op√©rations se d√©roulent en parall√®le et on ne sait pas quand l'une se terminera et une autre commencera. <br><br>  Il est difficile d'imaginer comment il s'av√®re que de simples op√©rations de lecture et d'√©criture effectu√©es √† diff√©rents moments de la journ√©e se d√©roulent simultan√©ment.  Mais si vous y r√©fl√©chissez, cela n'a pas vraiment d'importance pour nous lorsque les √©v√©nements d'√©criture et de lecture se produisent, si nous ne pouvons garantir que nous verrons le r√©sultat de l'enregistrement. <br><br>  Et nous ne pouvons vraiment pas voir le r√©sultat de l'enregistrement, c'est-√†-dire  dans une variable dont la valeur est <i>0</i> dans le flux <i>P,</i> nous √©crivons <i>1</i> , et dans le flux <i>Q</i> nous lisons cette variable.  Peu importe combien de temps physique passe apr√®s l'enregistrement, nous pouvons toujours lire <i>0</i> . <br><br>  <b>C'est ainsi que les ordinateurs fonctionnent et le mod√®le le refl√®te.</b> <br><br>  Le mod√®le est compl√®tement abstrait et n√©cessite une visualisation pratique pour un travail pratique.  Pour la visualisation et uniquement pour cela, un mod√®le avec le temps global est utilis√©, avec des r√©serves que pour prouver les propri√©t√©s des programmes, le temps global n'est pas utilis√©.  En visualisation, chaque √©v√©nement est repr√©sent√© comme un intervalle avec un d√©but et une fin. <br><br>  Les √©v√©nements se d√©roulent en parall√®le, comme nous l'avons d√©couvert.  Mais quand m√™me, le syst√®me a un <b>ordre partiel</b> , car il y a des paires sp√©ciales d'√©v√©nements qui ont un ordre, auquel cas ils disent que ces √©v√©nements ont une relation ¬´arriv√© avant¬ª.  Si vous entendez d'abord parler de la relation ¬´qui s'est produite avant¬ª, sachant probablement que cette relation organise en quelque sorte des √©v√©nements ne vous sera pas d'une grande utilit√©. <br><br><h2>  Essayer d'analyser un programme Java </h2><br>  Nous avons consid√©r√© un minimum th√©orique, essayons d'avancer et consid√©rons un programme multi-thread dans un langage sp√©cifique - Java, √† partir de deux threads avec un √©tat mutable commun. <br><br>  Un exemple classique. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span>, b = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { a = <span class="hljs-number"><span class="hljs-number">0</span></span>; b = <span class="hljs-number"><span class="hljs-number">0</span></span>; x = <span class="hljs-number"><span class="hljs-number">0</span></span>; y = <span class="hljs-number"><span class="hljs-number">0</span></span>; } Thread p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() -&gt; { a = <span class="hljs-number"><span class="hljs-number">1</span></span>; x = b; }); Thread q = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() -&gt; { b = <span class="hljs-number"><span class="hljs-number">1</span></span>; y = a; }); p.start(); q.start(); p.join(); q.join(); System.out.println(<span class="hljs-string"><span class="hljs-string">"x="</span></span> + x + <span class="hljs-string"><span class="hljs-string">", y="</span></span> + y);</code> </pre> <br>  Nous devons simuler l'ex√©cution de ce programme et obtenir tous les r√©sultats possibles - les valeurs des variables x et y.  Il y aura plusieurs r√©sultats, comme nous le rappelons de la th√©orie, un tel programme n'est pas d√©terministe. <br><br>  Comment allons-nous mod√©liser?  Je veux imm√©diatement utiliser le mod√®le d'op√©rations entrelac√©es.  Mais le mod√®le ¬´arriv√© avant¬ª nous dit que les √©v√©nements d'un thread sont parall√®les aux √©v√©nements d'un autre thread.  Par cons√©quent, le mod√®le d'op√©rations altern√©es ici n'est pas appropri√© s'il n'y a pas de relation ¬´ant√©rieure √†¬ª entre les op√©rations. <br><br>  Le r√©sultat de l'ex√©cution de chaque thread est toujours d√©termin√©, puisque les √©v√©nements dans un thread sont toujours ordonn√©s, consid√©rez qu'ils re√ßoivent gratuitement une relation ¬´arriv√© avant¬ª.  Mais comment les √©v√©nements dans diff√©rents flux peuvent obtenir la relation ¬´qui s'est produite avant¬ª n'est pas enti√®rement √©vident.  Bien s√ªr, cette relation est formalis√©e dans le mod√®le, l'ensemble du mod√®le est √©crit en langage math√©matique.  Mais que faire de cela dans la pratique, dans une langue particuli√®re, n'est pas imm√©diatement compris. <br><br>  Quelles sont les options? <br><br>  Ignorez les contraintes et simulez l'entrelacement.  Vous pouvez l'essayer, peut-√™tre qu'il ne se passera rien de mal. <br><br>  Pour comprendre quel type de r√©sultats peut √™tre obtenu, nous √©num√©rons simplement toutes les variantes possibles d'ex√©cution. <br><br>  Toutes les ex√©cutions de programme possibles peuvent √™tre repr√©sent√©es comme une machine √† √©tats finis. <br><br><img src="https://habrastorage.org/webt/z_/nb/a4/z_nba4dq4_xlfkdvw7vypddxo3s.jpeg"><br><br>  Chaque cercle est un √©tat du syst√®me, dans notre cas les variables <i>a, b, x, y</i> .  Une fonction de transition est une action sur un √©tat qui met le syst√®me dans un nouvel √©tat.  √âtant donn√© que deux flux peuvent effectuer des actions sur l'√©tat g√©n√©ral, il y aura deux transitions √† partir de chaque √©tat.  Les cercles doubles sont les √©tats final et initial du syst√®me. <br><br>  Au total, 6 ex√©cutions diff√©rentes sont possibles, ce qui donne des paires de valeurs x, y: <br> <code>(1, 1), (1, 0), (0, 1) <br></code> <br><img src="https://habrastorage.org/webt/uu/dn/ev/uudnevagixnomxjnrydhfgrph4i.png"><br><br>  Nous pouvons ex√©cuter le programme et v√©rifier les r√©sultats.  Comme il sied √† un programme comp√©titif, il aura un r√©sultat non d√©terministe. <br><br>  Pour tester des programmes comp√©titifs, il est pr√©f√©rable d'utiliser des outils sp√©ciaux ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">outil</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapport</a> ). <br><br>  Mais vous pouvez essayer d'ex√©cuter le programme plusieurs millions de fois, ou mieux encore, √©crire un cycle qui le fera pour nous. <br><br>  Si nous ex√©cutons le code sur une architecture √† c≈ìur unique ou √† processeur unique, nous devrions obtenir le r√©sultat de l'ensemble que nous attendons.  Le mod√®le de rotation fonctionnera tr√®s bien.  Sur une architecture multic≈ìur, par exemple x86, nous pouvons √™tre surpris par le r√©sultat - nous pouvons obtenir le r√©sultat (0,0), qui ne peut pas √™tre conforme √† notre mod√©lisation. <br><br>  L'explication peut √™tre trouv√©e sur Internet par le mot-cl√© - <b>r√©organisation</b> .  Maintenant, il est important de comprendre que la <b>mod√©lisation d'entrelacement n'est vraiment pas appropri√©e dans une situation o√π nous ne pouvons pas d√©terminer l'ordre d'acc√®s √† l'√©tat partag√©</b> . <br><br><h2>  Th√©orie de la programmation comp√©titive et JMM </h2><br>  Il est temps de regarder de plus pr√®s la relation ¬´qui s'est produite avant¬ª et comment elle se lie d'amiti√© avec JMM.  La d√©finition originale de la relation ¬´arriv√© avant¬ª se trouve dans Time, Clocks et Ordering of Events in a Distributed System. <br><br>  Le mod√®le de m√©moire de langage aide √† √©crire du code comp√©titif, car il d√©termine quelles op√©rations sont li√©es √† ¬´d√©j√† eu lieu¬ª.  Une liste de ces op√©rations est pr√©sent√©e dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sp√©cification</a> dans la section Ordre des commandes ant√©rieures.  En fait, cette section r√©pond √† la question - dans quelles conditions verrons-nous le r√©sultat de l'enregistrement dans un autre flux. <br><br>  Il existe diff√©rentes commandes dans JMM.  Alexei Shipilev parle tr√®s vigoureusement des r√®gles dans l'un de ses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapports</a> . <br><br>  Dans le mod√®le de temps global, toutes les op√©rations dans le m√™me thread sont en ordre.  Par exemple, les √©v√©nements d'√©criture et de lecture d'une variable peuvent √™tre repr√©sent√©s comme deux intervalles, puis le mod√®le garantit que ces intervalles ne se recouperont jamais dans le cadre d'un seul flux.  Dans JMM, cette commande est appel√©e commande de programme ( <i>PO</i> ). <br><br>  <i>PO</i> lie les actions dans un seul thread et ne dit rien sur l'ordre d'ex√©cution, il ne parle que de l'ordre dans le code source.  C'est tout √† fait suffisant pour garantir le <b>d√©terminisme pour chaque flux s√©par√©ment</b> .  <i>Les bons de commande</i> peuvent √™tre consid√©r√©s comme des donn√©es brutes.  <i>PO est</i> toujours facile √† organiser dans un programme - toutes les op√©rations (ordre lin√©aire) dans le code source dans un seul flux auront <i>PO</i> . <br><br>  Dans notre exemple, nous obtenons quelque chose comme ceci: <br><br>  <code>P: a = 1 PO x = b</code> - √©crire dans a et lire b a un ordre PO <br>  <code>Q: b = 1 PO y = a</code> - √©crire dans b et lire un ordre a PO <br><br>  J'ai espionn√© cette forme d'√©criture <i>w (a, 1) PO r (b): 0.</i> J'esp√®re vraiment que personne ne l'a brevet√© pour les rapports.  Cependant, la sp√©cification a une forme similaire. <br><br>  Mais chaque thread individuellement n'est pas particuli√®rement int√©ressant pour nous, puisque les threads ont un √©tat commun, nous sommes plus int√©ress√©s par l'interaction des flux.  Tout ce que nous voulons, c'est √™tre s√ªr que nous verrons un enregistrement des variables dans d'autres threads. <br><br>  Permettez-moi de vous rappeler que cela n'a pas fonctionn√© pour nous, car les op√©rations d'√©criture et de lecture de variables dans diff√©rents flux ne sont pas instantan√©es (ce sont des segments qui se croisent), respectivement, il est impossible d'analyser o√π se trouvent le d√©but et la fin des op√©rations. <br><br>  L'id√©e est simple - au moment o√π nous lisons la variable a dans le flux <i>Q</i> , l'enregistrement de cette m√™me variable dans le flux <i>P</i> n'est peut-√™tre pas encore termin√©.  Et peu importe le temps physique que ces √©v√©nements partagent - une nanoseconde ou quelques heures. <br><br>  Pour commander des √©v√©nements, nous avons besoin de la relation ¬´arriv√© avant¬ª.  JMM d√©finit cette relation.  La sp√©cification fixe l'ordre dans un thread: <br><br>  <i>Si l'op√©ration x et y sont dans le m√™me thread et dans <i>PO</i> x se produit d'abord, puis y, alors x s'est produit avant y.</i> <i><br></i> <br><br>  Pour l'avenir, nous pouvons dire que nous pouvons remplacer tous les <i>bons de commande</i> par Happens-before ( <i>HB</i> ): <br><br><pre> <code class="plaintext hljs">P: w(a, 1) HB r(b) Q: w(b, 1) HB r(a)</code> </pre> <br>  Mais encore une fois, nous revenons dans le cadre d'un flux.  <i>HB est</i> possible entre des op√©rations se produisant dans diff√©rents threads, pour traiter ces cas, nous nous familiariserons avec d'autres commandes. <br><br>  Ordre de synchronisation ( <i>SO</i> ) - relie les actions de synchronisation ( <i>SA</i> ), une liste compl√®te des <i>SA est</i> donn√©e dans la sp√©cification, √† la section 17.4.2.  Actions  En voici quelques uns: <br><br><ul><li>  Lecture d'une variable volatile </li><li>  √âcriture d'une variable volatile </li><li>  Verrouillage du moniteur </li><li>  D√©verrouiller le moniteur </li></ul><br>  <i>SO</i> est int√©ressant pour nous, car il a la propri√©t√© que toutes les lectures dans l'ordre <i>SO</i> voient les derni√®res entr√©es dans <i>SO</i> .  Et je vous rappelle que nous ne faisons que cela. <br><br>  √Ä cet endroit, je r√©p√©terai ce que nous recherchons.  Nous avons un programme multithread, nous voulons simuler toutes les ex√©cutions possibles et obtenir tous les r√©sultats qu'il peut donner.  Il existe des mod√®les qui permettent de le faire tout simplement.  Mais ils exigent que toutes les actions sur l'√©tat partag√© soient ordonn√©es. <br><br>  Selon la propri√©t√© <i>SO</i> - si toutes les actions du programme sont <i>SA,</i> nous atteindrons notre objectif.  C'est-√†-dire  nous pouvons d√©finir un <i>modificateur volatile</i> pour toutes les variables et nous pouvons utiliser un mod√®le d'alternance.  Si l'intuition vous dit que cela n'en vaut pas la peine, alors vous avez absolument raison.  Avec ces actions, nous interdisons simplement les optimisations sur le code, bien s√ªr, parfois c'est une bonne option, mais ce n'est certainement pas un cas g√©n√©ral. <br><br>  Consid√©rons une autre commande Synchronizes-With Order ( <i>SW</i> ) - SO pour des paires sp√©cifiques de d√©verrouillage / verrouillage, d'√©criture / lecture volatiles.  Peu importe le flux de ces actions, l'essentiel est qu'elles soient sur le m√™me moniteur, variable volatile.  <i>SW</i> fournit un pont entre les threads. <br><br>  Et maintenant, nous arrivons √† l'ordre le plus int√©ressant - Happens-before ( <i>HB</i> ). <br>  <i>HB</i> est une fermeture transitive de l'union de <i>SW</i> et <i>PO</i> .  <i>PO</i> donne un ordre lin√©aire dans le flux, et <i>SW</i> fournit un pont entre les flux.  <i>HB est</i> transitif, c'est-√†-dire  si <br><br><pre> <code class="plaintext hljs">x HB y  y HB z,  x HB z</code> </pre> <br>  La sp√©cification a une liste de relations <i>HB</i> , vous pouvez vous familiariser avec elle plus en d√©tail, voici une partie de la liste: <br><br>  Dans un seul thread, toute op√©ration se produit avant par toute op√©ration qui la suit dans le code source. <br><br>  La sortie d'un bloc / d'une m√©thode synchronis√©e se produit avant d'entrer un bloc / une m√©thode synchronis√©e sur le m√™me moniteur. <br><br>  L'√©criture d'un champ <i>volatile</i> se produit avant de lire le m√™me champ <i>volatile</i> . <br><br>  Revenons √† notre exemple: <br><br><pre> <code class="plaintext hljs">P: a = 1 PO x = b Q: b = 1 PO y = a</code> </pre> <br>  Revenons √† notre exemple et essayons d'analyser le programme en tenant compte des commandes. <br><br>  L'analyse du programme √† l'aide de JMM est bas√©e sur la proposition d'hypoth√®ses et leur confirmation ou r√©futation. <br><br><img src="https://habrastorage.org/webt/pu/hy/nz/puhynztfclug7afvnbpfht54wsg.png"><br><br>  Nous commen√ßons notre analyse avec l'hypoth√®se que pas une seule ex√©cution de programme ne donne le r√©sultat (0, 0).  L'absence de r√©sultat (0, 0) sur toutes les ex√©cutions est une propri√©t√© suppos√©e du programme. <br><br>  Nous testons l'hypoth√®se en construisant diff√©rentes ex√©cutions. <br><br>  J'ai rep√©r√© la nomenclature <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> (parfois il appara√Æt au lieu de <code>‚Ä¶</code> mot <code>race</code> avec une fl√®che, Alexey lui-m√™me utilise la fl√®che et le mot race dans ses rapports, mais avertit que cet ordre n'existe pas dans JMM et utilise cette notation pour plus de clart√©). <br><br>  Nous faisons une petite r√©servation. <br><br>  Puisque toutes les actions sur des variables communes sont importantes pour nous, et dans l'exemple, les variables communes sont <i>a, b, x, y</i> .  Ensuite, par exemple, l'op√©ration x = b doit √™tre consid√©r√©e comme r (b) et w (x, b), et <code>r(b) HB w(x,b)</code> (bas√© sur <i>PO</i> ).  Mais comme la variable x n'est lue nulle part dans les threads (la lecture imprim√©e √† la fin du code n'est pas int√©ressante, car apr√®s l'op√©ration de jointure sur le thread nous verrons la valeur x), nous ne pouvons pas consid√©rer l'action w (x, b). <br><br>  V√©rifiez la premi√®re repr√©sentation. <br><br><pre> <code class="plaintext hljs">w(a, 1) HB r(b): 0 ‚Ä¶ w(b, 1) HB r(a): 0</code> </pre> <br>  Dans le flux <i>Q,</i> on lit la variable a, on √©crit sur cette variable dans le flux <i>P.</i>  Il n'y a pas d'ordre entre l'√©criture et la lecture <i>(PO, SW, HB)</i> . <br><br>  Si la variable est √©crite dans un thread et que la lecture est dans un autre thread et qu'il n'y a pas de relation <i>HB</i> entre les op√©rations, alors ils disent que la variable est lue sous la race.  Et selon la course selon JMM, nous pouvons lire soit la derni√®re valeur enregistr√©e dans <i>HB</i> , soit toute autre valeur. <br><br>  Une telle performance est possible.  L'ex√©cution <b>ne viole pas JMM</b> .  Lors de la lecture de la variable a, vous pouvez voir n'importe quelle valeur, car la lecture a lieu sous la course et il n'y a aucune garantie que nous verrons l'action w (a, 1).  Cela ne signifie pas que le programme fonctionne correctement, cela signifie simplement qu'un tel r√©sultat est attendu. <br><br>  Cela n'a aucun sens de consid√©rer le reste de l'ex√©cution, car l' <b>hypoth√®se est d√©j√† d√©truite</b> . <br><br>  JMM dit que si le programme n'a pas de race de donn√©es, toutes les ex√©cutions peuvent √™tre consid√©r√©es comme s√©quentielles.  D√©barrassons-nous de la course, pour cela, nous devons rationaliser les op√©rations de lecture et d'√©criture dans diff√©rents threads.  Il est important de comprendre qu'un programme multithread, contrairement √† un programme s√©quentiel, a plusieurs ex√©cutions.  Et pour dire qu'un programme a une propri√©t√©, il est n√©cessaire de prouver que le programme a cette propri√©t√© non pas sur l'une des ex√©cutions, mais sur toutes les ex√©cutions. <br><br>  Pour prouver que le programme n'est pas une course, vous devez le faire pour toutes les performances.  Essayons de cr√©er <i>SA</i> et marquons la variable a avec un <i>modificateur volatile</i> .  <i>Les</i> variables <i>volatiles</i> seront pr√©fix√©es par v. <br><br>  Nous proposons <b>une nouvelle hypoth√®se</b> .  Si la variable a est rendue <i>volatile</i> , alors aucune ex√©cution du programme ne donnera le r√©sultat (0, 0). <br><br><pre> <code class="plaintext hljs">w(va, 1) HB r(b): 0 ‚Ä¶ w(b, 1) HB r(va): 0</code> </pre> <br>  L'ex√©cution <b>ne viole pas JMM</b> .  La lecture va se passe sous la course.  Toute race d√©truit la transitivit√© de HB. <br><br>  Nous proposons <b>une autre hypoth√®se</b> .  Si la variable b est rendue <i>volatile</i> , aucune ex√©cution du programme ne donnera le r√©sultat (0, 0). <br><br><pre> <code class="plaintext hljs">w(a, 1) HB r(vb): 0 ‚Ä¶ w(vb, 1) HB r(a): 0</code> </pre> <br>  L'ex√©cution ne viole pas JMM.  La lecture d'un a lieu sous la course. <br><br>  Testons <b>l'hypoth√®se</b> que si les variables a et b sont <i>volatiles</i> , alors aucune ex√©cution de programme ne donnera le r√©sultat (0, 0). <br><br>  V√©rifiez la premi√®re repr√©sentation. <br><br><pre> <code class="plaintext hljs">w(va, 1) SO r(vb): 0 SO w(vb, 1) SO r(va): 0</code> </pre> <br>  Puisque toutes les actions du programme <i>SA</i> (en particulier la lecture ou l'√©criture d'une variable <i>volatile</i> ), nous obtenons l'ordre <i>SO</i> complet entre toutes les actions.  Cela signifie que r (va) devrait voir w (va, 1).  Cette <b>ex√©cution viole JMM</b> . <br><br>  Il est n√©cessaire de proc√©der √† la prochaine ex√©cution afin de confirmer l'hypoth√®se.  Mais comme il y aura <i>SO</i> pour toute ex√©cution, vous pouvez d√©vier du formalisme - il est √©vident que le r√©sultat (0, 0) viole le JMM pour toute ex√©cution. <br><br>  Pour utiliser le mod√®le de rotation, vous devez ajouter <i>volatile</i> pour les variables a et b.  Un tel programme donnera les r√©sultats (1,1), (1,0) ou (0,1). <br><br>  Au final, on peut dire que des programmes tr√®s simples sont assez simples √† analyser. <br><br>  Mais les programmes complexes avec un grand nombre d'ex√©cutions et de donn√©es partag√©es sont difficiles √† analyser, car vous devez v√©rifier toutes les ex√©cutions. <br><br><h2>  Autres mod√®les d'ex√©cution comp√©titifs </h2><br>  Pourquoi envisager d'autres mod√®les de programmation comp√©titifs? <br><br>  L'utilisation de threads et de primitives de synchronisation peut r√©soudre tous les probl√®mes.  Tout cela est vrai, mais le probl√®me est que nous avons examin√© un exemple d'une douzaine de lignes de code, o√π 4 lignes de code font un travail utile. <br><br>  Et l√†, nous avons rencontr√© un tas de questions, au point que sans la sp√©cification, nous ne pourrions m√™me pas calculer correctement tous les r√©sultats possibles.  Les threads et les primitives de synchronisation sont une chose tr√®s difficile, dont l'utilisation est certainement justifi√©e dans certains cas.  Fondamentalement, ces cas sont li√©s aux performances. <br><br>  D√©sol√©, je me r√©f√®re beaucoup √† Elizarov, mais que puis-je faire si une personne a vraiment de l'exp√©rience dans ce domaine.  Donc, il a un autre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapport</a> merveilleux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">,</a> "Des millions de citations par seconde en Java pur", dans lequel il dit qu'un √©tat immuable est bon, mais je ne copierai pas mes millions de citations dans chaque flux, d√©sol√©.  Mais tous n'ont pas des millions de citations, beaucoup ont bien s√ªr des t√¢ches plus modestes.  Existe-t-il des mod√®les de programmation comp√©titifs qui vous permettent d'oublier JMM tout en √©crivant du code s√ªr et comp√©titif? <br><br>  Si vous √™tes vraiment int√©ress√© par cette question, je recommande fortement le livre de Paul Butcher, ¬´Seven Models of Competition in Seven Weeks.  Nous d√©voilons les secrets des flux. ‚Äù  Malheureusement, il n'a pas √©t√© possible de trouver suffisamment d'informations sur l'auteur, mais le livre devrait vous ouvrir les yeux sur de nouveaux paradigmes.  Malheureusement, je n'ai pas d'exp√©rience avec de nombreux autres mod√®les de comp√©tition, j'ai donc re√ßu la critique de ce livre. <br><br>  R√©pondre √† la question ci-dessus.  √Ä ma connaissance, il existe des mod√®les de programmation comp√©titifs qui peuvent au moins r√©duire consid√©rablement le besoin de conna√Ætre les nuances de JMM.  Cependant, s'il y a un √©tat et des flux mutables, ne visser aucune abstraction dessus, il y aura toujours un endroit o√π ces flux devraient synchroniser l'acc√®s √† l'√©tat.  Une autre question est que vous n'avez probablement pas √† synchroniser l'acc√®s vous-m√™me, par exemple, un framework peut r√©pondre √† cela.  Mais comme nous l'avons dit, t√¥t ou tard, l'abstraction peut se produire. <br><br>  Vous pouvez exclure tout √©tat mutable.  Dans le monde de la programmation fonctionnelle, c'est une pratique normale.  S'il n'y a pas de structures mutables, alors il n'y aura probablement pas de probl√®mes avec la m√©moire partag√©e par d√©finition.  Il existe des repr√©sentants de langages fonctionnels sur la machine virtuelle Java, tels que Clojure.  Clojure est un langage fonctionnel hybride, car il vous permet toujours de modifier les structures de donn√©es, mais fournit des outils plus efficaces et plus s√ªrs pour cela. <br><br>  Les langages fonctionnels sont un excellent outil pour travailler avec du code concurrentiel.  Personnellement, je ne l'utilise pas, car mon domaine d'activit√© est le d√©veloppement mobile, et l√†, il n'est tout simplement pas courant.  Bien que certaines approches puissent √™tre adopt√©es. <br><br>  Une autre fa√ßon de travailler avec des donn√©es mutables est d'emp√™cher le partage de donn√©es.  Les acteurs sont un tel mod√®le de programmation.  Les acteurs simplifient la programmation en ne permettant pas l'acc√®s simultan√© aux donn√©es.  Ceci est r√©alis√© par le fait qu'une fonction qui effectue un travail √† un moment donn√© peut fonctionner dans un seul thread. <br><br>  Cependant, un acteur peut changer l'√©tat interne.  √âtant donn√© qu'√† l'instant suivant, le m√™me acteur peut √™tre ex√©cut√© sur un autre thread, cela peut √™tre un probl√®me.  Le probl√®me peut √™tre r√©solu de diff√©rentes mani√®res, dans des langages de programmation tels que Erlang ou Elixir, o√π le mod√®le d'acteur fait partie int√©grante du langage, vous pouvez utiliser la r√©cursivit√© pour appeler un acteur avec un nouvel √©tat. <br><br>  √Ä Java, les r√©cursions peuvent √™tre trop ch√®res.  Cependant, en Java, il existe des cadres pour un travail pratique avec ce mod√®le, probablement le plus populaire est Akka.  Les d√©veloppeurs d'Akka se sont occup√©s de tout, vous pouvez aller √† la section de documentation d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Akka et du mod√®le de m√©moire Java</a> et lire deux cas o√π l'acc√®s √† un √©tat partag√© peut se produire √† partir de diff√©rents threads.  Mais plus important encore, la documentation indique quels √©v√©nements sont li√©s √† ¬´ce qui s'est pass√© avant¬ª.  C'est-√†-dire  cela signifie que nous pouvons changer l'√©tat de l'acteur autant que nous le souhaitons, mais lorsque nous recevons le message suivant et le traitons √©ventuellement dans un autre thread, nous sommes garantis de voir toutes les modifications apport√©es dans un autre thread. <br><br><h2>  Pourquoi le mod√®le de filetage est-il si populaire? </h2><br>  Nous avons examin√© deux mod√®les de programmation comp√©titive, en fait il y en a encore plus qui rendent la programmation comp√©titive plus facile et plus s√ªre. <br><br>  Mais pourquoi alors les fils et les serrures sont-ils toujours aussi populaires? <br><br>  Je pense que la raison est la simplicit√© de l'approche, bien s√ªr, d'une part, il est facile de faire de nombreuses erreurs non √©videntes avec les ruisseaux, de se tirer une balle dans le pied, etc.  Mais d'un autre c√¥t√© <b>, il n'y a rien de compliqu√© dans les flux, surtout si l'on ne pense pas aux cons√©quences</b> . <br><br>  √Ä un moment donn√©, le noyau peut ex√©cuter une instruction (en fait non, la concurrence existe au niveau de l'instruction, mais maintenant cela n'a plus d'importance), mais en raison du multit√¢che, m√™me sur des machines monoc≈ìur, plusieurs programmes peuvent √™tre ex√©cut√©s simultan√©ment (bien s√ªr pseudo simultan√©ment). <br><br>  Pour que le multit√¢che fonctionne, vous avez besoin de concurrence.  Comme nous l'avons d√©j√† compris, la concurrence est impossible sans plusieurs flux de gestion. <br><br>  Combien de threads pensez-vous qu'un programme qui s'ex√©cute sur un processeur de t√©l√©phone portable quadric≈ìur doit √™tre aussi rapide et r√©actif que possible? <br><br>  Il peut y en avoir plusieurs dizaines.  Maintenant, la question est, pourquoi avons-nous besoin d'autant de threads pour un programme qui s'ex√©cute sur du mat√©riel qui vous permet d'ex√©cuter seulement 2 √† 4 threads √† la fois? <br><br>  Pour essayer de r√©pondre √† cette question, supposons que seul notre programme fonctionne sur l'appareil et rien d'autre.  Comment g√©rerions-nous les ressources qui nous sont fournies? <br><br>  Vous pouvez donner un noyau pour l'interface utilisateur, le reste du noyau pour toute autre t√¢che.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si l'un des threads est bloqu√©, par exemple, le thread peut aller au contr√¥leur de m√©moire et attendre une r√©ponse, alors nous obtiendrons un noyau bloqu√©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelles technologies sont l√† pour r√©soudre le probl√®me? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe des threads en Java, nous pouvons cr√©er de nombreux threads, puis d'autres threads pourront effectuer des op√©rations pendant que certains threads sont bloqu√©s. Avec un outil comme les fils, nous pouvons simplifier nos vies. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'approche avec les threads n'est pas gratuite, la cr√©ation de threads prend g√©n√©ralement du temps (c'est d√©cid√© par les pools de threads), de la m√©moire leur est allou√©e, la commutation entre les threads est une op√©ration co√ªteuse. Mais il est relativement facile de programmer avec eux, c'est donc une technologie massive qui est si largement utilis√©e dans les langages g√©n√©raux, comme Java.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java aime g√©n√©ralement les threads, il n'est pas n√©cessaire de cr√©er pour chaque action un thread, il existe des √©l√©ments de niveau sup√©rieur, tels que les ex√©cuteurs, qui vous permettent de travailler avec des pools et d'√©crire du code plus √©volutif et flexible. Les flux sont vraiment pratiques, vous pouvez faire une demande de blocage au r√©seau et √©crire le traitement des r√©sultats sur la ligne suivante. M√™me si nous attendons quelques secondes le r√©sultat, nous pouvons encore effectuer d'autres t√¢ches, car le syst√®me d'exploitation se chargera de la r√©partition du temps processeur entre les threads. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les flux sont populaires non seulement dans le d√©veloppement backend, dans le d√©veloppement mobile, il est consid√©r√© comme tout √† fait normal de cr√©er des dizaines de flux afin que vous puissiez bloquer un flux pendant quelques secondes, en attendant que les donn√©es soient t√©l√©charg√©es sur le r√©seau ou les donn√©es du socket.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des langues comme Erlang ou Clojure sont encore des niches, et donc les mod√®les de programmation comp√©titifs qu'ils utilisent ne sont pas si populaires. </font><font style="vertical-align: inherit;">Cependant, leurs pr√©visions sont les plus optimistes.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclusions </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous d√©veloppez sur la plateforme JVM, vous devez accepter les r√®gles du jeu indiqu√©es par la plateforme. </font><font style="vertical-align: inherit;">C'est le seul moyen d'√©crire du code multithread normal. </font><font style="vertical-align: inherit;">Il est tr√®s souhaitable de comprendre le contexte de tout ce qui se passe, il sera donc plus facile d'accepter les r√®gles du jeu. </font><font style="vertical-align: inherit;">C‚Äôest encore mieux de regarder autour de vous et de vous familiariser avec d‚Äôautres paradigmes, bien que vous ne puissiez pas vous √©loigner du sous-marin, mais vous pouvez d√©couvrir de nouvelles approches et de nouveaux outils.</font></font><br><br><h2>  Mat√©riel suppl√©mentaire </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai essay√© de placer dans le texte de l'article des liens vers des sources dont j'ai obtenu des informations. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En g√©n√©ral, le mat√©riel JMM est facile √† trouver sur Internet. </font><font style="vertical-align: inherit;">Ici, je publierai des liens vers du mat√©riel suppl√©mentaire associ√© √† JMM et peut ne pas attirer imm√©diatement mon attention. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La lecture</font></font></b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le blog d'Alexey Shipilev</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Je sais ce qui est √©vident, mais c'est juste un p√©ch√© sans parler</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le blog de Cheremin Ruslan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - il n'a pas √©crit activement ces derniers temps, vous devez rechercher ses anciennes entr√©es dans le blog, croyez-moi, √ßa vaut le coup - il y a une source</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habr Gleb Smirnov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - il existe d'excellents articles sur le multithreading et le mod√®le de m√©moire</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le blog de Roman Elizarov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est abandonn√©, mais des fouilles arch√©ologiques doivent √™tre effectu√©es. </font><font style="vertical-align: inherit;">En g√©n√©ral, Roman a fait beaucoup pour √©duquer les gens √† la th√©orie de la programmation multithread, recherchez-la dans les m√©dias.</font></font></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podcasts</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Probl√®mes que j'ai trouv√©s particuli√®rement int√©ressants. </font><font style="vertical-align: inherit;">Ils ne concernent pas JMM, ils concernent l'enfer, ce qui se passe dans la glande. </font><font style="vertical-align: inherit;">Mais apr√®s les avoir √©cout√©s, je veux embrasser les cr√©ateurs de JMM, qui nous ont prot√©g√©s de tout cela.</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDCast # 62</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Away Alexander Titov et Amir Ayupov, ing√©nieurs Intel et Alexei Markin, programmeur de ICST</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDCast # 63</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Away Alexei Markin, programmeur de ICST</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©briefing: # 107 Histoires de grimpeurs</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©briefing: # 154 Guts - Attaque du Nouvel An</font></font></a> <br></li></ul><br>  <b>Vid√©o</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En plus des discours des personnes susmentionn√©es, faites attention √† la vid√©o acad√©mique. </font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Computer Science Center ‚Äî  11.     </a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">    </a> <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr440590/">https://habr.com/ru/post/fr440590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr440576/index.html">Modifications importantes apport√©es √† CTE dans PostgreSQL 12</a></li>
<li><a href="../fr440582/index.html">Les voitures √©lectriques sont-elles tir√©es vers le bas de la soci√©t√© automobile?</a></li>
<li><a href="../fr440584/index.html">Quel est le probl√®me avec le Raspberry Pi</a></li>
<li><a href="../fr440586/index.html">Exonum Consensus: Comment √ßa marche</a></li>
<li><a href="../fr440588/index.html">Le MIT a appris √† transmettre le son avec un laser</a></li>
<li><a href="../fr440592/index.html">Cr√©ation d'un jeu AR avec Vuforia</a></li>
<li><a href="../fr440594/index.html">1C et Yandex. Cloud Compute Cloud. De haut en bas</a></li>
<li><a href="../fr440596/index.html">Flightradar24 - comment √ßa marche?</a></li>
<li><a href="../fr440598/index.html">La sonde martienne InSight fonctionne avec succ√®s sur la plan√®te rouge</a></li>
<li><a href="../fr440600/index.html">Combien de noms de domaine .com ne sont pas utilis√©s?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>