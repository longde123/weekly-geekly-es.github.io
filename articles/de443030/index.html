<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë≤üèø üèä üëò Einfachste Speicherprofilerstellung auf STM32 und anderen Mikrocontrollern üôçüèª ü§ô üöè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Mit der Erfahrung kommt ein wissenschaftlicher Standardansatz zur Berechnung der richtigen Stapelgr√∂√üe: Nehmen Sie eine Zufallszahl und hoffen Sie au...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einfachste Speicherprofilerstellung auf STM32 und anderen Mikrocontrollern</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443030/"> <i>"Mit der Erfahrung kommt ein wissenschaftlicher Standardansatz zur Berechnung der richtigen Stapelgr√∂√üe: Nehmen Sie eine Zufallszahl und hoffen Sie auf das Beste."</i> <i><br></i>  <i>- Jack Ganssle, ‚ÄûDie Kunst, eingebettete Systeme zu entwerfen‚Äú</i> <br><br>  Hallo Habr! <br><br>  So seltsam es auch scheinen mag, bei der √ºberwiegenden Mehrheit der ‚ÄûSTM32-Primer‚Äú, die ich im Besonderen gesehen habe, und bei Mikrocontrollern im Allgemeinen gibt es im Allgemeinen nichts √ºber Speicherzuweisung, Stapelplatzierung und vor allem das Verhindern eines Speicher√ºberlaufs - als Folge davon Ein Bereich franst einen anderen aus und alles bricht zusammen, normalerweise mit bezaubernden Effekten. <br><br>  Dies ist teilweise auf die Einfachheit von Schulungsprojekten zur√ºckzuf√ºhren, die auf Debug-Boards mit relativ fettigen Mikrocontrollern durchgef√ºhrt werden, bei denen es schwierig ist, durch Blinken einer LED in einen Speichermangel zu geraten. In letzter Zeit werden jedoch selbst f√ºr Anf√§nger-Amateure immer h√§ufiger Verweise auf Controller vom Typ STM32F030F4P6 verwendet. , einfach zu installieren, einen Cent wert, aber auch mit einer Speichereinheit von Kilobyte. <br><br>  Mit solchen Controllern k√∂nnen Sie ganz ernsthafte Dinge f√ºr sich selbst tun (nun, hier wurde zum Beispiel eine so <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vollst√§ndig geeignete Messung</a> f√ºr uns am STM32F042K6T6 mit 6 KB RAM durchgef√ºhrt, von dem etwas mehr als 100 Bytes frei bleiben), aber wenn Sie mit Speicher arbeiten, ben√∂tigen Sie eine bestimmte Menge an Speicher Ordentlichkeit. <br><br>  Ich m√∂chte √ºber diese Genauigkeit sprechen.  Der Artikel wird kurz sein, Profis werden nichts Neues lernen - aber f√ºr Anf√§nger ist dieses Wissen sehr zu empfehlen. <br><br><a name="habracut"></a>  In einem typischen Projekt auf einem Mikrocontroller, der auf einem Cortex-M-Kern basiert, ist RAM in vier Abschnitte unterteilt: <br><br><ul><li>  Daten - Daten, die durch einen bestimmten Wert initialisiert wurden </li><li>  bss - Daten auf Null initialisiert </li><li>  heap - heap (dynamischer Bereich, aus dem der Speicher explizit mit malloc zugewiesen wird) </li><li>  Stack - der Stack (der dynamische Bereich, aus dem der Compiler implizit Speicher zuweist) </li></ul><br>  Der noinit-Bereich kann auch gelegentlich auftreten (nicht initialisierte Variablen - sie sind praktisch, da sie den Wert zwischen Neustarts beibehalten), noch seltener einige andere Bereiche, die f√ºr bestimmte Aufgaben zugewiesen sind. <br><br>  Sie befinden sich auf eine bestimmte Art und Weise im physischen Speicher - Tatsache ist, dass der Stapel in Mikrocontrollern auf ARM-Kernen von oben nach unten w√§chst.  Daher befindet es sich getrennt von den verbleibenden Speicherbl√∂cken am Ende des RAM: <br><br><img src="https://habrastorage.org/webt/so/mq/xc/somqxc24t6u7_f2ol0baenjtoqi.jpeg"><br><br>  Standardm√§√üig entspricht seine Adresse normalerweise der neuesten RAM-Adresse, und von dort aus sinkt sie mit zunehmendem Wachstum - und ein √§u√üerst unangenehmes Merkmal des Stapels w√§chst daraus heraus: Er kann bss erreichen und seine Oberseite neu schreiben, und Sie wissen nichts explizites dar√ºber. <br><br><h4>  Statische und dynamische Speicherbereiche </h4><br>  Der gesamte Speicher ist in zwei Kategorien unterteilt - statisch zugeordnet, d. H.  Speicher, dessen Gesamtmenge aus dem Programmtext ersichtlich ist und nicht von der Reihenfolge seiner Ausf√ºhrung abh√§ngt, und dynamisch zugewiesen wird, dessen erforderliches Volumen vom Fortschritt des Programms abh√§ngt. <br><br>  Letzteres beinhaltet einen Haufen (von dem wir mit malloc Brocken nehmen und mit free zur√ºckgeben) und einen Stapel, der von selbst w√§chst und schrumpft. <br><br>  Im Allgemeinen wird von der Verwendung von malloc auf Mikrocontrollern <b>dringend abgeraten, es</b> sei denn, Sie wissen genau, was Sie tun.  Das Hauptproblem, das sie mit sich bringen, ist die Speicherfragmentierung. Wenn Sie 10 Teile zu je 10 Bytes zuweisen und dann jede Sekunde frei werden, erhalten Sie keine 50 Bytes frei.  Sie erhalten 5 kostenlose St√ºcke zu je 10 Bytes. <br><br>  Dar√ºber hinaus kann der Compiler in der Phase des Kompilierens des Programms nicht automatisch bestimmen, wie viel Speicher Ihr Malloc ben√∂tigt (insbesondere unter Ber√ºcksichtigung der Fragmentierung, die nicht nur von der Gr√∂√üe der angeforderten Teile, sondern auch von der Reihenfolge ihrer Zuordnung und Ver√∂ffentlichung abh√§ngt), und kann Sie daher nicht warnen wenn am Ende nicht genug Speicher vorhanden ist. <br><br>  Es gibt Methoden, um dieses Problem zu umgehen - spezielle Malloc-Implementierungen, die in einem statisch zugewiesenen Bereich und nicht im gesamten RAM funktionieren, sorgf√§ltige Verwendung von Malloc unter Ber√ºcksichtigung einer m√∂glichen Fragmentierung auf Programmlogikebene usw.  - aber im Allgemeinen ist <b>Malloc besser nicht zu ber√ºhren</b> . <br><br>  Alle Speicherbereiche mit Grenzen und Adressen werden in einer Datei mit der Erweiterung .LD registriert, an der sich der Linker beim Erstellen des Projekts orientiert. <br><br><h4>  Statisch zugeordneter Speicher </h4><br>  Aus dem statisch zugewiesenen Speicher haben wir also zwei Bereiche - bss und data, die sich nur formal unterscheiden.  Wenn das System initialisiert wird, wird der Datenblock aus dem Flash kopiert, wo die erforderlichen Initialisierungswerte daf√ºr gespeichert werden. Der bss-Block wird einfach mit Nullen gef√ºllt (zumindest das F√ºllen mit Nullen wird als gute Form angesehen). <br><br>  Beide Dinge - das Kopieren von einem Flash und das F√ºllen mit Nullen - werden im Programmcode <i>in einer expliziten Form ausgef√ºhrt</i> , jedoch nicht in Ihrem main (), sondern in einer separaten Datei, die zuerst ausgef√ºhrt wird. Sie wird einmal geschrieben und einfach von Projekt zu Projekt gezogen. <br><br>  Dies interessiert uns jedoch nicht jetzt - sondern wie wir verstehen werden, ob unsere Daten √ºberhaupt in den RAM unseres Controllers passen. <br><br>  Es wird sehr einfach - vom Dienstprogramm arm-none-eabi-size mit einem einzigen Parameter - die kompilierte ELF-Datei unseres Programms erkannt (h√§ufig wird ihr Aufruf am Ende des Makefiles eingef√ºgt, weil es praktisch ist): <br><br><img src="https://habrastorage.org/webt/sz/nh/kg/sznhkgwspg27prcbdikvnkzv98c.png"><br><br>  Hier ist Text die Menge der Programmdaten, die im Flash liegen, und bss und Daten sind unsere statisch zugewiesenen Bereiche im RAM.  Die letzten beiden Spalten st√∂ren uns nicht - dies ist die Summe der ersten drei, es hat keine praktische Bedeutung. <br><br>  Insgesamt ben√∂tigen wir statisch im RAM bss + Datenbytes, in diesem Fall 5324 Bytes.  Der Controller hat 6144 Bytes RAM, wir verwenden kein Malloc, 820 Bytes bleiben √ºbrig. <br><br>  Welches sollte f√ºr uns auf dem Stapel genug sein. <br><br>  Aber genug?  Wenn nicht, w√§chst unser Stack zu unseren eigenen Daten, und zuerst werden die Daten √ºberschrieben, dann werden die Daten √ºberschrieben, und dann st√ºrzt alles ab.  Dar√ºber hinaus kann das Programm zwischen dem ersten und dem zweiten Punkt weiterarbeiten, ohne zu bemerken, dass die von ihm verarbeiteten Daten M√ºll enthalten.  Im schlimmsten Fall sind es die Daten, die Sie notiert haben, als alles in Ordnung mit dem Stapel war, und jetzt lesen Sie einfach - zum Beispiel die Kalibrierungsparameter eines Sensors - und dann haben Sie keine offensichtliche M√∂glichkeit zu verstehen, dass mit ihnen alles schlecht ist. Dieses Programm l√§uft weiter, als w√§re nichts passiert, und Sie erhalten M√ºll an der Ausgabe. <br><br><h4>  Dynamisch zugeordneter Speicher </h4><br>  Und hier beginnt der interessanteste Teil: Wenn Sie die Geschichte auf einen Satz reduzieren, ist es <i>fast unm√∂glich, die Gr√∂√üe des Stapels im Voraus zu bestimmen</i> . <br><br>  <i>Theoretisch</i> k√∂nnen Sie den Compiler auffordern, die von jeder einzelnen Funktion verwendete Stapelgr√∂√üe anzugeben, ihn dann auffordern, den Ausf√ºhrungsbaum Ihres Programms zur√ºckzugeben, und f√ºr jeden Zweig darin die Summe der Stapel aller in diesem Baum vorhandenen Funktionen berechnen.  Dies allein f√ºr ein mehr oder weniger komplexes Programm nimmt Ihnen viel Zeit in Anspruch. <br><br>  Dann erinnern Sie sich, dass jederzeit eine Unterbrechung auftreten kann, deren Prozessor ebenfalls Speicher ben√∂tigt. <br><br>  Dann - dass zwei oder drei verschachtelte Interrupts auftreten k√∂nnen, deren Handler ... <br><br>  Im Allgemeinen verstehen Sie.  Der Versuch, den Stapel f√ºr ein bestimmtes Programm zu z√§hlen, ist eine aufregende und allgemein n√ºtzliche Aktivit√§t, die Sie jedoch h√§ufig nicht ausf√ºhren. <br><br>  In der Praxis wird daher eine Technik verwendet, mit der Sie zumindest irgendwie verstehen k√∂nnen, ob sich alles in unserem Leben gut entwickelt - das sogenannte ‚ÄûMemory Painting‚Äú (Memory Painting). <br><br>  Bei dieser Methode ist es praktisch, dass sie nicht von den von Ihnen verwendeten Debugging-Tools abh√§ngt. Wenn das System √ºber mindestens einige Mittel zur Ausgabe von Informationen verf√ºgt, k√∂nnen Sie √ºberhaupt auf Debugging-Tools verzichten. <br><br>  Das Wesentliche ist, dass wir das gesamte Array vom Ende von bss bis zum Anfang des Stapels irgendwo in der sehr fr√ºhen Phase der Programmausf√ºhrung f√ºllen, wenn der Stapel noch genau klein ist, mit demselben Wert. <br><br>  Wenn wir √ºberpr√ºfen, an welcher Adresse dieser Wert bereits verschwunden ist, verstehen wir, wo der Stapel gefallen ist.  Da die gel√∂schte Farbe selbst nicht wiederhergestellt werden kann, kann die √úberpr√ºfung sporadisch durchgef√ºhrt werden - es wird die maximal erreichte Stapelgr√∂√üe angezeigt. <br><br>  Definieren Sie die Farbe der Farbe - der spezifische Wert spielt keine Rolle, unten habe ich nur mit zwei Fingern meiner linken Hand getippt.  Die Hauptsache ist, nicht 0 und FF zu w√§hlen: <br><br><pre><code class="cpp">#define STACK_CANARY_WORD (0xCACACACAUL)</code></pre><br>
 -  ,    -,      :<br>
<br>
<pre><code class="cpp">volatile unsigned *top, *start;
__asm__ volatile ("mov %[top], sp" : [top] "=r" (top) : : );
start = &amp;_ebss;
while (start &lt; top) {
    *(start++) = STACK_CANARY_WORD;
}</code></pre><br>
   ?     top ,     ‚Äî&nbsp;    ;   start ‚Äî&nbsp;   bss (,    ,  <a href="">    *.ld</a> ‚Äî       libopencm3).        bss        .<br>
<br>
        :<br>
<br>
<pre><code class="cpp">unsigned check_stack_size(void) {
    /* top of data section */
    unsigned *addr = &amp;_ebss;

    /* look for the canary word till the end of RAM */
    while ((addr &lt; &amp;_stack) &amp;&amp; (*addr == STACK_CANARY_WORD)) {
        addr++;
    }
    
    return ((unsigned)&amp;_stack - (unsigned)addr);
}</code></pre><br>
  _ebss   ,   _stack ‚Äî&nbsp; <a href="">   </a>,       ,  ,   ,   .<br>
<br>
        .<br>
<br>
    ‚Äî -      check_stack_size()      ,        ,        ,    .<br>
<br>
    .<br>
<br>
            712  ‚Äî      6          108 .<br>
<br>
<h4>Word of caution</h4><br>
     ‚Äî , ,   100-% .    ,  <i> </i>  , , ,   ,      . ,          ,       -,       10-20 %,      108         .<br>
<br>
     ,              ,                ,            .<br>
<br>
P.S.     RTOS      ‚Äî    MSP,      ,     PSP.     ,          ‚Äî        .</div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443030/">https://habr.com/ru/post/de443030/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443020/index.html">Das erste Videospiel meiner und meiner Freundin. Entwicklung mit Einheit. Teil 1</a></li>
<li><a href="../de443022/index.html">Rosserial & STM32</a></li>
<li><a href="../de443024/index.html">ITMO University Digest: 12 thematische Konferenzen, Hackathons und MOOC-Kurse f√ºr IT-Studenten</a></li>
<li><a href="../de443026/index.html">Zugangskontrolle und womit es gegessen wird</a></li>
<li><a href="../de443028/index.html">Digitale Veranstaltungen in Moskau vom 11. bis 17. M√§rz</a></li>
<li><a href="../de443032/index.html">Webkomponenten in der realen Welt</a></li>
<li><a href="../de443034/index.html">Neue Tesla-Ladestationen: Laden Sie den Akku in 5 Minuten f√ºr 120 Kilometer auf</a></li>
<li><a href="../de443038/index.html">Wenn Sekundenkleber ins Auge gelangt</a></li>
<li><a href="../de443040/index.html">7 Hauptgr√ºnde, warum Anwendungen in Google Play und AppStore blockiert werden</a></li>
<li><a href="../de443042/index.html">Start von 619.000 Tetris auf GLSL, deren Rendering und einem einfachen Bot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>