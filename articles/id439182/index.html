<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👶🏻 🛢️ 🏂 Bagaimana kami mendistribusikan pesanan antar driver di Yandex.Taxi 🚪 👨‍👩‍👦 🎛️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salah satu tugas utama di Yandex.Taxi adalah bagaimana memastikan bahwa mobil tiba dengan cepat kepada pengguna, dan waktu pengemudi untuk "idle run" ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kami mendistribusikan pesanan antar driver di Yandex.Taxi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/439182/"><img src="https://habrastorage.org/webt/5h/l9/th/5hl9thxhtitxpaufvidq23vkycy.png" alt="gambar"><br><br>  Salah satu tugas utama di Yandex.Taxi adalah bagaimana memastikan bahwa mobil tiba dengan cepat kepada pengguna, dan waktu pengemudi untuk "idle run" berkurang (yaitu, waktu ketika ia berada di telepon tanpa penumpang).  Tampaknya semuanya sederhana: pengguna memilih tarif, menunjukkan keinginan tambahan (kursi anak, misalnya).  Tetap menyaring driver di telepon sesuai dengan kriteria ini, pilih yang terdekat dan menawarkan pesanan kepadanya.  Namun, semuanya sangat sederhana hanya pada pandangan pertama. <br><br>  Hari ini saya akan memberi tahu komunitas Habr bagaimana kita memilih driver yang paling cocok dan bagaimana proses ini telah berkembang dari waktu ke waktu.  Anda akan belajar tentang dua pendekatan untuk menyelesaikan masalah. <br><a name="habracut"></a><br><h3>  Arsitektur Pencarian Umum </h3><br>  Ketika pengguna mengklik tombol "Panggil taksi", objek pesanan dibuat di backend dan pemrosesan dimulai sesuai dengan mesin negara.  Agar perintah dapat beralih dari status "Tertunda" ke "Pengemudi telah ditetapkan", Anda harus mencari pengemudi, menawarkan pesanan kepadanya dan menunggu konfirmasi bahwa pesanan telah diterima. <br><br><img src="https://habrastorage.org/webt/fn/bq/bp/fnbqbplbhy626m7u_kxujya0zho.png" alt="gambar"><br><br><h3>  Pendekatan Serakah </h3><br>  Untuk waktu yang sangat lama, pendekatan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rakus</a> bekerja di Yandex.Taxi.  Dengan pendekatan ini, pada tahap mencari kontraktor, permintaan dibuat ke layanan tracker mikro yang bertanggung jawab untuk driver.  Pelacak tahu segalanya tentang mobil: mulai dari warna dan pencitraan merek hingga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lokasi saat ini</a> .  Tracker memiliki geo-indeks lokal untuk driver dan konektor ke layanan routing (router) untuk membangun rute dari titik A ke titik B (dan bahkan melalui titik B, D, D).  Oleh karena itu, ketika permintaan dibuat untuk mencari pengemudi, Pelacak terlebih dahulu menentukan mobil terdekat di geo-indeks lokal di sepanjang radius langsung, dengan mempertimbangkan batasan pesanan "keras" (kelas mobil, persyaratan - kursi anak, angka kuning).  Kemudian, waktu dan panjang rute pasokan kendaraan ditentukan dan, dengan mempertimbangkan informasi ini, opsi terbaik dipilih. <br><br>  Kemudian, logika ini berevolusi: untuk setiap pengemudi mereka mulai mengandalkan "skor" -nya pada urutan - fungsi waktu mobil itu dikirim.  Dan driver sudah diberi peringkat dengan nilai skor.  Fungsi ini memperhitungkan tidak hanya waktu pengiriman itu sendiri, tetapi juga banyak faktor lain: dari tingkat permintaan di titik A dan B hingga "pengalaman" pengemudi.  Janji serakah ini disebut bonus. <br><br><h3>  Pendekatan buffer (balok) </h3><br>  Namun, dengan pendekatan serakah, pengemudi terdekat akan menerima orang yang pertama kali memesan taksi.  Namun, beberapa pengguna bahkan mungkin dibiarkan tanpa mobil. <br><br><img src="https://habrastorage.org/webt/k-/gr/df/k-grdfddnk6lgvkpxylphlkcv2e.png" alt="gambar"><br><br><img src="https://habrastorage.org/webt/6b/9x/iz/6b9xizmxnoqytx90py50-8utc00.png" alt="gambar"><br><br>  Dengan meningkatnya permintaan, ketika kompetisi untuk pemain dimulai, pendekatan serakah tidak baik.  Untuk memenuhi permintaan sebanyak mungkin bahkan di jam-jam paling sibuk, kami menggunakan banyak pendekatan dan algoritma.  Salah satunya adalah penunjukan (balok) penunjukan driver pada pesanan.  Ini didasarkan pada tugas yang terkenal dari bidang optimasi kombinatorial - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah penugasan</a> .  Singkatnya, intinya: mari kita memiliki N bekerja dan berkinerja M, setiap karyawan dapat menyelesaikan tugas apa pun selama waktu p (i, j) [0 &lt;= i &lt;N, 0 &lt;= j &lt;M].  Diperlukan untuk menetapkan kontraktor tersebut untuk setiap tugas untuk mengurangi total waktu pelaksanaan semua pekerjaan (dalam hal ini, satu kontraktor hanya dapat mengambil satu pekerjaan). <br><br><img src="https://habrastorage.org/webt/fc/-k/sh/fc-kshacpkn4hy0nuwqeo1mmzik.png" alt="gambar"><img src="https://habrastorage.org/webt/fp/en/ot/fpenotm7jopgnz5ndaj3fal_jie.png" alt="gambar"><br><br>  Ketika memecahkan masalah penugasan seperti itu, "biaya" kami untuk melakukan pekerjaan (pesanan) oleh pelaksana (armada taksi dan pengemudi) adalah nilai dari fungsi penilaian sejak kendaraan dikirimkan kepada pengguna.  Tugas ini dapat dijelaskan dalam bentuk grafik bipartit: di satu sisi, pesanan, di sisi lain, pemain.  Antara pesanan dan pemain ada tepi tertimbang (penilaian).  Dengan demikian, salah satu tujuan kami adalah untuk meminimalkan waktu pengiriman total kendaraan dengan memaksimalkan jumlah pesanan yang selesai (pencocokan maksimum).  Salah satu cara paling terkenal untuk memecahkan masalah seperti itu adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma Hungaria</a> . <br><div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/webt/vd/en/lr/vdenlrgpxfigisllopvwogmqk0k.png" alt="gambar"></td><td><img src="https://habrastorage.org/webt/jd/5q/sy/jd5qsysg54yoo-n99eipmfuky1m.png" alt="gambar"></td></tr></tbody></table></div><br>  Jelas, dengan janji buffer, kami tidak dapat memberikan driver berdasarkan permintaan, seperti halnya dengan pendekatan serakah.  Pertama, Anda perlu memasukkan urutan ke dalam antrian, kemudian bermain, dan kemudian menginformasikan tentang driver yang ditemukan.  Ini sama sekali tidak cocok dengan mesin pemrosesan pesanan negara, dan itu harus diperbaiki sedikit.  Untuk menguji dan membuat solusi baru tanpa mempengaruhi kolega kami, kami segera setuju bahwa kami akan melakukan segalanya dalam microservice DriverDispatcher yang terpisah.  Dia akan menerima pesanan, memasukkan antrian, mencari driver dan menyimpan hasil demonstrasi. <br><br>  Pertama-tama, kami harus menyiapkan Pelacak untuk profil beban baru.  Jika dengan pendekatan serakah, permintaan driver secara individual jatuh pada pelacak Tracker dan dialihkan ke instansinya dengan load balancing, maka di tujuan buffer semua permintaan berasal dari satu mesin: permintaan individual hanya akan menyumbat kumpulan koneksi.  Oleh karena itu, kami menambahkan kemampuan pelacak untuk memproses kumpulan permintaan yang diproses secara bersamaan di dalam pelacak.  Sepanjang jalan, kami juga harus menyelesaikan masalah sejumlah permintaan untuk pemrosesan batch yang masuk akal.  Di sisi klien (DriverDispatcher), kami membagi batch besar menjadi beberapa batch kecil dan mengirimkannya ke berbagai instance Tracker. <br><br><img src="https://habrastorage.org/webt/gf/kw/xb/gfkwxba9mefbr-advegu6vg4uv4.png" alt="gambar"><br><br>  Jadi, pelacak disiapkan, penilaian dianggap baik dalam Pelacak (penunjukan serakah) dan dalam layanan baru (DriverDispatcher'e), algoritma untuk menyelesaikan masalah penugasan debugged dan bekerja dengan benar.  Muncul pertanyaan tentang bagaimana mengintegrasikan semua ini ke dalam mesin pemrosesan pesanan negara.  Kami menambahkan pengiriman dan penghapusan meta-informasi pesanan di DriverDispatcher ketika pesanan ditransfer dari negara bagian ke negara.  Dan itu hampir berhasil.  Hampir - karena iterasi mencari kontraktor untuk memesan tidak dikendalikan secara eksternal.  Kami hanya bisa mengganti perjalanan ke pelacak dengan pengemudi dengan perjalanan ke layanan kami dan memberikan sopir ketika ditemukan, dan sebelum itu hanya memberikan 404. Tapi ini buruk, karena Anda perlu menawarkan pesanan kepada pengemudi segera setelah kami menemukan pesanan, dan bahkan beberapa detik keterlambatan berperan di sini: pengemudi hanya dapat berbelok ke arah yang salah, dan urutannya akan menjadi tidak relevan.  Untuk melakukan ini, kami memungkinkan memanggil proses pencarian untuk seorang artis tanpa memengaruhi tugas yang direncanakan.  Jadi kami menyimpan logika pencarian (dengan permintaan ulang) dan menambahkan kemampuan untuk menyebutnya di luar penjadwal. <br><br>  Dengan demikian, kami dapat menggabungkan mesin keadaan utama untuk pemrosesan pesanan dengan mesin keadaan dalam pengiriman buffer tanpa mempengaruhi logika kerja dan tanpa balapan antar negara.  Anda dapat menjalankan percobaan pertama pada pengguna langsung. <br><br>  Ini semua sangat keren, tetapi bagaimana dengan waktu untuk mencari artis, Anda bertanya.  Jika pencarian tidak dilakukan segera setelah penerimaan pesanan, maka waktu pencarian meningkat dan hasilnya dikompensasi oleh umpan yang lebih cepat?  Ini tidak sepenuhnya benar: dengan bantuan berbagai teknik (termasuk menggunakan pembelajaran mesin), kami dapat mengisolasi kasus ketika menunggu masuk akal, dalam kasus lain waktu tunggu tidak berubah. <br><br><h3>  Penarikan pin </h3><br>  Cara lain untuk menemukan artis lebih cepat adalah mulai mencarinya SEBELUM membuat pesanan.  Ketika <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pin</a> baru muncul (yaitu, pengguna hanya memasukkan data pesanan ke dalam aplikasi), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma</a> pembelajaran mesin mengevaluasi kemungkinan bahwa suatu pesanan akan mengikuti, dan memutuskan apakah akan memperhitungkannya saat buffering driver.  Kami dapat menemukan mobil di muka, dan ketika pengguna mengklik tombol pesanan, segera buat penawaran ke pengemudi yang sesuai. <br><br><h3>  Kesimpulan </h3><br>  Mencocokkan pesanan dan driver bukanlah tugas yang mudah, itu membutuhkan memperhitungkan banyak faktor.  Salah satunya adalah konteks pergerakan pengemudi saat memilih kandidat untuk dipesan.  Kami akan membicarakan ini di posting berikut. <br><br><h3>  Posting Teknologi Taksi Lainnya </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Harga dinamis, atau Bagaimana Yandex.Taxi memprediksi permintaan tinggi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara menggunakan visi komputer untuk menilai kondisi mobil.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengalaman Yandex.Taxi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana Yandex.Taxi memprediksi waktu pengiriman mobil menggunakan pembelajaran mesin</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439182/">https://habr.com/ru/post/id439182/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439170/index.html">Operator seluler akan membantu bank memverifikasi keakuratan data pelanggan</a></li>
<li><a href="../id439172/index.html">Menegaskan () ekstensi makro untuk menerapkan penanganan kesalahan minimal</a></li>
<li><a href="../id439174/index.html">Safe Internet Day: ancaman apa yang harus dicari di 2019</a></li>
<li><a href="../id439176/index.html">Kirim email dengan lampiran oleh JavaMailSender dari SpringFramework</a></li>
<li><a href="../id439180/index.html">Tantangan Rekko</a></li>
<li><a href="../id439184/index.html">Ubah kata sandi Anda: menguji kebijakan kata sandi layanan web</a></li>
<li><a href="../id439186/index.html">Editor UX: kisah nyata, kehidupan nyata</a></li>
<li><a href="../id439190/index.html">Cara membuat aplikasi augmented reality menggunakan ARCore</a></li>
<li><a href="../id439192/index.html">Speaker PC Ke Sebelas</a></li>
<li><a href="../id439194/index.html">Manajemen Karakter dengan SharedEvents</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>