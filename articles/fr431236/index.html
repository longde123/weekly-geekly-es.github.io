<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👨🏾 👣 🦗 Comment écrire sur Objective-C en 2018. Partie 1 👨🏼‍✈️ 👨🏽‍🎤 👼🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La plupart des projets iOS passent partiellement ou entièrement à Swift. Swift est un excellent langage, et c'est avec lui que réside l'avenir du déve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment écrire sur Objective-C en 2018. Partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/joom/blog/431236/"><p>  La plupart des projets iOS passent partiellement ou entièrement à Swift.  Swift est un excellent langage, et c'est avec lui que réside l'avenir du développement iOS.  Mais le langage est inextricablement lié à la boîte à outils, et il y a des inconvénients à la boîte à outils Swift. </p><br><p>  Il y a encore des bogues dans le compilateur Swift qui le font planter ou génèrent du code incorrect.  Swift n'a pas d'ABI stable.  Et, ce qui est très important, les projets Swift durent depuis trop longtemps. </p><br><p>  À cet égard, les projets existants pourraient être plus rentables pour poursuivre le développement de l'objectif-C.  Et Objective-C n'est plus ce qu'il était! </p><br><p>  Dans cette série d'articles, nous allons vous montrer les fonctionnalités utiles et les améliorations d'Objective-C, avec lesquelles il devient beaucoup plus agréable d'écrire du code.  Tous ceux qui écrivent dans Objective-C trouveront quelque chose d'intéressant pour eux-mêmes. </p><br><p><img src="https://habrastorage.org/webt/40/ah/xl/40ahxlidhdgcqetc2vg-m2dz8ja.jpeg"></p><a name="habracut"></a><br>
<h2 id="let-i-var">  <code>let</code> et <code>var</code> </h2><br><p>  Objective-C n'a plus besoin de spécifier explicitement les types de variables: dans Xcode 8, l'extension de langage <code>__auto_type</code> est apparue, et avant que l'inférence de type Xcode 8 ne soit disponible dans Objective-C ++ (en utilisant le mot <code>auto</code> clé <code>auto</code> avec l'avènement de C ++ 0X). </p><br><p>  Tout d'abord, ajoutons les macros <code>let</code> et <code>var</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define let __auto_type const #define var __auto_type</span></span></code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//  NSArray&lt;NSString *&gt; *const items = [string componentsSeparatedByString:@","]; void(^const completion)(NSData * _Nullable, NSURLResponse * _Nullable, NSError * _Nullable) = ^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) { // ... }; //  let items = [string componentsSeparatedByString:@","]; let completion = ^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) { // ... };</span></span></code> </pre> <br><p>  Si vous aviez l'habitude d'écrire <code>const</code> après un pointeur sur une classe Objective-C, c'était un luxe inadmissible, mais maintenant la déclaration implicite de <code>const</code> (via <code>let</code> ) a été prise pour acquise.  La différence est particulièrement visible lors de l'enregistrement d'un bloc dans une variable. </p><br><p>  Pour nous, nous avons développé une règle pour utiliser <code>let</code> et <code>var</code> pour déclarer toutes les variables.  Même lorsqu'une variable est initialisée à <code>nil</code> : </p><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">nullable</span></span> JMSomeResult *)doSomething { var result = (JMSomeResult *)<span class="hljs-literal"><span class="hljs-literal">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (...) { result = ...; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  La seule exception est lorsque vous devez vous assurer qu'une variable se voit attribuer une valeur dans chaque branche de code: </p><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (...) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (...) { value = ...; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { value = ...; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { value = ...; }</code> </pre> <br><p>  Ce n'est que de cette manière que nous obtiendrons un avertissement du compilateur si nous oublions d'affecter une valeur à l'une des branches. </p><br><p>  Et enfin: pour utiliser <code>let</code> et <code>var</code> pour les variables de type <code>id</code> , vous devez désactiver l'avertissement <code>auto-var-id</code> (ajoutez <code>-Wno-auto-var-id</code> aux "Autres drapeaux d'avertissement" dans les paramètres du projet). </p><br><h2 id="avtovyvod-tipa-vozvraschaemogo-znacheniya-bloka">  Valeur de retour du type de bloc automatique </h2><br><p>  Peu de gens savent que le compilateur peut déduire le type de la valeur de retour d'un bloc: </p><br><pre> <code class="objectivec hljs">let block = ^{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">@"abc"</span></span>; }; <span class="hljs-comment"><span class="hljs-comment">// `block`   `NSString *(^const)(void)`</span></span></code> </pre> <br><p>  C'est très pratique.  Surtout si vous écrivez du code réactif à l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ReactiveObjC</a> .  Mais il existe un certain nombre de restrictions en vertu desquelles vous devez spécifier explicitement le type de la valeur de retour. </p><br><ol><li><p>  S'il y a plusieurs <code>return</code> dans un bloc qui renvoient des valeurs de différents types. </p><br><pre> <code class="objectivec hljs">let block1 = ^<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span> value){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// `NSNotFound`   `NSInteger` return NSNotFound; } }; let block2 = ^JMSomeBaseClass *(BOOL flag) { if (flag) { return [[JMSomeBaseClass alloc] init]; } else { // `JMSomeDerivedClass`   `JMSomeBaseClass` return [[JMSomeDerivedClass alloc] init]; } };</span></span></code> </pre> <br></li><li><p>  S'il y a une <code>return</code> dans le bloc qui retourne <code>nil</code> . </p><br><pre> <code class="objectivec hljs">let block1 = ^<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> * _Nullable(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; }; let block2 = ^<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> * _Nullable(<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span> flag) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flag) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">@"abc"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; } };</code> </pre> <br></li><li><p>  Si le bloc doit retourner <code>BOOL</code> . </p><br><pre> <code class="objectivec hljs">let predicate = ^<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span> lhs, <span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span> rhs){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs &gt; rhs; };</code> </pre> <br></li></ol><br><p>  Les expressions avec un opérateur de comparaison en C (et donc en Objective-C) sont de type <code>int</code> .  Par conséquent, il vaut mieux en faire une règle pour toujours spécifier explicitement le type de retour <code>BOOL</code> . </p><br><h2 id="generics-i-forin">  Génériques et <code>for...in</code> </h2><br><p>  Dans Xcode 7, des génériques (ou plutôt des génériques légers) sont apparus dans Objective-C.  Nous espérons que vous les utilisez déjà.  Sinon, vous pouvez regarder la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">session de</a> la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WWDC</a> ou la lire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><p>  Pour nous, nous avons développé une règle pour toujours spécifier des paramètres génériques, même si c'est <code>id</code> ( <code>NSArray&lt;id&gt; *</code> ).  Ainsi, il est facile de distinguer le code hérité dans lequel les paramètres génériques ne sont pas encore spécifiés. </p><br><p>  Avec les macros <code>let</code> et <code>var</code> , nous nous attendons à pouvoir les utiliser dans une boucle <code>for...in</code> : </p><br><pre> <code class="objectivec hljs">let items = (<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *&gt; *)@[<span class="hljs-string"><span class="hljs-string">@"a"</span></span>, <span class="hljs-string"><span class="hljs-string">@"b"</span></span>, <span class="hljs-string"><span class="hljs-string">@"c"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> items) { <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">@"%@"</span></span>, item); }</code> </pre> <br><p>  Mais un tel code ne se compile pas.  Très probablement, <code>__auto_type</code> pas pris en charge dans <code>for...in</code> , car <code>for...in</code> ne fonctionne qu'avec les collections qui implémentent le protocole <code>NSFastEnumeration</code> .  Et pour les protocoles dans Objective-C, il n'y a pas de support pour les génériques. </p><br><p>  Pour corriger cet inconvénient, essayez de créer votre macro <code>foreach</code> .  La première chose qui vient à l'esprit: toutes les collections de Foundation ont une propriété <code>objectEnumerator</code> , et la macro pourrait ressembler à ceci: </p><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define foreach(object_, collection_) \ for (typeof([(collection_).objectEnumerator nextObject]) object_ in (collection_))</span></span></code> </pre> <br><p>  Mais pour <code>NSDictionary</code> et <code>NSMapTable</code> méthode du protocole <code>NSMapTable</code> <code>NSFastEnumeration</code> sur les clés, pas sur les valeurs (vous devrez utiliser <code>keyEnumerator</code> , pas <code>objectEnumerator</code> ). </p><br><p>  Nous devrons déclarer une nouvelle propriété qui ne sera utilisée que pour obtenir le type dans l'expression <code>typeof</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSArray</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__covariant</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectType</span></span></span><span class="hljs-class">&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ForeachSupport</span></span></span><span class="hljs-class">) @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">strong</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">readonly</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectType</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">jm_enumeratedType</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSDictionary</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__covariant</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyType</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__covariant</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectType</span></span></span><span class="hljs-class">&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ForeachSupport</span></span></span><span class="hljs-class">) @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">strong</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">readonly</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyType</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">jm_enumeratedType</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> #</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">define</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foreach</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object_</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">collection_</span></span></span><span class="hljs-class">) \ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">for</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeof</span></span></span><span class="hljs-class">((</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">collection_</span></span></span><span class="hljs-class">).</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">jm_enumeratedType</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object_</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">in</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">collection_</span></span></span><span class="hljs-class">))</span></span></code> </pre> <br><p>  Maintenant, notre code est bien meilleur: </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//  for (MyItemClass *item in items) { NSLog(@"%@", item); } //  foreach (item, items) { NSLog(@"%@", item); }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Extrait pour Xcode</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">foreach (&lt;<span class="hljs-meta"><span class="hljs-meta">#object#&gt;, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#collection#&gt;</span></span></span><span class="hljs-meta">) { </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#statements#&gt;</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> </div></div><br><h2 id="generics-i-copymutablecopy">  Génériques et <code>copy</code> / <code>mutableCopy</code> </h2><br><p>  Un autre endroit où la saisie n'est pas disponible dans Objective-C est les <code>-mutableCopy</code> et <code>-mutableCopy</code> (ainsi que les <code>-copyWithZone:</code> et <code>-mutableCopyWithZone:</code> mais nous ne les appelons pas directement). </p><br><p>  Pour éviter d'avoir besoin de transtypages explicites, vous pouvez redéclarer les méthodes avec le type de retour.  Par exemple, pour <code>NSArray</code> déclarations seraient: </p><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSArray</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__covariant</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectType</span></span></span><span class="hljs-class">&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypedCopying</span></span></span><span class="hljs-class">) - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSArray</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectType</span></span></span><span class="hljs-class">&gt; *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">copy</span></span></span><span class="hljs-class">; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSMutableArray</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectType</span></span></span><span class="hljs-class">&gt; *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mutableCopy</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre> <br><pre> <code class="objectivec hljs">let items = [<span class="hljs-built_in"><span class="hljs-built_in">NSMutableArray</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *&gt; array]; <span class="hljs-comment"><span class="hljs-comment">// ... //  let itemsCopy = (NSArray&lt;NSString *&gt; *)[items copy]; //  let itemsCopy = [items copy];</span></span></code> </pre> <br><h2 id="warn_unused_result"> <code>warn_unused_result</code> </h2> <br><p>  Puisque nous avons re-déclaré les <code>-mutableCopy</code> -copy et <code>-mutableCopy</code> , il serait bien de garantir que le résultat de l'appel de ces méthodes sera utilisé.  Pour ce faire, Clang a l'attribut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>warn_unused_result</code></a> . </p><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define JM_WARN_UNUSED_RESULT __attribute__((warn_unused_result))</span></span></code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSArray</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__covariant</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectType</span></span></span><span class="hljs-class">&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypedCopying</span></span></span><span class="hljs-class">) - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSArray</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectType</span></span></span><span class="hljs-class">&gt; *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">copy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JM_WARN_UNUSED_RESULT</span></span></span><span class="hljs-class">; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSMutableArray</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectType</span></span></span><span class="hljs-class">&gt; *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mutableCopy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JM_WARN_UNUSED_RESULT</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre> <br><p>  Pour le code suivant, le compilateur générera un avertissement: </p><br><pre> <code class="objectivec hljs">let items = @[<span class="hljs-string"><span class="hljs-string">@"a"</span></span>, <span class="hljs-string"><span class="hljs-string">@"b"</span></span>, <span class="hljs-string"><span class="hljs-string">@"c"</span></span>]; [items mutableCopy]; <span class="hljs-comment"><span class="hljs-comment">// Warning: Ignoring return value of function declared with 'warn_unused_result' attribute.</span></span></code> </pre> <br><h2 id="overloadable"> <code>overloadable</code> </h2> <br><p>  Peu de gens savent que Clang vous permet de redéfinir des fonctions en langage C (et donc en Objective-C).  En utilisant l'attribut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>overloadable</code></a> , vous pouvez créer des fonctions avec le même nom, mais avec différents types d'arguments ou avec des nombres différents. </p><br><p>  <em>Les fonctions remplaçables ne peuvent pas différer uniquement par le type de la valeur de retour.</em> </p><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define JM_OVERLOADABLE __attribute__((overloadable))</span></span></code> </pre> <br><pre> <code class="objectivec hljs">JM_OVERLOADABLE <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> JMCompare(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lhs, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rhs); JM_OVERLOADABLE <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> JMCompare(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lhs, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rhs, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> accuracy); JM_OVERLOADABLE <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> JMCompare(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> lhs, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> rhs); JM_OVERLOADABLE <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> JMCompare(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> lhs, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> rhs, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> accuracy);</code> </pre><br><h2 id="boxed-expressions">  Expressions encadrées </h2><br><p>  En 2012, lors d'une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">session WWDC 413,</a> Apple a présenté des littéraux pour <code>NSNumber</code> , <code>NSArray</code> et <code>NSDictionary</code> , ainsi que des expressions encadrées.  Vous pouvez en savoir plus sur les littéraux et les expressions encadrées dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation de Clang</a> . </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//  @YES // [NSNumber numberWithBool:YES] @NO // [NSNumber numberWithBool:NO] @123 // [NSNumber numberWithInt:123] @3.14 // [NSNumber numberWithDouble:3.14] @[obj1, obj2] // [NSArray arrayWithObjects:obj1, obj2, nil] @{key1: obj1, key2: obj2} // [NSDictionary dictionaryWithObjectsAndKeys:obj1, key1, obj2, key2, nil] // Boxed expressions @(boolVariable) // [NSNumber numberWithBool:boolVariable] @(intVariable) // [NSNumber numberWithInt:intVariable)]</span></span></code> </pre> <br><p>  En utilisant des littéraux et des expressions encadrées, vous pouvez facilement obtenir un objet représentant un nombre ou une valeur booléenne.  Mais pour obtenir un objet qui enveloppe la structure, vous devez écrire du code: </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//  `NSDirectionalEdgeInsets`  `NSValue` let insets = (NSDirectionalEdgeInsets){ ... }; let value = [[NSValue alloc] initWithBytes:&amp;insets objCType:@encode(typeof(insets))]; // ... //  `NSDirectionalEdgeInsets`  `NSValue` var insets = (NSDirectionalEdgeInsets){}; [value getValue:&amp;insets];</span></span></code> </pre> <br><p>  Des méthodes et propriétés d'assistance sont définies pour certaines classes (comme la méthode <code>+[NSValue valueWithCGPoint:]</code> et les propriétés <code>CGPointValue</code> ), mais ce n'est toujours pas aussi pratique qu'une expression encadrée! </p><br><p>  Et en 2015, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Alex Denisov a</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">créé un patch</a> pour Clang, vous permettant d'utiliser des expressions encadrées pour envelopper toutes les structures dans <code>NSValue</code> . </p><br><p>  Pour que notre structure <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>objc_boxable</code></a> en charge les expressions encadrées, il vous suffit d'ajouter l'attribut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>objc_boxable</code></a> pour la structure. </p><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define JM_BOXABLE __attribute__((objc_boxable))</span></span></code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> JM_BOXABLE JMDimension { JMDimensionUnit unit; <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span> value; } JMDimension;</code> </pre> <br><p>  Et nous pouvons utiliser la syntaxe <code>@(...)</code> pour notre structure: </p><br><pre> <code class="objectivec hljs">let dimension = (JMDimension){ ... }; let boxedValue = @(dimension); <span class="hljs-comment"><span class="hljs-comment">//   `NSValue *`</span></span></code> </pre> <br><p>  Vous devez toujours <code>-[NSValue getValue:]</code> structure via la méthode <code>-[NSValue getValue:]</code> ou la méthode category. </p><br><p>  CoreGraphics définit sa propre macro, <code>CG_BOXABLE</code> et les expressions encadrées sont déjà prises en charge pour les <code>CGPoint</code> , <code>CGSize</code> , <code>CGVector</code> et <code>CGRect</code> . </p><br><p>  Pour d'autres structures couramment utilisées, nous pouvons ajouter nous-mêmes la prise en charge des expressions encadrées: </p><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> JM_BOXABLE _NSRange <span class="hljs-built_in"><span class="hljs-built_in">NSRange</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> JM_BOXABLE <span class="hljs-built_in"><span class="hljs-built_in">CGAffineTransform</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CGAffineTransform</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> JM_BOXABLE <span class="hljs-built_in"><span class="hljs-built_in">UIEdgeInsets</span></span> <span class="hljs-built_in"><span class="hljs-built_in">UIEdgeInsets</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> JM_BOXABLE <span class="hljs-built_in"><span class="hljs-built_in">NSDirectionalEdgeInsets</span></span> <span class="hljs-built_in"><span class="hljs-built_in">NSDirectionalEdgeInsets</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> JM_BOXABLE <span class="hljs-built_in"><span class="hljs-built_in">UIOffset</span></span> <span class="hljs-built_in"><span class="hljs-built_in">UIOffset</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> JM_BOXABLE <span class="hljs-built_in"><span class="hljs-built_in">CATransform3D</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CATransform3D</span></span>;</code> </pre> <br><h2 id="compound-literals">  Littéraux composés </h2><br><p>  Une autre construction de langage utile est le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">littéral composé</a> .  Les littéraux composés sont apparus dans GCC en tant qu'extension de langage et ont ensuite été ajoutés à la norme C11. </p><br><p>  Si plus tôt, après avoir rencontré l'appel à <code>UIEdgeInsetsMake</code> , nous ne pouvions que deviner quelle indentation nous obtiendrions (nous devions regarder la déclaration de la fonction <code>UIEdgeInsetsMake</code> ), puis avec les littéraux composés, le code parle de lui-même: </p><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//  UIEdgeInsetsMake(1, 2, 3, 4) //  (UIEdgeInsets){ .top = 1, .left = 2, .bottom = 3, .right = 4 }</span></span></code> </pre> <br><p>  Il est encore plus pratique d'utiliser une telle construction lorsque certains des champs sont nuls: </p><br><pre> <code class="objectivec hljs">(<span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span>){ .y = <span class="hljs-number"><span class="hljs-number">10</span></span> } <span class="hljs-comment"><span class="hljs-comment">//  (CGPoint){ .x = 0, .y = 10 } (CGRect){ .size = { .width = 10, .height = 20 } } //  (CGRect){ .origin = { .x = 0, .y = 0 }, .size = { .width = 10, .height = 20 } } (UIEdgeInsets){ .top = 10, .bottom = 20 } //  (UIEdgeInsets){ .top = 20, .left = 0, .bottom = 10, .right = 0 }</span></span></code> </pre> <br><p>  Bien sûr, dans les littéraux composés, vous pouvez utiliser non seulement des constantes, mais aussi toutes les expressions: </p><br><pre> <code class="objectivec hljs">textFrame = (<span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>){ .origin = { .y = <span class="hljs-built_in"><span class="hljs-built_in">CGRectGetMaxY</span></span>(buttonFrame) + textMarginTop }, .size = textSize };</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Extraits pour Xcode</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">(<span class="hljs-built_in"><span class="hljs-built_in">NSRange</span></span>){ .location = &lt;<span class="hljs-meta"><span class="hljs-meta">#location#&gt;, .length = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#length#&gt;</span></span></span><span class="hljs-meta"> } (CGPoint){ .x = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#x#&gt;</span></span></span><span class="hljs-meta">, .y = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#y#&gt;</span></span></span><span class="hljs-meta"> } (CGSize){ .width = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#width#&gt;</span></span></span><span class="hljs-meta">, .height = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#height#&gt;</span></span></span><span class="hljs-meta"> } (CGRect){ .origin = { .x = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#x#&gt;</span></span></span><span class="hljs-meta">, .y = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#y#&gt;</span></span></span><span class="hljs-meta"> }, .size = { .width = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#width#&gt;</span></span></span><span class="hljs-meta">, .height = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#height#&gt;</span></span></span><span class="hljs-meta"> } } (UIEdgeInsets){ .top = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#top#&gt;</span></span></span><span class="hljs-meta">, .left = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#left#&gt;</span></span></span><span class="hljs-meta">, .bottom = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#bottom#&gt;</span></span></span><span class="hljs-meta">, .right = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#right#&gt;</span></span></span><span class="hljs-meta"> } (NSDirectionalEdgeInsets){ .top = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#top#&gt;</span></span></span><span class="hljs-meta">, .leading = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#leading#&gt;</span></span></span><span class="hljs-meta">, .bottom = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#bottom#&gt;</span></span></span><span class="hljs-meta">, .trailing = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#trailing#&gt;</span></span></span><span class="hljs-meta"> } (UIOffset){ .horizontal = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#horizontal#&gt;</span></span></span><span class="hljs-meta">, .vertical = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;#vertical#&gt;</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> </div></div><br><h2 id="nullability">  Annulation </h2><br><p>  Dans Xcode 6.3.2, les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">annotations de nullité</a> sont apparues dans Objective-C.  Les développeurs Apple les ont ajoutés pour importer l'API Objective-C dans Swift.  Mais si quelque chose est ajouté à la langue, vous devriez essayer de le mettre à votre service.  Et nous expliquerons comment nous utilisons la nullité dans un projet Objective-C et quelles sont les limitations. </p><br><p>  <em>Pour rafraîchir vos connaissances, vous pouvez regarder la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">session WWDC</a> .</em> </p><br><p>  La première chose que nous avons faite a été de commencer à écrire les <code>NS_ASSUME_NONNULL_END</code> <code>NS_ASSUME_NONNULL_BEGIN</code> / <code>NS_ASSUME_NONNULL_END</code> dans tous les fichiers <code>.m</code> .  Afin de ne pas le faire à la main, nous corrigeons les modèles de fichiers directement dans Xcode. </p><br><p>  Nous avons également commencé à définir correctement la nullité pour toutes les propriétés et méthodes privées. </p><br><p>  Si nous ajoutons les macros <code>NS_ASSUME_NONNULL_BEGIN</code> / <code>NS_ASSUME_NONNULL_END</code> à un fichier <code>.m</code> existant, nous ajoutons immédiatement les <code>null_resettable</code> , <code>null_resettable</code> et <code>_Nullable</code> dans l'ensemble du fichier. </p><br><p>  Tous les avertissements utiles du compilateur de nullité sont activés par défaut.  Mais il y a un avertissement extrême que je voudrais inclure: <code>-Wnullable-to-nonnull-conversion</code> (défini dans les "Autres drapeaux d'avertissement" dans les paramètres du projet).  Le compilateur génère cet avertissement lorsqu'une variable ou une expression avec un type nullable est implicitement convertie en un type non nul. </p><br><pre> <code class="objectivec hljs">+ (<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)foo:(<span class="hljs-keyword"><span class="hljs-keyword">nullable</span></span> <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)string { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> string; <span class="hljs-comment"><span class="hljs-comment">// Implicit conversion from nullable pointer 'NSString * _Nullable' to non-nullable pointer type 'NSString * _Nonnull' }</span></span></code> </pre> <br><p>  Malheureusement, pour <code>__auto_type</code> (et donc <code>let</code> et <code>var</code> ), cet avertissement ne fonctionne pas.  Le type déduit via <code>__auto_type</code> supprime l'annotation de nullité.  Et, à en juger par le commentaire du développeur Apple dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rdar: // 27062504</a> , ce comportement ne changera pas.  Il a été observé expérimentalement que l'ajout de <code>_Nullable</code> ou <code>_Nonnull</code> à <code>__auto_type</code> n'affecte rien. </p><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)test:(<span class="hljs-keyword"><span class="hljs-keyword">nullable</span></span> <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)string { let tmp = string; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br><p>  Pour supprimer l' <code>nullable-to-nonnull-conversion</code> nous avons écrit une macro qui "force le débouclage".  Idée tirée de la macro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>RBBNotNil</code></a> .  Mais en raison du comportement de <code>__auto_type</code> il a été possible de se débarrasser de la classe auxiliaire. </p><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define JMNonnull(obj_) \ ({ \ NSCAssert(obj_, @</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Expected `%@` not to be nil."</span></span></span><span class="hljs-meta">, @#obj_); \ (typeof({ __auto_type result_ = (obj_); result_; }))(obj_); \ })</span></span></code> </pre> <br><p>  Un exemple d'utilisation de la macro <code>JMNonnull</code> : </p><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JMRobot</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">strong</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullable</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JMLeg</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">leftLeg</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">strong</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullable</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JMLeg</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rightLeg</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JMRobot</span></span></span><span class="hljs-class"> - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stepLeft</span></span></span><span class="hljs-class"> </span></span>{ [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> step:JMNonnull(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.leftLeg)] } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)stepRight { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> step:JMNonnull(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.rightLeg)] } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)step:(JMLeg *)leg { <span class="hljs-comment"><span class="hljs-comment">// ... } @end</span></span></code> </pre> <br><p>  Notez qu'au moment de l'écriture, l'avertissement de <code>nullable-to-nonnull-conversion</code> ne fonctionne pas <code>nullable-to-nonnull-conversion</code> : le compilateur ne comprend pas encore qu'une variable <code>nullable</code> , après avoir vérifié l'inégalité, <code>nil</code> peut être interprétée comme non <code>nonnull</code> . </p><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)foo:(<span class="hljs-keyword"><span class="hljs-keyword">nullable</span></span> <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)string { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (string != <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> string; <span class="hljs-comment"><span class="hljs-comment">// Implicit conversion from nullable pointer 'NSString * _Nullable' to non-nullable pointer type 'NSString * _Nonnull' } else { return @""; } }</span></span></code> </pre> <br><p>  Dans le code Objective-C ++, vous pouvez contourner cette limitation en utilisant la construction <code>if let</code> , car Objective-C ++ autorise les déclarations de variables dans l'expression d'une <code>if</code> . </p><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)foo:(<span class="hljs-keyword"><span class="hljs-keyword">nullable</span></span> <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)stringOrNil { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (let string = stringOrNil) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> string; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">@""</span></span>; } }</code> </pre> <br><h2 id="poleznye-ssylki">  Liens utiles </h2><br><p>  Il y a aussi un certain nombre de macros et de mots clés plus connus que je voudrais mentionner: le mot clé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>@available</code></a> , les macros <code>NS_DESIGNATED_INITIALIZER</code> , <code>NS_UNAVAILABLE</code> , <code>NS_REQUIRES_SUPER</code> , <code>NS_NOESCAPE</code> , <code>NS_ENUM</code> , <code>NS_OPTIONS</code> (ou vos macros pour les mêmes attributs) et la macro de bibliothèque @keypath.  Nous vous recommandons également de consulter le reste de la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">libextobjc</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Quoi d'autre à lire</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://pspdfkit.com/blog/2017/even-swiftier-objective-c/</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://medium.com/@maicki/type-inference-with-auto-type-55a38ef56372</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://nshipster.com/__attribute__/</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.bignerdranch.com/blog/bools-sharp-corners/</a> </p></div></div><br><p>  → Le code de l'article est affiché dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gist</a> . </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Dans la première partie de l'article, nous avons essayé de parler des principales fonctionnalités et des améliorations simples du langage, qui facilitent grandement l'écriture et la prise en charge du code Objective-C.  Dans la partie suivante, nous montrerons comment vous pouvez augmenter votre productivité à l'aide d'énumérations comme dans Swift (ce sont des classes Case; ce sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des types de données algébriques</a> , ADT) et la possibilité de mettre en œuvre des méthodes au niveau du protocole. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr431236/">https://habr.com/ru/post/fr431236/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr431226/index.html">Le jeu Snake pour FPGA Cyclone IV (avec joystick VGA et SPI)</a></li>
<li><a href="../fr431228/index.html">Obstacle Run for Light: cristaux liquides pour aider</a></li>
<li><a href="../fr431230/index.html">Stockage pour infrastructure HPC, ou comment nous avons collecté un stockage de 65 PB au RIKEN Japan Research Center</a></li>
<li><a href="../fr431232/index.html">Nous générons de beaux espaces réservés SVG sur Node.js</a></li>
<li><a href="../fr431234/index.html">11 décembre, Moscou - Alfa JS MeetUp</a></li>
<li><a href="../fr431238/index.html">Le condensé des événements pour les professionnels RH dans le domaine de l'informatique pour décembre 2018</a></li>
<li><a href="../fr431242/index.html">TLS et certificats Web</a></li>
<li><a href="../fr431244/index.html">"Deux non filtré" ou un moyen facile de tirer une jambe</a></li>
<li><a href="../fr431246/index.html">@OpenStack Meetup at Mail.Ru Group: 30 novembre</a></li>
<li><a href="../fr431248/index.html">Qui sera responsable en agile de la qualité de développement de projets complexes, ou de la méthodologie Quality Gates</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>