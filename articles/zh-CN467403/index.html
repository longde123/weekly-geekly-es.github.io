<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🅾️ 🥫 👾 您可以和不能从Web组件中挤出的内容 🌿 🐖 🖼️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这不是教程或完整的综述，而是汇编组件库后的热血笔记。 一切都从平常的日常故事开始：有一个遗留代码，您需要将pipmochek和小棍子固定在遗留上，您不能一次重写任何内容，也不能用手触摸此处； 不要以防万一，以防万一，而事实上，为什么您不随便使用最好的Vanilla JS框架并开始编写，就像您的祖父遗...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>您可以和不能从Web组件中挤出的内容</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467403/">这不是教程或完整的综述，而是汇编组件库后的热血笔记。 一切都从平常的日常故事开始：有一个遗留代码，您需要将pipmochek和小棍子固定在遗留上，您不能一次重写任何内容，也不能用手触摸此处； 不要以防万一，以防万一，而事实上，为什么您不随便使用最好的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Vanilla JS</a>框架并开始编写，就像您的祖父遗赠的那样？ <br><a name="habracut"></a><br> 但是，由于预计工作量会非常引人注目，因此出于某种原因，没有人会想到用裸露的JS编写所有内容这一想法。 我们去看一下工具，并从中选择不会使我们的组件的消费者感到恐惧的工具。 <br><br><h2> 工具 </h2><br> 尽管我已经破坏了整个部分，但是这里需要说些什么。 首先，Web组件立即变得毫无争议：当创造力的结果是组件库，并且您无法拖动一个大型怪物la Angular时，它会完全完全模块化，那么剩下的就是您根本不需要拖动库代码，并在现代浏览器中“像那样”工作。  Web组件本身仍然是令人惊叹的Vanilla JS框架，仅解决了一些模块化问题。 用自己的双手还需要写很多东西-您需要标准化的包装器，并且希望每个组件的样板都最少。 <br><br> 这样的包装器并不多，甚至足够成熟以用于严肃的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">产品</a> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Hybrids，</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">LitElement，</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Stencil。</a> 他们都以相同的方式处理相同的事情，不同之处在于小事情。  Hybrids试图变得时髦和无类，Stencil变得时髦并且像反应，LitElement似乎都没有努力。 根据从微不足道的琐事中选择的结果，输出仍然是LitElement-OOPshniki从Hybrids转向鼻子，从非业余者转向-从Stencil转向，其中JSX通常觉得重复了并非最无可争辩的想法。 <br><br><h2> 战斗？ </h2><br> 在文档中讨论您可以做什么并没有那么有趣，因此我将继续主要讨论您不能做什么：他们通常不会在文档中写这些。 <br><br><h3> 模式 </h3><br> 在模板方面，LitElement使用lit-html，这非常简单： <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> template = html<span class="hljs-string"><span class="hljs-string">` &lt;div attr=</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${a}</span></span></span><span class="hljs-string"> .property=</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${b}</span></span></span><span class="hljs-string"> ?booleanAttr=</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${c}</span></span></span><span class="hljs-string"> @click=</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${handleClick}</span></span></span><span class="hljs-string"> &gt;&lt;/div&gt; `</span></span>;</code> </pre> <br> 这不是html，但您需要在一个符号中牢记三个构造-“。”，“？”和“ @”。 其他所有内容都是html。 关于JSX，带有它的className和其他名称，它与JS / TS代码相比更好一些，并且在法律上是分开的。 但是，顺便说一下，第一个“不可能”是从这里开始的-绑定任何不可行的东西，只能绑定属性和属性的值以及文本内容。 当然，在带标签的模板文字中，没有魔术，并且以一定数量的变态为代价，您可以在运行时放一个字符串，并在其上附加lit-html绑定器，但这实际上是用手进入渲染的，并且同样成功，您可以收集行并将其发送在innerHTML中。 通常，这都是通过模板的组成以及将复杂的组件分解为更简单的组件来完成的。 样板很小-几乎没有模板绑定，因为它只是一个变量，要创建一个组件，您需要五行“额外”的行。 <br><br><h3> 组成部分 </h3><br> 组件唯一（但很重要）的问题是，为了将组件与子代渲染图完全“混合”，在父模板的某个位置，您需要Shadow DOM。 当然，默认情况下它包含在LitElement中，总的来说似乎还不错。 但是，与css模块类似，影子DOM当前在样式方面存在一个大问题：要隔离样式，它必须完全隔离，但是这样会减少整个层叠。 根本不可能从外部进入孤立的样式。 通常（几乎）什么都没有。 <br><br> 例如，这极大地干扰了滚动不同主题的组件的能力。 影子DOM所能做的就是将所有样式选项打包到组件内部，或者尝试使主题完全依赖于CSS变量-这是“几乎”可以用来抽动孤立样式的方法。 但是有必要按字面意义为任何合理的样式提供变量，而且很有可能还会添加更多变量。 <br><br> 幸运的是，只需在组件中禁用LitElement中的Shadow DOM。 不幸的是，这也会禁用通过&lt;slot&gt;在模板的正确位置定位元素子元素的功能。 幸运的是，稍微变了一点，您可以同时获得第一个和第二个：为此，您<i>只</i>需要在每个必要的插槽上放置一个影子根即可，并且除了&lt;slot&gt;之外，其中没有任何内容。 因此，组件的样式将是开放的，并且将出现插槽。 我想举一个简单的例子，但是不幸的是，用于操作插槽的代码始终无法奏效-非常有兴趣的人可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a>阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此问题。</a> 我的灵感来自那里。 <br><br> 嗯，还值得一提的是，在可预见的将来，浏览器支持和polyfills <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">:: part</a>和::主题很可能会退出，并且影子DOM最终将成为每个人都在等待多年的解决方案-因此它与外界隔离可扩展/可变的。 但是到目前为止，这还不存在。 <br><br><h3> 部署 </h3><br> 在这一点上，不再写关于“不可能的事”的文章，因为所有事情都可以被进一步处理-点亮的库以ES模块的形式存在，因此没有任何问题，它们可以以任何方式以任何方式被拾取（即使使用可以处理模块本身的裸露浏览器） ） 对于IE和当前的Edge，您需要连接Web组件的polyfill，对于模块，如果要直接从浏览器中将其提起，则需要一些减轻浏览器导入负担的工具，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">es-module-shims。</a> 好吧，还是打捆机。 <br><br> 连接到应用程序中的Web组件简单易用，您可以在html中开始使用它们，并在代码中提取其方法和属性。 您可以在这里看到所有这些都可以很好地附加到另一个库或框架上（反应很好，但是平均而言一切都很好）。 我们坚持使用AngularJS，并且一切都很陈旧：ng-prop允许您将某些内容传输到组件，而ng-on则允许您侦听事件。 <br><br><h2> 总结 </h2><br> 如果您需要构建组件UI并将其固定在您绝对不希望使用的组件上（旧版代码，不时髦的可怕框架以及其他不良地方），则Web组件可以很好地解决问题。 使用它们管理的主要“成熟”库很小，没有模块化和布局方面的严重技术问题，您可以直接使用它。 您选择哪种类型的库-即使不是那么重要，目前它们之间的差异也很小。 具体来说，我们采用的LitElement并没有给我们带来任何额外的问题，而是在所有情况下均以预期的方式工作。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN467403/">https://habr.com/ru/post/zh-CN467403/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN467391/index.html">Yandex推出RPKI</a></li>
<li><a href="../zh-CN467393/index.html">NX Bootcamp将于10月启动</a></li>
<li><a href="../zh-CN467395/index.html">《哈勃周刊》第18期/新的Apple小工具，全模块化智能手机，白俄罗斯的程序员之乡，XY现象</a></li>
<li><a href="../zh-CN467399/index.html">您不能禁止携带：如何实施BYOD概念且不损害信息安全</a></li>
<li><a href="../zh-CN467401/index.html">特斯拉Model S和保时捷Taycan的比较</a></li>
<li><a href="../zh-CN467405/index.html">Lyft发起3D对象识别竞赛</a></li>
<li><a href="../zh-CN467407/index.html">我们与合作机器人Dobot M1合作</a></li>
<li><a href="../zh-CN467409/index.html">要在硅谷做生意，您需要表现出自己</a></li>
<li><a href="../zh-CN467413/index.html">PHP微服务框架-Swoft的“ Hello World”</a></li>
<li><a href="../zh-CN467415/index.html">现代外汇市场</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>