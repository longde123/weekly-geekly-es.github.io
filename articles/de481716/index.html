<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèª üëâüèΩ üåû Reaktive Programmierung, lohnt es sich, alles fallen zu lassen und dem Traum entgegen zu eilen? ü•† üë©üèø‚Äçüåæ üë©üèª‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ein weiterer Artikel √ºber reaktive Programmierung. Und nur nicht mit den Augen auf diese Zeile rollen und mit leiser Stimme laut sprechen - "Nun, was ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reaktive Programmierung, lohnt es sich, alles fallen zu lassen und dem Traum entgegen zu eilen?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481716/"><p>  Ein weiterer Artikel √ºber reaktive Programmierung.  Und nur nicht mit den Augen auf diese Zeile rollen und mit leiser Stimme laut sprechen - "Nun, was k√∂nnen Sie mir noch √ºber reaktives Programmieren sagen ... wie?"  Es unterscheidet sich ein wenig von einigen anderen, die wie Kohlepapier geschrieben sind, sodass einige Dinge darin ... seltsam oder sogar v√∂llig unangemessen erscheinen, wie sortierter Humor. </p><br><p>  Es spielt keine Rolle, ob Sie das reaktive Manifest auswendig kennen, ob in Ihrem Morgenkaffee R√ºckstau herrscht, ob Sie mit diesen Stiften alle Arten von Verlagen und Abonnenten ber√ºhren oder guten alten synchronen, blockierenden Code schreiben.  Oder vielleicht erst k√ºrzlich, hat jemand mit seinem aufrichtigen Werbebericht √ºber die strahlende Zukunft und den Streaming-Orgasmus (na ja, oder Inkjet, hier entscheiden die Feinheiten der √úbersetzung alles) ein Interesse an der neuen Technologie in Ihren Augen geweckt, indem er eine der reaktiven Bibliotheken verwendet hat. </p><br><p>  Es wird interessant sein. </p><a name="habracut"></a><br>
<h3 id="vozvedenie-v-absolyut">  Absolut </h3><br><p>  Stellen wir uns also vor, wir sind total verr√ºckt ... Obwohl das Wort hier eher aus politischen Gr√ºnden verwendet wird, weil jeder, der den Autor kennt, sich der Tatsache bewusst ist, dass er den ganzen Tag in einer verschlossenen Wohnung sitzt.  Es funktioniert nachts, raucht drei Wasserpfeifen pro Tag und geht ein paar Mal pro Woche nach drau√üen.  Dies geschieht normalerweise mit Ihrem Therapeuten, aber manchmal ist der Grund v√∂llig anders - IKEA. </p><br><p>  Also nehmen wir den alten synchronen, aber funktionierenden Code: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br><p>  Und wir versuchen es umzugestalten, weil es uns so vorkommt ... Obwohl nein, es ist zu viel, wird es niemand bei klarem Verstand tun.  Niemand  Bei klarem Verstand. </p><br><pre> <code class="java hljs">Mono&lt;Integer&gt; result = Flux.concat( Mono.just(<span class="hljs-number"><span class="hljs-number">1</span></span>), Flux.concat(Mono.just(<span class="hljs-number"><span class="hljs-number">2</span></span>), Mono.just(<span class="hljs-number"><span class="hljs-number">4</span></span>)) .reduce((a, b) -&gt; a * b)) .reduce((a, b) -&gt; a + b); StepVerifier.create(result) .expectNext(<span class="hljs-number"><span class="hljs-number">9</span></span>) .expectComplete() .verify();</code> </pre><br><p>  Aber wie Sie vielleicht bemerkt haben, habe ich es getan.  Und bitte beachten Sie!  Ich habe mich in diesem Beispiel <code>rSocket</code> <code>kafka</code> <code>rSocket</code> <code>kafka</code> , einen f√ºr die Addition und einen f√ºr die Multiplikation, die ich √ºber <code>rSocket</code> und <code>kafka</code> kommunizieren <code>kafka</code> . </p><br><p>  √úbrigens war es ein Warm-up.  Bevor wir beginnen, m√∂chte ich zwei Tipps geben.  Und so der erste Ratschlag: Seien Sie immer darauf vorbereitet, dass Ihre Kollegen wirklich kranke Psychopathen sein k√∂nnen, mit einer Reihe von Kinderkomplexen, die in Form eines Codes, nicht von bester Qualit√§t, und sehr eleganten architektonischen L√∂sungen auftauchen. </p><br><p>  Tipp zwei.  Ich habe beschlossen, es am Ende des Artikels zu belassen.  Aber wenn Sie nach allem, was Sie sehen, entscheiden, dass Sie sich von diesem d% &amp; @ a fernhalten sollten, dann wissen Sie, wo Sie danach suchen m√ºssen. </p><br><h3 id="bolee-realnyy-primer">  Echteres Beispiel </h3><br><p>  Nehmen wir ein etwas realistischeres Beispiel.  Zum Beispiel ... B√§ume.  Warum genau sie?  Weil wir alle B√§ume sowohl als Objekt im wirklichen Leben als auch als Datenstruktur lieben.  Dies ist einer der wichtigsten Teile der Welt um uns herum.  B√§ume produzieren Sauerstoff, damit wir atmen k√∂nnen. </p><br><p>  Viele Tiere leben auf B√§umen oder an Orten, an denen sich diese Gegenst√§nde ansammeln (diese Orte werden abh√§ngig von Park oder Wald genannt), aber Tiere, sogar Obdachlose, leben in Pappkartons, die urspr√ºnglich B√§ume waren. </p><br><p>  √úbrigens ist es eine interessante Tatsache, dass die Menschheit seit der Antike eines der am h√§ufigsten verwendeten Materialien im menschlichen Leben - Holz - aus den B√§umen gewinnt.  Stellen Sie sich vor, all diese St√∂cke, die wir unser ganzes Leben lang in unsere R√§der stecken und gleichzeitig alle anderen beschuldigen, auch aus Holz. </p><br><p>  Wir haben einen Baum, einen gew√∂hnlichen, unscheinbaren Baum, der auf dem Rasen unseres Codes gewachsen ist und eines Tages, wenn er erwachsen wird, in BST verwandelt wurde: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TreeNode</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TreeNode left, right; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TreeNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val, TreeNode left, TreeNode right)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.val = val; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.left = left; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.right = right; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TreeNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(val, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } <span class="hljs-comment"><span class="hljs-comment">//       TreeNode invert() { // ... } int sumOfLeftLeaves() { // ... } TreeNode searchBST(int val) { // .. } public List&lt;Integer&gt; toList() { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (left != null) list.addAll(left.toList()); list.add(val); if (right != null) list.addAll(right.toList()); return list; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; TreeNode treeNode = (TreeNode) o; return val == treeNode.val; } @Override public int hashCode() { return val; } @Override public String toString() { return toList().toString(); } }</span></span></code> </pre><br><p>  Und irgendwann, zum Beispiel am Montag um sechs Uhr morgens, hatte ein Programmierer nach einer schlaflosen Nacht die Idee, sie reaktiv zu machen.  Und er hat es geschafft.  Weil er ein Mann der Arbeit ist. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TreeNode</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Mono&lt;Integer&gt; value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Mono&lt;TreeNode&gt; left; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Mono&lt;TreeNode&gt; right; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TreeNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Mono&lt;Integer&gt; value, Mono&lt;TreeNode&gt; left, Mono&lt;TreeNode&gt; right)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = value; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.left = left; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.right = right; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TreeNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, TreeNode left, TreeNode right)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(Mono.just(value), Mono.justOrEmpty(left), Mono.justOrEmpty(right)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TreeNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(Mono.just(value), Mono.empty(), Mono.empty()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Flux&lt;TreeNode&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flux</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Flux.concat( left.flatMapMany(TreeNode::flux), Mono.just(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>), right.flatMapMany(TreeNode::flux) ); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> flux() .flatMap(n -&gt; n.value) .collectList() .map(Object::toString) .block(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == o) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || getClass() != o.getClass()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; TreeNode treeNode = (TreeNode) o; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Objects.equals(value.block(), treeNode.value.block()); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hashCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value.block(); }</code> </pre><br><p>  Sie sp√ºren die Frage in der Luft h√§ngen - "Warum?!".  Erstens ist es wundersch√∂n und zweitens ist es sehr skalierbar, da es asynchron ist, au√üerdem ist es umweltfreundlich und Greta Tunberg wird nicht einmal mit einem riesigen Umschnalldildo zu uns kommen ... Sie wissen, was ich meine.  Und vergessen Sie nicht, dass wir jetzt Druck zur√ºck haben.  √úbrigens erinnere ich Sie daran, dass kein Refactoring ohne Testabdeckung durchgef√ºhrt werden kann. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TreeNodeTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFlux</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TreeNode tree = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">3</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">6</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">9</span></span>))); StepVerifier.create(tree.flux().flatMap(n -&gt; n.value)) .expectNext(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>) .expectComplete() .verify(); } }</code> </pre> <br><p>  Gro√üartig.  Der Anfang ist gemacht, jetzt m√ºssen wir nur noch drei einfache <code>invert</code> , <code>sumOfLeftLeaves</code> und <code>searchBST</code> im alten, langweiligen, synchronen Baum <code>sumOfLeftLeaves</code> und einige Tests hinzuf√ºgen. </p><br><h3 id="invert">  Invertieren </h3><br><p>  Wir haben also bereits eine <code>invert</code> Methode implementiert, aber leider ist sie nicht reaktiv. Sehen Sie, wie traurig sie aussieht. Das einzige Plus dieser Methode ist, dass sie leicht zu lesen ist und dass es leicht zu verstehen ist, wenn wir den Baum invertieren Wir gehen rekursiv alle Knoten durch, erstellen Kopien und tauschen die untergeordneten Knoten aus.  Das hei√üt, im linken Kind des neuen Knotens setzen wir den invertierten Knoten vom rechten Kind und umgekehrt.  Und √ºberall sind diese √úberpr√ºfungen null. </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TreeNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> invert(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TreeNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TreeNode root)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; TreeNode swap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(root.val); swap.right = invert(root.left); swap.left = invert(root.right); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> swap; }</code> </pre><br><p>  Schauen Sie, was passiert ist, als wir es umgeschrieben haben, es mit neuen Farben gespielt hat und als Bonus haben wir null Sicherheit gratis bekommen. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Mono&lt;TreeNode&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Mono.just(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .map(n -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(n.value, n.right.flatMap(TreeNode::invert), n.left.flatMap(TreeNode::invert) )); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testInvert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TreeNode tree = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">3</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">6</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">9</span></span>))); Flux&lt;Integer&gt; inverted = tree.invert() .flatMapMany(TreeNode::flux) .flatMap(n -&gt; n.value); StepVerifier.create(inverted) .expectNext(<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) .expectComplete() .verify(); }</code> </pre> <br><h3 id="sumofleftleaves">  sumOfLeftLeaves </h3><br><p>  Normalerweise werden Menschen in zwei Typen eingeteilt, der erste Typ ist derjenige, der versteht, was diese Methode aus ihrem Namen macht, und alle anderen Menschen, die ihr Zimmer seit Jahren nicht verlassen haben und noch nie B√§ume gesehen haben. </p><br><p>  Ich kann dem zweiten Typ von Menschen mit Rat von meinem Psychotherapeuten helfen, der wahrscheinlich in der Lage ist, ein Behandlungsschema zu erstellen.  Und erkl√§ren Sie die Bedeutung dieser Methode.  Ein Knoten wird als <code>leaf</code> wenn er keine <code>leaf</code> Elemente hat. Er wird verlassen, wenn er an seinem √ºbergeordneten Element vom linken Zeiger nach <code>left</code> w√§chst.  Dies steht im Namen der Methode. </p><br><p>  Aber warum Worte, lassen Sie uns zur Sache kommen, sehen, wie es war ... </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumOfLeftLeaves</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sumOfLeftLeaves(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumOfLeftLeaves</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left, TreeNode root)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.left == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; root.right == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; left) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> root.val; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sumOfLeftLeaves(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, root.left) + sumOfLeftLeaves(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, root.right); }</code> </pre> <br><p>  ... und wie es wurde </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Mono&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumOfLeftLeaves</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sumOfLeftLeaves(Mono.just(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) .flatMap(n -&gt; n.value) .reduce(Integer::sum); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Flux&lt;TreeNode&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumOfLeftLeaves</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Mono&lt;TreeNode&gt; node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node .flux() .concatMap(n -&gt; Flux.concat( sumOfLeftLeaves(n.left, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>), Flux.first(n.left, n.right) .map(x -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">0</span></span>)) .switchIfEmpty( Mono.just(n) ) .filter(x -&gt; left), sumOfLeftLeaves(n.right, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) )); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testSumOfLeftLeaves</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TreeNode tree = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">11</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">15</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">7</span></span>)) ); StepVerifier.create(tree.sumOfLeftLeaves()) .expectNext(<span class="hljs-number"><span class="hljs-number">26</span></span>) .expectComplete() .verify(); }</code> </pre> <br><p>  Wow!  So reaktiv.  Sehr asynchron.  Zu genial  Also null Sicherheit.  Viel Gegendruck.  So skalierbar ... </p><br><p>  √úbrigens haben wir noch eine Methode, bei der wir, wie ich Ihnen verspreche, all diese Kraft in die richtige Richtung lenken werden. </p><br><h3 id="searchbst">  searchBST </h3><br><p>  Jeder Baum tr√§umt davon, ein bin√§rer Suchbaum zu werden, und diese Methode hilft uns bei der Suche danach.  Das sagt alles, also zeige ich sofort, wie schrecklich es war und wie wunderbar es wurde. </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TreeNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">searchBST</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> searchBST(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, val); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TreeNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">searchBST</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TreeNode root, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val &lt; root.val) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> searchBST(root.left, val); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val &gt; root.val) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> searchBST(root.right, val); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> root; }</code> </pre> <br><p>  F√ºhle es einfach: </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Mono&lt;TreeNode&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testSearchBST</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> searchBST(Mono.just(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>), val); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Mono&lt;TreeNode&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">searchBST</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Mono&lt;TreeNode&gt; root, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> root.flatMap(node -&gt; node.value .filter(v -&gt; v &gt; val) .flatMap(v -&gt; searchBST(node.left, val)) .switchIfEmpty(node.value .filter(v -&gt; v &lt; val) .flatMap(v -&gt; searchBST(node.right, val)) .switchIfEmpty(node.value .filter(v -&gt; v == val) .flatMap(v -&gt; root) ) )); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">searchBST</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TreeNode tree = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">3</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">7</span></span>)); StepVerifier.create(tree.searchBST(<span class="hljs-number"><span class="hljs-number">3</span></span>).flatMap(n -&gt; n.value)) .expectNext(<span class="hljs-number"><span class="hljs-number">3</span></span>) .expectComplete() .verify(); }</code> </pre> <br><p>  Nichts mehr hinzuzuf√ºgen.  Das ist reaktive Programmierung, es ist die meiste. </p><br><h3 id="esche-ne-konec">  Noch nicht vorbei </h3><br><p>  Wenn du wirklich coole Dinge tust, ist es sehr schwierig aufzuh√∂ren.  Sie sind m√ºde, Ihre Augen sind geschlossen, Sie m√∂chten schlafen, aber in Ihrem Inneren sp√ºren Sie einen riesigen Strom von Motivation.  Wenn Sie alles richtig machen, k√∂nnen Sie nicht aufh√∂ren, dieses Gef√ºhl einfangen und die Welt weiter verbessern. </p><br><p>  Nachdem Sie die B√§ume beseitigt haben, gehen Sie ohne zu z√∂gern zu den guten alten, einfach verbundenen Listen √ºber.  Ihre Zeit ist noch nicht abgelaufen, dennoch pr√ºfen Tausende von Personen bei technischen Interviews, ob sie fixiert sind.  Es ist Zeit, es reaktiv zu machen. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListNode</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ListNode next; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.val = val; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val, ListNode next)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.val = val; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.next = next; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ListNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">... array)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array.length &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; ListNode head = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ListNode(array[<span class="hljs-number"><span class="hljs-number">0</span></span>]); ListNode tail = head; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; array.length; i++) { ListNode next = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ListNode(array[i]); tail.next = next; tail = next; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> head; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ListNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">last</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next.last(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListTestNode</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Mono&lt;Boolean&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasCycle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ListNode head)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Mono.justOrEmpty(head) .flatMapMany(node -&gt; { Flux&lt;ListNode&gt; flux = Flux.generate(() -&gt; head, (n, sink) -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { sink.complete(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } sink.next(n); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n.next; }); Flux&lt;ListNode&gt; fast = flux.skip(<span class="hljs-number"><span class="hljs-number">1</span></span>); Flux&lt;ListNode&gt; slow = flux.flatMap(n -&gt; Flux.just(n, n)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fast.zipWith(slow); }) .any(objects -&gt; objects.getT1() == objects.getT2()) .defaultIfEmpty(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasCycle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ StepVerifier.create(hasCycle(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)) .expectNext(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) .expectComplete() .verify(); ListNode withoutCycle = ListNode.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); StepVerifier.create(hasCycle(withoutCycle)) .expectNext(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) .expectComplete() .verify(); ListNode withCycle = ListNode.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); withCycle.last().next = withCycle.next.next; StepVerifier.create(hasCycle(withCycle)) .expectNext(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .expectComplete() .verify(); }</code> </pre> <br><p>  Da wir das Thema technische Interviews angesprochen haben, sollten wir nicht die geliebte Aufgabe vergessen, das Geh√§use von Klammern zu √ºberpr√ºfen.  Die Show muss weitergehen! </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Mono&lt;Boolean&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValidParentheses</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Flux.range(<span class="hljs-number"><span class="hljs-number">0</span></span>, s.length()) .map(s::charAt) .reduceWith(() -&gt; <span class="hljs-string"><span class="hljs-string">""</span></span>, (str, c) -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-string"><span class="hljs-string">'{'</span></span> || c == <span class="hljs-string"><span class="hljs-string">'['</span></span> || c == <span class="hljs-string"><span class="hljs-string">'('</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str + c; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> last = str.charAt(str.length() - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-string"><span class="hljs-string">'}'</span></span> &amp;&amp; last != <span class="hljs-string"><span class="hljs-string">'{'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-string"><span class="hljs-string">']'</span></span> &amp;&amp; last != <span class="hljs-string"><span class="hljs-string">'['</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-string"><span class="hljs-string">')'</span></span> &amp;&amp; last != <span class="hljs-string"><span class="hljs-string">'('</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, str.length() - <span class="hljs-number"><span class="hljs-number">1</span></span>); }) .map(String::isEmpty); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testIsValidParentheses</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ StepVerifier.create(isValidParentheses(<span class="hljs-string"><span class="hljs-string">"()"</span></span>)) .expectNext(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .expectComplete() .verify(); StepVerifier.create(isValidParentheses(<span class="hljs-string"><span class="hljs-string">"()[]{}"</span></span>)) .expectNext(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .expectComplete() .verify(); StepVerifier.create(isValidParentheses(<span class="hljs-string"><span class="hljs-string">"{()[]()}"</span></span>)) .expectNext(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .expectComplete() .verify(); StepVerifier.create(isValidParentheses(<span class="hljs-string"><span class="hljs-string">"()"</span></span>)) .expectNext(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .expectComplete() .verify(); StepVerifier.create(isValidParentheses(<span class="hljs-string"><span class="hljs-string">"(]"</span></span>)) .expectNext(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) .expectComplete() .verify(); StepVerifier.create(isValidParentheses(<span class="hljs-string"><span class="hljs-string">"([)]"</span></span>)) .expectNext(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) .expectComplete() .verify(); }</code> </pre> <br><p>  Wow  So unver√§nderlich ... Sehr reaktiv. </p><br><h3 id="sovet-nomer-dva">  Tipp Nummer zwei </h3><br><p>  √úbrigens, wie ich versprochen habe, steht am Ende des Artikels der Rat Nummer zwei: <code>               .</code>  Manchmal sieht es zumindest albern und unpraktisch aus. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481716/">https://habr.com/ru/post/de481716/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481704/index.html">Dies ist die Norm - 2: wie normale Karten gebacken werden</a></li>
<li><a href="../de481706/index.html">Verlorene Quantencomputer im Rennen und ihre fatalen Fehler</a></li>
<li><a href="../de481708/index.html">Ist PocketBook so gut?</a></li>
<li><a href="../de481710/index.html">Kurz gesagt, machte die hundertj√§hrige Blockbuster-Farbe</a></li>
<li><a href="../de481714/index.html">Warum Videospiele und Brettspiele nicht der beste Indikator f√ºr KI-F√§higkeiten sind (Interview mit dem Sch√∂pfer von Keras)</a></li>
<li><a href="../de481718/index.html">11 Faktoren und Hacks im Leben, die Ihre Effektivit√§t steigern</a></li>
<li><a href="../de481726/index.html">Laravel Lokalisiertes Routing</a></li>
<li><a href="../de481728/index.html">Pry -> REPL f√ºr Ruby, das ist es wert</a></li>
<li><a href="../de481730/index.html">Habe MPow T6 geh√∂rt - gro√üartige TWS-Kopfh√∂rer mit praktischer Steuerung</a></li>
<li><a href="../de481734/index.html">Erfahrung mit Kartendruckern, Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>