<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕒 😜 💡 So machen Sie SFINAE schlank und zuverlässig ❄️ 🛏️ 🐅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo nochmal. Wir teilen Ihnen einen interessanten Artikel mit, dessen Übersetzung speziell für Studenten des Kurses "C ++ Developer" erstellt wurde ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So machen Sie SFINAE schlank und zuverlässig</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/466915/">  <i>Hallo nochmal.</i>  <i>Wir teilen Ihnen einen interessanten Artikel mit, dessen Übersetzung speziell für Studenten des Kurses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"C ++ Developer" erstellt wurde</a> .</i> <br><br><img src="https://habrastorage.org/webt/i1/cn/mm/i1cnmmt1eyhcbyi9exnawbo2vgq.png"><br><br><hr><br>  Heute haben wir einen Gastbeitrag von dám Balázs.  Adam ist Softwareentwickler bei Verizon Smart Communities Hungary und entwickelt Videoanalysen für eingebettete Systeme.  Eine seiner Leidenschaften ist die Optimierung der Kompilierungszeit, daher stimmte er sofort zu, einen Gastbeitrag zu diesem Thema zu schreiben.  Sie finden Adam online auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LinkedIn</a> . <a name="habracut"></a><br><br>  In einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihe von Artikeln darüber, wie man SFINAE elegant macht</a> , haben wir gesehen, wie man unsere SFINAE-Vorlage ziemlich präzise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">und ausdrucksstark macht</a> . <br><br>  Schauen Sie sich einfach die ursprüngliche Form an: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; x)</span></span></span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_ = T&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> f(T&amp;&amp; x, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::enable_if&lt;!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_reference&lt;T_&gt;::value, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">nullptr_t</span></span>&gt;::type = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>){} };</code> </pre> <br><br>  Und vergleichen Sie es mit dieser ausdrucksstärkeren Form: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> IsNotReference = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_reference_v&lt;T&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; x)</span></span></span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_ = T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = IsNotReference &lt;T_&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> f(T&amp;&amp; x){} };</code> </pre> <br>  Wir können davon ausgehen, dass es bereits möglich ist, sich zu entspannen und es in der Produktion einzusetzen.  Wir könnten, es funktioniert in den meisten Fällen, aber - wenn wir über Schnittstellen sprechen - sollte unser Code sicher und zuverlässig sein.  Ist es so?  Versuchen wir es zu hacken! <br><br><h2>  Fehler Nr. 1: SFINAE kann umgangen werden </h2><br>  In der Regel wird SFINAE verwendet, um einen Teil des Codes abhängig von der Bedingung zu deaktivieren.  Dies kann sehr nützlich sein, wenn wir beispielsweise die benutzerdefinierte Funktion abs aus irgendeinem Grund implementieren müssen (benutzerdefinierte Rechenklasse, Optimierung für eine bestimmte Ausrüstung, zu Schulungszwecken usw.): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myAbs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T val )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt;::max() }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"a: "</span></span> &lt;&lt; a &lt;&lt; <span class="hljs-string"><span class="hljs-string">" myAbs( a ): "</span></span> &lt;&lt; myAbs( a ) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br>  Dieses Programm zeigt Folgendes an, was ganz normal aussieht: <br><br><pre> <code class="cpp hljs">a: <span class="hljs-number"><span class="hljs-number">2147483647</span></span> myAbs( a ): <span class="hljs-number"><span class="hljs-number">2147483647</span></span></code> </pre> <br>  Aber wir können unsere <code>abs</code> Funktion mit vorzeichenlosen Argumenten <code>T</code> aufrufen, und der Effekt wird katastrophal sein: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">nt </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt;::max() }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"a: "</span></span> &lt;&lt; a &lt;&lt; <span class="hljs-string"><span class="hljs-string">" myAbs( a ): "</span></span> &lt;&lt; myAbs( a ) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br>  In der Tat zeigt das Programm jetzt Folgendes an: <br><br> <code>a: 4294967295 myAbs( a ): 1</code> <br> <br>  Unsere Funktion war nicht dafür ausgelegt, mit vorzeichenlosen Argumenten zu arbeiten, daher müssen wir die mögliche Menge von <code>T</code> mit SFINAE begrenzen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> IsSigned = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_signed_v&lt; T &gt; &gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = IsSigned&lt; T &gt; &gt; T myAbs( T val ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); }</code> </pre> <br>  Der Code funktioniert wie erwartet: Ein Aufruf von myAbs mit einem vorzeichenlosen Typ verursacht einen Fehler bei der Kompilierung: <br><br> <code><code>candidate template ignored: requirement 'std::is_signed_v&lt;</code> unsigned int&gt;' was not satisfied [with T = unsigned int]</code> <br> <br><h3>  SFINAE-Staat hacken </h3><br>  Was ist dann falsch an dieser Funktion?  Um diese Frage zu beantworten, müssen wir überprüfen, wie myAbs SFINAE implementiert. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = IsSigned&lt;T&gt; &gt; T myAbs( T val );</code> </pre> <br>  <code>myAbs</code> ist eine Funktionsvorlage mit zwei Arten von Eingabeschablonenparametern.  Der erste ist der tatsächliche Typ des Funktionsarguments, der zweite ist der Standardtyp <code><code>IsSigned &lt;</code> T <code>&gt;</code></code> (andernfalls <code><code>std::enable_if_t &lt;</code> std::is_signed_v <code>&lt;</code> T <code>&gt;</code> &gt;</code> oder <code><code>std::enable_if &lt;</code> std::is_signed_v <code>&lt;</code> T&gt;, void&gt;::type</code> , der <code>void</code> oder fehlgeschlagen ist). <br><br>  Wie können wir <code>myAbs</code> ?  Es gibt drei Möglichkeiten: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a{ myAbs( <span class="hljs-number"><span class="hljs-number">-5</span></span> ) }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b{ myAbs&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt;( <span class="hljs-number"><span class="hljs-number">-5</span></span> ) }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c{ myAbs&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> &gt;( <span class="hljs-number"><span class="hljs-number">-5</span></span> ) };</code> </pre> <br>  Der erste und der zweite Aufruf sind unkompliziert, aber der dritte ist interessant: Was ist das Argument der <code>void</code> Vorlage? <br><br>  Der zweite Vorlagenparameter ist anonym, hat einen Standardtyp, ist jedoch weiterhin ein Vorlagenparameter, sodass Sie ihn explizit angeben können.  Ist das ein Problem?  In diesem Fall ist dies wirklich ein großes Problem.  Wir können das dritte Formular verwenden, um unseren SFINAE-Scheck zu umgehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d{ myAbs&lt; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> &gt;( <span class="hljs-number"><span class="hljs-number">5u</span></span> ) }; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> e{ myAbs&lt; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> &gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt;::max() ) };</code> </pre> <br>  Dieser Code lässt sich gut kompilieren, führt jedoch zu katastrophalen Ergebnissen, um zu vermeiden, dass wir SFINAE verwendet haben: <br><br><pre> <code class="cpp hljs">a: <span class="hljs-number"><span class="hljs-number">4294967295</span></span> myAbs( a ): <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Wir werden dieses Problem lösen - aber zuerst: Gibt es noch andere Nachteile?  Nun ... <br><br><h2>  Fehler Nr. 2: Wir können keine spezifischen Implementierungen haben </h2><br>  Eine weitere häufige Verwendung von SFINAE besteht darin, bestimmte Implementierungen für bestimmte Bedingungen zur Kompilierungszeit bereitzustellen.  Was ist, wenn wir den Aufruf von <code>myAbs</code> mit <code>myAbs</code> Werten nicht vollständig verbieten und eine triviale Implementierung für diese Fälle bereitstellen möchten?  Wir können if constexpr in C ++ 17 verwenden (wir werden dies später diskutieren), oder wir können: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> IsSigned = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_signed_v&lt; T &gt; &gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> IsUnsigned = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_unsigned_v&lt; T &gt; &gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = IsSigned&lt; T &gt; &gt; T myAbs( T val ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = IsUnsigned&lt; T &gt; &gt; T myAbs( T val ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; }</code> </pre> <br>  Aber was ist das? <br><br><pre> <code class="cpp hljs">error: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> parameter redefines <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> argument <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = IsUnsigned&lt; T &gt; &gt; note: previous <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> argument defined here <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = IsSigned&lt; T &gt; &gt;</code> </pre> <br>  <i><b>Oh, der C ++ - Standard (C ++ 17; §17.1.16) besagt Folgendes</b> :</i> <br><br><blockquote>  "Die Standardargumente sollten dem Vorlagenparameter nicht durch zwei verschiedene Deklarationen im selben Bereich bereitgestellt werden." </blockquote><br>  Ups, genau das haben wir getan ... <br><br><h3>  Warum nicht regelmäßig verwenden, wenn? </h3><br>  Wir könnten stattdessen nur zur Laufzeit verwenden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myAbs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T val )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_signed_v&lt; T &gt; ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } }</code> </pre> <br>  Der Compiler würde die Bedingung optimieren, da <code><code>if (std::is_signed_v &lt;</code> T&gt;)</code> <code>if (false)</code> nach dem Erstellen der Vorlage zu <code>if (true)</code> oder <code>if (false)</code> .  Ja, mit unserer aktuellen Implementierung von <code>myAbs</code> dies funktionieren.  Insgesamt bedeutet dies jedoch eine enorme Einschränkung: Die <code>if</code> und <code>else</code> müssen für jedes <code>T</code> gültig sein <code>T</code>  Was ist, wenn wir unsere Implementierung ein wenig ändern: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myAbs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T val )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_signed_v&lt; T &gt; ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>( val ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a{ myAbs( <span class="hljs-number"><span class="hljs-number">5u</span></span> ) }; }</code> </pre> <br>  Unser Code stürzt sofort ab: <br><br><pre> <code class="cpp hljs">error: call of overloaded <span class="hljs-string"><span class="hljs-string">'abs(unsigned int&amp;)'</span></span> is ambiguous</code> </pre> <br>  Diese Einschränkung beseitigt SFINAE: Wir können Code schreiben, der nur für eine Teilmenge von T gültig ist (in myAbs ist er nur für vorzeichenlose Typen oder nur für vorzeichenbehaftete Typen gültig). <br><br><h3>  Lösung: ein anderes Formular für SFINAE </h3><br>  Was können wir tun, um diese Mängel zu beheben?  Für das erste Problem müssen wir unsere SFINAE-Prüfung erzwingen, unabhängig davon, wie Benutzer unsere Funktion aufrufen.  Derzeit kann unser Test umgangen werden, wenn der Compiler nicht den Standardtyp für den zweiten Vorlagenparameter benötigt. <br><br>  Was ist, wenn wir unseren SFINAE-Code verwenden, um einen Vorlagenparametertyp zu deklarieren, anstatt einen Standardtyp anzugeben?  Versuchen wir mal: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> IsSigned = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_signed_v&lt; T &gt;, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> &gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, IsSigned&lt; T &gt; = <span class="hljs-literal"><span class="hljs-literal">true</span></span> &gt; T myAbs( T val ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//int a{ myAbs( 5u ) }; int b{ myAbs&lt; int &gt;( 5u ) }; //int c{ myAbs&lt; unsigned int, true &gt;( 5u ) }; }</span></span></code> </pre> <br>  In gültigen Fällen muss IsSigned ein anderer Typ als void sein, da wir einen Standardwert für diesen Typ angeben möchten.  Es gibt keinen Wert für den void-Typ, daher sollten wir etwas anderes verwenden: bool, int, enum, nullptr_t usw. Normalerweise verwende ich bool - in diesem Fall sehen die Ausdrücke aussagekräftig aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, IsSigned&lt; T &gt; = <span class="hljs-literal"><span class="hljs-literal">true</span></span> &gt;</code> </pre> <br>  Es funktioniert!  Für <code>myAbs (5u)</code> Compiler wie zuvor einen Fehler aus: <br><br><pre> <code class="cpp hljs">candidate <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> ignored: requirement <span class="hljs-string"><span class="hljs-string">'std::is_signed_v&lt;unsigned int&gt;'</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> satisfied [with T = <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span></code> </pre> <br>  Der zweite Aufruf, <code><code>myAbs &lt;</code> int&gt; (5u)</code> ist noch gültig. Wir teilen dem Compilertyp <code>T</code> explizit mit, sodass er <code>5u</code> in <code>int</code> konvertiert. <br><br>  Schließlich können wir <code>myAbs</code> nicht mehr um den Finger <code><code>myAbs &lt; unsigned int, true&gt; (5u)</code></code> verfolgen: <code><code>myAbs &lt;</code> unsigned int, true&gt; (5u)</code> einen Fehler aus.  Es spielt keine Rolle, ob wir im Aufruf einen Standardwert angeben oder nicht, ein Teil des SFINAE-Ausdrucks wird trotzdem ausgewertet, da der Compiler einen Argumenttyp eines anonymen Vorlagenwerts benötigt. <br><br>  Wir können mit dem nächsten Problem fortfahren - aber warten Sie eine Minute!  Ich denke, wir überschreiben nicht mehr das Standardargument für denselben Vorlagenparameter. Wie war die ursprüngliche Situation? <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = IsUnsigned&lt; T &gt; &gt; T myAbs( T val ); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = IsSigned&lt; T &gt; &gt; T myAbs( T val );</code> </pre> <br>  Aber jetzt mit dem aktuellen Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, IsUnsigned&lt; T &gt; = <span class="hljs-literal"><span class="hljs-literal">true</span></span> &gt; T myAbs( T val ); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, IsSigned&lt; T &gt; = <span class="hljs-literal"><span class="hljs-literal">true</span></span> &gt; T myAbs( T val );</code> </pre> <br>  Es sieht dem vorherigen Code sehr ähnlich, so dass wir vielleicht denken, dass dies auch nicht funktioniert, aber tatsächlich hat dieser Code nicht das gleiche Problem.  Was ist <code><code>IsUnsigned &lt;</code> T&gt;</code> ?  Bool oder fehlgeschlagene Suche.  Und was ist <code><code>IsSigned &lt;</code> T&gt;</code> ?  Das Gleiche, aber wenn einer von ihnen Bool ist, ist der andere eine fehlgeschlagene Suche. <br><br>  Dies bedeutet, dass wir die Standardargumente nicht überschreiben, da es nur eine Funktion mit dem Vorlagenargument bool gibt, die andere eine fehlgeschlagene Ersetzung ist und daher nicht vorhanden ist. <br><br><h3>  Syntaktischer Zucker </h3><br>  <i><b>UPD</b></i>  <i>Dieser Absatz wurde vom Autor aufgrund von darin gefundenen Fehlern gelöscht.</i> <br><br><h3>  Alte Versionen von C ++ </h3><br>  Alle oben genannten Funktionen funktionieren mit C ++ 11, der einzige Unterschied besteht in der Ausführlichkeit der Definitionen von Einschränkungen zwischen Standardversionen: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//C++11 template&lt; typename T &gt; using IsSigned = typename std::enable_if&lt; std::is_signed&lt; T &gt;::value, bool &gt;::type; //C++14 - std::enable_if_t template&lt; typename T &gt; using IsSigned = std::enable_if_t&lt; std::is_signed&lt; T &gt;::value, bool &gt;; //C++17 - std::is_signed_v template&lt; typename T &gt; using IsSigned = std::enable_if_t&lt; std::is_signed_v&lt; T &gt;, bool &gt;;</span></span></code> </pre> <br>  Die Vorlage bleibt jedoch gleich: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, IsSigned&lt; T &gt; = <span class="hljs-literal"><span class="hljs-literal">true</span></span> &gt;</code> </pre> <br>  Im guten alten C ++ 98 gibt es keine Vorlagen-Aliase. Außerdem können Funktionsvorlagen keine Typen oder Standardwerte haben.  Wir können unseren SFINAE-Code in den Ergebnistyp oder nur in die Liste der Funktionsparameter einfügen.  Die zweite Option wird empfohlen, da die Konstruktoren keine Ergebnistypen haben.  Das Beste, was wir tun können, ist ungefähr so: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myAbs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T val, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> my_enable_if&lt; my_is_signed&lt; T &gt;::value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &gt;::type = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); }</code> </pre> <br>  Nur zum Vergleich - die moderne Version von C ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, IsSigned&lt; T &gt; = <span class="hljs-literal"><span class="hljs-literal">true</span></span> &gt; T myAbs( T val ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); }</code> </pre> <br>  Die C ++ 98-Version ist hässlich, führt einen bedeutungslosen Parameter ein, funktioniert aber - Sie können ihn verwenden, wenn dies unbedingt erforderlich ist.  Und ja: <code>my_enable_if</code> und <code>my_is_signed</code> sollten implementiert werden ( <code>std :: enable_if  std :: is_signed</code> waren neu in C ++ 11). <br><br><h3>  Aktueller Zustand </h3><br>  C ++ 17 wurde eingeführt, <code>if constexpr</code> , eine Methode zum Verwerfen von Code basierend auf Bedingungen zur Kompilierungszeit.  Sowohl if- als auch else-Anweisungen müssen syntaktisch korrekt sein, die Bedingung wird jedoch zur Kompilierungszeit ausgewertet. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myAbs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T val )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_signed_v&lt; T &gt; )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_unsigned_v&lt; T &gt; ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } <span class="hljs-comment"><span class="hljs-comment">/*else { static_assert( false, "T must be signed or unsigned arithmetic type." ); }*/</span></span> } }</code> </pre> <br>  Wie wir sehen können, ist unsere Bauchmuskelfunktion kompakter und leichter zu lesen.  Der Umgang mit nicht konformen Typen ist jedoch nicht einfach.  Der <code>static_assert</code> bedingungslose <code>static_assert</code> macht diese Aussage schlecht konsistent, was vom Standard verboten ist, unabhängig davon, ob sie verworfen wird oder nicht. <br><br>  Glücklicherweise gibt es eine Lücke: In Vorlagenobjekten werden abgelegte Operatoren nicht erstellt, wenn die Bedingung vom Wert unabhängig ist.  Großartig! <br><br>  Das einzige Problem mit unserem Code ist, dass er während der Vorlagendefinition abstürzt.  Wenn wir die Auswertung von <code>static_assert</code> bis zum Zeitpunkt der <code>static_assert</code> der Vorlage verschieben könnten, wäre das Problem gelöst: Sie würde nur dann erstellt, wenn alle unsere Bedingungen falsch sind.  Aber wie können wir <code>static_assert</code> verschieben, bis die Vorlage erstellt wird?  Machen Sie seinen Zustand abhängig vom Typ! <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> dependent_false_v{ <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myAbs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T val )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_signed_v&lt; T &gt; )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_unsigned_v&lt; T &gt; ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( dependent_false_v&lt; T &gt;, <span class="hljs-string"><span class="hljs-string">"Unsupported type"</span></span> ); } } }</code> </pre> <br><h3>  Über die Zukunft </h3><br>  Wir sind uns schon sehr nahe, aber wir müssen eine Weile warten, bis C ++ 20 die endgültige Lösung bringt: Konzepte!  Dadurch wird die Art und Weise, wie Vorlagen (und SFINAE) verwendet werden, vollständig geändert. <br><br>  Kurz gesagt: Konzepte können verwendet werden, um die Anzahl der Argumente zu begrenzen, die für Vorlagenparameter akzeptiert werden.  Für unsere Bauchmuskelfunktion könnten wir das folgende Konzept verwenden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-function">concept </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Arithmetic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_arithmetic_v&lt; T &gt;; }</code> </pre> <br>  Und wie können wir Konzepte verwenden?  Es gibt drei Möglichkeiten: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   template&lt; typename T &gt; requires Arithmetic&lt; T &gt;() T myAbs( T val ); //   template&lt; Arithmetic T &gt; T myAbs( T val ); //  Arithmetic myAbs( Arithmetic val );</span></span></code> </pre> <br>  Beachten Sie, dass das dritte Formular immer noch eine Vorlagenfunktion deklariert!  Hier ist die vollständige Implementierung von myAbs in C ++ 20: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-function">concept </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Arithmetic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_arithmetic_v&lt; T &gt;; } <span class="hljs-function"><span class="hljs-function">Arithmetic </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myAbs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Arithmetic val )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_signed_v&lt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decltype</span></span></span></span><span class="hljs-function"><span class="hljs-params">( val ) &gt; )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a{ myAbs( <span class="hljs-number"><span class="hljs-number">5u</span></span> ) }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b{ myAbs&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt;( <span class="hljs-number"><span class="hljs-number">5u</span></span> ) }; <span class="hljs-comment"><span class="hljs-comment">//std::string c{ myAbs( "d" ) }; }</span></span></code> </pre> <br>  Ein auskommentierter Aufruf gibt den folgenden Fehler aus: <br><br><pre> <code class="cpp hljs">error: cannot call function <span class="hljs-string"><span class="hljs-string">'auto myAbs(auto:1) [with auto:1 = const char*]'</span></span> constraints <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> satisfied within <span class="hljs-string"><span class="hljs-string">'template&lt;class T&gt; concept bool Arithmetic() [with T = const char*]'</span></span> <span class="hljs-function"><span class="hljs-function">concept </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Arithmetic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ ^~~~~~~~~~ <span class="hljs-string"><span class="hljs-string">'std::is_arithmetic_v'</span></span> evaluated to <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  Ich fordere alle auf, diese Methoden mutig im Produktionscode zu verwenden. Die Kompilierungszeit ist billiger als die Laufzeit.  Viel Spaß beim SFINAEing! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466915/">https://habr.com/ru/post/de466915/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466899/index.html">Warum alles fallen lassen und jetzt Swift und Kotlin lernen?</a></li>
<li><a href="../de466903/index.html">Präsentieren Sie immer Ihre Arbeit</a></li>
<li><a href="../de466905/index.html">Zur Frage des U-Boot</a></li>
<li><a href="../de466907/index.html">5G und WiFi 6: Wenn zwei Netzwerktechnologien besser sind als eine</a></li>
<li><a href="../de466911/index.html">Das US-Gericht hat das Scraping von Websites vollständig legalisiert und die technische Behinderung verboten</a></li>
<li><a href="../de466917/index.html">Wenn der HTTP-Standard nicht ausreicht. Mikronaut begehen</a></li>
<li><a href="../de466921/index.html">5 Probleme eines Serviceunternehmens und deren Lösung mithilfe der Automatisierungsplattform</a></li>
<li><a href="../de466923/index.html">Wie IT-Profis in einer ausländischen Bank die Herkunft von Geldern nachweisen können</a></li>
<li><a href="../de466925/index.html">Wie man Hi-CPU VDS für Bitrix ausführt, Papageien zerstreut und nicht pleite geht</a></li>
<li><a href="../de466929/index.html">Aktualisierungstoken hinzufügen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>