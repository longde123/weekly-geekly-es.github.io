<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹🏽 💃🏻 ↔️ 数学家的预测。 我们分析了检测异常的主要方法 👨🏽‍🎓 👨🏻‍💼 😁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在工业中将人工智能用于各种系统的预测性维护在国外越来越受欢迎。 该方法的目的是在操作阶段确定系统运行中的故障，直到系统出现故障为止，以便及时做出响应。 

 这种方法在我国和西方有多重要？ 例如，可以在有关《哈布雷》和《媒介》的文章中得出结论。 在Habré上几乎没有关于解决预测性维护问题的文章。 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>数学家的预测。 我们分析了检测异常的主要方法</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lanit/blog/447190/"> 在工业中将人工智能用于各种系统的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">预测性维护在</a>国外越来越受欢迎。 该方法的目的是在操作阶段确定系统运行中的故障，直到系统出现故障为止，以便及时做出响应。 <br><br> 这种方法在我国和西方有多重要？ 例如，可以在有关《哈布雷》和《媒介》的文章中得出结论。 在Habré上几乎没有关于解决预测性维护问题的文章。 在Medium上有一整套。 在这里， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里都</a>很好地描述了这种方法的目标和优势。 <br><br> 通过本文，您将学到： <br><br><ul><li> 为什么需要这种技术 </li><li> 哪种机器学习方法更常用于预测性维护， </li><li> 我如何通过一个简单的例子尝试其中的一些技巧。 </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/845/2a4/888/8452a4888db8d633dd14d426f6b80cbe.jpg"></div>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i>来源</i></a> <br><a name="habracut"></a><br> 预测服务提供哪些功能？ <br><br><ul><li> 控制修理工作的过程，必要时进行，从而节省了金钱，而且不着急，从而改善了这些工作的质量 </li><li> 识别设备运行中的特定故障（在设备运行时购买特定零件进行更换的能力提供了巨大的优势）； </li><li> 优化设备操作，负荷等； </li><li> 减少定期关闭设备的成本。 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下一篇有关Medium的文章</a>很好地描述了需要理解的问题，以了解如何在特定情况下解决此问题。 <br><br> 在收集数据或选择数据以构建模型时，重要的是要回答三组问题： <br><br><ol><li> 是否可以预测所有系统问题？ 哪个预测特别重要？ </li><li> 什么是失败过程？ 整个系统会停止工作还是仅更改工作模式？ 它是一个快速的过程，是瞬时的还是逐渐的退化？ </li><li> 系统性能是否足以反映其性能？ 它们与系统的各个部分或整个系统有关吗？ </li></ol><br> 事先了解您要预测的内容，可以预测的内容和不能预测的内容也很重要。 <br><br> 关于Medium的文章还列出了有助于确定您的特定目标的问题： <br><br><ul><li> 需要预测什么？ 剩余寿命，是否有异常行为，在接下来的N小时/天/周内发生故障的概率是多少？ </li><li> 是否有足够的历史数据？ </li><li> 是否知道系统何时给出异常读数，何时不给出。 是否可以标记此类指示？ </li><li> 模型应该看多远？ 读数在一小时/天/周的间隔中反映系统运行的独立性如何 </li><li> 您需要优化什么？ 该模型应该在发出错误警报的同时捕获尽可能多的违规，还是足以捕获无误报的多个事件。 </li></ul><br> 希望将来情况会有所改善。 迄今为止，在预测性维护领域中存在困难：很少有系统故障或系统故障时刻的例子，但它们没有被标记； 故障过程是未知的。 <br><br> 解决预测维护困难的主要途径是使用<b>异常搜索方法</b> 。 这样的算法不需要标记来进行训练。 对于测试和调试算法，必须以一种或另一种形式进行标记。 这种方法的局限性在于它们不能预测特定的故障，而只能指示指示器的异常。 <br><br> 但这已经不错。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/847/46c/6d7/84746c6d7414722b0a1b7b322000f201.jpg"></div>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i>来源</i></a> <br><br><h2> 方法 </h2><br> 现在，我想谈谈异常检测方法的一些功能，然后我们将一起在实践中测试一些简单算法的功能。 <br><br> 尽管在特定情况下将需要测试几种算法以查找异常并选择最佳算法，但是有可能确定该领域中使用的主要技术的一些优点和缺点。 <br><br> 首先，重要的是要事先了解数据中异常的百分比。 <br><br> 如果我们谈论的是半监督方法的一种变体（我们仅研究“正常”数据，然后进行工作（测试），然后研究异常数据），那么最佳选择就是<b>一类支持向量方法（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">One-Class SVM</a> ）</b> 。 当使用径向基函数作为内核时，此算法在原点周围构造一个非线性曲面。 训练数据越干净，效果越好。 <br><br> 在其他情况下，仍然需要知道异常点与“正常”点的比率-确定截止阈值。 <br><br> 如果数据中异常的数量超过5％，并且可以与主样本很好地分离，则可以使用标准的异常搜索方法。 <br><br> 在这种情况下，就质量而言， <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">隔离林</a>方法</b>是最稳定的： <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">隔离林是</a></b>随机数据。 更具特征性的指示更有可能更深入，而不寻常的指示则将在第一次迭代中与其余样本分离。 <br><br> 如果其他算法“适合”数据的具体情况，则效果更好。 <br><br> 当数据具有正态分布时， <b>椭圆包络法</b>是合适的，以多维正态分布近似数据。 该点属于分布的可能性越小，则该点异常的可能性就越大。 <br><br> 如果以这样的方式显示数据：不同点的相对位置很好地反映了它们的差异，那么度量方法似乎是一个不错的选择：例如， <b>k个最近的邻居，第k个最近的邻居，ABOD（基于角度的离群值检测）或LOF（局部离群值因子） ）</b> <br><br> 所有这些方法表明，“正确”的指标集中在多维空间的一个区域。 如果在第k个（或第k个）最近的邻居中，所有事物都离目标较远，则该点就是一个异常。 对于ABOD，其推理类似：如果相对于所考虑的k个点，所有k个最近的点都在相同的空间扇区中，则该点是异常的。 对于LOF：如果局部密度（对于每个点，由k个最近的邻居确定）低于k个最近的邻居，则该点是异常的。 <br><br> 如果数据聚类良好，则<b>基于聚类分析的方法</b>是一个不错的选择。 如果该点与几个群集的中心等距，则为异常。 <br><br> 如果在数据中很好地区分了最大方差变化的方向，那么<b>基于主成分法搜索异常</b>似乎是一个不错的选择。 在这种情况下，将n1（最“主要”分量）和n2（最不“主要”分量）的平均值偏差视为异常度量。 <br><br> 例如，建议查看<b>The Prognostics and Health Management Society（PHM Society）</b>的数据集。 这个非营利组织每年都会安排比赛。 例如，在2018年， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">需要预测操作错误以及离子束蚀刻厂发生故障之前的时间</a> 。 我们将采用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2015年</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据集</a> 。 它包含用于30个安装的多个传感器的读数（培训样本），并且需要预测何时以及将发生什么错误。 <br><br> 我没有在网络上找到测试样本的答案，因此我们只会训练一个。 <br><br> 通常，所有设置都是相似的，但在组件数量，异常数量等方面有所不同。 因此，在前20个学习，而在其他20个测试则没有太大意义。 <br><br> 因此，我们将选择一种安装方式，将其加载并查看这些数据。 本文将不涉及<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">功能工程</a> ，因此我们不会过多关注。 <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt %matplotlib inline <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> seaborn <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> sns <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.covariance <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> EllipticEnvelope <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.neighbors <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> LocalOutlierFactor <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.ensemble <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> IsolationForest <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.svm <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> OneClassSVM dfa=pd.read_csv(<span class="hljs-string"><span class="hljs-string">'plant_12a.csv'</span></span>,names=[<span class="hljs-string"><span class="hljs-string">'Component number'</span></span>,<span class="hljs-string"><span class="hljs-string">'Time'</span></span>,<span class="hljs-string"><span class="hljs-string">'S1'</span></span>,<span class="hljs-string"><span class="hljs-string">'S2'</span></span>,<span class="hljs-string"><span class="hljs-string">'S3'</span></span>,<span class="hljs-string"><span class="hljs-string">'S4'</span></span>,<span class="hljs-string"><span class="hljs-string">'S1ref'</span></span>,<span class="hljs-string"><span class="hljs-string">'S2ref'</span></span>,<span class="hljs-string"><span class="hljs-string">'S3ref'</span></span>,<span class="hljs-string"><span class="hljs-string">'S4ref'</span></span>]) dfa.head(<span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/301/77e/2bb/30177e2bb970e82495b18008b44d7ea4.jpg"></div><br> 如您所见，有七个组件，每个组件每15分钟读取四个传感器的读数。 比赛说明中的S1ref-S4ref作为参考值列出，但这些值与传感器的读数有很大不同。 为了不浪费时间思考它们的含义，我们将其删除。 如果查看每个要素（S1-S4）的值分布，结果发现S1，S2和S4的分布是连续的，而S3的分布是离散的。 此外，如果查看S2和S4的联合分布，结果发现它们成反比。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69b/82b/cde/69b82bcdecdfca69128d88673b0518b4.jpg"></div><br> 尽管偏离直接依赖关系可能表明存在错误，但我们将不检查此错误，而只是删除S4。 <br><br> 我们再次处理数据集。 离开S1，S2和S3。 我们使用StandardScaler缩放S1和S2（减去平均值并除以标准差），将S3转换为OHE（一次热编码）。 我们将所有安装组件的读数缝在一起。 共有89个功能。  2 * 7 = 14-7个组件的读数S1和S2和R3的75个唯一值。 只有5.6万条这样的线路。 <br><br> 上载有错误的文件。 <br><br><pre> <code class="python hljs">dfc=pd.read_csv(<span class="hljs-string"><span class="hljs-string">'plant_12c.csv'</span></span>,names=[<span class="hljs-string"><span class="hljs-string">'Start Time'</span></span>, <span class="hljs-string"><span class="hljs-string">'End Time'</span></span>,<span class="hljs-string"><span class="hljs-string">'Type'</span></span>]) dfc.head()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ad/419/e50/3ad419e50ac870a71c153b523a22bfed.jpg"></div><br> 在我们的数据集上尝试这些算法之前，我将允许自己再做一个小小的题外话。 您需要测试。 为此，建议采用错误的开始时间和结束时间。 并且在此间隔内的所有指示均被视为异常，而在外部-正常。 这种方法有许多缺点。 但是尤其是一种错误行为很可能发生在错误修复之前。 为了保真，让我们在半小时前及时转移异常窗口。 我们将评估F1量度，精度和召回率。 <br><br> 用于区分功能和确定模型质量的代码： <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_and_preprocess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(plant_num)</span></span></span><span class="hljs-function">:</span></span>   <span class="hljs-comment"><span class="hljs-comment">#      ,       dfa=pd.read_csv('plant_{}a.csv'.format(plant_num),names=['Component number','Time','S1','S2','S3','S4','S1ref','S2ref','S3ref','S4ref'])   dfc=pd.read_csv('plant_{}c.csv'.format(plant_num),names=['Start Time','End Time','Type']).drop(0,axis=0)   N_comp=len(dfa['Component number'].unique())   #  15    dfa['Time']=pd.to_datetime(dfa['Time']).dt.round('15min')   #  6    (  ,    )   dfc=dfc[dfc['Type']!=6]   dfc['Start Time']=pd.to_datetime(dfc['Start Time'])   dfc['End Time']=pd.to_datetime(dfc['End Time'])   #      ,       OHE  3-    dfa=pd.concat([dfa.groupby('Time').nth(i)[['S1','S2','S3']].rename(columns={"S1":"S1_{}".format(i),"S2":"S2_{}".format(i),"S3":"S3_{}".format(i)}) for i in range(N_comp)],axis=1).dropna().reset_index()   for k in range(N_comp):       dfa=pd.concat([dfa.drop('S3_'+str(k),axis=1),pd.get_dummies(dfa['S3_'+str(k)],prefix='S3_'+str(k))],axis=1).reset_index(drop=True)   #          df_train,df_test=train_test_split(dfa,test_size=0.25,shuffle=False)   cols_to_scale=df_train.filter(regex='S[1,2]').columns   scaler=preprocessing.StandardScaler().fit(df_train[cols_to_scale])   df_train[cols_to_scale]=scaler.transform(df_train[cols_to_scale])   df_test[cols_to_scale]=scaler.transform(df_test[cols_to_scale])   return df_train,df_test,dfc #       def get_true_labels(measure_times,dfc,shift_delta):   idxSet=set()   dfc['Start Time']-=pd.Timedelta(minutes=shift_delta)   dfc['End Time']-=pd.Timedelta(minutes=shift_delta)   for idx,mes_time in tqdm_notebook(enumerate(measure_times),total=measure_times.shape[0]):       intersect=np.array(dfc['Start Time']&lt;mes_time).astype(int)*np.array(dfc['End Time']&gt;mes_time).astype(int)       idxs=np.where(intersect)[0]       if idxs.shape[0]:           idxSet.add(idx)   dfc['Start Time']+=pd.Timedelta(minutes=shift_delta)   dfc['End Time']+=pd.Timedelta(minutes=shift_delta)   true_labels=pd.Series(index=measure_times.index)   true_labels.iloc[list(idxSet)]=1   true_labels.fillna(0,inplace=True)   return true_labels #          def check_model(model,df_train,df_test,filt='S[123]'):   model.fit(df_train.drop('Time',axis=1).filter(regex=(filt)))   y_preds = pd.Series(model.predict(df_test.drop(['Time','Label'],axis=1).filter(regex=(filt)))).map({-1:1,1:0})   print('F1 score: {:.3f}'.format(f1_score(df_test['Label'],y_preds)))   print('Precision score: {:.3f}'.format(precision_score(df_test['Label'],y_preds)))   print('Recall score: {:.3f}'.format(recall_score(df_test['Label'],y_preds)))   score = model.decision_function(df_test.drop(['Time','Label'],axis=1).filter(regex=(filt)))   sns.distplot(score[df_test['Label']==0])   sns.distplot(score[df_test['Label']==1]) df_train,df_test,anomaly_times=load_and_preprocess(12) df_test['Label']=get_true_labels(df_test['Time'],dfc,30)</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50b/6f2/be9/50b6f2be9c3220853e92461805030e0b.jpg"></div>  <i>PHM 2015 Data Challenge数据集上简单异常搜索算法的测试结果</i> <br><br> 回到算法。 让我们在数据上尝试一个Class SVM（OCSVM），IsolationForest（IF），EllipticEnvelope（EE）和LocalOutlierFactor（LOF）。 首先，我们将不设置任何参数。 我注意到LOF可以在两种模式下工作。 如果novellity = False只能在训练集中搜索异常（只有fit_predict），如果为True，则其目的是在训练集中搜索异常（可以单独拟合和预测）。  IF具有旧的和新的行为模式。 我们使用新的。 他给出了更好的结果。 <br><br>  OCSVM可以很好地检测到异常，但是假阳性过多。 对于其他方法，结果甚至更糟。 <br><br> 但是假设我们知道数据中异常的百分比。 在我们的案例中，为27％。  OCSVM具有nu-误差百分比的上限估计值，而支持向量的百分比下限值。 其他污染方法具有一定百分比的数据错误。 在IF和LOF方法中，它是自动确定的，而对于OCSVM和EE，默认情况下将其设置为0.1。 让我们尝试将污染（nu）设置为0.27。 现在是EE的最佳结果。 <br><br> 用于检查模型的代码： <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check_model</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model,df_train,df_test,filt=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'S[123]'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span>   model_type,model = model   model.fit(df_train.drop(<span class="hljs-string"><span class="hljs-string">'Time'</span></span>,axis=<span class="hljs-number"><span class="hljs-number">1</span></span>).filter(regex=(filt)))   y_preds = pd.Series(model.predict(df_test.drop([<span class="hljs-string"><span class="hljs-string">'Time'</span></span>,<span class="hljs-string"><span class="hljs-string">'Label'</span></span>],axis=<span class="hljs-number"><span class="hljs-number">1</span></span>).filter(regex=(filt)))).map({<span class="hljs-number"><span class="hljs-number">-1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>})   print(<span class="hljs-string"><span class="hljs-string">'F1 score for {}: {:.3f}'</span></span>.format(model_type,f1_score(df_test[<span class="hljs-string"><span class="hljs-string">'Label'</span></span>],y_preds)))   print(<span class="hljs-string"><span class="hljs-string">'Precision score for {}: {:.3f}'</span></span>.format(model_type,precision_score(df_test[<span class="hljs-string"><span class="hljs-string">'Label'</span></span>],y_preds)))   print(<span class="hljs-string"><span class="hljs-string">'Recall score for {}: {:.3f}'</span></span>.format(model_type,recall_score(df_test[<span class="hljs-string"><span class="hljs-string">'Label'</span></span>],y_preds)))   score = model.decision_function(df_test.drop([<span class="hljs-string"><span class="hljs-string">'Time'</span></span>,<span class="hljs-string"><span class="hljs-string">'Label'</span></span>],axis=<span class="hljs-number"><span class="hljs-number">1</span></span>).filter(regex=(filt)))   sns.distplot(score[df_test[<span class="hljs-string"><span class="hljs-string">'Label'</span></span>]==<span class="hljs-number"><span class="hljs-number">0</span></span>])   sns.distplot(score[df_test[<span class="hljs-string"><span class="hljs-string">'Label'</span></span>]==<span class="hljs-number"><span class="hljs-number">1</span></span>])   plt.title(<span class="hljs-string"><span class="hljs-string">'Decision score distribution for {}'</span></span>.format(model_type))   plt.show()</code> </pre> <br> 查看不同方法的异常指标的分布很有趣。 可以看出，LOF不适用于此数据。  EE指出该算法认为异常异常。 但是，正常点在那里。  IsoFor和OCSVM表明，选择截止阈值（污染度/ nu）很重要，这将改变准确性和完整性之间的权衡。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9d/0c8/80f/a9d0c880f36fe37f1de6c9290b8cccc7.png"></div><br> 传感器的读数接近正态分布，接近固定值，这是合乎逻辑的。 如果我们确实有一个标记过的测试样品，最好还有一个经过验证的样品，那么可以对污染值进行着色。 下一个问题是，哪些错误的指向更准确：误报还是误报？ <br><br>  LOF结果非常低。 不太令人印象深刻。 但是请记住，OHE变量与StandardScaler转换的变量一起进入输入。 并且默认距离是欧几里得。 但是，如果仅根据S1和S2计算变量，则可以纠正这种情况，并且结果可以与其他方法进行比较。 但是，重要的是要了解列出的度量标准分类器的关键参数之一是邻居数。 它会严重影响质量，必须对其进行调整。 距离度量本身也很不错。 <br><br> 现在尝试结合两个模型。 一开始，我们从训练集中删除异常。 然后，我们将在“更干净”的训练集上训练OCSVM。 根据以前的结果，我们观察到了EE的最大完整性。 我们通过EE清除训练样本，对其进行训练OCSVM，得到F1 = 0.50，准确度= 0.34，完整性= 0.95。 不令人印象深刻。 但是我们只是要求nu = 0.27。 我们拥有的数据或多或少是“干净的”。 假设训练样本与EE具有相同的完整性，那么将保留5％的错误。 我们将自己设置为nu，得到F1 = 0.69，准确度= 0.59，完整性= 0.82。 太好了 重要的是要注意，在其他方法中，这样的组合将不起作用，因为它们暗示训练集中的异常数和测试数相同。 当在纯训练数据集上训练这些方法时，您将必须指定比真实数据少的污染，并且不接近零，但是最好选择它进行交叉验证。 <br><br> 查看指示序列上的搜索结果很有趣： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a2/0c5/26d/2a20c526d944b55116f3fcd6af064eab.png"></div><br> 该图显示了7个组件的第一传感器和第二传感器的读数的一部分。 在图例中，相应错误的颜色（开始和结束由相同颜色的垂直线显示）。 点表示预测：绿色-真实预测，红色-假阳性，紫色-假阴性。 从图中可以看出，很难从视觉上确定错误时间，并且该算法很好地解决了这一任务。 尽管很重要的一点是，此处没有给出第三个传感器的读数。 此外，错误结束后还会出现假阳性读数。 即 该算法发现还有错误值，因此我们将该区域标记为无错误。 图的右侧显示了错误之前的区域，我们将其标记为错误的区域（错误发生前半小时），该区域被认为是无错误的，从而导致了假阴性模型错误。 在图的中心，识别出一个连贯的部分，被认为是一个错误。 结论可以得出如下：在解决搜索异常的问题时，您需要与了解需要预测其输出的系统本质的工程师紧密互动，因为检查标记上使用的算法并不能完全反映现实情况，并且无法模拟此类算法可以满足的条件。被使用。 <br><br> 绘制图表的代码： <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plot_time_course</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(df_test,dfc,y_preds,start,end,vert_shift=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span>   plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">15</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>))   cols=df_train.filter(regex=(<span class="hljs-string"><span class="hljs-string">'S[12]'</span></span>)).columns   add=<span class="hljs-number"><span class="hljs-number">0</span></span>   preds_idx=y_preds.iloc[start:end][y_preds[<span class="hljs-number"><span class="hljs-number">0</span></span>]==<span class="hljs-number"><span class="hljs-number">1</span></span>].index   true_idx=df_test.iloc[start:end,:][df_test[<span class="hljs-string"><span class="hljs-string">'Label'</span></span>]==<span class="hljs-number"><span class="hljs-number">1</span></span>].index   tp_idx=set(true_idx.values).intersection(set(preds_idx.values))   fn_idx=set(true_idx.values).difference(set(preds_idx.values))   fp_idx=set(preds_idx.values).difference(set(true_idx.values))   xtime=df_test[<span class="hljs-string"><span class="hljs-string">'Time'</span></span>].iloc[start:end]   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cols:       plt.plot(xtime,df_test[col].iloc[start:end]+add)       plt.scatter(xtime.loc[tp_idx].values,df_test.loc[tp_idx,col]+add,color=<span class="hljs-string"><span class="hljs-string">'green'</span></span>)       plt.scatter(xtime.loc[fn_idx].values,df_test.loc[fn_idx,col]+add,color=<span class="hljs-string"><span class="hljs-string">'violet'</span></span>)       plt.scatter(xtime.loc[fp_idx].values,df_test.loc[fp_idx,col]+add,color=<span class="hljs-string"><span class="hljs-string">'red'</span></span>)       add+=vert_shift   failures=dfc[(dfc[<span class="hljs-string"><span class="hljs-string">'Start Time'</span></span>]&gt;xtime.iloc[<span class="hljs-number"><span class="hljs-number">0</span></span>])&amp;(dfc[<span class="hljs-string"><span class="hljs-string">'Start Time'</span></span>]&lt;xtime.iloc[<span class="hljs-number"><span class="hljs-number">-1</span></span>])]   unique_fails=np.sort(failures[<span class="hljs-string"><span class="hljs-string">'Type'</span></span>].unique())   colors=np.array([np.random.rand(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> fail <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> unique_fails])   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> fail_idx <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> failures.index:       c=colors[np.where(unique_fails==failures.loc[fail_idx,<span class="hljs-string"><span class="hljs-string">'Type'</span></span>])[<span class="hljs-number"><span class="hljs-number">0</span></span>]][<span class="hljs-number"><span class="hljs-number">0</span></span>]       plt.axvline(failures.loc[fail_idx,<span class="hljs-string"><span class="hljs-string">'Start Time'</span></span>],color=c)       plt.axvline(failures.loc[fail_idx,<span class="hljs-string"><span class="hljs-string">'End Time'</span></span>],color=c)   leg=plt.legend(unique_fails)   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(unique_fails)):       leg.legendHandles[i].set_color(colors[i])</code> </pre> <br> 如果异常百分比低于5％和/或它们与“正常”指标的分离度很差，则上述方法效果不佳，值得使用基于神经网络的算法。 在最简单的情况下，这些将是： <br><br><ul><li> 自动编码器（受过训练的自动编码器的高错误将表示读数异常）； </li><li> 递归网络（按顺序学习以预测最后的读数。如果相差很大-表示异常）。 </li></ul><br> 另外，值得注意的是使用时间序列的细节。 重要的是要了解，以上大多数算法（自动编码器和隔离林除外）在添加滞后特征（从先前时间点读取的数据）时可能会给出较差的质量。 <br><br> 让我们尝试在示例中添加滞后特征。 竞赛说明说，错误发生3小时之前的值与错误没有任何关系。 然后在3小时内添加标志。 共有259个标志。 <br><br> 结果，OCSVM和IsolationForest的结果几乎保持不变，而椭圆形信封和LOF的结果下降。 <br><br> 要使用有关系统动力学的信息，应使用具有递归或卷积神经网络的自动编码器。 或者，例如，自动编码器，压缩信息和基于压缩信息来搜索异常的常规方法的组合。 反向方法似乎也很有希望。 通过标准算法对最不典型的点进行初步筛选，然后在更干净的数据上训练自动编码器。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/340/9e8/dbc/3409e8dbcc5e9bcac2a1acb08bc7d146.jpg"></div>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i>来源</i></a> <br><br> 有一套处理一维时间序列的技术。 所有这些都旨在预测未来的读数，与预测背离的点被视为异常。 <br><br><h2>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Holt-Winters模型</a> </h2><br> 三重指数平滑，将序列分为3个部分：水平，趋势和季节性。 因此，如果以这种形式呈现系列，则该方法效果很好。  Facebook Prophet的工作原理类似，但是以不同的方式评估组件本身。 例如，可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>阅读更多详细信息。 <br><br><h2>  S（ARIMA） </h2><br> 在这种方法中，预测模型基于自回归和移动平均值。 如果我们谈论的是S（ARIMA）的扩展，那么它使我们可以评估季节性。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>阅读有关该方法的更多信息。 <br><br><h2> 其他预测服务方法 </h2><br> 当涉及到时间序列并且有关于错误发生时间的信息时，您可以与老师一起应用教学方法。 在这种情况下，除了需要标记数据外，重要的是要了解错误预测将取决于错误的性质。 如果存在许多错误且性质不同，则很可能有必要分别预测每个错误，这将需要更多标记数据，但前景会更具吸引力。 <br><br> 在预测性维护中还有其他使用机器学习的方法。 例如，预测未来N天的系统故障（分类任务）。 重要的是要理解，这种方法要求系统操作中的错误之前要经过一段时间的降级（不一定是渐进的）。 在这种情况下，最成功的方法似乎是使用具有卷积和/或递归层的神经网络。 另外，值得注意的是增加时间序列的方法。 在我看来， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">两种方法</a>最有趣，同时又很简单： <br><br><ul><li> 选择该行的连续部分（例如70％，其余部分被删除）并拉伸到原始大小 </li><li> 选择该行的连续部分（例如20％）并拉伸或压缩。 之后，整个行将相应地压缩或拉伸到其原始大小。 </li></ul><br> 还有一个选项可以预测剩余的系统寿命（回归任务）。 在这里，我们可以区分一种单独的方法：预测的不是寿命，而是威布尔分布参数。 <br><br> 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>了解有关分布本身的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信息</a> ，以及与循环网格结合使用的信息。 该分布具有两个参数α和β。  α表示事件何时发生，β表示算法的信心。 尽管这种方法的应用前景广阔，但在这种情况下训练神经网络会出现困难，因为与起预测适当寿命相比，算法一开始不安全很容易。 <br><br> 另外，值得注意的是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Cox回归</a> 。 它使您可以在诊断后预测每个时间点的系统容错能力，并将其表示为两个功能的乘积。 一种功能是系统的降级，与系统的参数无关，即 任何此类系统的共同点。 其次是对特定系统参数的指数依赖。 因此，对于一个人来说，有一个与衰老相关的共同功能，每个人或多或少都是一样的。 但是健康状况的恶化也与内部器官的状态有关，这对每个人来说都是不同的。 <br><br> 希望您现在对预测性维护有所了解。 我敢肯定，您将对这种技术最常用的机器学习方法有疑问。 我很乐意在评论中回答他们每个人。 如果您不仅对询问编写的内容感兴趣，还想做类似的事情，我们的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CleverDATA</a>团队将始终为有才华和热情的专业人员感到高兴。 <br><br><div class="spoiler">  <b class="spoiler_title">有空缺吗？</b>  <b class="spoiler_title">当然可以！</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Java开发人员（大数据）</a> </li></ul></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN447190/">https://habr.com/ru/post/zh-CN447190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN447178/index.html">使用过程挖掘技术的5个有效机会</a></li>
<li><a href="../zh-CN447180/index.html">Kubernetes入口控制器的概述和比较</a></li>
<li><a href="../zh-CN447182/index.html">操作系统：三个简单的部分。 第3部分：Process API（翻译）</a></li>
<li><a href="../zh-CN447184/index.html">什么是首次公开募股（IEO），与ICO有何不同？</a></li>
<li><a href="../zh-CN447186/index.html">如何在一天内启动ML原型。 报告Yandex.Taxi</a></li>
<li><a href="../zh-CN447192/index.html">技术在古老的香料混合艺术中可以发挥什么作用？</a></li>
<li><a href="../zh-CN447194/index.html">Metro中的渲染功能：Exodus c光线追踪</a></li>
<li><a href="../zh-CN447196/index.html">7. Check Point入门R80.20。 门禁控制</a></li>
<li><a href="../zh-CN447198/index.html">月球任务“ Bereshit”：坠落事故坠落在月球上</a></li>
<li><a href="../zh-CN447204/index.html">4月17日：公开演讲“游戏开发者的道路：从构思到发布”以及高等法律学院的游戏库</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>