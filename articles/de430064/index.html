<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👈🏽 👢 😺 C ++: eine Sitzung der spontanen Archäologie und warum Sie keine variablen Funktionen im Stil von C verwenden sollten 👨🏾‍🎤 👨🏽‍🤝‍👨🏼 🤸🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alles begann wie immer mit einem Fehler. Dies ist das erste Mal, dass ich mit der Java Native Interface gearbeitet habe, und im C ++ - Teil habe ich e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++: eine Sitzung der spontanen Archäologie und warum Sie keine variablen Funktionen im Stil von C verwenden sollten</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430064/"> Alles begann wie immer mit einem Fehler.  Dies ist das erste Mal, dass ich mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java Native Interface gearbeitet habe,</a> und im C ++ - Teil habe ich eine Funktion eingeschlossen, die ein Java-Objekt erstellt.  Diese Funktion - <code>CallVoidMethod</code> - ist variabel, d.h.  Neben einem Zeiger auf die <abbr title="Java Native Interface">JNI-</abbr> Umgebung, einem Zeiger auf den zu erstellenden Objekttyp und einem Bezeichner für die aufgerufene Methode (in diesem Fall den Konstruktor) werden eine beliebige Anzahl anderer Argumente verwendet.  Welches ist logisch, weil  Diese anderen Argumente werden auf der Java-Seite an die aufgerufene Methode übergeben, und die Methoden können unterschiedlich sein, mit einer unterschiedlichen Anzahl von Argumenten eines beliebigen Typs. <br><br>  Dementsprechend habe ich auch meinen Wrapper variabel gemacht.  Um eine beliebige Anzahl von Argumenten an <code>CallVoidMethod</code> zu <code>CallVoidMethod</code> <code>va_list</code> , da dies in diesem Fall anders ist.  Ja, das hat <code>va_list</code> an <code>CallVoidMethod</code> gesendet.  Und ließ den banalen JVM-Segmentierungsfehler fallen. <br><br>  In 2 Stunden habe ich es geschafft, mehrere Versionen der JVM vom 8. bis zum 11. zu testen, weil: Erstens ist dies meine erste Erfahrung mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Java virtuelle Maschine">JVM</a> , und in dieser Angelegenheit habe ich StackOverflow mehr vertraut als mir selbst und zweitens jemandem dann habe ich auf StackOverflow in diesem Fall empfohlen, nicht OpenJDK, sondern OracleJDK und nicht 8, sondern 10 zu verwenden. Und erst dann habe ich endlich bemerkt, dass es zusätzlich zur Variablen <code>CallVoidMethod</code> gibt, die eine beliebige Anzahl von Argumenten über <code>va_list</code> <code>CallVoidMethodV</code> . <br><br>  Was mir an dieser Geschichte nicht am besten gefallen hat, war, dass ich den Unterschied zwischen den Auslassungspunkten (Auslassungspunkten) und <code>va_list</code> nicht sofort bemerkt habe.  Und nachdem ich es bemerkt hatte, konnte ich mir nicht erklären, was der grundlegende Unterschied war.  Wir müssen uns also mit Auslassungspunkten und <code>va_list</code> und (da wir immer noch über C ++ sprechen) mit variablen Vorlagen befassen. <br><a name="habracut"></a><br><h3>  Was ist mit den Auslassungspunkten und der va_list, die im Standard angegeben sind? </h3><br>  Der C ++ - Standard beschreibt nur die Unterschiede zwischen seinen Anforderungen und denen von Standard C. Die Unterschiede selbst werden später erörtert, aber im Moment werde ich kurz erklären, was Standard C sagt (beginnend mit C89). <br><br><ul><li>  Sie können eine Funktion deklarieren, die eine beliebige Anzahl von Argumenten akzeptiert.  Das heißt,  Eine Funktion kann mehr Argumente als Parameter haben.  Dazu muss die Liste der Parameter mit einem <i>Auslassungszeichen enden, es</i> muss jedoch auch mindestens ein fester Parameter <i>[C11 6.9.1 / 8]</i> vorhanden sein: <br><br><pre> <code class="plaintext hljs">void foo(int parm1, int parm2, ...);</code> </pre> </li><li>  Informationen über die Anzahl und Art der Argumente, die der Ellipse entsprechen, werden nicht an die Funktion selbst übergeben.  Das heißt,  nach dem zuletzt genannten Parameter ( <code>parm2</code> im obigen Beispiel) <i>[C11 6.7.6.3/9]</i> . <br></li><li>  Um auf diese Argumente zuzugreifen, müssen Sie den im Header <code>&lt;stdarg.h&gt;</code> deklarierten Typ <code>va_list</code> und 4 (3 vor dem C11-Standard) Makros verwenden: <code>va_start</code> , <code>va_arg</code> , <code>va_end</code> und <code>va_copy</code> (beginnend mit C11) <i>[C11 7.16]</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Zum Beispiel</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">int add(int count, ...) { int result = 0; va_list args; va_start(args, count); for (int i = 0; i &lt; count; ++i) { result += va_arg(args, int); } va_end(args); return result; }</code> </pre> <br>  Ja, die Funktion weiß nicht, wie viele Argumente sie hat.  Sie muss diese Nummer irgendwie übergeben.  In diesem Fall über ein einzelnes benanntes Argument (eine weitere häufige Option besteht darin, <code>NULL</code> als letztes Argument zu übergeben, wie in <code>execl</code> oder 0). </div></div></li><li>  Das zuletzt genannte Argument darf keine <code>register</code> , es kann keine Funktion oder ein Array sein.  Andernfalls undefiniertes Verhalten <i>[C11 7.16.1.4/4]</i> . </li><li>  Darüber hinaus wird auf das zuletzt genannte Argument und auf alle namenlosen <i>Argumente die</i> " <i>Standardargumentwerbung</i> " angewendet ( <i>Standardargumentwerbung</i> ; wenn es eine gute Übersetzung dieses Konzepts ins Russische gibt, verwende ich es gerne).  Dies bedeutet, dass, wenn das Argument den Typ <code>char</code> , <code>short</code> (mit oder ohne Vorzeichen) oder <code>float</code> , auf die entsprechenden Parameter als <code>int</code> , <code>int</code> (mit oder ohne Vorzeichen) oder <code>double</code> zugegriffen werden muss.  Andernfalls undefiniertes Verhalten <i>[C11 7.16.1.1/2]</i> . </li><li>  Über den Typ <code>va_list</code> wird nur gesagt, dass er in <code>&lt;stdarg.h&gt;</code> und vollständig ist ( <code>&lt;stdarg.h&gt;</code> die Größe eines Objekts dieses Typs ist bekannt) <i>[C11 7.16 / 3]</i> . </li></ul><br><h3>  Warum?  Aber weil! </h3><br>  Es gibt nicht viele Arten in C.  Warum ist <code>va_list</code> im Standard deklariert, aber nichts wird über seine interne Struktur gesagt? <br><br>  Warum brauchen wir eine Ellipse, wenn eine beliebige Anzahl von Argumenten an eine Funktion über <code>va_list</code> ?  Man könnte jetzt sagen: "als syntaktischer Zucker", aber vor 40 Jahren gab es sicher keine Zeit für Zucker. <br><br>  Philip James Plauger <i>Phillip James Plauger</i> in dem Buch <i>The Standard C Library</i> - 1992 - sagt, dass C ursprünglich ausschließlich für PDP-11-Computer erstellt wurde.  Und dort war es möglich, alle Argumente der Funktion mit einfacher Zeigerarithmetik zu sortieren.  Das Problem trat mit der Popularität von C und der Übertragung des Compilers auf andere Architekturen auf.  In der ersten Ausgabe von <i>The C Programming Language von</i> <i>Brian Kernighan</i> und Dennis Ritchie - 1978 - heißt es ausdrücklich: <blockquote>  Übrigens gibt es keine akzeptable Möglichkeit, eine tragbare Funktion mit einer beliebigen Anzahl von Argumenten zu schreiben, weil  Es gibt keine tragbare Möglichkeit für die aufgerufene Funktion, herauszufinden, wie viele Argumente beim Aufruf an sie übergeben wurden.  ... <code>printf</code> , die typischste C-Sprachfunktion einer beliebigen Anzahl von Argumenten, ... ist nicht portierbar und muss für jedes System implementiert werden. </blockquote>  Dieses Buch beschreibt <code>printf</code> , hat aber noch kein <code>vprintf</code> und erwähnt nicht den Typ und die Makros <code>va_*</code> .  Sie erscheinen in der zweiten Ausgabe der C-Programmiersprache (1988), und dies ist das Verdienst des Komitees für die Entwicklung des ersten C-Standards (C89, auch bekannt als ANSI C).  Das Komitee fügte dem <code>&lt;stdarg.h&gt;</code> Überschrift <code>&lt;stdarg.h&gt;</code> hinzu, die als Grundlage <code>&lt;varargs.h&gt;</code> von Andrew Koenig mit dem Ziel erstellt wurde, die Portabilität des UNIX-Betriebssystems zu <code>&lt;varargs.h&gt;</code> .  <code>va_*</code> wurde beschlossen, <code>va_*</code> als Makros zu <code>va_*</code> , damit vorhandene Compiler den neuen Standard leichter unterstützen können. <br><br>  Mit dem Aufkommen von C89 und der <code>va_*</code> -Familie ist es nun möglich geworden, tragbare variable Funktionen zu erstellen.  Und obwohl die interne Struktur dieser Familie noch in keiner Weise beschrieben ist und keine Anforderungen dafür bestehen, ist bereits klar, warum. <br><br>  Aus purer Neugier finden Sie Beispiele für die Implementierung von <code>&lt;stdarg.h&gt;</code> .  Die gleiche „C-Standardbibliothek“ bietet beispielsweise ein Beispiel für <b>Borland Turbo C ++</b> : <br><br><div class="spoiler">  <b class="spoiler_title">&lt;stdarg.h&gt; von Borland Turbo C ++</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#ifndef _STADARG #define _STADARG #define _AUPBND 1 #define _ADNBND 1 typedef char* va_list #define va_arg(ap, T) \ (*(T*)(((ap) += _Bnd(T, _AUPBND)) - _Bnd(T, _ADNBND))) #define va_end(ap) \ (void)0 #define va_start(ap, A) \ (void)((ap) = (char*)&amp;(A) + _Bnd(A, _AUPBND)) #define _Bnd(X, bnd) \ (sizeof(X) + (bnd) &amp; ~(bnd)) #endif</code> </pre> <br></div></div><br>  Das viel neuere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SystemV ABI für AMD64</a> verwendet diesen Typ für <code>va_list</code> : <br><br><div class="spoiler">  <b class="spoiler_title">va_list von SystemV ABI AMD64</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">typedef struct { unsigned int gp_offset; unsigned int fp_offset; void *overflow_arg_area; void *reg_save_area; } va_list[1];</code> </pre> <br></div></div><br>  Im Allgemeinen können wir sagen, dass der Typ und die Makros <code>va_*</code> eine Standardschnittstelle zum Durchlaufen von Argumenten einer variablen Funktion darstellen und ihre Implementierung aus historischen Gründen vom Compiler, den Zielplattformen und der Architektur abhängt.  Darüber hinaus erschien in C eine Ellipse (d. H. Variable Funktionen im Allgemeinen) früher als <code>va_list</code> (d. H. Der Header <code>&lt;stdarg.h&gt;</code> ).  Und <code>va_list</code> wurde nicht erstellt, um die Auslassungspunkte zu ersetzen, sondern um Entwicklern das Schreiben ihrer tragbaren Variablenfunktionen zu ermöglichen. <br><br>  C ++ behält weitgehend die Abwärtskompatibilität mit C bei, daher gilt alles oben Genannte für C.  Es gibt aber auch Funktionen. <br><br><h3>  Variable Funktionen in C ++ </h3><br>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WG21-</a> Arbeitsgruppe war an der Entwicklung des C ++ - Standards beteiligt.  1989 wurde der neu geschaffene C89-Standard zugrunde gelegt, der sich allmählich änderte, um C ++ selbst zu beschreiben.  1995 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erhielt</a> <i>John Micco den</i> Vorschlag <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">N0695</a> , in dem der Autor vorschlug, die Beschränkungen für Makros <code>va_*</code> : <br><br><ul><li>  Weil  Im Gegensatz zu C können Sie in C ++ die <code>register</code> von Variablen abrufen. Das zuletzt genannte Argument einer Variablenfunktion kann diese Speicherklasse haben. <br></li><li>  Weil  Die in C ++ angezeigten Links verstoßen gegen die ungeschriebene Regel der C-Variablenfunktionen - die Größe des Parameters muss mit der Größe seines deklarierten Typs übereinstimmen -, dann kann das zuletzt genannte Argument kein Link sein.  Ansonsten vages Verhalten. <br></li><li>  Weil  In C ++ gibt es kein Konzept, „ <i>den Typ des Arguments standardmäßig zu erhöhen</i> “ <i>,</i> sondern die Phrase <br><blockquote>  Wenn der Parameter <code>parmN</code> mit ... <code>parmN</code> wird, einem Typ, der nicht mit dem Typ kompatibel ist, der nach Anwendung der Standardargument-Promotions resultiert, ist das Verhalten undefiniert </blockquote>  muss ersetzt werden durch <blockquote>  Wenn der Parameter <code>parmN</code> mit ... <code>parmN</code> wird, einem Typ, der nicht mit dem Typ kompatibel ist, der beim Übergeben eines Arguments entsteht, für das es keinen Parameter gibt, ist das Verhalten undefiniert </blockquote></li></ul>  Ich habe nicht einmal den letzten Punkt übersetzt, um meinen Schmerz zu teilen.  Erstens bleibt die " <i>Eskalation</i> des <i>Standardargumenttyps</i> " in C ++ Standard <i>[C ++ 17 8.2.2 / 9]</i> .  Und zweitens habe ich lange über die Bedeutung dieses Satzes nachgedacht, verglichen mit Standard C, wo alles klar ist.  Erst nachdem ich N0695 gelesen hatte, verstand ich endlich: Ich meine das Gleiche. <br><br>  Alle 3 Änderungen wurden jedoch übernommen <i>[C ++ 98 18.7 / 3]</i> .  Zurück in C ++ ist die Anforderung, dass eine Variablenfunktion mindestens einen benannten Parameter haben muss (in diesem Fall können Sie nicht auf die anderen zugreifen, aber dazu später mehr), verschwunden, und die Liste der gültigen Typen unbenannter Argumente wurde durch Zeiger auf Klassenmitglieder und <abbr title="Einfache alte Daten">POD-</abbr> Typen ergänzt. <br><br>  Der C ++ 03-Standard brachte keine Änderungen an den Variationsfunktionen.  C ++ 11 begann, ein unbenanntes Argument vom Typ <code>std::nullptr_t</code> in <code>void*</code> zu konvertieren, und erlaubte Compilern nach eigenem Ermessen, Typen mit nicht trivialen Konstruktoren und Destruktoren zu unterstützen <i>[C ++ 11 5.2.2 / 7]</i> .  C ++ 14 erlaubte die Verwendung von Funktionen und Arrays als zuletzt genanntem Parameter <i>[C ++ 14 18.10 / 3]</i> , und C ++ 17 verbot die Verwendung der Erweiterung des Parameterpakets ( <i>Pack-Erweiterung</i> ) und der vom Lambda erfassten Variablen <i>[C ++ 17 21.10.1 / 1]</i> . <br><br>  Infolgedessen fügte C ++ seinen Fallstricken variable Funktionen hinzu.  Nur nicht spezifizierte Typunterstützung mit nicht trivialen Konstruktoren / Destruktoren lohnt sich.  Im Folgenden werde ich versuchen, alle nicht offensichtlichen Merkmale variabler Funktionen in einer Liste zusammenzufassen und durch spezifische Beispiele zu ergänzen. <br><br><h3>  Wie man variable Funktionen einfach und falsch benutzt </h3><br><ol><li>  Es ist falsch, das zuletzt genannte Argument mit einem heraufgestuften Typ zu deklarieren, d. H.  <code>char</code> , <code>signed char</code> , <code>unsigned char</code> , <code>singed short</code> , <code>unsigned short</code> oder <code>float</code> .  Das Ergebnis gemäß dem Standard ist undefiniertes Verhalten. <br><br><div class="spoiler">  <b class="spoiler_title">Ungültiger Code</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(float n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> <br></div></div><br>  Von allen Compilern, die ich zur Hand hatte (gcc, clang, MSVC), gab nur <b>clang</b> eine Warnung aus. <br><br><div class="spoiler">  <b class="spoiler_title">Clang Warnung</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:7:18: warning: passing an object that undergoes default argument promotion to 'va_start' has undefined behavior [-Wvarargs] va_start(va, n); ^</code> </pre> </div></div><br>  Und obwohl sich der kompilierte Code in allen Fällen korrekt verhalten hat, sollten Sie sich nicht darauf verlassen. <br><br><div class="spoiler">  <b class="spoiler_title">Es wird richtig sein</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(double n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br></li><li>  Es ist falsch, das zuletzt genannte Argument als Referenz zu deklarieren.  Beliebiger Link.  Der Standard verspricht auch in diesem Fall undefiniertes Verhalten. <br><br><div class="spoiler">  <b class="spoiler_title">Ungültiger Code</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int&amp; n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br>  <b>gcc 7.3.0</b> hat diesen Code ohne einen einzigen Kommentar kompiliert.  <b>lang 6.0.0</b> hat eine Warnung ausgegeben, diese aber dennoch kompiliert. <br><br><div class="spoiler">  <b class="spoiler_title">Clang Warnung</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:7:18: warning: passing an object of reference type to 'va_start' has undefined behavior [-Wvarargs] va_start(va, n); ^</code> </pre> </div></div><br>  In beiden Fällen hat das Programm korrekt funktioniert (zum Glück können Sie sich nicht darauf verlassen).  Aber <b>MSVC 19.15.26730</b> zeichnete sich aus - es weigerte sich, den Code zu kompilieren, weil  <code>va_start</code> Argument <code>va_start</code> keine Referenz sein. <br><br><div class="spoiler">  <b class="spoiler_title">Fehler von MSVC</b> <div class="spoiler_text"><pre> <code class="diff hljs">c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vadefs.h(151): error C2338: va_start argument must not have reference type and must not be parenthesized</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Nun, die richtige Option sieht zum Beispiel so aus</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int* n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br></li><li>  Es ist falsch, <code>va_arg</code> , den Typ <code>char</code> , <code>short</code> oder <code>float</code> <code>va_arg</code> erhöhen. <br><br><div class="spoiler">  <b class="spoiler_title">Ungültiger Code</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdarg&gt; #include &lt;iostream&gt; void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, float) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); } int main() { foo(0, 1, 2.0f, 3); return 0; }</code> </pre> </div></div><br>  Es ist hier interessanter.  <b>gcc</b> bei der Kompilierung gibt eine Warnung aus, dass <code>double</code> anstelle von <code>float</code> muss. Wenn dieser Code weiterhin ausgeführt wird, wird das Programm mit einem Fehler beendet. <br><br><div class="spoiler">  <b class="spoiler_title">Gcc Warnung</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:9:15: warning: 'float' is promoted to 'double' when passed through '...' std::cout &lt;&lt; va_arg(va, float) &lt;&lt; std::endl; ^~~~~~ ./test.cpp:9:15: note: (so you should pass 'double' not 'float' to 'va_arg') ./test.cpp:9:15: note: if this code is reached, the program will abort</code> </pre> </div></div><br>  In der Tat stürzt das Programm mit einer Beschwerde über eine ungültige Anweisung ab. <br>  Eine Dump-Analyse zeigt, dass das Programm ein SIGILL-Signal empfangen hat.  Und es zeigt auch die Struktur von <code>va_list</code> .  Für 32 Bit ist dies <br><br><pre> <code class="diff hljs">va = 0xfffc6918 ""</code> </pre> <br>  d.h.  <code>va_list</code> ist nur <code>char*</code> .  Für 64 Bit: <br><br><pre> <code class="diff hljs">va = {{gp_offset = 16, fp_offset = 48, overflow_arg_area = 0x7ffef147e7e0, reg_save_area = 0x7ffef147e720}}</code> </pre> <br>  d.h.  genau das, was in SystemV ABI AMD64 beschrieben ist. <br><br>  <b>clang</b> at compilation warnt vor undefiniertem Verhalten und schlägt außerdem vor, <code>float</code> durch <code>double</code> ersetzen. <br><br><div class="spoiler">  <b class="spoiler_title">Clang Warnung</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:9:26: warning: second argument to 'va_arg' is of promotable type 'float'; this va_arg has undefined behavior because arguments will be promoted to 'double' [-Wvarargs] std::cout &lt;&lt; va_arg(va, float) &lt;&lt; std::endl; ^~~~~</code> </pre> </div></div><br>  Aber das Programm stürzt nicht mehr ab, die 32-Bit-Version produziert: <br><br><pre> <code class="diff hljs">1 0 1073741824</code> </pre> <br>  64 Bit: <br><br><pre> <code class="diff hljs">1 0 3</code> </pre> <br>  <b>MSVC</b> liefert genau die gleichen Ergebnisse, nur ohne Vorwarnung, auch mit <code>/Wall</code> . <br><br>  Hier könnte angenommen werden, dass der Unterschied zwischen 32 und 64 Bit auf die Tatsache zurückzuführen ist, dass im ersten Fall der ABI alle Argumente über den Stapel an die aufgerufene Funktion weiterleitet und im zweiten Fall die ersten vier (Windows) oder sechs (Linux) Argumente über die Prozessorregister, der Rest durch Stapel [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wiki</a> ].  Aber nein, wenn Sie <code>foo</code> nicht mit 4 Argumenten, sondern mit 19 aufrufen und auf dieselbe Weise ausgeben, ist das Ergebnis dasselbe: Volles Durcheinander in der 32-Bit-Version und Nullen für alle <code>float</code> in der 64-Bit-Version.  Das heißt,  Der Punkt ist natürlich in ABI, aber nicht in der Verwendung von Registern, um Argumente zu übergeben. <br><br><div class="spoiler">  <b class="spoiler_title">Natürlich ist es richtig, dies zu tun</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, double) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br></li><li>  Es ist falsch, eine Instanz einer Klasse mit einem nichttrivialen Konstruktor oder Destruktor als unbenanntes Argument zu übergeben.  Es sei denn natürlich, das Schicksal dieses Codes reizt Sie zumindest ein wenig mehr als "hier und jetzt kompilieren und ausführen". <br><br><div class="spoiler">  <b class="spoiler_title">Ungültiger Code</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdarg&gt; #include &lt;iostream&gt; struct Bar { Bar() { std::cout &lt;&lt; "Bar default ctor" &lt;&lt; std::endl; } Bar(const Bar&amp;) { std::cout &lt;&lt; "Bar copy ctor" &lt;&lt; std::endl; } ~Bar() { std::cout &lt;&lt; "Bar dtor" &lt;&lt; std::endl; } }; struct Cafe { Cafe() { std::cout &lt;&lt; "Cafe default ctor" &lt;&lt; std::endl; } Cafe(const Cafe&amp;) { std::cout &lt;&lt; "Cafe copy ctor" &lt;&lt; std::endl; } ~Cafe() { std::cout &lt;&lt; "Cafe dtor" &lt;&lt; std::endl; } }; void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; "Before va_arg" &lt;&lt; std::endl; const auto b = va_arg(va, Bar); va_end(va); } int main() { Bar b; Cafe c; foo(1, b, c); return 0; }</code> </pre> </div></div><br>  Clang ist der strengere von allen.  Er weigert sich einfach, diesen Code zu kompilieren, da das zweite Argument, <code>va_arg</code> kein POD-Typ ist, und warnt, dass das Programm beim Start <code>va_arg</code> . <br><br><div class="spoiler">  <b class="spoiler_title">Clang Warnung</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:23:31: error: second argument to 'va_arg' is of non-POD type 'Bar' [-Wnon-pod-varargs] const auto b = va_arg(va, Bar); ^~~ ./test.cpp:31:12: error: cannot pass object of non-trivial type 'Bar' through variadic function; call will abort at runtime [-Wnon-pod-varargs] foo(1, b, c); ^</code> </pre> </div></div><br>  So wird es sein, wenn Sie immer noch mit dem <code>-Wno-non-pod-varargs</code> . <br><br>  <b>MSVC</b> warnt davor, dass die Verwendung von Typen mit nicht trivialen Konstruktoren in diesem Fall nicht portierbar ist. <br><br><div class="spoiler">  <b class="spoiler_title">Warnung von MSVC</b> <div class="spoiler_text"><pre> <code class="diff hljs">d:\my documents\visual studio 2017\projects\test\test\main.cpp(31): warning C4840:    "Bar"         </code> </pre> </div></div><br>  Der Code wird jedoch kompiliert und ordnungsgemäß ausgeführt.  Folgendes wird in der Konsole angezeigt: <br><br><div class="spoiler">  <b class="spoiler_title">Ergebnis starten</b> <div class="spoiler_text"><pre> <code class="diff hljs">Bar default ctor Cafe default ctor Before va_arg Bar copy ctor Bar dtor Cafe dtor Bar dtor</code> </pre> </div></div><br>  Das heißt,  Eine Kopie wird nur zum Zeitpunkt des Aufrufs von <code>va_arg</code> , und das Argument wird, wie sich herausstellt, als Referenz übergeben.  Es ist irgendwie nicht offensichtlich, aber der Standard erlaubt. <br><br>  <b>gcc 6.3.0 wird</b> ohne einen einzigen Kommentar kompiliert.  Die Ausgabe ist die gleiche: <br><br><div class="spoiler">  <b class="spoiler_title">Ergebnis starten</b> <div class="spoiler_text"><pre> <code class="diff hljs">Bar default ctor Cafe default ctor Before va_arg Bar copy ctor Bar dtor Cafe dtor Bar dtor</code> </pre> </div></div><br>  <b>gcc 7.3.0 warnt</b> auch vor nichts, aber das Verhalten ändert sich: <br><br><div class="spoiler">  <b class="spoiler_title">Ergebnis starten</b> <div class="spoiler_text"><pre> <code class="diff hljs">Bar default ctor Cafe default ctor Cafe copy ctor Bar copy ctor Before va_arg Bar copy ctor Bar dtor Bar dtor Cafe dtor Cafe dtor Bar dtor</code> </pre> </div></div><br>  Das heißt,  Diese Version des Compilers übergibt Argumente nach Wert, und beim Aufruf erstellt <code>va_arg</code> eine weitere Kopie.  Es würde Spaß machen, diesen Unterschied beim Wechsel von der 6. zur 7. Version von gcc zu suchen, wenn die Konstruktoren / Destruktoren Nebenwirkungen haben. <br><br>  Übrigens, wenn Sie explizit einen Verweis auf die Klasse übergeben und anfordern: <br><br><div class="spoiler">  <b class="spoiler_title">Ein weiterer falscher Code</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; "Before va_arg" &lt;&lt; std::endl; const auto&amp; b = va_arg(va, Bar&amp;); va_end(va); } int main() { Bar b; Cafe c; foo(1, std::ref(b), c); return 0; }</code> </pre> </div></div><br>  dann werfen alle Compiler einen Fehler aus.  Gemäß Standard. <br><br>  Wenn Sie wirklich wollen, ist es im Allgemeinen besser, Argumente per Zeiger zu übergeben. <br><br><div class="spoiler">  <b class="spoiler_title">So</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; "Before va_arg" &lt;&lt; std::endl; const auto* b = va_arg(va, Bar*); va_end(va); } int main() { Bar b; Cafe c; foo(1, &amp;b, &amp;c); return 0; }</code> </pre> </div></div><br></li></ol><br><h3>  Überlastauflösung und variable Funktionen </h3><br>  Einerseits ist alles einfach: Der Abgleich mit einer Ellipse ist schlechter als der Abgleich mit einem regulären benannten Argument, selbst bei einer Standard- oder benutzerdefinierten Typkonvertierung. <br><br><div class="spoiler">  <b class="spoiler_title">Überlastungsbeispiel</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(...) { std::cout &lt;&lt; "C variadic function" &lt;&lt; std::endl; } void foo(int) { std::cout &lt;&lt; "Ordinary function" &lt;&lt; std::endl; } int main() { foo(1); foo(1ul); foo(); return 0; }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Ergebnis starten</b> <div class="spoiler_text"><pre> <code class="diff hljs">$ ./test Ordinary function Ordinary function C variadic function</code> </pre> </div></div><br>  Dies funktioniert jedoch nur, bis der Aufruf von <code>foo</code> ohne Argumente separat betrachtet werden muss. <br><br><div class="spoiler">  <b class="spoiler_title">Rufen Sie foo ohne Argumente auf</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(...) { std::cout &lt;&lt; "C variadic function" &lt;&lt; std::endl; } void foo() { std::cout &lt;&lt; "Ordinary function without arguments" &lt;&lt; std::endl; } int main() { foo(1); foo(); return 0; }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Compiler-Ausgabe</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:16:9: error: call of overloaded 'foo()' is ambiguous foo(); ^ ./test.cpp:3:6: note: candidate: void foo(...) void foo(...) ^~~ ./test.cpp:8:6: note: candidate: void foo() void foo() ^~~</code> </pre> </div></div><br>  Alles entspricht dem Standard: Es gibt keine Argumente - es gibt keinen Vergleich mit den Auslassungspunkten, und wenn die Überlastung behoben ist, wird die Variationsfunktion nicht schlechter als gewöhnlich. <br><br><h3>  Wann lohnt es sich trotzdem, variable Funktionen zu verwenden? </h3><br>  Nun, variative Funktionen verhalten sich manchmal nicht sehr offensichtlich und können sich im Kontext von C ++ leicht als schlecht portabel herausstellen.  Im Internet gibt es viele Tipps wie "Erstellen oder verwenden Sie keine variablen C-Funktionen", aber sie werden ihre Unterstützung nicht aus dem C ++ - Standard entfernen.  Diese Funktionen bieten also einige Vorteile?  Na da. <br><br><ul><li>  Der häufigste und offensichtlichste Fall ist die Abwärtskompatibilität.  Hier werde ich sowohl die Verwendung von C-Bibliotheken von Drittanbietern (mein Fall mit JNI) als auch die Bereitstellung der C-API für die C ++ - Implementierung einbeziehen. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Ein Substitutionsfehler ist kein Fehler">SFINAE</a> .  Hier ist es sehr nützlich, dass in C ++ eine Variablenfunktion keine benannten Argumente haben muss und dass beim Auflösen überladener Funktionen eine Variablenfunktion als letzte betrachtet wird (wenn mindestens ein Argument vorhanden ist).  Und wie jede andere Funktion kann eine variable Funktion nur deklariert, aber nie aufgerufen werden. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class T&gt; struct HasFoo { private: template &lt;class U, class = decltype(std::declval&lt;U&gt;().foo())&gt; static void detect(const U&amp;); static int detect(...); public: static constexpr bool value = std::is_same&lt;void, decltype(detect(std::declval&lt;T&gt;()))&gt;::value; };</code> </pre> </div></div><br>  Obwohl in C ++ 14 können Sie etwas anders machen. <br><br><div class="spoiler">  <b class="spoiler_title">Ein weiteres Beispiel</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class T&gt; struct HasFoo { private: template &lt;class U, class = decltype(std::declval&lt;U&gt;().foo())&gt; static constexpr bool detect(const U*) { return true; } template &lt;class U&gt; static constexpr bool detect(...) { return false; } public: static constexpr bool value = detect&lt;T&gt;(nullptr); };</code> </pre> </div></div><br>  Und in diesem Fall ist es bereits notwendig zu beobachten, mit welchen Argumenten <code>detect(...)</code> aufgerufen werden kann.  Ich würde es vorziehen, ein paar Zeilen zu ändern und eine moderne Alternative zu variablen Funktionen zu verwenden, ohne all ihre Mängel. <br></li></ul><br><h3>  Variantenvorlagen oder das Erstellen von Funktionen aus einer beliebigen Anzahl von Argumenten in modernem C ++ </h3><br>  Die Idee variabler Vorlagen wurde bereits 2004 von Douglas Gregor, Jaakko Järvi und Gary Powell vorgeschlagen, d. H.  7 Jahre vor der Einführung des C ++ 11-Standards, in dem diese variablen Vorlagen offiziell unterstützt wurden.  Der Standard enthielt eine dritte Überarbeitung ihres Vorschlags, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">N2080</a> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Von Anfang an wurden variable Vorlagen erstellt, damit Programmierer aus einer beliebigen Anzahl von Argumenten typsichere (und portable!) Funktionen erstellen konnten. </font><font style="vertical-align: inherit;">Ein weiteres Ziel ist es, die Unterstützung für Klassenvorlagen mit einer variablen Anzahl von Parametern zu vereinfachen. Jetzt geht es jedoch nur noch um variable Funktionen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variable Vorlagen brachten drei neue Konzepte in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ [C ++ 17 17.5.3]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Template - </font><font style="vertical-align: inherit;">Parameter - </font><font style="vertical-align: inherit;">Paket ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Template - </font><font style="vertical-align: inherit;">Parameter - </font><font style="vertical-align: inherit;">Pack</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) - ist eine Parametervorlage, statt dessen ist es möglich , </font><font style="vertical-align: inherit;">jede (einschließlich 0) Anzahl der Template - </font><font style="vertical-align: inherit;">Argument zu übertragen;</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Paket von Funktionsparametern ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktionsparameterpaket</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) - dementsprechend ist dies ein Funktionsparameter, der eine beliebige (einschließlich 0) Anzahl von Funktionsargumenten akzeptiert;</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und die Erweiterung des Pakets ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pack-Erweiterung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) ist das einzige, was mit dem Parameterpaket durchgeführt werden kann.</font></font><br></li></ul><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(const std::string&amp; format, Args ... args) { printf(format.c_str(), args...); }</code> </pre> <br>  <code>class ... Args</code> —   , <code>Args ... args</code> —   ,  <code>args...</code> —    . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine vollständige Liste, wo und wie Parameterpakete erweitert werden können, finden Sie im Standard selbst </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[C ++ 17 17.5.3 / 4]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Und im Zusammenhang mit der Diskussion variabler Funktionen genügt es zu sagen:</font></font><br><br><ul><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Funktionsparameterpaket kann in die Argumentliste einer anderen Funktion erweitert werden</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void bar(const std::string&amp; format, Args ... args) { foo&lt;Args...&gt;(format.c_str(), args...); }</code> </pre> </div></div><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder zur Initialisierungsliste</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(const std::string&amp; format, Args ... args) { const auto list = {args...}; }</code> </pre> </div></div><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder zur Lambda-Erfassungsliste</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(const std::string&amp; format, Args ... args) { auto lambda = [&amp;format, args...] () { printf(format.c_str(), args...); }; lambda(); }</code> </pre> </div></div><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiteres Paket von Funktionsparametern kann in einem Faltungsausdruck erweitert werden</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; int foo(Args ... args) { return (0 + ... + args); }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faltungen erschienen in C ++ 14 und können unär und binär sein, rechts und links. </font><font style="vertical-align: inherit;">Die vollständigste Beschreibung findet sich wie immer im Standard </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[C ++ 17 8.1.6]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beide Arten von Parameterpaketen können in den Operator sizeof ... erweitert werden</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(Args ... args) { const auto size1 = sizeof...(Args); const auto size2 = sizeof...(args); }</code> </pre> </div></div><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das explizite Auslassungs Pakets Bei der </font><font style="vertical-align: inherit;">Angabe der </font><font style="vertical-align: inherit;">benötigt wird , </font><font style="vertical-align: inherit;">um die verschiedenen Vorlagen (zur Unterstützung </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muster</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) Offenlegung und diese Mehrdeutigkeit zu vermeiden.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Zum Beispiel</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo() { using OneTuple = std::tuple&lt;std::tuple&lt;Args&gt;...&gt;; using NestTuple = std::tuple&lt;std::tuple&lt;Args...&gt;&gt;; }</code> </pre> <br> <code>OneTuple</code> —      ( <code>std:tuple&lt;std::tuple&lt;int&gt;&gt;, std::tuple&lt;double&gt;&gt;</code> ),  <code>NestTuple</code> — ,     —   ( <code>std::tuple&lt;std::tuple&lt;int, double&gt;&gt;</code> ). </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beispielimplementierung von printf mit variablen Vorlagen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bereits erwähnt, wurden Variablenvorlagen auch als direkter Ersatz für die Variablenfunktionen von C erstellt. Die Autoren dieser Vorlagen selbst schlugen ihre sehr einfache, aber typsichere Version vor </font></font><code>printf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- eine der ersten Variablenfunktionen in C.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf auf Vorlagen</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void printf(const char* s) { while (*s) { if (*s == '%' &amp;&amp; *++s != '%') throw std::runtime_error("invalid format string: missing arguments"); std::cout &lt;&lt; *s++; } } template &lt;typename T, typename ... Args&gt; void printf(const char* s, T value, Args ... args) { while (*s) { if (*s == '%' &amp;&amp; *++s != '%') { std::cout &lt;&lt; value; return printf(++s, args...); } std::cout &lt;&lt; *s++; } throw std::runtime_error("extra arguments provided to printf"); }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich vermute, dann erschien dieses Muster der Aufzählung variabler Argumente - durch einen rekursiven Aufruf überladener Funktionen. </font><font style="vertical-align: inherit;">Aber ich bevorzuge immer noch die Option ohne Rekursion.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf auf Vorlagen und ohne Rekursion</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;typename ... Args&gt; void printf(const std::string&amp; fmt, const Args&amp; ... args) { size_t fmtIndex = 0; size_t placeHolders = 0; auto printFmt = [&amp;fmt, &amp;fmtIndex, &amp;placeHolders]() { for (; fmtIndex &lt; fmt.size(); ++fmtIndex) { if (fmt[fmtIndex] != '%') std::cout &lt;&lt; fmt[fmtIndex]; else if (++fmtIndex &lt; fmt.size()) { if (fmt[fmtIndex] == '%') std::cout &lt;&lt; '%'; else { ++fmtIndex; ++placeHolders; break; } } } }; ((printFmt(), std::cout &lt;&lt; args), ..., (printFmt())); if (placeHolders &lt; sizeof...(args)) throw std::runtime_error("extra arguments provided to printf"); if (placeHolders &gt; sizeof...(args)) throw std::runtime_error("invalid format string: missing arguments"); }</code> </pre> </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Überlastungsauflösung und variable Vorlagenfunktionen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Auflösung werden diese variativen Funktionen nach anderen als Standard und am wenigsten spezialisiert betrachtet. </font><font style="vertical-align: inherit;">Bei einem Aufruf ohne Argumente gibt es jedoch kein Problem.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überlastungsbeispiel</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(int) { std::cout &lt;&lt; "Ordinary function" &lt;&lt; std::endl; } void foo() { std::cout &lt;&lt; "Ordinary function without arguments" &lt;&lt; std::endl; } template &lt;class T&gt; void foo(T) { std::cout &lt;&lt; "Template function" &lt;&lt; std::endl; } template &lt;class ... Args&gt; void foo(Args ...) { std::cout &lt;&lt; "Template variadic function" &lt;&lt; std::endl; } int main() { foo(1); foo(); foo(2.0); foo(1, 2); return 0; }</code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnis starten</font></font></b> <div class="spoiler_text"><pre> <code class="diff hljs">$ ./test Ordinary function Ordinary function without arguments Template function Template variadic function</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Überladung behoben ist, kann eine variable Vorlagenfunktion nur eine variable C-Funktion umgehen (obwohl warum sie mischen?). </font><font style="vertical-align: inherit;">Außer - natürlich! </font><font style="vertical-align: inherit;">- Aufruf ohne Argumente.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufruf ohne Argumente</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(...) { std::cout &lt;&lt; "C variadic function" &lt;&lt; std::endl; } template &lt;class ... Args&gt; void foo(Args ...) { std::cout &lt;&lt; "Template variadic function" &lt;&lt; std::endl; } int main() { foo(1); foo(); return 0; }</code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnis starten</font></font></b> <div class="spoiler_text"><pre> <code class="diff hljs">$ ./test Template variadic function C variadic function</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es gibt einen Vergleich mit einer Ellipse - die entsprechende Funktion verliert, es gibt keinen Vergleich mit einer Ellipse - und die Vorlagenfunktion ist der Nicht-Vorlagenfunktion unterlegen. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ein kurzer Hinweis zur Geschwindigkeit variabler Vorlagenfunktionen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Jahr 2008 </font><font style="vertical-align: inherit;">reichte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Loïc Joly</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seinen Vorschlag </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N2772</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beim C ++ Standardization Committee ein </font><font style="vertical-align: inherit;">, in dem er in der Praxis zeigte, dass variable Vorlagenfunktionen langsamer arbeiten als ähnliche Funktionen, deren Argument die Initialisierungsliste ist ( </font></font><code>std::initializer_list</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Und obwohl dies im </font><font style="vertical-align: inherit;">Gegensatz zu theoretischer Fundierung des Autors selbst, schlug Joly zu implementieren </font></font><code>std::min</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>std::max</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>std::minmax</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es ist durch die Initialisierung Listen statt Variante Muster. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber bereits im Jahr 2009 erschien eine Widerlegung. Bei den Tests von Joli wurde ein „schwerwiegender Fehler“ entdeckt (es scheint sogar für sich selbst). Neue Tests (siehe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) haben gezeigt, dass variable Vorlagenfunktionen immer noch schneller und manchmal erheblich sind. </font><font style="vertical-align: inherit;">Was seitdem nicht verwunderlich ist </font><font style="vertical-align: inherit;">Die Initialisierungsliste erstellt Kopien ihrer Elemente, und für variable Vorlagen können Sie bei der Kompilierung viel zählen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doch in C ++ 11 und nachfolgenden Standards </font></font><code>std::min</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>std::max</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>std::minmax</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- das ist die üblichen Template - </font><font style="vertical-align: inherit;">Funktionen, eine beliebige Anzahl von Argumenten, die durch die Initialisierung Liste übertragen werden.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kurze Zusammenfassung und Schlussfolgerung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Variablenfunktionen im C-Stil: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie kennen weder die Anzahl ihrer Argumente noch ihre Typen. </font><font style="vertical-align: inherit;">Der Entwickler muss einen Teil der Argumente an die Funktion verwenden, um Informationen über den Rest zu übergeben.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erhöhen Sie implizit die Typen unbenannter Argumente (und die zuletzt genannten). </font><font style="vertical-align: inherit;">Wenn Sie es vergessen, bekommen Sie vages Verhalten.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie behalten die Abwärtskompatibilität mit reinem C bei und unterstützen daher nicht die Übergabe von Argumenten als Referenz. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vor C ++ 11 wurden Argumente, die nicht vom </font><font style="vertical-align: inherit;">Typ </font></font><abbr title="Einfache alte Daten"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POD</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> waren, </font><font style="vertical-align: inherit;">nicht unterstützt </font><font style="vertical-align: inherit;">, und seit C ++ 11 lag die Unterstützung für nicht triviale Typen im Ermessen des Compilers.</font></font> Das heißt,<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Verhalten des Codes hängt vom Compiler und seiner Version ab. </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die einzig zulässige Verwendung von Variablenfunktionen ist die Interaktion mit der C-API in C ++ - Code. </font><font style="vertical-align: inherit;">Für alles andere, einschließlich </font></font><abbr title="Ein Substitutionsfehler ist kein Fehler"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , gibt es variable Vorlagenfunktionen, die:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kennen Sie die Anzahl und Art aller ihrer Argumente. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Geben Sie safe ein und ändern Sie nicht die Typen ihrer Argumente. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie unterstützen die Übergabe von Argumenten in jeder Form - nach Wert, Zeiger, Referenz, universeller Verknüpfung. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wie bei jeder anderen C ++ - Funktion gibt es keine Einschränkungen für die Argumenttypen. </font></font><br></li><li>        (   C ),   . <br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variable Vorlagenfunktionen können im Vergleich zu ihren Gegenstücken im C-Stil ausführlicher sein und erfordern manchmal sogar eine eigene überladene Nicht-Vorlagenversion (rekursives Durchlaufen von Argumenten). </font><font style="vertical-align: inherit;">Sie sind schwerer zu lesen und zu schreiben. </font><font style="vertical-align: inherit;">All dies wird jedoch durch das Fehlen der aufgeführten Mängel und das Vorhandensein der aufgeführten Vorteile mehr als bezahlt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Schlussfolgerung ist einfach: Variative Funktionen im C-Stil bleiben nur aufgrund der Abwärtskompatibilität in C ++ erhalten und bieten eine Vielzahl von Optionen, um Ihr Bein zu schießen. </font><font style="vertical-align: inherit;">In modernem C ++ ist es sehr ratsam, keine neuen zu schreiben und wenn möglich keine vorhandenen variablen C-Funktionen zu verwenden. </font><font style="vertical-align: inherit;">Variable Vorlagenfunktionen gehören zur Welt des modernen C ++ und sind viel sicherer. </font><font style="vertical-align: inherit;">Verwenden Sie sie.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Literatur und Quellen </font></font></h3><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PJ Plauger, Die Standard C Bibliothek</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brian W. Kernighan und Dennis M. Ritchie, Programmiersprache C, 1. Auflage</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brian W. Kernighan und Dennis M. Ritchie, Programmiersprache C, 2. Auflage</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standard C11, Entwurf N1570</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 98 Standard</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 03 Standard</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 11 Standard, Entwurf N3337</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standard C ++ 14, Entwurf N4296</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 17 Standard, Entwurf N4659</font></font></a> <br></li></ul><br><h3>  PS </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist einfach, elektronische Versionen der im Internet genannten Bücher zu finden und herunterzuladen. </font><font style="vertical-align: inherit;">Ich bin mir jedoch nicht sicher, ob dies legal ist, daher gebe ich keine Links.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430064/">https://habr.com/ru/post/de430064/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430052/index.html">Warum ist es für Hardwareentwickler wichtig, Qualitäts-Cusdev durchzuführen?</a></li>
<li><a href="../de430054/index.html">HolyJS 2018 Moskau: kostenlose Online-Übertragung, Party sowie Wissenschafts- und Technologie-Rap</a></li>
<li><a href="../de430058/index.html">Wellenprozesse in Hydraulikleitungen. Die Grundlagen</a></li>
<li><a href="../de430060/index.html">Hackspace, Denis Perevalov, Anastasia Krokhaleva - die Magie des Programmierens</a></li>
<li><a href="../de430062/index.html">Microservices. Entwicklungs- und Refactoring-Muster mit Java-Beispielen</a></li>
<li><a href="../de430068/index.html">Ordnung der Puppe</a></li>
<li><a href="../de430070/index.html">Stapel und Warteschlange sind zwei schlechte Paradigmen und was kann dagegen getan werden?</a></li>
<li><a href="../de430072/index.html">Serverseitig Swift Underestimated: Interview mit Paul Hudson</a></li>
<li><a href="../de430074/index.html">Wie ich fast einen Virus gefangen hätte, der versucht, Stiefel zu verkaufen</a></li>
<li><a href="../de430076/index.html">Kostenlose Ausstrahlung von DotNext 2018 Moskau</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>