<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëàüèΩ üë¢ üò∫ C ++: eine Sitzung der spontanen Arch√§ologie und warum Sie keine variablen Funktionen im Stil von C verwenden sollten üë®üèæ‚Äçüé§ üë®üèΩ‚Äçü§ù‚Äçüë®üèº ü§∏üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alles begann wie immer mit einem Fehler. Dies ist das erste Mal, dass ich mit der Java Native Interface gearbeitet habe, und im C ++ - Teil habe ich e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++: eine Sitzung der spontanen Arch√§ologie und warum Sie keine variablen Funktionen im Stil von C verwenden sollten</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430064/"> Alles begann wie immer mit einem Fehler.  Dies ist das erste Mal, dass ich mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java Native Interface gearbeitet habe,</a> und im C ++ - Teil habe ich eine Funktion eingeschlossen, die ein Java-Objekt erstellt.  Diese Funktion - <code>CallVoidMethod</code> - ist variabel, d.h.  Neben einem Zeiger auf die <abbr title="Java Native Interface">JNI-</abbr> Umgebung, einem Zeiger auf den zu erstellenden Objekttyp und einem Bezeichner f√ºr die aufgerufene Methode (in diesem Fall den Konstruktor) werden eine beliebige Anzahl anderer Argumente verwendet.  Welches ist logisch, weil  Diese anderen Argumente werden auf der Java-Seite an die aufgerufene Methode √ºbergeben, und die Methoden k√∂nnen unterschiedlich sein, mit einer unterschiedlichen Anzahl von Argumenten eines beliebigen Typs. <br><br>  Dementsprechend habe ich auch meinen Wrapper variabel gemacht.  Um eine beliebige Anzahl von Argumenten an <code>CallVoidMethod</code> zu <code>CallVoidMethod</code> <code>va_list</code> , da dies in diesem Fall anders ist.  Ja, das hat <code>va_list</code> an <code>CallVoidMethod</code> gesendet.  Und lie√ü den banalen JVM-Segmentierungsfehler fallen. <br><br>  In 2 Stunden habe ich es geschafft, mehrere Versionen der JVM vom 8. bis zum 11. zu testen, weil: Erstens ist dies meine erste Erfahrung mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Java virtuelle Maschine">JVM</a> , und in dieser Angelegenheit habe ich StackOverflow mehr vertraut als mir selbst und zweitens jemandem dann habe ich auf StackOverflow in diesem Fall empfohlen, nicht OpenJDK, sondern OracleJDK und nicht 8, sondern 10 zu verwenden. Und erst dann habe ich endlich bemerkt, dass es zus√§tzlich zur Variablen <code>CallVoidMethod</code> gibt, die eine beliebige Anzahl von Argumenten √ºber <code>va_list</code> <code>CallVoidMethodV</code> . <br><br>  Was mir an dieser Geschichte nicht am besten gefallen hat, war, dass ich den Unterschied zwischen den Auslassungspunkten (Auslassungspunkten) und <code>va_list</code> nicht sofort bemerkt habe.  Und nachdem ich es bemerkt hatte, konnte ich mir nicht erkl√§ren, was der grundlegende Unterschied war.  Wir m√ºssen uns also mit Auslassungspunkten und <code>va_list</code> und (da wir immer noch √ºber C ++ sprechen) mit variablen Vorlagen befassen. <br><a name="habracut"></a><br><h3>  Was ist mit den Auslassungspunkten und der va_list, die im Standard angegeben sind? </h3><br>  Der C ++ - Standard beschreibt nur die Unterschiede zwischen seinen Anforderungen und denen von Standard C. Die Unterschiede selbst werden sp√§ter er√∂rtert, aber im Moment werde ich kurz erkl√§ren, was Standard C sagt (beginnend mit C89). <br><br><ul><li>  Sie k√∂nnen eine Funktion deklarieren, die eine beliebige Anzahl von Argumenten akzeptiert.  Das hei√üt,  Eine Funktion kann mehr Argumente als Parameter haben.  Dazu muss die Liste der Parameter mit einem <i>Auslassungszeichen enden, es</i> muss jedoch auch mindestens ein fester Parameter <i>[C11 6.9.1 / 8]</i> vorhanden sein: <br><br><pre> <code class="plaintext hljs">void foo(int parm1, int parm2, ...);</code> </pre> </li><li>  Informationen √ºber die Anzahl und Art der Argumente, die der Ellipse entsprechen, werden nicht an die Funktion selbst √ºbergeben.  Das hei√üt,  nach dem zuletzt genannten Parameter ( <code>parm2</code> im obigen Beispiel) <i>[C11 6.7.6.3/9]</i> . <br></li><li>  Um auf diese Argumente zuzugreifen, m√ºssen Sie den im Header <code>&lt;stdarg.h&gt;</code> deklarierten Typ <code>va_list</code> und 4 (3 vor dem C11-Standard) Makros verwenden: <code>va_start</code> , <code>va_arg</code> , <code>va_end</code> und <code>va_copy</code> (beginnend mit C11) <i>[C11 7.16]</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Zum Beispiel</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">int add(int count, ...) { int result = 0; va_list args; va_start(args, count); for (int i = 0; i &lt; count; ++i) { result += va_arg(args, int); } va_end(args); return result; }</code> </pre> <br>  Ja, die Funktion wei√ü nicht, wie viele Argumente sie hat.  Sie muss diese Nummer irgendwie √ºbergeben.  In diesem Fall √ºber ein einzelnes benanntes Argument (eine weitere h√§ufige Option besteht darin, <code>NULL</code> als letztes Argument zu √ºbergeben, wie in <code>execl</code> oder 0). </div></div></li><li>  Das zuletzt genannte Argument darf keine <code>register</code> , es kann keine Funktion oder ein Array sein.  Andernfalls undefiniertes Verhalten <i>[C11 7.16.1.4/4]</i> . </li><li>  Dar√ºber hinaus wird auf das zuletzt genannte Argument und auf alle namenlosen <i>Argumente die</i> " <i>Standardargumentwerbung</i> " angewendet ( <i>Standardargumentwerbung</i> ; wenn es eine gute √úbersetzung dieses Konzepts ins Russische gibt, verwende ich es gerne).  Dies bedeutet, dass, wenn das Argument den Typ <code>char</code> , <code>short</code> (mit oder ohne Vorzeichen) oder <code>float</code> , auf die entsprechenden Parameter als <code>int</code> , <code>int</code> (mit oder ohne Vorzeichen) oder <code>double</code> zugegriffen werden muss.  Andernfalls undefiniertes Verhalten <i>[C11 7.16.1.1/2]</i> . </li><li>  √úber den Typ <code>va_list</code> wird nur gesagt, dass er in <code>&lt;stdarg.h&gt;</code> und vollst√§ndig ist ( <code>&lt;stdarg.h&gt;</code> die Gr√∂√üe eines Objekts dieses Typs ist bekannt) <i>[C11 7.16 / 3]</i> . </li></ul><br><h3>  Warum?  Aber weil! </h3><br>  Es gibt nicht viele Arten in C.  Warum ist <code>va_list</code> im Standard deklariert, aber nichts wird √ºber seine interne Struktur gesagt? <br><br>  Warum brauchen wir eine Ellipse, wenn eine beliebige Anzahl von Argumenten an eine Funktion √ºber <code>va_list</code> ?  Man k√∂nnte jetzt sagen: "als syntaktischer Zucker", aber vor 40 Jahren gab es sicher keine Zeit f√ºr Zucker. <br><br>  Philip James Plauger <i>Phillip James Plauger</i> in dem Buch <i>The Standard C Library</i> - 1992 - sagt, dass C urspr√ºnglich ausschlie√ülich f√ºr PDP-11-Computer erstellt wurde.  Und dort war es m√∂glich, alle Argumente der Funktion mit einfacher Zeigerarithmetik zu sortieren.  Das Problem trat mit der Popularit√§t von C und der √úbertragung des Compilers auf andere Architekturen auf.  In der ersten Ausgabe von <i>The C Programming Language von</i> <i>Brian Kernighan</i> und Dennis Ritchie - 1978 - hei√üt es ausdr√ºcklich: <blockquote>  √úbrigens gibt es keine akzeptable M√∂glichkeit, eine tragbare Funktion mit einer beliebigen Anzahl von Argumenten zu schreiben, weil  Es gibt keine tragbare M√∂glichkeit f√ºr die aufgerufene Funktion, herauszufinden, wie viele Argumente beim Aufruf an sie √ºbergeben wurden.  ... <code>printf</code> , die typischste C-Sprachfunktion einer beliebigen Anzahl von Argumenten, ... ist nicht portierbar und muss f√ºr jedes System implementiert werden. </blockquote>  Dieses Buch beschreibt <code>printf</code> , hat aber noch kein <code>vprintf</code> und erw√§hnt nicht den Typ und die Makros <code>va_*</code> .  Sie erscheinen in der zweiten Ausgabe der C-Programmiersprache (1988), und dies ist das Verdienst des Komitees f√ºr die Entwicklung des ersten C-Standards (C89, auch bekannt als ANSI C).  Das Komitee f√ºgte dem <code>&lt;stdarg.h&gt;</code> √úberschrift <code>&lt;stdarg.h&gt;</code> hinzu, die als Grundlage <code>&lt;varargs.h&gt;</code> von Andrew Koenig mit dem Ziel erstellt wurde, die Portabilit√§t des UNIX-Betriebssystems zu <code>&lt;varargs.h&gt;</code> .  <code>va_*</code> wurde beschlossen, <code>va_*</code> als Makros zu <code>va_*</code> , damit vorhandene Compiler den neuen Standard leichter unterst√ºtzen k√∂nnen. <br><br>  Mit dem Aufkommen von C89 und der <code>va_*</code> -Familie ist es nun m√∂glich geworden, tragbare variable Funktionen zu erstellen.  Und obwohl die interne Struktur dieser Familie noch in keiner Weise beschrieben ist und keine Anforderungen daf√ºr bestehen, ist bereits klar, warum. <br><br>  Aus purer Neugier finden Sie Beispiele f√ºr die Implementierung von <code>&lt;stdarg.h&gt;</code> .  Die gleiche ‚ÄûC-Standardbibliothek‚Äú bietet beispielsweise ein Beispiel f√ºr <b>Borland Turbo C ++</b> : <br><br><div class="spoiler">  <b class="spoiler_title">&lt;stdarg.h&gt; von Borland Turbo C ++</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#ifndef _STADARG #define _STADARG #define _AUPBND 1 #define _ADNBND 1 typedef char* va_list #define va_arg(ap, T) \ (*(T*)(((ap) += _Bnd(T, _AUPBND)) - _Bnd(T, _ADNBND))) #define va_end(ap) \ (void)0 #define va_start(ap, A) \ (void)((ap) = (char*)&amp;(A) + _Bnd(A, _AUPBND)) #define _Bnd(X, bnd) \ (sizeof(X) + (bnd) &amp; ~(bnd)) #endif</code> </pre> <br></div></div><br>  Das viel neuere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SystemV ABI f√ºr AMD64</a> verwendet diesen Typ f√ºr <code>va_list</code> : <br><br><div class="spoiler">  <b class="spoiler_title">va_list von SystemV ABI AMD64</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">typedef struct { unsigned int gp_offset; unsigned int fp_offset; void *overflow_arg_area; void *reg_save_area; } va_list[1];</code> </pre> <br></div></div><br>  Im Allgemeinen k√∂nnen wir sagen, dass der Typ und die Makros <code>va_*</code> eine Standardschnittstelle zum Durchlaufen von Argumenten einer variablen Funktion darstellen und ihre Implementierung aus historischen Gr√ºnden vom Compiler, den Zielplattformen und der Architektur abh√§ngt.  Dar√ºber hinaus erschien in C eine Ellipse (d. H. Variable Funktionen im Allgemeinen) fr√ºher als <code>va_list</code> (d. H. Der Header <code>&lt;stdarg.h&gt;</code> ).  Und <code>va_list</code> wurde nicht erstellt, um die Auslassungspunkte zu ersetzen, sondern um Entwicklern das Schreiben ihrer tragbaren Variablenfunktionen zu erm√∂glichen. <br><br>  C ++ beh√§lt weitgehend die Abw√§rtskompatibilit√§t mit C bei, daher gilt alles oben Genannte f√ºr C.  Es gibt aber auch Funktionen. <br><br><h3>  Variable Funktionen in C ++ </h3><br>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WG21-</a> Arbeitsgruppe war an der Entwicklung des C ++ - Standards beteiligt.  1989 wurde der neu geschaffene C89-Standard zugrunde gelegt, der sich allm√§hlich √§nderte, um C ++ selbst zu beschreiben.  1995 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erhielt</a> <i>John Micco den</i> Vorschlag <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">N0695</a> , in dem der Autor vorschlug, die Beschr√§nkungen f√ºr Makros <code>va_*</code> : <br><br><ul><li>  Weil  Im Gegensatz zu C k√∂nnen Sie in C ++ die <code>register</code> von Variablen abrufen. Das zuletzt genannte Argument einer Variablenfunktion kann diese Speicherklasse haben. <br></li><li>  Weil  Die in C ++ angezeigten Links versto√üen gegen die ungeschriebene Regel der C-Variablenfunktionen - die Gr√∂√üe des Parameters muss mit der Gr√∂√üe seines deklarierten Typs √ºbereinstimmen -, dann kann das zuletzt genannte Argument kein Link sein.  Ansonsten vages Verhalten. <br></li><li>  Weil  In C ++ gibt es kein Konzept, ‚Äû <i>den Typ des Arguments standardm√§√üig zu erh√∂hen</i> ‚Äú <i>,</i> sondern die Phrase <br><blockquote>  Wenn der Parameter <code>parmN</code> mit ... <code>parmN</code> wird, einem Typ, der nicht mit dem Typ kompatibel ist, der nach Anwendung der Standardargument-Promotions resultiert, ist das Verhalten undefiniert </blockquote>  muss ersetzt werden durch <blockquote>  Wenn der Parameter <code>parmN</code> mit ... <code>parmN</code> wird, einem Typ, der nicht mit dem Typ kompatibel ist, der beim √úbergeben eines Arguments entsteht, f√ºr das es keinen Parameter gibt, ist das Verhalten undefiniert </blockquote></li></ul>  Ich habe nicht einmal den letzten Punkt √ºbersetzt, um meinen Schmerz zu teilen.  Erstens bleibt die " <i>Eskalation</i> des <i>Standardargumenttyps</i> " in C ++ Standard <i>[C ++ 17 8.2.2 / 9]</i> .  Und zweitens habe ich lange √ºber die Bedeutung dieses Satzes nachgedacht, verglichen mit Standard C, wo alles klar ist.  Erst nachdem ich N0695 gelesen hatte, verstand ich endlich: Ich meine das Gleiche. <br><br>  Alle 3 √Ñnderungen wurden jedoch √ºbernommen <i>[C ++ 98 18.7 / 3]</i> .  Zur√ºck in C ++ ist die Anforderung, dass eine Variablenfunktion mindestens einen benannten Parameter haben muss (in diesem Fall k√∂nnen Sie nicht auf die anderen zugreifen, aber dazu sp√§ter mehr), verschwunden, und die Liste der g√ºltigen Typen unbenannter Argumente wurde durch Zeiger auf Klassenmitglieder und <abbr title="Einfache alte Daten">POD-</abbr> Typen erg√§nzt. <br><br>  Der C ++ 03-Standard brachte keine √Ñnderungen an den Variationsfunktionen.  C ++ 11 begann, ein unbenanntes Argument vom Typ <code>std::nullptr_t</code> in <code>void*</code> zu konvertieren, und erlaubte Compilern nach eigenem Ermessen, Typen mit nicht trivialen Konstruktoren und Destruktoren zu unterst√ºtzen <i>[C ++ 11 5.2.2 / 7]</i> .  C ++ 14 erlaubte die Verwendung von Funktionen und Arrays als zuletzt genanntem Parameter <i>[C ++ 14 18.10 / 3]</i> , und C ++ 17 verbot die Verwendung der Erweiterung des Parameterpakets ( <i>Pack-Erweiterung</i> ) und der vom Lambda erfassten Variablen <i>[C ++ 17 21.10.1 / 1]</i> . <br><br>  Infolgedessen f√ºgte C ++ seinen Fallstricken variable Funktionen hinzu.  Nur nicht spezifizierte Typunterst√ºtzung mit nicht trivialen Konstruktoren / Destruktoren lohnt sich.  Im Folgenden werde ich versuchen, alle nicht offensichtlichen Merkmale variabler Funktionen in einer Liste zusammenzufassen und durch spezifische Beispiele zu erg√§nzen. <br><br><h3>  Wie man variable Funktionen einfach und falsch benutzt </h3><br><ol><li>  Es ist falsch, das zuletzt genannte Argument mit einem heraufgestuften Typ zu deklarieren, d. H.  <code>char</code> , <code>signed char</code> , <code>unsigned char</code> , <code>singed short</code> , <code>unsigned short</code> oder <code>float</code> .  Das Ergebnis gem√§√ü dem Standard ist undefiniertes Verhalten. <br><br><div class="spoiler">  <b class="spoiler_title">Ung√ºltiger Code</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(float n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> <br></div></div><br>  Von allen Compilern, die ich zur Hand hatte (gcc, clang, MSVC), gab nur <b>clang</b> eine Warnung aus. <br><br><div class="spoiler">  <b class="spoiler_title">Clang Warnung</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:7:18: warning: passing an object that undergoes default argument promotion to 'va_start' has undefined behavior [-Wvarargs] va_start(va, n); ^</code> </pre> </div></div><br>  Und obwohl sich der kompilierte Code in allen F√§llen korrekt verhalten hat, sollten Sie sich nicht darauf verlassen. <br><br><div class="spoiler">  <b class="spoiler_title">Es wird richtig sein</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(double n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br></li><li>  Es ist falsch, das zuletzt genannte Argument als Referenz zu deklarieren.  Beliebiger Link.  Der Standard verspricht auch in diesem Fall undefiniertes Verhalten. <br><br><div class="spoiler">  <b class="spoiler_title">Ung√ºltiger Code</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int&amp; n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br>  <b>gcc 7.3.0</b> hat diesen Code ohne einen einzigen Kommentar kompiliert.  <b>lang 6.0.0</b> hat eine Warnung ausgegeben, diese aber dennoch kompiliert. <br><br><div class="spoiler">  <b class="spoiler_title">Clang Warnung</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:7:18: warning: passing an object of reference type to 'va_start' has undefined behavior [-Wvarargs] va_start(va, n); ^</code> </pre> </div></div><br>  In beiden F√§llen hat das Programm korrekt funktioniert (zum Gl√ºck k√∂nnen Sie sich nicht darauf verlassen).  Aber <b>MSVC 19.15.26730</b> zeichnete sich aus - es weigerte sich, den Code zu kompilieren, weil  <code>va_start</code> Argument <code>va_start</code> keine Referenz sein. <br><br><div class="spoiler">  <b class="spoiler_title">Fehler von MSVC</b> <div class="spoiler_text"><pre> <code class="diff hljs">c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vadefs.h(151): error C2338: va_start argument must not have reference type and must not be parenthesized</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Nun, die richtige Option sieht zum Beispiel so aus</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int* n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br></li><li>  Es ist falsch, <code>va_arg</code> , den Typ <code>char</code> , <code>short</code> oder <code>float</code> <code>va_arg</code> erh√∂hen. <br><br><div class="spoiler">  <b class="spoiler_title">Ung√ºltiger Code</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdarg&gt; #include &lt;iostream&gt; void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, float) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); } int main() { foo(0, 1, 2.0f, 3); return 0; }</code> </pre> </div></div><br>  Es ist hier interessanter.  <b>gcc</b> bei der Kompilierung gibt eine Warnung aus, dass <code>double</code> anstelle von <code>float</code> muss. Wenn dieser Code weiterhin ausgef√ºhrt wird, wird das Programm mit einem Fehler beendet. <br><br><div class="spoiler">  <b class="spoiler_title">Gcc Warnung</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:9:15: warning: 'float' is promoted to 'double' when passed through '...' std::cout &lt;&lt; va_arg(va, float) &lt;&lt; std::endl; ^~~~~~ ./test.cpp:9:15: note: (so you should pass 'double' not 'float' to 'va_arg') ./test.cpp:9:15: note: if this code is reached, the program will abort</code> </pre> </div></div><br>  In der Tat st√ºrzt das Programm mit einer Beschwerde √ºber eine ung√ºltige Anweisung ab. <br>  Eine Dump-Analyse zeigt, dass das Programm ein SIGILL-Signal empfangen hat.  Und es zeigt auch die Struktur von <code>va_list</code> .  F√ºr 32 Bit ist dies <br><br><pre> <code class="diff hljs">va = 0xfffc6918 ""</code> </pre> <br>  d.h.  <code>va_list</code> ist nur <code>char*</code> .  F√ºr 64 Bit: <br><br><pre> <code class="diff hljs">va = {{gp_offset = 16, fp_offset = 48, overflow_arg_area = 0x7ffef147e7e0, reg_save_area = 0x7ffef147e720}}</code> </pre> <br>  d.h.  genau das, was in SystemV ABI AMD64 beschrieben ist. <br><br>  <b>clang</b> at compilation warnt vor undefiniertem Verhalten und schl√§gt au√üerdem vor, <code>float</code> durch <code>double</code> ersetzen. <br><br><div class="spoiler">  <b class="spoiler_title">Clang Warnung</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:9:26: warning: second argument to 'va_arg' is of promotable type 'float'; this va_arg has undefined behavior because arguments will be promoted to 'double' [-Wvarargs] std::cout &lt;&lt; va_arg(va, float) &lt;&lt; std::endl; ^~~~~</code> </pre> </div></div><br>  Aber das Programm st√ºrzt nicht mehr ab, die 32-Bit-Version produziert: <br><br><pre> <code class="diff hljs">1 0 1073741824</code> </pre> <br>  64 Bit: <br><br><pre> <code class="diff hljs">1 0 3</code> </pre> <br>  <b>MSVC</b> liefert genau die gleichen Ergebnisse, nur ohne Vorwarnung, auch mit <code>/Wall</code> . <br><br>  Hier k√∂nnte angenommen werden, dass der Unterschied zwischen 32 und 64 Bit auf die Tatsache zur√ºckzuf√ºhren ist, dass im ersten Fall der ABI alle Argumente √ºber den Stapel an die aufgerufene Funktion weiterleitet und im zweiten Fall die ersten vier (Windows) oder sechs (Linux) Argumente √ºber die Prozessorregister, der Rest durch Stapel [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wiki</a> ].  Aber nein, wenn Sie <code>foo</code> nicht mit 4 Argumenten, sondern mit 19 aufrufen und auf dieselbe Weise ausgeben, ist das Ergebnis dasselbe: Volles Durcheinander in der 32-Bit-Version und Nullen f√ºr alle <code>float</code> in der 64-Bit-Version.  Das hei√üt,  Der Punkt ist nat√ºrlich in ABI, aber nicht in der Verwendung von Registern, um Argumente zu √ºbergeben. <br><br><div class="spoiler">  <b class="spoiler_title">Nat√ºrlich ist es richtig, dies zu tun</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, double) &lt;&lt; std::endl; std::cout &lt;&lt; va_arg(va, int) &lt;&lt; std::endl; va_end(va); }</code> </pre> </div></div><br></li><li>  Es ist falsch, eine Instanz einer Klasse mit einem nichttrivialen Konstruktor oder Destruktor als unbenanntes Argument zu √ºbergeben.  Es sei denn nat√ºrlich, das Schicksal dieses Codes reizt Sie zumindest ein wenig mehr als "hier und jetzt kompilieren und ausf√ºhren". <br><br><div class="spoiler">  <b class="spoiler_title">Ung√ºltiger Code</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdarg&gt; #include &lt;iostream&gt; struct Bar { Bar() { std::cout &lt;&lt; "Bar default ctor" &lt;&lt; std::endl; } Bar(const Bar&amp;) { std::cout &lt;&lt; "Bar copy ctor" &lt;&lt; std::endl; } ~Bar() { std::cout &lt;&lt; "Bar dtor" &lt;&lt; std::endl; } }; struct Cafe { Cafe() { std::cout &lt;&lt; "Cafe default ctor" &lt;&lt; std::endl; } Cafe(const Cafe&amp;) { std::cout &lt;&lt; "Cafe copy ctor" &lt;&lt; std::endl; } ~Cafe() { std::cout &lt;&lt; "Cafe dtor" &lt;&lt; std::endl; } }; void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; "Before va_arg" &lt;&lt; std::endl; const auto b = va_arg(va, Bar); va_end(va); } int main() { Bar b; Cafe c; foo(1, b, c); return 0; }</code> </pre> </div></div><br>  Clang ist der strengere von allen.  Er weigert sich einfach, diesen Code zu kompilieren, da das zweite Argument, <code>va_arg</code> kein POD-Typ ist, und warnt, dass das Programm beim Start <code>va_arg</code> . <br><br><div class="spoiler">  <b class="spoiler_title">Clang Warnung</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:23:31: error: second argument to 'va_arg' is of non-POD type 'Bar' [-Wnon-pod-varargs] const auto b = va_arg(va, Bar); ^~~ ./test.cpp:31:12: error: cannot pass object of non-trivial type 'Bar' through variadic function; call will abort at runtime [-Wnon-pod-varargs] foo(1, b, c); ^</code> </pre> </div></div><br>  So wird es sein, wenn Sie immer noch mit dem <code>-Wno-non-pod-varargs</code> . <br><br>  <b>MSVC</b> warnt davor, dass die Verwendung von Typen mit nicht trivialen Konstruktoren in diesem Fall nicht portierbar ist. <br><br><div class="spoiler">  <b class="spoiler_title">Warnung von MSVC</b> <div class="spoiler_text"><pre> <code class="diff hljs">d:\my documents\visual studio 2017\projects\test\test\main.cpp(31): warning C4840:    "Bar"         </code> </pre> </div></div><br>  Der Code wird jedoch kompiliert und ordnungsgem√§√ü ausgef√ºhrt.  Folgendes wird in der Konsole angezeigt: <br><br><div class="spoiler">  <b class="spoiler_title">Ergebnis starten</b> <div class="spoiler_text"><pre> <code class="diff hljs">Bar default ctor Cafe default ctor Before va_arg Bar copy ctor Bar dtor Cafe dtor Bar dtor</code> </pre> </div></div><br>  Das hei√üt,  Eine Kopie wird nur zum Zeitpunkt des Aufrufs von <code>va_arg</code> , und das Argument wird, wie sich herausstellt, als Referenz √ºbergeben.  Es ist irgendwie nicht offensichtlich, aber der Standard erlaubt. <br><br>  <b>gcc 6.3.0 wird</b> ohne einen einzigen Kommentar kompiliert.  Die Ausgabe ist die gleiche: <br><br><div class="spoiler">  <b class="spoiler_title">Ergebnis starten</b> <div class="spoiler_text"><pre> <code class="diff hljs">Bar default ctor Cafe default ctor Before va_arg Bar copy ctor Bar dtor Cafe dtor Bar dtor</code> </pre> </div></div><br>  <b>gcc 7.3.0 warnt</b> auch vor nichts, aber das Verhalten √§ndert sich: <br><br><div class="spoiler">  <b class="spoiler_title">Ergebnis starten</b> <div class="spoiler_text"><pre> <code class="diff hljs">Bar default ctor Cafe default ctor Cafe copy ctor Bar copy ctor Before va_arg Bar copy ctor Bar dtor Bar dtor Cafe dtor Cafe dtor Bar dtor</code> </pre> </div></div><br>  Das hei√üt,  Diese Version des Compilers √ºbergibt Argumente nach Wert, und beim Aufruf erstellt <code>va_arg</code> eine weitere Kopie.  Es w√ºrde Spa√ü machen, diesen Unterschied beim Wechsel von der 6. zur 7. Version von gcc zu suchen, wenn die Konstruktoren / Destruktoren Nebenwirkungen haben. <br><br>  √úbrigens, wenn Sie explizit einen Verweis auf die Klasse √ºbergeben und anfordern: <br><br><div class="spoiler">  <b class="spoiler_title">Ein weiterer falscher Code</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; "Before va_arg" &lt;&lt; std::endl; const auto&amp; b = va_arg(va, Bar&amp;); va_end(va); } int main() { Bar b; Cafe c; foo(1, std::ref(b), c); return 0; }</code> </pre> </div></div><br>  dann werfen alle Compiler einen Fehler aus.  Gem√§√ü Standard. <br><br>  Wenn Sie wirklich wollen, ist es im Allgemeinen besser, Argumente per Zeiger zu √ºbergeben. <br><br><div class="spoiler">  <b class="spoiler_title">So</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void foo(int n, ...) { va_list va; va_start(va, n); std::cout &lt;&lt; "Before va_arg" &lt;&lt; std::endl; const auto* b = va_arg(va, Bar*); va_end(va); } int main() { Bar b; Cafe c; foo(1, &amp;b, &amp;c); return 0; }</code> </pre> </div></div><br></li></ol><br><h3>  √úberlastaufl√∂sung und variable Funktionen </h3><br>  Einerseits ist alles einfach: Der Abgleich mit einer Ellipse ist schlechter als der Abgleich mit einem regul√§ren benannten Argument, selbst bei einer Standard- oder benutzerdefinierten Typkonvertierung. <br><br><div class="spoiler">  <b class="spoiler_title">√úberlastungsbeispiel</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(...) { std::cout &lt;&lt; "C variadic function" &lt;&lt; std::endl; } void foo(int) { std::cout &lt;&lt; "Ordinary function" &lt;&lt; std::endl; } int main() { foo(1); foo(1ul); foo(); return 0; }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Ergebnis starten</b> <div class="spoiler_text"><pre> <code class="diff hljs">$ ./test Ordinary function Ordinary function C variadic function</code> </pre> </div></div><br>  Dies funktioniert jedoch nur, bis der Aufruf von <code>foo</code> ohne Argumente separat betrachtet werden muss. <br><br><div class="spoiler">  <b class="spoiler_title">Rufen Sie foo ohne Argumente auf</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(...) { std::cout &lt;&lt; "C variadic function" &lt;&lt; std::endl; } void foo() { std::cout &lt;&lt; "Ordinary function without arguments" &lt;&lt; std::endl; } int main() { foo(1); foo(); return 0; }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Compiler-Ausgabe</b> <div class="spoiler_text"><pre> <code class="diff hljs">./test.cpp:16:9: error: call of overloaded 'foo()' is ambiguous foo(); ^ ./test.cpp:3:6: note: candidate: void foo(...) void foo(...) ^~~ ./test.cpp:8:6: note: candidate: void foo() void foo() ^~~</code> </pre> </div></div><br>  Alles entspricht dem Standard: Es gibt keine Argumente - es gibt keinen Vergleich mit den Auslassungspunkten, und wenn die √úberlastung behoben ist, wird die Variationsfunktion nicht schlechter als gew√∂hnlich. <br><br><h3>  Wann lohnt es sich trotzdem, variable Funktionen zu verwenden? </h3><br>  Nun, variative Funktionen verhalten sich manchmal nicht sehr offensichtlich und k√∂nnen sich im Kontext von C ++ leicht als schlecht portabel herausstellen.  Im Internet gibt es viele Tipps wie "Erstellen oder verwenden Sie keine variablen C-Funktionen", aber sie werden ihre Unterst√ºtzung nicht aus dem C ++ - Standard entfernen.  Diese Funktionen bieten also einige Vorteile?  Na da. <br><br><ul><li>  Der h√§ufigste und offensichtlichste Fall ist die Abw√§rtskompatibilit√§t.  Hier werde ich sowohl die Verwendung von C-Bibliotheken von Drittanbietern (mein Fall mit JNI) als auch die Bereitstellung der C-API f√ºr die C ++ - Implementierung einbeziehen. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Ein Substitutionsfehler ist kein Fehler">SFINAE</a> .  Hier ist es sehr n√ºtzlich, dass in C ++ eine Variablenfunktion keine benannten Argumente haben muss und dass beim Aufl√∂sen √ºberladener Funktionen eine Variablenfunktion als letzte betrachtet wird (wenn mindestens ein Argument vorhanden ist).  Und wie jede andere Funktion kann eine variable Funktion nur deklariert, aber nie aufgerufen werden. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class T&gt; struct HasFoo { private: template &lt;class U, class = decltype(std::declval&lt;U&gt;().foo())&gt; static void detect(const U&amp;); static int detect(...); public: static constexpr bool value = std::is_same&lt;void, decltype(detect(std::declval&lt;T&gt;()))&gt;::value; };</code> </pre> </div></div><br>  Obwohl in C ++ 14 k√∂nnen Sie etwas anders machen. <br><br><div class="spoiler">  <b class="spoiler_title">Ein weiteres Beispiel</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class T&gt; struct HasFoo { private: template &lt;class U, class = decltype(std::declval&lt;U&gt;().foo())&gt; static constexpr bool detect(const U*) { return true; } template &lt;class U&gt; static constexpr bool detect(...) { return false; } public: static constexpr bool value = detect&lt;T&gt;(nullptr); };</code> </pre> </div></div><br>  Und in diesem Fall ist es bereits notwendig zu beobachten, mit welchen Argumenten <code>detect(...)</code> aufgerufen werden kann.  Ich w√ºrde es vorziehen, ein paar Zeilen zu √§ndern und eine moderne Alternative zu variablen Funktionen zu verwenden, ohne all ihre M√§ngel. <br></li></ul><br><h3>  Variantenvorlagen oder das Erstellen von Funktionen aus einer beliebigen Anzahl von Argumenten in modernem C ++ </h3><br>  Die Idee variabler Vorlagen wurde bereits 2004 von Douglas Gregor, Jaakko J√§rvi und Gary Powell vorgeschlagen, d. H.  7 Jahre vor der Einf√ºhrung des C ++ 11-Standards, in dem diese variablen Vorlagen offiziell unterst√ºtzt wurden.  Der Standard enthielt eine dritte √úberarbeitung ihres Vorschlags, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">N2080</a> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Von Anfang an wurden variable Vorlagen erstellt, damit Programmierer aus einer beliebigen Anzahl von Argumenten typsichere (und portable!) Funktionen erstellen konnten. </font><font style="vertical-align: inherit;">Ein weiteres Ziel ist es, die Unterst√ºtzung f√ºr Klassenvorlagen mit einer variablen Anzahl von Parametern zu vereinfachen. Jetzt geht es jedoch nur noch um variable Funktionen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variable Vorlagen brachten drei neue Konzepte in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ [C ++ 17 17.5.3]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Template - </font><font style="vertical-align: inherit;">Parameter - </font><font style="vertical-align: inherit;">Paket ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Template - </font><font style="vertical-align: inherit;">Parameter - </font><font style="vertical-align: inherit;">Pack</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) - ist eine Parametervorlage, statt dessen ist es m√∂glich , </font><font style="vertical-align: inherit;">jede (einschlie√ülich 0) Anzahl der Template - </font><font style="vertical-align: inherit;">Argument zu √ºbertragen;</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Paket von Funktionsparametern ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktionsparameterpaket</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) - dementsprechend ist dies ein Funktionsparameter, der eine beliebige (einschlie√ülich 0) Anzahl von Funktionsargumenten akzeptiert;</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und die Erweiterung des Pakets ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pack-Erweiterung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) ist das einzige, was mit dem Parameterpaket durchgef√ºhrt werden kann.</font></font><br></li></ul><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(const std::string&amp; format, Args ... args) { printf(format.c_str(), args...); }</code> </pre> <br>  <code>class ... Args</code> ‚Äî   , <code>Args ... args</code> ‚Äî   ,  <code>args...</code> ‚Äî    . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine vollst√§ndige Liste, wo und wie Parameterpakete erweitert werden k√∂nnen, finden Sie im Standard selbst </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[C ++ 17 17.5.3 / 4]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Und im Zusammenhang mit der Diskussion variabler Funktionen gen√ºgt es zu sagen:</font></font><br><br><ul><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Funktionsparameterpaket kann in die Argumentliste einer anderen Funktion erweitert werden</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void bar(const std::string&amp; format, Args ... args) { foo&lt;Args...&gt;(format.c_str(), args...); }</code> </pre> </div></div><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder zur Initialisierungsliste</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(const std::string&amp; format, Args ... args) { const auto list = {args...}; }</code> </pre> </div></div><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder zur Lambda-Erfassungsliste</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(const std::string&amp; format, Args ... args) { auto lambda = [&amp;format, args...] () { printf(format.c_str(), args...); }; lambda(); }</code> </pre> </div></div><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiteres Paket von Funktionsparametern kann in einem Faltungsausdruck erweitert werden</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; int foo(Args ... args) { return (0 + ... + args); }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faltungen erschienen in C ++ 14 und k√∂nnen un√§r und bin√§r sein, rechts und links. </font><font style="vertical-align: inherit;">Die vollst√§ndigste Beschreibung findet sich wie immer im Standard </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[C ++ 17 8.1.6]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br></li><li><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beide Arten von Parameterpaketen k√∂nnen in den Operator sizeof ... erweitert werden</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo(Args ... args) { const auto size1 = sizeof...(Args); const auto size2 = sizeof...(args); }</code> </pre> </div></div><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das explizite Auslassungs Pakets Bei der </font><font style="vertical-align: inherit;">Angabe der </font><font style="vertical-align: inherit;">ben√∂tigt wird , </font><font style="vertical-align: inherit;">um die verschiedenen Vorlagen (zur Unterst√ºtzung </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muster</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) Offenlegung und diese Mehrdeutigkeit zu vermeiden.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Zum Beispiel</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;class ... Args&gt; void foo() { using OneTuple = std::tuple&lt;std::tuple&lt;Args&gt;...&gt;; using NestTuple = std::tuple&lt;std::tuple&lt;Args...&gt;&gt;; }</code> </pre> <br> <code>OneTuple</code> ‚Äî      ( <code>std:tuple&lt;std::tuple&lt;int&gt;&gt;, std::tuple&lt;double&gt;&gt;</code> ),  <code>NestTuple</code> ‚Äî ,     ‚Äî   ( <code>std::tuple&lt;std::tuple&lt;int, double&gt;&gt;</code> ). </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beispielimplementierung von printf mit variablen Vorlagen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bereits erw√§hnt, wurden Variablenvorlagen auch als direkter Ersatz f√ºr die Variablenfunktionen von C erstellt. Die Autoren dieser Vorlagen selbst schlugen ihre sehr einfache, aber typsichere Version vor </font></font><code>printf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- eine der ersten Variablenfunktionen in C.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf auf Vorlagen</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void printf(const char* s) { while (*s) { if (*s == '%' &amp;&amp; *++s != '%') throw std::runtime_error("invalid format string: missing arguments"); std::cout &lt;&lt; *s++; } } template &lt;typename T, typename ... Args&gt; void printf(const char* s, T value, Args ... args) { while (*s) { if (*s == '%' &amp;&amp; *++s != '%') { std::cout &lt;&lt; value; return printf(++s, args...); } std::cout &lt;&lt; *s++; } throw std::runtime_error("extra arguments provided to printf"); }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich vermute, dann erschien dieses Muster der Aufz√§hlung variabler Argumente - durch einen rekursiven Aufruf √ºberladener Funktionen. </font><font style="vertical-align: inherit;">Aber ich bevorzuge immer noch die Option ohne Rekursion.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf auf Vorlagen und ohne Rekursion</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">template &lt;typename ... Args&gt; void printf(const std::string&amp; fmt, const Args&amp; ... args) { size_t fmtIndex = 0; size_t placeHolders = 0; auto printFmt = [&amp;fmt, &amp;fmtIndex, &amp;placeHolders]() { for (; fmtIndex &lt; fmt.size(); ++fmtIndex) { if (fmt[fmtIndex] != '%') std::cout &lt;&lt; fmt[fmtIndex]; else if (++fmtIndex &lt; fmt.size()) { if (fmt[fmtIndex] == '%') std::cout &lt;&lt; '%'; else { ++fmtIndex; ++placeHolders; break; } } } }; ((printFmt(), std::cout &lt;&lt; args), ..., (printFmt())); if (placeHolders &lt; sizeof...(args)) throw std::runtime_error("extra arguments provided to printf"); if (placeHolders &gt; sizeof...(args)) throw std::runtime_error("invalid format string: missing arguments"); }</code> </pre> </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √úberlastungsaufl√∂sung und variable Vorlagenfunktionen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Aufl√∂sung werden diese variativen Funktionen nach anderen als Standard und am wenigsten spezialisiert betrachtet. </font><font style="vertical-align: inherit;">Bei einem Aufruf ohne Argumente gibt es jedoch kein Problem.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úberlastungsbeispiel</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(int) { std::cout &lt;&lt; "Ordinary function" &lt;&lt; std::endl; } void foo() { std::cout &lt;&lt; "Ordinary function without arguments" &lt;&lt; std::endl; } template &lt;class T&gt; void foo(T) { std::cout &lt;&lt; "Template function" &lt;&lt; std::endl; } template &lt;class ... Args&gt; void foo(Args ...) { std::cout &lt;&lt; "Template variadic function" &lt;&lt; std::endl; } int main() { foo(1); foo(); foo(2.0); foo(1, 2); return 0; }</code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnis starten</font></font></b> <div class="spoiler_text"><pre> <code class="diff hljs">$ ./test Ordinary function Ordinary function without arguments Template function Template variadic function</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die √úberladung behoben ist, kann eine variable Vorlagenfunktion nur eine variable C-Funktion umgehen (obwohl warum sie mischen?). </font><font style="vertical-align: inherit;">Au√üer - nat√ºrlich! </font><font style="vertical-align: inherit;">- Aufruf ohne Argumente.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufruf ohne Argumente</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;iostream&gt; void foo(...) { std::cout &lt;&lt; "C variadic function" &lt;&lt; std::endl; } template &lt;class ... Args&gt; void foo(Args ...) { std::cout &lt;&lt; "Template variadic function" &lt;&lt; std::endl; } int main() { foo(1); foo(); return 0; }</code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnis starten</font></font></b> <div class="spoiler_text"><pre> <code class="diff hljs">$ ./test Template variadic function C variadic function</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es gibt einen Vergleich mit einer Ellipse - die entsprechende Funktion verliert, es gibt keinen Vergleich mit einer Ellipse - und die Vorlagenfunktion ist der Nicht-Vorlagenfunktion unterlegen. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ein kurzer Hinweis zur Geschwindigkeit variabler Vorlagenfunktionen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Jahr 2008 </font><font style="vertical-align: inherit;">reichte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo√Øc Joly</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seinen Vorschlag </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N2772</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beim C ++ Standardization Committee ein </font><font style="vertical-align: inherit;">, in dem er in der Praxis zeigte, dass variable Vorlagenfunktionen langsamer arbeiten als √§hnliche Funktionen, deren Argument die Initialisierungsliste ist ( </font></font><code>std::initializer_list</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Und obwohl dies im </font><font style="vertical-align: inherit;">Gegensatz zu theoretischer Fundierung des Autors selbst, schlug Joly zu implementieren </font></font><code>std::min</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>std::max</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>std::minmax</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es ist durch die Initialisierung Listen statt Variante Muster. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber bereits im Jahr 2009 erschien eine Widerlegung. Bei den Tests von Joli wurde ein ‚Äûschwerwiegender Fehler‚Äú entdeckt (es scheint sogar f√ºr sich selbst). Neue Tests (siehe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) haben gezeigt, dass variable Vorlagenfunktionen immer noch schneller und manchmal erheblich sind. </font><font style="vertical-align: inherit;">Was seitdem nicht verwunderlich ist </font><font style="vertical-align: inherit;">Die Initialisierungsliste erstellt Kopien ihrer Elemente, und f√ºr variable Vorlagen k√∂nnen Sie bei der Kompilierung viel z√§hlen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doch in C ++ 11 und nachfolgenden Standards </font></font><code>std::min</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>std::max</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>std::minmax</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- das ist die √ºblichen Template - </font><font style="vertical-align: inherit;">Funktionen, eine beliebige Anzahl von Argumenten, die durch die Initialisierung Liste √ºbertragen werden.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kurze Zusammenfassung und Schlussfolgerung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Variablenfunktionen im C-Stil: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie kennen weder die Anzahl ihrer Argumente noch ihre Typen. </font><font style="vertical-align: inherit;">Der Entwickler muss einen Teil der Argumente an die Funktion verwenden, um Informationen √ºber den Rest zu √ºbergeben.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erh√∂hen Sie implizit die Typen unbenannter Argumente (und die zuletzt genannten). </font><font style="vertical-align: inherit;">Wenn Sie es vergessen, bekommen Sie vages Verhalten.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie behalten die Abw√§rtskompatibilit√§t mit reinem C bei und unterst√ºtzen daher nicht die √úbergabe von Argumenten als Referenz. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vor C ++ 11 wurden Argumente, die nicht vom </font><font style="vertical-align: inherit;">Typ </font></font><abbr title="Einfache alte Daten"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POD</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> waren, </font><font style="vertical-align: inherit;">nicht unterst√ºtzt </font><font style="vertical-align: inherit;">, und seit C ++ 11 lag die Unterst√ºtzung f√ºr nicht triviale Typen im Ermessen des Compilers.</font></font> Das hei√üt,<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Verhalten des Codes h√§ngt vom Compiler und seiner Version ab. </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die einzig zul√§ssige Verwendung von Variablenfunktionen ist die Interaktion mit der C-API in C ++ - Code. </font><font style="vertical-align: inherit;">F√ºr alles andere, einschlie√ülich </font></font><abbr title="Ein Substitutionsfehler ist kein Fehler"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , gibt es variable Vorlagenfunktionen, die:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kennen Sie die Anzahl und Art aller ihrer Argumente. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Geben Sie safe ein und √§ndern Sie nicht die Typen ihrer Argumente. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie unterst√ºtzen die √úbergabe von Argumenten in jeder Form - nach Wert, Zeiger, Referenz, universeller Verkn√ºpfung. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wie bei jeder anderen C ++ - Funktion gibt es keine Einschr√§nkungen f√ºr die Argumenttypen. </font></font><br></li><li>        (   C ),   . <br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variable Vorlagenfunktionen k√∂nnen im Vergleich zu ihren Gegenst√ºcken im C-Stil ausf√ºhrlicher sein und erfordern manchmal sogar eine eigene √ºberladene Nicht-Vorlagenversion (rekursives Durchlaufen von Argumenten). </font><font style="vertical-align: inherit;">Sie sind schwerer zu lesen und zu schreiben. </font><font style="vertical-align: inherit;">All dies wird jedoch durch das Fehlen der aufgef√ºhrten M√§ngel und das Vorhandensein der aufgef√ºhrten Vorteile mehr als bezahlt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Schlussfolgerung ist einfach: Variative Funktionen im C-Stil bleiben nur aufgrund der Abw√§rtskompatibilit√§t in C ++ erhalten und bieten eine Vielzahl von Optionen, um Ihr Bein zu schie√üen. </font><font style="vertical-align: inherit;">In modernem C ++ ist es sehr ratsam, keine neuen zu schreiben und wenn m√∂glich keine vorhandenen variablen C-Funktionen zu verwenden. </font><font style="vertical-align: inherit;">Variable Vorlagenfunktionen geh√∂ren zur Welt des modernen C ++ und sind viel sicherer. </font><font style="vertical-align: inherit;">Verwenden Sie sie.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Literatur und Quellen </font></font></h3><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PJ Plauger, Die Standard C Bibliothek</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brian W. Kernighan und Dennis M. Ritchie, Programmiersprache C, 1. Auflage</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brian W. Kernighan und Dennis M. Ritchie, Programmiersprache C, 2. Auflage</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standard C11, Entwurf N1570</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 98 Standard</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 03 Standard</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 11 Standard, Entwurf N3337</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standard C ++ 14, Entwurf N4296</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 17 Standard, Entwurf N4659</font></font></a> <br></li></ul><br><h3>  PS </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist einfach, elektronische Versionen der im Internet genannten B√ºcher zu finden und herunterzuladen. </font><font style="vertical-align: inherit;">Ich bin mir jedoch nicht sicher, ob dies legal ist, daher gebe ich keine Links.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430064/">https://habr.com/ru/post/de430064/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430052/index.html">Warum ist es f√ºr Hardwareentwickler wichtig, Qualit√§ts-Cusdev durchzuf√ºhren?</a></li>
<li><a href="../de430054/index.html">HolyJS 2018 Moskau: kostenlose Online-√úbertragung, Party sowie Wissenschafts- und Technologie-Rap</a></li>
<li><a href="../de430058/index.html">Wellenprozesse in Hydraulikleitungen. Die Grundlagen</a></li>
<li><a href="../de430060/index.html">Hackspace, Denis Perevalov, Anastasia Krokhaleva - die Magie des Programmierens</a></li>
<li><a href="../de430062/index.html">Microservices. Entwicklungs- und Refactoring-Muster mit Java-Beispielen</a></li>
<li><a href="../de430068/index.html">Ordnung der Puppe</a></li>
<li><a href="../de430070/index.html">Stapel und Warteschlange sind zwei schlechte Paradigmen und was kann dagegen getan werden?</a></li>
<li><a href="../de430072/index.html">Serverseitig Swift Underestimated: Interview mit Paul Hudson</a></li>
<li><a href="../de430074/index.html">Wie ich fast einen Virus gefangen h√§tte, der versucht, Stiefel zu verkaufen</a></li>
<li><a href="../de430076/index.html">Kostenlose Ausstrahlung von DotNext 2018 Moskau</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>