<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥃 👨🏼‍🔧 👇🏿 Die ganze Wahrheit über RTOS. Artikel Nr. 26. Kanäle: Nebendienstleistungen und Datenstrukturen ⭐️ 💮 🐚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werden wir weiterhin Datenübertragungskanäle betrachten. 

 Channel Support Services 
 Nucleus RTOS verfügt über vier API-Aufrufe, d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit über RTOS. Artikel Nr. 26. Kanäle: Nebendienstleistungen und Datenstrukturen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433374/"><img src="https://habrastorage.org/webt/ok/ll/ke/okllkejturanltd2yqnjeofmqxu.jpeg"><br><br>  In diesem Artikel werden wir weiterhin Datenübertragungskanäle betrachten. <br><br><h2>  Channel Support Services </h2><br>  Nucleus RTOS verfügt über vier API-Aufrufe, die zusätzliche Funktionen für Kanäle bereitstellen: Zurücksetzen eines Kanals, Empfangen von Kanalinformationen, Abrufen der Anzahl der Kanäle in einer Anwendung und Abrufen von Zeigern auf alle Kanäle in einer Anwendung.  Die ersten drei Funktionen sind in Nucleus SE implementiert. <br><a name="habracut"></a><br>  Frühere Artikel in der Reihe: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 25.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenkanäle: Einführung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlangen: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlangen: Einführung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postfächer: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postfächer: Einführung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Einführung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Hilfsdienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Einführung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Signale</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherpartitionen: Dienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherbereiche: Einführung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabendatenstrukturen und nicht unterstützte API-Aufrufe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstleistungen für die Arbeit mit Aufgaben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben: Konfiguration und Einführung in die API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Erweiterte Funktionen und Kontexterhaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einführung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einführung.</a> <br><br><h3>  Kanal zurückgesetzt </h3><br>  Dieser API-Aufruf setzt den Kanal auf seinen ursprünglichen, nicht verwendeten Zustand zurück.  Alle darin gespeicherten Nachrichten gehen verloren.  Alle auf dem Kanal angehaltenen Aufgaben werden mit dem Rückkehrcode <b>NUSE_PIPE_WAS_RESET fortgesetzt</b> . <br><br>  <b><i>Kanal-Reset-Aufruf in Nucleus RTOS</i></b> <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NU_Reset_Pipe (NU_PIPE * -Pipe);</b> <br><br>  Parameter: <br><br>  <b>Pipe</b> - Ein Zeiger auf einen benutzerdefinierten Kanalsteuerblock. <br><br>  Rückgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_PIPE</b> - ungültiger <b>Kanalzeiger</b> . <br><br>  <b><i>Channel Reset Challenge in Nucleus SE</i></b> <br><br>  Dieser API-Serviceaufruf unterstützt die Kernfunktionalität der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NUSE_Pipe_Reset (NUSE_PIPE-Pipe);</b> <br><br>  Parameter: <br><br>  <b>Pipe</b> ist der Index (ID) der <b>Pipe, die</b> gelöscht wird. <br><br>  Rückgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_PIPE</b> - Ungültiger <b>Kanalindex</b> . <br><br>  <b><i>Implementierung des Kanalrücksetzens in Nucleus SE</i></b> <br><br>  Der Code für die Funktion <b>NUSE_Pipe_Reset ()</b> (nach Überprüfung der Parameter) ist ziemlich einfach.  Die Start- und Endindizes des Kanals sowie der Nachrichtenzähler im Kanal werden auf 0 gesetzt. <br><br>  Wenn die Task-Sperre aktiviert ist, ist zusätzlicher Code für die Wiederherstellung angehaltener Tasks verantwortlich: <br><br><pre><code class="plaintext hljs">while (NUSE_Pipe_Blocking_Count[pipe] != 0) { U8 index; /* check whether any tasks are blocked */ /* on this pipe */ for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_PIPE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == pipe)) { NUSE_Task_Blocking_Return[index] = NUSE_PIPE_RESET; NUSE_Task_Status[index] = NUSE_READY; break; } } NUSE_Pipe_Blocking_Count[pipe]--; } #if NUSE_SCHEDULER_TYPE == NUSE_PRIORITY_SCHEDULER NUSE_Reschedule(NUSE_NO_TASK); #endif</code> </pre> <br>  Jeder auf dem Kanal angehaltenen Aufgabe wird der Status "Bereit" mit dem Rückkehrcode <b>NUSE_PIPE_WAS_RESET zugewiesen</b> .  Nach Abschluss dieses Vorgangs wird bei Verwendung des Prioritätsplaners die Funktion <b>NUSE_Reschedule () aufgerufen</b> , da eine oder mehrere Aufgaben mit hoher Priorität zur Ausführung bereit sein können. <br><br><h3>  Kanalinfo </h3><br>  Dieser Serviceabruf gibt Kanalinformationen zurück.  Die Implementierung dieses Aufrufs in Nucleus SE unterscheidet sich von Nucleus RTOS darin, dass weniger Informationen zurückgegeben werden.  Dies liegt daran, dass Objektnamen, Nachrichten mit variabler Länge und die Reihenfolge der Aufgabenpausen in Nucleus SE nicht unterstützt werden und die Aufgabenpause deaktiviert werden kann. <br><br>  <b><i>Rufen Sie Kanalinformationen in Nucleus RTOS an</i></b> <br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NU_Pipe_Information (NU_PIPE * Pipe, CHAR * Name, VOID ** Startadresse, UNSIGNED * Pipe_size, UNSIGNED * verfügbar, UNSIGNED * Nachrichten, OPTION * Nachrichtentyp, UNSIGNED * Nachrichtengröße, OPTION * Suspend_Typ, UNSIGNED * Aufgaben_waask;</b> <br><br>  Parameter: <br><br>  <b>Pipe</b> - Zeiger auf den vom Benutzer bereitgestellten Kanalsteuerblock; <br>  <b>name</b> - Zeiger auf den 8-stelligen Bereich für den Kanalnachrichtennamen; <br>  <b>start_address</b> - ein Zeiger auf einen Zeiger, in den die Adresse des Anfangs des <b>Kanaldatenbereichs</b> geschrieben wird; <br>  <b>pipe_size</b> - ein Zeiger auf eine Variable zum Speichern der Gesamtzahl der Bytes im Kanal; <br>  <b>verfügbar</b> - Zeiger auf eine Variable zum Speichern der Anzahl der verfügbaren Bytes im Kanal; <br>  <b>Nachrichten</b> - ein Zeiger auf eine Variable zum Speichern der Anzahl von Nachrichten im Kanal; <br>  <b>message_type</b> - Ein Zeiger auf eine Variable zum Speichern des vom Kanal unterstützten Nachrichtentyps.  Es kann die Werte <b>NU_FIXED_SIZE</b> und <b>NU_VARIABLE_SIZE annehmen</b> . <br>  <b>message_size</b> - Zeiger auf eine Variable zum Speichern der Anzahl von Bytes in jeder <b>Kanalnachricht</b> .  Wenn der Kanal Nachrichten mit variabler Länge unterstützt, ist diese Nummer die maximale Nachrichtengröße. <br>  <b>suspend_type</b> - Ein Zeiger auf eine Variable zum Speichern des Typs der Suspend-Task.  Es kann die Werte <b>NU_FIFO</b> und <b>NU_PRIORITY annehmen</b> . <br>  <b>task_waiting</b> - ein Zeiger auf eine Variable zum Speichern der Anzahl der auf diesem Kanal angehaltenen Aufgaben; <br>  <b>first_task</b> - Ein Zeiger auf einen Zeiger auf die erste angehaltene Aufgabe. <br><br>  Rückgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_PIPE</b> - ungültiger <b>Kanalzeiger</b> . <br><br>  <b><i>Kanalinformationen in Nucleus SE anfordern</i></b> <br>  Dieser API-Aufruf unterstützt die Kernfunktionalität der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NUSE_Pipe_Information (NUSE_PIPE-Pipe, ADDR * Startadresse, U8 * Pipe-Größe, U8 * verfügbar, U8 * Nachrichten, U8 * Nachrichtengröße, U8 * Aufgaben warten, NUSE_TASK * first_task);</b> <br><br>  Parameter: <br><br>  <b>Pipe</b> - Index des Kanals, Informationen darüber, welche angefordert werden; <br>  <b>start_address</b> - Zeiger auf eine Variable vom Typ <b>ADDR</b> zum Speichern der Adresse des Anfangs des <b>Kanaldatenbereichs</b> ; <br>  <b>pipe_size</b> - ein Zeiger auf eine Variable vom Typ <b>U8</b> zum Speichern der Gesamtzahl der Nachrichten, die der Kanal empfangen kann; <br>  <b>verfügbar</b> - ein Zeiger auf eine Variable vom Typ <b>U8</b> zum Speichern der Anzahl der Nachrichten, für die im Kanal noch freier Speicherplatz vorhanden ist; <br>  <b>Nachrichten</b> - ein Zeiger auf eine Variable vom Typ <b>U8</b> zum Speichern der aktuellen Anzahl von Nachrichten im Kanal; <br>  <b>message_size</b> - Zeiger auf eine Variable vom Typ <b>U8</b> zum Speichern der Größe der von diesem Kanal verarbeiteten Nachrichten; <br>  <b>task_waiting</b> - ein Zeiger auf eine Variable zum Speichern der Anzahl der auf diesem Kanal angehaltenen Aufgaben (nichts wird zurückgegeben, wenn die Aufgabe angehalten ist); <br>  <b>first_task</b> - Ein Zeiger auf eine Variable vom Typ <b>NUSE_TASK</b> , die den Index der ersten angehaltenen Aufgabe übernimmt (nichts wird zurückgegeben, wenn die Aufgabe angehalten ist). <br><br>  Rückgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_PIPE</b> - ungültiger <b>Kanalindex</b> ; <br>  <b>NUSE_INVALID_POINTER</b> - Ein oder mehrere <b>Zeigerparameter</b> sind falsch. <br><br>  <b><i>Implementieren von Kanalinformationen in Nucleus SE</i></b> <br><br>  Die Implementierung dieses API-Aufrufs ist ziemlich einfach: <br><br><pre> <code class="plaintext hljs">*start_address = NUSE_Pipe_Data[pipe]; *pipe_size = NUSE_Pipe_Size[pipe]; *available = NUSE_Pipe_Size[pipe] - NUSE_Pipe_Items[pipe]; *messages = NUSE_Pipe_Items[pipe]; *message_size = NUSE_Pipe_Message_Size[pipe]; #if NUSE_BLOCKING_ENABLE *tasks_waiting = NUSE_Pipe_Blocking_Count[pipe]; if (NUSE_Pipe_Blocking_Count[pipe] != 0) { U8 index; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_PIPE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == pipe)) { *first_task = index; break; } } } else { *first_task = 0; } #else *tasks_waiting = 0; *first_task = 0; #endif</code> </pre><br>  Die Funktion gibt den Status des Kanals zurück.  Wenn dann Task-Sperren aktiviert sind, werden die Anzahl der ausstehenden Tasks und der Index der ersten zurückgegeben (andernfalls werden diese beiden Parameter auf 0 gesetzt). <br><br><h3>  Abrufen der Anzahl der Kanäle </h3><br>  Dieser Serviceabruf gibt die Anzahl der in der Anwendung konfigurierten Kanäle zurück.  In Nucleus RTOS kann sich dieser Wert im Laufe der Zeit ändern, und der Rückgabewert gibt die aktuelle Anzahl von Kanälen an.  In Nucleus SE wird der Rückgabewert während der Erstellungsphase festgelegt und kann nicht geändert werden. <br><br>  <b><i>Fordern Sie einen Kanalzähler in Nucleus RTOS an</i></b> <br>  Prototyp eines Serviceabrufs: <br><br>  <b>UNSIGNED NU_Established_Pipes (VOID);</b> <br><br>  Parameter: <br>  Sind abwesend. <br><br>  Rückgabewert: <br>  Die Anzahl der im System erstellten Kanäle. <br><br>  <b><i>Fordern Sie einen Kanalzähler in Nucleus SE an</i></b> <br>  Dieser Dienstprogrammaufruf unterstützt die Kernfunktionalität der Nucleus RTOS-API <br><br>  Prototyp eines Serviceabrufs: <br>  <b>U8 NUSE_Pipe_Count (void);</b> <br><br>  Parameter: <br>  Sind abwesend. <br><br>  Rückgabewert: <br>  Die Anzahl der in der Anwendung konfigurierten Kanäle. <br><br>  <b><i>Implementierung eines Kanalzählers in Nucleus SE</i></b> <br>  Die Implementierung dieses API-Aufrufs ist recht einfach: Der Wert des Symbols <b>#define</b> <b>NUSE_PIPE_NUMBER</b> wird <b>zurückgegeben</b> . <br><br><h2>  Datenstrukturen </h2><br>  Kanäle verwenden sechs oder sieben Datenstrukturen (entweder im RAM oder im ROM), die (wie andere Nucleus SE-Objekte) eine Reihe von Tabellen sind, deren Größe und Anzahl der Anzahl der konfigurierten Kanäle und ihrer Parameter entspricht. <br><br>  Ich empfehle dringend, dass der Anwendungscode keinen direkten Zugriff auf diese Datenstrukturen verwendet, sondern über die bereitgestellten API-Funktionen auf sie verweist.  Dies vermeidet Inkompatibilität mit zukünftigen Versionen von Nucleus SE und unerwünschte Nebenwirkungen und vereinfacht die Portierung von Anwendungen auf Nucleus RTOS.  Das Folgende ist eine detaillierte Übersicht über Datenstrukturen, um das Verständnis von Serviceabruf- und Debugging-Code zu vereinfachen. <br><br><h3>  Kerneldaten im RAM </h3><br>  Diese Daten haben folgende Struktur: <br><br>  <b>NUSE_Pipe_Head []</b> ist ein Array von Zeigern vom Typ <b>U8</b> , die einen Eintrag für jeden konfigurierten Kanal haben und den Beginn des Nachrichtenkanals angeben.  Wird als Adressindex in <b>NUSE_Pipe_Data [] verwendet</b> (siehe unten). <br>  <b>NUSE_Pipe_Tail []</b> ist ein <b>U8-</b> Array, das einen Eintrag für jeden konfigurierten Kanal hat und auf das Ende des Nachrichtenkanals zeigt.  Wird als Adressindex in <b>NUSE_Pipe_Data [] verwendet</b> (siehe unten). <br>  <b>NUSE_Pipe_Items []</b> ist ein Array vom Typ <b>U8</b> , das einen Eintrag für jeden konfigurierten Kanal hat und ein Zähler für die aktuelle Anzahl von Nachrichten im Kanal ist.  Diese Daten sind redundant, da dieser Wert über die Kanalstart- und -endindizes erhalten werden kann, das Vorhandensein eines Zählers jedoch den Code vereinfacht. <br>  <b>NUSE_Pipe_Blocking_Count []</b> - Dieses Array vom Typ <b>U8</b> enthält Zähler für die Anzahl der blockierten Aufgaben auf jedem Kanal.  Dieses Array wird nur erstellt, wenn die Unterstützung für Task-Sperren aktiviert ist. <br><br>  Alle diese Datenstrukturen werden beim <b>Start von</b> Nucleus SE von der Funktion <b>NUSE_Init_Pipe ()</b> mit Nullen initialisiert.  Dies ist logisch, da alle Kanäle leer (nicht verwendet) erstellt werden.  Einer der folgenden Artikel enthält eine vollständige Beschreibung der Startvorgänge für Nucleus SE. <br><br>  Im Folgenden sind die Definitionen dieser Datenstrukturen in der Datei <b>nuse_init.c aufgeführt</b> : <br><br><pre> <code class="plaintext hljs">RAM U8 NUSE_Pipe_Head[NUSE_PIPE_NUMBER]; RAM U8 NUSE_Pipe_Tail[NUSE_PIPE_NUMBER]; RAM U8 NUSE_Pipe_Items[NUSE_PIPE_NUMBER]; #if NUSE_BLOCKING_ENABLE RAM U8 NUSE_Pipe_Blocking_Count[NUSE_PIPE_NUMBER]; #endif</code> </pre><br><h3>  RAM-Benutzerdaten </h3><br>  Es liegt in der Verantwortung des Benutzers, einen Datenbereich im RAM bereitzustellen, um die Daten jedes konfigurierten Kanals zu speichern.  Die Größe dieses Bereichs sollte ein Array vom Typ <b>U8 enthalten</b> , in das alle Kanalnachrichten passen. <br><br><h3>  ROM-Daten </h3><br>  Die Struktur dieser Daten ist wie folgt: <br><br>  <b>NUSE_Pipe_Data []</b> ist ein Array vom Typ <b>ADDR</b> , das einen Datensatz für jeden konfigurierten Kanal enthält und den Datenbereich jedes Kanals angibt (siehe Abschnitt "Benutzerdaten im RAM" oben). <br>  <b>NUSE_Pipe_Size []</b> ist ein Array vom Typ <b>U8</b> , das einen Eintrag für jeden konfigurierten Kanal hat und die Anzahl der Nachrichten <b>anzeigt</b> , die in jeden Kanal passen können. <br>  <b>NUSE_Pipe_Message_Size []</b> ist ein Array vom Typ <b>U8</b> , das einen Datensatz für jeden konfigurierten Kanal enthält und die Größe der Nachrichten (in Byte) anzeigt, die auf jedem Kanal platziert werden können. <br><br>  Diese Datenstrukturen werden (statisch) in der Datei <b>nuse_config.c</b> deklariert und initialisiert. <br><br><pre> <code class="plaintext hljs">ROM ADDR *NUSE_Pipe_Data[NUSE_PIPE_NUMBER] = { /* addresses of pipe data areas ------ */ }; ROM U8 NUSE_Pipe_Size[NUSE_PIPE_NUMBER] = { /* pipe sizes ------ */ }; ROM U8 NUSE_Pipe_Message_Size[NUSE_PIPE_NUMBER] = { /* pipe message sizes ------ */ };</code> </pre><br><h3>  Kanalspeicher </h3><br>  Wie bei allen anderen Nucleus SE-Kernobjekten ist die für die Kanäle benötigte Speichermenge vorhersehbar. <br><br>  Die Datenmenge im ROM (in Bytes) für alle Kanäle in der Anwendung kann wie folgt berechnet werden: <br><br>  <b>NUSE_PIPE_NUMBER * (Größe von (ADDR) + 2)</b> <br><br>  Die Menge der Kerneldaten im RAM (in Byte) für alle Anwendungskanäle, wenn Aufgaben aktiviert sind, kann wie folgt berechnet werden: <br><br>  <b>NUSE_PIPE_NUMBER * 4</b> <br><br>  Sonst: <br><br>  <b>NUSE_PIPE_NUMBER * 3</b> <br><br>  Die Menge der Benutzerdaten im RAM (in Byte) für den Kanal mit dem <b>Pipe-</b> Index: <br><br>  <b>NUSE_Pipe_Size [Pipe] * NUSE_Pipe_Message_Size [Pipe]</b> <br><br><h2>  Nicht realisierte API-Aufrufe </h2><br>  Vier Nucleus RTOS API-Serviceaufrufe sind in Nucleus SE nicht implementiert. <br><br><h3>  Kanalerstellung </h3><br>  Dieser API-Aufruf erstellt einen Kanal.  Nucleus SE benötigt dies nicht, da die Kanäle statisch erstellt werden. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NU_Create_Pipe (NU_PIPE * Pipe, CHAR * Name, VOID * Start_Adresse, UNSIGNED Pipe_Size, OPTION Nachrichtentyp, UNSIGNED Nachricht_Größe, OPTION Suspend_Typ);</b> <br><br>  Parameter: <br><br>  <b>Pipe</b> - ein Zeiger auf den vom Benutzer bereitgestellten Kanalsteuerungsblock, der in anderen API-Aufrufen als Hauptkanalaktivator verwendet wird; <br>  <b>name</b> - Zeiger auf einen 7-stelligen Kanalnamen mit einer abschließenden Null; <br>  <b>start_address</b> - Kanalstartadresse; <br>  <b>pipe_size</b> - die Gesamtzahl der Bytes im Kanal; <br>  <b>Nachrichtentyp</b> - Nachrichtentyp, der vom Kanal unterstützt wird.  Es kann die Werte <b>NU_FIXED_SIZE</b> oder <b>NU_VARIABLE_SIZE annehmen</b> . <br>  <b>message_size</b> - Wenn der Kanal Nachrichten mit fester Länge unterstützt, gibt dieser Parameter die genaue Größe jeder Nachricht an.  Wenn der Kanal Nachrichten mit variabler Länge unterstützt, ist dieser Wert die maximale Nachrichtengröße. <br>  <b>suspend_type</b> - Gibt den Typ der Task-Suspendierung auf dem Kanal an.  Es kann die Werte <b>NU_FIFO</b> und <b>NU_PRIORITY</b> (FIFO-Scheduler bzw. PRIORITY-Scheduler) annehmen. <br><br>  Rückgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_PIPE</b> - Nullzeiger auf die Kanalsteuereinheit ( <b>NULL</b> ) oder die Steuereinheit wird bereits verwendet; <br>  <b>NU_INVALID_MEMORY</b> - In <b>start_address wurde</b> ein falscher Datenbereich angegeben. <br>  <b>NU_INVALID_MESSAGE</b> - ungültiger Parameter <b>message_type</b> ; <br>  <b>NU_INVALID_SIZE</b> - Entweder ist die Nachrichtengröße größer als die <b>Kanalgröße</b> oder die Kanal- oder Nachrichtengröße ist Null. <br>  <b>NU_INVALID_SUSPEND</b> - ungültiger <b>suspend_type-</b> Parameter. <br><br><h3>  Kanal löschen </h3><br>  Dieser API-Aufruf löscht einen zuvor erstellten Kanal.  Nucleus SE benötigt es nicht, da die Kanäle statisch erstellt werden und nicht gelöscht werden können. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Delete_Pipe (NU_PIPE * -Pipe);</b> <br><br>  Parameter: <br>  <b>Pipe</b> - ein Zeiger auf einen Kanalsteuerblock. <br><br>  Rückgabewert: <br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_PIPE</b> - ungültiger <b>Kanalzeiger</b> . <br><br><h3>  Kanalzeiger </h3><br>  Dieser API-Aufruf erstellt eine sequentielle Liste von Zeigern auf alle Kanäle im System.  In Nucleus SE ist dies nicht erforderlich, da die Kanäle durch einen einfachen Index und nicht durch einen Zeiger identifiziert werden. Daher wäre eine solche Funktion redundant. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>UNSIGNED NU_Pipe_Pointers (NU_PIPE ** Zeigerliste, UNSIGNED Maximum_Pointers);</b> <br><br>  Parameter: <br>  <b>pointer_list</b> - Ein Zeiger auf ein Array von <b>NU_PIPE-</b> Zeigern.  Dieses Array wird mit Zeigern auf zuvor erstellte Kanäle im System gefüllt. <br>  <b>Maximale Zeiger</b> - Die maximale Anzahl von Zeigern im Array. <br><br>  Rückgabewert: <br>  Die Anzahl der <b>NU_PIPE-</b> Zeiger im Array <br><br><h3>  Auf einen Kanal senden </h3><br>  Dieser API-Aufruf leitet die Nachricht an alle Aufgaben weiter, die auf Nachrichten von einem bestimmten Kanal warten.  In Nucleus SE wurde diese Funktion nicht implementiert, da sie die redundante Komplexität erhöht. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Broadcast_To_Pipe (NU_PIPE * -Pipe, VOID * -Nachricht, UNSIGNED-Größe, UNSIGNED-Suspend);</b> <br><br>  Parameter: <br>  <b>Pipe</b> - ein Zeiger auf einen Kanalsteuerblock; <br>  <b>Nachricht</b> - Zeiger auf die übertragene Nachricht; <br>  <b>Größe</b> - Die Anzahl der nicht <b>signierten</b> Datenelemente in der Nachricht.  Wenn der Kanal Nachrichten mit variabler Länge unterstützt, muss dieser Parameter gleich oder kleiner als die Größe der vom Kanal unterstützten Nachricht sein.  Wenn der Kanal Nachrichten mit fester Länge unterstützt, muss dieser Parameter genau der Größe der vom Kanal unterstützten Nachrichten entsprechen. <br>  <b>suspend</b> - Gibt an, ob die aufrufende Aufgabe angehalten werden soll, wenn der Kanal bereits voll ist.  <b>Dies</b> kann <b>NU_NO_SUSPEND</b> , <b>NU_SUSPEND</b> oder ein Timeout-Wert sein. <br><br>  Rückgabewert: <br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_PIPE</b> - ungültiger Zeiger auf den Kanal; <br>  <b>NU_INVALID_POINTER</b> - Nullzeiger auf eine Nachricht ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> - Die angegebene Nachrichtengröße ist nicht mit der beim Erstellen des Kanals angegebenen Nachrichtengröße kompatibel. <br>  <b>NU_INVALID_SUSPEND</b> - Versuch, einen nicht aufgabenbezogenen Thread auszusetzen; <br>  <b>NU_PIPE_FULL</b> - Im Kanal ist nicht genügend Platz für die Nachricht vorhanden. <br>  <b>NU_TIMEOUT</b> - Der Kanal ist auch nach Ablauf der angegebenen Zeitspanne noch voll. <br>  <b>NU_PIPE_DELETED</b> - Der Kanal wurde gelöscht, während die Aufgabe angehalten wurde. <br>  <b>NU_PIPE_RESET</b> - Der Kanal wurde zurückgesetzt, während die Aufgabe angehalten wurde. <br><br><h2>  Nucleus RTOS-kompatibel </h2><br>  Wie bei allen anderen Nucleus SE-Objekten war es mein Ziel, die Kompatibilität des Anwendungscodes mit Nucleus RTOS zu maximieren.  Kanäle sind keine Ausnahme und werden aus Sicht des Benutzers auf die gleiche Weise wie in Nucleus RTOS implementiert.  Es gibt auch eine gewisse Inkompatibilität, die ich für akzeptabel hielt, da der Code dadurch verständlicher und effizienter in Bezug auf den erforderlichen Speicher wird.  Andernfalls können Nucleus RTOS-API-Aufrufe fast direkt auf Nucleus SE portiert werden. <br><br><h3>  Objektkennungen </h3><br>  In Nucleus RTOS werden alle Objekte durch eine Datenstruktur (Steuerblock) beschrieben, die einen bestimmten Datentyp hat.  Ein Zeiger auf diese Steuereinheit dient als Kanalkennung.  Ich entschied, dass in Nucleus SE ein anderer Ansatz für die effiziente Nutzung des Speichers erforderlich ist: Alle Kernelobjekte werden durch eine Reihe von Tabellen im RAM und / oder ROM beschrieben.  Die Größe dieser Tabellen wird durch die Anzahl der konfigurierten Objekte jedes Typs bestimmt.  Die Kennung eines bestimmten Objekts ist der Index in dieser Tabelle.  Also habe ich <b>NUSE_PIPE</b> als das Äquivalent von <b>U8 definiert</b> , eine Variable (kein Zeiger) dieses Typs dient als Kanal-ID.  Diese leichte Inkompatibilität ist leicht zu handhaben, wenn der Code von Nucleus SE nach Nucleus RTOS und umgekehrt portiert wird.  In der Regel werden keine anderen Operationen an Objektkennungen als Verschieben und Speichern ausgeführt. <br><br>  Nucleus RTOS unterstützt auch die Kanalbenennung.  Diese Namen werden nur zum Debuggen verwendet.  Ich habe sie von Nucleus SE ausgeschlossen, um Speicherplatz zu sparen. <br><br><h3>  Nachrichtengröße und -typ </h3><br>  In Nucleus RTOS kann ein Kanal so konfiguriert werden, dass er Nachrichten verarbeitet, die aus einer beliebigen Anzahl von Bytes bestehen, genau wie Nucleus SE.  Nucleus RTOS unterstützt auch Nachrichtenkanäle variabler Länge, für die zum Zeitpunkt der Erstellung nur die maximale Nachrichtengröße angegeben wird.  Nachrichten mit variabler Länge werden in Nucleus SE nicht unterstützt. <br><br><h3>  Kanalgröße </h3><br>  In Nucleus SE beträgt die maximale Anzahl von Nachrichten pro Kanal 256, da alle Variablen und Konstanten vom Typ <b>U8 sind</b> .  Nucleuts RTOS unterliegt keinen solchen Einschränkungen. <br><br><h3>  Nicht realisierte API-Aufrufe </h3><br>  Nucleus RTOS unterstützt zehn Kanal-Overheads.  Vier davon sind in Nucleus SE nicht implementiert.  Eine ausführliche Beschreibung dieser Aufrufe sowie die Gründe für diese Entscheidung finden Sie im Abschnitt "Nicht realisierte API-Aufrufe" weiter oben in diesem Artikel. <br><br>  Im folgenden Artikel werden wir die Systemzeit betrachten. <br><br>  <b>Über den Autor:</b> Colin Walls ist seit über dreißig Jahren in der Elektronikindustrie tätig und widmet sich die meiste Zeit der Firmware.  Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics).  Colin Walls spricht häufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier Bücher über Firmware.  Lebt in Großbritannien.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Colins</a> professioneller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog</a> , E-Mail: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433374/">https://habr.com/ru/post/de433374/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433364/index.html">LDraw + Unity. Wie ich Lego generiert habe</a></li>
<li><a href="../de433366/index.html">Arbeiten mit externen Ressourcen in Unity3D</a></li>
<li><a href="../de433368/index.html">Wie man das Denken von Lebensmitteln auf die Welt anwendet: ein Beispiel für ein Sweatshirt</a></li>
<li><a href="../de433370/index.html">Sharding-Theorie</a></li>
<li><a href="../de433372/index.html">Auto Fahrrad</a></li>
<li><a href="../de433376/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 21: Datenverfolgung, Teil 1</a></li>
<li><a href="../de433378/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 21: Datenverfolgung, Teil 2</a></li>
<li><a href="../de433380/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 21: Datenverfolgung, Teil 3</a></li>
<li><a href="../de433382/index.html">[Illustriert] Leitfaden zum Networking in Kubernetes. Teil 3</a></li>
<li><a href="../de433384/index.html">Unsere persönlichen Daten werden immer noch dreist verkauft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>