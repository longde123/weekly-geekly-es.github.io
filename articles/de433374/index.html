<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•É üë®üèº‚Äçüîß üëáüèø Die ganze Wahrheit √ºber RTOS. Artikel Nr. 26. Kan√§le: Nebendienstleistungen und Datenstrukturen ‚≠êÔ∏è üíÆ üêö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werden wir weiterhin Daten√ºbertragungskan√§le betrachten. 

 Channel Support Services 
 Nucleus RTOS verf√ºgt √ºber vier API-Aufrufe, d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit √ºber RTOS. Artikel Nr. 26. Kan√§le: Nebendienstleistungen und Datenstrukturen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433374/"><img src="https://habrastorage.org/webt/ok/ll/ke/okllkejturanltd2yqnjeofmqxu.jpeg"><br><br>  In diesem Artikel werden wir weiterhin Daten√ºbertragungskan√§le betrachten. <br><br><h2>  Channel Support Services </h2><br>  Nucleus RTOS verf√ºgt √ºber vier API-Aufrufe, die zus√§tzliche Funktionen f√ºr Kan√§le bereitstellen: Zur√ºcksetzen eines Kanals, Empfangen von Kanalinformationen, Abrufen der Anzahl der Kan√§le in einer Anwendung und Abrufen von Zeigern auf alle Kan√§le in einer Anwendung.  Die ersten drei Funktionen sind in Nucleus SE implementiert. <br><a name="habracut"></a><br>  Fr√ºhere Artikel in der Reihe: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 25.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenkan√§le: Einf√ºhrung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlangen: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlangen: Einf√ºhrung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postf√§cher: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postf√§cher: Einf√ºhrung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Einf√ºhrung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Hilfsdienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Einf√ºhrung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Signale</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherpartitionen: Dienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherbereiche: Einf√ºhrung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabendatenstrukturen und nicht unterst√ºtzte API-Aufrufe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstleistungen f√ºr die Arbeit mit Aufgaben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben: Konfiguration und Einf√ºhrung in die API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Erweiterte Funktionen und Kontexterhaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einf√ºhrung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einf√ºhrung.</a> <br><br><h3>  Kanal zur√ºckgesetzt </h3><br>  Dieser API-Aufruf setzt den Kanal auf seinen urspr√ºnglichen, nicht verwendeten Zustand zur√ºck.  Alle darin gespeicherten Nachrichten gehen verloren.  Alle auf dem Kanal angehaltenen Aufgaben werden mit dem R√ºckkehrcode <b>NUSE_PIPE_WAS_RESET fortgesetzt</b> . <br><br>  <b><i>Kanal-Reset-Aufruf in Nucleus RTOS</i></b> <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NU_Reset_Pipe (NU_PIPE * -Pipe);</b> <br><br>  Parameter: <br><br>  <b>Pipe</b> - Ein Zeiger auf einen benutzerdefinierten Kanalsteuerblock. <br><br>  R√ºckgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_PIPE</b> - ung√ºltiger <b>Kanalzeiger</b> . <br><br>  <b><i>Channel Reset Challenge in Nucleus SE</i></b> <br><br>  Dieser API-Serviceaufruf unterst√ºtzt die Kernfunktionalit√§t der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NUSE_Pipe_Reset (NUSE_PIPE-Pipe);</b> <br><br>  Parameter: <br><br>  <b>Pipe</b> ist der Index (ID) der <b>Pipe, die</b> gel√∂scht wird. <br><br>  R√ºckgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_PIPE</b> - Ung√ºltiger <b>Kanalindex</b> . <br><br>  <b><i>Implementierung des Kanalr√ºcksetzens in Nucleus SE</i></b> <br><br>  Der Code f√ºr die Funktion <b>NUSE_Pipe_Reset ()</b> (nach √úberpr√ºfung der Parameter) ist ziemlich einfach.  Die Start- und Endindizes des Kanals sowie der Nachrichtenz√§hler im Kanal werden auf 0 gesetzt. <br><br>  Wenn die Task-Sperre aktiviert ist, ist zus√§tzlicher Code f√ºr die Wiederherstellung angehaltener Tasks verantwortlich: <br><br><pre><code class="plaintext hljs">while (NUSE_Pipe_Blocking_Count[pipe] != 0) { U8 index; /* check whether any tasks are blocked */ /* on this pipe */ for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_PIPE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == pipe)) { NUSE_Task_Blocking_Return[index] = NUSE_PIPE_RESET; NUSE_Task_Status[index] = NUSE_READY; break; } } NUSE_Pipe_Blocking_Count[pipe]--; } #if NUSE_SCHEDULER_TYPE == NUSE_PRIORITY_SCHEDULER NUSE_Reschedule(NUSE_NO_TASK); #endif</code> </pre> <br>  Jeder auf dem Kanal angehaltenen Aufgabe wird der Status "Bereit" mit dem R√ºckkehrcode <b>NUSE_PIPE_WAS_RESET zugewiesen</b> .  Nach Abschluss dieses Vorgangs wird bei Verwendung des Priorit√§tsplaners die Funktion <b>NUSE_Reschedule () aufgerufen</b> , da eine oder mehrere Aufgaben mit hoher Priorit√§t zur Ausf√ºhrung bereit sein k√∂nnen. <br><br><h3>  Kanalinfo </h3><br>  Dieser Serviceabruf gibt Kanalinformationen zur√ºck.  Die Implementierung dieses Aufrufs in Nucleus SE unterscheidet sich von Nucleus RTOS darin, dass weniger Informationen zur√ºckgegeben werden.  Dies liegt daran, dass Objektnamen, Nachrichten mit variabler L√§nge und die Reihenfolge der Aufgabenpausen in Nucleus SE nicht unterst√ºtzt werden und die Aufgabenpause deaktiviert werden kann. <br><br>  <b><i>Rufen Sie Kanalinformationen in Nucleus RTOS an</i></b> <br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NU_Pipe_Information (NU_PIPE * Pipe, CHAR * Name, VOID ** Startadresse, UNSIGNED * Pipe_size, UNSIGNED * verf√ºgbar, UNSIGNED * Nachrichten, OPTION * Nachrichtentyp, UNSIGNED * Nachrichtengr√∂√üe, OPTION * Suspend_Typ, UNSIGNED * Aufgaben_waask;</b> <br><br>  Parameter: <br><br>  <b>Pipe</b> - Zeiger auf den vom Benutzer bereitgestellten Kanalsteuerblock; <br>  <b>name</b> - Zeiger auf den 8-stelligen Bereich f√ºr den Kanalnachrichtennamen; <br>  <b>start_address</b> - ein Zeiger auf einen Zeiger, in den die Adresse des Anfangs des <b>Kanaldatenbereichs</b> geschrieben wird; <br>  <b>pipe_size</b> - ein Zeiger auf eine Variable zum Speichern der Gesamtzahl der Bytes im Kanal; <br>  <b>verf√ºgbar</b> - Zeiger auf eine Variable zum Speichern der Anzahl der verf√ºgbaren Bytes im Kanal; <br>  <b>Nachrichten</b> - ein Zeiger auf eine Variable zum Speichern der Anzahl von Nachrichten im Kanal; <br>  <b>message_type</b> - Ein Zeiger auf eine Variable zum Speichern des vom Kanal unterst√ºtzten Nachrichtentyps.  Es kann die Werte <b>NU_FIXED_SIZE</b> und <b>NU_VARIABLE_SIZE annehmen</b> . <br>  <b>message_size</b> - Zeiger auf eine Variable zum Speichern der Anzahl von Bytes in jeder <b>Kanalnachricht</b> .  Wenn der Kanal Nachrichten mit variabler L√§nge unterst√ºtzt, ist diese Nummer die maximale Nachrichtengr√∂√üe. <br>  <b>suspend_type</b> - Ein Zeiger auf eine Variable zum Speichern des Typs der Suspend-Task.  Es kann die Werte <b>NU_FIFO</b> und <b>NU_PRIORITY annehmen</b> . <br>  <b>task_waiting</b> - ein Zeiger auf eine Variable zum Speichern der Anzahl der auf diesem Kanal angehaltenen Aufgaben; <br>  <b>first_task</b> - Ein Zeiger auf einen Zeiger auf die erste angehaltene Aufgabe. <br><br>  R√ºckgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_PIPE</b> - ung√ºltiger <b>Kanalzeiger</b> . <br><br>  <b><i>Kanalinformationen in Nucleus SE anfordern</i></b> <br>  Dieser API-Aufruf unterst√ºtzt die Kernfunktionalit√§t der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NUSE_Pipe_Information (NUSE_PIPE-Pipe, ADDR * Startadresse, U8 * Pipe-Gr√∂√üe, U8 * verf√ºgbar, U8 * Nachrichten, U8 * Nachrichtengr√∂√üe, U8 * Aufgaben warten, NUSE_TASK * first_task);</b> <br><br>  Parameter: <br><br>  <b>Pipe</b> - Index des Kanals, Informationen dar√ºber, welche angefordert werden; <br>  <b>start_address</b> - Zeiger auf eine Variable vom Typ <b>ADDR</b> zum Speichern der Adresse des Anfangs des <b>Kanaldatenbereichs</b> ; <br>  <b>pipe_size</b> - ein Zeiger auf eine Variable vom Typ <b>U8</b> zum Speichern der Gesamtzahl der Nachrichten, die der Kanal empfangen kann; <br>  <b>verf√ºgbar</b> - ein Zeiger auf eine Variable vom Typ <b>U8</b> zum Speichern der Anzahl der Nachrichten, f√ºr die im Kanal noch freier Speicherplatz vorhanden ist; <br>  <b>Nachrichten</b> - ein Zeiger auf eine Variable vom Typ <b>U8</b> zum Speichern der aktuellen Anzahl von Nachrichten im Kanal; <br>  <b>message_size</b> - Zeiger auf eine Variable vom Typ <b>U8</b> zum Speichern der Gr√∂√üe der von diesem Kanal verarbeiteten Nachrichten; <br>  <b>task_waiting</b> - ein Zeiger auf eine Variable zum Speichern der Anzahl der auf diesem Kanal angehaltenen Aufgaben (nichts wird zur√ºckgegeben, wenn die Aufgabe angehalten ist); <br>  <b>first_task</b> - Ein Zeiger auf eine Variable vom Typ <b>NUSE_TASK</b> , die den Index der ersten angehaltenen Aufgabe √ºbernimmt (nichts wird zur√ºckgegeben, wenn die Aufgabe angehalten ist). <br><br>  R√ºckgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_PIPE</b> - ung√ºltiger <b>Kanalindex</b> ; <br>  <b>NUSE_INVALID_POINTER</b> - Ein oder mehrere <b>Zeigerparameter</b> sind falsch. <br><br>  <b><i>Implementieren von Kanalinformationen in Nucleus SE</i></b> <br><br>  Die Implementierung dieses API-Aufrufs ist ziemlich einfach: <br><br><pre> <code class="plaintext hljs">*start_address = NUSE_Pipe_Data[pipe]; *pipe_size = NUSE_Pipe_Size[pipe]; *available = NUSE_Pipe_Size[pipe] - NUSE_Pipe_Items[pipe]; *messages = NUSE_Pipe_Items[pipe]; *message_size = NUSE_Pipe_Message_Size[pipe]; #if NUSE_BLOCKING_ENABLE *tasks_waiting = NUSE_Pipe_Blocking_Count[pipe]; if (NUSE_Pipe_Blocking_Count[pipe] != 0) { U8 index; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_PIPE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == pipe)) { *first_task = index; break; } } } else { *first_task = 0; } #else *tasks_waiting = 0; *first_task = 0; #endif</code> </pre><br>  Die Funktion gibt den Status des Kanals zur√ºck.  Wenn dann Task-Sperren aktiviert sind, werden die Anzahl der ausstehenden Tasks und der Index der ersten zur√ºckgegeben (andernfalls werden diese beiden Parameter auf 0 gesetzt). <br><br><h3>  Abrufen der Anzahl der Kan√§le </h3><br>  Dieser Serviceabruf gibt die Anzahl der in der Anwendung konfigurierten Kan√§le zur√ºck.  In Nucleus RTOS kann sich dieser Wert im Laufe der Zeit √§ndern, und der R√ºckgabewert gibt die aktuelle Anzahl von Kan√§len an.  In Nucleus SE wird der R√ºckgabewert w√§hrend der Erstellungsphase festgelegt und kann nicht ge√§ndert werden. <br><br>  <b><i>Fordern Sie einen Kanalz√§hler in Nucleus RTOS an</i></b> <br>  Prototyp eines Serviceabrufs: <br><br>  <b>UNSIGNED NU_Established_Pipes (VOID);</b> <br><br>  Parameter: <br>  Sind abwesend. <br><br>  R√ºckgabewert: <br>  Die Anzahl der im System erstellten Kan√§le. <br><br>  <b><i>Fordern Sie einen Kanalz√§hler in Nucleus SE an</i></b> <br>  Dieser Dienstprogrammaufruf unterst√ºtzt die Kernfunktionalit√§t der Nucleus RTOS-API <br><br>  Prototyp eines Serviceabrufs: <br>  <b>U8 NUSE_Pipe_Count (void);</b> <br><br>  Parameter: <br>  Sind abwesend. <br><br>  R√ºckgabewert: <br>  Die Anzahl der in der Anwendung konfigurierten Kan√§le. <br><br>  <b><i>Implementierung eines Kanalz√§hlers in Nucleus SE</i></b> <br>  Die Implementierung dieses API-Aufrufs ist recht einfach: Der Wert des Symbols <b>#define</b> <b>NUSE_PIPE_NUMBER</b> wird <b>zur√ºckgegeben</b> . <br><br><h2>  Datenstrukturen </h2><br>  Kan√§le verwenden sechs oder sieben Datenstrukturen (entweder im RAM oder im ROM), die (wie andere Nucleus SE-Objekte) eine Reihe von Tabellen sind, deren Gr√∂√üe und Anzahl der Anzahl der konfigurierten Kan√§le und ihrer Parameter entspricht. <br><br>  Ich empfehle dringend, dass der Anwendungscode keinen direkten Zugriff auf diese Datenstrukturen verwendet, sondern √ºber die bereitgestellten API-Funktionen auf sie verweist.  Dies vermeidet Inkompatibilit√§t mit zuk√ºnftigen Versionen von Nucleus SE und unerw√ºnschte Nebenwirkungen und vereinfacht die Portierung von Anwendungen auf Nucleus RTOS.  Das Folgende ist eine detaillierte √úbersicht √ºber Datenstrukturen, um das Verst√§ndnis von Serviceabruf- und Debugging-Code zu vereinfachen. <br><br><h3>  Kerneldaten im RAM </h3><br>  Diese Daten haben folgende Struktur: <br><br>  <b>NUSE_Pipe_Head []</b> ist ein Array von Zeigern vom Typ <b>U8</b> , die einen Eintrag f√ºr jeden konfigurierten Kanal haben und den Beginn des Nachrichtenkanals angeben.  Wird als Adressindex in <b>NUSE_Pipe_Data [] verwendet</b> (siehe unten). <br>  <b>NUSE_Pipe_Tail []</b> ist ein <b>U8-</b> Array, das einen Eintrag f√ºr jeden konfigurierten Kanal hat und auf das Ende des Nachrichtenkanals zeigt.  Wird als Adressindex in <b>NUSE_Pipe_Data [] verwendet</b> (siehe unten). <br>  <b>NUSE_Pipe_Items []</b> ist ein Array vom Typ <b>U8</b> , das einen Eintrag f√ºr jeden konfigurierten Kanal hat und ein Z√§hler f√ºr die aktuelle Anzahl von Nachrichten im Kanal ist.  Diese Daten sind redundant, da dieser Wert √ºber die Kanalstart- und -endindizes erhalten werden kann, das Vorhandensein eines Z√§hlers jedoch den Code vereinfacht. <br>  <b>NUSE_Pipe_Blocking_Count []</b> - Dieses Array vom Typ <b>U8</b> enth√§lt Z√§hler f√ºr die Anzahl der blockierten Aufgaben auf jedem Kanal.  Dieses Array wird nur erstellt, wenn die Unterst√ºtzung f√ºr Task-Sperren aktiviert ist. <br><br>  Alle diese Datenstrukturen werden beim <b>Start von</b> Nucleus SE von der Funktion <b>NUSE_Init_Pipe ()</b> mit Nullen initialisiert.  Dies ist logisch, da alle Kan√§le leer (nicht verwendet) erstellt werden.  Einer der folgenden Artikel enth√§lt eine vollst√§ndige Beschreibung der Startvorg√§nge f√ºr Nucleus SE. <br><br>  Im Folgenden sind die Definitionen dieser Datenstrukturen in der Datei <b>nuse_init.c aufgef√ºhrt</b> : <br><br><pre> <code class="plaintext hljs">RAM U8 NUSE_Pipe_Head[NUSE_PIPE_NUMBER]; RAM U8 NUSE_Pipe_Tail[NUSE_PIPE_NUMBER]; RAM U8 NUSE_Pipe_Items[NUSE_PIPE_NUMBER]; #if NUSE_BLOCKING_ENABLE RAM U8 NUSE_Pipe_Blocking_Count[NUSE_PIPE_NUMBER]; #endif</code> </pre><br><h3>  RAM-Benutzerdaten </h3><br>  Es liegt in der Verantwortung des Benutzers, einen Datenbereich im RAM bereitzustellen, um die Daten jedes konfigurierten Kanals zu speichern.  Die Gr√∂√üe dieses Bereichs sollte ein Array vom Typ <b>U8 enthalten</b> , in das alle Kanalnachrichten passen. <br><br><h3>  ROM-Daten </h3><br>  Die Struktur dieser Daten ist wie folgt: <br><br>  <b>NUSE_Pipe_Data []</b> ist ein Array vom Typ <b>ADDR</b> , das einen Datensatz f√ºr jeden konfigurierten Kanal enth√§lt und den Datenbereich jedes Kanals angibt (siehe Abschnitt "Benutzerdaten im RAM" oben). <br>  <b>NUSE_Pipe_Size []</b> ist ein Array vom Typ <b>U8</b> , das einen Eintrag f√ºr jeden konfigurierten Kanal hat und die Anzahl der Nachrichten <b>anzeigt</b> , die in jeden Kanal passen k√∂nnen. <br>  <b>NUSE_Pipe_Message_Size []</b> ist ein Array vom Typ <b>U8</b> , das einen Datensatz f√ºr jeden konfigurierten Kanal enth√§lt und die Gr√∂√üe der Nachrichten (in Byte) anzeigt, die auf jedem Kanal platziert werden k√∂nnen. <br><br>  Diese Datenstrukturen werden (statisch) in der Datei <b>nuse_config.c</b> deklariert und initialisiert. <br><br><pre> <code class="plaintext hljs">ROM ADDR *NUSE_Pipe_Data[NUSE_PIPE_NUMBER] = { /* addresses of pipe data areas ------ */ }; ROM U8 NUSE_Pipe_Size[NUSE_PIPE_NUMBER] = { /* pipe sizes ------ */ }; ROM U8 NUSE_Pipe_Message_Size[NUSE_PIPE_NUMBER] = { /* pipe message sizes ------ */ };</code> </pre><br><h3>  Kanalspeicher </h3><br>  Wie bei allen anderen Nucleus SE-Kernobjekten ist die f√ºr die Kan√§le ben√∂tigte Speichermenge vorhersehbar. <br><br>  Die Datenmenge im ROM (in Bytes) f√ºr alle Kan√§le in der Anwendung kann wie folgt berechnet werden: <br><br>  <b>NUSE_PIPE_NUMBER * (Gr√∂√üe von (ADDR) + 2)</b> <br><br>  Die Menge der Kerneldaten im RAM (in Byte) f√ºr alle Anwendungskan√§le, wenn Aufgaben aktiviert sind, kann wie folgt berechnet werden: <br><br>  <b>NUSE_PIPE_NUMBER * 4</b> <br><br>  Sonst: <br><br>  <b>NUSE_PIPE_NUMBER * 3</b> <br><br>  Die Menge der Benutzerdaten im RAM (in Byte) f√ºr den Kanal mit dem <b>Pipe-</b> Index: <br><br>  <b>NUSE_Pipe_Size [Pipe] * NUSE_Pipe_Message_Size [Pipe]</b> <br><br><h2>  Nicht realisierte API-Aufrufe </h2><br>  Vier Nucleus RTOS API-Serviceaufrufe sind in Nucleus SE nicht implementiert. <br><br><h3>  Kanalerstellung </h3><br>  Dieser API-Aufruf erstellt einen Kanal.  Nucleus SE ben√∂tigt dies nicht, da die Kan√§le statisch erstellt werden. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NU_Create_Pipe (NU_PIPE * Pipe, CHAR * Name, VOID * Start_Adresse, UNSIGNED Pipe_Size, OPTION Nachrichtentyp, UNSIGNED Nachricht_Gr√∂√üe, OPTION Suspend_Typ);</b> <br><br>  Parameter: <br><br>  <b>Pipe</b> - ein Zeiger auf den vom Benutzer bereitgestellten Kanalsteuerungsblock, der in anderen API-Aufrufen als Hauptkanalaktivator verwendet wird; <br>  <b>name</b> - Zeiger auf einen 7-stelligen Kanalnamen mit einer abschlie√üenden Null; <br>  <b>start_address</b> - Kanalstartadresse; <br>  <b>pipe_size</b> - die Gesamtzahl der Bytes im Kanal; <br>  <b>Nachrichtentyp</b> - Nachrichtentyp, der vom Kanal unterst√ºtzt wird.  Es kann die Werte <b>NU_FIXED_SIZE</b> oder <b>NU_VARIABLE_SIZE annehmen</b> . <br>  <b>message_size</b> - Wenn der Kanal Nachrichten mit fester L√§nge unterst√ºtzt, gibt dieser Parameter die genaue Gr√∂√üe jeder Nachricht an.  Wenn der Kanal Nachrichten mit variabler L√§nge unterst√ºtzt, ist dieser Wert die maximale Nachrichtengr√∂√üe. <br>  <b>suspend_type</b> - Gibt den Typ der Task-Suspendierung auf dem Kanal an.  Es kann die Werte <b>NU_FIFO</b> und <b>NU_PRIORITY</b> (FIFO-Scheduler bzw. PRIORITY-Scheduler) annehmen. <br><br>  R√ºckgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_PIPE</b> - Nullzeiger auf die Kanalsteuereinheit ( <b>NULL</b> ) oder die Steuereinheit wird bereits verwendet; <br>  <b>NU_INVALID_MEMORY</b> - In <b>start_address wurde</b> ein falscher Datenbereich angegeben. <br>  <b>NU_INVALID_MESSAGE</b> - ung√ºltiger Parameter <b>message_type</b> ; <br>  <b>NU_INVALID_SIZE</b> - Entweder ist die Nachrichtengr√∂√üe gr√∂√üer als die <b>Kanalgr√∂√üe</b> oder die Kanal- oder Nachrichtengr√∂√üe ist Null. <br>  <b>NU_INVALID_SUSPEND</b> - ung√ºltiger <b>suspend_type-</b> Parameter. <br><br><h3>  Kanal l√∂schen </h3><br>  Dieser API-Aufruf l√∂scht einen zuvor erstellten Kanal.  Nucleus SE ben√∂tigt es nicht, da die Kan√§le statisch erstellt werden und nicht gel√∂scht werden k√∂nnen. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Delete_Pipe (NU_PIPE * -Pipe);</b> <br><br>  Parameter: <br>  <b>Pipe</b> - ein Zeiger auf einen Kanalsteuerblock. <br><br>  R√ºckgabewert: <br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_PIPE</b> - ung√ºltiger <b>Kanalzeiger</b> . <br><br><h3>  Kanalzeiger </h3><br>  Dieser API-Aufruf erstellt eine sequentielle Liste von Zeigern auf alle Kan√§le im System.  In Nucleus SE ist dies nicht erforderlich, da die Kan√§le durch einen einfachen Index und nicht durch einen Zeiger identifiziert werden. Daher w√§re eine solche Funktion redundant. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>UNSIGNED NU_Pipe_Pointers (NU_PIPE ** Zeigerliste, UNSIGNED Maximum_Pointers);</b> <br><br>  Parameter: <br>  <b>pointer_list</b> - Ein Zeiger auf ein Array von <b>NU_PIPE-</b> Zeigern.  Dieses Array wird mit Zeigern auf zuvor erstellte Kan√§le im System gef√ºllt. <br>  <b>Maximale Zeiger</b> - Die maximale Anzahl von Zeigern im Array. <br><br>  R√ºckgabewert: <br>  Die Anzahl der <b>NU_PIPE-</b> Zeiger im Array <br><br><h3>  Auf einen Kanal senden </h3><br>  Dieser API-Aufruf leitet die Nachricht an alle Aufgaben weiter, die auf Nachrichten von einem bestimmten Kanal warten.  In Nucleus SE wurde diese Funktion nicht implementiert, da sie die redundante Komplexit√§t erh√∂ht. <br><br>  Prototyp eines Serviceabrufs: <br>  <b>STATUS NU_Broadcast_To_Pipe (NU_PIPE * -Pipe, VOID * -Nachricht, UNSIGNED-Gr√∂√üe, UNSIGNED-Suspend);</b> <br><br>  Parameter: <br>  <b>Pipe</b> - ein Zeiger auf einen Kanalsteuerblock; <br>  <b>Nachricht</b> - Zeiger auf die √ºbertragene Nachricht; <br>  <b>Gr√∂√üe</b> - Die Anzahl der nicht <b>signierten</b> Datenelemente in der Nachricht.  Wenn der Kanal Nachrichten mit variabler L√§nge unterst√ºtzt, muss dieser Parameter gleich oder kleiner als die Gr√∂√üe der vom Kanal unterst√ºtzten Nachricht sein.  Wenn der Kanal Nachrichten mit fester L√§nge unterst√ºtzt, muss dieser Parameter genau der Gr√∂√üe der vom Kanal unterst√ºtzten Nachrichten entsprechen. <br>  <b>suspend</b> - Gibt an, ob die aufrufende Aufgabe angehalten werden soll, wenn der Kanal bereits voll ist.  <b>Dies</b> kann <b>NU_NO_SUSPEND</b> , <b>NU_SUSPEND</b> oder ein Timeout-Wert sein. <br><br>  R√ºckgabewert: <br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_PIPE</b> - ung√ºltiger Zeiger auf den Kanal; <br>  <b>NU_INVALID_POINTER</b> - Nullzeiger auf eine Nachricht ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> - Die angegebene Nachrichtengr√∂√üe ist nicht mit der beim Erstellen des Kanals angegebenen Nachrichtengr√∂√üe kompatibel. <br>  <b>NU_INVALID_SUSPEND</b> - Versuch, einen nicht aufgabenbezogenen Thread auszusetzen; <br>  <b>NU_PIPE_FULL</b> - Im Kanal ist nicht gen√ºgend Platz f√ºr die Nachricht vorhanden. <br>  <b>NU_TIMEOUT</b> - Der Kanal ist auch nach Ablauf der angegebenen Zeitspanne noch voll. <br>  <b>NU_PIPE_DELETED</b> - Der Kanal wurde gel√∂scht, w√§hrend die Aufgabe angehalten wurde. <br>  <b>NU_PIPE_RESET</b> - Der Kanal wurde zur√ºckgesetzt, w√§hrend die Aufgabe angehalten wurde. <br><br><h2>  Nucleus RTOS-kompatibel </h2><br>  Wie bei allen anderen Nucleus SE-Objekten war es mein Ziel, die Kompatibilit√§t des Anwendungscodes mit Nucleus RTOS zu maximieren.  Kan√§le sind keine Ausnahme und werden aus Sicht des Benutzers auf die gleiche Weise wie in Nucleus RTOS implementiert.  Es gibt auch eine gewisse Inkompatibilit√§t, die ich f√ºr akzeptabel hielt, da der Code dadurch verst√§ndlicher und effizienter in Bezug auf den erforderlichen Speicher wird.  Andernfalls k√∂nnen Nucleus RTOS-API-Aufrufe fast direkt auf Nucleus SE portiert werden. <br><br><h3>  Objektkennungen </h3><br>  In Nucleus RTOS werden alle Objekte durch eine Datenstruktur (Steuerblock) beschrieben, die einen bestimmten Datentyp hat.  Ein Zeiger auf diese Steuereinheit dient als Kanalkennung.  Ich entschied, dass in Nucleus SE ein anderer Ansatz f√ºr die effiziente Nutzung des Speichers erforderlich ist: Alle Kernelobjekte werden durch eine Reihe von Tabellen im RAM und / oder ROM beschrieben.  Die Gr√∂√üe dieser Tabellen wird durch die Anzahl der konfigurierten Objekte jedes Typs bestimmt.  Die Kennung eines bestimmten Objekts ist der Index in dieser Tabelle.  Also habe ich <b>NUSE_PIPE</b> als das √Ñquivalent von <b>U8 definiert</b> , eine Variable (kein Zeiger) dieses Typs dient als Kanal-ID.  Diese leichte Inkompatibilit√§t ist leicht zu handhaben, wenn der Code von Nucleus SE nach Nucleus RTOS und umgekehrt portiert wird.  In der Regel werden keine anderen Operationen an Objektkennungen als Verschieben und Speichern ausgef√ºhrt. <br><br>  Nucleus RTOS unterst√ºtzt auch die Kanalbenennung.  Diese Namen werden nur zum Debuggen verwendet.  Ich habe sie von Nucleus SE ausgeschlossen, um Speicherplatz zu sparen. <br><br><h3>  Nachrichtengr√∂√üe und -typ </h3><br>  In Nucleus RTOS kann ein Kanal so konfiguriert werden, dass er Nachrichten verarbeitet, die aus einer beliebigen Anzahl von Bytes bestehen, genau wie Nucleus SE.  Nucleus RTOS unterst√ºtzt auch Nachrichtenkan√§le variabler L√§nge, f√ºr die zum Zeitpunkt der Erstellung nur die maximale Nachrichtengr√∂√üe angegeben wird.  Nachrichten mit variabler L√§nge werden in Nucleus SE nicht unterst√ºtzt. <br><br><h3>  Kanalgr√∂√üe </h3><br>  In Nucleus SE betr√§gt die maximale Anzahl von Nachrichten pro Kanal 256, da alle Variablen und Konstanten vom Typ <b>U8 sind</b> .  Nucleuts RTOS unterliegt keinen solchen Einschr√§nkungen. <br><br><h3>  Nicht realisierte API-Aufrufe </h3><br>  Nucleus RTOS unterst√ºtzt zehn Kanal-Overheads.  Vier davon sind in Nucleus SE nicht implementiert.  Eine ausf√ºhrliche Beschreibung dieser Aufrufe sowie die Gr√ºnde f√ºr diese Entscheidung finden Sie im Abschnitt "Nicht realisierte API-Aufrufe" weiter oben in diesem Artikel. <br><br>  Im folgenden Artikel werden wir die Systemzeit betrachten. <br><br>  <b>√úber den Autor:</b> Colin Walls ist seit √ºber drei√üig Jahren in der Elektronikindustrie t√§tig und widmet sich die meiste Zeit der Firmware.  Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics).  Colin Walls spricht h√§ufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier B√ºcher √ºber Firmware.  Lebt in Gro√übritannien.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Colins</a> professioneller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog</a> , E-Mail: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433374/">https://habr.com/ru/post/de433374/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433364/index.html">LDraw + Unity. Wie ich Lego generiert habe</a></li>
<li><a href="../de433366/index.html">Arbeiten mit externen Ressourcen in Unity3D</a></li>
<li><a href="../de433368/index.html">Wie man das Denken von Lebensmitteln auf die Welt anwendet: ein Beispiel f√ºr ein Sweatshirt</a></li>
<li><a href="../de433370/index.html">Sharding-Theorie</a></li>
<li><a href="../de433372/index.html">Auto Fahrrad</a></li>
<li><a href="../de433376/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 21: Datenverfolgung, Teil 1</a></li>
<li><a href="../de433378/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 21: Datenverfolgung, Teil 2</a></li>
<li><a href="../de433380/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 21: Datenverfolgung, Teil 3</a></li>
<li><a href="../de433382/index.html">[Illustriert] Leitfaden zum Networking in Kubernetes. Teil 3</a></li>
<li><a href="../de433384/index.html">Unsere pers√∂nlichen Daten werden immer noch dreist verkauft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>