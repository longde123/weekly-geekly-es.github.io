<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòè üïë üë®‚Äçüë®‚Äçüëß‚Äçüë¶ Comment LLVM optimise la fonction ‚õîÔ∏è üë®üèª‚Äçüî¨ ‚òÉÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le compilateur d'optimisation AOT est g√©n√©ralement structur√© comme suit: 



1. frontend conversion de code source en repr√©sentation interm√©diaire 
2....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment LLVM optimise la fonction</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433598/">  Le compilateur d'optimisation AOT est g√©n√©ralement structur√© comme suit: <br><br><ol><li>  frontend conversion de code source en repr√©sentation interm√©diaire </li><li>  pipeline d'optimisation ind√©pendant de la machine (IR): une s√©quence de passes qui r√©√©crit IR pour √©liminer les sections et les structures inefficaces qui ne peuvent pas √™tre directement converties en code machine.  Parfois, cette partie est appel√©e milieu de gamme. </li><li>  Backend d√©pendant de la machine pour g√©n√©rer le code assembleur ou le code machine. </li></ol><br><img src="https://habrastorage.org/webt/dx/1k/k8/dx1kk8oxixxudiub62ffatlrpzq.jpeg"><br><br>  Dans certains compilateurs, le format IR reste inchang√© tout au long du processus d'optimisation, dans d'autres, son format ou ses modifications s√©mantiques.  Dans LLVM, le format et la s√©mantique sont fixes, et il est donc possible d'ex√©cuter des passes dans n'importe quel ordre sans risque de compilation incorrecte ou de plantages du compilateur. <br><a name="habracut"></a><br>  La s√©quence des passes d'optimisation a √©t√© d√©velopp√©e par les d√©veloppeurs du compilateur, l'objectif √©tant de terminer le travail dans un d√©lai acceptable.  Il change de temps en temps et, bien s√ªr, il existe un ensemble diff√©rent de passes √† ex√©cuter √† diff√©rents niveaux d'optimisation.  L'un des sujets √† long terme de la recherche informatique est l'utilisation de l'apprentissage automatique ou d'autres m√©thodes pour trouver le meilleur pipeline d'optimisation pour une utilisation g√©n√©rale et pour des applications sp√©cifiques pour lesquelles le pipeline par d√©faut n'est pas bien adapt√©. <br><br>  Les principes de conception des passages sont le minimalisme et l'orthogonalit√©: chaque passage doit bien faire une chose et leur fonctionnalit√© ne doit pas se chevaucher.  En pratique, des compromis sont parfois possibles.  En pratique, lorsque deux passes g√©n√®rent du travail l'une pour l'autre, elles peuvent √™tre combin√©es en une seule passe plus grande.  De plus, certaines fonctionnalit√©s de niveau IR, telles que le pliage d'op√©rateurs constants, sont si utiles qu'il est inutile de les mettre dans une passe distincte, LLVM minimise par d√©faut les op√©rations constantes lors de la cr√©ation d'une instruction. <br><br>  Dans cet article, nous verrons comment certaines optimisations LLVM fonctionnent.  Je veux dire que vous avez lu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette partie</a> sur la fa√ßon dont Clang compile la fonction ou que vous comprenez plus ou moins comment fonctionne LLVM IR.  Comprendre le formulaire SSA (assignation unique statique) est particuli√®rement utile: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wikipedia</a> vous donnera une introduction et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce livre</a> vous donnera plus d'informations que vous ne le souhaiteriez.  Lisez √©galement la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©f√©rence du langage LLVM</a> et une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">liste de passes d'optimisation</a> . <br><br>  Voyons comment Clang / LLVM 6.0.1 optimise ce code C ++: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_sorted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[i] &gt; a[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Dans le m√™me temps, nous nous souvenons que le pipeline d'optimisation est un endroit tr√®s occup√© et nous manquerons beaucoup de moments amusants, tels que: <br><br>  L'insertion est une optimisation simple mais tr√®s importante qui ne se produit pas dans cet exemple, car  nous consid√©rons une seule fonction.  Presque toutes les optimisations sp√©cifiques √† C ++, mais pas √† C. Auto-vectorisation, qui emp√™che une sortie anticip√©e de la boucle <br><br>  Dans le texte ci-dessous, je vais ignorer toutes les passes qui n'apportent aucune modification au code.  De plus, nous ne nous pencherons pas sur le backend, qui fait √©galement beaucoup de travail.  Mais m√™me les passages restants sont beaucoup!  (D√©sol√© pour les images, mais cela semble √™tre le meilleur moyen d'√©viter les difficult√©s de formatage). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici le fichier IR</a> cr√©√© par Clang (j'ai supprim√© manuellement l'attribut ¬´optnone¬ª que Clang a ins√©r√©) et la ligne de commande utilis√©e pour voir l'effet de chaque passe d'optimisation: <br><br><pre> <code class="bash hljs">opt -O2 -<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>-before-all -<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>-after-all is_sorted2.ll</code> </pre> <br>  Le premier passage est la <a href="">simplification</a> du <a href="">CFG</a> (graphe de flux de contr√¥le).  Puisque Clang n'effectue pas d'optimisation, l'IR qu'il g√©n√®re contient des options d'optimisation simples: <br><br><img src="https://habrastorage.org/webt/kn/xb/ow/knxbowtdwkjlcjaogvmo7rlzdtu.png"><br><br>  Ici, l'unit√© de base 26 se d√©place simplement vers le bloc 27. De tels blocs peuvent √™tre supprim√©s en redirigeant les r√©f√©rences vers eux par le bloc de destination.  LLVM renum√©rote automatiquement les blocs.  La liste compl√®te des conversions produites par SimplifyCFG est r√©pertori√©e en haut de l'all√©e. <br><br> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> <ul><li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> <li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> <li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> <li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> <li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> <li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> </ul> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> <br>  La plupart des opportunit√©s d'optimisation CFG apparaissent gr√¢ce au travail d'autres passes LLVM.  Par exemple, la suppression de l'√©limination du code mort et des invariants de boucles mobiles peut facilement conduire √† des blocs de base vides. <br><br>  Le passage suivant, <a href="">SROA</a> (remplacement scalaire des agr√©gats), est l'un des plus utilis√©s.  Son nom pr√™te √† confusion car SROA n'est qu'une de ses fonctions.  La passe v√©rifie chaque instruction alloca (allocation de m√©moire sur la pile de fonctions) et essaie de la convertir en registres SSA.  Une instruction alloca ( <i>c'est-√†-dire, en fait, une variable sur la pile d'</i> environ Transl.) Se transforme en plusieurs registres si elle est affect√©e statiquement plusieurs fois, et si alloca est une classe ou une structure, elle est divis√©e en composants (c'est ce qu'on appelle ¬´scalaire¬ª remplacement ¬ªmentionn√© au nom du passage).  Une version simple de SROA se rendrait pour empiler les variables pour lesquelles l'op√©ration de prise d'adresse est utilis√©e, mais la version LLVM interagit avec un algorithme d'analyse d'alias et agit de mani√®re intelligente (bien que cela ne soit pas requis dans l'exemple suivant). <br><br><img src="https://habrastorage.org/webt/d9/qp/tt/d9qpttybpemz-gxsqew6orkzlj8.png"><br><br>  Apr√®s SROA, les instructions d'allocation (et les instructions de chargement et de stockage correspondantes) disparaissent et le code devient plus propre et plus adapt√© aux optimisations suivantes (bien s√ªr, SROA ne peut pas supprimer toutes les allocations dans le cas g√©n√©ral, cela ne se produit que si l'analyse du pointeur peut se d√©barrasser compl√®tement des alias).  Dans le processus, SROA ins√®re des instructions phi dans le code.  Les instructions phi forment le c≈ìur de la repr√©sentation SSA, et le manque de phi dans le code que Clang g√©n√®re nous indique que Clang g√©n√®re une version triviale de SSA, dans laquelle les blocs de base sont connect√©s via la m√©moire et non via les registres SSA. <br><br>  Ce qui suit est ¬´ <a href="">√©limination pr√©coce de la sous-expression commune</a> ¬ª, ESC (√©limination pr√©coce des sous-expressions communes).  CSE essaie d'√©liminer les cas de sous-expressions excessives qui peuvent se produire √† la fois dans le code √©crit par l'homme et dans le code partiellement optimis√©.  ¬´Early CSE¬ª est une version rapide et facile de CSE qui identifie les calculs redondants triviaux. <br><br><img src="https://habrastorage.org/webt/zv/bk/ud/zvbkudo1n9njnkertwvr_agrkrq.png"><br><br>  Ici,% 10 et% 17 font la m√™me chose, c'est-√†-dire que le code peut √™tre r√©√©crit afin qu'une valeur soit utilis√©e et que la seconde soit supprim√©e.  Cela donne un aper√ßu des avantages de SSA: lorsque chaque registre n'est attribu√© qu'une seule fois, il n'existe pas de versions multiples d'un m√™me registre.  Ainsi, des calculs redondants peuvent √™tre d√©tect√©s en utilisant l'√©quivalence syntaxique, sans utiliser une analyse approfondie du programme (ce n'est pas le cas pour les emplacements de m√©moire qui existent en dehors du monde SSA). <br><br>  Ensuite, plusieurs passes sont lanc√©es qui n'ont aucun effet dans notre cas, puis " <a href="">l'optimiseur de variable globale</a> " est lanc√©, qui est d√©crit comme suit: <br><br> <code>     ,      .   ,        ,  ,     ,  ..</code> <br> <br>  Ce passage apporte les modifications suivantes: <br><br><img src="https://habrastorage.org/webt/pz/nd/nm/pzndnmja1jgtbkw9acxrenagtku.png"><br><br>  Il a ajout√© un attribut de fonction: les m√©tadonn√©es utilis√©es par une partie du compilateur pour stocker des informations sur ce qui pourrait √™tre utile pour une autre partie du compilateur.  Vous pouvez lire sur le but de cet attribut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Contrairement √† d'autres optimisations que nous avons consid√©r√©es, l'optimiseur de variables globales est interproc√©dural; il regarde enti√®rement le module LLVM.  Un module est (plus ou moins) l'√©quivalent d'une unit√© de compilation en C et C ++.  Contrairement √† l'optimisation interproc√©durale, l'intraproc√©dural ne voit qu'une seule fonction √† la fois. <br><br>  Le passage suivant combine des instructions et est appel√© ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">combinateur d'instructions</a> ¬ª, InstCombine.  Il s'agit d'un ensemble important et diversifi√© d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">optimisations</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">judas</a> , qui (g√©n√©ralement) r√©√©crivent certaines instructions, combin√©es par des donn√©es communes, sous une forme plus efficace.  InstCombine ne modifie pas le flux de contr√¥le d'une fonction.  Dans l'exemple ci-dessus, il n'a pas beaucoup chang√©: <br><br><img src="https://habrastorage.org/webt/ma/z2/ky/maz2ky8g_cis8kasz94_rlhzck4.png"><br><br>  Ici, au lieu de soustraire 1 de% 1, afin de calculer% 4, nous ajoutons -1.  Ce n'est pas une optimisation, mais une canonisation.  Lorsqu'il existe de nombreuses fa√ßons de faire le calcul, LLVM essaie de l'amener √† la forme canonique (souvent choisie au hasard) que les passes et les backends suivants s'attendent √† voir.  La deuxi√®me modification apport√©e par InstCombine est la forme canonique de deux op√©rations d'expansion sign√©es (l'instruction sext), qui calculent% 7 et% 11 convertis en expansion nulle (zext).  Cette conversion est s√ªre lorsque le compilateur peut prouver que l'op√©rande sext n'est pas n√©gatif.  Dans ce cas, cela est d√ª au fait que la variable de boucle passe de 0 √† n (si n est n√©gatif, la boucle ne s'ex√©cute pas du tout).  La derni√®re modification a √©t√© l'ajout de l'indicateur ¬´nuw¬ª (pas de retour √† la ligne non sign√©) √† l'instruction qui calcule% 10.  Nous pouvons voir que cela est s√ªr, du fait que (1) la variable de boucle augmente toujours et (2) si la variable commence √† z√©ro et augmente, elle deviendrait ind√©finie lorsque le signe change √† l'intersection INT_MAX avant d'atteindre un d√©bordement non sign√©, suivant UINT_MAX.  Cet indicateur peut √™tre utilis√© pour des optimisations ult√©rieures. <br><br>  Ensuite, SimplifyCFG d√©marre une deuxi√®me fois et supprime deux blocs de base vides: <br><br><img src="https://habrastorage.org/webt/oa/jj/om/oajjom0adr5es0yccpze9nnkyzs.png"><br><br>  Ensuite, le passage "D√©duire les attributs de fonction" annote la fonction: <br><br><img src="https://habrastorage.org/webt/vj/s4/dm/vjs4dmr1paqb3s0yabk6ev-ycfq.png"><br><br>  ¬´Norecurse¬ª signifie que la fonction n'est incluse dans aucun appel r√©cursif, ¬´en lecture seule¬ª signifie que la fonction ne change pas l'√©tat global.  L'attribut de param√®tre ¬´nocapture¬ª signifie que le param√®tre n'est enregistr√© nulle part apr√®s avoir quitt√© la fonction, et ¬´en lecture seule¬ª signifie que la m√©moire n'est pas modifi√©e par la fonction.  Vous pouvez voir une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">liste d'</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">attributs</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de fonction</a> et d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">attributs de param√®tre</a> . <br><br>  Ensuite, la passe ¬´ <a href="">faire tourner les boucles</a> ¬ª d√©place le code dans le but d'am√©liorer les conditions des optimisations suivantes: <br><br><img src="https://habrastorage.org/webt/fd/qm/eg/fdqmegxzophmowskfsd-wpwjkmi.png"><br><br>  Bien que la diff√©rence semble intimidante, les changements sont en fait minimes.  Nous pouvons voir ce qui s'est pass√©, d'une mani√®re plus lisible, si nous demandons √† LLVM de dessiner un graphique de transfert de contr√¥le avant et apr√®s avoir travers√© les cycles de rotation.  Voici leur vue avant (gauche) et apr√®s (droite): <br><br><img src="https://habrastorage.org/webt/ab/wb/8p/abwb8pofuvyvzu13vn278retos8.png"><br><br>  Le code d'origine suit toujours la structure de boucle g√©n√©r√©e par Clang: <br><br><pre> <code class="cpp hljs">initializer <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> COND COND: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> BODY <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> EXIT BODY: body modifier <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> COND EXIT:</code> </pre> <br>  Apr√®s l'ex√©cution, la boucle ressemble √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">initializer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(condition)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">goto</span></span></span><span class="hljs-function"> BODY </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">else</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">goto</span></span></span><span class="hljs-function"> EXIT BODY: body modifier </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(condition)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">goto</span></span></span><span class="hljs-function"> BODY </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">else</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">goto</span></span></span><span class="hljs-function"> EXIT EXIT:</span></span></code> </pre> <br>  (Les corrections propos√©es par Johannes Durfert sont list√©es ci-dessous - merci!) <br><br>  Le but de la passe de rotation de boucle est de supprimer une branche, ce qui permet d'autres optimisations.  Je n'ai pas trouv√© de meilleure description de cette conversion sur Internet. <br><br>  La passe de simplification CFG minimise deux blocs de base qui contiennent uniquement des instructions phi d√©g√©n√©r√©es (entr√©e unique): <br><br><img src="https://habrastorage.org/webt/vi/rp/tv/virptvmlal7fxobwfsagegvh9sa.png"><br><br>  La passe du combinateur d'instructions transforme ¬´% 4 = 0 s &lt;(% 1 - 1)¬ª en ¬´% 4 =% 1 s&gt; 1¬ª (o√π s &lt;et s&gt; sont des op√©rations de comparaison d'op√©randes sign√©s), ceci transformation utile, elle r√©duit la longueur des cha√Ænes de d√©pendances et peut √©galement cr√©er des instructions ¬´mortes¬ª (inaccessibles) (voir le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">patch</a> qui fait √ßa).  Cette passe supprime √©galement les instructions phi triviales qui ont √©t√© ajout√©es par la passe de rotation de boucle. <br><br><img src="https://habrastorage.org/webt/5j/ds/vd/5jdsvdbgbxm2ycakdby1q9t9stm.png"><br><br>  Ce qui suit est le passage ¬´ <a href="">canonicalize natural loops</a> ¬ª, qui est d√©crit dans son propre code source comme suit: <br><br> <code>          ,          . <br> <br>     (Loop pre-header) ,   ,      .      ,,  LICM. <br> <br>       ,   ,     (      )        (      ).   , ,  "store-sinking",   LICM. <br> <br>   ,               (backedge). <br> <br>  Indirectbr   .            ,      .    ,    ,     . <br> <br> ,   simplifycfg  ,   ,      ,         . <br> <br>  , ,  CFG,       . <br></code> <br><br>  Ici, nous voyons que le bloc de sortie a √©t√© ins√©r√©: <br><br><img src="https://habrastorage.org/webt/k_/qb/v0/k_qbv0es1zxpy7-uprkg-qc0l5y.png"><br><br>  Suit ensuite la " <a href="">simplification de la variable de boucle</a> ": <br><br> <code>       ( ,    ),    ,      . <br> <br>     ,     : <br> <br>       ,        . ,  'for (i = 7; i*i &lt; 1000; ++i)'   'for (i = 0; i != 25; ++i)'. <br> <br>          indvar        ,       .           ,     "". <br></code> <br>  L'effet de cette passe sera de changer la variable de boucle 32 bits en 64 bits: <br><br><img src="https://habrastorage.org/webt/e9/o2/ta/e9o2tabc6zwddljjzvfqxevmnlm.png"><br><br>  Je ne sais pas pourquoi zext - pr√©c√©demment converti en forme canonique √† partir du sext, est revenu √† nouveau au sext. <br><br>  Maintenant, le passage ¬´ <a href="">num√©rotation de valeur globale</a> ¬ª effectue une optimisation tr√®s intelligente.  L'une des raisons de la r√©daction de ce message est le d√©sir de le montrer.  La voyez-vous ici? <br><br><img src="https://habrastorage.org/webt/xz/w9/qz/xzw9qzzlspziaetqokxpkgeajz4.png"><br><br>  Tu as vu?  Oui, deux instructions de chargement dans la boucle de gauche, correspondant √† un [i] et un [i + 1].  Ici, le GVN a constat√© qu'un [i] n'√©tait pas n√©cessaire pour charger, car un [i + 1] d'une it√©ration de la boucle pouvait √™tre transf√©r√© √† la suivante, comme un [i].  Cette astuce simple r√©duit de moiti√© le nombre de lectures en m√©moire effectu√©es par la fonction.  LLVM et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GCC</a> n'ont appris √† effectuer cette transformation que r√©cemment. <br><br>  Vous pourriez vous demander si cette astuce fonctionnera si nous comparons un [i] avec un [i + 2].  Il s'av√®re que non, mais GCC peut allouer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jusqu'√† quatre registres</a> pour de tels cas. <br><br>  Ensuite, la passe ¬´ <a href="">√©limination du code mort de suivi des bits</a> ¬ª commence: <br><br> <code>    "Bit-Tracking Dead Code Elimination".   (,   ""  ""  ..) ""   .        ,    "" .</code> <br> <br>  Mais ici, il s'av√®re que de telles astuces ne sont pas n√©cessaires, car le seul code mort est l'instruction GEP (get element pointer), et il est trivialement mort (la passe GVN a supprim√© l'instruction de chargement qui utilisait l'adresse calcul√©e par cette instruction): <br><br><img src="https://habrastorage.org/webt/wc/ya/kp/wcyakpozeya4ntmpbtgj8e49h0u.png"><br><br>  Maintenant, l'algorithme de combinaison des instructions a plac√© add dans une autre unit√© de base.  La logique par laquelle cette transformation a √©t√© plac√©e dans InstCombine n'est pas claire pour moi, peut-√™tre qu'il n'y avait aucun endroit √©vident o√π elle pourrait √™tre plac√©e: <br><br><img src="https://habrastorage.org/webt/wl/5a/lf/wl5alf_cvrnvgdjtmrmeiqddvno.png"><br><br>  Quelque chose de plus √©trange se produit maintenant: le pass ¬´ <a href="">jump threading</a> ¬ª a supprim√© ce que le pass ¬´canonicalize natural loops¬ª a fait auparavant: <br><br><img src="https://habrastorage.org/webt/8l/qo/wj/8lqowjsprlzfgnu9w_kilkckbvc.png"><br><br>  Ensuite, nous avons √† nouveau coul√© sous la forme canonique: <br><br><img src="https://habrastorage.org/webt/-c/ax/ev/-caxev-fsfgtsrr10dhwmwizuzg.png"><br><br>  Et la simplification du CFG le transforme diff√©remment: <br><br><img src="https://habrastorage.org/webt/6m/p6/c8/6mp6c8wo3tdsj4ylu5_iuycuktc.png"><br><br>  Et retour: <br><br><img src="https://habrastorage.org/webt/yn/jm/k3/ynjmk3lrtjxek1x2tmlsbdw2sfc.png"><br><br>  Et l√† encore: <br><br><img src="https://habrastorage.org/webt/to/l2/jb/tol2jb-p3tatdxzdqpas_vsnkt0.png"><br><br>  Et retour: <br><br><img src="https://habrastorage.org/webt/xx/dd/o5/xxddo5fos6vgooq4g_mu4pvrss4.png"><br><br>  Et l√†: <br><br><img src="https://habrastorage.org/webt/nf/gp/qv/nfgpqvw4-oikia4hmkxok04vmwo.png"><br><br>  Et enfin, nous avons fini avec le Midland!  Le code √† droite est le code que nous transmettrons (dans notre cas) au backend x86-64. <br><br>  Vous pouvez √™tre curieux si les fluctuations du comportement √† la fin du pipeline sont le r√©sultat d'un bogue du compilateur, mais prenons en compte que cette fonction est tr√®s, tr√®s simple et qu'il y a beaucoup de passes impliqu√©es dans son traitement, mais je ne les ai m√™me pas mentionn√©es car elles n'a apport√© aucune modification au code.  Tout au long de la seconde moiti√© du pipeline d'optimisation, nous observons principalement des cas d√©g√©n√©r√©s pour cette fonction. <br><br>  Remerciements: certains √©tudiants de mon cours de compilateur approfondi cet automne ont laiss√© des commentaires sur une √©bauche de ce message (et j'ai √©galement utilis√© ce mat√©riel pour les devoirs).  J'ai parcouru les fonctions discut√©es ici dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce</a> bon ensemble de conf√©rences sur l'optimisation de boucle. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr433598/">https://habr.com/ru/post/fr433598/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr433582/index.html">Et si la participation aux b√©n√©fices 30/70 cesse d'√™tre une norme de d√©veloppement de jeu?</a></li>
<li><a href="../fr433586/index.html">Comment nous n'avons pas gagn√© le hackathon</a></li>
<li><a href="../fr433588/index.html">Performances incroyables des algorithmes parall√®les C ++ 17. Mythe ou r√©alit√©?</a></li>
<li><a href="../fr433592/index.html">Informations: Yandex.Phone</a></li>
<li><a href="../fr433596/index.html">L'erreur de Magellan: d√©passement de tampon ou exp√©dition autour du monde avec SQLite FTS</a></li>
<li><a href="../fr433600/index.html">Pixel 3 apprend √† d√©terminer la profondeur des photos</a></li>
<li><a href="../fr433602/index.html">La simplicit√© math√©matique peut √™tre √† l'origine de la vitesse d'√©volution.</a></li>
<li><a href="../fr433604/index.html">Travail confortable avec Android Studio</a></li>
<li><a href="../fr433606/index.html">Profondeurs SIEM: corr√©lations pr√™tes √† l'emploi. Partie 3.2. M√©thodologie de normalisation des √©v√©nements</a></li>
<li><a href="../fr433608/index.html">La voiture du futur. √âcrans au lieu de vitres automobiles?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>