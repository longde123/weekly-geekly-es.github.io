<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😏 🕑 👨‍👨‍👧‍👦 Comment LLVM optimise la fonction ⛔️ 👨🏻‍🔬 ☃️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le compilateur d'optimisation AOT est généralement structuré comme suit: 



1. frontend conversion de code source en représentation intermédiaire 
2....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment LLVM optimise la fonction</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433598/">  Le compilateur d'optimisation AOT est généralement structuré comme suit: <br><br><ol><li>  frontend conversion de code source en représentation intermédiaire </li><li>  pipeline d'optimisation indépendant de la machine (IR): une séquence de passes qui réécrit IR pour éliminer les sections et les structures inefficaces qui ne peuvent pas être directement converties en code machine.  Parfois, cette partie est appelée milieu de gamme. </li><li>  Backend dépendant de la machine pour générer le code assembleur ou le code machine. </li></ol><br><img src="https://habrastorage.org/webt/dx/1k/k8/dx1kk8oxixxudiub62ffatlrpzq.jpeg"><br><br>  Dans certains compilateurs, le format IR reste inchangé tout au long du processus d'optimisation, dans d'autres, son format ou ses modifications sémantiques.  Dans LLVM, le format et la sémantique sont fixes, et il est donc possible d'exécuter des passes dans n'importe quel ordre sans risque de compilation incorrecte ou de plantages du compilateur. <br><a name="habracut"></a><br>  La séquence des passes d'optimisation a été développée par les développeurs du compilateur, l'objectif étant de terminer le travail dans un délai acceptable.  Il change de temps en temps et, bien sûr, il existe un ensemble différent de passes à exécuter à différents niveaux d'optimisation.  L'un des sujets à long terme de la recherche informatique est l'utilisation de l'apprentissage automatique ou d'autres méthodes pour trouver le meilleur pipeline d'optimisation pour une utilisation générale et pour des applications spécifiques pour lesquelles le pipeline par défaut n'est pas bien adapté. <br><br>  Les principes de conception des passages sont le minimalisme et l'orthogonalité: chaque passage doit bien faire une chose et leur fonctionnalité ne doit pas se chevaucher.  En pratique, des compromis sont parfois possibles.  En pratique, lorsque deux passes génèrent du travail l'une pour l'autre, elles peuvent être combinées en une seule passe plus grande.  De plus, certaines fonctionnalités de niveau IR, telles que le pliage d'opérateurs constants, sont si utiles qu'il est inutile de les mettre dans une passe distincte, LLVM minimise par défaut les opérations constantes lors de la création d'une instruction. <br><br>  Dans cet article, nous verrons comment certaines optimisations LLVM fonctionnent.  Je veux dire que vous avez lu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette partie</a> sur la façon dont Clang compile la fonction ou que vous comprenez plus ou moins comment fonctionne LLVM IR.  Comprendre le formulaire SSA (assignation unique statique) est particulièrement utile: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wikipedia</a> vous donnera une introduction et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce livre</a> vous donnera plus d'informations que vous ne le souhaiteriez.  Lisez également la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">référence du langage LLVM</a> et une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">liste de passes d'optimisation</a> . <br><br>  Voyons comment Clang / LLVM 6.0.1 optimise ce code C ++: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_sorted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[i] &gt; a[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Dans le même temps, nous nous souvenons que le pipeline d'optimisation est un endroit très occupé et nous manquerons beaucoup de moments amusants, tels que: <br><br>  L'insertion est une optimisation simple mais très importante qui ne se produit pas dans cet exemple, car  nous considérons une seule fonction.  Presque toutes les optimisations spécifiques à C ++, mais pas à C. Auto-vectorisation, qui empêche une sortie anticipée de la boucle <br><br>  Dans le texte ci-dessous, je vais ignorer toutes les passes qui n'apportent aucune modification au code.  De plus, nous ne nous pencherons pas sur le backend, qui fait également beaucoup de travail.  Mais même les passages restants sont beaucoup!  (Désolé pour les images, mais cela semble être le meilleur moyen d'éviter les difficultés de formatage). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici le fichier IR</a> créé par Clang (j'ai supprimé manuellement l'attribut «optnone» que Clang a inséré) et la ligne de commande utilisée pour voir l'effet de chaque passe d'optimisation: <br><br><pre> <code class="bash hljs">opt -O2 -<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>-before-all -<span class="hljs-built_in"><span class="hljs-built_in">print</span></span>-after-all is_sorted2.ll</code> </pre> <br>  Le premier passage est la <a href="">simplification</a> du <a href="">CFG</a> (graphe de flux de contrôle).  Puisque Clang n'effectue pas d'optimisation, l'IR qu'il génère contient des options d'optimisation simples: <br><br><img src="https://habrastorage.org/webt/kn/xb/ow/knxbowtdwkjlcjaogvmo7rlzdtu.png"><br><br>  Ici, l'unité de base 26 se déplace simplement vers le bloc 27. De tels blocs peuvent être supprimés en redirigeant les références vers eux par le bloc de destination.  LLVM renumérote automatiquement les blocs.  La liste complète des conversions produites par SimplifyCFG est répertoriée en haut de l'allée. <br><br> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> <ul><li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> <li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> <li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> <li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> <li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> <li> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> </li> </ul> <code>         ,       . : <br> <br>   ,         ,           .  phi-   ,   .   ,     .   invoke  nounwind-  call  "if (x) if (y)"  "if (x&amp;y)" <br></code> <br>  La plupart des opportunités d'optimisation CFG apparaissent grâce au travail d'autres passes LLVM.  Par exemple, la suppression de l'élimination du code mort et des invariants de boucles mobiles peut facilement conduire à des blocs de base vides. <br><br>  Le passage suivant, <a href="">SROA</a> (remplacement scalaire des agrégats), est l'un des plus utilisés.  Son nom prête à confusion car SROA n'est qu'une de ses fonctions.  La passe vérifie chaque instruction alloca (allocation de mémoire sur la pile de fonctions) et essaie de la convertir en registres SSA.  Une instruction alloca ( <i>c'est-à-dire, en fait, une variable sur la pile d'</i> environ Transl.) Se transforme en plusieurs registres si elle est affectée statiquement plusieurs fois, et si alloca est une classe ou une structure, elle est divisée en composants (c'est ce qu'on appelle «scalaire» remplacement »mentionné au nom du passage).  Une version simple de SROA se rendrait pour empiler les variables pour lesquelles l'opération de prise d'adresse est utilisée, mais la version LLVM interagit avec un algorithme d'analyse d'alias et agit de manière intelligente (bien que cela ne soit pas requis dans l'exemple suivant). <br><br><img src="https://habrastorage.org/webt/d9/qp/tt/d9qpttybpemz-gxsqew6orkzlj8.png"><br><br>  Après SROA, les instructions d'allocation (et les instructions de chargement et de stockage correspondantes) disparaissent et le code devient plus propre et plus adapté aux optimisations suivantes (bien sûr, SROA ne peut pas supprimer toutes les allocations dans le cas général, cela ne se produit que si l'analyse du pointeur peut se débarrasser complètement des alias).  Dans le processus, SROA insère des instructions phi dans le code.  Les instructions phi forment le cœur de la représentation SSA, et le manque de phi dans le code que Clang génère nous indique que Clang génère une version triviale de SSA, dans laquelle les blocs de base sont connectés via la mémoire et non via les registres SSA. <br><br>  Ce qui suit est « <a href="">élimination précoce de la sous-expression commune</a> », ESC (élimination précoce des sous-expressions communes).  CSE essaie d'éliminer les cas de sous-expressions excessives qui peuvent se produire à la fois dans le code écrit par l'homme et dans le code partiellement optimisé.  «Early CSE» est une version rapide et facile de CSE qui identifie les calculs redondants triviaux. <br><br><img src="https://habrastorage.org/webt/zv/bk/ud/zvbkudo1n9njnkertwvr_agrkrq.png"><br><br>  Ici,% 10 et% 17 font la même chose, c'est-à-dire que le code peut être réécrit afin qu'une valeur soit utilisée et que la seconde soit supprimée.  Cela donne un aperçu des avantages de SSA: lorsque chaque registre n'est attribué qu'une seule fois, il n'existe pas de versions multiples d'un même registre.  Ainsi, des calculs redondants peuvent être détectés en utilisant l'équivalence syntaxique, sans utiliser une analyse approfondie du programme (ce n'est pas le cas pour les emplacements de mémoire qui existent en dehors du monde SSA). <br><br>  Ensuite, plusieurs passes sont lancées qui n'ont aucun effet dans notre cas, puis " <a href="">l'optimiseur de variable globale</a> " est lancé, qui est décrit comme suit: <br><br> <code>     ,      .   ,        ,  ,     ,  ..</code> <br> <br>  Ce passage apporte les modifications suivantes: <br><br><img src="https://habrastorage.org/webt/pz/nd/nm/pzndnmja1jgtbkw9acxrenagtku.png"><br><br>  Il a ajouté un attribut de fonction: les métadonnées utilisées par une partie du compilateur pour stocker des informations sur ce qui pourrait être utile pour une autre partie du compilateur.  Vous pouvez lire sur le but de cet attribut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Contrairement à d'autres optimisations que nous avons considérées, l'optimiseur de variables globales est interprocédural; il regarde entièrement le module LLVM.  Un module est (plus ou moins) l'équivalent d'une unité de compilation en C et C ++.  Contrairement à l'optimisation interprocédurale, l'intraprocédural ne voit qu'une seule fonction à la fois. <br><br>  Le passage suivant combine des instructions et est appelé « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">combinateur d'instructions</a> », InstCombine.  Il s'agit d'un ensemble important et diversifié d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">optimisations</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">judas</a> , qui (généralement) réécrivent certaines instructions, combinées par des données communes, sous une forme plus efficace.  InstCombine ne modifie pas le flux de contrôle d'une fonction.  Dans l'exemple ci-dessus, il n'a pas beaucoup changé: <br><br><img src="https://habrastorage.org/webt/ma/z2/ky/maz2ky8g_cis8kasz94_rlhzck4.png"><br><br>  Ici, au lieu de soustraire 1 de% 1, afin de calculer% 4, nous ajoutons -1.  Ce n'est pas une optimisation, mais une canonisation.  Lorsqu'il existe de nombreuses façons de faire le calcul, LLVM essaie de l'amener à la forme canonique (souvent choisie au hasard) que les passes et les backends suivants s'attendent à voir.  La deuxième modification apportée par InstCombine est la forme canonique de deux opérations d'expansion signées (l'instruction sext), qui calculent% 7 et% 11 convertis en expansion nulle (zext).  Cette conversion est sûre lorsque le compilateur peut prouver que l'opérande sext n'est pas négatif.  Dans ce cas, cela est dû au fait que la variable de boucle passe de 0 à n (si n est négatif, la boucle ne s'exécute pas du tout).  La dernière modification a été l'ajout de l'indicateur «nuw» (pas de retour à la ligne non signé) à l'instruction qui calcule% 10.  Nous pouvons voir que cela est sûr, du fait que (1) la variable de boucle augmente toujours et (2) si la variable commence à zéro et augmente, elle deviendrait indéfinie lorsque le signe change à l'intersection INT_MAX avant d'atteindre un débordement non signé, suivant UINT_MAX.  Cet indicateur peut être utilisé pour des optimisations ultérieures. <br><br>  Ensuite, SimplifyCFG démarre une deuxième fois et supprime deux blocs de base vides: <br><br><img src="https://habrastorage.org/webt/oa/jj/om/oajjom0adr5es0yccpze9nnkyzs.png"><br><br>  Ensuite, le passage "Déduire les attributs de fonction" annote la fonction: <br><br><img src="https://habrastorage.org/webt/vj/s4/dm/vjs4dmr1paqb3s0yabk6ev-ycfq.png"><br><br>  «Norecurse» signifie que la fonction n'est incluse dans aucun appel récursif, «en lecture seule» signifie que la fonction ne change pas l'état global.  L'attribut de paramètre «nocapture» signifie que le paramètre n'est enregistré nulle part après avoir quitté la fonction, et «en lecture seule» signifie que la mémoire n'est pas modifiée par la fonction.  Vous pouvez voir une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">liste d'</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">attributs</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de fonction</a> et d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">attributs de paramètre</a> . <br><br>  Ensuite, la passe « <a href="">faire tourner les boucles</a> » déplace le code dans le but d'améliorer les conditions des optimisations suivantes: <br><br><img src="https://habrastorage.org/webt/fd/qm/eg/fdqmegxzophmowskfsd-wpwjkmi.png"><br><br>  Bien que la différence semble intimidante, les changements sont en fait minimes.  Nous pouvons voir ce qui s'est passé, d'une manière plus lisible, si nous demandons à LLVM de dessiner un graphique de transfert de contrôle avant et après avoir traversé les cycles de rotation.  Voici leur vue avant (gauche) et après (droite): <br><br><img src="https://habrastorage.org/webt/ab/wb/8p/abwb8pofuvyvzu13vn278retos8.png"><br><br>  Le code d'origine suit toujours la structure de boucle générée par Clang: <br><br><pre> <code class="cpp hljs">initializer <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> COND COND: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> BODY <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> EXIT BODY: body modifier <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> COND EXIT:</code> </pre> <br>  Après l'exécution, la boucle ressemble à ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">initializer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(condition)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">goto</span></span></span><span class="hljs-function"> BODY </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">else</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">goto</span></span></span><span class="hljs-function"> EXIT BODY: body modifier </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(condition)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">goto</span></span></span><span class="hljs-function"> BODY </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">else</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">goto</span></span></span><span class="hljs-function"> EXIT EXIT:</span></span></code> </pre> <br>  (Les corrections proposées par Johannes Durfert sont listées ci-dessous - merci!) <br><br>  Le but de la passe de rotation de boucle est de supprimer une branche, ce qui permet d'autres optimisations.  Je n'ai pas trouvé de meilleure description de cette conversion sur Internet. <br><br>  La passe de simplification CFG minimise deux blocs de base qui contiennent uniquement des instructions phi dégénérées (entrée unique): <br><br><img src="https://habrastorage.org/webt/vi/rp/tv/virptvmlal7fxobwfsagegvh9sa.png"><br><br>  La passe du combinateur d'instructions transforme «% 4 = 0 s &lt;(% 1 - 1)» en «% 4 =% 1 s&gt; 1» (où s &lt;et s&gt; sont des opérations de comparaison d'opérandes signés), ceci transformation utile, elle réduit la longueur des chaînes de dépendances et peut également créer des instructions «mortes» (inaccessibles) (voir le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">patch</a> qui fait ça).  Cette passe supprime également les instructions phi triviales qui ont été ajoutées par la passe de rotation de boucle. <br><br><img src="https://habrastorage.org/webt/5j/ds/vd/5jdsvdbgbxm2ycakdby1q9t9stm.png"><br><br>  Ce qui suit est le passage « <a href="">canonicalize natural loops</a> », qui est décrit dans son propre code source comme suit: <br><br> <code>          ,          . <br> <br>     (Loop pre-header) ,   ,      .      ,,  LICM. <br> <br>       ,   ,     (      )        (      ).   , ,  "store-sinking",   LICM. <br> <br>   ,               (backedge). <br> <br>  Indirectbr   .            ,      .    ,    ,     . <br> <br> ,   simplifycfg  ,   ,      ,         . <br> <br>  , ,  CFG,       . <br></code> <br><br>  Ici, nous voyons que le bloc de sortie a été inséré: <br><br><img src="https://habrastorage.org/webt/k_/qb/v0/k_qbv0es1zxpy7-uprkg-qc0l5y.png"><br><br>  Suit ensuite la " <a href="">simplification de la variable de boucle</a> ": <br><br> <code>       ( ,    ),    ,      . <br> <br>     ,     : <br> <br>       ,        . ,  'for (i = 7; i*i &lt; 1000; ++i)'   'for (i = 0; i != 25; ++i)'. <br> <br>          indvar        ,       .           ,     "". <br></code> <br>  L'effet de cette passe sera de changer la variable de boucle 32 bits en 64 bits: <br><br><img src="https://habrastorage.org/webt/e9/o2/ta/e9o2tabc6zwddljjzvfqxevmnlm.png"><br><br>  Je ne sais pas pourquoi zext - précédemment converti en forme canonique à partir du sext, est revenu à nouveau au sext. <br><br>  Maintenant, le passage « <a href="">numérotation de valeur globale</a> » effectue une optimisation très intelligente.  L'une des raisons de la rédaction de ce message est le désir de le montrer.  La voyez-vous ici? <br><br><img src="https://habrastorage.org/webt/xz/w9/qz/xzw9qzzlspziaetqokxpkgeajz4.png"><br><br>  Tu as vu?  Oui, deux instructions de chargement dans la boucle de gauche, correspondant à un [i] et un [i + 1].  Ici, le GVN a constaté qu'un [i] n'était pas nécessaire pour charger, car un [i + 1] d'une itération de la boucle pouvait être transféré à la suivante, comme un [i].  Cette astuce simple réduit de moitié le nombre de lectures en mémoire effectuées par la fonction.  LLVM et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GCC</a> n'ont appris à effectuer cette transformation que récemment. <br><br>  Vous pourriez vous demander si cette astuce fonctionnera si nous comparons un [i] avec un [i + 2].  Il s'avère que non, mais GCC peut allouer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jusqu'à quatre registres</a> pour de tels cas. <br><br>  Ensuite, la passe « <a href="">élimination du code mort de suivi des bits</a> » commence: <br><br> <code>    "Bit-Tracking Dead Code Elimination".   (,   ""  ""  ..) ""   .        ,    "" .</code> <br> <br>  Mais ici, il s'avère que de telles astuces ne sont pas nécessaires, car le seul code mort est l'instruction GEP (get element pointer), et il est trivialement mort (la passe GVN a supprimé l'instruction de chargement qui utilisait l'adresse calculée par cette instruction): <br><br><img src="https://habrastorage.org/webt/wc/ya/kp/wcyakpozeya4ntmpbtgj8e49h0u.png"><br><br>  Maintenant, l'algorithme de combinaison des instructions a placé add dans une autre unité de base.  La logique par laquelle cette transformation a été placée dans InstCombine n'est pas claire pour moi, peut-être qu'il n'y avait aucun endroit évident où elle pourrait être placée: <br><br><img src="https://habrastorage.org/webt/wl/5a/lf/wl5alf_cvrnvgdjtmrmeiqddvno.png"><br><br>  Quelque chose de plus étrange se produit maintenant: le pass « <a href="">jump threading</a> » a supprimé ce que le pass «canonicalize natural loops» a fait auparavant: <br><br><img src="https://habrastorage.org/webt/8l/qo/wj/8lqowjsprlzfgnu9w_kilkckbvc.png"><br><br>  Ensuite, nous avons à nouveau coulé sous la forme canonique: <br><br><img src="https://habrastorage.org/webt/-c/ax/ev/-caxev-fsfgtsrr10dhwmwizuzg.png"><br><br>  Et la simplification du CFG le transforme différemment: <br><br><img src="https://habrastorage.org/webt/6m/p6/c8/6mp6c8wo3tdsj4ylu5_iuycuktc.png"><br><br>  Et retour: <br><br><img src="https://habrastorage.org/webt/yn/jm/k3/ynjmk3lrtjxek1x2tmlsbdw2sfc.png"><br><br>  Et là encore: <br><br><img src="https://habrastorage.org/webt/to/l2/jb/tol2jb-p3tatdxzdqpas_vsnkt0.png"><br><br>  Et retour: <br><br><img src="https://habrastorage.org/webt/xx/dd/o5/xxddo5fos6vgooq4g_mu4pvrss4.png"><br><br>  Et là: <br><br><img src="https://habrastorage.org/webt/nf/gp/qv/nfgpqvw4-oikia4hmkxok04vmwo.png"><br><br>  Et enfin, nous avons fini avec le Midland!  Le code à droite est le code que nous transmettrons (dans notre cas) au backend x86-64. <br><br>  Vous pouvez être curieux si les fluctuations du comportement à la fin du pipeline sont le résultat d'un bogue du compilateur, mais prenons en compte que cette fonction est très, très simple et qu'il y a beaucoup de passes impliquées dans son traitement, mais je ne les ai même pas mentionnées car elles n'a apporté aucune modification au code.  Tout au long de la seconde moitié du pipeline d'optimisation, nous observons principalement des cas dégénérés pour cette fonction. <br><br>  Remerciements: certains étudiants de mon cours de compilateur approfondi cet automne ont laissé des commentaires sur une ébauche de ce message (et j'ai également utilisé ce matériel pour les devoirs).  J'ai parcouru les fonctions discutées ici dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce</a> bon ensemble de conférences sur l'optimisation de boucle. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr433598/">https://habr.com/ru/post/fr433598/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr433582/index.html">Et si la participation aux bénéfices 30/70 cesse d'être une norme de développement de jeu?</a></li>
<li><a href="../fr433586/index.html">Comment nous n'avons pas gagné le hackathon</a></li>
<li><a href="../fr433588/index.html">Performances incroyables des algorithmes parallèles C ++ 17. Mythe ou réalité?</a></li>
<li><a href="../fr433592/index.html">Informations: Yandex.Phone</a></li>
<li><a href="../fr433596/index.html">L'erreur de Magellan: dépassement de tampon ou expédition autour du monde avec SQLite FTS</a></li>
<li><a href="../fr433600/index.html">Pixel 3 apprend à déterminer la profondeur des photos</a></li>
<li><a href="../fr433602/index.html">La simplicité mathématique peut être à l'origine de la vitesse d'évolution.</a></li>
<li><a href="../fr433604/index.html">Travail confortable avec Android Studio</a></li>
<li><a href="../fr433606/index.html">Profondeurs SIEM: corrélations prêtes à l'emploi. Partie 3.2. Méthodologie de normalisation des événements</a></li>
<li><a href="../fr433608/index.html">La voiture du futur. Écrans au lieu de vitres automobiles?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>