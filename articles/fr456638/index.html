<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì§ üîµ üéÆ Comparaison du m√™me projet dans Rust, Haskell, C ++, Python, Scala et OCaml üë©üèæ‚Äçü§ù‚Äçüë®üèª üñï ü§™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Au dernier semestre de l'universit√©, j'ai choisi le cours de compilateur CS444 . L√†, chaque groupe de 1 √† 3 personnes devait √©crire un compilateur √† p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comparaison du m√™me projet dans Rust, Haskell, C ++, Python, Scala et OCaml</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456638/"> Au dernier semestre de l'universit√©, j'ai choisi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le cours de compilateur CS444</a> .  L√†, chaque groupe de 1 √† 3 personnes devait √©crire un compilateur √† partir d'un sous-ensemble important de Java en x86.  Langue pour choisir un groupe.  C'√©tait une occasion rare de comparer les impl√©mentations de grands programmes de la m√™me fonctionnalit√©, √©crits par des programmeurs tr√®s comp√©tents dans diff√©rentes langues, et de comparer la diff√©rence de conception et de choix de langue.  Une telle comparaison a donn√© lieu √† de nombreuses r√©flexions int√©ressantes.  Une telle comparaison contr√¥l√©e des langues est rarement observ√©e.  Ce n'est pas parfait, mais bien mieux que la plupart des histoires subjectives sur lesquelles les opinions des gens sur les langages de programmation sont bas√©es. <br><br>  Nous avons fait notre compilateur Rust et je l'ai d'abord compar√© avec le projet de l'√©quipe Haskell.  Je m'attendais √† ce que leur programme soit beaucoup plus court, mais il s'est av√©r√© √™tre de la m√™me taille ou plus grand.  Il en va de m√™me pour OCaml.  Ensuite, je l'ai compar√© au compilateur C ++, et l√†, on s'attendait √† ce que le compilateur soit environ 30% plus grand, principalement en raison des en-t√™tes, du manque de types de somme et de la correspondance des mod√®les.  La comparaison suivante √©tait avec ma petite amie, qui a fait le compilateur seule en Python et a utilis√© moins de la moiti√© du code par rapport √† nous, en raison de la puissance de la m√©taprogrammation et des types dynamiques.  Un autre ami avait un programme Scala plus petit.  Ce qui m'a le plus surpris, c'est la comparaison avec une autre √©quipe qui utilisait √©galement Rust, mais ils se sont av√©r√©s avoir trois fois plus de code en raison de diff√©rentes d√©cisions de conception.  En fin de compte, la plus grande diff√©rence dans la quantit√© de code √©tait dans la m√™me langue! <br><a name="habracut"></a><br>  J'expliquerai pourquoi je consid√®re cela comme une bonne comparaison, je donnerai des informations sur chaque projet et expliquerai les raisons des diff√©rences de taille du compilateur.  Je tirerai √©galement des conclusions de chaque comparaison.  N'h√©sitez pas √† utiliser ces liens pour acc√©der √† la section qui vous int√©resse: <br><br><h1>  Table des mati√®res </h1><br><ul><li>  Pourquoi est-ce que je trouve cela significatif <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rouille (base de comparaison)</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Haskell</a> : tailles 1.0-1.6, selon la fa√ßon dont vous comptez, pour des raisons int√©ressantes <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C ++</a> : 1,4 tailles pour des raisons √©videntes <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Python</a> : taille 0,5 gr√¢ce √† une m√©taprogrammation sophistiqu√©e! <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rouille (un autre groupe)</a> : trois fois la taille gr√¢ce √† un design diff√©rent! <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Scala</a> : 0,7 tailles <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OCaml</a> : taille 1.0-1.6 selon la fa√ßon dont vous comptez, similaire √† Haskell </li></ul><br><h1>  Pourquoi est-ce que je trouve cela significatif </h1><br>  Avant de dire que la quantit√© de code (j'ai compar√© les cha√Ænes et les octets) est une m√©trique terrible, je tiens √† noter que dans ce cas, elle peut fournir une bonne compr√©hension.  Au moins, c'est l'exemple le plus bien contr√¥l√© o√π diff√©rentes √©quipes √©crivent le m√™me grand programme que j'ai entendu ou lu. <br><br><ul><li>  Personne (y compris moi) ne savait que je mesurerais ce param√®tre, donc personne n'a essay√© de jouer des m√©triques, tout le monde a juste essay√© de terminer le projet rapidement et correctement. <br></li><li>  Tous (√† l'exception du projet Python, dont je parlerai plus tard) ont impl√©ment√© le programme dans le seul but de r√©ussir la m√™me suite de tests automatis√©s dans le m√™me laps de temps, de sorte que les r√©sultats ne peuvent pas √™tre consid√©rablement d√©form√©s par des groupes qui r√©solvent diff√©rents probl√®mes. <br></li><li>  Le projet a √©t√© achev√© en quelques mois, avec l'√©quipe, et devait se d√©velopper progressivement et passer des tests connus et inconnus.  Cela signifie qu'il √©tait utile d'√©crire du code clair et clair. <br></li><li>  En plus de passer les tests du cours, le code ne sera utilis√© pour rien d'autre, personne ne le lira et, √©tant un compilateur pour un sous-ensemble limit√© de Java dans l'assembleur de texte, il ne sera pas utile. <br></li><li>  Aucune biblioth√®que autre que la biblioth√®que standard n'est autoris√©e et aucun assistant pour l'analyse, m√™me s'ils se trouvent dans la biblioth√®que standard.  Cela signifie que la comparaison ne peut pas √™tre fauss√©e par les biblioth√®ques de compilateur puissantes que seules certaines commandes poss√®dent. <br></li><li>  Il y avait non seulement des tests publics, mais aussi secrets.  Ils ont commenc√© une fois apr√®s la livraison finale.  Cela signifiait qu'il y avait une incitation √† √©crire votre propre code de test et √† vous assurer que le compilateur est fiable, correct et g√®re les situations de fronti√®re complexes. <br></li><li>  Bien que tous les participants soient des √©tudiants, je les consid√®re comme des programmeurs assez comp√©tents.  Chacun d'entre eux a effectu√© des stages pendant au moins deux ans, principalement dans des entreprises de haute technologie, travaillant parfois m√™me sur des compilateurs.  Presque tous programment depuis 7-13 ans et sont des passionn√©s qui lisent beaucoup sur Internet en dehors de leurs cours. <br></li><li>  Le code g√©n√©r√© n'a pas √©t√© pris en compte, mais les fichiers de grammaire et le code qui a g√©n√©r√© l'autre code ont √©t√© pris en compte. </li></ul><br>  Ainsi, je pense que la quantit√© de code fournit une compr√©hension d√©cente de combien d'efforts seront n√©cessaires pour soutenir chaque projet, s'il √©tait √† long terme.  Je pense que pas trop de diff√©rence entre les projets vous permet √©galement de r√©futer certaines d√©clarations extraordinaires que j'ai lues, par exemple, que le compilateur Haskell sera plus de la moiti√© de la taille de C ++ en raison du langage. <br><br><a name="1"></a><h1>  Rouille (base de comparaison) </h1><br>  Un de mes camarades et moi-m√™me avons √©crit plus de 10 000 lignes dans Rust plus t√¥t, et le troisi√®me coll√®gue a peut-√™tre √©crit 500 lignes sur certains hackathons.  Notre compilateur est sorti en 6806 lignes de <code>wc -l</code> , 5900 lignes de source (sans espaces et commentaires) et 220 Ko <code>wc -c</code> . <br><br>  J'ai constat√© que dans d'autres projets, ces proportions sont √† peu pr√®s respect√©es, √† quelques exceptions pr√®s, que je noterai.  Pour le reste de l'article, quand je parle de cha√Ænes ou de sommes, je veux dire <code>wc -l</code> , mais cela n'a pas d'importance (sauf si je remarque la diff√©rence), et vous pouvez convertir avec un coefficient. <br><br>  J'ai √©crit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un autre article d√©crivant notre conception</a> , qui a r√©ussi tous les tests publics et secrets.  Il contient √©galement des fonctionnalit√©s suppl√©mentaires que nous avons con√ßues pour le plaisir, pas pour passer des tests, qui ont probablement ajout√© environ 400 lignes.  Il a √©galement environ 500 lignes de nos tests unitaires. <br><br><a name="2"></a><h1>  Haskell </h1><br>  L'√©quipe Haskell comprenait deux de mes amis qui ont √©crit peut-√™tre quelques milliers de lignes de Haskell chacun, ainsi que beaucoup de contenu en ligne sur Haskell et d'autres langages fonctionnels similaires tels que OCaml et Lean.  Ils avaient un autre co√©quipier que je ne connaissais pas tr√®s bien, mais il semble qu'un programmeur fort ait utilis√© Haskell auparavant. <br><br>  Leur compilateur totalisait 9 750 lignes de <code>wc -l</code> , 357 Ko et 7777 lignes de code (SLOC).  Cette √©quipe a √©galement les seules diff√©rences significatives entre ces ratios: leur compilateur est 1,4 fois plus grand que le n√¥tre en lignes, 1,3 fois en SLOC et 1,6 fois en octets.  Ils n'ont impl√©ment√© aucune fonction suppl√©mentaire, r√©ussi 100% des tests publics et secrets. <br><br>  Il est important de noter que l'inclusion de tests a surtout affect√© cette √©quipe.  Puisqu'ils ont soigneusement abord√© l'exactitude du code, ils ont inclus 1 600 lignes de tests.  Ils ont d√©tect√© plusieurs situations limites que notre √©quipe n'a pas d√©tect√©es, mais ces cas n'ont tout simplement pas √©t√© v√©rifi√©s par des tests de cours.  Donc sans tests des deux c√¥t√©s (6,3 mille lignes contre 8,1 mille lignes) leur compilateur n'est que 30% de plus que le n√¥tre. <br><br>  Ici, j'ai tendance √† octets comme une mesure de comparaison de volume plus raisonnable, car dans un projet Haskell, en moyenne, il y a des lignes plus longues, car il n'a pas un grand nombre de lignes d'une parenth√®se fermante, et <code>rustfmt</code> ne casse pas les cha√Ænes de fonctions unifilaires en plusieurs lignes. <br><br>  Apr√®s avoir fouill√© avec l'un de mes co√©quipiers, nous avons trouv√© l'explication suivante pour cette diff√©rence: <br><br><ul><li>  Nous avons utilis√© un analyseur lexical manuscrit et une m√©thode de descente r√©cursive, et ils ont utilis√© un g√©n√©rateur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NFA</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DFA</a> et un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">analyseur LR</a> , puis une passe pour convertir l'arbre d'analyse en AST ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">arbre de syntaxe abstraite</a> , repr√©sentation plus pratique du code).  Cela leur a donn√© beaucoup plus de code: 2677 lignes par rapport √† notre 1705, soit environ 1000 lignes de plus. <br></li><li>  Ils ont utilis√© l'AST g√©n√©rique fantaisiste, qui est pass√© √† divers param√®tres de type √† mesure que plus d'informations √©taient ajout√©es √† chaque passage.  Cette fonction et d'autres fonctions d'aide √† la r√©√©criture expliquent probablement pourquoi leur code AST est environ 500 lignes plus long que notre impl√©mentation, o√π nous collectons des litt√©raux struct et mutons les champs <code>Option&lt;_&gt;</code> pour ajouter des informations au fur et √† mesure. <br></li><li>  Ils ont encore environ 400 lignes de code pendant la g√©n√©ration, qui sont principalement associ√©es √† la plus grande abstraction n√©cessaire pour g√©n√©rer et combiner le code de mani√®re purement fonctionnelle, o√π nous utilisons simplement des lignes de mutation et d'√©criture. </li></ul><br>  Ces diff√©rences plus les tests expliquent toutes les diff√©rences de volume.  En fait, nos fichiers de constantes de pliage et de r√©solution de contexte sont de taille tr√®s proche.  Mais encore, il y a une certaine diff√©rence d'octets en raison de lignes plus longues: probablement parce que plus de code est n√©cessaire pour r√©√©crire l'arborescence enti√®re √† chaque passage. <br><br>  Par cons√©quent, en mettant de c√¥t√© les d√©cisions de conception, √† mon avis, Rust et Haskell sont √©galement expressifs, peut-√™tre avec un l√©ger avantage Rust en raison de la possibilit√© d'utiliser facilement la mutation quand cela est pratique.  Il √©tait √©galement int√©ressant de savoir que mon choix de la m√©thode de descente r√©cursive et de l'analyseur lexical manuscrit √©tait payant: c'√©tait un risque qui contredisait les recommandations et les instructions du professeur, mais j'ai d√©cid√© que c'√©tait plus facile et c'√©tait juste. <br><br>  Les fans de Haskell feront valoir que cette √©quipe n'a probablement pas profit√© pleinement de Haskell, et s'ils connaissaient mieux la langue, ils auraient pu faire un projet avec moins de code.  Je suis d'accord, quelqu'un comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Edward Kmett</a> peut √©crire le m√™me compilateur en beaucoup moins.  En effet, l‚Äô√©quipe de mon ami n‚Äôa pas utilis√© beaucoup d‚Äôabstractions super-avanc√©es bizarres et de librairies combinatoires sophistiqu√©es telles que les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">objectifs</a> .  Cependant, tout cela affecte la lisibilit√© du code.  Tous les membres de l'√©quipe sont des programmeurs exp√©riment√©s, ils savaient que Haskell √©tait capable de choses tr√®s bizarres, mais ont d√©cid√© de ne pas les utiliser parce qu'ils ont d√©cid√© que les comprendre prendrait plus de temps qu'ils n'en √©conomiseraient et rendrait le code plus difficile √† comprendre pour les autres.  Cela semble √™tre un vrai compromis, et l'affirmation selon laquelle Haskell est magiquement adapt√© aux compilateurs va dans quelque chose comme "Haskell n√©cessite des comp√©tences extr√™mement √©lev√©es dans l'√©criture de compilateurs si vous ne vous souciez pas du support de code pour les personnes qui ne sont pas non plus tr√®s habiles chez Haskell." <br><br>  Il est √©galement int√©ressant de noter qu'au d√©but de chaque projet, le professeur dit que les √©tudiants peuvent utiliser n'importe quelle langue qui s'ex√©cute sur un serveur universitaire, mais avertit que les √©quipes sur Haskell sont diff√©rentes des autres: elles ont la plus grande dispersion dans les notes.  Beaucoup de gens surestiment leurs capacit√©s et les √©quipes Haskell ont les notes les plus mauvaises, bien que d'autres se d√©brouillent tr√®s bien comme mes amis. <br><br><a name="3"></a><h1>  C ++ </h1><br>  Ensuite, j'ai parl√© √† mon ami de l'√©quipe C ++.  Je ne connaissais qu'une seule personne dans cette √©quipe, mais le C ++ est utilis√© dans plusieurs cours de notre universit√©, donc probablement tout le monde dans l'√©quipe avait une exp√©rience en C ++. <br><br>  Leur projet comprenait 8733 lignes et 280 Ko, sans compter le code de test, mais comprenant environ 500 lignes de fonctions suppl√©mentaires.  Ce qui le rend 1,4 fois plus grand que notre code sans tests, qui a √©galement environ 500 lignes de fonctions suppl√©mentaires.  Ils ont r√©ussi 100% des tests publics, mais seulement 90% des tests secrets.  Vraisemblablement parce qu'ils n'ont pas impl√©ment√© les tableaux de vtables sophistiqu√©s requis par la sp√©cification, qui prennent peut-√™tre 50 √† 100 lignes de code. <br><br>  Je ne me suis pas trop plong√© dans ces diff√©rences de taille.  Je suppose que cela est principalement d√ª √†: <br><br><ul><li>  Ils utilisent l'analyseur LR et le r√©√©criveur d'arbre au lieu de la m√©thode de descente r√©cursive. <br></li><li>  Le manque de types de somme et de comparaisons de mod√®les en C ++, que nous avons largement utilis√©s et qui √©taient tr√®s utiles. <br></li><li>  La n√©cessit√© de dupliquer toutes les signatures dans les fichiers d'en-t√™te, ce qui n'est pas le cas dans Rust. </li></ul><br>  Nous avons √©galement compar√© le temps de compilation.  Sur mon ordinateur portable, la version de d√©bogage propre de notre compilateur prend 9,7 s, la version propre 12,5 s et la version de d√©bogage incr√©mentiel 3,5 s.  Mon ami n'avait pas de temps pour sa construction C ++ (en utilisant la cr√©ation parall√®le), mais il a dit que les chiffres sont similaires, avec la mise en garde qu'ils ont mis en ≈ìuvre de nombreuses petites fonctions dans les fichiers d'en-t√™te pour r√©duire la duplication des signatures au prix d'un temps plus long (√† savoir par cons√©quent, je ne peux pas mesurer la surcharge de ligne nette dans les fichiers d'en-t√™te). <br><br><a name="4"></a><h1>  Python </h1><br>  Mon ami, un tr√®s bon programmeur, a d√©cid√© de faire le projet seul en Python.  Elle a √©galement impl√©ment√© des fonctionnalit√©s plus avanc√©es (pour le plaisir) que toute autre √©quipe, y compris une vue SSA interm√©diaire avec l'allocation des registres et d'autres optimisations.  D'autre part, comme il fonctionnait seul et impl√©mentait de nombreuses fonctions suppl√©mentaires, il accordait le moins d'attention √† la qualit√© du code, par exemple, en lan√ßant des exceptions indiff√©renci√©es pour toutes les erreurs (en s'appuyant sur des traces pour le d√©bogage) au lieu d'impl√©menter des types d'erreur et des messages correspondants, comme nous. <br><br>  Son compilateur comprenait 4581 lignes et a pass√© tous les tests publics et secrets.  Elle a √©galement impl√©ment√© des fonctions plus avanc√©es que toute autre commande, mais il est difficile de d√©terminer la quantit√© de code suppl√©mentaire n√©cessaire, car la plupart des fonctions suppl√©mentaires √©taient des versions plus puissantes de choses simples que tout le monde devait impl√©menter, telles que le pliage de constantes et la g√©n√©ration de code.  Les fonctions suppl√©mentaires sont probablement de 1 000 √† 2 000 lignes, au moins, donc je suis s√ªr que son code est au moins deux fois plus expressif que le n√¥tre. <br><br>  Une grande partie de cette diff√©rence est probablement le typage dynamique.  Seulement dans nos <code>ast.rs</code> 500 lignes de d√©finitions de types et beaucoup plus de types d√©finis ailleurs dans le compilateur.  Nous sommes √©galement toujours limit√©s au syst√®me de type lui-m√™me.  Par exemple, nous avons besoin d'une infrastructure pour ajouter de mani√®re ergonomique de nouvelles informations √† l'AST au fur et √† mesure que nous passons et y acc√©dons plus tard.  En Python, vous pouvez simplement d√©finir de nouveaux champs sur les n≈ìuds AST. <br><br>  La m√©taprogrammation puissante explique √©galement une partie de la diff√©rence.  Par exemple, m√™me si elle a utilis√© un analyseur LR au lieu d'une m√©thode de descente r√©cursive, dans mon cas, je pense qu'il a fallu moins de code car au lieu de passer par une r√©√©criture d'arbre, sa grammaire LR comprenait des morceaux de code Python pour construire l'AST, que le g√©n√©rateur pourrait transformer en fonctions Python en utilisant <code>eval</code> .  Une partie de la raison pour laquelle nous n'avons pas utilis√© l'analyseur LR est parce que la construction d'un AST sans r√©√©crire l'arbre n√©cessitera beaucoup de c√©r√©monies (cr√©ation de fichiers Rust ou de macros proc√©durales) pour associer la grammaire √† des fragments de code Rust. <br><br>  Un autre exemple de la puissance de la m√©taprogrammation et de la frappe dynamique est le fichier <code>visit.rs</code> 400 lignes, qui est essentiellement un code r√©p√©titif qui impl√©mente un visiteur sur un tas de structures AST.  En Python, cela peut √™tre une fonction courte d'environ 10 lignes qui introspecte r√©cursivement les champs d'un n≈ìud AST et les visite (en utilisant l'attribut <code>__dict__</code> ). <br><br>  En tant que fan de Rust et des langages typ√©s statiquement en g√©n√©ral, je suis enclin √† noter que le syst√®me de typage est tr√®s utile pour pr√©venir les erreurs et pour les performances.  Une m√©taprogrammation inhabituelle peut √©galement rendre difficile la compr√©hension du fonctionnement du code.  Cependant, cette comparaison m'a surpris par le fait que je ne m'attendais pas √† ce que la diff√©rence dans la quantit√© de code soit si grande.  Si la diff√©rence dans son ensemble est vraiment proche d'avoir √† √©crire deux fois plus de code, je pense toujours que Rust est un compromis appropri√©, mais toujours la moiti√© du code est un argument, et √† l'avenir, j'ai tendance √† faire quelque chose en Ruby / Python si vous avez juste besoin de construire rapidement quelque chose seul, puis de le jeter. <br><br><a name="5"></a><h1>  Rouille (un autre groupe) </h1><br>  La comparaison la plus int√©ressante pour moi a √©t√© avec mon ami qui a √©galement fait un projet √† Rust avec un co√©quipier (que je ne connaissais pas).  Mon ami a eu une bonne exp√©rience de Rust.  Il a contribu√© au d√©veloppement du compilateur Rust et a beaucoup lu.  Je ne sais rien de son camarade. <br><br>  Leur projet comprenait 17 211 lignes brutes, 15 000 lignes source et 637 Ko, sans le code de test et le code g√©n√©r√©.  Il n'avait pas de fonctions suppl√©mentaires, et il n'a r√©ussi que 4 des 10 tests secrets et 90% des tests publics pour la g√©n√©ration de code, car ils n'avaient pas assez de temps avant la date limite pour impl√©menter des parties plus bizarres de la sp√©cification.  Leur programme est trois fois plus grand que le n√¥tre, √©crit dans la m√™me langue, et avec moins de fonctionnalit√©s! <br><br>  Ce r√©sultat a √©t√© vraiment incroyable pour moi et a √©clips√© toutes les diff√©rences entre les langues que j'ai √©tudi√©es jusqu'√† pr√©sent.  Par cons√©quent, nous avons compar√© les listes de tailles de fichiers <code>wc -l</code> , et v√©rifi√© √©galement comment chacun de nous a impl√©ment√© certaines choses sp√©cifiques qui ont entra√Æn√© des tailles de code diff√©rentes. <br><br>  Il semble que tout se r√©sume √† l'adoption coh√©rente de diverses d√©cisions de conception.  Par exemple, leur interface (analyse lexicale, analyse, cr√©ation d'AST) prend 7597 lignes par rapport √† notre 2164. Ils ont utilis√© l'analyseur lexical DFA et l'analyseur LALR (1), mais d'autres groupes ont fait des choses similaires sans trop de code.  En regardant leur dossier de d√©sherbeur, j'ai remarqu√© un certain nombre de d√©cisions de conception qui √©taient diff√©rentes des n√¥tres: <br><br><ul><li>  Ils ont d√©cid√© d'utiliser un arbre d'analyse enti√®rement typ√© au lieu d'un arbre d'analyse standard, uniforme et bas√© sur des cha√Ænes.  Cela n√©cessitait probablement beaucoup plus de d√©finitions de types et de code de conversion suppl√©mentaire au stade de l'analyse ou un analyseur plus complexe. <br></li><li>  Ils ont utilis√© des impl√©mentations de <code>tryfrom</code> tryfrom pour convertir entre les types d'arbre d'analyse et les types AST pour les valider.  Cela conduit √† de nombreux blocs d' <code>impl</code> 10-20 lignes.  Pour ce faire, nous avons utilis√© des fonctions qui renvoient des types de <code>Result</code> , ce qui g√©n√®re moins de lignes, et nous lib√®re √©galement un peu de la structure de type, simplifiant le param√©trage et la r√©utilisation.  Certaines des choses qui, pour nous, √©taient des branches de <code>match</code> seule ligne, avaient des blocs <code>impl</code> 10 lignes. <br></li><li>  Nos types sont structur√©s pour r√©duire le copier-coller.  Par exemple, ils ont utilis√© des champs s√©par√©s <code>is_abstract</code> , <code>is_native</code> et <code>is_static</code> , o√π le code de v√©rification des contraintes a d√ª √™tre copi√© deux fois: une fois pour les m√©thodes de type vide et une fois pour les m√©thodes de type retour, avec de l√©g√®res modifications.  Alors que notre <code>void</code> n'√©tait qu'un type sp√©cial, nous avons trouv√© une taxonomie de modificateurs avec <code>mode</code> et <code>visibility</code> qui appliquait des contraintes de niveau type, et des erreurs de contrainte √©taient g√©n√©r√©es par d√©faut pour l'op√©rateur de correspondance, ce qui traduisait les ensembles de modificateurs en <code>mode</code> et <code>visibility</code> . </li></ul><br>  Je n'ai pas regard√© le code des passes de l'analyse de leur compilateur, mais ils sont aussi super.  J'ai parl√© avec mon ami, et il semble qu'ils n'aient pas mis en place quelque chose de similaire √† l'infrastructure des visiteurs, comme la n√¥tre.  Je suppose que, avec quelques autres diff√©rences de conception plus petites, explique la diff√©rence de taille de cette pi√®ce.  Le visiteur permet √† nos passes d'analyse de se concentrer uniquement sur les parties de l'AST dont elles ont besoin, plut√¥t que de faire correspondre le mod√®le √† l'ensemble de la structure de l'AST.  Cela √©conomise beaucoup de code. <br><br>  Leur partie pour la g√©n√©ration de code se compose de 3594 lignes, et la n√¥tre - 1560. J'ai regard√© leur code et il semble que presque toute la diff√©rence est qu'ils ont choisi une structure de donn√©es interm√©diaire pour les instructions d'assembleur, o√π nous avons simplement utilis√© le formatage de cha√Æne pour la sortie directe de l'assembleur .  Ils devaient d√©finir des types et des fonctions de sortie pour toutes les instructions et tous les types d'op√©randes utilis√©s.  Cela signifiait √©galement que la construction des instructions d'assemblage prenait plus de code.  L√† o√π nous avions un op√©rateur de format avec des instructions courtes, comme <code>mov ecx, [edx]</code> , ils avaient besoin d'un op√©rateur g√©ant <code>rustfmt</code> , divis√© en 6 lignes, qui a construit une instruction avec un tas de types imbriqu√©s interm√©diaires pour les op√©randes qui incluent jusqu'√† 6 niveaux de crochets imbriqu√©s.  Nous pourrions √©galement produire des blocs d'instructions connexes, comme un pr√©ambule de fonction, dans une instruction de format unique, o√π ils devaient sp√©cifier la construction compl√®te de chaque instruction. <br><br>  Notre √©quipe envisageait d'utiliser une abstraction comme la leur.  Il √©tait plus facile de produire un assemblage de texte ou d'√©mettre directement du code machine, mais ce n'√©tait pas une exigence du cours.  La m√™me chose pourrait √™tre faite avec moins de code et de meilleures performances en utilisant le <code>X86Writer</code> X86Writer avec des m√©thodes comme <code>push(reg: Register)</code> .  Nous avons √©galement pris en compte que cela pourrait simplifier le d√©bogage et les tests, mais nous avons r√©alis√© que la visualisation de l'assembleur de texte g√©n√©r√© est en fait plus facile √† lire et √† tester √† l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tests de clich√©s</a> , si vous ins√©rez des commentaires g√©n√©reusement.  Mais nous (apparemment correctement) avons pr√©dit que cela prendrait beaucoup de code suppl√©mentaire, et il n'y avait aucun avantage r√©el, √©tant donn√© nos besoins r√©els, nous ne nous sommes donc pas inqui√©t√©s. <br><br>  Il est bon de comparer cela avec la repr√©sentation interm√©diaire que l'√©quipe C ++ a utilis√©e comme fonction suppl√©mentaire, ce qui ne leur a pris que 500 lignes suppl√©mentaires.  Ils ont utilis√© une structure tr√®s simple (pour les d√©finitions de types simples et le code de construction) qui utilisait des op√©rations proches de celles requises par Java.  Cela signifiait que leur repr√©sentation interm√©diaire √©tait beaucoup plus petite (et n√©cessitait donc moins de code de construction) que l'assembleur r√©sultant, car de nombreuses op√©rations de langage, telles que les appels et les transtypages, ont √©t√© d√©velopp√©es dans de nombreuses instructions d'assembleur.  Ils disent √©galement que cela a vraiment aid√© le d√©bogage, car cela a √©limin√© beaucoup de d√©chets et am√©lior√© la lisibilit√©.  Une pr√©sentation de niveau sup√©rieur a √©galement permis de faire quelques optimisations simples sur leur repr√©sentation interm√©diaire.  L'√©quipe C ++ a trouv√© un tr√®s bon design qui leur a fait beaucoup plus de bien avec beaucoup moins de code. <br><br>  En g√©n√©ral, il semble que la raison commune de la triple diff√©rence de volume soit due √† l'adoption coh√©rente de diverses d√©cisions de conception, grandes et petites, dans le sens de plus de code.  Ils ont impl√©ment√© un certain nombre d'abstractions, ce que nous n'avons pas fait - ils ont ajout√© plus de code et ignor√© certaines de nos abstractions, ce qui r√©duit la quantit√© de code. <br><br>  Ce r√©sultat m'a vraiment surpris.  Je savais que les d√©cisions de conception √©taient importantes, mais je n'aurais pas devin√© √† l'avance qu'elles entra√Æneraient des diff√©rences de cette taille, √©tant donn√© que je n'ai examin√© que des personnes que je consid√®re comme de bons programmeurs comp√©tents.  De tous les r√©sultats de comparaison, c'est le plus significatif pour moi. ,  ,      ,   ,      ,     ,        ,   AST    ,        . <br><br>      ‚Äî   .            ,       ,             ,                .       :   ,       ,     . ,     ,     ,    ,    ,       .        ,   ,           (,    C++),     . <br><br>       :  ,   ,    ,    ,   ,   ,    ,   . <br><br><a name="6"></a><h1> Scala </h1><br>     ,        Scala,        .     4141   ~160  ,   .   8  10    100%        .  ,     5906      ,     30%. <br><br>            .          LR.    ,   .         LR.       LR   150-  Python,   -  Java,     ,       .       -   Scala,       1073      1443,                . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le reste de leur compilateur √©tait √©galement plus petit que le n√¥tre, sans grandes diff√©rences de conception √©videntes, m√™me si je ne me suis pas plong√© dans le code. </font><font style="vertical-align: inherit;">Je soup√ßonne que cela est d√ª √† des diff√©rences dans l'expressivit√© de Scala et de Rust. </font><font style="vertical-align: inherit;">Scala et Rust ont des fonctionnalit√©s de programmation similaires utiles pour les compilateurs, telles que la correspondance de mod√®les, mais la m√©moire g√©r√©e de Scala enregistre le code n√©cessaire pour que le v√©rificateur d'emprunt fonctionne dans Rust. </font><font style="vertical-align: inherit;">De plus, Scala a un sucre syntaxique plus vari√© que Rust.</font></font><br><br><a name="7"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> OCaml </font></font></h1><br>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jane Street</a> (    ‚Äî . .),           Jane Street,       OCaml. <br><br>    10914   377 ,         .   9/10      . <br><br>    , ,            LR-   ,     regex-&gt;NFA-&gt;DFA   .   ( ,  ,  AST)  5548 ,   ‚Äî 2164,     .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> ,     snapshot-,       ,      ~600    ,   ‚Äî  200. <br><br>       5366    (461    ‚Äî     )  4642  ,    15%,     ,    ,   . , ,       , Rust  OCaml   ,   ,  OCaml   ,  Rust ‚Äî . <br><br><h1>  Conclusion </h1><br>     ,    ,       . ,     ,       ,  ,    ,        . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr456638/">https://habr.com/ru/post/fr456638/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr456622/index.html">Comment cr√©er un OS certifi√© selon la protection de classe I</a></li>
<li><a href="../fr456624/index.html">Outils Python utiles</a></li>
<li><a href="../fr456630/index.html">Pr√©sentation d'Airflow pour g√©rer les Spark Jobs √† ivi: espoirs et b√©quilles</a></li>
<li><a href="../fr456632/index.html">Nous construisons le quatri√®me √©tage des mod√®les C ++ dans RESTinio. Pourquoi et comment?</a></li>
<li><a href="../fr456634/index.html">Recettes Nginx: CAS (Central Authorization Service)</a></li>
<li><a href="../fr456640/index.html">Analyse du concours d'intelligence √©conomique √† PHDays 9</a></li>
<li><a href="../fr456642/index.html">La premi√®re remise des dipl√¥mes du programme JetBrains Corporate Master et ITMO University</a></li>
<li><a href="../fr456644/index.html">Une imprimante photo-polym√®re 3D √† bas prix plus longue appara√Æt sur Kickstarter</a></li>
<li><a href="../fr456646/index.html">Indulgence - comment se d√©barrasser de la dette pour les t√¢ches</a></li>
<li><a href="../fr456650/index.html">Choisir un oscilloscope de poche √©conomique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>