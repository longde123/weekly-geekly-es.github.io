<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ûï üßô üïì JavaScript-Ausf√ºhrungskontext und Aufrufstapel üöé üçê üëÉüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie ein JavaScript-Entwickler sind oder einer werden m√∂chten, bedeutet dies, dass Sie die internen Mechanismen zum Ausf√ºhren von JS-Code verstehe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript-Ausf√ºhrungskontext und Aufrufstapel</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/422089/">  Wenn Sie ein JavaScript-Entwickler sind oder einer werden m√∂chten, bedeutet dies, dass Sie die internen Mechanismen zum Ausf√ºhren von JS-Code verstehen m√ºssen.  Insbesondere ein Verst√§ndnis des Ausf√ºhrungskontexts und des Aufrufstapels ist unbedingt erforderlich, um andere JavaScript-Konzepte zu beherrschen, z. B. das Erh√∂hen von Variablen, den Umfang und das Schlie√üen.  Das Material, dessen √úbersetzung wir heute ver√∂ffentlichen, ist dem Ausf√ºhrungskontext und dem Aufrufstapel in JavaScript gewidmet. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/bz/v7/-r/bzv7-r-dgsdl8xuatbnagrxzcqy.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Ausf√ºhrungskontext</font> </h2><br>  Der Ausf√ºhrungskontext ist vereinfacht ausgedr√ºckt ein Konzept, das die Umgebung beschreibt, in der JavaScript-Code ausgef√ºhrt wird.  Code wird immer in einem Kontext ausgef√ºhrt. <br><br><h3>  <font color="#3AC1EF">‚ñç F√ºhren Sie Kontexttypen aus</font> </h3><br>  JavaScript hat drei Arten von Ausf√ºhrungskontexten: <br><br><ul><li> Globaler Ausf√ºhrungskontext.  Dies ist der grundlegende Standardausf√ºhrungskontext.  Wenn sich ein Code nicht in einer Funktion befindet, geh√∂rt dieser Code zum globalen Kontext.  Der globale Kontext ist durch das Vorhandensein eines globalen Objekts gekennzeichnet, das im Fall des Browsers das <code>window</code> ist, und durch die Tatsache, dass das <code>this</code> this auf dieses globale Objekt verweist.  Ein Programm kann nur einen globalen Kontext haben. </li><li>  Funktionsausf√ºhrungskontext.  Jedes Mal, wenn eine Funktion aufgerufen wird, wird ein neuer Kontext daf√ºr erstellt.  Jede Funktion hat ihren eigenen Ausf√ºhrungskontext.  Ein Programm kann gleichzeitig viele Kontexte zum Ausf√ºhren von Funktionen haben.  Beim Erstellen eines neuen Kontexts f√ºr die Ausf√ºhrung einer Funktion werden eine bestimmte Abfolge von Schritten durchlaufen, die im Folgenden erl√§utert werden. </li><li>  Der Ausf√ºhrungskontext der <code>eval</code> .  Code, der innerhalb der <code>eval</code> Funktion ausgef√ºhrt wird, hat auch einen eigenen Ausf√ºhrungskontext.  Die <code>eval</code> wird jedoch sehr selten verwendet, daher werden wir hier nicht auf diesen Ausf√ºhrungskontext eingehen. </li></ul><br><h2>  <font color="#3AC1EF">Ausf√ºhrungsstapel</font> </h2><br>  Der Ausf√ºhrungsstapel, der auch als Aufrufstapel bezeichnet wird, ist der LIFO-Stapel, der zum Speichern von Ausf√ºhrungskontexten verwendet wird, die w√§hrend der Codeausf√ºhrung erstellt wurden. <br><br>  Wenn die JS-Engine mit der Verarbeitung des Skripts beginnt, erstellt die Engine einen globalen Ausf√ºhrungskontext und platziert ihn auf dem aktuellen Stapel.  Wenn ein Befehl zum Aufrufen einer Funktion erkannt wird, erstellt die Engine einen neuen Ausf√ºhrungskontext f√ºr diese Funktion und platziert ihn oben auf dem Stapel. <br><br>  Die Engine f√ºhrt eine Funktion aus, deren Ausf√ºhrungskontext sich oben im Stapel befindet.  Wenn die Funktion abgeschlossen ist, wird ihr Kontext aus dem Stapel entfernt und die Steuerung wird in den Kontext √ºbertragen, der sich im vorherigen Element des Stapels befindet. <br><br>  Wir werden diese Idee anhand des folgenden Beispiels untersuchen: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">first</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Inside first function'</span></span>); second(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Again inside first function'</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">second</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Inside second function'</span></span>); } first(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Inside Global Execution Context'</span></span>);</code> </pre> <br>  So √§ndert sich der Aufrufstapel, wenn dieser Code ausgef√ºhrt wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e12/8e2/12a/e128e212aac1a408b77666b4dcf6a254.png"></div><br>  <i><font color="#999999">Call Stack Status</font></i> <br><br>  Wenn der obige Code in den Browser geladen wird, erstellt die JavaScript-Engine einen globalen Ausf√ºhrungskontext und platziert ihn auf dem aktuellen Aufrufstapel.  Wenn Sie die Funktion <code>first()</code> aufrufen, erstellt die Engine einen neuen Kontext f√ºr diese Funktion und platziert ihn oben auf dem Stapel. <br><br>  Wenn die Funktion <code>second()</code> Funktion <code>first()</code> aufgerufen wird, wird f√ºr diese Funktion ein neuer Ausf√ºhrungskontext erstellt und ebenfalls auf den Stapel verschoben.  Nachdem die Funktion <code>second()</code> ihre Arbeit abgeschlossen hat, wird ihr Kontext vom Stapel entfernt und die Steuerung wird in den Ausf√ºhrungskontext √ºbertragen, der sich auf dem darunter liegenden Stapel befindet, dh in den Kontext der Funktion <code>first()</code> . <br><br>  Wenn die Funktion <code>first()</code> wird, wird ihr Kontext aus dem Stapel entfernt und die Steuerung in den globalen Kontext √ºbertragen.  Nachdem der gesamte Code ausgef√ºhrt wurde, ruft die Engine den globalen Ausf√ºhrungskontext vom aktuellen Stapel ab. <br><br><h2>  <font color="#3AC1EF">Informationen zum Erstellen von Kontexten und Ausf√ºhren von Code</font> </h2><br>  Bisher haben wir dar√ºber gesprochen, wie die JS-Engine Ausf√ºhrungskontexte verwaltet.  Lassen Sie uns nun dar√ºber sprechen, wie Ausf√ºhrungskontexte erstellt werden und was mit ihnen passiert, nachdem sie erstellt wurden.  Insbesondere sprechen wir √ºber die Phase der Erstellung des Ausf√ºhrungskontexts und die Phase der Codeausf√ºhrung. <br><br><h3>  <font color="#3AC1EF">‚ñç Phase der Erstellung des Ausf√ºhrungskontexts</font> </h3><br>  Bevor der JavaScript-Code ausgef√ºhrt wird, wird der Ausf√ºhrungskontext erstellt.  Bei der Erstellung werden drei Aktionen ausgef√ºhrt: <br><br><ol><li>  Dieser Wert wird bestimmt und <code>this</code> (diese Bindung) ist gebunden. </li><li>  Die <code>LexicalEnvironment</code> Komponente wird erstellt. </li><li>  Die <code>VariableEnvironment</code> Komponente wird erstellt. </li></ol><br>  Konzeptionell kann der Ausf√ºhrungskontext wie folgt dargestellt werden: <br><br><pre> <code class="hljs cs">ExecutionContext = { ThisBinding = &lt;<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>&gt;, LexicalEnvironment = { ... }, VariableEnvironment = { ... }, }</code> </pre> <br><h4>  Diese Bindung </h4><br>  Im globalen Ausf√ºhrungskontext enth√§lt <code>this</code> einen Verweis auf das globale Objekt (wie bereits erw√§hnt, ist es im Browser ein <code>window</code> ). <br><br>  Im Kontext der Funktionsausf√ºhrung h√§ngt der Wert davon ab, wie die Funktion aufgerufen wurde.  Wenn es als Methode eines Objekts aufgerufen wird, ist der Wert dieses Objekts an dieses Objekt gebunden.  In anderen F√§llen ist <code>this</code> an ein globales Objekt gebunden oder auf <code>undefined</code> (im strengen Modus).  Betrachten Sie ein Beispiel: <br><br><pre> <code class="hljs lua">let foo = { baz: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(this); } } foo.baz();    // <span class="hljs-string"><span class="hljs-string">'this'</span></span>    <span class="hljs-string"><span class="hljs-string">'foo'</span></span>,    <span class="hljs-string"><span class="hljs-string">'baz'</span></span>              //    <span class="hljs-string"><span class="hljs-string">'foo'</span></span> let bar = foo.baz; bar();       // <span class="hljs-string"><span class="hljs-string">'this'</span></span>     window,                 //     </code> </pre> <br><h4>  Lexikalische Umgebung </h4><br>  Gem√§√ü <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der</a> ES6- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spezifikation</a> ist Lexical Environment ein Begriff, der verwendet wird, um die Beziehung zwischen Bezeichnern und einzelnen Variablen und Funktionen basierend auf der Struktur der lexikalischen Verschachtelung des ECMAScript-Codes zu definieren.  Die lexikalische Umgebung besteht aus einem Umgebungsdatensatz und einem Verweis auf die externe lexikalische Umgebung, die <code>null</code> . <br><br>  Einfach ausgedr√ºckt ist eine lexikalische Umgebung eine Struktur, in der Informationen √ºber die Entsprechung von Bezeichnern und Variablen gespeichert werden.  Mit "Bezeichner" ist hier der Name einer Variablen oder Funktion gemeint, und mit "Variable" ist eine Referenz auf ein bestimmtes Objekt (einschlie√ülich einer Funktion) oder einen primitiven Wert gemeint. <br><br>  In der lexikalischen Umgebung gibt es zwei Komponenten: <br><br><ol><li>  Aufzeichnung einer Umgebung.  Hier werden Variablen- und Funktionsdeklarationen gespeichert. </li><li>  Link zur externen Umgebung.  Das Vorhandensein eines solchen Links zeigt an, dass die lexikalische Umgebung Zugriff auf die √ºbergeordnete lexikalische Umgebung (Bereich) hat. </li></ol><br>  Es gibt zwei Arten von lexikalischen Umgebungen: <br><br><ol><li>  Die globale Umgebung (oder der globale Ausf√ºhrungskontext) ist eine lexikalische Umgebung ohne externe Umgebung.  Der globale Umgebungsverweis auf die externe Umgebung ist <code>null</code> .  In der globalen Umgebung (im Umgebungsdatensatz) sind integrierte Sprachentit√§ten (wie <code>Object</code> , <code>Array</code> usw.) verf√ºgbar, die dem globalen Objekt zugeordnet sind. Au√üerdem sind vom Benutzer globale Variablen definiert.  Der Wert in dieser Umgebung zeigt auf ein globales Objekt. </li><li>  Die Umgebung der Funktion, in der im Umgebungsdatensatz die vom Benutzer deklarierten Variablen gespeichert sind.  Der Verweis auf die externe Umgebung kann sowohl ein globales Objekt als auch eine Funktion au√üerhalb der betreffenden Funktion angeben. </li></ol><br>  Es gibt zwei Arten von Umgebungsdatens√§tzen: <br><br><ol><li>  Ein deklarativer Umgebungsdatensatz, in dem Variablen, Funktionen und Parameter gespeichert sind. </li><li>  Ein Umgebungsobjektdatensatz, in dem Informationen zu Variablen und Funktionen in einem globalen Kontext gespeichert werden. </li></ol><br>  Infolgedessen wird in einer globalen Umgebung ein Umgebungsdatensatz durch einen Objektumgebungsdatensatz und in einer Funktionsumgebung durch einen deklarativen Umgebungsdatensatz dargestellt. <br><br>  Beachten Sie, dass in der Umgebung der Funktion der deklarative Datensatz der Umgebung auch das <code>arguments</code> enth√§lt, in dem die Entsprechung zwischen den Indizes und den Werten der an die Funktion √ºbergebenen Argumente sowie Informationen zur Anzahl solcher Argumente gespeichert sind. <br><br>  Die lexikalische Umgebung kann als folgender Pseudocode dargestellt werden: <br><br><pre> <code class="hljs pgsql">GlobalExectionContext = { LexicalEnvironment: {   EnvironmentRecord: {     <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>: "Object",     //        }   <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>&gt; } } FunctionExectionContext = { LexicalEnvironment: {   EnvironmentRecord: {     <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>: "Declarative",     //        }   <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;        &gt; } }</code> </pre> <br><h4>  Umgebungsvariablen </h4><br>  Eine variable Umgebung ist auch eine lexikalische Umgebung, in deren Umgebungsdatensatz die mit <code>VariableStatement</code> Befehlen erstellten Bindungen im aktuellen Ausf√ºhrungskontext gespeichert sind. <br><br>  Da die Umgebung von Variablen auch eine lexikalische Umgebung ist, besitzt sie alle oben beschriebenen Eigenschaften der lexikalischen Umgebung. <br><br>  In ES6 gibt es einen Unterschied zwischen den Komponenten <code>LexicalEnvironment</code> und <code>VariableEnvironment</code> .  Es besteht in der Tatsache, dass ersteres zum Speichern von Deklarationen von Funktionen und Variablen verwendet wird, die mit den Schl√ºsselw√∂rtern <code>let</code> und <code>const</code> deklariert wurden, und letzteres nur zum Speichern von Variablenbindungen, die mit dem Schl√ºsselwort <code>var</code> deklariert wurden. <br><br>  Betrachten Sie Beispiele, die veranschaulichen, was wir gerade besprochen haben: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">30</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">multiply</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, f</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> g = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e * f * g; } c = multiply(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>);</code> </pre> <br>  Eine schematische Darstellung des Ausf√ºhrungskontexts f√ºr diesen Code sieht folgenderma√üen aus: <br><br><pre> <code class="hljs pgsql">GlobalExectionContext = { ThisBinding: &lt;<span class="hljs-keyword"><span class="hljs-keyword">Global</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>&gt;, LexicalEnvironment: {   EnvironmentRecord: {     <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>: "Object",     //          a: &lt; uninitialized &gt;,     b: &lt; uninitialized &gt;,     multiply: &lt; func &gt;   }   <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>&gt; }, VariableEnvironment: {   EnvironmentRecord: {     <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>: "Object",     //          c: undefined,   }   <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>&gt; } } FunctionExectionContext = { ThisBinding: &lt;<span class="hljs-keyword"><span class="hljs-keyword">Global</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>&gt;, LexicalEnvironment: {   EnvironmentRecord: {     <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>: "Declarative",     //          Arguments: {<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">30</span></span>, length: <span class="hljs-number"><span class="hljs-number">2</span></span>},   },   <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;GlobalLexicalEnvironment&gt; }, VariableEnvironment: {   EnvironmentRecord: {     <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>: "Declarative",     //          g: undefined   },   <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span>: &lt;GlobalLexicalEnvironment&gt; } }</code> </pre> <br>  Wie Sie wahrscheinlich bemerkt haben, haben Variablen und Konstanten, die mit den Schl√ºsselw√∂rtern <code>let</code> und <code>const</code> deklariert wurden, keine zugeordneten Werte, und Variablen, die mit dem Schl√ºsselwort <code>var</code> deklariert wurden, werden auf <code>undefined</code> . <br><br>  Dies liegt daran, dass der Code w√§hrend der Erstellung des Kontexts nach Deklarationen von Variablen und Funktionen sucht, w√§hrend die Deklarationen von Funktionen vollst√§ndig in der Umgebung gespeichert werden.  Die Werte von Variablen werden bei Verwendung von <code>var</code> auf <code>undefined</code> , und bei Verwendung von <code>let</code> oder <code>const</code> bleiben sie nicht initialisiert. <br><br>  Aus diesem Grund k√∂nnen Sie auf Variablen zugreifen, die mit <code>var</code> deklariert wurden, bevor sie deklariert wurden (obwohl sie <code>undefined</code> ). Wenn Sie jedoch versuchen, auf Variablen oder Konstanten zuzugreifen, die mit <code>let</code> und <code>const</code> deklariert wurden, bevor sie deklariert wurden, tritt ein Fehler auf . <br><br>  Was wir gerade beschrieben haben, hei√üt "Hubvariablen".  Variablendeklarationen ‚Äûsteigen‚Äú an die Spitze ihres lexikalischen Bereichs, bevor Operationen ausgef√ºhrt werden, bei denen ihnen Werte zugewiesen werden. <br><br><h3>  <font color="#3AC1EF">‚ñç Phase der Codeausf√ºhrung</font> </h3><br>  Dies ist vielleicht der einfachste Teil dieses Materials.  In diesem Stadium werden die Werte den Variablen zugewiesen und der Code wird ausgef√ºhrt. <br><br>  Beachten Sie, dass die JS-Engine, wenn sie w√§hrend der Ausf√ºhrung des Codes den Wert der mit dem Schl√ºsselwort <code>let</code> am Deklarationsort deklarierten Variablen nicht finden kann, dieser Variablen den <code>undefined</code> Wert <code>undefined</code> . <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Wir haben gerade die internen Mechanismen zur Ausf√ºhrung von JavaScript-Code besprochen.  Um ein sehr guter JS-Entwickler zu sein, ist es zwar nicht erforderlich, all dies zu wissen. Wenn Sie jedoch die oben genannten Konzepte verstehen, k√∂nnen Sie andere Mechanismen der Sprache besser und tiefer verstehen, z. B. das Erh√∂hen von Variablen, den Umfang usw. Kurzschl√ºsse. <br><br>  <b>Liebe Leser!</b>  Was halten Sie au√üer dem Ausf√ºhrungskontext und dem Aufrufstapel f√ºr JavaScript-Entwickler f√ºr n√ºtzlich? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422089/">https://habr.com/ru/post/de422089/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422079/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 329 (27. August - 2. September 2018)</a></li>
<li><a href="../de422081/index.html">Anwendung f√ºr ein Framework f√ºr einen Multi-Plattform-Bot</a></li>
<li><a href="../de422083/index.html">Einseitige Site auf Kotlin und SpringBoot ohne Verwendung von JSP</a></li>
<li><a href="../de422085/index.html">Nach Auswahl sortieren</a></li>
<li><a href="../de422087/index.html">Computer Vision in der Industrie. Vortrag in Yandex</a></li>
<li><a href="../de422091/index.html">Effektive Verwendung von Array-Methoden in JavaScript</a></li>
<li><a href="../de422093/index.html">"Storytelling with Data" von Cole Nussbaumer Knaflic: ein informelles Buchkompendium</a></li>
<li><a href="../de422095/index.html">Spezielles Audio-Gadget: ‚Äûstille‚Äú Stimme von ‚ÄûMedusa‚Äú, ‚ÄûFl√ºstern‚Äú der Schilde und 162 dB von LRAD</a></li>
<li><a href="../de422097/index.html">Hinweise des IoT-Anbieters. Ein bisschen √ºber Frequenzen</a></li>
<li><a href="../de422099/index.html">Gro√üe Betreiber verdienen das "Fr√ºhlingsgesetz", indem sie kleinen Betreibern Hosting-Dienste anbieten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>