<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🏫 🤳🏼 👩‍👧‍👦 C ++ 11 und Ereignisbehandlung 🔓 ™️ ⬜️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich denke, dass die Ereignisverarbeitung als Interaktionsmethode zwischen Objekten in OOP fast jedem bekannt ist, der OOP mindestens einmal berührt ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++ 11 und Ereignisbehandlung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424593/">  Ich denke, dass die Ereignisverarbeitung als Interaktionsmethode zwischen Objekten in OOP fast jedem bekannt ist, der OOP mindestens einmal berührt hat.  Zumindest ist dieser Ansatz in einem meiner Meinung nach sehr breiten Aufgabenbereich sehr praktisch.  In vielen Programmiersprachen ist die Event-Handling-Engine integriert.  In C ++ gibt es jedoch keinen solchen Mechanismus.  Mal sehen, was Sie dagegen tun können. <br><a name="habracut"></a><br><a name="Intro"></a><h1>  Kurze Einführung </h1><br>  <i>Ein Ereignis</i> kann unter bestimmten Bedingungen mit einem Objekt geschehen (z. B. mit einer Schaltfläche, wenn Sie mit der Maus darauf klicken).  Andere Unternehmen müssen sich dessen möglicherweise bewusst sein.  dann <i>abonnieren sie die Veranstaltung</i> .  In diesem Fall wird beim <i>Eintreten</i> eines Ereignisses der <i>Handler eines</i> Objekts <i>eines</i> Drittanbieters aufgerufen, das das Ereignis abonniert hat.  Somit hat er die Möglichkeit, Code auszuführen, d.h.  auf ein Ereignis reagieren.  Ebenso kann ein Objekt <i>ein Ereignis abbestellen,</i> wenn es nicht mehr darauf reagieren möchte.  Infolgedessen haben wir viele Objekte, die mithilfe der Ereignisse eines von ihnen und der Reaktion auf diese Ereignisse anderer miteinander verbunden werden können. <br><br>  So etwas, obwohl das jeder weiß. <br><br><a name="Trivial"></a><h1>  Einfachste Implementierung </h1><br>  Es scheint einfach, ein solches Verhalten zu implementieren.  Und es könnte so aussehen: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: AbstractEventHandler() {} };</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEvent</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandler = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent() : m_handlers() { } ~TEvent() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( TEventHandler* oneHandler : m_handlers ) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> oneHandler; m_handlers.clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( TEventHandler* oneHandler : m_handlers ) oneHandler-&gt;call( params... ); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=( TEventHandler&amp; eventHandler ) { m_handlers.push_back( &amp;eventHandler ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;TEventHandler*&gt; m_handlers; };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethod = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::* )( TParams... ); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MethodEventHandler( TObject&amp; object, TMethod method ) : AbstractEventHandler&lt;TParams...&gt;(), m_object( object ), m_method( method ) { assert( m_method != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> override final </span></span>{ ( m_object.*m_method )( params... ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TObject&amp; m_object; TMethod m_method; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class">&lt;TParams...&gt;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">createMethodEventHandler</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">:</span></span>:*method )( TParams... ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodEventHandler&lt;TObject, TParams...&gt;( object, method ); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> METHOD_HANDLER( Object, Method ) createMethodEventHandler( Object, &amp;Method ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MY_METHOD_HANDLER( Method ) METHOD_HANDLER( *this, Method )</span></span></code> </pre><br>  Die Anwendung dieses Falles sollte folgende Form haben: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestWindow</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; onButtonClick; . . . }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClickEventHandler</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testWindowButtonClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ ... } . . . }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[] )</span></span></span><span class="hljs-function"> </span></span>{ . . . TestWindow testWindow; ClickEventHandler clickEventHandler; testWindow.onButtonClick += METHOD_HANDLER( clickEventHandler, ClickEventHandler::testWindowButtonClick ); . . . }</code> </pre><br>  Natürlich wird eine Handler-Methode (-Funktionsmitglied einer Klasse) nicht die einzige Art von Handlern sein, aber dazu später mehr. <br><br>  Alles scheint bequem, kompakt und großartig zu sein.  Es gibt jedoch eine Reihe von Mängeln. <br><br><a name="HandlerCompare"></a><h1>  Handler-Vergleich </h1><br>  Um das Abbestellen eines Ereignisses zu implementieren, muss die Vergleichsmöglichkeit zum Handler hinzugefügt werden (by <i>==</i> und <i>! ==</i> ).  Diejenigen Handler, die dieselbe Methode (eine Elementfunktion einer Klasse) desselben Objekts (d. H. Dieselbe Instanz derselben Klasse) aufrufen, werden als gleich betrachtet. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isEquals( other ); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == other ); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MyType&amp; other )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; . . . };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TMethodHolder</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethod = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::* )( TParams... ); <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AbstractEventHandler&lt;TParams...&gt;&amp; other )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType* _other = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType*&gt;( &amp;other ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( _other != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; &amp;m_object == &amp;_other.m_object &amp;&amp; m_method == _other.m_method ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TObject&amp; m_object; TMethod m_method; . . . };</code> </pre><br>  Dann können wir Handler aus dem Ereignisabonnement entfernen.  In diesem Fall muss das Hinzufügen derselben (gleichen) Handler verboten werden. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEvent</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandler = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandlerIt = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;TEventHandler*&gt;::const_iterator; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=( TEventHandler&amp; eventHandler ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( findEventHandler( eventHandler ) == m_handlers.end() ) { m_handlers.push_back( &amp;eventHandler ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-=( TEventHandler&amp; eventHandler ) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = findEventHandler( eventHandler ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( it != m_handlers.end() ) { TEventHandler* removedEventHandler = *it; m_handlers.erase( it ); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> removedEventHandler; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> TEventHandlerIt </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findEventHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::find_if( m_handlers.cbegin(), m_handlers.cend(), [ &amp;eventHandler ]( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TEventHandler* oneHandler ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( *oneHandler == eventHandler ); } ); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;TEventHandler*&gt; m_handlers; . . . };</code> </pre><br>  Hier geben die Funktionen zum Hinzufügen / Entfernen des Handlers bei Erfolg <i>true</i> und <i>false zurück,</i> wenn die entsprechende Aktion (Hinzufügen oder Entfernen) nicht ausgeführt wurde. <br><br>  Ja, der Anwendungsfall mit Vergleich beinhaltet die Erstellung temporärer, nirgends hinzugefügter Handler, die nirgendwo gelöscht werden.  Aber dazu später mehr. <br><br>  Kann das verwendet werden?  Noch nicht vollständig implementiert. <br><br><a name="HandlerRemoving"></a><h1>  Entfernen eines Handlers in einem Handler </h1><br>  Wir stoßen also sofort auf einen Absturz während der Codeausführung, bei dem sich der Handler vom Ereignis abmeldet (ich denke, es ist nicht der seltenste <i>Anwendungsfall,</i> wenn der Handler unter keinen Umständen selbst schneidet): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestWindow</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; onButtonClick; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TestWindow&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">instance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; . . . }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClickEventHandler</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testWindowButtonClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ TestWindow::instance().onButtonClick -= MY_METHOD_HANDLER( ClickEventHandler::testWindowButtonClick ); } . . . }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[] )</span></span></span><span class="hljs-function"> </span></span>{ . . . ClickEventHandler clickEventHandler; TestWindow::instance().onButtonClick += METHOD_HANDLER( clickEventHandler, ClickEventHandler::testWindowButtonClick ); . . . }</code> </pre><br>  Das Problem tritt aus einem sehr einfachen Grund auf: <br><br><ul><li>  Das Ereignis wird ausgelöst und beginnt mit der Iteration (unter Verwendung von Iteratoren) von Handlern, wobei diese aufgerufen werden. </li><li>  der nächste Handler in sich bewirkt, dass er selbst gelöscht wird; </li><li>  Das Ereignis löscht den angegebenen Handler und macht den entsprechenden Iterator ungültig. </li><li>  Nach Abschluss dieses Handlers kehrt das Ereignis zur Aufzählung der anderen zurück. Der aktuelle Iterator (der dem Remote-Handler entspricht) ist jedoch bereits ungültig. </li><li>  Das Ereignis versucht, auf den ungültigen Iterator zuzugreifen, was zu einem Absturz führt. </li></ul><br>  Daher müssen Fälle überprüft werden, in denen die Liste der Handler geändert werden kann, was zur Ungültigmachung von Iteratoren führen würde.  und dann einen Leseschutz für solche Iteratoren implementieren. <br><br>  Der Vorteil von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: list</a> 'in dieser Anwendung ist die Tatsache, dass beim Löschen nur ein Iterator ungültig wird - für das gelöschte Element (was beispielsweise Folgendes betrifft);  Das Hinzufügen eines Elements führt überhaupt nicht zur Ungültigmachung von Iteratoren.  Daher müssen wir den einzigen Fall steuern: Löschen eines Elements, dessen Iterator in der aktuellen Aufzählung der Elemente aktuell ist.  In diesem Fall können Sie beispielsweise ein Element nicht löschen, sondern einfach markieren, dass das aktuelle Element gelöscht werden soll, und es innerhalb der Aufzählung von Elementen ausführen lassen. <br><br>  Es wäre möglich, die Implementierung sofort einzuführen, aber ich schlage vor, dieses Problem zusammen mit den folgenden zu lösen. <br><br><a name="ThreadSafety"></a><h1>  Gewindesicherheit </h1><br>  Möglicherweise sind Aufrufe von drei möglichen Funktionen - Hinzufügen, Löschen und Sortieren von Handlern (wenn ein Ereignis ausgelöst wird) - von verschiedenen Threads zu zufälligen Zeiten möglich.  Dies schafft ein ganzes Feld von Möglichkeiten für ihre "zeitliche Überschneidung", "Überlappung" ihrer Ausführung untereinander und den daraus resultierenden Rückgang des Programms.  Versuchen wir dies zu vermeiden.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mutexe sind unser Alles</a> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEvent</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandler = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandlerIt = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;TEventHandler*&gt;::const_iterator; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent() : m_handlers(), m_currentIt(), m_isCurrentItRemoved( <span class="hljs-literal"><span class="hljs-literal">false</span></span> ), m_handlerListMutex() { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> </span></span>{ m_handlerListMutex.lock_shared(); m_isCurrentItRemoved = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; m_currentIt = m_handlers.begin(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( m_currentIt != m_handlers.end() ) { m_handlerListMutex.unlock_shared(); ( *m_currentIt )-&gt;call( params... ); m_handlerListMutex.lock_shared(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_isCurrentItRemoved ) { m_isCurrentItRemoved = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; TEventHandlerIt removedIt = m_currentIt; ++m_currentIt; deleteHandler( removedIt ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++m_currentIt; } } m_handlerListMutex.unlock_shared(); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=( TEventHandler&amp; eventHandler ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_lock&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( findEventHandler( eventHandler ) == m_handlers.end() ) { m_handlers.push_back( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( eventHandler ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-=( TEventHandler&amp; eventHandler ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_lock&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = findEventHandler( eventHandler ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( it != m_handlers.end() ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( it == m_currentIt ) m_isCurrentItRemoved = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> deleteHandler( it ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">//      'm_handlerListMutex' inline TEventHandlerIt findEventHandler( TEventHandler&amp; eventHandler ) const { return std::find_if( m_handlers.cbegin(), m_handlers.cend(), [ &amp;eventHandler ]( const TEventHandler* oneHandler ) { return ( *oneHandler == eventHandler ); } ); } //      'm_handlerListMutex' inline void deleteHandler( TEventHandlerIt it ) { TEventHandler* removedEventHandler = *it; m_handlers.erase( it ); delete removedEventHandler; } std::list&lt;TEventHandler*&gt; m_handlers; //    'm_handlerListMutex' mutable TEventHandlerIt m_currentIt; mutable bool m_isCurrentItRemoved; mutable std::shared_mutex m_handlerListMutex; };</span></span></code> </pre><br>  Vergessen Sie nicht, das Fenster fast jedes Mal offen zu lassen, wenn Sie jeden Handler anrufen.  Dies ist erforderlich, damit Sie im Handler auf das Ereignis zugreifen und es ändern können (z. B. Handler hinzufügen / entfernen), ohne einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Deadlock</a> zu verursachen.  Sie können keine Angst vor der Gültigkeit der Daten haben, denn wie wir herausgefunden haben, führt das einzige, was dazu führt, das Löschen des aktuellen Elements, und diese Situation wurde verarbeitet. <br>  <b>UPD1.</b>  Danke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Cheater</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schlug vor,</a> dass <i>std :: shared_mutex</i> nur in <i>C ++ 17 erscheint</i> (und <i>std :: shared_lock</i> nur in <i>C ++ 14</i> ).  Diejenigen, für die dies kritisch ist, werden wahrscheinlich mit <i>std :: mutex</i> zu tun haben. <br>  <b>UPD2.</b>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weiter über die Thread-Sicherheit</a> (ohne die Reihenfolge der Erzählungen beizubehalten). <br><br><a name="EventVisibility"></a><h1>  Problem mit der Sichtbarkeit von Ereignissen </h1><br>  Wenn Sie ein Ereignis als Mitglied einer Klasse verwenden, erscheint es logisch, es <i>öffentlich</i> zu machen, damit Objekte von Drittanbietern ihre Handler hinzufügen / entfernen können.  Dies führt jedoch zu <i>operator ()</i> , d.h.  Ein Ereignisanruf ist auch von außen zugänglich, was in einigen Fällen nicht akzeptabel sein kann.  Wir werden dieses Problem lösen, indem wir aus der Ereignisklasse ( <i>TEvent &lt;...&gt;</i> ) eine abstrakte Schnittstelle isolieren, die nur für die Behandlung von <i>Handlern</i> vorgesehen ist. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEvent</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandler = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=( TEventHandler&amp; eventHandler ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addHandler( eventHandler ); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-=( TEventHandler&amp; eventHandler ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> removeHandler( eventHandler ); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: IEvent() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEvent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IEvent&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent() : IEvent&lt;TParams...&gt;() . . . { } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,     'TEvent::operator+=' } virtual bool removeHandler( TEventHandler&amp; eventHandler ) override { // ,     'TEvent::operator-=' } . . . };</span></span></code> </pre><br>  Jetzt können wir den Teil des Ereignisses, der für die Arbeit mit Handlern verantwortlich ist, und den Teil, der für den Aufruf verantwortlich ist, in verschiedene Bereiche aufteilen. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestWindow</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TestWindow() : onButtonClick( m_onButtonClick ), m_onButtonClick() { } IEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&amp; onButtonClick; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; m_onButtonClick; . . . };</code> </pre><br>  Somit können Objekte von Drittanbietern ihre Handler <i>jetzt</i> über <i>TestWindow :: onButtonClick</i> hinzufügen / entfernen, können dieses Ereignis jedoch nicht selbst auslösen.  Ein Aufruf kann jetzt nur innerhalb der <i>TestWindow-</i> Klasse (und ihrer Nachkommen, wenn beispielsweise der Umfang des Ereignisses <i>geschützt ist</i> ) ausgeführt werden. <br><br>  Der triviale Code verwandelt sich langsam in etwas Ungeheuerliches, aber dies ist nicht das Ende. <br><br><a name="EventHandlerParams"></a><h1>  Passen Sie die Ereignisparameter und ihre Handler an </h1><br>  In der aktuellen Implementierung müssen das Ereignis und alle seine Handler über eine streng entsprechende Liste von Parametern verfügen.  Dies führt zu einer Reihe von Nachteilen. <br><br>  <b>Der erste.</b>  Angenommen, wir haben eine Klassenvorlage, in der sich ein Ereignis mit einem Vorlagenparameter befindet. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSource</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TSource&amp;&gt; onValueChanged; . . . };</code> </pre><br>  Aufgrund der Tatsache, dass der Typ, der hier verwendet wird, nicht im Voraus bekannt ist, ist es sinnvoll, ihn als konstante Verknüpfung und nicht als Wert zu übergeben.  Für jede Implementierung müssen jedoch auch bei grundlegenden Typen entsprechende Handler vorhanden sein. <br><br><pre> <code class="cpp hljs">MyClass&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; myBoolClass; . . . <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSource</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyHandlerClass</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleValueChanged1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; newValue )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleValueChanged2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue )</span></span></span></span>; . . . }; . . . MyHandlerClass myHandlerClass; myBoolClass.onValueChanged += METHOD_HANDLER( myHandlerClass, MyHandlerClass::handleValueChanged1 ); <span class="hljs-comment"><span class="hljs-comment">// OK myBoolClass.onValueChanged += METHOD_HANDLER( myHandlerClass, MyHandlerClass::handleValueChanged2 ); // compile error</span></span></code> </pre><br>  Ich möchte Handler der Form <i>MyHandlerClass :: handleValueChanged2</i> mit einem ähnlichen Ereignis verbinden können, aber bisher gibt es keine solche Möglichkeit. <br><br>  <b>Der zweite.</b>  Versuchen wir, einen Funktor-Handler zu implementieren, der einer vorhandenen Handler-Methode (-Funktionsmitglied einer Klasse) ähnelt. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: FunctorEventHandler( TFunctor&amp; functor ) : AbstractEventHandler&lt;TParams...&gt;(), m_functor( functor ) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> override final </span></span>{ m_functor( params... ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TFunctor&amp; m_functor; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class">&lt;TParams...&gt;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">createFunctorEventHandler</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">functor</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FunctorEventHandler&lt;TFunctor, TParams...&gt;( functor ); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FUNCTOR_HANDLER( Functor ) createFunctorEventHandler( Functor )</span></span></code> </pre><br>  Versuchen Sie nun, es auf ein Ereignis zu schrauben. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestWindow</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; onButtonClick; . . . }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClickEventHandler</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ . . . } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[] )</span></span></span><span class="hljs-function"> </span></span>{ . . . TestWindow testWindow; ClickEventHandler clickEventHandler; testWindow.onButtonClick += FUNCTOR_HANDLER( clickEventHandler ); . . . }</code> </pre><br>  Das Ergebnis ist ein Kompilierungsfehler.  Für die Funktion <i>createFunctorEventHandler</i> kann <i>der</i> Compiler die <i>TParam-</i> Typen <i>nicht</i> aus dem einzigen Argument für diese Funktion ableiten - dem Funktor selbst.  Der Funktor enthält wirklich keine Informationen darüber, welche Art von Handler basierend darauf erstellt werden soll.  Das einzige, was in dieser Situation getan werden kann, ist etwas zu schreiben wie: <br><br><pre> <code class="cpp hljs">testWindow.onButtonClick += createFunctorEventHandler&lt;ClickEventHandler, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;( clickEventHandler );</code> </pre><br>  Aber das wollen Sie gar nicht. <br><br><a name="HandlerHolder"></a><h1>  Verbinden eines Ereignisses mit verschiedenen Arten von Handlern </h1><br>  Es gibt also eine Wunschliste, die der Implementierung überlassen bleibt.  Wir werden die Situation am Beispiel eines Funktor-Handlers betrachten, eine Handler-Methode (-Funktionsmitglied einer Klasse) wird auf ähnliche Weise erhalten. <br><br>  Da es allein aufgrund eines Funktors unmöglich ist zu sagen, wie die Liste der Parameter des entsprechenden Handlers aussehen wird, werden wir dies nicht tun.  Diese Frage wird nicht zum Zeitpunkt der Erstellung des Handlers relevant, sondern zum Zeitpunkt des Versuchs, sie einem bestimmten Ereignis zuzuordnen.  Und ja, das sind zwei verschiedene Punkte.  Diese Idee kann wie folgt umgesetzt werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorHolder</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: FunctorEventHandler( FunctorHolder&lt;TFunctor&gt;&amp; functorHolder ) : AbstractEventHandler&lt;TParams...&gt;(), m_functorHolder( functorHolder ) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> override </span></span>{ m_functorHolder.m_functor( params... ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: FunctorHolder&lt;TFunctor&gt;&amp; m_functorHolder; . . . };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: FunctorHolder( TFunctor&amp; functor ) : m_functor( functor ) { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCallParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class">&lt;TCallParams...&gt;&amp;() {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FunctorEventHandler&lt;TFunctor, TCallParams...&gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TFunctor&amp; m_functor; . . . <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">friend</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorEventHandler</span></span></span><span class="hljs-class">;</span></span> };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorHolder</span></span></span><span class="hljs-class">&lt;TFunctor&gt;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">createFunctorEventHandler</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">functor</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FunctorHolder&lt;TFunctor&gt;( functor ); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FUNCTOR_HANDLER( Functor ) createFunctorEventHandler( Functor ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LAMBDA_HANDLER( Lambda ) FUNCTOR_HANDLER( Lambda ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STD_FUNCTION_HANDLER( StdFunction ) FUNCTOR_HANDLER( StdFunction ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FUNCTION_HANDLER( Function ) FUNCTOR_HANDLER( &amp;Function )</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEvent</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandler = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">+=( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addHandler( <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;TEventHandler&amp;&gt;( some ) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">-=( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> removeHandler( <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;TEventHandler&amp;&gt;( some ) ); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: IEvent() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br>  Kurz gesagt, die Trennung der Momente der Erstellung des Handlers und seiner Bindung an das Ereignis ist hier ausgeprägter als zuvor.  Dies umgeht die im vorherigen Absatz beschriebenen Probleme.  <i>Typkompatibilitätstests</i> werden durchgeführt, wenn versucht wird, einen bestimmten <i>FunctorHolder</i> an einen bestimmten <i>FunctorEventHandler anzuhängen</i> oder vielmehr eine Instanz der <i>FunctorEventHandler &lt;...&gt; -Klasse</i> mit einem ganz bestimmten <i>Funktortyp</i> zu erstellen.  und in dieser Klasse gibt es eine Codezeile <i>m_functorHolder.m_functor (params ...);</i>  , die einfach nicht für eine Reihe von Typen kompiliert werden können, die mit einem Funktor nicht kompatibel sind (oder wenn es überhaupt kein Funktor ist, d. h. ein Objekt, das keinen <i>Operator () hat</i> ). <br><br>  Ich wiederhole, dass das Problem des Löschens temporärer Objekte unten diskutiert wird.  Darüber hinaus ist anzumerken, dass für jeden Fall eine Reihe von Makros erstellt wurden, um zum einen die Fähigkeiten dieses Handlertyps zu demonstrieren und zum anderen, falls einer von ihnen mit einer Datei geändert werden sollte. <br><br>  Überprüfen Sie das Ergebnis. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestWindow</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; onButtonClick; . . . }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor3</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor4</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor5</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor6</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor7</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[] )</span></span></span><span class="hljs-function"> </span></span>{ . . . TestWindow testWindow; Functor functor; Functor2 functor2; Functor3 functor3; Functor4 functor4; Functor5 functor5; Functor6 functor6; Functor7 functor7; testWindow.onButtonClick += FUNCTOR_HANDLER( functor ); <span class="hljs-comment"><span class="hljs-comment">// ok testWindow.onButtonClick += FUNCTOR_HANDLER( functor2 ); // ok testWindow.onButtonClick += FUNCTOR_HANDLER( functor3 ); // ok testWindow.onButtonClick += FUNCTOR_HANDLER( functor4 ); // ok testWindow.onButtonClick += FUNCTOR_HANDLER( functor5 ); // compile error testWindow.onButtonClick += FUNCTOR_HANDLER( functor6 ); // ok testWindow.onButtonClick += FUNCTOR_HANDLER( functor7 ); // compile error . . . }</span></span></code> </pre><br>  Beim Versuch, einen der Parameter von <i>const lvalue</i> in <i>lvalue</i> zu konvertieren, tritt ein <i>Kompilierungsfehler</i> auf.  Das Konvertieren von <i>rWert</i> in <i>unkonstanten lWert verursacht</i> keinen Fehler, obwohl es erwähnenswert ist, dass eine potenzielle Gefahr eines Selbstschusses im Bein besteht: Der Handler kann die auf den Stapel kopierte Variable ändern, die beim <i>Beenden dieses Handlers</i> freudig gelöscht wird. <br><br>  Im Allgemeinen sollte die Fehlermeldung ungefähr so ​​aussehen: <br><br><pre> <code class="hljs vhdl"><span class="hljs-literal"><span class="hljs-literal">Error</span></span> C2664 <span class="hljs-symbol"><span class="hljs-symbol">'void</span></span> Functor5::operator ()(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;,<span class="hljs-built_in"><span class="hljs-built_in">unsigned</span></span> int &amp;)': cannot convert argument <span class="hljs-number"><span class="hljs-number">1</span></span> from <span class="hljs-symbol"><span class="hljs-symbol">'const</span></span> std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>' <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;'</code> </pre><br>  Zur besseren Übersichtlichkeit können Sie bei Verwendung von Ereignissen und Handlern im Code von Drittanbietern Ihre eigene Fehlermeldung hinzufügen.  Dazu muss eine kleine unterstützende Struktur geschrieben werden (ich gebe zu, ich habe irgendwo einen ähnlichen Ansatz ausspioniert): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsFunctorParamsCompatible</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-function"><span class="hljs-function">true_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decltype</span></span></span></span><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TCheckedFunctor&gt;()( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TCheckedParams&gt;()... ) )* = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-function"><span class="hljs-function">false_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ... )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>( exists&lt;TFunctor, TParams...&gt;( <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) )::value; }; } <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( IsFunctorParamsCompatible&lt;TFunctor, TParams...&gt;::value, <span class="hljs-string"><span class="hljs-string">"Event and functor arguments are not compatible"</span></span> ); m_functorHolder-&gt;m_functor( params... ); } . . . };</code> </pre><br><a name="AboutSfinae"></a>  Diese Arbeit basiert auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SFINAE-</a> Mechanismus.  Kurz gesagt, es wird versucht, die erste Funktion zu kompilieren. Wenn dies jedoch aufgrund der Inkompatibilität der Argumente (oder des Fehlens von <i>operator ()</i> aus dem, was als Funktor übergeben wurde) nicht funktioniert, gibt der Compiler keinen Fehler aus, sondern versucht lediglich, die zweite Funktion zu kompilieren.  Wir tun alles so, dass die Kompilierung immer erfolgreich ist, und schließen dann, nachdem die Funktion kompiliert wurde, (indem wir das Ergebnis in den <i>Wert</i> schreiben) über die Kompatibilität der Argumente für die angegebenen Typen. <br><br>  Jetzt sieht die Fehlermeldung ungefähr so ​​aus: <br><br><pre> <code class="cpp hljs">Error C2338 Event <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> functor arguments are <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> compatible Error C2664 <span class="hljs-string"><span class="hljs-string">'void Functor5::operator ()(std::string &amp;,unsigned int &amp;)'</span></span>: cannot convert argument <span class="hljs-number"><span class="hljs-number">1</span></span> from <span class="hljs-string"><span class="hljs-string">'const std::string'</span></span> to <span class="hljs-string"><span class="hljs-string">'std::string &amp;'</span></span></code> </pre><br>  Zusätzlich zu einer zusätzlichen, informativeren Fehlermeldung löst dieser Ansatz das Problem der Konvertierung von Argumenten von <i>rWert</i> in <i>unkonstanten Wert</i> : Jetzt verursacht er einen Argumentinkompatibilitätsfehler, d. H.  <i>Der Versuch</i> , den <i>functor6-</i> Handler aus dem obigen Beispiel hinzuzufügen, führt zu einem Fehler bei der Kompilierung. <br>  <b>UPD</b>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verfeinerung</a> (ohne die narrative Reihenfolge <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beizubehalten</a> ). <br><br><a name="FunctorCompare"></a><h1>  Funktionsvergleich </h1><br>  Aufgrund von Änderungen in der Handlerklasse ändert sich die Implementierung des Vergleichens von Instanzen dieser Klasse geringfügig.  Ich werde noch einmal eine Implementierung nur eines Funktor-Handlers bereitstellen, da die Handler-Methode (-Funktionsmitglied der Klasse) ähnlich aussehen wird. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isEquals( other ); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == other ); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MyType&amp; other )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; . . . };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = FunctorEventHandler&lt;TFunctor, TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AbstractEventHandler&lt;TParams...&gt;&amp; other )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType* _other = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType*&gt;( &amp;other ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( _other != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; *m_functorHolder == *_other-&gt;m_functorHolder ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: FunctorHolder&lt;TFunctor&gt;&amp; m_functorHolder; . . . };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorHolder</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = FunctorHolder&lt;TFunctor&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( m_functor == other.m_functor ); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == other ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TFunctor&amp; m_functor; . . . };</code> </pre><br>  Hierbei enden die Ähnlichkeiten bei der Durchführung des Vergleichs und der Teil beginnt nur für die Handler-Funktoren. <br><br>  Wie oben erwähnt, haben wir verschiedene Arten von Funktorhandlern erhalten: direkte Funktorobjekte, Lambda-Ausdrücke, Instanzen der Klasse <i>std :: function</i> , einzelne Funktionen.  Von diesen können Funktorobjekte, Lambda-Ausdrücke und Instanzen der Klasse <i>std :: function</i> nicht mit <i>operator ==</i> verglichen werden (sie müssen an der Adresse verglichen werden), einzelne Funktionen jedoch, weil  bereits gespeichert bei.  Um die Vergleichsfunktion nicht für jeden Fall separat umzuschreiben, schreiben wir sie in allgemeiner Form: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEqu</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEnabled</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EqualityChecker</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEquatable</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EqualityChecker</span></span></span><span class="hljs-class">&lt;TEquatable, typename std::enable_if&lt;is_equatable&lt;TEquatable&gt;::value&gt;::type&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TEquatable&amp; operand1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TEquatable&amp; operand2 )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( operand1 == operand2 ); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TNonEquatable</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EqualityChecker</span></span></span><span class="hljs-class">&lt;TNonEquatable, typename std::enable_if&lt;!is_equatable&lt;TNonEquatable&gt;::value&gt;::type&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TNonEquatable&amp; operand1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TNonEquatable&amp; operand2 )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &amp;operand1 == &amp;operand2 ); } }; } <span class="hljs-comment"><span class="hljs-comment">// template&lt;class TFunctor&gt; class FunctorHolder { . . . using MyType = FunctorHolder&lt;TFunctor&gt;; public: bool operator==( const MyType&amp; other ) const { return EqualityChecker&lt;TFunctor&gt;::isEquals( m_functor, other.m_functor ); } private: TFunctor&amp; m_functor; . . . };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es versteht sich, dass </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is_equatable</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine Hilfsvorlage ist, die bestimmt, ob zwei Instanzen eines bestimmten Typs auf Gleichheit überprüft werden können. </font><font style="vertical-align: inherit;">Mit seiner Hilfe </font><font style="vertical-align: inherit;">wählen wir </font><font style="vertical-align: inherit;">mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: enable_if</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine von zwei teilweise spezialisierten </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EqualityChecker-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Strukturen aus </font><font style="vertical-align: inherit;">, die einen Vergleich durchführen: nach Wert oder nach Adresse. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is_equatable</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementiert ist </font><i><font style="vertical-align: inherit;">,</font></i><font style="vertical-align: inherit;"> kann wie folgt sein:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_equatable</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-function"><span class="hljs-function">true_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decltype</span></span></span></span><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;U&gt;() == </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;U&gt;() )* = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-function"><span class="hljs-function">false_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ... )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>( exists&lt;T&gt;( <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) )::value; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Implementierung basiert auf dem Mechanismus </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die bereits verwendet wurden </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zuvor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Nur hier überprüfen wir das Vorhandensein von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operator ==</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für Instanzen einer bestimmten Klasse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf diese einfache Weise ist die Implementierung des Vergleichs von Handler-Funktoren fertig.</font></font><br><br><a name="GarbageCollection"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Müllabfuhr </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seien Sie nachsichtig, ich wollte auch eine laute Überschrift einfügen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir nähern uns dem Finale und es ist Zeit, die große Anzahl von erstellten Objekten loszuwerden, die niemand kontrolliert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jede Ereignisaktion mit einem Handler erstellt zwei Objekte: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Holder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in dem der ausführbare Teil des </font><i><font style="vertical-align: inherit;">Handlers gespeichert ist</font></i><font style="vertical-align: inherit;"> , und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbinden Sie es mit dem Ereignis. Wir werden nicht vergessen, dass im Falle eines erneuten Hinzufügens des Handlers keine Hinzufügung erfolgt - zwei Objekte werden „in der Luft aufgehängt“ (es sei denn, dieser Fall wird natürlich jedes Mal separat geprüft). Eine andere Situation: Entfernen des Handlers; Es werden auch zwei neue Objekte erstellt, um in der Liste der Ereignishandler nach demselben (Gleichen) zu suchen. Der gefundene Handler aus der Liste wird natürlich gelöscht (falls vorhanden), und dieser temporäre Handler, der für die Suche erstellt wurde und aus zwei Objekten besteht, befindet sich wieder in der Luft. Im Allgemeinen nicht cool. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenden Sie sich an </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">intelligente Zeiger</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wir müssen bestimmen, wie die Semantik des Eigentums an jedem der beiden </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Handlerobjekte lautet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Alleineigentum ( </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">std :: unique_ptr</font></a><font style="vertical-align: inherit;"> ) oder Shared ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inhaber</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neben der Verwendung durch das Ereignis selbst beim Hinzufügen / Entfernen sollte es im </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gespeichert </font><font style="vertical-align: inherit;">werden. Daher verwenden wir es für das gemeinsame Eigentum und für den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EventHandler ist es</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> allein, weil Nach der Erstellung wird es nur in der Liste der Ereignishandler gespeichert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir realisieren diese Idee:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~AbstractEventHandler() {} . . . }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Types</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;AbstractEventHandler&lt;Types...&gt;&gt;;</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerCast</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Types</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class">&lt;Types...&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cast</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;THandlerPtr&lt;Types...&gt;&gt;( some ); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TPtr</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerCast</span></span></span><span class="hljs-class">&lt;std::shared_ptr&lt;TPtr&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Types</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class">&lt;Types...&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cast</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;TPtr&gt; some ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HandlerCast&lt;TPtr&gt;::cast&lt;Types...&gt;( *some ); } }; } <span class="hljs-comment"><span class="hljs-comment">// template&lt;class ...TParams&gt; class IEvent { public: template&lt;class TSome&gt; bool operator+=( TSome&amp;&amp; some ) { return addHandler( HandlerCast&lt;TSome&gt;::cast&lt;TParams...&gt;( some ) ); } template&lt;class TSome&gt; bool operator-=( TSome&amp;&amp; some ) { return removeHandler( HandlerCast&lt;TSome&gt;::cast&lt;TParams...&gt;( some ) ); } protected: using TEventHandlerPtr = THandlerPtr&lt;TParams...&gt;; IEvent() {} virtual bool addHandler( TEventHandlerPtr eventHandler ) = 0; virtual bool removeHandler( TEventHandlerPtr eventHandler ) = 0; }; template&lt;class ...TParams&gt; class TEvent : public IEvent&lt;TParams...&gt; { using TEventHandlerIt = typename std::list&lt;TEventHandlerPtr&gt;::const_iterator; public: TEvent() { . . . } ~TEvent() { // empty } protected: virtual bool addHandler( TEventHandlerPtr eventHandler ) override { std::unique_lock&lt;std::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); if( findEventHandler( eventHandler ) == m_handlers.end() ) { m_handlers.push_back( std::move( eventHandler ) ); return true; } return false; } virtual bool removeHandler( TEventHandlerPtr eventHandler ) override { . . . } private: //      'm_handlerListMutex' inline TEventHandlerIt findEventHandler( const TEventHandlerPtr&amp; eventHandler ) const { return std::find_if( m_handlers.cbegin(), m_handlers.cend(), [ &amp;eventHandler ]( const TEventHandlerPtr&amp; oneHandler ) { return ( *oneHandler == *eventHandler ); } ); } //      'm_handlerListMutex' inline void deleteHandler( TEventHandlerIt it ) { m_handlers.erase( it ); } std::list&lt;TEventHandlerPtr&gt; m_handlers; . . . };</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TMethodHolder</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethodHolderPtr = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;TMethodHolder&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MethodEventHandler( TMethodHolderPtr methodHolder ) : AbstractEventHandler&lt;TParams...&gt;(), m_methodHolder( methodHolder ) { assert( m_methodHolder != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TMethodHolderPtr m_methodHolder; . . . }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = MethodHolder&lt;TObject, TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethod = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::* )( TParams... ); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MethodHolder( TObject&amp; object, TMethod method ) { . . . } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCallParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class">&lt;TCallParams...&gt;() {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> THandlerPtr&lt;TCallParams...&gt;( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodEventHandler&lt;MyType, TCallParams...&gt;( <span class="hljs-comment"><span class="hljs-comment">/*   ? */</span></span> ) ); } . . . }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MethodHolder&lt;TObject, TParams...&gt;&gt; createMethodEventHandler( TObject&amp; object, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::*method )( TParams... ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MethodHolder&lt;TObject, TParams...&gt;&gt;( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodHolder&lt;TObject, TParams...&gt;( object, method ) ); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> METHOD_HANDLER( Object, Method ) createMethodEventHandler( Object, &amp;Method ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MY_METHOD_HANDLER( Method ) METHOD_HANDLER( *this, Method )</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Wichtigste zuerst. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zunächst das Ereignis und seine Schnittstelle für die Arbeit mit Handlern. In letzterem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fall können</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie Typen </font><font style="vertical-align: inherit;">nicht mehr </font><font style="vertical-align: inherit;">direkt mit </font><i><font style="vertical-align: inherit;">static_cast konvertieren</font></i><font style="vertical-align: inherit;"> , da der zu konvertierende Typ "innerhalb" von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr liegt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Für eine solche Konvertierung verwenden wir jetzt die zusätzliche </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HandlerCast-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Struktur </font><font style="vertical-align: inherit;">, die durch ihre private Spezialisierung den Zugriff auf das Objekt in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr ermöglicht</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und bereits mit ihr arbeitet (in ihrer nicht spezialisierten Implementierung) und den guten alten </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_cast anwendet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Ereignis selbst; Auch hier gibt es einige wichtige Änderungen. Zunächst beenden wir das manuelle Löschen von Handlerinstanzen im Destruktor und beim Löschen. Jetzt reicht es aus, den Smart Pointer mit diesem Handler aus der Liste zu entfernen. Außerdem ist es beim Hinzufügen eines Handlers wichtig, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: move</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht zu vergessen </font><font style="vertical-align: inherit;">, da </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: unique_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unterstützt das Kopieren nicht (was für eine solche Semantik durchaus logisch ist). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gehen wir weiter zu den Handlern. Nach der alten Tradition ist nur einer von ihnen gegeben, der zweite ist ähnlich. Und hier kommt es auf den ersten Blick darauf an, die Arten gespeicherter / erstellter Objekte von Links / Zeigern zu intelligenten Zeigern zu ändern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber es gibt einen subtilen Punkt. Die Funktion </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">createMethodEventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gibt </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> an eine Instanz zurück</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHolder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Etwas später wird versucht, es in einen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Handlertyp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><i><font style="vertical-align: inherit;">MethodEventHandler</font></i><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">zu konvertieren </font><font style="vertical-align: inherit;">, in dem eine neue Instanz von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodEventHandler erstellt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und an den Konstruktor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> übergeben werden muss. Genau dies war beabsichtigt, damit die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHolder-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Instanz </font><font style="vertical-align: inherit;">später </font><i><font style="vertical-align: inherit;">gelöscht wird,</font></i><font style="vertical-align: inherit;"> wenn die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodEventHandler-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Instanz </font><i><font style="vertical-align: inherit;">gelöscht wurde</font></i><font style="vertical-align: inherit;"> . Das Problem ist jedoch, dass </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHolder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> keinen Zugriff auf das bereits erstellte </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr hat</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in dem es selbst </font><i><font style="vertical-align: inherit;">gespeichert ist</font></i><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um das Problem zu lösen, müssen </font><font style="vertical-align: inherit;">Sie </font><font style="vertical-align: inherit;">in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHolder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> einen </font><font style="vertical-align: inherit;">intelligenten Zeiger auf sich selbst </font><i><font style="vertical-align: inherit;">speichern</font></i><font style="vertical-align: inherit;"> . Wir verwenden jedoch, damit die Entfernung nicht beeinträchtigt wird</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: schwach_ptr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = MethodHolder&lt;TObject, TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethod = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::* )( TParams... ); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCallParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class">&lt;TCallParams...&gt;() {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> THandlerPtr&lt;TCallParams...&gt;( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodEventHandler&lt;MyType, TCallParams...&gt;( m_me.lock() ) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MyType&gt; create( TObject&amp; object, TMethod method ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MyType&gt; result( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyType( object, method ) ); result-&gt;m_me = result; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: MethodHolder( TObject&amp; object, TMethod method ) : m_object( object ), m_method( method ) { assert( m_method != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } TObject&amp; m_object; TMethod m_method; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::weak_ptr&lt;MyType&gt; m_me; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MethodHolder&lt;TObject, TParams...&gt;&gt; createMethodEventHandler( TObject&amp; object, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::*method )( TParams... ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MethodHolder&lt;TObject, TParams...&gt;::create( object, method ); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aus Gründen der Übersichtlichkeit gebe ich beim Entfernen eines Handlers aus einem Ereignis eine ungefähre Reihenfolge der Ereignisse an (ich entschuldige mich für ein zufälliges Wortspiel): </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Ereignis entfernt das Element aus der Liste ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m_handlers.erase (it);</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), wodurch der Destruktor aufgerufen wird.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Destruktor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: unique_ptr wird aufgerufen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , was zu einem Aufruf des Destruktors des verwalteten Objekts führt.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Destruktor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodEventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird </font><i><font style="vertical-align: inherit;">aufgerufen</font></i><font style="vertical-align: inherit;"> , der alle Felder des Objekts löscht, einschließlich des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Felds m_methodHolder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lautet </font><font style="vertical-align: inherit;">.</font></font></li><li>   <i>std::shared_ptr</i> ;  ,      (..         )      ( <i>MethodHolder</i> );      ,     <i>std::weak_ptr</i>    ; </li><li>   <i>MethodHolder</i> ,      ,   ,  <i>m_me</i> ,  <i>std::weak_ptr</i> ; </li><li>   <i>std::weak_ptr</i> ;     ;  weil   <i>std::weak_ptr</i>   ,    ; </li><li>  Gewinn. </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist wichtig zu beachten, dass der Destruktor der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AbstractEventHandler-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse </font><font style="vertical-align: inherit;">virtuell sein muss. </font><font style="vertical-align: inherit;">Andernfalls wird nach Klausel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Klausel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AbstractEventHandler-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Destruktor aufgerufen </font><font style="vertical-align: inherit;">und weitere Aktionen werden nicht ausgeführt.</font></font><br><br><a name="Joins"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ereignis- und Handlerverbindung </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In einigen Fällen, wenn das Hinzufügen / Entfernen eines Handlers zu einem Ereignis ziemlich häufig vorkommt (gemäß einer Logik), möchten Sie nicht herumspielen und jedes Mal eine Instanz des Ereignisses und eine Instanz des Handlers abrufen, um erneut ein Abonnement / Abmelden von diesem Ereignis zu implementieren. </font><font style="vertical-align: inherit;">Aber ich möchte sie einmal verbinden und dann, falls erforderlich, mit dieser Verbindung arbeiten und einen vordefinierten Handler zu einem vordefinierten Ereignis hinzufügen / daraus entfernen. </font><font style="vertical-align: inherit;">Sie können dies wie folgt implementieren:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Types</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;AbstractEventHandler&lt;Types...&gt;&gt;;</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEvent</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandlerPtr = THandlerPtr&lt;TParams...&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isHandlerAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TEventHandlerPtr&amp; eventHandler )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandlerPtr eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandlerPtr eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerEventJoin</span></span></span><span class="hljs-class">&lt;TParams...&gt;;</span></span> . . . }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEvent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IEvent&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isHandlerAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TEventHandlerPtr&amp; eventHandler )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::shared_lock&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( findEventHandler( eventHandler ) != m_handlers.end() ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandlerPtr eventHandler )</span></span></span><span class="hljs-function"> override </span></span>{ . . . } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandlerPtr eventHandler )</span></span></span><span class="hljs-function"> override </span></span>{ . . . } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">//      'm_handlerListMutex' inline TEventHandlerIt findEventHandler( const TEventHandlerPtr&amp; eventHandler ) const { . . . } std::list&lt;TEventHandlerPtr&gt; m_handlers; mutable std::shared_mutex m_handlerListMutex; . . . };</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerEventJoin</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: HandlerEventJoin( IEvent&lt;TParams...&gt;&amp; _event, THandlerPtr&lt;TParams...&gt; handler ) : m_event( _event ), m_handler( handler ) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isJoined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_event.isHandlerAdded( m_handler ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_event.addHandler( m_handler ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unjoin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_event.removeHandler( m_handler ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: IEvent&lt;TParams...&gt;&amp; m_event; THandlerPtr&lt;TParams...&gt; m_handler; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie sehen können, wurde jetzt ein weiterer möglicher Ort zum Speichern der Instanz des Handlers hinzugefügt, sodass wir hierfür </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> anstelle von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: unique_ptr verwenden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Klasse ist für mich jedoch etwas unpraktisch. Ich möchte Verbindungsinstanzen ohne eine Liste von Parametern speichern und erstellen, die die Klassenvorlage instanziieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir implementieren dies mithilfe einer abstrakten Ahnenklasse und eines Wrappers:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventJoin</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~AbstractEventJoin() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isJoined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unjoin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: AbstractEventJoin() {} };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerEventJoin</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventJoin { . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isJoined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ . . . } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ . . . } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unjoin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ . . . } . . . };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventJoinWrapper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inline</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventJoinWrapper</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEvent</span></span></span><span class="hljs-class">&lt;TParams...&gt;&amp; _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handler</span></span></span><span class="hljs-class"> ) :</span></span> m_eventJoin( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;HandlerEventJoin&lt;TParams...&gt;&gt;( _event, HandlerCast&lt;TSome&gt;::cast&lt;TParams...&gt;( handler ) ) ) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EventJoinWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_eventJoin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ } ~EventJoinWrapper() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_eventJoin != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> m_eventJoin; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isJoined(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAssigned</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( m_eventJoin != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isJoined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( m_eventJoin != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; m_eventJoin-&gt;isJoined() ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( m_eventJoin != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ? m_eventJoin-&gt;join() : <span class="hljs-literal"><span class="hljs-literal">false</span></span> ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unjoin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( m_eventJoin != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ? m_eventJoin-&gt;unjoin() : <span class="hljs-literal"><span class="hljs-literal">false</span></span> ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: AbstractEventJoin* m_eventJoin; }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> EventJoin = EventJoinWrapper;</code> </pre><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HandlerCast</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist dieselbe unterstützende Struktur, die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwendet </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">wurde</font></a><font style="vertical-align: inherit;"> . Übrigens ist es wichtig, nicht zu vergessen, den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AbstractEventJoin-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Destruktor </font><font style="vertical-align: inherit;">virtuell </font><font style="vertical-align: inherit;">zu machen, </font><font style="vertical-align: inherit;">damit beim Löschen seiner Instanz im </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EventJoinWrapper-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Destruktor der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HandlerEventJoin-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Destruktor </font><i><font style="vertical-align: inherit;">aufgerufen wird</font></i><font style="vertical-align: inherit;"> , da sonst das Feld </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">THandlerPtr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und damit der Handler selbst </font><font style="vertical-align: inherit;">nicht zerstört werden </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Implementierung scheint praktikabel zu sein, aber nur auf den ersten Blick. Durch Kopieren oder Verschieben einer Instanz von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EventJoinWrapper</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m_eventJoin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in seinem Destruktor </font><font style="vertical-align: inherit;">erneut gelöscht </font><font style="vertical-align: inherit;">. Daher verwenden wir </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um die Instanz zu speichern</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AbstractEventJoin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sowie eine leicht optimierte Semantik der Bewegung (und des Kopierens) implementieren, weil </font><font style="vertical-align: inherit;">Dies ist eine möglicherweise häufige Operation.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventJoinWrapper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: EventJoinWrapper( EventJoinWrapper&amp;&amp; other ) : m_eventJoin( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( other.m_eventJoin ) ) { } EventJoinWrapper( EventJoinWrapper&amp; other ) : m_eventJoin( other.m_eventJoin ) { } ~EventJoinWrapper() { <span class="hljs-comment"><span class="hljs-comment">/*empty*/</span></span> } EventJoinWrapper&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( EventJoinWrapper&amp;&amp; other ) { m_eventJoin = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( other.m_eventJoin ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } EventJoinWrapper&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EventJoinWrapper&amp; other ) { m_eventJoin = other.m_eventJoin; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } . . . <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;AbstractEventJoin&gt; m_eventJoin; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie jetzt einen Handler mit einem Ereignis verbinden, können Sie sofort eine Instanz einer neuen Verbindung zurückgeben: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEvent</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventJoin</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">+=( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-function"><span class="hljs-function">EventJoin </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::forward&lt;TSome&gt;( some ) )</span></span></span></span>; result.join(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } . . . };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und nachdem Sie die dreieckige Abhängigkeit durch </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">include aufgelöst haben </font></font></i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(IEvent &lt;= EventJointWrapper.hpp; EventJointWrapper &lt;= HandlerEventJoin.hpp; HandlerEventJoin &lt;= IEvent.hpp),</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> indem Sie einige Dateien in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.h</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.hpp unterteilen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , können Sie sogar damit arbeiten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Erstellen von Verbindungsinstanzen erfolgt nach denselben Regeln wie beim Abonnieren des Ereignishandlers:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventHolder</span></span></span><span class="hljs-class"> {</span></span> TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;&gt; onEvent; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodsHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;&amp; )</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method5</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[] )</span></span></span><span class="hljs-function"> </span></span>{ EventHolder _eventHolder; MethodsHolder _methodsHolder; EventJoin join1 = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( _methodsHolder, MethodsHolder::method1 ) ); <span class="hljs-comment"><span class="hljs-comment">// ok EventJoin join2 = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( _methodsHolder, MethodsHolder::method2 ) ); // ok EventJoin join3 = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( _methodsHolder, MethodsHolder::method3 ) ); // error EventJoin join4 = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( _methodsHolder, MethodsHolder::method4 ) ); // error EventJoin join5 = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( _methodsHolder, MethodsHolder::method5 ) ); // error return 0; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Außerdem können Sie die Ereignisverarbeitung "aktivieren" / "deaktivieren" (für die im Prinzip Verbindungen erstellt wurden): </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventHolder</span></span></span><span class="hljs-class"> {</span></span> TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; onEvent; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodsHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; text, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Text '"</span></span> &lt;&lt; text &lt;&lt; <span class="hljs-string"><span class="hljs-string">"' handled "</span></span> &lt;&lt; count &lt;&lt; <span class="hljs-string"><span class="hljs-string">" times."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[] )</span></span></span><span class="hljs-function"> </span></span>{ EventHolder _eventHolder; MethodsHolder methodsHolder; EventJoin eventJoin = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( methodsHolder, MethodsHolder::handleEvent ) ); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> handlingText = <span class="hljs-string"><span class="hljs-string">"testing..."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; ++i ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( eventJoin.isJoined() ) eventJoin.unjoin(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> eventJoin.join(); _eventHolder.onEvent( handlingText, i ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-string"><span class="hljs-string">'testing...'</span></span> handled <span class="hljs-number"><span class="hljs-number">0</span></span> times. <span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-string"><span class="hljs-string">'testing...'</span></span> handled <span class="hljs-number"><span class="hljs-number">2</span></span> times. <span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-string"><span class="hljs-string">'testing...'</span></span> handled <span class="hljs-number"><span class="hljs-number">4</span></span> times. <span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-string"><span class="hljs-string">'testing...'</span></span> handled <span class="hljs-number"><span class="hljs-number">6</span></span> times. <span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-string"><span class="hljs-string">'testing...'</span></span> handled <span class="hljs-number"><span class="hljs-number">8</span></span> times.</code> </pre><br><a name="Totals"></a><h1>  Zusammenfassung </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zunächst ist anzumerken, dass die Aufgabe, einen Artikel so kurz wie möglich und kurz und bündig zu schreiben, völlig gescheitert ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich hoffe, dass die daraus resultierende Implementierung der Ereignisverarbeitung sehr funktional ist und zumindest jemandem nützlich sein wird.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein sehr umständliches Beispiel, das die Hauptmerkmale demonstriert</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;functional&gt; #include "events/event.hpp" #include "events/handler/methodeventhandler.hpp" #include "events/handler/functoreventhandler.hpp" #include "events/join/handlereventjoin.hpp" #include "events/join/eventjoinwrapper.hpp" class Foo { public: Foo() : onMake( m_onMake ), m_onMake(), m_onMakeInner(), m_makeCount( 0 ) { m_onMakeInner += FUNCTOR_HANDLER( m_onMake ); } IEvent&lt;unsigned int&gt;&amp; onMake; void make() { m_onMakeInner( m_makeCount++ ); } private: TEvent&lt;unsigned int&gt; m_onMake, m_onMakeInner; unsigned int m_makeCount; }; namespace instances { Foo&amp; getFoo() { static Foo _foo; return _foo; } } // instances struct FunctorHandler { void operator()( unsigned int makeCount ); }; void functionHandler( unsigned int makeCount ); class ClassHandler { public: void handle( unsigned int makeCount ); }; namespace instances { FunctorHandler&amp; getFunctorHandler() { static FunctorHandler _functorHandler; return _functorHandler; } std::function&lt;void( unsigned int )&gt;&amp; getStdFunctionHandler() { static std::function&lt;void( unsigned int )&gt; _stdFunctionHandler = []( unsigned int makeCount ) { std::cout &lt;&lt; "It's std::function handler" &lt;&lt; std::endl; if( makeCount &gt;= 2 ) instances::getFoo().onMake -= STD_FUNCTION_HANDLER( instances::getStdFunctionHandler() ); }; return _stdFunctionHandler; } ClassHandler&amp; getClassHandler() { static ClassHandler _classHandler; return _classHandler; } } // instances void FunctorHandler::operator()( unsigned int makeCount ) { std::cout &lt;&lt; "It's functor handler" &lt;&lt; std::endl; if( makeCount &gt;= 0 ) instances::getFoo().onMake -= FUNCTOR_HANDLER( instances::getFunctorHandler() ); } void functionHandler( unsigned int makeCount ) { std::cout &lt;&lt; "It's function handler" &lt;&lt; std::endl; if( makeCount &gt;= 3 ) instances::getFoo().onMake -= FUNCTION_HANDLER( functionHandler ); } void ClassHandler::handle( unsigned int makeCount ) { std::cout &lt;&lt; "It's method handler" &lt;&lt; std::endl; if( makeCount &gt;= 4 ) instances::getFoo().onMake -= MY_METHOD_HANDLER( ClassHandler::handle ); } int main( int argc, char* argv[] ) { Foo&amp; foo = instances::getFoo(); auto lambdaHandler = []( unsigned int ) { std::cout &lt;&lt; "It's lambda handler" &lt;&lt; std::endl; }; foo.onMake += FUNCTOR_HANDLER( instances::getFunctorHandler() ); foo.onMake += LAMBDA_HANDLER( lambdaHandler ); EventJoin lambdaJoin = foo.onMake += LAMBDA_HANDLER( ( [ &amp;foo, &amp;lambdaHandler ]( unsigned int makeCount ) { if( makeCount &gt;= 1 ) foo.onMake -= LAMBDA_HANDLER( lambdaHandler ); } ) ); foo.onMake += STD_FUNCTION_HANDLER( instances::getStdFunctionHandler() ); foo.onMake += FUNCTION_HANDLER( functionHandler ); foo.onMake += METHOD_HANDLER( instances::getClassHandler(), ClassHandler::handle ); for( int i = 0; i &lt; 6; ++i ) { std::cout &lt;&lt; "Make " &lt;&lt; i &lt;&lt; " time:" &lt;&lt; std::endl; foo.make(); std::cout &lt;&lt; std::endl; } lambdaJoin.unjoin(); return 0; }</span></span></span></span></code> </pre><br>  Fazit: <br><br><pre> <code class="hljs powershell">Make <span class="hljs-number"><span class="hljs-number">0</span></span> time: It<span class="hljs-string"><span class="hljs-string">'s functor handler It'</span></span>s lambda handler It<span class="hljs-string"><span class="hljs-string">'s std::function handler It'</span></span>s <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Make</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">1</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">time</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lambda</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">std</span></span></span><span class="hljs-function">::</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Make</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">2</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">time</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">std</span></span></span><span class="hljs-function">::</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Make</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">3</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">time</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Make</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">4</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">time</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Make</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">5</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">time</span></span></span><span class="hljs-function">:</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es ist erwähnenswert, einige wichtige Punkte zu beachten: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es wurde nicht separat angegeben, daher möchte ich erwähnen, dass das Ereignis selbst in dieser Implementierung ein Funktor ist. Dies bedeutet, dass es als Handler für ein anderes Ereignis fungieren kann. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können Sie keine konstanten Methoden (Klassenelementfunktionen) als Handler verwenden. </font><font style="vertical-align: inherit;">Ich denke, wenn eine solche Gelegenheit benötigt wird, ist es nicht schwierig, einen neuen Typ von Handler dafür zu schreiben, der auf bestehenden basiert.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Darüber hinaus wurden in der endgültigen Version einige Punkte im Artikel weggelassen, um die Sichtbarkeit und Lesbarkeit des Codes zu verbessern: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Typ des Rückgabewerts der Methode (Elementfunktion der Klasse) für den entsprechenden Handler kann beliebig sein, nicht unbedingt </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ungültig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (für Handler-Funktoren wurde dies ebenfalls durchgeführt).</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die gesamte Implementierung ist in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namespaces eingeschlossen,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> um die Verwendung in Projekten zu vereinfachen (wenn dies jemandem überflüssig erscheint, können Sie sie jederzeit entfernen).</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Noexcept-Bezeichner</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wurde an </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">einigen Stellen</font></a><font style="vertical-align: inherit;"> hinzugefügt </font><font style="vertical-align: inherit;">.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allen, die hier zumindest diagonal gelesen haben, einen niedrigen Bogen. </font><font style="vertical-align: inherit;">Ich lege den gesamten Code bei; </font><font style="vertical-align: inherit;">es kann auch hier genommen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (mit den neuesten Verbesserungen).</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ganzer Code</font></font></b> <div class="spoiler_text"><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/helpers/is_equatable.hpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;type_traits&gt; template&lt;class T&gt; class is_equatable { private: template&lt;class U&gt; static constexpr std::true_type exists( decltype( std::declval&lt;U&gt;() == std::declval&lt;U&gt;() )* = nullptr ) noexcept; template&lt;class U&gt; static constexpr std::false_type exists( ... ) noexcept; public: static constexpr bool value = decltype( exists&lt;T&gt;( nullptr ) )::value; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/handlers/abstracteventhandler.hpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"eventhandlerptr.h"</span></span></span><span class="hljs-meta"> namespace events { namespace handlers { template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class ...TParams&gt; class AbstractEventHandler { using MyType = AbstractEventHandler&lt;TParams...&gt;; public: virtual ~AbstractEventHandler() {} virtual void call( TParams... params ) = 0; bool operator==( const MyType&amp; other ) const noexcept { return isEquals( other ); } bool operator!=( const MyType&amp; other ) const noexcept { return !( *this == other ); } protected: AbstractEventHandler() {} virtual bool isEquals( const MyType&amp; other ) const noexcept = 0; }; } // handlers } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/handlers/eventhandlerptr.h</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; namespace events { namespace handlers { template&lt;class ...TParams&gt; class AbstractEventHandler; template&lt;class ...Types&gt; using TEventHandlerPtr = std::shared_ptr&lt;AbstractEventHandler&lt;Types...&gt;&gt;; } // handlers } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/handlers/functoreventhandler.hpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;assert.h&gt; #include "abstracteventhandler.hpp" #include "../helpers/is_equatable.hpp" namespace events { namespace handlers { namespace { template&lt;class TFunctor, class ...TParams&gt; struct IsFunctorParamsCompatible { private: template&lt;class TCheckedFunctor, class ...TCheckedParams&gt; static constexpr std::true_type exists( decltype( std::declval&lt;TCheckedFunctor&gt;()( std::declval&lt;TCheckedParams&gt;()... ) )* = nullptr ) noexcept; template&lt;class TCheckedFunctor, class ...TCheckedParams&gt; static constexpr std::false_type exists( ... ) noexcept; public: static constexpr bool value = decltype( exists&lt;TFunctor, TParams...&gt;( nullptr ) )::value; }; } // template&lt;class TFunctor&gt; class FunctorHolder; template&lt;class TFunctor, class ...TParams&gt; class FunctorEventHandler : public AbstractEventHandler&lt;TParams...&gt; { using MyType = FunctorEventHandler&lt;TFunctor, TParams...&gt;; using TFunctorHolderPtr = std::shared_ptr&lt;FunctorHolder&lt;TFunctor&gt;&gt;; public: FunctorEventHandler( TFunctorHolderPtr functorHolder ) : AbstractEventHandler&lt;TParams...&gt;(), m_functorHolder( functorHolder ) { assert( m_functorHolder != nullptr ); } virtual void call( TParams... params ) override { static_assert( IsFunctorParamsCompatible&lt;TFunctor, TParams...&gt;::value, "Event and functor arguments are not compatible" ); m_functorHolder-&gt;m_functor( params... ); } protected: virtual bool isEquals( const AbstractEventHandler&lt;TParams...&gt;&amp; other ) const noexcept override { const MyType* _other = dynamic_cast&lt;const MyType*&gt;( &amp;other ); return ( _other != nullptr &amp;&amp; *m_functorHolder == *_other-&gt;m_functorHolder ); } private: TFunctorHolderPtr m_functorHolder; }; namespace { template&lt;class TEqu, class TEnabled = void&gt; struct EqualityChecker; template&lt;class TEquatable&gt; struct EqualityChecker&lt;TEquatable, typename std::enable_if&lt;is_equatable&lt;TEquatable&gt;::value&gt;::type&gt; { static constexpr bool isEquals( const TEquatable&amp; operand1, const TEquatable&amp; operand2 ) noexcept { return ( operand1 == operand2 ); } }; template&lt;class TNonEquatable&gt; struct EqualityChecker&lt;TNonEquatable, typename std::enable_if&lt;!is_equatable&lt;TNonEquatable&gt;::value&gt;::type&gt; { static constexpr bool isEquals( const TNonEquatable&amp; operand1, const TNonEquatable&amp; operand2 ) noexcept { return ( &amp;operand1 == &amp;operand2 ); } }; } // template&lt;class TFunctor&gt; class FunctorHolder { using MyType = FunctorHolder&lt;TFunctor&gt;; public: template&lt;class ...TCallParams&gt; operator TEventHandlerPtr&lt;TCallParams...&gt;() { return TEventHandlerPtr&lt;TCallParams...&gt;( new FunctorEventHandler&lt;TFunctor, TCallParams...&gt;( m_me.lock() ) ); } bool operator==( const MyType&amp; other ) const noexcept { return EqualityChecker&lt;TFunctor&gt;::isEquals( m_functor, other.m_functor ); } bool operator!=( const MyType&amp; other ) const noexcept { return !( *this == other ); } template&lt;class TFunctor&gt; static std::shared_ptr&lt;MyType&gt; create( TFunctor&amp;&amp; functor ) { std::shared_ptr&lt;MyType&gt; result( new MyType( functor ) ); result-&gt;m_me = result; return result; } private: FunctorHolder( TFunctor&amp; functor ) : m_functor( functor ), m_me() { } TFunctor&amp; m_functor; std::weak_ptr&lt;MyType&gt; m_me; template&lt;class TFunctor, class ...TParams&gt; friend class FunctorEventHandler; }; template&lt;class TFunctor&gt; std::shared_ptr&lt;FunctorHolder&lt;TFunctor&gt;&gt; createFunctorEventHandler( TFunctor&amp;&amp; functor ) { return FunctorHolder&lt;TFunctor&gt;::create( functor ); } } // handlers } // events #define FUNCTOR_HANDLER( Functor ) ::events::handlers::createFunctorEventHandler( Functor ) #define LAMBDA_HANDLER( Lambda ) FUNCTOR_HANDLER( Lambda ) #define STD_FUNCTION_HANDLER( StdFunction ) FUNCTOR_HANDLER( StdFunction ) #define FUNCTION_HANDLER( Function ) FUNCTOR_HANDLER( &amp;Function )</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/handlers/methodeventhandler.hpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;assert.h&gt; #include "abstracteventhandler.hpp" namespace events { namespace handlers { namespace { template&lt;class TMethodHolder, class ...TParams&gt; struct IsMethodParamsCompatible { private: template&lt;class TCheckedMethodHolder, class ...TCheckedParams&gt; static constexpr std::true_type exists( decltype( ( std::declval&lt;TCheckedMethodHolder&gt;().m_object.*std::declval&lt;TCheckedMethodHolder&gt;().m_method )( std::declval&lt;TCheckedParams&gt;()... ) )* = nullptr ) noexcept; template&lt;class TCheckedMethodHolder, class ...TCheckedParams&gt; static constexpr std::false_type exists( ... ) noexcept; public: static constexpr bool value = decltype( exists&lt;TMethodHolder, TParams...&gt;( nullptr ) )::value; }; } // template&lt;class TMethodHolder, class ...TParams&gt; class MethodEventHandler : public AbstractEventHandler&lt;TParams...&gt; { using MyType = MethodEventHandler&lt;TMethodHolder, TParams...&gt;; using TMethodHolderPtr = std::shared_ptr&lt;TMethodHolder&gt;; public: MethodEventHandler( TMethodHolderPtr methodHolder ) : AbstractEventHandler&lt;TParams...&gt;(), m_methodHolder( methodHolder ) { assert( m_methodHolder != nullptr ); } virtual void call( TParams... params ) override { static_assert( IsMethodParamsCompatible&lt;TMethodHolder, TParams...&gt;::value, "Event and method arguments are not compatible" ); ( m_methodHolder-&gt;m_object.*m_methodHolder-&gt;m_method )( params... ); } protected: virtual bool isEquals( const AbstractEventHandler&lt;TParams...&gt;&amp; other ) const noexcept override { const MyType* _other = dynamic_cast&lt;const MyType*&gt;( &amp;other ); return ( _other != nullptr &amp;&amp; *m_methodHolder == *_other-&gt;m_methodHolder ); } private: TMethodHolderPtr m_methodHolder; }; template&lt;class TObject, class TResult, class ...TParams&gt; class MethodHolder { using MyType = MethodHolder&lt;TObject, TResult, TParams...&gt;; using TMethod = TResult( TObject::* )( TParams... ); public: template&lt;class ...TCallParams&gt; operator TEventHandlerPtr&lt;TCallParams...&gt;() { return TEventHandlerPtr&lt;TCallParams...&gt;( new MethodEventHandler&lt;MyType, TCallParams...&gt;( m_me.lock() ) ); } bool operator==( const MyType&amp; other ) const noexcept { return ( &amp;m_object == &amp;other.m_object &amp;&amp; m_method == other.m_method ); } bool operator!=( const MyType&amp; other ) const noexcept { return !( *this == other ); } template&lt;class TObject, class ...TParams&gt; static std::shared_ptr&lt;MyType&gt; create( TObject&amp; object, TMethod method ) { std::shared_ptr&lt;MyType&gt; result( new MyType( object, method ) ); result-&gt;m_me = result; return result; } private: MethodHolder( TObject&amp; object, TMethod method ) : m_object( object ), m_method( method ) { assert( m_method != nullptr ); } TObject&amp; m_object; TMethod m_method; std::weak_ptr&lt;MyType&gt; m_me; template&lt;class TMethodHolder, class ...TParams&gt; friend class MethodEventHandler; template&lt;class TMethodHolder, class ...TParams&gt; friend struct IsMethodParamsCompatible; }; template&lt;class TObject, class TResult, class ...TParams&gt; std::shared_ptr&lt;MethodHolder&lt;TObject, TResult, TParams...&gt;&gt; createMethodEventHandler( TObject&amp; object, TResult( TObject::*method )( TParams... ) ) { return MethodHolder&lt;TObject, TResult, TParams...&gt;::create( object, method ); } } // handlers } // events #define METHOD_HANDLER( Object, Method ) ::events::handlers::createMethodEventHandler( Object, &amp;Method ) #define MY_METHOD_HANDLER( Method ) METHOD_HANDLER( *this, Method )</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/handlers/handlercast.hpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include "eventhandlerptr.h" namespace events { namespace handlers { template&lt;class TSome&gt; struct HandlerCast { template&lt;class ...Types&gt; static constexpr TEventHandlerPtr&lt;Types...&gt; cast( TSome&amp; some ) { return static_cast&lt;TEventHandlerPtr&lt;Types...&gt;&gt;( some ); } }; template&lt;class TPtr&gt; struct HandlerCast&lt;std::shared_ptr&lt;TPtr&gt;&gt; { template&lt;class ...Types&gt; static constexpr TEventHandlerPtr&lt;Types...&gt; cast( std::shared_ptr&lt;TPtr&gt; some ) { return HandlerCast&lt;TPtr&gt;::cast&lt;Types...&gt;( *some ); } }; } // handlers } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/event.hpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;type_traits&gt; #include &lt;list&gt; #include &lt;memory&gt; #include &lt;shared_mutex&gt; #include &lt;algorithm&gt; #include &lt;assert.h&gt; #include "handlers/abstracteventhandler.hpp" #include "handlers/eventhandlerptr.h" #include "handlers/handlercast.hpp" #include "joins/eventjoinwrapper.hpp" namespace events { namespace joins { template&lt;class ...TParams&gt; class HandlerEventJoin; } template&lt;class ...TParams&gt; class IEvent { public: template&lt;class TSome&gt; EventJoin operator+=( TSome&amp;&amp; some ) { EventJoin result( *this, std::forward&lt;TSome&gt;( some ) ); result.join(); return result; } template&lt;class TSome&gt; bool operator-=( TSome&amp;&amp; some ) { return removeHandler( handlers::HandlerCast&lt;TSome&gt;::cast&lt;TParams...&gt;( some ) ); } protected: using TMyEventHandlerPtr = handlers::TEventHandlerPtr&lt;TParams...&gt;; IEvent() {} virtual bool isHandlerAdded( const TMyEventHandlerPtr&amp; eventHandler ) const = 0; virtual bool addHandler( TMyEventHandlerPtr eventHandler ) = 0; virtual bool removeHandler( TMyEventHandlerPtr eventHandler ) = 0; friend class joins::HandlerEventJoin&lt;TParams...&gt;; }; template&lt;class ...TParams&gt; class TEvent : public IEvent&lt;TParams...&gt; { using TEventHandlerIt = typename std::list&lt;TMyEventHandlerPtr&gt;::const_iterator; public: TEvent() : m_handlers(), m_currentIt(), m_isCurrentItRemoved( false ), m_handlerListMutex() { } void operator()( TParams... params ) { m_handlerListMutex.lock_shared(); m_isCurrentItRemoved = false; m_currentIt = m_handlers.begin(); while( m_currentIt != m_handlers.end() ) { m_handlerListMutex.unlock_shared(); ( *m_currentIt )-&gt;call( params... ); m_handlerListMutex.lock_shared(); if( m_isCurrentItRemoved ) { m_isCurrentItRemoved = false; TEventHandlerIt removedIt = m_currentIt; ++m_currentIt; deleteHandler( removedIt ); } else { ++m_currentIt; } } m_handlerListMutex.unlock_shared(); } protected: virtual bool isHandlerAdded( const TMyEventHandlerPtr&amp; eventHandler ) const override { std::shared_lock&lt;std::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); return ( findEventHandler( eventHandler ) != m_handlers.end() ); } virtual bool addHandler( TMyEventHandlerPtr eventHandler ) override { std::unique_lock&lt;std::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); if( findEventHandler( eventHandler ) == m_handlers.end() ) { m_handlers.push_back( std::move( eventHandler ) ); return true; } return false; } virtual bool removeHandler( TMyEventHandlerPtr eventHandler ) override { std::unique_lock&lt;std::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); auto it = findEventHandler( eventHandler ); if( it != m_handlers.end() ) { if( it == m_currentIt ) m_isCurrentItRemoved = true; else deleteHandler( it ); return true; } return false; } private: //      'm_handlerListMutex' inline TEventHandlerIt findEventHandler( const TMyEventHandlerPtr&amp; eventHandler ) const noexcept { return std::find_if( m_handlers.cbegin(), m_handlers.cend(), [ &amp;eventHandler ]( const TMyEventHandlerPtr&amp; oneHandler ) { return ( *oneHandler == *eventHandler ); } ); } //      'm_handlerListMutex' inline void deleteHandler( TEventHandlerIt it ) { m_handlers.erase( it ); } std::list&lt;TMyEventHandlerPtr&gt; m_handlers; //    'm_handlerListMutex' mutable TEventHandlerIt m_currentIt; mutable bool m_isCurrentItRemoved; mutable std::shared_mutex m_handlerListMutex; }; } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">./events/joins/abstracteventjoin.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once namespace events { namespace joins { class AbstractEventJoin { public: virtual ~AbstractEventJoin(); virtual bool isJoined() const = 0; virtual bool join() = 0; virtual bool unjoin() = 0; protected: AbstractEventJoin(); }; } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// joins } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">./events/joins/abstracteventjoin.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"abstracteventjoin.h"</span></span></span><span class="hljs-meta"> namespace events { namespace joins { AbstractEventJoin::AbstractEventJoin() { } AbstractEventJoin::~AbstractEventJoin() { } } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// joins } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">./events/joins/handlereventjoin.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"abstracteventjoin.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../handlers/eventhandlerptr.h"</span></span></span><span class="hljs-meta"> namespace events { template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class ...TParams&gt; class IEvent; namespace joins { template&lt;class ...TParams&gt; class HandlerEventJoin : public AbstractEventJoin { public: HandlerEventJoin( IEvent&lt;TParams...&gt;&amp; _event, ::events::handlers::TEventHandlerPtr&lt;TParams...&gt; handler ) : AbstractEventJoin(), m_event( _event ), m_handler( handler ) { } virtual inline bool isJoined() const override; virtual inline bool join() override; virtual inline bool unjoin() override; private: IEvent&lt;TParams...&gt;&amp; m_event; ::events::handlers::TEventHandlerPtr&lt;TParams...&gt; m_handler; }; } // joins } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">./events/joins/handlereventjoin.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"handlereventjoin.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../event.hpp"</span></span></span><span class="hljs-meta"> namespace events { namespace joins { template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class ...TParams&gt; bool HandlerEventJoin&lt;TParams...&gt;::isJoined() const { return m_event.isHandlerAdded( m_handler ); } template&lt;class ...TParams&gt; bool HandlerEventJoin&lt;TParams...&gt;::join() { return m_event.addHandler( m_handler ); } template&lt;class ...TParams&gt; bool HandlerEventJoin&lt;TParams...&gt;::unjoin() { return m_event.removeHandler( m_handler ); } } // joins } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">./events/joins/eventjoinwrapper.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include "../handlers/eventhandlerptr.h" namespace events { template&lt;class ...TParams&gt; class IEvent; namespace joins { class AbstractEventJoin; class EventJoinWrapper { public: template&lt;class TSome, class ...TParams&gt; inline EventJoinWrapper( IEvent&lt;TParams...&gt;&amp; _event, TSome&amp;&amp; handler ); constexpr EventJoinWrapper() noexcept; EventJoinWrapper( EventJoinWrapper&amp;&amp; other ) noexcept; EventJoinWrapper( EventJoinWrapper&amp; other ) noexcept; EventJoinWrapper&amp; operator=( EventJoinWrapper&amp;&amp; other ) noexcept; EventJoinWrapper&amp; operator=( const EventJoinWrapper&amp; other ) noexcept; operator bool() const; bool isAssigned() const; bool isJoined() const; bool join(); bool unjoin(); private: std::shared_ptr&lt;AbstractEventJoin&gt; m_eventJoin; }; } // joins using EventJoin = joins::EventJoinWrapper; } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">./events/joins/eventjoinwrapper.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"eventjoinwrapper.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"handlereventjoin.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../handlers/handlercast.hpp"</span></span></span><span class="hljs-meta"> namespace events { namespace joins { template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class TSome, class ...TParams&gt; EventJoinWrapper::EventJoinWrapper( IEvent&lt;TParams...&gt;&amp; _event, TSome&amp;&amp; handler ) : m_eventJoin( std::make_shared&lt;HandlerEventJoin&lt;TParams...&gt;&gt;( _event, ::events::handlers::HandlerCast&lt;TSome&gt;::cast&lt;TParams...&gt;( handler ) ) ) { } } // joins } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">./events/joins/eventjoinwrapper.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"eventjoinwrapper.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;type_traits&gt; #include "abstracteventjoin.h" namespace events { namespace joins { constexpr EventJoinWrapper::EventJoinWrapper() noexcept : m_eventJoin( nullptr ) { } EventJoinWrapper::EventJoinWrapper( EventJoinWrapper&amp;&amp; other ) noexcept : m_eventJoin( std::move( other.m_eventJoin ) ) { } EventJoinWrapper::EventJoinWrapper( EventJoinWrapper&amp; other ) noexcept : m_eventJoin( other.m_eventJoin ) { } EventJoinWrapper&amp; EventJoinWrapper::operator=( EventJoinWrapper&amp;&amp; other ) noexcept { m_eventJoin = std::move( other.m_eventJoin ); return *this; } EventJoinWrapper&amp; EventJoinWrapper::operator=( const EventJoinWrapper&amp; other ) noexcept { m_eventJoin = other.m_eventJoin; return *this; } EventJoinWrapper::operator bool() const { return isJoined(); } bool EventJoinWrapper::isAssigned() const { return ( m_eventJoin != nullptr ); } bool EventJoinWrapper::isJoined() const { return ( m_eventJoin != nullptr &amp;&amp; m_eventJoin-&gt;isJoined() ); } bool EventJoinWrapper::join() { return ( m_eventJoin != nullptr ? m_eventJoin-&gt;join() : false ); } bool EventJoinWrapper::unjoin() { return ( m_eventJoin != nullptr ? m_eventJoin-&gt;unjoin() : false ); } } // joins } // events</span></span></span></span></code> </pre><br></div></div><br></div></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD1. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier und früher im Artikel wird unter </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VC ++ 14</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> geschriebener Code </font><i><font style="vertical-align: inherit;">angegeben</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Aus Gründen der Kompatibilität mit anderen Compilern ist es besser, den Code vom Link zu übernehmen. </font><font style="vertical-align: inherit;">Besonderer Dank geht an </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cheater</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für die Kompatibilität mit dem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GCC</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><a name="ThreadRev"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD2. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lexxmark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sah</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ein Loch in das Gewinde in Bezug auf mehrere gleichzeitige Ereignisse Anrufe.</font></font><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kleinere Verbesserungen</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeHelper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandlerPtr = handlers::TEventHandlerPtr&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandlerIt = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;TEventHandlerPtr&gt;::const_iterator; }; } <span class="hljs-comment"><span class="hljs-comment">// template&lt;class ...TParams&gt; class IEvent { . . . protected: using TMyEventHandlerPtr = typename TypeHelper&lt;TParams...&gt;::TEventHandlerPtr; . . . }; namespace { template&lt;class ...TParams&gt; struct EventCore { using TMyHandlerPtr = typename TypeHelper&lt;TParams...&gt;::TEventHandlerPtr; std::list&lt;TMyHandlerPtr&gt; handlers; mutable std::shared_mutex coreMutex; }; template&lt;class ...TParams&gt; class HandlerRunner { using TMyEventCore = EventCore&lt;TParams...&gt;; using TMyHandlerIt = typename TypeHelper&lt;TParams...&gt;::TEventHandlerIt; public: HandlerRunner( TMyEventCore&amp; eventCore ) : m_eventCore( eventCore ), currentIt(), wasRemoving( false ) { } void run( TParams... params ) { m_eventCore.coreMutex.lock_shared(); currentIt = m_eventCore.handlers.begin(); wasRemoving = false; while( currentIt != m_eventCore.handlers.end() ) { m_eventCore.coreMutex.unlock_shared(); ( *currentIt )-&gt;call( params... ); m_eventCore.coreMutex.lock_shared(); if( wasRemoving ) wasRemoving = false; else ++currentIt; } m_eventCore.coreMutex.unlock_shared(); } TMyHandlerIt currentIt; mutable bool wasRemoving; private: TMyEventCore&amp; m_eventCore; }; } // template&lt;class ...TParams&gt; class TEvent : public IEvent&lt;TParams...&gt; { using TMyEventHandlerPtr = typename TypeHelper&lt;TParams...&gt;::TEventHandlerPtr; using TMyEventHandlerIt = typename TypeHelper&lt;TParams...&gt;::TEventHandlerIt; using TMyHandlerRunner = HandlerRunner&lt;TParams...&gt;; public: TEvent() : m_core() { } void operator()( TParams... params ) { TMyHandlerRunner newHandlerRunner( m_core ); m_core.coreMutex.lock_shared(); auto it = m_handlerRunners.insert( m_handlerRunners.end(), &amp;newHandlerRunner ); m_core.coreMutex.unlock_shared(); newHandlerRunner.run( params... ); m_core.coreMutex.lock_shared(); m_handlerRunners.erase( it ); m_core.coreMutex.unlock_shared(); } protected: virtual bool isHandlerAdded( const TMyEventHandlerPtr&amp; eventHandler ) const override { std::shared_lock&lt;std::shared_mutex&gt; _coreMutexLock( m_core.coreMutex ); return ( findEventHandler( eventHandler ) != m_core.handlers.end() ); } virtual bool addHandler( TMyEventHandlerPtr eventHandler ) override { std::unique_lock&lt;std::shared_mutex&gt; _coreMutexLock( m_core.coreMutex ); if( findEventHandler( eventHandler ) == m_core.handlers.end() ) { m_core.handlers.push_back( std::move( eventHandler ) ); return true; } return false; } virtual bool removeHandler( TMyEventHandlerPtr eventHandler ) override { std::unique_lock&lt;std::shared_mutex&gt; _coreMutexLock( m_core.coreMutex ); auto it = findEventHandler( eventHandler ); if( it != m_core.handlers.end() ) { for( TMyHandlerRunner* oneHandlerRunner : m_handlerRunners ) { if( it == oneHandlerRunner-&gt;currentIt ) { ++oneHandlerRunner-&gt;currentIt; oneHandlerRunner-&gt;wasRemoving = true; } } m_core.handlers.erase( it ); return true; } return false; } private: //      'm_core.coreMutex' inline TMyEventHandlerIt findEventHandler( const TMyEventHandlerPtr&amp; eventHandler ) const { return std::find_if( m_core.handlers.cbegin(), m_core.handlers.cend(), [ &amp;eventHandler ]( const TMyEventHandlerPtr&amp; oneHandler ) { return ( *oneHandler == *eventHandler ); } ); } EventCore&lt;TParams...&gt; m_core; std::list&lt;TMyHandlerRunner*&gt; m_handlerRunners; };</span></span></code> </pre><br>        (,  ,     )    <i>HandlerRunner</i> ,       . ,     : <i>currentIt</i> (    )  <i>wasRemoving</i> (,        ).   <i>HandlerRunner'</i>          <i>operator()</i> ;        (,  )  ,    <i>EventCore</i> .  T.O.      ,   ,        ,     ,         ,       . <br></div></div><a name="HolderImprovement"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD3. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dank </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isnullxbh</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wurde ein weiterer Fehler gefunden. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist mit einer unsachgemäßen Speicherung und dem anschließenden Zugriff auf Objekte verbunden, die von </font><i><font style="vertical-align: inherit;">rvalue übergeben werden</font></i><font style="vertical-align: inherit;"> (hauptsächlich Lambda-Ausdrücke).</font></font><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Korrektur</font></font></b> <div class="spoiler_text">     ,   <i>lvalue</i> ,  <i>lvalue</i> -,  ,   <i>rvalue</i> ,   (,  ).      : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectSaver</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LValue</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectSaver</span></span></span><span class="hljs-class">&lt;LValue&amp;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TObject = LValue&amp;; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RValue</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectSaver</span></span></span><span class="hljs-class">&lt;RValue&amp;&amp;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TObject = RValue; };</code> </pre><br>  <i>Holder</i>           ( <i>lvalue</i>  <i>rvalue</i> ),        ,  «»     .     <i>type erasing</i> (   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ).   ,   <i>Holder'</i>   . <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TBase</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractInnerHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~AbstractInnerHolder() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> TBase&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> TBase&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const_cast</span></span>&lt;AbstractInnerHolder&lt;TBase&gt;&amp;&gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ).get(); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TBase</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TInner</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TInnerHolder</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractInnerHolder&lt;TBase&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TInnerObject = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ObjectSaver&lt;TInner&gt;::TObject; TInnerHolder( TInner _inner ) : AbstractInnerHolder&lt;TBase&gt;(), inner( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TInner&gt;( _inner ) ) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> TBase&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;TBase&amp;&gt;( inner ); } TInnerObject inner; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TAssignBase</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgInner</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractInnerHolder</span></span></span><span class="hljs-class">&lt;TAssignBase&gt;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">createInnerHolder</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgInner</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inner</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TAssignInner = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>( inner ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TInnerHolder&lt;TAssignBase, TAssignInner&gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgInner&gt;( inner ) ); }</code> </pre><br>      <i>Holder'</i> .    <i>MethodHolder'</i> . <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TResult</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodHolder</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = MethodHolder&lt;TObject, TResult, TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethod = TResult( TObject::* )( TParams... ); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ~MethodHolder() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> &amp;m_innerHolder; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &amp;m_innerHolder.get() == &amp;other.m_innerHolder.get() &amp;&amp; m_method == other.m_method ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgObject</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MyType&gt; create( TArgObject&amp;&amp; object, TMethod method ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MyType&gt; result( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyType( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgObject&gt;( object ), method ) ); result-&gt;m_me = result; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgObject</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodHolder</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgObject</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TMethod</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">method</span></span></span><span class="hljs-class"> ) :</span></span> m_innerHolder( createInnerHolder&lt;TObject&gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgObject&gt;( object ) ) ), m_method( method ) { assert( m_method != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } AbstractInnerHolder&lt;TObject&gt;&amp; m_innerHolder; TMethod m_method; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::weak_ptr&lt;MyType&gt; m_me; . . . };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TMethodHolder</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsMethodParamsCompatible</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedMethodHolder</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-function"><span class="hljs-function">true_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decltype</span></span></span></span><span class="hljs-function"><span class="hljs-params">( ( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TCheckedMethodHolder&gt;().m_innerHolder.get().*</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TCheckedMethodHolder&gt;().m_method )( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TCheckedParams&gt;()... ) )* = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; . . . }; } <span class="hljs-comment"><span class="hljs-comment">// template&lt;class TMethodHolder, class ...TParams&gt; class MethodEventHandler : public AbstractEventHandler&lt;TParams...&gt; { public: virtual void call( TParams... params ) override { static_assert( IsMethodParamsCompatible&lt;TMethodHolder, TParams...&gt;::value, "Event and method arguments are not compatible" ); ( m_methodHolder-&gt;m_innerHolder.get().*m_methodHolder-&gt;m_method )( params... ); } private: TMethodHolderPtr m_methodHolder; . . . };</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TResult</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MethodHolder&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::decay&lt;TObject&gt;::type, TResult, TParams...&gt;&gt; createMethodEventHandler( TObject&amp;&amp; object, TResult( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::decay&lt;TObject&gt;::type::*method )( TParams... ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MethodHolder&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::decay&lt;TObject&gt;::type, TResult, TParams...&gt;::create( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TObject&gt;( object ), method ); }</code> </pre><br>  Fertig. <i>FunctorHolder</i>   .        .    -    . <br></div></div><br><a name="Qt"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PS Vergleich mit dem Qt-Signal / Slot-Mechanismus </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich denke, ich werde mich nicht irren, wenn ich sage, dass </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ein sehr verbreitetes Framework für die Entwicklung in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Unter anderem verfügt es über </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen eigenen Ereignisverarbeitungsmechanismus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , bei dem Signale als Analoga von Ereignissen und Slots als Analoga von Handlern vorhanden sind. </font><font style="vertical-align: inherit;">Es wird mit dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta-Object Compiler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementiert </font><font style="vertical-align: inherit;">, der Teil des globaleren </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta-Object-Systems ist</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das wiederum mit dem in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> über </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwendeten </font><font style="vertical-align: inherit;">Add-On </font><font style="vertical-align: inherit;">implementiert wird </font><font style="vertical-align: inherit;">.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Merkmale beider Implementierungen: </font></font></h4><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Fähigkeit, Signale (Ereignisse) mit Methoden (Mitgliedsfunktionen), Funktoren und Funktionen zu verbinden; </font></font></li><li>     ()  (),        ( <i>lvalue</i> , <i>rvalue</i> ); </li><li>      (  ); </li><li>    ()      (   ). </li></ul><br><h4>  <i>Qt</i> : </h4><br><ul><li> <i>   ;</i> <br>  <i>Qt</i>          ;     «»,  ,     « »  ;   ,        ; ,       ; <br></li><li> <i>    ;</i> <br>   <i>Qt</i>          (    )      (    );        ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Qt::UniqueConnection</a> ;      ,        ,  ,  <i>Qt</i>        ; <br></li><li> <i>     ,   ;</i> <br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Qt::QueuedConnection</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Qt::BlockingQueuedConnection</a>     ;      ()       ;          ();    ,         ,         ;  d.h.   ,           ; ,       . <br></li></ul><br><h4>  <i>Qt</i> : </h4><br><ul><li> <i>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">QObject</a> ;</i> <br>    , ,   <i>QObject</i> ,     ,  ,    ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> : <i>Virtual inheritance with QObject is not supported.</i> );    ,   ,  ; <br></li><li> <i>   template';</i> <br>        ,     <i>public</i> - <i>QObject</i> ;     <i>moc'</i> ; ,    <br><div class="spoiler"> <b class="spoiler_title">,</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QObject&gt; class AbstractProperty : public QObject { Q_OBJECT protected: AbstractProperty(); signals: void valueChanged(); }; template&lt;class TSource&gt; class TProperty : public AbstractProperty { public: TProperty( const TSource&amp; value = TSource() ) : AbstractProperty(), m_value( value ) { } const TSource&amp; value() const { return m_value; } void setValue( const TSource&amp; newValue ) { if( newValue != m_value ) { m_value = newValue; emit valueChanged(); } } private: TSource m_value; };</span></span></span></span></code> </pre><br>  ,  <i>valueChanged</i>    (  ,  )  ,        . <br></div></div> ,   ,     ; <br></li><li> <strike><i>     .cpp-;</i></strike> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ; <br></li><li> <i>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">QMetaObject::Connection</a> ;</i> <br>    ,  <i>Qt</i>   (   )    ,    ;      ()   ,    ,           ;            ,          ;  <i>Qt</i>     ; <br></li><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwendung von zusätzlich generiertem </font><font style="vertical-align: inherit;">Code durch </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">moc</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist bereits völlig subjektiv, aber die Entscheidung ist, wo für jede Klasse, die Signale und Slots verwendet (Slots sind nicht immer), mehrere (pro Datei für jede Konfiguration) generierte Dateien vorhanden sind, die einige Unannehmlichkeiten verursachen. </font><font style="vertical-align: inherit;">aber um ehrlich zu sein, ist dies der kleinste Fehler.</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist wichtig anzumerken, dass dieser Vergleich mit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dennoch sehr subjektiv ist und nicht darauf abzielt, diesen Rahmen zu erhöhen oder zu verurteilen. </font><font style="vertical-align: inherit;">Es muss beachtet werden, dass </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zusätzlich zum Signal- / Slot-Mechanismus </font><font style="vertical-align: inherit;">eine hervorragende Funktionalität bietet, sowohl unter Verwendung dieses Mechanismus als auch unabhängig davon. </font><font style="vertical-align: inherit;">In jedem Fall liegt es immer an Ihnen, zu entscheiden, was Sie verwenden und was nicht.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424593/">https://habr.com/ru/post/de424593/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424583/index.html">Sie werden kein Held, wenn Sie ein Entwickler sind</a></li>
<li><a href="../de424585/index.html">CryEngine 5.5 von Crytek veröffentlicht</a></li>
<li><a href="../de424587/index.html">Zusammenfassung des Buches "Verkäufe an große Unternehmen"</a></li>
<li><a href="../de424589/index.html">So melden Sie sich für ein PhD-Programm für maschinelles Lernen an</a></li>
<li><a href="../de424591/index.html">Es gibt kein Ideal: wie ich nach einer Programmiersprache für mich gesucht habe</a></li>
<li><a href="../de424595/index.html">MVC + Szenario gegen Fat Controller</a></li>
<li><a href="../de424597/index.html">Interview mit dem Sprecher der RubyRussia-Konferenz Marcus Schirp</a></li>
<li><a href="../de424599/index.html">Sie müssen auswählen, welche Software Sie benötigen: pünktlich geschrieben oder von hoher Qualität</a></li>
<li><a href="../de424601/index.html">Informationsarchitektur im Internet Teil 1</a></li>
<li><a href="../de424603/index.html">Das Buch „Warum liegen wir falsch? Denkfallen in Aktion. “ Auszüge Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>