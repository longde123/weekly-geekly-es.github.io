<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üàÅ üê® üë®‚Äçüë©‚Äçüëß‚Äçüëß .NET-Referenztypen im Vergleich zu Werttypen. Teil 2 üëè üé´ üë®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Objektbasistyp und die Implementierung von Schnittstellen. Boxen 


 Es scheint, wir sind durch die H√∂lle und das Hochwasser gekommen und k√∂nnen j...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET-Referenztypen im Vergleich zu Werttypen. Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/439490/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img width="350" align="left" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png"></a> </p><br><h2 id="the-object-base-type-and-implementation-of-interfaces-boxing">  Der Objektbasistyp und die Implementierung von Schnittstellen.  Boxen </h2><br><p>  Es scheint, wir sind durch die H√∂lle und das Hochwasser gekommen und k√∂nnen jedes Interview festhalten, auch das f√ºr das .NET CLR-Team.  Gehen wir jedoch nicht zu microsoft.com und suchen nach offenen Stellen.  Jetzt m√ºssen wir verstehen, wie Werttypen ein Objekt erben, wenn sie weder einen Verweis auf SyncBlockIndex noch einen Zeiger auf eine virtuelle Methodentabelle enthalten.  Dies wird unser Typensystem vollst√§ndig erkl√§ren und alle Teile eines Puzzles werden ihren Platz finden.  Wir brauchen jedoch mehr als einen Satz. </p><br><p>  Erinnern wir uns nun noch einmal daran, wie Werttypen im Speicher zugewiesen werden.  Sie bekommen den Ort in Erinnerung genau dort, wo sie sind.  Referenztypen werden auf dem Haufen kleiner und gro√üer Objekte zugeordnet.  Sie geben immer einen Verweis auf die Stelle auf dem Haufen an, an der sich das Objekt befindet.  Jeder Werttyp verf√ºgt √ºber Methoden wie ToString, Equals und GetHashCode.  Sie sind virtuell und √ºberschreibbar, erlauben jedoch nicht, einen Werttyp durch √úberschreiben von Methoden zu erben.  Wenn Werttypen √ºberschreibbare Methoden verwenden, ben√∂tigen sie eine virtuelle Methodentabelle, um Aufrufe weiterzuleiten.  Dies w√ºrde zu den Problemen f√ºhren, Strukturen an eine nicht verwaltete Welt weiterzugeben: zus√§tzliche Felder w√ºrden dorthin gehen.  Infolgedessen gibt es irgendwo Beschreibungen von Werttypmethoden, auf die Sie jedoch nicht direkt √ºber eine virtuelle Methodentabelle zugreifen k√∂nnen. </p><br><p>  Dies k√∂nnte die Idee bringen, dass der Mangel an Vererbung k√ºnstlich ist </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Dieses Kapitel wurde vom Autor und von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">professionellen √úbersetzern</a> gemeinsam aus dem Russischen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºbersetzt</a> .  Sie k√∂nnen uns bei der √úbersetzung von Russisch oder Englisch in eine andere Sprache helfen, haupts√§chlich ins Chinesische oder Deutsche. <br><br>  Wenn Sie sich bei uns bedanken m√∂chten, k√∂nnen Sie dies am besten tun, indem Sie uns einen Stern auf Github geben oder das Repository teilen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><a name="habracut"></a><br><p>  Dies k√∂nnte die Idee bringen, dass der Mangel an Vererbung k√ºnstlich ist: </p><br><ul><li>  es gibt Vererbung von einem Objekt, aber nicht direkt; </li><li> Innerhalb eines Basistyps befinden sich ToString, Equals und GetHashCode.  In Werttypen haben diese Methoden ihr eigenes Verhalten.  Dies bedeutet, dass Methoden in Bezug auf ein <code>object</code> √ºberschrieben <code>object</code> . </li><li>  Wenn Sie einen Typ in ein <code>object</code> umwandeln, haben Sie au√üerdem das volle Recht, ToString, Equals und GetHashCode aufzurufen. </li><li>  Beim Aufrufen einer Instanzmethode f√ºr einen Werttyp erh√§lt die Methode eine andere Struktur, die eine Kopie eines Originals ist.  Das Aufrufen einer Instanzmethode entspricht dem Aufrufen einer statischen Methode: <code>Method(ref structInstance, newInternalFieldValue)</code> .  Dieser Aufruf besteht <code>this</code> mit einer Ausnahme.  Eine JIT sollte den Hauptteil einer Methode kompilieren, sodass es nicht erforderlich w√§re, Strukturfelder zu versetzen und √ºber den Zeiger auf eine virtuelle Methodentabelle zu springen, die in der Struktur nicht vorhanden ist.  <em>Es existiert f√ºr Werttypen an einer anderen Stelle</em> . </li></ul><br><p>  Das Verhalten der Typen ist unterschiedlich, aber dieser Unterschied ist auf der Ebene der Implementierung in der CLR nicht so gro√ü.  Wir werden etwas sp√§ter dar√ºber sprechen. </p><br><p>  Schreiben wir die folgende Zeile in unser Programm: </p><br><pre> <code class="plaintext hljs">var obj = (object)10;</code> </pre> <br><p>  Es wird uns erm√∂glichen, mit Nummer 10 unter Verwendung einer Basisklasse umzugehen.  Dies nennt man Boxen.  Das hei√üt, wir haben eine VMT, um virtuelle Methoden wie ToString (), Equals und GetHashCode aufzurufen.  In Wirklichkeit erstellt das Boxen eine Kopie eines Werttyps, jedoch keinen Zeiger auf ein Original.  Dies liegt daran, dass wir den urspr√ºnglichen Wert √ºberall speichern k√∂nnen: auf dem Stapel oder als Feld einer Klasse.  Wenn wir es in einen Objekttyp umwandeln, k√∂nnen wir einen Verweis auf diesen Wert so lange speichern, wie wir m√∂chten.  Wenn Boxen passiert: </p><br><ul><li>  Die CLR reserviert Speicherplatz auf dem Heap f√ºr eine Struktur + SyncBlockIndex + VMT eines Werttyps (zum Aufrufen von ToString, GetHashCode, Equals). </li><li>  Dort wird eine Instanz eines Werttyps kopiert. </li></ul><br><p>  Jetzt haben wir eine Referenzvariante eines Werttyps.  Eine Struktur hat <strong>absolut die gleichen Systemfelder wie ein Referenztyp</strong> . <br>  nach dem Boxen ein vollwertiger Referenztyp werden.  Die Struktur wurde eine Klasse.  Nennen wir es einen .NET-Salto.  Dies ist ein fairer Name. </p><br><p>  Schauen Sie sich nur an, was passiert, wenn Sie eine Struktur verwenden, die eine Schnittstelle mit derselben Schnittstelle implementiert. </p><br><pre> <code class="plaintext hljs">struct Foo : IBoo { int x; void Boo() { x = 666; } } IBoo boo = new Foo(); boo.Boo();</code> </pre> <br><p>  Wenn wir die Foo-Instanz erstellen, geht ihr Wert tats√§chlich an den Stapel.  Dann setzen wir diese Variable in eine Schnittstellestypvariable und die Struktur in eine Referenztypvariable.  Als n√§chstes gibt es Boxen und wir haben den Objekttyp als Ausgabe.  Es handelt sich jedoch um eine Variable vom Typ Schnittstelle.  Das hei√üt, wir brauchen eine Typkonvertierung.  Der Anruf erfolgt also folgenderma√üen: </p><br><pre> <code class="plaintext hljs">IBoo boo = (IBoo)(box_to_object)new Foo(); boo.Boo();</code> </pre> <br><p>  Das Schreiben eines solchen Codes ist nicht effektiv.  Sie m√ºssen eine Kopie anstelle eines Originals √§ndern: </p><br><pre> <code class="plaintext hljs">void Main() { var foo = new Foo(); foo.a = 1; Console.WriteLite(foo.a); // -&gt; 1 IBoo boo = foo; boo.Boo(); // looks like changing foo.a to 10 Console.WriteLite(foo.a); // -&gt; 1 } struct Foo: IBoo { public int a; public void Boo() { a = 10; } } interface IBoo { void Boo(); }</code> </pre> <br><p>  Wenn wir uns den Code zum ersten Mal ansehen, m√ºssen wir nicht wissen, womit wir uns im Code befassen, <em>au√üer in unserem eigenen,</em> und eine Besetzung der IBoo-Oberfl√§che sehen.  Dies l√§sst uns denken, dass Foo eine Klasse und keine Struktur ist.  Dann gibt es keine visuelle Trennung in Strukturen und Klassen, was uns zum Nachdenken bringt <br>  Die Ergebnisse der Schnittstellenmodifikation m√ºssen in foo eingehen, was nicht der Fall ist, da boo eine Kopie von foo ist.  Das ist irref√ºhrend.  Meiner Meinung nach sollte dieser Code Kommentare erhalten, damit andere Entwickler damit umgehen k√∂nnen. </p><br><p>  Die zweite Sache bezieht sich auf die vorherigen Gedanken, dass wir einen Typ von einem Objekt in IBoo umwandeln k√∂nnen.  Dies ist ein weiterer Beweis daf√ºr, dass ein Boxed-Value-Typ eine Referenzvariante eines Werttyps ist.  Oder alle Typen in einem Typsystem sind Referenztypen.  Wir k√∂nnen einfach mit Strukturen wie mit Werttypen arbeiten und ihren Wert vollst√§ndig √ºbergeben.  Dereferenzieren eines Zeigers auf ein Objekt, wie Sie es in der Welt von C ++ sagen w√ºrden. </p><br><p>  Sie k√∂nnen einwenden, dass wenn es wahr w√§re, es so aussehen w√ºrde: </p><br><pre> <code class="plaintext hljs">var referenceToInteger = (IInt32)10;</code> </pre> <br><p>  Wir w√ºrden nicht nur ein Objekt erhalten, sondern eine typisierte Referenz f√ºr einen Boxed-Value-Typ.  Dies w√ºrde die gesamte Idee der Werttypen (dh die Integrit√§t ihres Wertes) zerst√∂ren und eine gro√üartige Optimierung basierend auf ihren Eigenschaften erm√∂glichen.  Nehmen wir diese Idee auf! </p><br><pre> <code class="plaintext hljs">public sealed class Boxed&lt;T&gt; { public T Value; [MethodImpl(MethodImplOptions.AggressiveInlining)] public override bool Equals(object obj) { return Value.Equals(obj); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public override string ToString() { return Value.ToString(); } [MethodImpl(MethodImplOptions.AggressiveInlining)] public override int GetHashCode() { return Value.GetHashCode(); } }</code> </pre> <br><p>  Wir haben ein komplettes Analogon zum Boxen.  Wir k√∂nnen den Inhalt jedoch √§ndern, indem wir Instanzmethoden aufrufen.  Diese √Ñnderungen wirken sich auf alle Teile aus, die auf diese Datenstruktur verweisen. </p><br><pre> <code class="plaintext hljs">var typedBoxing = new Boxed&lt;int&gt; { Value = 10 }; var pureBoxing = (object)10;</code> </pre> <br><p>  Die erste Variante ist nicht sehr attraktiv.  Anstatt einen Typ zu gie√üen, schaffen wir Unsinn.  Die zweite Zeile ist viel besser, aber die beiden Zeilen sind fast identisch.  Der einzige Unterschied besteht darin, dass w√§hrend des √ºblichen Boxens nach dem Zuweisen von Speicher auf dem Heap keine Speicherbereinigung mit Nullen erfolgt.  Die notwendige Struktur nimmt den Speicher sofort in Anspruch, w√§hrend die erste Variante gereinigt werden muss.  Dadurch arbeitet es um 10% l√§nger als das √ºbliche Boxen. </p><br><p>  Stattdessen k√∂nnen wir einige Methoden f√ºr unseren Boxwert aufrufen. </p><br><pre> <code class="plaintext hljs">struct Foo { public int x; public void ChangeTo(int newx) { x = newx; } } var boxed = new Boxed&lt;Foo&gt; { Value = new Foo { x = 5 } }; boxed.Value.ChangeTo(10); var unboxed = boxed.Value;</code> </pre> <br><p>  Wir haben ein neues Instrument.  √úberlegen wir, was wir damit machen k√∂nnen. </p><br><ul><li>  Unser Typ <code>Boxed&lt;T&gt;</code> macht dasselbe wie der √ºbliche Typ: Ordnet Speicher auf dem Heap zu, √ºbergibt dort einen Wert und erm√∂glicht das Abrufen, indem eine Art Unbox ausgef√ºhrt wird. </li><li>  Wenn Sie einen Verweis auf eine Boxstruktur verlieren, wird dieser vom GC erfasst. </li><li>  Wir k√∂nnen jetzt jedoch mit einem Box-Typ arbeiten, dh seine Methoden aufrufen. </li><li>  Wir k√∂nnen auch eine Instanz eines Werttyps in SOH / LOH durch eine andere ersetzen.  Wir konnten es vorher nicht tun, da wir das Unboxing durchf√ºhren, die Struktur in eine andere √§ndern und zur√ºckboxen m√ºssten, um den Kunden einen neuen Verweis zu geben. </li></ul><br><p>  Das Hauptproblem des Boxens ist die Erzeugung von Verkehr im Speicher.  Der Verkehr mit unbekannter Anzahl von Objekten, von denen ein Teil bis zur ersten Generation √ºberleben kann, wo wir Probleme mit der Speicherbereinigung bekommen.  Es wird viel M√ºll geben und wir h√§tten es vermeiden k√∂nnen.  Wenn wir jedoch den Verkehr von kurzlebigen Objekten haben, ist die erste L√∂sung das Pooling.  Dies ist ein ideales Ende von .NET Salto. </p><br><pre> <code class="plaintext hljs">var pool = new Pool&lt;Boxed&lt;Foo&gt;&gt;(maxCount:1000); var boxed = pool.Box(10); boxed.Value=70; // use boxed value here pool.Free(boxed);</code> </pre> <br><p>  Jetzt kann das Boxen mit einem Pool funktionieren, der den Speicherverkehr beim Boxen eliminiert.  Wir k√∂nnen sogar Objekte in der Finalisierungsmethode wieder zum Leben erwecken und sich wieder in den Pool zur√ºckversetzen.  Dies kann n√ºtzlich sein, wenn eine Box-Struktur einen anderen asynchronen Code als Ihren verwendet und Sie nicht verstehen k√∂nnen, wann dies unn√∂tig wurde.  In diesem Fall kehrt es w√§hrend der GC zum Pool zur√ºck. </p><br><p>  Lassen Sie uns schlie√üen: </p><br><ul><li>  Wenn das Boxen versehentlich ist und nicht passieren sollte, lassen Sie es nicht passieren.  Dies kann zu Leistungsproblemen f√ºhren. </li><li>  Wenn f√ºr die Architektur eines Systems Boxen erforderlich ist, kann es Varianten geben.  Wenn der Verkehr von Boxstrukturen gering und fast unsichtbar ist, k√∂nnen Sie Boxen verwenden.  Wenn der Datenverkehr sichtbar ist, m√∂chten Sie m√∂glicherweise das Boxen mit einer der oben genannten L√∂sungen zusammenfassen.  Es verbraucht einige Ressourcen, sorgt aber daf√ºr, dass GC ohne √úberlastung funktioniert. </li></ul><br><p>  Schauen wir uns letztendlich einen v√∂llig unpraktischen Code an: </p><br><pre> <code class="plaintext hljs">static unsafe void Main() { // here we create boxed int object boxed = 10; // here we get the address of a pointer to a VMT var address = (void**)EntityPtr.ToPointerWithOffset(boxed); unsafe { // here we get a Virtual Methods Table address var structVmt = typeof(SimpleIntHolder).TypeHandle.Value.ToPointer(); // change the VMT address of the integer passed to Heap into a VMT SimpleIntHolder, turning Int into a structure *address = structVmt; } var structure = (IGetterByInterface)boxed; Console.WriteLine(structure.GetByInterface()); } interface IGetterByInterface { int GetByInterface(); } struct SimpleIntHolder : IGetterByInterface { public int value; int IGetterByInterface.GetByInterface() { return value; } }</code> </pre> <br><p>  Der Code verwendet eine kleine Funktion, die einen Zeiger von einer Referenz auf ein Objekt erhalten kann.  Die Bibliothek ist unter der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github-Adresse</a> verf√ºgbar.  Dieses Beispiel zeigt, dass das √ºbliche Boxen int in einen typisierten Referenztyp verwandelt.  Lass uns gehen <br>  Schauen Sie sich die Schritte im Prozess an: </p><br><ol><li>  Boxen Sie f√ºr eine ganze Zahl. </li><li>  Rufen Sie die Adresse eines erhaltenen Objekts ab (die Adresse von Int32 VMT). </li><li>  Holen Sie sich die VMT eines SimpleIntHolder </li><li>  Ersetzen Sie die VMT einer Boxed Integer durch die VMT einer Struktur. </li><li>  Machen Sie das Unboxing zu einem Strukturtyp </li><li>  Zeigen Sie den Feldwert auf dem Bildschirm an und erhalten Sie den Int32 <br>  verpackt. </li></ol><br><p>  Ich mache es absichtlich √ºber die Schnittstelle, da ich zeigen m√∂chte, dass es funktionieren wird <br>  auf diese Weise. </p><br><h3 id="nullablet">  Nullable \ &lt;T&gt; </h3><br><p>  Erw√§hnenswert ist das Verhalten des Boxens mit nullbaren Werttypen.  Diese Funktion von Nullable-Werttypen ist sehr attraktiv, da das Boxen eines Werttyps, der eine Art Null ist, Null zur√ºckgibt. </p><br><pre> <code class="plaintext hljs">int? x = 5; int? y = null; var boxedX = (object)x; // -&gt; 5 var boxedY = (object)y; // -&gt; null</code> </pre> <br><p>  Dies f√ºhrt uns zu einer eigent√ºmlichen Schlussfolgerung: Da null keinen Typ hat, ist der <br>  Der einzige Weg, um einen Typ zu erhalten, der sich vom Box-Typ unterscheidet, ist der folgende: </p><br><pre> <code class="plaintext hljs">int? x = null; var pseudoBoxed = (object)x; double? y = (double?)pseudoBoxed;</code> </pre> <br><p>  Der Code funktioniert nur, weil Sie einen Typ nach Belieben umwandeln k√∂nnen <br>  mit null. </p><br><h2 id="going-deeper-in-boxing">  Tiefer im Boxen </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abschlie√üend</a> m√∂chte ich Ihnen noch etwas √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Typ System.Enum</a> erz√§hlen.  Logischerweise sollte dies ein Werttyp sein, da es sich um eine √ºbliche Aufz√§hlung handelt: Aliasing von Zahlen auf Namen in einer Programmiersprache.  System.Enum ist jedoch ein Referenztyp.  Alle in Ihrem Feld sowie in .NET Framework definierten Enum-Datentypen werden von System.Enum geerbt.  Es ist ein Klassendatentyp.  Dar√ºber hinaus handelt es sich um eine abstrakte Klasse, die von <code>System.ValueType</code> geerbt wurde. </p><br><pre> <code class="plaintext hljs"> [Serializable] [System.Runtime.InteropServices.ComVisible(true)] public abstract class Enum : ValueType, IComparable, IFormattable, IConvertible { // ... }</code> </pre> <br><p>  Bedeutet dies, dass alle Aufz√§hlungen auf dem SOH zugeordnet sind und wenn wir sie verwenden, √ºberladen wir den Heap und den GC?  Eigentlich nein, da wir sie nur benutzen.  Dann nehmen wir an, dass es irgendwo einen Pool von Aufz√§hlungen gibt und wir nur ihre Instanzen erhalten.  Nein, schon wieder.  Sie k√∂nnen beim Marshalling Aufz√§hlungen in Strukturen verwenden.  Aufz√§hlungen sind √ºbliche Zahlen. </p><br><p>  Die Wahrheit ist, dass CLR die Datentypstruktur beim Bilden hackt, wenn <a href="">eine Klasse in einen Werttyp umgewandelt wird</a> : </p><br><pre> <code class="plaintext hljs">// Check to see if the class is a valuetype; but we don't want to mark System.Enum // as a ValueType. To accomplish this, the check takes advantage of the fact // that System.ValueType and System.Enum are loaded one immediately after the // other in that order, and so if the parent MethodTable is System.ValueType and // the System.Enum MethodTable is unset, then we must be building System.Enum and // so we don't mark it as a ValueType. if(HasParent() &amp;&amp; ((g_pEnumClass != NULL &amp;&amp; GetParentMethodTable() == g_pValueTypeClass) || GetParentMethodTable() == g_pEnumClass)) { bmtProp-&gt;fIsValueClass = true; HRESULT hr = GetMDImport()-&gt;GetCustomAttributeByName(bmtInternal-&gt;pType-&gt;GetTypeDefToken(), g_CompilerServicesUnsafeValueTypeAttribute, NULL, NULL); IfFailThrow(hr); if (hr == S_OK) { SetUnsafeValueClass(); } }</code> </pre> <br><p>  Warum das tun?  Insbesondere wegen der Idee der Vererbung - um eine angepasste Aufz√§hlung zu erstellen, m√ºssen Sie beispielsweise die Namen m√∂glicher Werte angeben.  Es ist jedoch unm√∂glich, Werttypen zu erben.  Daher haben Entwickler es als Referenztyp entworfen, der es beim Kompilieren in einen Werttyp verwandeln kann. </p><br><h2 id="what-if-you-want-to-see-boxing-personally">  Was ist, wenn Sie das Boxen pers√∂nlich sehen m√∂chten? </h2><br><p>  Gl√ºcklicherweise m√ºssen Sie keinen Disassembler verwenden und in den Code-Dschungel gelangen.  Wir haben die Texte des gesamten .NET-Plattformkerns und viele davon sind in Bezug auf .NET Framework CLR und CoreCLR identisch.  Sie k√∂nnen auf die unten stehenden Links klicken und die Implementierung des Boxens sofort sehen: </p><br><ul><li>  Es gibt eine separate Gruppe von Optimierungen, von denen jede a verwendet <br>  spezifischer Prozessortyp: <br><ul><li>  <em><a href="">JIT_BoxFastMP_InlineGetThread</a></em> <br>  (AMD64 - Multiprozessor- oder Server-GC, impliziter lokaler Thread-Speicher) </li><li>  <em><a href="">JIT_BoxFastMP</a></em> <br>  (AMD64 - Multiprozessor oder Server GC) </li><li>  <em><a href="">JIT_BoxFastUP</a></em> <br>  (AMD64 - Einzelprozessor oder Workstation GC) </li><li>  <em><a href="">JIT_TrialAlloc :: GenBox (..)</a></em> <br>  (x86) √ºber JitHelpers verbunden </li></ul></li><li>  In allgemeinen F√§llen leitet eine JIT einen Aufruf einer Hilfsfunktion ein <br>  <a href="">Compiler :: impImportAndPushBox (..)</a> </li><li>  Generische Version verwendet weniger optimiert <br>  <a href="">MethodTable :: Box (..)</a> <br><ul><li>  Schlie√ülich wird [CopyValueClassUnchecked (..)] aufgerufen <br>  ( <a href="">https://github.com/dotnet/coreclr/blob/master/src/vm/object.cpp#L1514-L1581</a> ). <br>  Der Code zeigt, warum es besser ist, Strukturen mit einer Gr√∂√üe von bis zu 8 Byte auszuw√§hlen. </li></ul></li></ul><br><p>  Hier wird die einzige Methode zum Entpacken verwendet: <br>  <em><a href="">JIT_Unbox (..)</a></em> , ein Wrapper um <em><a href="">JIT_Unbox_Helper (..)</a></em> . </p><br><p>  Interessant ist auch, dass ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://stackoverflow.com/questions/3743762/unboxing-does-not-create-a-copy-of-the-value-is-this-right</a> ) Unboxing nicht das Kopieren bedeutet Daten auf den Haufen.  Boxen bedeutet, einen Zeiger auf den Heap zu √ºbergeben, w√§hrend die Kompatibilit√§t der Typen getestet wird.  Der IL-Opcode nach dem Entpacken definiert die Aktionen mit dieser Adresse.  Die Daten k√∂nnen zum Aufrufen einer Methode in eine lokale Variable oder in den Stapel kopiert werden.  Andernfalls h√§tten wir eine doppelte Kopie;  zuerst beim Kopieren vom Heap an einen anderen Ort und dann beim Kopieren an den Zielort. </p><br><h2 id="questions">  Fragen </h2><br><h3 id="why-net-clr-cant-do-pooling-for-boxing-itself">  Warum kann .NET CLR kein Pooling f√ºr das Boxen selbst durchf√ºhren? </h3><br><p>  Wenn wir mit einem Java-Entwickler sprechen, wissen wir zwei Dinge: </p><br><ul><li>  Alle Werttypen in Java sind eingerahmt, dh sie sind im Wesentlichen keine Werttypen.  Ganzzahlen werden ebenfalls eingerahmt. </li><li>  Aus Optimierungsgr√ºnden werden alle Ganzzahlen von -128 bis 127 aus dem Objektpool entnommen. </li></ul><br><p>  Warum passiert dies in .NET CLR w√§hrend des Boxens nicht?  Es ist einfach.  Da wir den Inhalt eines Boxed-Value-Typs √§ndern k√∂nnen, k√∂nnen wir Folgendes tun: </p><br><pre> <code class="plaintext hljs">object x = 1; x.GetType().GetField("m_value", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(x, 138); Console.WriteLine(x); // -&gt; 138</code> </pre> <br><p>  Oder so (C ++ / CLI): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object^ obj)</span></span></span><span class="hljs-function"> </span></span>{ Int32^ i = (Int32^)obj; *i = <span class="hljs-number"><span class="hljs-number">138</span></span>; }</code> </pre> <br><p>  Wenn wir uns mit Pooling befassen w√ºrden, w√ºrden wir alle in der Anwendung auf 138 √§ndern, was nicht gut ist. </p><br><p>  Das n√§chste ist die Essenz von Werttypen in .NET.  Sie besch√§ftigen sich mit Wert, was bedeutet, dass sie schneller arbeiten.  Boxen ist selten und das Hinzuf√ºgen von Boxnummern geh√∂rt zur Welt der Fantasie und der schlechten Architektur.  Dies ist √ºberhaupt nicht n√ºtzlich. </p><br><h3 id="why-it-is-not-possible-to-do-boxing-on-stack-instead-of-the-heap-when-you-call-a-method-that-takes-an-object-type-which-is-a-value-type-in-fact">  Warum ist es nicht m√∂glich, anstelle des Heaps auf dem Stapel zu boxen, wenn Sie eine Methode aufrufen, die einen Objekttyp annimmt, der tats√§chlich ein Werttyp ist? </h3><br><p>  Wenn das Boxen des Werttyps auf dem Stapel ausgef√ºhrt wird und die Referenz auf den Heap verschoben wird, kann die Referenz in der Methode an eine andere Stelle verschoben werden. Beispielsweise kann eine Methode die Referenz in das Feld einer Klasse einf√ºgen.  Die Methode wird dann gestoppt und die Methode, die das Boxen gemacht hat, wird ebenfalls gestoppt.  Infolgedessen zeigt die Referenz auf einen Totraum auf dem Stapel. </p><br><h3 id="why-it-is-not-possible-to-use-value-type-as-a-field">  Warum ist es nicht m√∂glich, den Werttyp als Feld zu verwenden? </h3><br><p>  Manchmal m√∂chten wir eine Struktur als Feld einer anderen Struktur verwenden, die die erste verwendet.  Oder einfacher: Verwenden Sie Struktur als Strukturfeld.  Fragen Sie mich nicht, warum dies n√ºtzlich sein kann.  Es kann nicht.  Wenn Sie eine Struktur als Feld oder durch Abh√§ngigkeit von einer anderen Struktur verwenden, erstellen Sie eine Rekursion, dh eine Struktur mit unendlicher Gr√∂√üe.  In .NET Framework gibt es jedoch einige Stellen, an denen Sie dies tun k√∂nnen.  Ein Beispiel ist <code>System.Char</code> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das sich selbst enth√§lt</a> : </p><br><pre> <code class="plaintext hljs">public struct Char : IComparable, IConvertible { // Member Variables internal char m_value; //... }</code> </pre> <br><p>  Alle primitiven CLR-Typen sind auf diese Weise entworfen.  Wir, blo√üe Sterbliche, k√∂nnen dieses Verhalten nicht umsetzen.  Dar√ºber hinaus brauchen wir das nicht: Es wird getan, um primitiven Typen in CLR einen OOP-Geist zu verleihen. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Dieser Charper wurde von professionellen √úbersetzern aus dem Russischen wie aus der Sprache des Autors <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºbersetzt</a> .  Sie k√∂nnen uns bei der Erstellung einer √ºbersetzten Version dieses Textes in eine andere Sprache, einschlie√ülich Chinesisch oder Deutsch, unter Verwendung der russischen und englischen Textversion als Quelle helfen. <br><br>  Wenn Sie "Danke" sagen m√∂chten, k√∂nnen Sie uns am besten einen Stern auf Github oder Forking Repository geben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/sidristij/dotnetbook</a> <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439490/">https://habr.com/ru/post/de439490/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439480/index.html">Nachgeben oder warum verlangsamt sich Ihr CRM (und CRM)?</a></li>
<li><a href="../de439482/index.html">devleads - (un) finanzielle Motivation</a></li>
<li><a href="../de439484/index.html">Abrufen von Aufz√§hlungsdaten in einer Automapper-Perspektive</a></li>
<li><a href="../de439486/index.html">.NET-Referenztypen im Vergleich zu Werttypen. Teil 1</a></li>
<li><a href="../de439488/index.html">QA Meetup Videoaufzeichnung</a></li>
<li><a href="../de439492/index.html">10 Tipps f√ºr einen guten technischen Vorsprung</a></li>
<li><a href="../de439496/index.html">So erfolgt die Abrechnung dort: Wenn Kunde und Entwickler unterschiedliche Sprachen sprechen</a></li>
<li><a href="../de439498/index.html">Auf welcher Hardware soll ein riesiger Informationsschacht analysiert werden?</a></li>
<li><a href="../de439500/index.html">Warum sind Captchas so kompliziert geworden?</a></li>
<li><a href="../de439502/index.html">Undefiniertes Verhalten und Wahrheit nicht definiert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>