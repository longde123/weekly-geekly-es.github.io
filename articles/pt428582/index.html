<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∏üèº ü§ô üçì Hist√≥ria esquecida de OOP üñ•Ô∏è üà∑Ô∏è ü•£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A maioria dos paradigmas de programa√ß√£o que usamos hoje foi estudada matematicamente nos anos 30, usando as id√©ias do c√°lculo lambda e da m√°quina de T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hist√≥ria esquecida de OOP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/428582/"> A maioria dos paradigmas de programa√ß√£o que usamos hoje foi estudada matematicamente nos anos 30, usando as id√©ias do c√°lculo lambda e da m√°quina de Turing, que s√£o variantes do modelo de computa√ß√£o universal (sistemas formalizados que podem executar c√°lculos de uso geral).  A tese de Church-Turing mostrou que o c√°lculo lambda e as m√°quinas de Turing s√£o funcionalmente equivalentes.  Ou seja, estamos falando sobre o fato de que tudo o que pode ser calculado usando uma m√°quina de Turing tamb√©m pode ser calculado usando o c√°lculo lambda e vice-versa. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/hq/so/jp/hqsojpds8ed1zxx9g7lelnfknbu.jpeg"></a> <br><a name="habracut"></a><br>  Existe um equ√≠voco comum de que as m√°quinas de Turing podem calcular tudo o que pode ser calculado.  Existem classes de problemas (por exemplo, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">problema de parar</a> ) que podem ser computados usando m√°quinas de Turing apenas em alguns casos.  Quando a palavra ‚Äúcomput√°vel‚Äù √© usada neste texto, significa ‚Äúcomputavelmente por uma m√°quina de Turing‚Äù. <br><br>  O c√°lculo Lambda demonstra a abordagem da aplica√ß√£o de fun√ß√µes em c√°lculos de cima para baixo.  Uma m√°quina de fita Turing √© uma abordagem imperativa (passo a passo) da computa√ß√£o, implementada de baixo para cima. <br><br>  As linguagens de programa√ß√£o de baixo n√≠vel, como c√≥digo de m√°quina ou assembler, apareceram na d√©cada de 1940 e, no final da d√©cada de 1950, surgiram as primeiras linguagens populares de alto n√≠vel que implementavam abordagens funcionais e imperativas.  Portanto, dialetos da linguagem Lisp ainda s√£o amplamente utilizados, entre eles Clojure, Scheme, AutoLisp e assim por diante.  Nos anos 50, idiomas como FORTRAN e COBOL apareceram.  Eles s√£o exemplos de linguagens imperativas de alto n√≠vel que ainda est√£o vivas.  Embora se deva notar que os idiomas da fam√≠lia C, na maioria das √°reas, substitu√≠ram o COBOL e o FORTRAN. <br><br>  As ra√≠zes da programa√ß√£o imperativa e funcional est√£o na matem√°tica formal da computa√ß√£o, elas apareceram diante dos computadores digitais.  A Programa√ß√£o Orientada a Objetos (OOP), veio depois, se origina na revolu√ß√£o da programa√ß√£o estrutural, que ocorreu nas d√©cadas de sessenta e setenta do s√©culo passado. <br><br>  O primeiro objeto que eu conhecia foi usado por Ivan Sutherland em seu fat√≠dico aplicativo Sketchpad, criado entre 1961 e 1962, que ele descreveu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste</a> trabalho em 1963.  Os objetos eram caracteres gr√°ficos exibidos na tela do oscilosc√≥pio (talvez seja a primeira vez na hist√≥ria do uso de um monitor gr√°fico de computador) que ap√≥ie a heran√ßa por meio de delegados din√¢micos, que Ivan Sutherland chamou de "mestres" em seu trabalho.  Qualquer objeto pode se tornar um objeto mestre, inst√¢ncias adicionais do objeto foram chamadas de "ocorr√™ncias".  Isso fez do sistema Sketchpad o propriet√°rio da primeira das famosas linguagens de programa√ß√£o que implementaram a heran√ßa de prot√≥tipo. <br><br>  A primeira linguagem de programa√ß√£o, comumente conhecida como "orientada a objetos", foi a linguagem Simula, cujas especifica√ß√µes foram desenvolvidas em 1965.  Como o Sketchpad, Silmula previa o trabalho com objetos, mas tamb√©m inclu√≠a classes, heran√ßa baseada em classes, subclasses e m√©todos virtuais. <br><br>  <i><font color="#999999">Um m√©todo virtual √© um m√©todo definido em uma classe projetada para ser redefinida por subclasses.</font></i>  <i><font color="#999999">Os m√©todos virtuais permitem que os programas invoquem m√©todos que podem n√£o existir no momento em que o c√≥digo √© compilado, usando o despacho din√¢mico para determinar qual m√©todo espec√≠fico deve ser chamado durante a execu√ß√£o do programa.</font></i>  <i><font color="#999999">O JavaScript possui tipos din√¢micos e usa uma cadeia de delega√ß√£o para determinar qual m√©todo chamar.Como resultado, essa linguagem n√£o precisa introduzir o conceito de m√©todos virtuais para programadores.</font></i>  <i><font color="#999999">Em outras palavras, todos os m√©todos em JavaScript usam despacho em tempo de execu√ß√£o; como resultado, os m√©todos em JavaScript n√£o precisam ser declarados "virtuais" para oferecer suporte a esse recurso.</font></i> <br><br><h2>  <font color="#3AC1EF">Opini√£o do pai do POO sobre POO</font> </h2><br>  <i><font color="#999999">"Eu cunhei o termo" orientado a objetos "e posso dizer que n√£o quis dizer C ++."</font></i>  <i><font color="#999999">Alan Kay, Confer√™ncia OOPSLA, 1997.</font></i> <br><br>  Alan Kay cunhou o termo "programa√ß√£o orientada a objetos", referindo-se √† linguagem de programa√ß√£o Smalltalk (1972).  Esse idioma foi desenvolvido por Alan Kay, Dan Ingles e outros funcion√°rios do Xerox PARC Research Center como parte do projeto do dispositivo Dynabook.  Smalltalk era mais orientado a objetos que Simula.  No Smalltalk, tudo √© um objeto, incluindo classes, n√∫meros inteiros e blocos (fechamentos).  A implementa√ß√£o inicial da linguagem, Smalltalk-72, n√£o teve a capacidade de subclasse.  Esse recurso apareceu no Smalltalk-76. <br><br>  Embora o Smalltalk apoiasse as classes e, como resultado, subclasse, o Smalltalk n√£o colocava essas id√©ias em primeiro plano.  Era uma linguagem funcional que Lisp influenciou tanto quanto Simula.  De acordo com Alan Kay, tratar as classes como um mecanismo de reutiliza√ß√£o de c√≥digo √© um erro.  O setor de programa√ß√£o presta muita aten√ß√£o √† cria√ß√£o de subclasses, distraindo as vantagens reais da programa√ß√£o orientada a objetos. <br><br>  JavaScript e Smalltalk t√™m muito em comum.  Eu diria que o JavaScript √© a vingan√ßa de Smalltalk no mundo por entender mal os conceitos de OOP.  Ambos os idiomas suportam os seguintes recursos: <br><br><ul><li>  Objetos </li><li>  Fun√ß√µes e fechamentos de primeira classe. </li><li>  Tipos din√¢micos. </li><li>  Associa√ß√£o tardia (fun√ß√µes e m√©todos podem ser substitu√≠dos durante a execu√ß√£o do programa). </li><li>  POO sem um sistema de heran√ßa baseado em classe. </li></ul><br>  <i><font color="#999999">‚ÄúLamento ter encontrado o termo‚Äú objetos ‚Äùpara esse fen√¥meno h√° muito tempo, pois seu uso leva ao fato de que muitas pessoas d√£o import√¢ncia prim√°ria a uma id√©ia que n√£o √© t√£o importante quanto a principal.</font></i>  <i><font color="#999999">A ideia principal √© enviar mensagens. ‚Äù</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  Em uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">correspond√™ncia por</a> email de 2003, Alan Kay esclareceu o que tinha em mente quando chamou Smalltalk de "uma linguagem orientada a objetos". <br><br>  <i><font color="#999999">"Para mim, OOP significa apenas mensagens, armazenamento local e prote√ß√£o, estado de oculta√ß√£o e liga√ß√£o muito tarde".</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  Em outras palavras, de acordo com as id√©ias de Alan Kay, os ingredientes mais importantes da POO s√£o os seguintes: <br><br><ul><li>  Mensagens </li><li>  Encapsulamento. </li><li>  Liga√ß√£o din√¢mica. </li></ul><br>  √â importante notar que Alan Kay, o homem que inventou o termo ‚ÄúPOO‚Äù e o trouxe √†s massas, n√£o considerou a heran√ßa e o polimorfismo os componentes mais importantes da POO. <br><br><h2>  <font color="#3AC1EF">A ess√™ncia do OOP</font> </h2><br>  A combina√ß√£o de mensagens e encapsulamento serve a v√°rios prop√≥sitos importantes: <br><br><ul><li>  Evitando o estado mut√°vel compartilhado de um objeto, encapsulando o estado e isolando outros objetos das altera√ß√µes locais em seu estado.  A √∫nica maneira de influenciar o estado de outro objeto √© pedir que ele mude (em vez de dar um comando a ele) enviando uma mensagem a ele.  As altera√ß√µes de estado s√£o monitoradas no n√≠vel local, celular, o estado n√£o √© disponibilizado para outros objetos. </li><li>  Separa√ß√£o de objetos um do outro.  O remetente da mensagem √© fracamente acoplado ao destinat√°rio por meio da API do sistema de mensagens. </li><li>  Adaptabilidade e resist√™ncia a mudan√ßas durante a execu√ß√£o do programa atrav√©s de liga√ß√£o tardia.  A adapta√ß√£o √†s mudan√ßas durante a execu√ß√£o do programa oferece muitas vantagens significativas, que Alan Kay considerou muito importantes para a OOP. </li></ul><br>  As fontes de inspira√ß√£o para Alan Kay, que expressou essas id√©ias, foram seus conhecimentos de biologia e o que ele sabia sobre a ARPANET (esta √© uma vers√£o inicial da Internet).  Ou seja, estamos falando de c√©lulas biol√≥gicas e de computadores individuais conectados √† rede.  Mesmo assim, Alan Kay imaginou como os programas s√£o executados em computadores enormes e distribu√≠dos (a Internet), enquanto computadores individuais agem como c√©lulas biol√≥gicas, trabalhando independentemente com seu pr√≥prio estado isolado e trocando dados com outros computadores enviando mensagens. <br><br>  <i><font color="#999999">"Eu percebi que uma met√°fora para uma c√©lula ou computador ajudaria a se livrar dos dados [...]".</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  Dizendo "ajudar a se livrar dos dados", Alan Kay, √© claro, estava ciente dos problemas causados ‚Äã‚Äãpelo estado mut√°vel compartilhado e da forte conectividade causada pelo compartilhamento de dados.  Hoje, esses t√≥picos s√£o amplamente ouvidos.  Por√©m, no final dos anos 60, os programadores da ARPANET estavam descontentes com a necessidade de escolher uma representa√ß√£o de modelo de dados para seus programas antes de desenvolv√™-los.  Os desenvolvedores queriam se afastar dessa pr√°tica, porque, antecipadamente, se dirigindo √† estrutura determinada pela apresenta√ß√£o dos dados, √© mais dif√≠cil mudar alguma coisa no futuro. <br><br>  O problema era que diferentes maneiras de apresentar os dados exigidos, para acesso a eles, c√≥digo diferente e sintaxe diferente nas linguagens de programa√ß√£o usadas em algum momento.  O Santo Graal aqui seria uma maneira universal de acessar e gerenciar dados.  Se todos os dados ficassem iguais para o programa, isso resolveria muitos problemas dos desenvolvedores em rela√ß√£o ao desenvolvimento e manuten√ß√£o de programas. <br>  Alan Kay tentou "se livrar" da id√©ia, segundo a qual dados e programas eram, em certo sentido, entidades independentes.  Eles n√£o s√£o considerados como tais na Lista ou no Smalltalk.  N√£o h√° separa√ß√£o entre o que pode ser feito com dados (com valores, vari√°veis, estruturas de dados etc.) e constru√ß√µes de software como fun√ß√µes.  As fun√ß√µes s√£o "cidad√£os de primeira classe" e os programas podem mudar durante sua execu√ß√£o.  Em outras palavras, o Smalltalk n√£o possui um relacionamento especial e privilegiado com os dados. <br><br>  Alan Kay, al√©m disso, considerava objetos como estruturas alg√©bricas, que davam garantias definidas e matematicamente comprov√°veis ‚Äã‚Äãde seu comportamento. <br><br>  <i><font color="#999999">"Minha forma√ß√£o matem√°tica me permitiu entender que cada objeto pode ter v√°rios modelos alg√©bricos associados a ele, que pode haver grupos inteiros de modelos semelhantes e que eles podem ser muito, muito √∫teis."</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  Ficou provado que sim, e isso serviu de base para objetos, como promessas e lentes, al√©m disso, a teoria das categorias foi influenciada por ambos. <br>  A natureza alg√©brica de como Alan Kay viu os objetos permitiria que os objetos fornecessem verifica√ß√£o formal, comportamento determin√≠stico e melhorassem a capacidade de teste, uma vez que os modelos alg√©bricos s√£o, em ess√™ncia, opera√ß√µes que obedecem a v√°rias regras na forma de equa√ß√µes. <br><br>  No jarg√£o dos programadores, ‚Äúmodelos alg√©bricos‚Äù s√£o abstra√ß√µes criadas a partir de fun√ß√µes (opera√ß√µes) que s√£o acompanhadas por certas regras, impostas por testes de unidade que essas fun√ß√µes devem passar (axiomas, equa√ß√µes). <br><br>  Essas id√©ias foram esquecidas por d√©cadas na maioria das linguagens orientadas a objetos da fam√≠lia C, incluindo C ++, Java, C # e assim por diante.  Mas essas id√©ias come√ßam a busca pela jornada de retorno, nas vers√µes recentes das linguagens orientadas a objetos mais usadas. <br><br>  Nesta ocasi√£o, algu√©m pode dizer que o mundo da programa√ß√£o redescobre os benef√≠cios da programa√ß√£o funcional e fornece argumentos racionais no contexto de linguagens orientadas a objetos. <br><br>  Como o JavaScript e o Smalltalk, as linguagens orientadas a objetos mais modernas est√£o se tornando cada vez mais "multiparadigma".  N√£o h√° raz√£o para escolher entre programa√ß√£o funcional e OOP.  Quando analisamos a ess√™ncia hist√≥rica de cada uma dessas abordagens, elas parecem n√£o apenas compat√≠veis, mas tamb√©m id√©ias complementares. <br><br>  O que, de acordo com os pensamentos de Alan Kay, √© o mais importante na OLP? <br><br><ul><li>  Encapsulamento. </li><li>  Mensagens </li><li>  Liga√ß√£o din√¢mica (a capacidade dos programas de se desenvolverem e se adaptarem √†s mudan√ßas durante sua execu√ß√£o). </li></ul><br>  O que √© insignificante no POO? <br><br><ul><li>  Classes. </li><li>  Heran√ßa baseada em classe. </li><li>  Rela√ß√£o particular a objetos, fun√ß√µes ou dados. </li><li> Palavra-chave <code>new</code> . </li><li>  Polimorfismo. </li><li>  Digita√ß√£o est√°tica. </li><li>  Atitude para com as classes como "tipos". </li></ul><br>  Se voc√™ conhece Java ou C #, pode pensar que a digita√ß√£o est√°tica ou o polimorfismo s√£o os ingredientes mais importantes da OOP, mas Alan Kay prefere lidar com padr√µes de comportamento universais na forma alg√©brica.  Aqui est√° um exemplo escrito em Haskell: <br><br><pre> <code class="hljs erlang-repl">fmap :: (a -&gt; b) -&gt; fa -&gt; fb</code> </pre> <br>  Essa √© a assinatura do functor universal de <code>map</code> , que funciona com os tipos indefinidos <code>a</code> e <code>b</code> , aplicando a fun√ß√£o de <code>a</code> em <code>b</code> no contexto do functor <code>a</code> para criar o functor <code>b</code> .  "Functor" √© uma palavra do jarg√£o matem√°tico, cujo significado √© reduzido para "suporte da opera√ß√£o de exibi√ß√£o".  Se voc√™ est√° familiarizado com o m√©todo <code>[].map()</code> no JavaScript, j√° sabe o que isso significa. <br><br>  Aqui est√£o alguns exemplos de JavaScript: <br><br><pre> <code class="hljs powershell">// isEven = Number =&gt; Boolean const isEven = n =&gt; n % <span class="hljs-number"><span class="hljs-number">2</span></span> === <span class="hljs-number"><span class="hljs-number">0</span></span>; const nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]; //  map   `a =&gt; b`    `a` ( `this`) //     `b` //    `a`   `Number`,   `b`  `Boolean` const results = nums.map(isEven); console.log(results); // [<span class="hljs-type"><span class="hljs-type">false</span></span>, <span class="hljs-type"><span class="hljs-type">true</span></span>, <span class="hljs-type"><span class="hljs-type">false</span></span>, <span class="hljs-type"><span class="hljs-type">true</span></span>, <span class="hljs-type"><span class="hljs-type">false</span></span>, <span class="hljs-type"><span class="hljs-type">true</span></span>]</code> </pre> <br>  O m√©todo <code>.map()</code> √© universal, no sentido de que <code>a</code> e <code>b</code> podem ser de qualquer tipo, e esse m√©todo lida com uma situa√ß√£o semelhante sem problemas, pois matrizes s√£o estruturas de dados que implementam as leis alg√©bricas dos functores.  Os tipos para <code>.map()</code> n√£o importam, pois esse m√©todo n√£o tenta trabalhar com os valores correspondentes diretamente.  Em vez disso, ele usa uma fun√ß√£o que espera e retorna valores dos tipos correspondentes que est√£o corretos do ponto de vista do aplicativo. <br><br><pre> <code class="hljs pgsql">// matches = a =&gt; <span class="hljs-type"><span class="hljs-type">Boolean</span></span> //  `a`    ,   const matches = control =&gt; input =&gt; input === control; const strings = [<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-string"><span class="hljs-string">'baz'</span></span>]; const results = strings.map(matches(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>)); console.log(results); // [<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>]</code> </pre> <br>  Pode ser dif√≠cil expressar corretamente e totalmente o relacionamento de tipos universais em linguagens como TypeScript, mas √© muito simples no sistema de tipos Hindley-Milner usado em Haskell, que suporta tipos mais altos (tipos de tipos). <br><br>  A maioria dos sistemas de tipos imp√µe restri√ß√µes muito fortes para permitir a livre express√£o de id√©ias din√¢micas e funcionais, como composi√ß√£o de fun√ß√µes, composi√ß√£o livre de objetos, expans√£o de objetos durante a execu√ß√£o do programa, uso de combinadores, lentes e assim por diante.  Em outras palavras?  tipos est√°ticos geralmente dificultam a cria√ß√£o de software usando m√©todos de constru√ß√£o. <br><br>  Se o seu sistema de tipos tiver muitas restri√ß√µes (como no TypeScript ou Java), para atingir os mesmos objetivos, voc√™ precisar√° escrever um c√≥digo mais complexo do que ao usar idiomas com uma abordagem mais livre para digitar.  Isso n√£o significa que o uso de tipos est√°ticos seja uma ideia infeliz ou que todas as implementa√ß√µes de tipos est√°ticos tenham as mesmas limita√ß√µes.  Por exemplo, encontrei muito menos problemas ao trabalhar com o sistema do tipo Haskell. <br><br>  Se voc√™ √© f√£ de tipos est√°ticos e n√£o √© contra restri√ß√µes, desejo sete p√©s sob a quilha.  Mas se voc√™ achar que algumas das id√©ias expressas aqui s√£o dif√≠ceis de implementar devido ao fato de n√£o ser f√°cil digitar fun√ß√µes obtidas pela composi√ß√£o de outras fun√ß√µes e estruturas alg√©bricas compostas, culpe o sistema de tipos e n√£o a id√©ia.  Motoristas gostam das comodidades que os SUVs de quadro oferecem, mas ningu√©m reclama que n√£o voa.  Para voar, voc√™ precisa de um ve√≠culo com mais graus de liberdade. <br><br>  Se as restri√ß√µes simplificam o seu c√≥digo - √≥timo!  Mas se as restri√ß√µes for√ßarem voc√™ a escrever c√≥digo mais complexo, talvez algo esteja errado com essas restri√ß√µes. <br><br><h2>  <font color="#3AC1EF">O que √© um "objeto"?</font> </h2><br>  A palavra "objeto", ao longo do tempo, adquiriu muitas conota√ß√µes secund√°rias de significado.  O que chamamos de "objetos" em JavaScript s√£o simplesmente tipos de dados compostos, sem nenhuma sugest√£o de programa√ß√£o baseada em classe ou as id√©ias de Alan Kay para transmiss√£o de mensagens. <br><br>  Em JavaScript, esses objetos podem suportar, e geralmente suportam, encapsulamento, passagem de mensagens, separa√ß√£o de comportamento por m√©todos, at√© polimorfismo usando subclasses (embora usando uma cadeia de delega√ß√£o em vez de despacho baseado em tipo). <br><br>  Alan Kay queria se livrar da diferen√ßa entre o programa e seus dados.  O JavaScript, at√© certo ponto, alcan√ßa esse objetivo colocando os m√©todos de objeto no mesmo local que as propriedades que armazenam os dados.  Qualquer propriedade, por exemplo, pode ser atribu√≠da a qualquer fun√ß√£o.  Voc√™ pode construir o comportamento do objeto dinamicamente e alterar o conte√∫do sem√¢ntico do objeto durante a execu√ß√£o do programa. <br><br>  Um objeto √© apenas uma estrutura de dados composta e n√£o precisa de nada de especial para ser considerado um objeto.  No entanto, programar usando objetos n√£o leva ao fato de que esse c√≥digo acaba sendo "orientado a objetos", assim como o uso de fun√ß√µes n√£o torna o c√≥digo "funcional". <br><br><h2>  <font color="#3AC1EF">OOP n√£o √© mais um OOP real</font> </h2><br>  Como o conceito de "objeto" nas linguagens de programa√ß√£o modernas significa muito menos do que Alan Kay quis dizer, eu uso a palavra "componente" em vez da palavra "objeto" para descrever as regras deste OOP.  Muitos objetos pertencem e s√£o controlados diretamente por algum c√≥digo JavaScript de terceiros, mas os componentes devem encapsular seu pr√≥prio estado e control√°-lo. <br><br>  Aqui est√° o que √© OOP real: <br><br><ul><li>  Programa√ß√£o usando componentes (Alan Kay os chama de "objetos"). </li><li>  O estado do componente deve ser encapsulado. </li><li>  Para comunica√ß√£o entre entidades, √© usado o sistema de mensagens. </li><li>  Os componentes podem ser adicionados, modificados e substitu√≠dos no tempo de execu√ß√£o. </li></ul><br>  A maioria dos comportamentos de objetos pode ser definida de maneira universal usando estruturas de dados alg√©bricas.  N√£o h√° necessidade de heran√ßa.  Os componentes podem reutilizar comportamentos de fun√ß√µes p√∫blicas e importar m√≥dulos, sem precisar tornar seus dados p√∫blicos. <br><br>  Manipular objetos em JavaScript ou usar heran√ßa baseada em classe n√£o significa que algu√©m esteja envolvido na programa√ß√£o OOP.  Mas o uso de componentes de tais maneiras - significa.  Mas √© muito dif√≠cil livrar-se das id√©ias estabelecidas sobre os termos, ent√£o talvez devamos deixar o termo "OOP" e chamar o que os "componentes" acima s√£o usados ‚Äã‚Äãcomo "Programa√ß√£o Orientada a Mensagens (MOP)"?  Usaremos o termo "MOP" abaixo para falar sobre programa√ß√£o orientada a mensagens. <br><br>  Por acaso, a palavra em ingl√™s ‚Äúmop‚Äù √© traduzida como ‚Äúmop‚Äù e, como voc√™ sabe, √© usada para restaurar a ordem. <br><br><h2>  <font color="#3AC1EF">Como √© um bom MOP?</font> </h2><br>  A maioria dos programas modernos possui uma certa interface de usu√°rio (interface do usu√°rio, interface do usu√°rio) respons√°vel por interagir com o usu√°rio, algum c√≥digo envolvido no gerenciamento do estado do aplicativo (dados do usu√°rio) e c√≥digo que funciona com o sistema ou √© respons√°vel pela troca de dados com a rede. <br><br>  Para dar suporte √† opera√ß√£o de cada um desses sistemas, processos de longa dura√ß√£o, como ouvintes de eventos, podem ser necess√°rios.  Aqui voc√™ precisar√° do estado do aplicativo - para armazenar algo como informa√ß√µes sobre conex√µes de rede, sobre o estado das coisas com os controles da interface e sobre o pr√≥prio aplicativo. <br><br>  Um bom MOP significa que, em vez de todos os sistemas terem acesso ao estado um do outro e poderem control√°-los diretamente, eles interagem entre si por meio de mensagens.  Quando o usu√°rio clica no bot√£o "Salvar", a mensagem <code>"SAVE"</code> pode ser enviada.  O componente do aplicativo de gerenciamento de estado pode interpretar essa mensagem e redirecion√°-la para o processador respons√°vel pela atualiza√ß√£o do estado (como uma fun√ß√£o de redutor puro).  Talvez ap√≥s a atualiza√ß√£o do estado, o componente respons√°vel pelo gerenciamento do estado <code>"STATE_UPDATED"</code> a mensagem <code>"STATE_UPDATED"</code> o componente da interface do usu√°rio, que, por sua vez, interpreta o estado, decide quais partes da interface precisam ser atualizadas e transmite o estado atualizado aos subcomponentes respons√°veis ‚Äã‚Äãpor trabalhar com elementos de interface espec√≠ficos. <br><br>  Enquanto isso, o componente respons√°vel pelas conex√µes de rede pode monitorar a conex√£o do usu√°rio com outro computador na rede, ouvir mensagens e enviar uma vis√£o atualizada do estado para salv√°-lo na m√°quina remota.  Esse componente √© respons√°vel por trabalhar com mecanismos de rede, sabe se a conex√£o funciona ou n√£o e assim por diante. <br><br>  Sistemas de aplicativos semelhantes n√£o devem conhecer os detalhes de suas outras partes.  Eles devem se preocupar apenas em resolver seus pr√≥prios problemas.  Os componentes do sistema podem ser desmontados e montados como construtor.  Eles implementam interfaces padronizadas, o que significa que eles podem interagir entre si.  Desde que os requisitos conhecidos para a interface dos componentes sejam atendidos, esses componentes podem ser substitu√≠dos por outros, com as mesmas interfaces, mas fazendo a mesma coisa de maneira diferente ou executando, recebendo as mesmas mensagens, algo completamente diferente.  Voc√™ pode alterar um componente para outro, mesmo durante a execu√ß√£o do programa - isso n√£o interromper√° o trabalho. <br><br>  Os componentes de um sistema de software nem precisam estar no mesmo computador.  O sistema pode ser descentralizado.  O armazenamento em rede pode colocar dados em um sistema de armazenamento descentralizado como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IPFS</a> , como resultado, o usu√°rio √© independente da integridade de uma m√°quina espec√≠fica, o que garante a seguran√ßa de seus dados.  Com essa abordagem, os dados s√£o armazenados e protegidos de maneira confi√°vel contra intrusos. <br><br>  A OLP, em parte, ficou sob a influ√™ncia das id√©ias da ARPANET, e um dos objetivos deste projeto era criar uma rede descentralizada que fosse resistente a ataques como um ataque nuclear. <br><br>  Um bom sistema MOP pode ser caracterizado por um n√≠vel semelhante de estabilidade usando componentes que suportam troca a quente enquanto o aplicativo est√° em execu√ß√£o.  Ele poder√° continuar funcionando se o usu√°rio trabalhar com ele a partir de um telefone celular e estiver fora da cobertura da rede devido ao fato de ter entrado no t√∫nel.  Se um furac√£o interromper o fornecimento de energia de um dos datacenters em que seus servidores est√£o localizados, ele tamb√©m continuar√° funcionando. <br><br>  Chegou a hora do mundo do software se libertar de um experimento de heran√ßa baseado em classe sem √™xito e adotar os princ√≠pios matem√°ticos e cient√≠ficos que estavam na vanguarda da OOP. <br><br>  √â hora de n√≥s, desenvolvedores, criar programas mais flex√≠veis, est√°veis ‚Äã‚Äãe bonitos, usando uma combina√ß√£o harmoniosa de MOP e programa√ß√£o funcional. <br>  A prop√≥sito, o acr√¥nimo "MOP" j√° est√° em uso, descrevendo "Monitoring Oriented Programming", mas esse conceito, diferente do OOP, simplesmente desaparece silenciosamente. <br><br>  Portanto, n√£o desanime se o termo "MOP" n√£o parecer uma palavra do jarg√£o dos programadores.  Apenas arrume seu POO com os princ√≠pios acima mencionados. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt428582/">https://habr.com/ru/post/pt428582/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt428572/index.html">Componentes de ordem superior em React</a></li>
<li><a href="../pt428574/index.html">Eleve a comunica√ß√£o corporativa ao pr√≥ximo n√≠vel com o Zextras Chat</a></li>
<li><a href="../pt428576/index.html">[marcador] Vers√£o em PDF do tutorial do Node.js. e novo guia JavaScript</a></li>
<li><a href="../pt428578/index.html">Como come√ßar com o Hibernate Search</a></li>
<li><a href="../pt428580/index.html">Good Communication Guide</a></li>
<li><a href="../pt428588/index.html">Resumo dos eventos de TI em novembro (parte dois)</a></li>
<li><a href="../pt428590/index.html">Microintera√ß√µes e micro prompts na interface</a></li>
<li><a href="../pt428592/index.html">Pare de contratar "gerentes eficazes". Eles n√£o s√£o apenas in√∫teis, mas prejudiciais</a></li>
<li><a href="../pt428596/index.html">Elon Musk demitiu os gerentes de projetos de Internet via sat√©lite Starlink devido ao n√£o cumprimento de prazos</a></li>
<li><a href="../pt428598/index.html">Redes neurais profundas para avalia√ß√£o autom√°tica de chamadas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>