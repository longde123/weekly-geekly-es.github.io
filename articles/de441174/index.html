<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🉑 🏟️ 👩🏾‍🎓 OOP ist tot, es lebe OOP 🕘 🖕🏻 🛫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Inspirationsquellen 
 Dieser Beitrag entstand dank einer kürzlich erschienenen Veröffentlichung von Aras Prantskevichus über einen Bericht für Junior-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OOP ist tot, es lebe OOP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441174/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d22/8c2/d99/d228c2d99b9b17da94979d7fc5f728ee.png" alt="Bild"></div><br><h1>  Inspirationsquellen </h1><br>  Dieser Beitrag entstand dank einer kürzlich erschienenen Veröffentlichung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Aras Prantskevichus</a> über einen Bericht für Junior-Programmierer.  Es wird erläutert, wie Sie sich an neue ECS-Architekturen anpassen können.  Aras folgt dem üblichen Muster ( <em>Erklärung unten</em> ): zeigt Beispiele für den schrecklichen OOP-Code und zeigt dann, dass das relationale Modell ( <em>nennt es aber eher „ECS“ als relational</em> ) eine großartige Alternative ist.  Auf keinen Fall kritisiere ich Aras - ich bin ein großer Fan seiner Arbeit und lobe ihn für seine hervorragende Präsentation!  Ich habe seine Präsentation anstelle von Hunderten anderer ECS-Beiträge aus dem Internet gewählt, weil er zusätzliche Anstrengungen unternommen und parallel zur Präsentation ein Git-Repository für Studien veröffentlicht hat.  Es enthält ein kleines einfaches „Spiel“, das als Beispiel für die Auswahl verschiedener Architekturlösungen dient.  Dieses kleine Projekt ermöglichte es mir, meine Kommentare zu einem bestimmten Material zu demonstrieren. Danke, Aras! <br><br>  Aras-Folien sind hier verfügbar: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">http://aras-p.info/texts/files/2018Academy - ECS-DoD.pdf</a> . Der Code befindet sich auf github: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">https://github.com/aras-p/dod-playground</a> . <br><br>  Ich werde (noch?) Die resultierende ECS-Architektur aus diesem Bericht nicht analysieren, sondern mich von Anfang an auf den „schlechten OOP“ -Code (ähnlich dem ausgestopften Trick) konzentrieren.  Ich werde zeigen, wie es wirklich aussehen würde, wenn alle Verstöße gegen die Prinzipien von OOD (objektorientiertes Design, objektorientiertes Design) korrekt korrigiert würden. <br><br>  <strong>Spoiler: Die Beseitigung aller OOD-Verstöße führt zu Leistungsverbesserungen ähnlich wie bei der Konvertierung von Aras in ECS. Außerdem wird weniger RAM benötigt und es werden weniger Codezeilen benötigt als in der ECS-Version!</strong> <br><br>  <em>TL; DR: Bevor Sie zu dem Schluss kommen, dass OOP saugt und ECS-Laufwerke verwendet, halten Sie an und untersuchen Sie OOD (um zu wissen, wie OOP richtig verwendet wird) und verstehen Sie auch das relationale Modell (um zu wissen, wie ECS richtig angewendet wird).</em> <br><a name="habracut"></a><br>  Ich habe lange Zeit an vielen Diskussionen über ECS im Forum teilgenommen, teilweise weil ich nicht denke, dass dieses Modell als separater Begriff verdient ( <em>Spoiler: Dies ist nur eine Ad-hoc-Version des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">relationalen Modells</a></em> ), sondern auch, weil Fast <em>jeder</em> Beitrag, <em>jede</em> Präsentation oder <em>jeder</em> Artikel, der für ein ECS-Muster wirbt, folgt der folgenden Struktur: <br><br><ol><li>  Zeigen Sie ein Beispiel für schrecklichen OOP-Code, dessen Implementierung aufgrund übermäßiger Vererbung schreckliche Fehler aufweist (was bedeutet, dass diese Implementierung gegen viele OOD-Prinzipien verstößt). <br></li><li>  Zu zeigen, dass Komposition eine bessere Lösung als Vererbung ist (und ganz zu schweigen davon, dass OOD uns tatsächlich die gleiche Lektion erteilt). <br></li><li>  Zeigen Sie, dass das relationale Modell hervorragend für Spiele geeignet ist (nennen Sie es jedoch „ECS“). </li></ol><br>  Eine solche Struktur macht mich wütend, weil: <strong>(A)</strong> dies ein Trick ist, der "gestopft" ist ... er vergleicht weich mit warm (schlechter Code und guter Code) ... und dies ist unfair, selbst wenn es unbeabsichtigt gemacht wird und nicht erforderlich ist, um zu demonstrieren, dass die neue Architektur gut ist;  und was noch wichtiger ist: <strong>(B)</strong> es hat einen Nebeneffekt - ein solcher Ansatz unterdrückt das Wissen und demotiviert die Leser versehentlich davon, mit Studien vertraut zu sein, die seit einem halben Jahrhundert durchgeführt wurden.  Sie begannen in den 1960er Jahren über das relationale Modell zu schreiben.  In den 70er und 80er Jahren hat sich dieses Modell erheblich verbessert.  Anfänger haben oft Fragen wie "In <em>welche Klasse möchten Sie diese Daten einfügen?</em> " Und als Antwort wird ihnen oft etwas Unbestimmtes gesagt, wie " <em>Sie müssen nur Erfahrung sammeln und dann lernen Sie nur, innerlich zu verstehen</em> " ... aber in den 70er Jahren war diese Frage aktiv studiert und im allgemeinen Fall wurde eine formelle Antwort abgeleitet;  Dies wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Datenbanknormalisierung bezeichnet</a> .  Wenn Sie vorhandene Forschungsergebnisse verwerfen und ECS als eine völlig neue und moderne Lösung bezeichnen, verbergen Sie dieses Wissen vor Anfängern. <br><br>  Die Grundlagen der objektorientierten Programmierung wurden vor ebenso langer, wenn nicht früherer Zeit gelegt ( <em>dieser Stil begann in den 1950er Jahren zu erforschen</em> )!  In den 1990er Jahren wurde die Objektorientierung jedoch modisch, viral und entwickelte sich sehr schnell zum vorherrschenden Programmierparadigma.  Die Popularität vieler neuer OO-Sprachen, einschließlich Java und der ( <em>standardisierten Version</em> ) C ++, ist explosionsartig gestiegen.  Da dies jedoch auf einen Hype zurückzuführen war, musste jeder dieses hochkarätige Konzept kennen, um in seinen Lebenslauf schreiben zu können, aber nur wenige gingen wirklich darauf ein.  Diese neuen Sprachen haben die Schlüsselwörter - <em>Klasse</em> , <em>virtuell</em> , <em>erweitert</em> , <em>implementiert</em> - aus vielen Funktionen von OO erstellt, und ich glaube, dass OO in diesem Moment in zwei separate Einheiten unterteilt wurde, die ihr eigenes Leben führen. <br><br>  Ich werde die Verwendung dieser OO-inspirierten Sprachfunktionen als „ <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">OOP</a></strong> “ und die Verwendung von OO-inspirierten Design- / Architekturtechniken als „ <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">OOD</a></strong> “ bezeichnen.  Alle haben sehr schnell die OOP aufgenommen.  Bildungseinrichtungen bieten OO-Kurse an, in denen neue OOP-Programmierer gebacken werden. Das Wissen über OOD bleibt jedoch zurück. <br><br>  Ich glaube, dass Code, der die Sprachfunktionen von OOP verwendet, aber nicht den Prinzipien des OOD-Designs folgt, <strong>kein OO-Code ist</strong> .  Die meisten Kritikpunkte gegen OOP verwenden beispielsweise entkernten Code, der eigentlich kein OO-Code ist. <br><br>  OOP-Code hat einen sehr schlechten Ruf, insbesondere weil der größte Teil des OOP-Codes nicht den Prinzipien von OOD folgt und daher kein „wahrer“ OO-Code ist. <br><br><h1>  Hintergrund </h1><br>  Wie oben erwähnt, wurden die 1990er Jahre zum Höhepunkt der „OO-Mode“, und zu dieser Zeit war die „schlechte OOP“ wahrscheinlich die schlechteste.  Wenn Sie zu diesem Zeitpunkt OOP studiert haben, haben Sie höchstwahrscheinlich etwas über die „vier Säulen von OOP“ gelernt: <br><br><ul><li>  Abstraktion </li><li>  Kapselung </li><li>  Polymorphismus </li><li>  Vererbung </li></ul><br>  Ich nenne sie lieber nicht vier Säulen, sondern „vier OOP-Tools“.  Dies sind Tools, mit denen <em><strong>Sie</strong></em> Probleme lösen können.  Es reicht jedoch nicht aus, nur herauszufinden, wie das Tool funktioniert. Sie müssen wissen, wann Sie es verwenden müssen. Seitens der Lehrer ist es unverantwortlich, den Menschen ein neues Tool beizubringen und ihnen nicht zu sagen, wann es sich lohnt, es zu verwenden.  In den frühen 2000er Jahren gab es Widerstand gegen den aktiven Missbrauch dieser Werkzeuge, eine Art „zweite Welle“ des OOD-Denkens.  Das Ergebnis war die Entstehung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">SOLID-</a> Mnemonik, mit der sich die architektonischen Stärken schnell bewerten ließen.  Es sollte angemerkt werden, dass diese Weisheit in den 90er Jahren tatsächlich weit verbreitet war, aber noch kein cooles Akronym erhalten hat, das es ermöglichte, sie als fünf Grundprinzipien festzulegen ... <br><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Das Prinzip der alleinigen Verantwortung</a></strong> ( <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Prinzip der</a></strong> Einzelverantwortung).  Jede Klasse sollte nur einen Grund für die Änderung haben.  Wenn die Klasse "A" zwei Verantwortlichkeiten hat, müssen Sie die Klassen "B" und "C" erstellen, um jede einzeln zu verarbeiten, und dann "A" aus "B" und "C" erstellen. </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Das Prinzip der Offenheit / Schließung</a></strong> ( <b>O</b> Stift / geschlossenes Prinzip).  Software ändert sich im Laufe der Zeit ( <em>d. H. Ihre Unterstützung ist wichtig</em> ).  Versuchen Sie, die Teile, die sich am wahrscheinlichsten ändern, in <em>Implementierungen (</em> <em>d. H. In bestimmten Klassen</em> ) zu platzieren und <em>Schnittstellen</em> basierend auf den Teilen zu erstellen, die sich wahrscheinlich nicht ändern ( <em>z. B. abstrakte Basisklassen</em> ). <br></li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Das Substitutionsprinzip von Barbara Liskov</a></strong> ( <b>L</b> iskov-Substitutionsprinzip).  Jede Implementierung einer Schnittstelle muss zu 100% die Anforderungen dieser Schnittstelle erfüllen, d. H.  Jeder Algorithmus, der mit einer Schnittstelle arbeitet, sollte mit jeder Implementierung funktionieren. </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Das Prinzip der Trennung der Schnittstelle</a></strong> (Prinzip <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">der Schnittstellentrennung</a></strong> ).  Machen Sie die Schnittstellen so klein wie möglich, damit jeder Teil des Codes die kleinste Menge an Codebasis „kennt“, um unnötige Abhängigkeiten zu vermeiden.  Dieser Tipp ist auch für C ++ geeignet, wo die Kompilierungszeiten sehr lang werden, wenn Sie ihn nicht befolgen. </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Das Prinzip der Abhängigkeitsinversion</a></strong> ( <b>D-</b> Abhängigkeitsinversionsprinzip).  Anstelle von zwei spezifischen Implementierungen, die direkt kommunizieren (und voneinander abhängen), können sie normalerweise getrennt werden, indem ihre Kommunikationsschnittstelle als dritte Klasse formalisiert wird, die als Schnittstelle zwischen ihnen verwendet wird.  Es kann sich um eine abstrakte Basisklasse handeln, die die Aufrufe der zwischen ihnen verwendeten Methoden definiert, oder auch nur um eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">POD-</a> Struktur, die die zwischen ihnen übertragenen Daten definiert. </li><li>  Ein anderes Prinzip ist im Akronym SOLID nicht enthalten, aber ich bin sicher, dass es sehr wichtig ist: <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">„Komposition</a></strong> lieber als <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Vererbung“</a></strong> (Composite-Wiederverwendungsprinzip).  Die Zusammensetzung <em>ist standardmäßig die richtige Wahl</em> .  Die Vererbung sollte in Fällen belassen werden, in denen dies unbedingt erforderlich ist. </li></ul><br>  Also bekommen wir SOLID-C (++) <img alt=":) :) :)" height="20" src="https://habrastorage.org/getpro/habr/post_images/e8d/c8c/1e8/e8dc8c1e846d52073e8f2a944b2006fa.png" width="20"><br><br>  Im Folgenden werde ich auf diese Prinzipien verweisen und sie als Akronyme bezeichnen - SRP, OCP, LSP, ISP, DIP, CRP ... <br><br>  Noch ein paar Anmerkungen: <br><br><ul><li>  In OOD können die Konzepte von <em>Schnittstellen</em> und <em>Implementierungen</em> nicht an bestimmte OOP-Schlüsselwörter gebunden werden.  In C ++ erstellen wir häufig Schnittstellen mit <em>abstrakten Basisklassen</em> und <em>virtuellen Funktionen</em> und erben dann <em>Implementierungen,</em> die von diesen Basisklassen geerbt werden. Dies ist jedoch nur eine spezielle Methode, um das Prinzip der Schnittstelle zu implementieren.  In C ++ können wir auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">PIMPL</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">undurchsichtige Zeiger</a> , Ententypisierung, typedef usw. verwenden. Sie können eine OOD-Struktur erstellen und diese dann in C implementieren, in dem es überhaupt keine OOP-Sprachschlüsselwörter gibt!  Wenn ich also über <em>Schnittstellen</em> spreche, meine ich nicht unbedingt <em>virtuelle</em> Funktionen - ich spreche über das Prinzip, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">die Implementierung zu verbergen</a> .  Schnittstellen <em>können</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">polymorph sein</a> , aber meistens sind sie es!  Polymorphismus wird sehr selten richtig verwendet, aber Schnittstellen sind ein grundlegendes Konzept für jede Software. <br><ul><li>  Wie ich oben klargestellt habe, wird diese Struktur als <em>Schnittstelle</em> verwendet, wenn Sie eine POD-Struktur erstellen, in der einfach einige Daten für die Übertragung von einer Klasse zu einer anderen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">gespeichert werden</a> . Dies ist eine formale <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Beschreibung der Daten</a> . <br></li><li>  Selbst wenn Sie nur eine separate Klasse mit dem <em>öffentlichen</em> und dem <em>privaten</em> Teil erstellen, ist alles, was sich im gemeinsamen Teil befindet, eine <em>Schnittstelle</em> , und alles im privaten Teil ist eine <em>Implementierung</em> . </li></ul></li><li>  Die Vererbung hat tatsächlich (mindestens) zwei Typen - Schnittstellenvererbung und Implementierungsvererbung. <br><ul><li>  In C ++ umfasst die Schnittstellenvererbung abstrakte Basisklassen mit rein virtuellen Funktionen, PIMPL und bedingtem Typedef.  In Java wird die Schnittstellenvererbung durch das Schlüsselwort <em>implements</em> ausgedrückt. </li><li>  In C ++ erfolgt die Vererbung von Implementierungen jedes Mal, wenn die Basisklassen etwas anderes als reine virtuelle Funktionen enthalten.  In Java wird die Vererbung der Implementierung mit dem <em>Schlüsselwort</em> extenses ausgedrückt. </li><li>  OOD hat viele Regeln für das Erben von Schnittstellen, aber die Vererbung von Implementierungen ist normalerweise als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">"Code mit einem Biss" zu betrachten</a> ! </li></ul></li></ul><br>  Und schließlich sollte ich einige Beispiele für das schreckliche OOP-Training zeigen und wie es im wirklichen Leben zu schlechtem Code führt (und zu OOPs schlechtem Ruf). <br><br><ol><li>  Als Ihnen Hierarchien / Vererbung beigebracht wurde, wurde Ihnen möglicherweise eine ähnliche Aufgabe übertragen: <strong><em>Angenommen, Sie haben eine Universitätsanwendung, die ein Verzeichnis von Studenten und Mitarbeitern enthält.</em></strong>  <strong><em>Sie können die Basisklasse Person und dann die von Person geerbte Schülerklasse und die Staff-Klasse erstellen.</em></strong> <br><br>  Nein nein Nein.  Hier werde ich dich aufhalten.  Die unausgesprochene Implikation des LSP-Prinzips ist, dass <em>Klassenhierarchien</em> und die <em>Algorithmen, die sie verarbeiten,</em> symbiotisch sind.  Dies sind zwei Hälften des gesamten Programms.  OOP ist eine Erweiterung der prozeduralen Programmierung und wird immer noch hauptsächlich mit diesen Prozeduren in Verbindung gebracht.  Wenn wir nicht wissen, welche Arten von Algorithmen mit <i>Schülern</i> und <em>Mitarbeitern</em> funktionieren ( <em>und welche Algorithmen aufgrund von Polymorphismus vereinfacht werden</em> ), ist es völlig unverantwortlich, mit der Erstellung der Struktur von Klassenhierarchien zu beginnen.  Zuerst müssen Sie die Algorithmen <em>und</em> Daten kennen. </li><li>  Als Ihnen Hierarchien / Vererbung beigebracht wurde, wurde Ihnen wahrscheinlich eine ähnliche Aufgabe übertragen: <b><i>Angenommen, Sie haben eine Klasse von Formen.</i></b>  <b><i>Wir haben auch Quadrate und Rechtecke als Unterklassen.</i></b>  <b><i>Sollte ein Quadrat ein Rechteck oder ein Rechteck ein Quadrat sein?</i></b> <br><br>  Dies ist tatsächlich ein gutes Beispiel, um den Unterschied zwischen der Vererbung von Implementierungen und der Vererbung von Schnittstellen zu demonstrieren. <br><ul><li>  Wenn Sie den Implementierungsvererbungsansatz verwenden, ignorieren Sie den LSP vollständig und denken aus praktischer Sicht über die Möglichkeit nach, Code unter Verwendung der Vererbung als Werkzeug wiederzuverwenden. <br><br>  Unter diesem Gesichtspunkt ist Folgendes vollkommen logisch: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class"> :</span></span> Square { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; };</code> </pre> <br>  Das Quadrat hat nur die Breite und das Rechteck hat die Breite + Höhe, dh wenn wir das Quadrat mit der Höhenkomponente erweitern, erhalten wir ein Rechteck! <br><ul><li>  Wie Sie vielleicht vermutet haben, sagt OOD, dass dies ( <em>wahrscheinlich</em> ) falsch ist.  Ich sagte <em>"wahrscheinlich",</em> weil Sie hier über die impliziten Eigenschaften der Schnittstelle streiten können ... na ja. <br><br>  Ein Quadrat hat immer die gleiche Höhe und Breite. Von der Benutzeroberfläche des Quadrats aus kann man also davon ausgehen, dass der Bereich "Breite * Breite" ist. <br><br>  Beim Erben eines Quadrats muss die Klasse der Rechtecke (gemäß LSP) den Regeln der quadratischen Schnittstelle entsprechen.  Jeder Algorithmus, der für ein Quadrat korrekt funktioniert, sollte auch für ein Rechteck korrekt funktionieren. </li><li>  Nehmen Sie einen anderen Algorithmus: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Square*&gt; shapes; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> area = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> s : shapes) area += s-&gt;width * s-&gt;width;</code> </pre> <br>  Es funktioniert korrekt für Quadrate (Berechnung der Summe ihrer Flächen), aber nicht für Rechtecke. <br><br>  Daher verstößt das Rechteck gegen das LSP-Prinzip. </li></ul></li><li>  Wenn Sie den Ansatz der Schnittstellenvererbung verwenden, erben weder Square noch Rectangle voneinander.  Die Schnittstellen für das Quadrat und das Rechteck sind tatsächlich unterschiedlich, und eine ist keine Obermenge der anderen. <br></li><li>  Daher rät OOD von der Verwendung der Implementierungsvererbung ab.  Wie oben erwähnt, ist OOD die richtige Wahl, wenn Sie Code wiederverwenden möchten! <br><ul><li>  Die <i>korrekte</i> Version des obigen (fehlerhaften) Codes für die Vererbungshierarchie von C ++ - Implementierungen sieht also folgendermaßen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Shape { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> width * width; }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Square, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Shape { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> width * height; }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; };</code> </pre> <br><ul><li>  "Public Virtual" bedeutet in Java "implementiert".  Wird bei der Implementierung der Schnittstelle verwendet. <br></li><li>  Mit "Privat" können Sie die Basisklasse erweitern, ohne ihre Schnittstelle zu erben. In diesem Fall ist das Rechteck <b>kein</b> Quadrat, obwohl es von ihm erbt. <br></li></ul></li><li>  Ich empfehle nicht, solchen Code zu schreiben, aber wenn Sie die Vererbung von Implementierungen verwenden möchten, müssen Sie genau das tun! </li></ul></li></ul></li></ol><br>  TL; DR - Ihre OOP-Klasse hat Ihnen gesagt, wie Vererbung war.  Ihre fehlende OOD-Klasse hätte Ihnen sagen sollen, dass Sie sie 99% der Zeit nicht verwenden sollen! <br><br><h1>  Entitäts- / Komponentenkonzepte </h1><br>  Nachdem wir uns mit den Voraussetzungen befasst haben, gehen wir weiter zu dem Punkt, an dem Aras begonnen hat - zum sogenannten Ausgangspunkt eines „typischen OOP“. <br><br>  Aber für den Anfang noch eine Ergänzung: Aras nennt diesen Code „traditionelles OOP“, und ich möchte dem widersprechen.  Dieser Code mag für OOP in der realen Welt typisch sein, verstößt jedoch wie die obigen Beispiele gegen alle Arten von Grundprinzipien von OO und sollte daher überhaupt nicht als traditionell angesehen werden. <br><br>  Ich werde mit dem ersten Commit beginnen, bevor er die Struktur in Richtung ECS ​​neu erstellt: <a href="" rel="external nofollow">„Damit es wieder unter Windows funktioniert“ 3529f232510c95f53112bbfff87df6bbc6aa1fae</a> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ------------------------------------------------------------------------------------------------- // super simple "component system" class GameObject; class Component; typedef std::vector&lt;Component*&gt; ComponentVector; typedef std::vector&lt;GameObject*&gt; GameObjectVector; // Component base class. Knows about the parent game object, and has some virtual methods. class Component { public: Component() : m_GameObject(nullptr) {} virtual ~Component() {} virtual void Start() {} virtual void Update(double time, float deltaTime) {} const GameObject&amp; GetGameObject() const { return *m_GameObject; } GameObject&amp; GetGameObject() { return *m_GameObject; } void SetGameObject(GameObject&amp; go) { m_GameObject = &amp;go; } bool HasGameObject() const { return m_GameObject != nullptr; } private: GameObject* m_GameObject; }; // Game object class. Has an array of components. class GameObject { public: GameObject(const std::string&amp;&amp; name) : m_Name(name) { } ~GameObject() { // game object owns the components; destroy them when deleting the game object for (auto c : m_Components) delete c; } // get a component of type T, or null if it does not exist on this game object template&lt;typename T&gt; T* GetComponent() { for (auto i : m_Components) { T* c = dynamic_cast&lt;T*&gt;(i); if (c != nullptr) return c; } return nullptr; } // add a new component to this game object void AddComponent(Component* c) { assert(!c-&gt;HasGameObject()); c-&gt;SetGameObject(*this); m_Components.emplace_back(c); } void Start() { for (auto c : m_Components) c-&gt;Start(); } void Update(double time, float deltaTime) { for (auto c : m_Components) c-&gt;Update(time, deltaTime); } private: std::string m_Name; ComponentVector m_Components; }; // The "scene": array of game objects. static GameObjectVector s_Objects; // Finds all components of given type in the whole scene template&lt;typename T&gt; static ComponentVector FindAllComponentsOfType() { ComponentVector res; for (auto go : s_Objects) { T* c = go-&gt;GetComponent&lt;T&gt;(); if (c != nullptr) res.emplace_back(c); } return res; } // Find one component of given type in the scene (returns first found one) template&lt;typename T&gt; static T* FindOfType() { for (auto go : s_Objects) { T* c = go-&gt;GetComponent&lt;T&gt;(); if (c != nullptr) return c; } return nullptr; }</span></span></code> </pre> <br>  Ja, es ist schwierig, sofort hundert Codezeilen herauszufinden. Beginnen wir also schrittweise ... Wir brauchen einen weiteren Aspekt der Voraussetzungen - es war beliebt, die Vererbung in Spielen der 90er Jahre zu verwenden, um alle Probleme der Wiederverwendung von Code zu lösen.  Sie hatten Entität, erweiterbaren Charakter, erweiterbaren Player und Monster und so weiter ... Dies ist eine Vererbung von Implementierungen, wie wir zuvor beschrieben haben ( <em>"Code mit einem Choke"</em> ), und es scheint richtig zu sein, damit zu beginnen, aber als Ergebnis führt dies zu einem sehr unflexible Codebasis.  Weil OOD das oben beschriebene Prinzip „Zusammensetzung über Vererbung“ hat.  In den 2000er Jahren wurde das Prinzip „Komposition über Vererbung“ populär, und Spieleentwickler begannen, ähnlichen Code zu schreiben. <br><br>  Was macht dieser Code?  Na ja nicht gut <img alt=": D." height="20" src="https://habrastorage.org/getpro/habr/post_images/4c3/d02/890/4c3d028909133f97a7a351651c98c08b.png" title=": D." width="20"><br><br>  Kurz gesagt, <strong>dieser Code implementiert ein vorhandenes Merkmal der Sprache erneut - Komposition</strong> als Laufzeitbibliothek und nicht als Merkmal der Sprache.  Sie können sich das so vorstellen, als würde der Code tatsächlich eine neue Metasprache über C ++ und eine virtuelle Maschine (VM) erstellen, um diese Metasprache auszuführen.  Im Aras-Demospiel ist dieser Code nicht erforderlich ( <em>wir werden ihn bald vollständig entfernen!</em> ) Und dient nur dazu, die Spielleistung um das Zehnfache zu reduzieren. <br><br>  Aber was macht er eigentlich?  Dies ist das Konzept des " <strong>E</strong> ntity / <strong>C</strong> omponent-Systems" ( <em>manchmal aus irgendeinem Grund als " <strong>E</strong> ntity / <strong>C</strong> omponent-System" bezeichnet</em> ), es unterscheidet sich jedoch vollständig vom Konzept des " <strong>E</strong> ntity <strong>C"</strong> omponent System "(" Entity-Component-System ") ( <em>das aus offensichtlichen Gründen niemals als</em> " Entity Component System System " <em>bezeichnet wird</em> ). Es formalisiert mehrere Prinzipien der" EC ": <br><br><ul><li>  Das Spiel besteht aus Funktionen von "Entities" ("Entity") ( <em>in diesem Beispiel</em> GameObjects), die aus "Components" ("Component") bestehen. </li><li>  GameObjects implementieren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">das Muster "Service Locator"</a> - ihre untergeordneten Komponenten werden nach Typ abgefragt. </li><li>  Komponenten wissen, zu welchem ​​GameObject sie gehören - sie können Komponenten finden, die sich auf derselben Ebene wie sie befinden, indem sie das übergeordnete GameObject abfragen. <br></li><li>  Die Komposition kann nur eine Ebene tief sein ( <em>Komponenten können keine eigenen untergeordneten Komponenten haben, GameObjects können keine untergeordneten GameObjects haben</em> ). <br></li><li>  GameObject kann nur eine Komponente jedes Typs haben ( <em>in einigen Frameworks ist dies eine obligatorische Anforderung, in anderen nicht</em> ). <br></li><li>  Jede Komponente ändert sich (wahrscheinlich) im Laufe der Zeit auf eine nicht spezifizierte Weise, sodass die Schnittstelle ein "Virtual Void Update" enthält. <br></li><li>  GameObjects gehören zu einer Szene, die Abfragen für alle GameObjects (und damit für alle Komponenten) ausführen kann. </li></ul><br>  Ein ähnliches Konzept war in den 2000er Jahren sehr beliebt und erwies sich trotz seiner Einschränkungen als flexibel genug, um damals und heute unzählige Spiele zu erstellen. <br><br>  Dies ist jedoch nicht erforderlich.  Ihre Programmiersprache unterstützt bereits die Komposition als Merkmal der Sprache - es ist kein aufgeblähtes Konzept erforderlich, um darauf zuzugreifen ... Warum gibt es diese Konzepte dann?  Um ehrlich zu sein, können Sie zur <em>Laufzeit dynamische Kompositionen durchführen</em> .  Anstatt GameObject-Typen im Code hart zu definieren, können Sie sie aus Datendateien laden.  Und das ist sehr praktisch, weil es Spiel- / Level-Designern ermöglicht, ihre eigenen Objekttypen zu erstellen ... In den meisten Spielprojekten gibt es jedoch nur sehr wenige Designer und buchstäblich eine ganze Armee von Programmierern, daher würde ich argumentieren, dass dies eine wichtige Gelegenheit ist.  Schlimmer noch, dies ist nicht die einzige Möglichkeit, eine Komposition zur Laufzeit zu implementieren!  Zum Beispiel verwendet Unity C # als "Skriptsprache", und viele andere Spiele verwenden seine Alternativen, zum Beispiel Lua - ein praktisches Tool für Designer, das C # / Lua-Code generieren kann, um neue Spielobjekte zu definieren, ohne dass ein derart aufgeblähtes Konzept erforderlich ist!  Wir werden dieses "Feature" im nächsten Beitrag erneut hinzufügen und so gestalten, dass es uns keinen zehnfachen Leistungsabfall kostet ... <br><br>  Lassen Sie uns diesen Code gemäß OOD bewerten: <br><br><ul><li>  GameObject :: GetComponent verwendet dynamic_cast.  Die meisten Leute werden Ihnen sagen, dass dynamic_cast ein "Code mit einem Choke" ist, ein großer Hinweis darauf, dass Sie irgendwo einen Fehler haben.  Ich würde dies sagen - dies ist ein Beweis dafür, dass Sie gegen den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">LSP</a> verstoßen haben - Sie haben eine Art Algorithmus, der mit der Basisschnittstelle funktioniert, aber er muss verschiedene Implementierungsdetails kennen.  Aus diesem Grund riecht der Code schlecht. <br></li><li>  GameObject ist im Prinzip nicht schlecht, wenn Sie sich vorstellen, dass es die Vorlage "Service Locator" implementiert ... aber wenn Sie aus Sicht von OOD über die Kritik hinausgehen, stellt diese Vorlage implizite Verbindungen zwischen Teilen des Projekts her, und ich denke ( <em>ohne einen Link zu Wikipedia, der dies unterstützen kann Ich mit Kenntnissen aus der Informatik</em> ), dass implizite Kommunikationskanäle ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Gegenmuster</a> sind und explizite Kommunikationskanäle bevorzugen sollten.  Das gleiche Argument gilt für das aufgeblähte "Konzept der Ereignisse", die manchmal in Spielen verwendet werden ... <br></li><li>  Ich möchte feststellen, dass eine Komponente eine Verletzung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">SRP darstellt,</a> weil ihre Schnittstelle ( <em>Virtual Void Update (Zeit)</em> ) zu breit ist.  Die Verwendung von "Virtual Void Update" in der Spieleentwicklung ist allgegenwärtig, aber ich würde auch sagen, dass es sich um ein Antimuster handelt.  Gute Software sollte es Ihnen ermöglichen, leicht über Kontrollfluss und Datenfluss nachzudenken.  Wenn Sie <em>jedes Element des Gameplay-Codes</em> hinter dem Aufruf "Virtual Void Update" platzieren, werden der Kontrollstrom und der Datenstrom vollständig und vollständig verschleiert.  IMHO, unsichtbare <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Nebenwirkungen</a> , auch als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Fernwirkung bezeichnet,</a> sind einige der häufigsten Fehlerquellen, und „Virtual Void Update“ stellt sicher, dass fast alles eine unsichtbare Nebenwirkung ist. <br></li><li>  Obwohl das Ziel der Component-Klasse darin besteht, die Komposition zu aktivieren, erfolgt dies durch Vererbung, was eine Verletzung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">CRP darstellt</a> . </li><li>  Die einzig gute Seite dieses Beispiels ist, dass der Spielcode übertrieben ist, um den Prinzipien von SRP und ISP zu entsprechen - er ist in viele einfache Komponenten mit sehr geringer Verantwortung unterteilt, was sich hervorragend für die Wiederverwendung von Code eignet. <br><br>  Er ist jedoch nicht so gut darin, DIP aufrechtzuerhalten - viele Komponenten kennen sich direkt. </li></ul><br>  Der gesamte oben gezeigte Code kann also tatsächlich gelöscht werden.  Diese ganze Struktur.  Löschen Sie GameObject (in anderen Frameworks auch Entity genannt), entfernen Sie Component und löschen Sie FindOfType.  Dies ist Teil einer nutzlosen VM, die gegen OOD-Prinzipien verstößt und unser Spiel schrecklich verlangsamt. <br><br><h1>  Komposition ohne Frameworks (d. H. Unter Verwendung von Merkmalen der Programmiersprache selbst) </h1><br>  Wie können unsere GameObjects die Komposition verwenden und aus Komponenten bestehen, wenn wir das Kompositionsframework entfernen und nicht über die Component-Basisklasse verfügen?  Wie der Titel schon sagt, anstatt diese aufgeblähte VM zu schreiben und GameObjects in einer seltsamen Metasprache darüber zu erstellen, schreiben wir sie einfach in C ++, weil wir Spielprogrammierer sind und dies buchstäblich unsere Aufgabe ist. <br><br>  Hier ist das Commit, mit dem das Entity / Component-Framework entfernt wurde: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">https://github.com/hodgman/dod-playground/commit/f42290d0217d700dea2ed002f2f3b1dc45e8c27c</a> <br><br>  Hier ist die Originalversion des Quellcodes: <a href="" rel="external nofollow">https://github.com/hodgman/dod-playground/blob/3529f232510c95f53112bbfff87df6bbc6aa1fae/source/game.cpp</a> <br><br>  Hier ist die geänderte Version des Quellcodes: <a href="" rel="external nofollow">https://github.com/hodgman/dod-playground/blob/f42290d0217d700dea2ed002f2f3b1dc45e8c27c/source/game.cpp</a> <br><br>  Kurz zu den Änderungen: <br><br><ul><li>  ": Public Component" wurde aus jedem Komponententyp entfernt. <br></li><li>  Jedem Komponententyp wurde ein Konstruktor hinzugefügt. <br><ul><li>  Bei OOD geht es hauptsächlich darum, den Status einer Klasse zu kapseln. Da diese Klassen jedoch so klein / einfach sind, gibt es nichts Besonderes zu verbergen: Eine Schnittstelle ist eine Beschreibung der Daten.  Einer der Hauptgründe dafür, dass die Kapselung die Hauptsäule ist, besteht darin, dass wir die konstante Wahrheit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">von Klasseninvarianten</a> garantieren können. Wenn die Invariante gebrochen ist, müssen Sie nur den gekapselten Implementierungscode untersuchen, um den Fehler zu finden.  In diesem Codebeispiel lohnt es sich, Konstruktoren hinzuzufügen, um eine einfache Invariante zu implementieren - alle Werte müssen initialisiert werden. </li></ul></li><li>  Ich habe die zu allgemeinen "Update" -Methoden umbenannt, damit ihre Namen das widerspiegeln, was sie tatsächlich tun - UpdatePosition für MoveComponent und ResolveCollisions für AvoidComponent. <br></li><li>  Ich habe drei fest codierte Codeblöcke entfernt, die einer Vorlage / einem Fertighaus ähnelten - den Code, der ein GameObject mit bestimmten Komponententypen erstellt, und es durch drei C ++ - Klassen ersetzt. <br></li><li>  Antipattern "Virtual Void Update" beseitigt. <br></li><li>  Anstatt dass die Komponenten über die Vorlage "Service Locator" nacheinander suchen, werden sie während des Aufbaus vom Spiel explizit miteinander verbunden. </li></ul><br><h2>  Die Objekte </h2><br>  Daher anstelle dieses Codes für "virtuelle Maschinen": <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// create regular objects that move for (auto i = 0; i &lt; kObjectCount; ++i) { GameObject* go = new GameObject("object"); // position it within world bounds PositionComponent* pos = new PositionComponent(); pos-&gt;x = RandomFloat(bounds-&gt;xMin, bounds-&gt;xMax); pos-&gt;y = RandomFloat(bounds-&gt;yMin, bounds-&gt;yMax); go-&gt;AddComponent(pos); // setup a sprite for it (random sprite index from first 5), and initial white color SpriteComponent* sprite = new SpriteComponent(); sprite-&gt;colorR = 1.0f; sprite-&gt;colorG = 1.0f; sprite-&gt;colorB = 1.0f; sprite-&gt;spriteIndex = rand() % 5; sprite-&gt;scale = 1.0f; go-&gt;AddComponent(sprite); // make it move MoveComponent* move = new MoveComponent(0.5f, 0.7f); go-&gt;AddComponent(move); // make it avoid the bubble things AvoidComponent* avoid = new AvoidComponent(); go-&gt;AddComponent(avoid); s_Objects.emplace_back(go); }</span></span></code> </pre> <br>  Wir haben jetzt regulären C ++ - Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegularObject</span></span></span><span class="hljs-class"> {</span></span> PositionComponent pos; SpriteComponent sprite; MoveComponent move; AvoidComponent avoid; RegularObject(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> WorldBoundsComponent&amp; bounds) : move(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.7f</span></span>) <span class="hljs-comment"><span class="hljs-comment">// position it within world bounds , pos(RandomFloat(bounds.xMin, bounds.xMax), RandomFloat(bounds.yMin, bounds.yMax)) // setup a sprite for it (random sprite index from first 5), and initial white color , sprite(1.0f, 1.0f, 1.0f, rand() % 5, 1.0f) { } }; ... // create regular objects that move regularObject.reserve(kObjectCount); for (auto i = 0; i &lt; kObjectCount; ++i) regularObject.emplace_back(bounds);</span></span></code> </pre> <br><h2>  Algorithmen </h2><br>  Eine weitere wichtige Änderung wurde an den Algorithmen vorgenommen.  Denken Sie daran, am Anfang habe ich gesagt, dass Schnittstellen und Algorithmen in Symbiose funktionieren und sich gegenseitig beeinflussen sollten.  So ist auch hier das Antipattern " <em>Virtual Void Update</em> " zum Feind geworden.  Der Anfangscode enthält den Hauptschleifenalgorithmus, der nur aus folgenden Elementen besteht: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// go through all objects for (auto go : s_Objects) { // Update all their components go-&gt;Update(time, deltaTime);</span></span></code> </pre> <br>  Sie können argumentieren, dass es schön und einfach ist, aber meiner Meinung nach ist es sehr, sehr schlecht.  Dies verschleiert sowohl den <em>Kontrollfluss</em> als auch den <em>Datenfluss</em> innerhalb des Spiels vollständig.  Wenn wir unsere Software verstehen wollen, wenn wir sie unterstützen wollen, wenn wir neue Dinge hinzufügen, optimieren, effizient auf mehreren Prozessorkernen ausführen wollen, müssen wir sowohl den Kontrollfluss als auch den Datenfluss verstehen.  Daher muss "Virtual Void Update" in Brand gesetzt werden. <br><br>  Stattdessen haben wir eine explizitere Hauptschleife erstellt, die das Verständnis des Kontrollflusses erheblich vereinfacht (der darin <em>enthaltene Datenfluss ist immer noch verschleiert, wir werden dies jedoch in den folgenden Commits beheben</em> ). <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Update all positions for (auto&amp; go : s_game-&gt;regularObject) { UpdatePosition(deltaTime, go, s_game-&gt;bounds.wb); } for (auto&amp; go : s_game-&gt;avoidThis) { UpdatePosition(deltaTime, go, s_game-&gt;bounds.wb); } // Resolve all collisions for (auto&amp; go : s_game-&gt;regularObject) { ResolveCollisions(deltaTime, go, s_game-&gt;avoidThis); }</span></span></code> </pre> <br>  Der Nachteil dieses Stils ist, dass wir für <em>jeden neuen Objekttyp</em> , der dem Spiel hinzugefügt wird, mehrere Zeilen zur Hauptschleife hinzufügen müssen.  Ich werde in einem späteren Beitrag aus dieser Serie darauf zurückkommen. <br><br><h1>  Leistung </h1><br>  Es gibt viele große OOD-Verstöße, einige schlechte Entscheidungen werden bei der Auswahl einer Struktur getroffen und es gibt viele Möglichkeiten zur Optimierung, aber ich werde im nächsten Beitrag der Serie darauf eingehen.  Bereits zu diesem Zeitpunkt ist jedoch klar, dass die Version mit „festem OOD“ fast vollständig mit dem endgültigen „ECS“ -Code am Ende der Präsentation übereinstimmt oder diesen gewinnt. Und wir haben nur den schlechten Pseudo-OOP-Code genommen und dafür gesorgt, dass er den Prinzipien entspricht OOP (und auch hundert Codezeilen gelöscht)! <br><br><div style="text-align:center;"><img alt="img" src="https://habrastorage.org/getpro/habr/post_images/d22/8c2/d99/d228c2d99b9b17da94979d7fc5f728ee.png"></div><br><h1>  Nächste Schritte </h1><br>  Hier möchte ich ein viel breiteres Spektrum von Problemen betrachten, einschließlich der Lösung der verbleibenden OOD-Probleme, unveränderlicher Objekte ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Programmierung in einem funktionalen Stil</a> ) und der Vorteile, die sie in Diskussionen über Datenflüsse, Nachrichtenübermittlung und Anwendung der DOD-Logik auf unseren OOD-Code bringen können. Anwenden relevanter Weisheit in OOD-Code, Entfernen dieser Klassen von „Entitäten“, mit denen wir am Ende endeten, und Verwenden nur reiner Komponenten unter Verwendung verschiedener Stile zum Verbinden von Komponenten (Vergleichen von Zeigern und  die Verantwortung zu tragen) Komponenten von Behältern aus der realen Welt, ECS-Revision Version für eine bessere Optimierung, sowie die weitere Optimierung, die nicht im Bericht Aras <em>(wie Multi-Threading / SIMD) erwähnt.</em>  Die Reihenfolge wird nicht unbedingt so sein, und vielleicht werde ich nicht alle oben genannten Punkte berücksichtigen ... <br><br><h1>  Ergänzung </h1><br>  Die Links zu dem Artikel haben sich über die Kreise der Spieleentwickler hinaus verbreitet, daher füge ich hinzu: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">ECS</a> " ( <em>dieser Wikipedia-Artikel ist übrigens schlecht, er kombiniert die Konzepte von EC und ECS, und dies ist nicht dasselbe ...</em> ) - dies ist eine gefälschte Vorlage, die innerhalb von Communities verbreitet wird Spieleentwickler.  Tatsächlich handelt es sich um eine Version des relationalen Modells, bei der „Entitäten“ nur IDs sind, die ein formloses Objekt kennzeichnen, „Komponenten“ Zeilen in bestimmten Tabellen sind, die auf IDs verweisen, und „Systeme“ Prozedurcode sind, der Komponenten ändern kann .  Diese „Vorlage“ wurde immer als Lösung für das Problem der übermäßigen Verwendung von Vererbung positioniert, es wird jedoch nicht erwähnt, dass die übermäßige Verwendung von Vererbung tatsächlich gegen die Empfehlungen des OOP verstößt.  Daher meine Empörung.  Dies ist nicht der „einzig wahre Weg“, Software zu schreiben.  Der Beitrag soll sicherstellen, dass die Leute tatsächlich etwas über bestehende Designprinzipien lernen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441174/">https://habr.com/ru/post/de441174/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441158/index.html">Wie Ethik zum teuersten Thema im Silicon Valley wurde und Philosophie zur praktischsten Lösung wurde</a></li>
<li><a href="../de441160/index.html">Wie man lernt zu bestimmen, wann man nein sagt</a></li>
<li><a href="../de441166/index.html">Wir erhalten das Master-Passwort vom gesperrten Passwort-Manager 1Password 4</a></li>
<li><a href="../de441168/index.html">QUIC DataChannels: Erste Schritte</a></li>
<li><a href="../de441172/index.html">Wie der 3D-Druckmarkt 2018 wuchs und was er für das Geschäft bedeutet</a></li>
<li><a href="../de441180/index.html">Bewölkt mit der Möglichkeit, die Sternenhimmelwerbung nicht zu deaktivieren</a></li>
<li><a href="../de441182/index.html">Maschinensynästhetischer Ansatz zur Erkennung von Netzwerk-DDoS-Angriffen. Teil 2</a></li>
<li><a href="../de441184/index.html">Die erste Spielekonferenz der Mail.ru Group</a></li>
<li><a href="../de441186/index.html">ASH Viewer: Neustart</a></li>
<li><a href="../de441192/index.html">Verwendung der Rechenleistung von R zum Testen der Hypothese der Mittelgleichheit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>