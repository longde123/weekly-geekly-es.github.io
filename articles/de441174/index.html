<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üâë üèüÔ∏è üë©üèæ‚Äçüéì OOP ist tot, es lebe OOP üïò üñïüèª üõ´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Inspirationsquellen 
 Dieser Beitrag entstand dank einer k√ºrzlich erschienenen Ver√∂ffentlichung von Aras Prantskevichus √ºber einen Bericht f√ºr Junior-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OOP ist tot, es lebe OOP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441174/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d22/8c2/d99/d228c2d99b9b17da94979d7fc5f728ee.png" alt="Bild"></div><br><h1>  Inspirationsquellen </h1><br>  Dieser Beitrag entstand dank einer k√ºrzlich erschienenen Ver√∂ffentlichung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Aras Prantskevichus</a> √ºber einen Bericht f√ºr Junior-Programmierer.  Es wird erl√§utert, wie Sie sich an neue ECS-Architekturen anpassen k√∂nnen.  Aras folgt dem √ºblichen Muster ( <em>Erkl√§rung unten</em> ): zeigt Beispiele f√ºr den schrecklichen OOP-Code und zeigt dann, dass das relationale Modell ( <em>nennt es aber eher ‚ÄûECS‚Äú als relational</em> ) eine gro√üartige Alternative ist.  Auf keinen Fall kritisiere ich Aras - ich bin ein gro√üer Fan seiner Arbeit und lobe ihn f√ºr seine hervorragende Pr√§sentation!  Ich habe seine Pr√§sentation anstelle von Hunderten anderer ECS-Beitr√§ge aus dem Internet gew√§hlt, weil er zus√§tzliche Anstrengungen unternommen und parallel zur Pr√§sentation ein Git-Repository f√ºr Studien ver√∂ffentlicht hat.  Es enth√§lt ein kleines einfaches ‚ÄûSpiel‚Äú, das als Beispiel f√ºr die Auswahl verschiedener Architekturl√∂sungen dient.  Dieses kleine Projekt erm√∂glichte es mir, meine Kommentare zu einem bestimmten Material zu demonstrieren. Danke, Aras! <br><br>  Aras-Folien sind hier verf√ºgbar: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">http://aras-p.info/texts/files/2018Academy - ECS-DoD.pdf</a> . Der Code befindet sich auf github: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">https://github.com/aras-p/dod-playground</a> . <br><br>  Ich werde (noch?) Die resultierende ECS-Architektur aus diesem Bericht nicht analysieren, sondern mich von Anfang an auf den ‚Äûschlechten OOP‚Äú -Code (√§hnlich dem ausgestopften Trick) konzentrieren.  Ich werde zeigen, wie es wirklich aussehen w√ºrde, wenn alle Verst√∂√üe gegen die Prinzipien von OOD (objektorientiertes Design, objektorientiertes Design) korrekt korrigiert w√ºrden. <br><br>  <strong>Spoiler: Die Beseitigung aller OOD-Verst√∂√üe f√ºhrt zu Leistungsverbesserungen √§hnlich wie bei der Konvertierung von Aras in ECS. Au√üerdem wird weniger RAM ben√∂tigt und es werden weniger Codezeilen ben√∂tigt als in der ECS-Version!</strong> <br><br>  <em>TL; DR: Bevor Sie zu dem Schluss kommen, dass OOP saugt und ECS-Laufwerke verwendet, halten Sie an und untersuchen Sie OOD (um zu wissen, wie OOP richtig verwendet wird) und verstehen Sie auch das relationale Modell (um zu wissen, wie ECS richtig angewendet wird).</em> <br><a name="habracut"></a><br>  Ich habe lange Zeit an vielen Diskussionen √ºber ECS im Forum teilgenommen, teilweise weil ich nicht denke, dass dieses Modell als separater Begriff verdient ( <em>Spoiler: Dies ist nur eine Ad-hoc-Version des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">relationalen Modells</a></em> ), sondern auch, weil Fast <em>jeder</em> Beitrag, <em>jede</em> Pr√§sentation oder <em>jeder</em> Artikel, der f√ºr ein ECS-Muster wirbt, folgt der folgenden Struktur: <br><br><ol><li>  Zeigen Sie ein Beispiel f√ºr schrecklichen OOP-Code, dessen Implementierung aufgrund √ºberm√§√üiger Vererbung schreckliche Fehler aufweist (was bedeutet, dass diese Implementierung gegen viele OOD-Prinzipien verst√∂√üt). <br></li><li>  Zu zeigen, dass Komposition eine bessere L√∂sung als Vererbung ist (und ganz zu schweigen davon, dass OOD uns tats√§chlich die gleiche Lektion erteilt). <br></li><li>  Zeigen Sie, dass das relationale Modell hervorragend f√ºr Spiele geeignet ist (nennen Sie es jedoch ‚ÄûECS‚Äú). </li></ol><br>  Eine solche Struktur macht mich w√ºtend, weil: <strong>(A)</strong> dies ein Trick ist, der "gestopft" ist ... er vergleicht weich mit warm (schlechter Code und guter Code) ... und dies ist unfair, selbst wenn es unbeabsichtigt gemacht wird und nicht erforderlich ist, um zu demonstrieren, dass die neue Architektur gut ist;  und was noch wichtiger ist: <strong>(B)</strong> es hat einen Nebeneffekt - ein solcher Ansatz unterdr√ºckt das Wissen und demotiviert die Leser versehentlich davon, mit Studien vertraut zu sein, die seit einem halben Jahrhundert durchgef√ºhrt wurden.  Sie begannen in den 1960er Jahren √ºber das relationale Modell zu schreiben.  In den 70er und 80er Jahren hat sich dieses Modell erheblich verbessert.  Anf√§nger haben oft Fragen wie "In <em>welche Klasse m√∂chten Sie diese Daten einf√ºgen?</em> " Und als Antwort wird ihnen oft etwas Unbestimmtes gesagt, wie " <em>Sie m√ºssen nur Erfahrung sammeln und dann lernen Sie nur, innerlich zu verstehen</em> " ... aber in den 70er Jahren war diese Frage aktiv studiert und im allgemeinen Fall wurde eine formelle Antwort abgeleitet;  Dies wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Datenbanknormalisierung bezeichnet</a> .  Wenn Sie vorhandene Forschungsergebnisse verwerfen und ECS als eine v√∂llig neue und moderne L√∂sung bezeichnen, verbergen Sie dieses Wissen vor Anf√§ngern. <br><br>  Die Grundlagen der objektorientierten Programmierung wurden vor ebenso langer, wenn nicht fr√ºherer Zeit gelegt ( <em>dieser Stil begann in den 1950er Jahren zu erforschen</em> )!  In den 1990er Jahren wurde die Objektorientierung jedoch modisch, viral und entwickelte sich sehr schnell zum vorherrschenden Programmierparadigma.  Die Popularit√§t vieler neuer OO-Sprachen, einschlie√ülich Java und der ( <em>standardisierten Version</em> ) C ++, ist explosionsartig gestiegen.  Da dies jedoch auf einen Hype zur√ºckzuf√ºhren war, musste jeder dieses hochkar√§tige Konzept kennen, um in seinen Lebenslauf schreiben zu k√∂nnen, aber nur wenige gingen wirklich darauf ein.  Diese neuen Sprachen haben die Schl√ºsselw√∂rter - <em>Klasse</em> , <em>virtuell</em> , <em>erweitert</em> , <em>implementiert</em> - aus vielen Funktionen von OO erstellt, und ich glaube, dass OO in diesem Moment in zwei separate Einheiten unterteilt wurde, die ihr eigenes Leben f√ºhren. <br><br>  Ich werde die Verwendung dieser OO-inspirierten Sprachfunktionen als ‚Äû <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">OOP</a></strong> ‚Äú und die Verwendung von OO-inspirierten Design- / Architekturtechniken als ‚Äû <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">OOD</a></strong> ‚Äú bezeichnen.  Alle haben sehr schnell die OOP aufgenommen.  Bildungseinrichtungen bieten OO-Kurse an, in denen neue OOP-Programmierer gebacken werden. Das Wissen √ºber OOD bleibt jedoch zur√ºck. <br><br>  Ich glaube, dass Code, der die Sprachfunktionen von OOP verwendet, aber nicht den Prinzipien des OOD-Designs folgt, <strong>kein OO-Code ist</strong> .  Die meisten Kritikpunkte gegen OOP verwenden beispielsweise entkernten Code, der eigentlich kein OO-Code ist. <br><br>  OOP-Code hat einen sehr schlechten Ruf, insbesondere weil der gr√∂√üte Teil des OOP-Codes nicht den Prinzipien von OOD folgt und daher kein ‚Äûwahrer‚Äú OO-Code ist. <br><br><h1>  Hintergrund </h1><br>  Wie oben erw√§hnt, wurden die 1990er Jahre zum H√∂hepunkt der ‚ÄûOO-Mode‚Äú, und zu dieser Zeit war die ‚Äûschlechte OOP‚Äú wahrscheinlich die schlechteste.  Wenn Sie zu diesem Zeitpunkt OOP studiert haben, haben Sie h√∂chstwahrscheinlich etwas √ºber die ‚Äûvier S√§ulen von OOP‚Äú gelernt: <br><br><ul><li>  Abstraktion </li><li>  Kapselung </li><li>  Polymorphismus </li><li>  Vererbung </li></ul><br>  Ich nenne sie lieber nicht vier S√§ulen, sondern ‚Äûvier OOP-Tools‚Äú.  Dies sind Tools, mit denen <em><strong>Sie</strong></em> Probleme l√∂sen k√∂nnen.  Es reicht jedoch nicht aus, nur herauszufinden, wie das Tool funktioniert. Sie m√ºssen wissen, wann Sie es verwenden m√ºssen. Seitens der Lehrer ist es unverantwortlich, den Menschen ein neues Tool beizubringen und ihnen nicht zu sagen, wann es sich lohnt, es zu verwenden.  In den fr√ºhen 2000er Jahren gab es Widerstand gegen den aktiven Missbrauch dieser Werkzeuge, eine Art ‚Äûzweite Welle‚Äú des OOD-Denkens.  Das Ergebnis war die Entstehung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">SOLID-</a> Mnemonik, mit der sich die architektonischen St√§rken schnell bewerten lie√üen.  Es sollte angemerkt werden, dass diese Weisheit in den 90er Jahren tats√§chlich weit verbreitet war, aber noch kein cooles Akronym erhalten hat, das es erm√∂glichte, sie als f√ºnf Grundprinzipien festzulegen ... <br><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Das Prinzip der alleinigen Verantwortung</a></strong> ( <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Prinzip der</a></strong> Einzelverantwortung).  Jede Klasse sollte nur einen Grund f√ºr die √Ñnderung haben.  Wenn die Klasse "A" zwei Verantwortlichkeiten hat, m√ºssen Sie die Klassen "B" und "C" erstellen, um jede einzeln zu verarbeiten, und dann "A" aus "B" und "C" erstellen. </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Das Prinzip der Offenheit / Schlie√üung</a></strong> ( <b>O</b> Stift / geschlossenes Prinzip).  Software √§ndert sich im Laufe der Zeit ( <em>d. H. Ihre Unterst√ºtzung ist wichtig</em> ).  Versuchen Sie, die Teile, die sich am wahrscheinlichsten √§ndern, in <em>Implementierungen (</em> <em>d. H. In bestimmten Klassen</em> ) zu platzieren und <em>Schnittstellen</em> basierend auf den Teilen zu erstellen, die sich wahrscheinlich nicht √§ndern ( <em>z. B. abstrakte Basisklassen</em> ). <br></li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Das Substitutionsprinzip von Barbara Liskov</a></strong> ( <b>L</b> iskov-Substitutionsprinzip).  Jede Implementierung einer Schnittstelle muss zu 100% die Anforderungen dieser Schnittstelle erf√ºllen, d. H.  Jeder Algorithmus, der mit einer Schnittstelle arbeitet, sollte mit jeder Implementierung funktionieren. </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Das Prinzip der Trennung der Schnittstelle</a></strong> (Prinzip <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">der Schnittstellentrennung</a></strong> ).  Machen Sie die Schnittstellen so klein wie m√∂glich, damit jeder Teil des Codes die kleinste Menge an Codebasis ‚Äûkennt‚Äú, um unn√∂tige Abh√§ngigkeiten zu vermeiden.  Dieser Tipp ist auch f√ºr C ++ geeignet, wo die Kompilierungszeiten sehr lang werden, wenn Sie ihn nicht befolgen. </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Das Prinzip der Abh√§ngigkeitsinversion</a></strong> ( <b>D-</b> Abh√§ngigkeitsinversionsprinzip).  Anstelle von zwei spezifischen Implementierungen, die direkt kommunizieren (und voneinander abh√§ngen), k√∂nnen sie normalerweise getrennt werden, indem ihre Kommunikationsschnittstelle als dritte Klasse formalisiert wird, die als Schnittstelle zwischen ihnen verwendet wird.  Es kann sich um eine abstrakte Basisklasse handeln, die die Aufrufe der zwischen ihnen verwendeten Methoden definiert, oder auch nur um eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">POD-</a> Struktur, die die zwischen ihnen √ºbertragenen Daten definiert. </li><li>  Ein anderes Prinzip ist im Akronym SOLID nicht enthalten, aber ich bin sicher, dass es sehr wichtig ist: <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">‚ÄûKomposition</a></strong> lieber als <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Vererbung‚Äú</a></strong> (Composite-Wiederverwendungsprinzip).  Die Zusammensetzung <em>ist standardm√§√üig die richtige Wahl</em> .  Die Vererbung sollte in F√§llen belassen werden, in denen dies unbedingt erforderlich ist. </li></ul><br>  Also bekommen wir SOLID-C (++) <img alt=":) :) :)" height="20" src="https://habrastorage.org/getpro/habr/post_images/e8d/c8c/1e8/e8dc8c1e846d52073e8f2a944b2006fa.png" width="20"><br><br>  Im Folgenden werde ich auf diese Prinzipien verweisen und sie als Akronyme bezeichnen - SRP, OCP, LSP, ISP, DIP, CRP ... <br><br>  Noch ein paar Anmerkungen: <br><br><ul><li>  In OOD k√∂nnen die Konzepte von <em>Schnittstellen</em> und <em>Implementierungen</em> nicht an bestimmte OOP-Schl√ºsselw√∂rter gebunden werden.  In C ++ erstellen wir h√§ufig Schnittstellen mit <em>abstrakten Basisklassen</em> und <em>virtuellen Funktionen</em> und erben dann <em>Implementierungen,</em> die von diesen Basisklassen geerbt werden. Dies ist jedoch nur eine spezielle Methode, um das Prinzip der Schnittstelle zu implementieren.  In C ++ k√∂nnen wir auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">PIMPL</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">undurchsichtige Zeiger</a> , Ententypisierung, typedef usw. verwenden. Sie k√∂nnen eine OOD-Struktur erstellen und diese dann in C implementieren, in dem es √ºberhaupt keine OOP-Sprachschl√ºsselw√∂rter gibt!  Wenn ich also √ºber <em>Schnittstellen</em> spreche, meine ich nicht unbedingt <em>virtuelle</em> Funktionen - ich spreche √ºber das Prinzip, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">die Implementierung zu verbergen</a> .  Schnittstellen <em>k√∂nnen</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">polymorph sein</a> , aber meistens sind sie es!  Polymorphismus wird sehr selten richtig verwendet, aber Schnittstellen sind ein grundlegendes Konzept f√ºr jede Software. <br><ul><li>  Wie ich oben klargestellt habe, wird diese Struktur als <em>Schnittstelle</em> verwendet, wenn Sie eine POD-Struktur erstellen, in der einfach einige Daten f√ºr die √úbertragung von einer Klasse zu einer anderen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">gespeichert werden</a> . Dies ist eine formale <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Beschreibung der Daten</a> . <br></li><li>  Selbst wenn Sie nur eine separate Klasse mit dem <em>√∂ffentlichen</em> und dem <em>privaten</em> Teil erstellen, ist alles, was sich im gemeinsamen Teil befindet, eine <em>Schnittstelle</em> , und alles im privaten Teil ist eine <em>Implementierung</em> . </li></ul></li><li>  Die Vererbung hat tats√§chlich (mindestens) zwei Typen - Schnittstellenvererbung und Implementierungsvererbung. <br><ul><li>  In C ++ umfasst die Schnittstellenvererbung abstrakte Basisklassen mit rein virtuellen Funktionen, PIMPL und bedingtem Typedef.  In Java wird die Schnittstellenvererbung durch das Schl√ºsselwort <em>implements</em> ausgedr√ºckt. </li><li>  In C ++ erfolgt die Vererbung von Implementierungen jedes Mal, wenn die Basisklassen etwas anderes als reine virtuelle Funktionen enthalten.  In Java wird die Vererbung der Implementierung mit dem <em>Schl√ºsselwort</em> extenses ausgedr√ºckt. </li><li>  OOD hat viele Regeln f√ºr das Erben von Schnittstellen, aber die Vererbung von Implementierungen ist normalerweise als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">"Code mit einem Biss" zu betrachten</a> ! </li></ul></li></ul><br>  Und schlie√ülich sollte ich einige Beispiele f√ºr das schreckliche OOP-Training zeigen und wie es im wirklichen Leben zu schlechtem Code f√ºhrt (und zu OOPs schlechtem Ruf). <br><br><ol><li>  Als Ihnen Hierarchien / Vererbung beigebracht wurde, wurde Ihnen m√∂glicherweise eine √§hnliche Aufgabe √ºbertragen: <strong><em>Angenommen, Sie haben eine Universit√§tsanwendung, die ein Verzeichnis von Studenten und Mitarbeitern enth√§lt.</em></strong>  <strong><em>Sie k√∂nnen die Basisklasse Person und dann die von Person geerbte Sch√ºlerklasse und die Staff-Klasse erstellen.</em></strong> <br><br>  Nein nein Nein.  Hier werde ich dich aufhalten.  Die unausgesprochene Implikation des LSP-Prinzips ist, dass <em>Klassenhierarchien</em> und die <em>Algorithmen, die sie verarbeiten,</em> symbiotisch sind.  Dies sind zwei H√§lften des gesamten Programms.  OOP ist eine Erweiterung der prozeduralen Programmierung und wird immer noch haupts√§chlich mit diesen Prozeduren in Verbindung gebracht.  Wenn wir nicht wissen, welche Arten von Algorithmen mit <i>Sch√ºlern</i> und <em>Mitarbeitern</em> funktionieren ( <em>und welche Algorithmen aufgrund von Polymorphismus vereinfacht werden</em> ), ist es v√∂llig unverantwortlich, mit der Erstellung der Struktur von Klassenhierarchien zu beginnen.  Zuerst m√ºssen Sie die Algorithmen <em>und</em> Daten kennen. </li><li>  Als Ihnen Hierarchien / Vererbung beigebracht wurde, wurde Ihnen wahrscheinlich eine √§hnliche Aufgabe √ºbertragen: <b><i>Angenommen, Sie haben eine Klasse von Formen.</i></b>  <b><i>Wir haben auch Quadrate und Rechtecke als Unterklassen.</i></b>  <b><i>Sollte ein Quadrat ein Rechteck oder ein Rechteck ein Quadrat sein?</i></b> <br><br>  Dies ist tats√§chlich ein gutes Beispiel, um den Unterschied zwischen der Vererbung von Implementierungen und der Vererbung von Schnittstellen zu demonstrieren. <br><ul><li>  Wenn Sie den Implementierungsvererbungsansatz verwenden, ignorieren Sie den LSP vollst√§ndig und denken aus praktischer Sicht √ºber die M√∂glichkeit nach, Code unter Verwendung der Vererbung als Werkzeug wiederzuverwenden. <br><br>  Unter diesem Gesichtspunkt ist Folgendes vollkommen logisch: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class"> :</span></span> Square { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; };</code> </pre> <br>  Das Quadrat hat nur die Breite und das Rechteck hat die Breite + H√∂he, dh wenn wir das Quadrat mit der H√∂henkomponente erweitern, erhalten wir ein Rechteck! <br><ul><li>  Wie Sie vielleicht vermutet haben, sagt OOD, dass dies ( <em>wahrscheinlich</em> ) falsch ist.  Ich sagte <em>"wahrscheinlich",</em> weil Sie hier √ºber die impliziten Eigenschaften der Schnittstelle streiten k√∂nnen ... na ja. <br><br>  Ein Quadrat hat immer die gleiche H√∂he und Breite. Von der Benutzeroberfl√§che des Quadrats aus kann man also davon ausgehen, dass der Bereich "Breite * Breite" ist. <br><br>  Beim Erben eines Quadrats muss die Klasse der Rechtecke (gem√§√ü LSP) den Regeln der quadratischen Schnittstelle entsprechen.  Jeder Algorithmus, der f√ºr ein Quadrat korrekt funktioniert, sollte auch f√ºr ein Rechteck korrekt funktionieren. </li><li>  Nehmen Sie einen anderen Algorithmus: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Square*&gt; shapes; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> area = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> s : shapes) area += s-&gt;width * s-&gt;width;</code> </pre> <br>  Es funktioniert korrekt f√ºr Quadrate (Berechnung der Summe ihrer Fl√§chen), aber nicht f√ºr Rechtecke. <br><br>  Daher verst√∂√üt das Rechteck gegen das LSP-Prinzip. </li></ul></li><li>  Wenn Sie den Ansatz der Schnittstellenvererbung verwenden, erben weder Square noch Rectangle voneinander.  Die Schnittstellen f√ºr das Quadrat und das Rechteck sind tats√§chlich unterschiedlich, und eine ist keine Obermenge der anderen. <br></li><li>  Daher r√§t OOD von der Verwendung der Implementierungsvererbung ab.  Wie oben erw√§hnt, ist OOD die richtige Wahl, wenn Sie Code wiederverwenden m√∂chten! <br><ul><li>  Die <i>korrekte</i> Version des obigen (fehlerhaften) Codes f√ºr die Vererbungshierarchie von C ++ - Implementierungen sieht also folgenderma√üen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Shape { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> width * width; }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Square, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Shape { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> width * height; }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; };</code> </pre> <br><ul><li>  "Public Virtual" bedeutet in Java "implementiert".  Wird bei der Implementierung der Schnittstelle verwendet. <br></li><li>  Mit "Privat" k√∂nnen Sie die Basisklasse erweitern, ohne ihre Schnittstelle zu erben. In diesem Fall ist das Rechteck <b>kein</b> Quadrat, obwohl es von ihm erbt. <br></li></ul></li><li>  Ich empfehle nicht, solchen Code zu schreiben, aber wenn Sie die Vererbung von Implementierungen verwenden m√∂chten, m√ºssen Sie genau das tun! </li></ul></li></ul></li></ol><br>  TL; DR - Ihre OOP-Klasse hat Ihnen gesagt, wie Vererbung war.  Ihre fehlende OOD-Klasse h√§tte Ihnen sagen sollen, dass Sie sie 99% der Zeit nicht verwenden sollen! <br><br><h1>  Entit√§ts- / Komponentenkonzepte </h1><br>  Nachdem wir uns mit den Voraussetzungen befasst haben, gehen wir weiter zu dem Punkt, an dem Aras begonnen hat - zum sogenannten Ausgangspunkt eines ‚Äûtypischen OOP‚Äú. <br><br>  Aber f√ºr den Anfang noch eine Erg√§nzung: Aras nennt diesen Code ‚Äûtraditionelles OOP‚Äú, und ich m√∂chte dem widersprechen.  Dieser Code mag f√ºr OOP in der realen Welt typisch sein, verst√∂√üt jedoch wie die obigen Beispiele gegen alle Arten von Grundprinzipien von OO und sollte daher √ºberhaupt nicht als traditionell angesehen werden. <br><br>  Ich werde mit dem ersten Commit beginnen, bevor er die Struktur in Richtung ECS ‚Äã‚Äãneu erstellt: <a href="" rel="external nofollow">‚ÄûDamit es wieder unter Windows funktioniert‚Äú 3529f232510c95f53112bbfff87df6bbc6aa1fae</a> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ------------------------------------------------------------------------------------------------- // super simple "component system" class GameObject; class Component; typedef std::vector&lt;Component*&gt; ComponentVector; typedef std::vector&lt;GameObject*&gt; GameObjectVector; // Component base class. Knows about the parent game object, and has some virtual methods. class Component { public: Component() : m_GameObject(nullptr) {} virtual ~Component() {} virtual void Start() {} virtual void Update(double time, float deltaTime) {} const GameObject&amp; GetGameObject() const { return *m_GameObject; } GameObject&amp; GetGameObject() { return *m_GameObject; } void SetGameObject(GameObject&amp; go) { m_GameObject = &amp;go; } bool HasGameObject() const { return m_GameObject != nullptr; } private: GameObject* m_GameObject; }; // Game object class. Has an array of components. class GameObject { public: GameObject(const std::string&amp;&amp; name) : m_Name(name) { } ~GameObject() { // game object owns the components; destroy them when deleting the game object for (auto c : m_Components) delete c; } // get a component of type T, or null if it does not exist on this game object template&lt;typename T&gt; T* GetComponent() { for (auto i : m_Components) { T* c = dynamic_cast&lt;T*&gt;(i); if (c != nullptr) return c; } return nullptr; } // add a new component to this game object void AddComponent(Component* c) { assert(!c-&gt;HasGameObject()); c-&gt;SetGameObject(*this); m_Components.emplace_back(c); } void Start() { for (auto c : m_Components) c-&gt;Start(); } void Update(double time, float deltaTime) { for (auto c : m_Components) c-&gt;Update(time, deltaTime); } private: std::string m_Name; ComponentVector m_Components; }; // The "scene": array of game objects. static GameObjectVector s_Objects; // Finds all components of given type in the whole scene template&lt;typename T&gt; static ComponentVector FindAllComponentsOfType() { ComponentVector res; for (auto go : s_Objects) { T* c = go-&gt;GetComponent&lt;T&gt;(); if (c != nullptr) res.emplace_back(c); } return res; } // Find one component of given type in the scene (returns first found one) template&lt;typename T&gt; static T* FindOfType() { for (auto go : s_Objects) { T* c = go-&gt;GetComponent&lt;T&gt;(); if (c != nullptr) return c; } return nullptr; }</span></span></code> </pre> <br>  Ja, es ist schwierig, sofort hundert Codezeilen herauszufinden. Beginnen wir also schrittweise ... Wir brauchen einen weiteren Aspekt der Voraussetzungen - es war beliebt, die Vererbung in Spielen der 90er Jahre zu verwenden, um alle Probleme der Wiederverwendung von Code zu l√∂sen.  Sie hatten Entit√§t, erweiterbaren Charakter, erweiterbaren Player und Monster und so weiter ... Dies ist eine Vererbung von Implementierungen, wie wir zuvor beschrieben haben ( <em>"Code mit einem Choke"</em> ), und es scheint richtig zu sein, damit zu beginnen, aber als Ergebnis f√ºhrt dies zu einem sehr unflexible Codebasis.  Weil OOD das oben beschriebene Prinzip ‚ÄûZusammensetzung √ºber Vererbung‚Äú hat.  In den 2000er Jahren wurde das Prinzip ‚ÄûKomposition √ºber Vererbung‚Äú popul√§r, und Spieleentwickler begannen, √§hnlichen Code zu schreiben. <br><br>  Was macht dieser Code?  Na ja nicht gut <img alt=": D." height="20" src="https://habrastorage.org/getpro/habr/post_images/4c3/d02/890/4c3d028909133f97a7a351651c98c08b.png" title=": D." width="20"><br><br>  Kurz gesagt, <strong>dieser Code implementiert ein vorhandenes Merkmal der Sprache erneut - Komposition</strong> als Laufzeitbibliothek und nicht als Merkmal der Sprache.  Sie k√∂nnen sich das so vorstellen, als w√ºrde der Code tats√§chlich eine neue Metasprache √ºber C ++ und eine virtuelle Maschine (VM) erstellen, um diese Metasprache auszuf√ºhren.  Im Aras-Demospiel ist dieser Code nicht erforderlich ( <em>wir werden ihn bald vollst√§ndig entfernen!</em> ) Und dient nur dazu, die Spielleistung um das Zehnfache zu reduzieren. <br><br>  Aber was macht er eigentlich?  Dies ist das Konzept des " <strong>E</strong> ntity / <strong>C</strong> omponent-Systems" ( <em>manchmal aus irgendeinem Grund als " <strong>E</strong> ntity / <strong>C</strong> omponent-System" bezeichnet</em> ), es unterscheidet sich jedoch vollst√§ndig vom Konzept des " <strong>E</strong> ntity <strong>C"</strong> omponent System "(" Entity-Component-System ") ( <em>das aus offensichtlichen Gr√ºnden niemals als</em> " Entity Component System System " <em>bezeichnet wird</em> ). Es formalisiert mehrere Prinzipien der" EC ": <br><br><ul><li>  Das Spiel besteht aus Funktionen von "Entities" ("Entity") ( <em>in diesem Beispiel</em> GameObjects), die aus "Components" ("Component") bestehen. </li><li>  GameObjects implementieren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">das Muster "Service Locator"</a> - ihre untergeordneten Komponenten werden nach Typ abgefragt. </li><li>  Komponenten wissen, zu welchem ‚Äã‚ÄãGameObject sie geh√∂ren - sie k√∂nnen Komponenten finden, die sich auf derselben Ebene wie sie befinden, indem sie das √ºbergeordnete GameObject abfragen. <br></li><li>  Die Komposition kann nur eine Ebene tief sein ( <em>Komponenten k√∂nnen keine eigenen untergeordneten Komponenten haben, GameObjects k√∂nnen keine untergeordneten GameObjects haben</em> ). <br></li><li>  GameObject kann nur eine Komponente jedes Typs haben ( <em>in einigen Frameworks ist dies eine obligatorische Anforderung, in anderen nicht</em> ). <br></li><li>  Jede Komponente √§ndert sich (wahrscheinlich) im Laufe der Zeit auf eine nicht spezifizierte Weise, sodass die Schnittstelle ein "Virtual Void Update" enth√§lt. <br></li><li>  GameObjects geh√∂ren zu einer Szene, die Abfragen f√ºr alle GameObjects (und damit f√ºr alle Komponenten) ausf√ºhren kann. </li></ul><br>  Ein √§hnliches Konzept war in den 2000er Jahren sehr beliebt und erwies sich trotz seiner Einschr√§nkungen als flexibel genug, um damals und heute unz√§hlige Spiele zu erstellen. <br><br>  Dies ist jedoch nicht erforderlich.  Ihre Programmiersprache unterst√ºtzt bereits die Komposition als Merkmal der Sprache - es ist kein aufgebl√§htes Konzept erforderlich, um darauf zuzugreifen ... Warum gibt es diese Konzepte dann?  Um ehrlich zu sein, k√∂nnen Sie zur <em>Laufzeit dynamische Kompositionen durchf√ºhren</em> .  Anstatt GameObject-Typen im Code hart zu definieren, k√∂nnen Sie sie aus Datendateien laden.  Und das ist sehr praktisch, weil es Spiel- / Level-Designern erm√∂glicht, ihre eigenen Objekttypen zu erstellen ... In den meisten Spielprojekten gibt es jedoch nur sehr wenige Designer und buchst√§blich eine ganze Armee von Programmierern, daher w√ºrde ich argumentieren, dass dies eine wichtige Gelegenheit ist.  Schlimmer noch, dies ist nicht die einzige M√∂glichkeit, eine Komposition zur Laufzeit zu implementieren!  Zum Beispiel verwendet Unity C # als "Skriptsprache", und viele andere Spiele verwenden seine Alternativen, zum Beispiel Lua - ein praktisches Tool f√ºr Designer, das C # / Lua-Code generieren kann, um neue Spielobjekte zu definieren, ohne dass ein derart aufgebl√§htes Konzept erforderlich ist!  Wir werden dieses "Feature" im n√§chsten Beitrag erneut hinzuf√ºgen und so gestalten, dass es uns keinen zehnfachen Leistungsabfall kostet ... <br><br>  Lassen Sie uns diesen Code gem√§√ü OOD bewerten: <br><br><ul><li>  GameObject :: GetComponent verwendet dynamic_cast.  Die meisten Leute werden Ihnen sagen, dass dynamic_cast ein "Code mit einem Choke" ist, ein gro√üer Hinweis darauf, dass Sie irgendwo einen Fehler haben.  Ich w√ºrde dies sagen - dies ist ein Beweis daf√ºr, dass Sie gegen den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">LSP</a> versto√üen haben - Sie haben eine Art Algorithmus, der mit der Basisschnittstelle funktioniert, aber er muss verschiedene Implementierungsdetails kennen.  Aus diesem Grund riecht der Code schlecht. <br></li><li>  GameObject ist im Prinzip nicht schlecht, wenn Sie sich vorstellen, dass es die Vorlage "Service Locator" implementiert ... aber wenn Sie aus Sicht von OOD √ºber die Kritik hinausgehen, stellt diese Vorlage implizite Verbindungen zwischen Teilen des Projekts her, und ich denke ( <em>ohne einen Link zu Wikipedia, der dies unterst√ºtzen kann Ich mit Kenntnissen aus der Informatik</em> ), dass implizite Kommunikationskan√§le ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Gegenmuster</a> sind und explizite Kommunikationskan√§le bevorzugen sollten.  Das gleiche Argument gilt f√ºr das aufgebl√§hte "Konzept der Ereignisse", die manchmal in Spielen verwendet werden ... <br></li><li>  Ich m√∂chte feststellen, dass eine Komponente eine Verletzung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">SRP darstellt,</a> weil ihre Schnittstelle ( <em>Virtual Void Update (Zeit)</em> ) zu breit ist.  Die Verwendung von "Virtual Void Update" in der Spieleentwicklung ist allgegenw√§rtig, aber ich w√ºrde auch sagen, dass es sich um ein Antimuster handelt.  Gute Software sollte es Ihnen erm√∂glichen, leicht √ºber Kontrollfluss und Datenfluss nachzudenken.  Wenn Sie <em>jedes Element des Gameplay-Codes</em> hinter dem Aufruf "Virtual Void Update" platzieren, werden der Kontrollstrom und der Datenstrom vollst√§ndig und vollst√§ndig verschleiert.  IMHO, unsichtbare <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Nebenwirkungen</a> , auch als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Fernwirkung bezeichnet,</a> sind einige der h√§ufigsten Fehlerquellen, und ‚ÄûVirtual Void Update‚Äú stellt sicher, dass fast alles eine unsichtbare Nebenwirkung ist. <br></li><li>  Obwohl das Ziel der Component-Klasse darin besteht, die Komposition zu aktivieren, erfolgt dies durch Vererbung, was eine Verletzung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">CRP darstellt</a> . </li><li>  Die einzig gute Seite dieses Beispiels ist, dass der Spielcode √ºbertrieben ist, um den Prinzipien von SRP und ISP zu entsprechen - er ist in viele einfache Komponenten mit sehr geringer Verantwortung unterteilt, was sich hervorragend f√ºr die Wiederverwendung von Code eignet. <br><br>  Er ist jedoch nicht so gut darin, DIP aufrechtzuerhalten - viele Komponenten kennen sich direkt. </li></ul><br>  Der gesamte oben gezeigte Code kann also tats√§chlich gel√∂scht werden.  Diese ganze Struktur.  L√∂schen Sie GameObject (in anderen Frameworks auch Entity genannt), entfernen Sie Component und l√∂schen Sie FindOfType.  Dies ist Teil einer nutzlosen VM, die gegen OOD-Prinzipien verst√∂√üt und unser Spiel schrecklich verlangsamt. <br><br><h1>  Komposition ohne Frameworks (d. H. Unter Verwendung von Merkmalen der Programmiersprache selbst) </h1><br>  Wie k√∂nnen unsere GameObjects die Komposition verwenden und aus Komponenten bestehen, wenn wir das Kompositionsframework entfernen und nicht √ºber die Component-Basisklasse verf√ºgen?  Wie der Titel schon sagt, anstatt diese aufgebl√§hte VM zu schreiben und GameObjects in einer seltsamen Metasprache dar√ºber zu erstellen, schreiben wir sie einfach in C ++, weil wir Spielprogrammierer sind und dies buchst√§blich unsere Aufgabe ist. <br><br>  Hier ist das Commit, mit dem das Entity / Component-Framework entfernt wurde: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">https://github.com/hodgman/dod-playground/commit/f42290d0217d700dea2ed002f2f3b1dc45e8c27c</a> <br><br>  Hier ist die Originalversion des Quellcodes: <a href="" rel="external nofollow">https://github.com/hodgman/dod-playground/blob/3529f232510c95f53112bbfff87df6bbc6aa1fae/source/game.cpp</a> <br><br>  Hier ist die ge√§nderte Version des Quellcodes: <a href="" rel="external nofollow">https://github.com/hodgman/dod-playground/blob/f42290d0217d700dea2ed002f2f3b1dc45e8c27c/source/game.cpp</a> <br><br>  Kurz zu den √Ñnderungen: <br><br><ul><li>  ": Public Component" wurde aus jedem Komponententyp entfernt. <br></li><li>  Jedem Komponententyp wurde ein Konstruktor hinzugef√ºgt. <br><ul><li>  Bei OOD geht es haupts√§chlich darum, den Status einer Klasse zu kapseln. Da diese Klassen jedoch so klein / einfach sind, gibt es nichts Besonderes zu verbergen: Eine Schnittstelle ist eine Beschreibung der Daten.  Einer der Hauptgr√ºnde daf√ºr, dass die Kapselung die Haupts√§ule ist, besteht darin, dass wir die konstante Wahrheit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">von Klasseninvarianten</a> garantieren k√∂nnen. Wenn die Invariante gebrochen ist, m√ºssen Sie nur den gekapselten Implementierungscode untersuchen, um den Fehler zu finden.  In diesem Codebeispiel lohnt es sich, Konstruktoren hinzuzuf√ºgen, um eine einfache Invariante zu implementieren - alle Werte m√ºssen initialisiert werden. </li></ul></li><li>  Ich habe die zu allgemeinen "Update" -Methoden umbenannt, damit ihre Namen das widerspiegeln, was sie tats√§chlich tun - UpdatePosition f√ºr MoveComponent und ResolveCollisions f√ºr AvoidComponent. <br></li><li>  Ich habe drei fest codierte Codebl√∂cke entfernt, die einer Vorlage / einem Fertighaus √§hnelten - den Code, der ein GameObject mit bestimmten Komponententypen erstellt, und es durch drei C ++ - Klassen ersetzt. <br></li><li>  Antipattern "Virtual Void Update" beseitigt. <br></li><li>  Anstatt dass die Komponenten √ºber die Vorlage "Service Locator" nacheinander suchen, werden sie w√§hrend des Aufbaus vom Spiel explizit miteinander verbunden. </li></ul><br><h2>  Die Objekte </h2><br>  Daher anstelle dieses Codes f√ºr "virtuelle Maschinen": <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// create regular objects that move for (auto i = 0; i &lt; kObjectCount; ++i) { GameObject* go = new GameObject("object"); // position it within world bounds PositionComponent* pos = new PositionComponent(); pos-&gt;x = RandomFloat(bounds-&gt;xMin, bounds-&gt;xMax); pos-&gt;y = RandomFloat(bounds-&gt;yMin, bounds-&gt;yMax); go-&gt;AddComponent(pos); // setup a sprite for it (random sprite index from first 5), and initial white color SpriteComponent* sprite = new SpriteComponent(); sprite-&gt;colorR = 1.0f; sprite-&gt;colorG = 1.0f; sprite-&gt;colorB = 1.0f; sprite-&gt;spriteIndex = rand() % 5; sprite-&gt;scale = 1.0f; go-&gt;AddComponent(sprite); // make it move MoveComponent* move = new MoveComponent(0.5f, 0.7f); go-&gt;AddComponent(move); // make it avoid the bubble things AvoidComponent* avoid = new AvoidComponent(); go-&gt;AddComponent(avoid); s_Objects.emplace_back(go); }</span></span></code> </pre> <br>  Wir haben jetzt regul√§ren C ++ - Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegularObject</span></span></span><span class="hljs-class"> {</span></span> PositionComponent pos; SpriteComponent sprite; MoveComponent move; AvoidComponent avoid; RegularObject(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> WorldBoundsComponent&amp; bounds) : move(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.7f</span></span>) <span class="hljs-comment"><span class="hljs-comment">// position it within world bounds , pos(RandomFloat(bounds.xMin, bounds.xMax), RandomFloat(bounds.yMin, bounds.yMax)) // setup a sprite for it (random sprite index from first 5), and initial white color , sprite(1.0f, 1.0f, 1.0f, rand() % 5, 1.0f) { } }; ... // create regular objects that move regularObject.reserve(kObjectCount); for (auto i = 0; i &lt; kObjectCount; ++i) regularObject.emplace_back(bounds);</span></span></code> </pre> <br><h2>  Algorithmen </h2><br>  Eine weitere wichtige √Ñnderung wurde an den Algorithmen vorgenommen.  Denken Sie daran, am Anfang habe ich gesagt, dass Schnittstellen und Algorithmen in Symbiose funktionieren und sich gegenseitig beeinflussen sollten.  So ist auch hier das Antipattern " <em>Virtual Void Update</em> " zum Feind geworden.  Der Anfangscode enth√§lt den Hauptschleifenalgorithmus, der nur aus folgenden Elementen besteht: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// go through all objects for (auto go : s_Objects) { // Update all their components go-&gt;Update(time, deltaTime);</span></span></code> </pre> <br>  Sie k√∂nnen argumentieren, dass es sch√∂n und einfach ist, aber meiner Meinung nach ist es sehr, sehr schlecht.  Dies verschleiert sowohl den <em>Kontrollfluss</em> als auch den <em>Datenfluss</em> innerhalb des Spiels vollst√§ndig.  Wenn wir unsere Software verstehen wollen, wenn wir sie unterst√ºtzen wollen, wenn wir neue Dinge hinzuf√ºgen, optimieren, effizient auf mehreren Prozessorkernen ausf√ºhren wollen, m√ºssen wir sowohl den Kontrollfluss als auch den Datenfluss verstehen.  Daher muss "Virtual Void Update" in Brand gesetzt werden. <br><br>  Stattdessen haben wir eine explizitere Hauptschleife erstellt, die das Verst√§ndnis des Kontrollflusses erheblich vereinfacht (der darin <em>enthaltene Datenfluss ist immer noch verschleiert, wir werden dies jedoch in den folgenden Commits beheben</em> ). <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Update all positions for (auto&amp; go : s_game-&gt;regularObject) { UpdatePosition(deltaTime, go, s_game-&gt;bounds.wb); } for (auto&amp; go : s_game-&gt;avoidThis) { UpdatePosition(deltaTime, go, s_game-&gt;bounds.wb); } // Resolve all collisions for (auto&amp; go : s_game-&gt;regularObject) { ResolveCollisions(deltaTime, go, s_game-&gt;avoidThis); }</span></span></code> </pre> <br>  Der Nachteil dieses Stils ist, dass wir f√ºr <em>jeden neuen Objekttyp</em> , der dem Spiel hinzugef√ºgt wird, mehrere Zeilen zur Hauptschleife hinzuf√ºgen m√ºssen.  Ich werde in einem sp√§teren Beitrag aus dieser Serie darauf zur√ºckkommen. <br><br><h1>  Leistung </h1><br>  Es gibt viele gro√üe OOD-Verst√∂√üe, einige schlechte Entscheidungen werden bei der Auswahl einer Struktur getroffen und es gibt viele M√∂glichkeiten zur Optimierung, aber ich werde im n√§chsten Beitrag der Serie darauf eingehen.  Bereits zu diesem Zeitpunkt ist jedoch klar, dass die Version mit ‚Äûfestem OOD‚Äú fast vollst√§ndig mit dem endg√ºltigen ‚ÄûECS‚Äú -Code am Ende der Pr√§sentation √ºbereinstimmt oder diesen gewinnt. Und wir haben nur den schlechten Pseudo-OOP-Code genommen und daf√ºr gesorgt, dass er den Prinzipien entspricht OOP (und auch hundert Codezeilen gel√∂scht)! <br><br><div style="text-align:center;"><img alt="img" src="https://habrastorage.org/getpro/habr/post_images/d22/8c2/d99/d228c2d99b9b17da94979d7fc5f728ee.png"></div><br><h1>  N√§chste Schritte </h1><br>  Hier m√∂chte ich ein viel breiteres Spektrum von Problemen betrachten, einschlie√ülich der L√∂sung der verbleibenden OOD-Probleme, unver√§nderlicher Objekte ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Programmierung in einem funktionalen Stil</a> ) und der Vorteile, die sie in Diskussionen √ºber Datenfl√ºsse, Nachrichten√ºbermittlung und Anwendung der DOD-Logik auf unseren OOD-Code bringen k√∂nnen. Anwenden relevanter Weisheit in OOD-Code, Entfernen dieser Klassen von ‚ÄûEntit√§ten‚Äú, mit denen wir am Ende endeten, und Verwenden nur reiner Komponenten unter Verwendung verschiedener Stile zum Verbinden von Komponenten (Vergleichen von Zeigern und  die Verantwortung zu tragen) Komponenten von Beh√§ltern aus der realen Welt, ECS-Revision Version f√ºr eine bessere Optimierung, sowie die weitere Optimierung, die nicht im Bericht Aras <em>(wie Multi-Threading / SIMD) erw√§hnt.</em>  Die Reihenfolge wird nicht unbedingt so sein, und vielleicht werde ich nicht alle oben genannten Punkte ber√ºcksichtigen ... <br><br><h1>  Erg√§nzung </h1><br>  Die Links zu dem Artikel haben sich √ºber die Kreise der Spieleentwickler hinaus verbreitet, daher f√ºge ich hinzu: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">ECS</a> " ( <em>dieser Wikipedia-Artikel ist √ºbrigens schlecht, er kombiniert die Konzepte von EC und ECS, und dies ist nicht dasselbe ...</em> ) - dies ist eine gef√§lschte Vorlage, die innerhalb von Communities verbreitet wird Spieleentwickler.  Tats√§chlich handelt es sich um eine Version des relationalen Modells, bei der ‚ÄûEntit√§ten‚Äú nur IDs sind, die ein formloses Objekt kennzeichnen, ‚ÄûKomponenten‚Äú Zeilen in bestimmten Tabellen sind, die auf IDs verweisen, und ‚ÄûSysteme‚Äú Prozedurcode sind, der Komponenten √§ndern kann .  Diese ‚ÄûVorlage‚Äú wurde immer als L√∂sung f√ºr das Problem der √ºberm√§√üigen Verwendung von Vererbung positioniert, es wird jedoch nicht erw√§hnt, dass die √ºberm√§√üige Verwendung von Vererbung tats√§chlich gegen die Empfehlungen des OOP verst√∂√üt.  Daher meine Emp√∂rung.  Dies ist nicht der ‚Äûeinzig wahre Weg‚Äú, Software zu schreiben.  Der Beitrag soll sicherstellen, dass die Leute tats√§chlich etwas √ºber bestehende Designprinzipien lernen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441174/">https://habr.com/ru/post/de441174/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441158/index.html">Wie Ethik zum teuersten Thema im Silicon Valley wurde und Philosophie zur praktischsten L√∂sung wurde</a></li>
<li><a href="../de441160/index.html">Wie man lernt zu bestimmen, wann man nein sagt</a></li>
<li><a href="../de441166/index.html">Wir erhalten das Master-Passwort vom gesperrten Passwort-Manager 1Password 4</a></li>
<li><a href="../de441168/index.html">QUIC DataChannels: Erste Schritte</a></li>
<li><a href="../de441172/index.html">Wie der 3D-Druckmarkt 2018 wuchs und was er f√ºr das Gesch√§ft bedeutet</a></li>
<li><a href="../de441180/index.html">Bew√∂lkt mit der M√∂glichkeit, die Sternenhimmelwerbung nicht zu deaktivieren</a></li>
<li><a href="../de441182/index.html">Maschinensyn√§sthetischer Ansatz zur Erkennung von Netzwerk-DDoS-Angriffen. Teil 2</a></li>
<li><a href="../de441184/index.html">Die erste Spielekonferenz der Mail.ru Group</a></li>
<li><a href="../de441186/index.html">ASH Viewer: Neustart</a></li>
<li><a href="../de441192/index.html">Verwendung der Rechenleistung von R zum Testen der Hypothese der Mittelgleichheit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>