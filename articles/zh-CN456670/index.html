<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕕 🛬 🌰 关于非常间谍身份验证方法 ⛪️ 👨🏻‍🎤 👤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="因此，我们将超级特工爱丽丝（Alice）和鲍勃（Bob）送到一个秘密国家的秘密基地。 在执行任务期间，他们将必须联系并一起工作，交换信息，进行日常间谍活动。 当然，所有这些都必须遵守所有可能的规则和安全程序。 


 的确，在最后一轮，我们想向他们透露：特派团本身和特工本身以及所有国家安全都处于危险...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>关于非常间谍身份验证方法</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456670/"><p>因此，我们将超级特工爱丽丝（Alice）和鲍勃（Bob）送到一个秘密国家的秘密基地。 在执行任务期间，他们将必须联系并一起工作，交换信息，进行日常间谍活动。 当然，所有这些都必须遵守所有可能的规则和安全程序。 </p><br><p> 的确，在最后一轮，我们想向他们透露：特派团本身和特工本身以及所有国家安全都处于危险之中。 因此，向间谍提供最少的必要信息符合我们的利益。 特别是，他们对彼此和通信技术的了解越少越好。 </p><br><p> 但是，他们将如何确定其总部战友？ </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ceb/454/721/ceb4547217be4972a9e5f8fe323cf257.gif" alt="KDPV"></p><br><p>  TL; DR-为不存在的国家的虚构的三个字符的机构发明了使用隐写术的用户身份验证机制。 </p><a name="habracut"></a><br><h2 id="o-volkah-i-ovechih-shkurah"> 关于狼和羊皮 </h2><br><p> 封面是封面，所以爱丽丝和鲍勃都不应该因其任何行为引起怀疑。 适当的计划意味着对在所有可能的水平上对其进行持续监视的偏执狂。 这篇文章不会解决直接交换信息的任务（它应该拥有自己的单独系列），而仅仅是确保信息被需要的人传递给需要的人的一种方式。 </p><br><p> 而且，两个间谍极有可能以普通公民的身份拥有历史，而且彼此之间毫无联系。 因此，您必须立即否决使用传统的加密工具和安全通道-每个反情报代理都知道，没有亲密关系的诚实人没有什么可隐瞒的。 </p><br><h2 id="chto-delat"> 怎么办 </h2><br><p> 当然，这样的任务并不是新任务，它很高兴地存在并且早在您的Internet出现之前就已解决。 而且不仅做出了决定，所以一些决定在文化上得到了加强，并且仍然存在于书籍，电影和游戏中。 </p><br><p> 让我们看一个这样的场景：两个穿着大衣的人在一个公共场所会聚，交换非常奇怪的短语。 如果发起的短语和答案正确，则身份验证成功，并且人们交换标记为“最高机密”的文件夹，并在未知的方向分散。 </p><br><p> 这种方案的缺点很明显-短语必须保密并且<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">经常更改</a> ，这在敌方领土上并不是很简单。 同时，为了不被偶然发声并且不引出KDPV的情况，它们变得相当突出和随机，这意味着他们可以发出发声者。 </p><br><p><img src="https://habrastorage.org/webt/pl/pe/sh/plpeshe7ifcmijrxlaziosekgey.png"></p><br><p> 在数字技术时代，我们不喜欢这种方法。 尤其是当您回想起几乎所有的沟通渠道都是由某人控制的时，无论动机是好是坏。 而且，无论他们向我们保证什么，人们的生活都不应受到任何Facebook隐私政策的信任。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/984/c5d/c5d/984c5dc5dae5cba450b58907693ceed6.png"></p><br><h2 id="steganografiya-opyat"> 隐写术（再次？） </h2><br><p> 刺猬很明显，在这种情况下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">彼此隐藏</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">能力</a>比以往任何时候都更具吸引力。 实际上，即使所描述的方法是其亚种-代码短语也可以视为内部仅包含一点信息的容器。 </p><br><p> 食虫动物科的同一哺乳动物了解到，这并不是简单地将隐蔽容器互相扔。 与某些普通的PGP加密相比，这种交换将引起几乎更多的怀疑，因此我们不感兴趣。 </p><br><h3 id="a-o-chem-togda"> 那怎么办 </h3><br><p> 与密码不同，隐秘容器具有明显的优势-应用程序上下文。 除了明显的内容以外，任何文本，图像，音频文件等也都具有进行<strong>自然</strong>讨论的可能性，不仅可以从海湾发送，而且可以在不引起怀疑的对话过程中发送。 </p><br><p> 有了这样的想法，我们就可以基于公共密钥草拟一个简单的隐写身份验证协议： </p><br><ul><li>  A-&gt; B：一条漂亮的消息，要求隐匿某些参数的容器； </li><li>  B：选择与请求的上下文和参数匹配的容器<em>C</em> ； </li><li>  B：类似地创建消息<em>M</em> ； </li><li>  B-&gt; A： <em>C'=嵌入（C，M，K）</em> ； </li><li>  A：检查<em>C'</em>是否符合设置的参数； </li><li>  A-&gt; B： <em>M'=提取（C'，K）</em> ； </li><li>  B：检查<em>M</em>和<em>M'是否</em>匹配。 </li></ul><br><p> 这样的协议有明显的缺点-Alice和Bob必须同时具有公用密钥以及嵌入和提取功能。 他们的妥协可能导致对敌人的身份验证方法进行详细分析的可能性，并危及其他用户和总部。 需要修复某些问题。 </p><br><h2 id="ispolnitel-ne-cherepashka"> 艺术家不是臭虫 </h2><br><p> 如果读者在计算机课问世之后上学，那么他应该记得使用乌龟，蚂蚁等表演者学习算法的基础知识。 他们的想法是演示通过创建简单程序来优化大量手动单项操作的可能性。 为了解决我们的问题，我们需要朝相反的方向发展。 </p><br><p><img src="https://habrastorage.org/webt/nc/lo/lo/nclolotljunb2zzbkgr2-4qo0ri.png" alt="好吧，不是很可爱吗？"></p><br><p> 由于我们可以根据给定的参数简化最终算法的编写过程，从步骤序列到过程描述，因此我们可以执行逆过程。 如果您将容器想象成是其某些组件的数组，那么按键嵌入消息可以写为在容器元素上具有各种常数参数的特定索引处的有序操作序列。 </p><br><p> 这是非数学开始的地方，所以我请胆小的人简单地将难看的段落翻到运算部分，甚至更进一步。 我保证，没有可怕的事情会发生。 </p><br><p> 要嵌入数据，我们需要以下形式的序列： <em>（f1，S1，i，D1），（f2，S2，j，D2）...</em> ，其中： </p><br><ul><li>  <em>Di-</em>嵌入式数据的某些部分； </li><li>  <em>i，j</em>是容器元素的索引； </li><li>  <em>fi：（状态，元素，D）-&gt;（状态，元素）</em> -嵌入函数; </li><li>  <em>Si</em>是操作的上下文， <em>（El'，S [i + 1]）= fi（Si，El，Di）</em> 。 </li></ul><br><p> 要提取它，您不需要存储部分数据（K.O.），因此有足够的三元组： <em>（g1，S1，I1），（g2，S2，I2）...</em>具有相同的值，只有<em>gi：（State，Element）-&gt; （状态D）</em> 。 </p><br><p> 所有这些可以通过下面的对称图表示。 如果由于某种原因我未能弄清楚，那就不吓人了，请继续阅读。 </p><br><p><img src="https://habrastorage.org/webt/l7/yk/pk/l7ykpkwfi8sfkcebwxryswzo1r0.png" alt="好还是没有"></p><br><p> 可以看出，嵌入功能具有更大的自由度。 与她的姐姐不同，她修改了容器，同时基于两个独立的元素（嵌入式数据和元素）进行了修改。 谢谢，或更确切地说，正因为如此，通过这种系统实现隐写算法的两种全局方法是可行的： </p><br><ol><li> 选择最合适的元素索引以根据嵌入功能进行更改（最不明显或根本不需要），然后将形成的序列绑定到特定容器。 使用这种方法，在需要使用诸如加密和其他安全媒体之类的经典方法进行嵌入之前，需要将它们彼此隔离。 </li><li> 找到一种将容器划分为元素和嵌入函数的方法，以使容器进行的任何预期更改都将同样不可见。 在这种情况下，序列与容器无关，甚至可以由完全随机的生成器创建。 灵活性降低，最坏情况无法控制。 另一方面，这种方法在现场应用时更简单，更方便，因此下面我将使用它。 </li></ol><br><p> 如果算法不需要状态，则以上所有内容仍然有效，只是在图中没有单个字母和块。 实际上，没有它，它甚至更加容易。 </p><br><h2 id="i-zachem-ono-nam"> 为什么我们需要它？ </h2><br><p> 现在，如果您预先知道将使用哪个容器来使用消息和密钥，而不是完全公开算法的各个部分，则可以生成并提供仅用于相似序列的代理，并为其提供解释器。 好吧，当然，不仅仅是奉献，以后还会更多。 </p><br><h3 id="dobavlyaem-asimmetrichnost"> 添加不对称 </h3><br><p> 即使是乌龟艺术家也可以通过数百种不同的方式绘制正方形，只需更改操作顺序并添加新的操作即可。 这意味着没有人会打扰我们，并且不会对固定输入数据的描述序列做同样的事情。 </p><br><p> 也就是说，我们可以采用嵌入顺序，添加新操作，将其全部混合，以使结果保持不变。 除非存在状态，否则将有必要对其进行跟踪并为序列单独添加必要的更改。 这就是为什么没有它会更容易，是的。 </p><br><p> 经过这样的揉捏和嘈杂，一种或另一种方式，甚至嵌入者本人也将不再能够理解他实际嵌入的内容： <em>N个</em>操作的任何序列都将代表<em>N！</em> 潜在的嵌入消息-嵌入部分的每个排列对应一个。 同时， <em>N</em>本身是一个大问题。 因此，可以将这样的序列称为开放-它们既不提供有关嵌入消息的信息，也不提供有关所使用的算法和密钥的任何信息。 </p><br><p> 在提取信息时，对于我们（从所有可能的位置恢复相同的正确消息）和要提取的部分数量这两个方面都非常重要，因此提取顺序从诞生之日起就保持不变。 由于它们隐式包含有关所使用的密钥，生成器和算法的信息，因此像红皮书中的动物一样，需要对其进行存储和保护。 并保密。 </p><br><p> 不对称与它有什么关系？ 事实是，现在每个提取序列都与无限数量的嵌入器相关联。 在通常情况下，一个与另一个的还原是一项艰巨的任务。 </p><br><h3 id="ekspluatiruem"> 我们正在经营 </h3><br><p> 我们忘记了任何近乎数学的知识，回到原来的任务-我们如何将爱丽丝和鲍勃送到敌方领土，以便： </p><br><ul><li> 他们不认识对方的脸 </li><li> 手头没有秘密算法 </li><li> 但是您可以在开放频道上进行交流时互相验证吗？ </li></ul><br><p> 好吧，在第一段中，所有内容都很清楚，我们只是不向他们提供彼此的任何明确信息，也没有共享密钥。 第二，您需要记住上面协议的描述。 现在，我们可以直接排除代表潜在状态机密和所有这些内容的<em>Embed</em>和<em>Extract</em>算法。 并且，考虑到这一点，对于第三个协议，可以制定以下两阶段协议。 </p><br><p>  <strong>在任务开始之前</strong>生成身份验证信息，总部是Trent的可信任方： </p><br><ul><li>  T：选择密钥算法和密钥K，并在其帮助下创建： <br><ul><li> 提取序列<em>Ex</em> ; </li><li> 适用于身份验证（在下面）的<em>Ctx</em>上下文； </li></ul></li><li>  T-&gt; A： <em>Ctx，Ex</em> ； </li><li>  T：使用<em>Ex</em>和创建的上下文，生成： <br><ul><li> 消息<em>M</em>先前未用于零件中的所选代理<em>| Ex |</em>  ; </li><li>  <em>Em</em>的一次性序列，如上所述将其打开； </li></ul></li><li>  T-&gt; B： <em>Em，h（M）</em> （如果需要）创建其他集合。 </li></ul><br><p> 因此，爱丽丝在所有场合和未来联系的上下文中只有一个序列，而鲍勃成为其中嵌入的一组一次性序列和消息哈希的快乐所有者。 </p><br><p>  <strong>任务期间</strong>已经存在的身份验证协议如下所示： </p><br><ul><li>  A-&gt; B：基于<em>Ctx</em>上下文并带有容器描述的启动<em>IM</em>消息； </li><li>  B：选择合适的<em>C〜IM</em> ； </li><li>  B-&gt; A： <em>C'= Em（C）</em> ； </li><li> 答：检查是否符合<em>C'〜IM</em> （由于更改是不可见的，因此应将其保存）； </li><li>  A-&gt; B： <em>M'= Ex（C'）</em> ，标记为M'。 </li><li>  B：检查， <em>h（M'）== h（M）</em> ，破坏<em>Em，h（M）</em> 。 </li></ul><br><p> 细心的读者会注意到，在协议之前，爱丽丝和鲍勃只有一套信息，这本身对他们或潜在的对手都没有任何意义，仅在“玩弄颜色”期间。 </p><br><p> 每个开放的Bob集仅使用一次，这由Alice的倒数第二步控制。 当遇到另一个人以前使用过的<em>M</em> （因此她看不见<em>Em</em> ）时，她意识到自己的一个“同伴”是假货。 </p><br><p> 同一个人的反复使用告诉她，她不了解协议的复杂性，而且肯定不是与她联系的人。 好吧，迟到总比没有好。 </p><br><p><img src="https://habrastorage.org/webt/bv/6v/0h/bv6v0hcim8kmzndrvn5__thsp1y.png"></p><br><p> 好的，这就是所有看起来太复杂和不可理解的地方。 有人来过吗？ </p><br><p> 让我们更好地在实践中进行演示，因为即使是间谍本身也不需要知道使用协议的细节，更不用说贫穷的读者了。 刚开始的时候，它只是关于如何实现的。 </p><br><h2 id="vysokie-tehnologii"> 高科技 </h2><br><p> 因此，仅需编写该协议所需的所有内容。 好吧，尽管您可以做到，但您并不能做任何事情。 今天，我的代码的受害者将是…… <em>命运之轮</em> ……Java？ 好吧，好吧，与此同时，STL中的所有功能都将成为现实，您无需寻找任何东西。 </p><br><p> 让我们从所需的API开始。 要工作，只需要确定容器元素数组的类即可通过索引接收和更改元素： </p><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyContainer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StegoContainer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyElement</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> MyElement </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  i-  } public void set(int i, MyElement v) { //  i-  } public int size() { //    } }</span></span></code> </pre> <br><p> 减少了进一步的使用，以在必要的容器上创建隐写自动机的包装，并将嵌入和提取的功能提供给其输入： </p><br><pre> <code class="java hljs">StegoMachine&lt;MyState, MyElement&gt; myMachine = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StegoMachine( initialState, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyContainer&lt;MyElement&gt;(<span class="hljs-comment"><span class="hljs-comment">/*   */</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> StegoEmbed myEmbed = (st, el, dp) -&gt; { <span class="hljs-comment"><span class="hljs-comment">//    dp   el   st }; final StegoExtract myExtract = (st, el) -&gt; { //     el   st return dp; }; //    MyDataPart part = /*    */; myMachine.exec(1337, myEmbed, part); //... //    /,   //      State currState = myMachine.getState(); //... //    part = myMachine.exec(80085, myExtract); //... //        MyContainer container = (MyContainer) myMachine.getContainer();</span></span></code> </pre> <br><p> 如果算法的实现不需要维护内部状态，则以相同的方式使用带有后缀Stateless的类。 </p><br><p> 序列生成器可以根据需要工作，并且没有通用的API。 在一般情况下，任何东西一般都可以成为数据的一部分，从单独的位到单独的编码中的摇滚艺术品。 </p><br><h3 id="primer-realizacii"> 实施实例 </h3><br><h4 id="o-metode"> 关于方法 </h4><br><p> 作为实现的示例，使用创建的接口，我实现了LSB系列的一种简单算法，用于具有无损压缩的位图图像。 它们的元素是在所有RGB分量的最低有效位中没有邻居的像素。  embed函数与源数据的单个位一起使用，并且仅更改组件之一（索引将指向）的值的低位。 </p><br><p> 这很简单，但是对于实现协议非常有用，因为根据他们的选择改变任何元素同样是不可察觉的，因此要更改的元素的索引是使用随机生成器生成的。 对于Java，使用<em>SecureRandom</em> ，但是如果需要的话，它很容易更改为其熵源。 </p><br><p>  <em>不过，这是一种非常简单的方法，我不建议将其用于真实间谍。</em> </p><br><h4 id="o-heshah"> 关于哈希 </h4><br><p> 由于文本趋向于根据代理的模拟身份而失真（有些不放大写字母，另一些不喜欢放表情符号等，其他通常不识字），因此我建议使用sha256来计算哈希值，但只能使用小写的印刷单词： </p><br><pre> <code class="plaintext hljs">h("Hello world?...") == h("hello, world!11")</code> </pre> <br><h4 id="ob-interfeyse"> 关于界面 </h4><br><p> 该软件包包括两个部分-一个部分用于生成序列，其他用于Trent的哈希，另一部分用于嵌入和检查收到的消息是否符合要求。 </p><br><p> 两者的工作都从命令行通过其参数和输入输出流进行；没有其他接口被交付（恐惧和恐惧）。 仍然，作为总部的雇员，间谍-意味着具有某种资格。 好吧，如果没有，我仍然会举一个例子。 </p><br><div class="spoiler">  <b class="spoiler_title">这是一个帮助</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/yx/1m/ge/yx1mge8ligshzbsv7hxi3olw__g.png" alt="用法截图"></p><br></div></div><br><h3 id="chto-im-vsem-delat-to"> 他们都做什么？ </h3><br><p> 首先，总部的Trent需要制定身份验证信息。 特别是要事先考虑代理将工作的情况。 </p><br><p> 例如，假设Bob是图形自由职业者，而Alice是他的客户。 身份验证将以创建图形/设计/其他东西的命令为幌子进行。 </p><br><p> 我们向双方报告此有用信息，并返回到协议本身。 我们将预先准备合适的<em>M.txt</em>嵌入式消息，以减少其中的字符数：“它非常适合在我汇款的地方。” 使用Trent实用程序生成<em>Em</em>和<em>Ex</em> ： </p><br><pre> <code class="bash hljs">Trent@HQWorkstation:~$ java -jar HQUtil.jar -ex $(<span class="hljs-built_in"><span class="hljs-built_in">stat</span></span> -c%s <span class="hljs-string"><span class="hljs-string">"M.txt"</span></span>) 4096 &gt; Ex.txt Trent@HQWorkstation:~$ cat Ex.txt | java -jar HQUtil.jar -em <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(cat M.txt)</span></span></span><span class="hljs-string">"</span></span> 0.25 4096 &gt; Em.txt Trent@HQWorkstation:~$ cat M.txt | java -jar HQUtil.jar -h &gt; hash.bin</code> </pre> <br><p>  <code>$(stat -c%s "M.txt")</code>返回消息的大小（以字节为单位），以及<code>$(stat -c%s "M.txt")</code>所生成索引范围的限制（以允许使用较小的容器）。 同样， <code>$(cat M.txt)</code>用于将消息本身传递给命令行参数。 原则上，您可以使用自己的体力劳动来避免重击，但是对谁来说更方便。 </p><br><p>  <em>Ex.txt</em>传递给Alice， <em>Em.txt</em>和<em>hash.bin传递</em>给Bob。 现在，假设代理已成功部署并希望彼此通信-我们继续执行协议。 鲍勃将自己的简历或工作机会交换出去，爱丽丝开始交流： </p><br><pre> <code class="plaintext hljs">: ,     %_% :        ,   .  ? : ,   </code> </pre> <br><p> 鲍勃寻找一把雨伞的图像，如果灵魂有创造力，甚至可以自己绘制一把雨伞，或者稍加压缩/施加水印（或者自由职业者现在在那做的事情），然后执行以下操作： </p><br><pre> <code class="bash hljs">Bob@PC:~$ cat Em.txt | java -jar SpyUtil.jar -e umbrella.png</code> </pre> <br><p> 等待一会儿，假装上班，如果实际上他没有做，他自然会考虑上下文，将已收到的容器发送给Alice： </p><br><pre> <code class="plaintext hljs">: ,  ,     </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">传送带信息的雨伞，670kb</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/qw/nk/in/qwnkinuhpppynf6ve9gkrmpnehm.png"></p></div></div><br><p> 依次检索内部存储的消息： </p><br><pre> <code class="bash hljs">Alice@PC:~$ cat Ex.txt | java -jar SpyUtil.jar -e umbrella.png      </code> </pre> <br><p> 将一组单词转换为普通句子并将其发送给Bob： </p><br><pre> <code class="plaintext hljs">: ,  ,   ?</code> </pre><br><p> 他检查消息的准确性： </p><br><pre> <code class="java hljs">Bob<span class="hljs-meta"><span class="hljs-meta">@PC</span></span>:~$ java -jar SpyUtil.jar -c hash.bin <span class="hljs-string"><span class="hljs-string">",  ,   ?"</span></span> ,  ,   ? - Correct</code> </pre><br><p> 如果一切正常，并继续进行轻松的交流。 观察者的整个对话看起来像这样： </p><br><div class="spoiler">  <b class="spoiler_title">500 KB gif</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ff/ye/he/ffyeheonv4qo9dxdjygalg8kvtq.gif"></p></div></div><br><p> 显然，在所有这些拦截中，反情报都不会发现任何可疑的东西。 实际上，在这种情况下，甚至隐身分析方法也不会总是被应用-好吧，有人以5美元的价格订购了一把雨伞的照片，他们发现了一些令互联网感到惊讶的东西。 计算资源和人员并非无休止地检查每种情况。 认证成功，大幕。 </p><br><p>  -&gt; <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN456670/">https://habr.com/ru/post/zh-CN456670/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN456658/index.html">成长：我们如何评估团队技能</a></li>
<li><a href="../zh-CN456662/index.html">如何使用测试驱动的开发为治疗师省钱</a></li>
<li><a href="../zh-CN456664/index.html">机器人赔钱时该向谁起诉</a></li>
<li><a href="../zh-CN456666/index.html">Web图腾或我们如何使互联网更安全</a></li>
<li><a href="../zh-CN456668/index.html">Microsoft ML Spark：Spark扩展，使SparkML更人性化，LightGBM作为奖励</a></li>
<li><a href="../zh-CN456672/index.html">Nginx配方：从PostgreSQL到websocket的异步通知</a></li>
<li><a href="../zh-CN456674/index.html">您不知道的在Facebook上推广的新机会</a></li>
<li><a href="../zh-CN456676/index.html">登录分布式php应用程序</a></li>
<li><a href="../zh-CN456678/index.html">未来的电子状态。 第4部分</a></li>
<li><a href="../zh-CN456680/index.html">UX设计中的八种命名法（第2部分）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>