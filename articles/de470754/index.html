<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤕 👨‍🍳 ❗️ RASA Chatbot: Parallelen Erfahrung 👨‍👦‍👦 🥠 ☢️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Chatbot-Branche boomt. Anfangs waren sie dumm genug und konnten einen Dialog mit dem Benutzer führen, führend sein und mögliche Antworten anbieten...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RASA Chatbot: Parallelen Erfahrung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/parallels/blog/470754/"><img src="https://habrastorage.org/webt/v-/c5/a0/v-c5a0h7xtstdf2m4u5ivyr1gli.jpeg"><br><br>  Die Chatbot-Branche boomt.  Anfangs waren sie dumm genug und konnten einen Dialog mit dem Benutzer führen, führend sein und mögliche Antworten anbieten.  Dann wurden die Bots etwas schlauer und forderten vom Benutzer Texteingaben, um die Antworten mit Schlüsselwörtern zu versehen.  Die Entwicklung des maschinellen Lernens hat dazu geführt, dass die Fähigkeit zur Kommunikation mit dem Bot und der Stimme entstanden ist.  Die meisten Lösungen gingen jedoch nicht sehr weit von der gleichen Konstruktion des Dialogdiagramms und dem Übergang zwischen seinen Knoten durch Schlüsselwörter entfernt. <a name="habracut"></a><br><br>  Vor kurzem haben wir bei Parallels beschlossen, eine Reihe interner Prozesse zu optimieren und als Experiment einen Bot für unsere eigenen Bedürfnisse zu erstellen.  Nach einer kurzen Suche beschlossen wir, unser Glück beim Open-Source-Projekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RASA</a> zu versuchen.  Laut den Entwicklern selbst haben sie einen Chat-Bot der dritten Generation erstellt.  Das heißt, dieser Bot umgeht nicht nur das Zustandsdiagramm, sondern kann den Kontext des vorherigen Dialogfelds speichern und verwenden.  Bis heute sieht die beste Illustration für moderne Chat-Bots ungefähr so ​​aus: <br><br><img src="https://habrastorage.org/webt/wi/d6/ks/wid6ksu-v47injjfrc2gvccl2uw.png"><br><br>  Das heißt, Chat-Bots sind nur eine Reihe verifizierter Regeln für den Wechsel von einem Punkt in der Grafik zu einem anderen.  Wenn Sie sich die vorhandenen Lösungen der Giganten des Marktes ansehen, gibt es tatsächlich nichts, was sich von den dortigen Regeln unterscheidet.  Grob gesagt sieht dieses Set ungefähr so ​​aus: <br><br>  Dialog an Punkt XXX. <br>  Wenn der Benutzer ein Angebot mit den Worten ['Kaufen', 'Ticket'] eingegeben hat, fahren Sie mit dem Punkt „WO FRAGEN“ fort. <br>  Wenn der Benutzer ein Angebot mit den Worten ['kaufen', 'Schnitzel'] eingegeben hat, fahren Sie mit dem Punkt „FRAGEN VON WAS“ fort. <br><br>  Es ist sofort klar, dass es hier Müll ist, wenn der Benutzer eingibt: "Ich möchte ein Ticket nach Porto kaufen", wird er immer noch gefragt: "Wohin möchten Sie gehen?"  Um den Dialog humaner zu gestalten, müssen Sie neue Regeln hinzufügen, was zu tun ist, wenn es einen Hinweis auf den Ort gibt. <br>  Fügen Sie dann Regeln hinzu, was zu tun ist, wenn Ort und Zeit angegeben sind, und so weiter. <br><br>  Dieses Regelwerk wird schnell genug wachsen, aber es ist nicht das Schlimmste. Alle „richtigen“ Wege können beschrieben, verbessert und geleckt werden. <br><br>  Das Unangenehmste ist, dass eine Person im Gegensatz zu einem Bot eine unvorhersehbare Kreatur ist und jederzeit ganz anders fragen kann.  Das heißt, in dem Moment, in dem der Bot bereits bereit ist, ein Ticket zu buchen, kann eine Person fragen: "Übrigens, was ist mit dem Wetter?"  oder "obwohl nicht, möchte ich in mein Auto steigen, wie lange dauert die Straße?" <br><br>  Dies kann er jedoch auch im Moment nach der Wahl einer Stadt, aber vor der Wahl einer Abfahrtszeit oder sogar der Wahl eines Ortes, an den er gehen möchte, erfragen.  Der Bot, der auf Zustandsautomaten basiert, wird blockieren und seine mechanischen Pseudopoden werden traurig zucken und der Benutzer wird frustriert sein. <br><br>  Hier können (und sollten) Sie maschinelles Lernen anwenden.  Dann treten jedoch neue Probleme auf: Wenn Sie beispielsweise das Verstärkungstraining verwenden, um Übergänge zu Diagrammpunkten vorherzusagen, stellen sich Fragen: Woher erhalten Sie die Daten für dieses Training und wer bewertet die Qualität der Antworten? <br><br>  Es ist unwahrscheinlich, dass Benutzer zustimmen, Ihren Bot zu unterrichten, und wie die Praxis zeigt, kann eine Benutzergemeinschaft einem Bot überhaupt nicht beibringen, was Sie wollen und was die Gesellschaft für anständig hält.  Darüber hinaus reagiert der Bot in der Anfangsphase völlig fehl am Platz, was die Benutzer nervös macht und sich im Prinzip nicht mit dieser Unterstützung herumschlägt. <br><br>  Nachdem die RASA-Entwickler alle Mängel der vorhandenen Bots analysiert und überlegt hatten, versuchten sie, die Probleme wie folgt zu lösen: <br><br><ul><li>  Jede Eingabe des Benutzers erfolgt über die „Bestimmung der Absicht“, dh der durch maschinelles Lernen eingegebene Text wird einer (oder mehreren) Absichten zugeordnet.  Bei Bedarf werden Entitäten auch vom Text isoliert und dem Speicher des Bots hinzugefügt. </li><li>  Dieser Prozess ähnelt anderen Bots mit Ausnahme des verwendeten Absichtsbestimmungsmodells. </li><li>  Die nächste Aktion des Bots wird mithilfe von maschinellem Lernen basierend auf dem Kontext, dh den vorherigen Aktionen, Absichten und dem Speicherstatus des Bots, vorhergesagt. </li><li>  Gleichzeitig werden für das erste Training nicht viele Daten benötigt, und der Bot kann durchaus vorhersagen, welche Aktion auch ohne bestimmte Beispiele und Regeln ausgeführt werden soll. </li></ul><br>  Betrachten Sie die Arbeitsmechanismen genauer. <br><br><h3>  <font color="#cc0000">RASA NLU</font> </h3><br>  Beginnen wir mit dem ersten Wal, auf dem der Bot ruht.  Dies ist ein Verständnis der natürlichen Sprache, das aus zwei Hauptteilen besteht: Bestimmung der Absicht und Anerkennung von Entitäten. <br><br>  <b>Absichtserkennung</b> <br>  Die Bestimmung der Absicht basiert auf einem modifizierten Algorithmus namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">StarSpace</a> von Facebook, der auf Tensorflow implementiert ist.  In diesem Fall werden keine vorab trainierten Modelle von Vektordarstellungen von Wörtern verwendet, sodass Sie die Einschränkungen dieser Darstellungen umgehen können. <br><br>  Das Bestimmen der Absicht in RASA-Algorithmen funktioniert beispielsweise für jede Sprache sowie für bestimmte Wörter, die Sie in den Trainingsbeispielen angeben.  Bei der Implementierung durch vorab trainierte Vektordarstellungen wie GloVe oder word2vec verursacht die Lokalisierung des Bots und seine Anwendung in hochspezialisierten Bereichen genügend Kopfschmerzen. <br><br>  Der Algorithmus basiert auf der Vektorisierung von Sätzen durch eine Vielzahl von Wörtern und dem Vergleich ihrer „Ähnlichkeit“.  Beispiele für Absichten und Absichten selbst werden unter Verwendung einer Worttasche in Vektoren umgewandelt und der Eingabe der entsprechenden neuronalen Netze zugeführt.  Am Ausgang des neuronalen Netzwerks wird ein Vektor für diesen bestimmten Satz von Wörtern erhalten (dieselbe Einbettung). <br><br>  Das Training findet so statt, dass die Verlustfunktion in Form der Summe paarweiser Abstände (entweder Kosinus- oder Vektorprodukte) zwischen zwei ähnlichen Vektoren und k-unterschiedlichen Vektoren minimiert wird.  Somit wird nach dem Training jeder Absicht ein bestimmter Vektor zugeordnet. <br><br>  Nach Erhalt der Benutzereingaben wird der Vorschlag auf ähnliche Weise vektorisiert und durch das trainierte Modell geführt.  Danach wird der Abstand vom resultierenden Vektor zu allen Absichtsvektoren berechnet.  Das Ergebnis wird eingestuft, wobei die wahrscheinlichsten Absichten hervorgehoben und negative Werte abgeschnitten werden, dh völlig unähnlich. <br><br>  Zusätzlich zu den oben genannten Brötchen können Sie mit diesem Ansatz automatisch mehr als eine Absicht vom Vorschlag unterscheiden.  Zum Beispiel: „Ja, das habe ich verstanden.  Aber wie kann ich jetzt nach Hause kommen? "  Wird als "intent_confirm + intent_how_to_drive" erkannt, wodurch Sie humanere Dialoge mit dem Bot erstellen können. <br><br>  Übrigens können Sie vor dem Training künstliche Sätze aus Beispielen erstellen, indem Sie vorhandene mischen, um die Anzahl der Trainingsbeispiele zu erhöhen. <br><br><h3>  <font color="#cc0000">RASA-Entitätserkennung</font> </h3><br>  Der zweite Teil der NLU ist das Extrahieren von Entitäten aus Text.  Ein Benutzer schreibt beispielsweise: „Ich möchte mit zwei Freunden in ein chinesisches Restaurant gehen.“ Der Bot muss nicht nur die Absicht, sondern auch die entsprechenden Daten hervorheben.  Das heißt, füllen Sie Ihr Gedächtnis aus, dass die Gerichte im Restaurant chinesisch sein sollten und dass die Anzahl der Besucher drei beträgt. <br><br>  Hierfür wird ein Ansatz verwendet, der auf bedingten Zufallsfeldern basiert und bereits irgendwo im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Habré beschrieben wurde</a> , sodass ich ihn nicht wiederholen werde.  Wer dies wünscht, kann diesen Algorithmus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf der Stanford-Website</a> nachlesen. <br><br>  Außerdem stelle ich fest, dass Sie Entitäten aus Text abrufen können, der auf Vorlagen, Texten (z. B. Städtenamen) basiert, sowie eine Verbindung zu einem separaten Facebook-Entlein-Dienst herstellen können, über den Sie auch eines Tages gerne schreiben würden. <br><br><h3>  <font color="#cc0000">RASA Geschichten</font> </h3><br>  Der zweite Blauwal, auf dem RASA Core basiert, sind Geschichten.  Das allgemeine Wesen der Geschichten sind Beispiele für echte Gespräche mit dem Bot, die als Absichtsreaktion formatiert sind.  Basierend auf diesen Geschichten wird ein wiederkehrendes neuronales Netzwerk (LSTM) trainiert, das den vorherigen Nachrichtenverlauf der gewünschten Aktion zuordnet.  Auf diese Weise können Sie Diagramme von Dialogen nicht starr festlegen und nicht alle möglichen Zustände und Übergänge zwischen ihnen bestimmen. <br><br>  Mit einer ausreichenden Anzahl von Beispielen wird das Netzwerk den nächsten Status für den Übergang angemessen vorhersagen, unabhängig vom Vorhandensein eines bestimmten Beispiels.  Leider ist die genaue Anzahl der Geschichten dafür nicht bekannt, und alles, woran man sich orientieren kann, ist der Satz der Entwickler: "Je mehr, desto besser." <br><br>  Um das System zu trainieren und nicht nur einige erfundene Dialoge dort aufzuzeichnen, können Sie interaktives Training verwenden. <br><br>  Es gibt zwei Möglichkeiten: <br>  1. Lassen Sie eine Reihe von Ingenieuren Gespräche mit dem Bot führen und korrigieren Sie falsche Vorhersagen, falsche Definitionen von Entitäten und Stecker, um Aktionen für Geschichten vorherzusagen. <br><br>  2. Speichern Sie Konversationen in der Datenbank und verwenden Sie dann speziell geschulte Techniker, um die Dialoge zu betrachten, in denen der Benutzer sein Problem nicht lösen konnte, dh zu einer Person gewechselt wurde oder der Bot seine Hilflosigkeit eingestand und nicht antworten konnte. <br><br>  Um den Mechanismus von Geschichten zu verstehen, ist es am einfachsten, ein einfaches Beispiel zu analysieren.  Angenommen, eine Tischreservierung in einem Restaurant, ein Beispiel, das von den Entwicklern im Abschnitt mit den Quellcodebeispielen bereitgestellt wurde.  Zuerst bestimmen wir unsere Absichten und dann machen wir ein paar Geschichten. <br><br>  Absichten und ihre Beispiele: <br><br>  Intent_hello <br><ul><li>  Hallo </li><li>  Hallo </li><li>  Aloha </li><li>  Guten Morgen </li></ul><br>  ... <br>  Absicht_Danke <br><ul><li>  Danke </li><li>  Schön </li><li>  Danke </li></ul><br>  ... <br>  Intent_request <br><ul><li>  Tschüss überspringen </li></ul><br>  Intent_inform <br><ul><li>  Tschüss überspringen </li></ul><br>  Als nächstes müssen Sie den Speicher des Bots festlegen, dh die Slots bestimmen, in denen aufgezeichnet wird, was der Benutzer benötigt.  Definieren Sie die Slots: <br><br>  Küche: <br>  Typ: nicht funktionsfähig <br>  auto_fill: false <br>  num_people: <br>  Typ: nicht funktionsfähig <br>  auto_fill: false <br><br>  Und jetzt werden wir Beispiele (einen kleinen Teil) für die oben ausgelassenen Absichten zeigen.  Die Klammern in den Beispielen sind die Daten für das Training von Ner_CRF im Format [Entität] (Variablenname für die Speicherung: Was wir speichern). <br><br>  intent_request_restaurant <br><ul><li>  Ich bin auf der Suche nach einem Restaurant </li><li>  Kann ich [schwedisches] (Küchen-) Essen für [sechs Personen] bekommen (num_people: 6)? </li><li>  ein Restaurant, das [karibische] (Küche) Essen serviert </li><li>  Ich bin wie ein Restaurant </li><li>  Ich bin auf der Suche nach einem Restaurant, das [mediterrane] (Küche) Essen serviert </li></ul><br>  intent_inform <br><ul><li>  [2] (num_people) Personen </li><li>  für [drei] (num_people: 3) Personen </li><li>  nur [eine] (num_people: 1) Person </li><li>  wie wäre es mit [asiatisch orientalisch] (Küche) </li><li>  Was ist mit [indischem] (Küchen-) Essen? </li><li>  Wie wäre es mit [türkisch] (Küche) Art von Essen </li><li>  um [englisch] (Küche) </li></ul><br>  Nun bestimmen wir die Geschichte des Hauptpfades: <br><br>  * grüße <br>  - äußern_greet <br>  * Intent_request <br>  - restaurant_form <br>  - form {"name": "restaurant_form"} <br>  - form {"name": null} <br>  - action_book_restaurant <br>  * Danke <br>  - Äußerste Sorgen <br><br>  Das ist der perfekte Bot für eine perfekte Welt.  Wenn der Benutzer im ersten Satz sofort alle erforderlichen Daten angegeben hat, wird eine Tabelle reserviert.  Zum Beispiel schreibt er: "Ich möchte einen Tisch im spanischen Restaurant für fünf Personen reservieren."  In diesem Fall sind num_people 5 und cuisine - spanish, was für den Bot für weitere Aktionen auf der Reservierung ausreicht. <br><br>  Wenn Sie sich jedoch die Beispiele ansehen, können Sie feststellen, dass die Daten nicht immer in der erforderlichen Menge vorhanden sind und manchmal überhaupt nicht.  Es werden also nicht zum Kern gehörende Dialoge angezeigt. <br><br>  Angenommen, die Anfrage enthält keine Daten zur Küche, d. H. So etwas wie dieser Dialog: <br>  Hallo <br>  Hallo <br>  Ich möchte ein Restaurant für fünf Personen buchen <br>  ... <br><br>  Damit es korrekt ausgefüllt werden kann, müssen Sie den Verlauf des folgenden Formulars ermitteln: <br>  * grüße <br>  - äußern_greet <br>  * Intent_request <br>  - restaurant_form <br>  - form {"name": "restaurant_form"} <br>  - slot {"request_slot": "num_people"} <br>  - absolute_ask_coven <br>  * form: inform {"cuisine": "mexican"} <br>  - Slot {"Küche": "Mexikaner"} <br>  - form: restaurant_form <br>  ... <br><br>  Und das Beste daran ist, dass, wenn Sie Geschichten für mehrere Küchen erstellen, der Bot bei Treffen mit einem Unbekannten die nächste Aktion selbst vorhersagt, obwohl dies nicht sehr sicher ist.  Wenn Sie eine ähnliche Geschichte erstellen, aber der "Cuisine" -Slot ausgefüllt ist und nicht der "num_people" -Slot, ist es dem Bot absolut egal, in welcher Reihenfolge die Informationen zu den Tabellenreservierungsparametern bereitgestellt werden. <br><br>  Es gibt zwei Möglichkeiten, um Versuche zu stoppen, einen Bot vom richtigen Weg zu führen: mögliche Geschichten zu finden, um „über nichts“ zu sprechen, oder alle Versuche, ein solches Gespräch zu beginnen - antworten Sie, dass es sich lohnt, wieder ins Geschäft zurückzukehren. <br><br>  Da sich unser Unternehmen am Anfang einer erstaunlichen Reise in die Welt der Chatbots befindet, besteht die Möglichkeit, dass es neue Artikel darüber gibt, welchen Rechen wir gesammelt haben und was wir getan haben.  Bleib dran! <br><br><img src="https://habrastorage.org/webt/23/uz/eq/23uzeqjeu53ummt2ywqdlaiubmi.jpeg"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470754/">https://habr.com/ru/post/de470754/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470742/index.html">Navier-Stokes-Gleichung und Flüssigkeitssimulation auf CUDA</a></li>
<li><a href="../de470744/index.html">Mathematik enthüllt Geheimnisse des Feedbacks lebender Zellen</a></li>
<li><a href="../de470746/index.html">Facebook macht Konversation zur nächsten beliebten Oberfläche</a></li>
<li><a href="../de470750/index.html">Amazon fing an, Spitzenprodukte zu fangen</a></li>
<li><a href="../de470752/index.html">Parsen von Wechat-Zahlungen</a></li>
<li><a href="../de470756/index.html">Erstellen einer Backend-Anwendung für den Apollo-Online-Chat Node.js.</a></li>
<li><a href="../de470758/index.html">Überblick über die Virusaktivität im September 2019</a></li>
<li><a href="../de470772/index.html">TON: Empfehlungen und Best Practices</a></li>
<li><a href="../de470774/index.html">Neue Typanmerkungen in Python 3.8 (Protokoll, Final, TypedDict, Literal)</a></li>
<li><a href="../de470778/index.html">Seagate ST2000DM008 Laufwerk Bewertung: schnelle "zwei" ohne Überpreis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>