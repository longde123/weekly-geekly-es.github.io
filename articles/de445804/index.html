<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëêüèø üèåÔ∏è ‚ÅâÔ∏è Kapselung f√ºr echte Samurai oder die Nuancen, die mit dem internen Schl√ºsselwort in C # verbunden sind üë∑üèª üîû üëçüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prolog: intern ist neue √ñffentlichkeit 


 Jeder von uns tr√§umte von einem Projekt, bei dem alles richtig gemacht w√ºrde. Es scheint ganz nat√ºrlich. So...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kapselung f√ºr echte Samurai oder die Nuancen, die mit dem internen Schl√ºsselwort in C # verbunden sind</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445804/"><h2>  Prolog: intern ist neue √ñffentlichkeit </h2><br><p>  Jeder von uns tr√§umte von einem Projekt, bei dem alles richtig gemacht w√ºrde.  Es scheint ganz nat√ºrlich.  Sobald Sie von der M√∂glichkeit erfahren, guten Code zu schreiben, und sobald Sie Legenden √ºber den Code h√∂ren, der leicht gelesen und ge√§ndert werden kann, leuchten Sie sofort auf: "Nun, jetzt mache ich es richtig, ich bin schlau und lese McConnell." </p><br><img src="https://habrastorage.org/getpro/habr/post_images/d7e/34f/ba6/d7e34fba6115e561d2016fa85f7a846a.jpg" alt="Bild"><br><br><p>  Ein solches Projekt ist in meinem Leben passiert.  Noch einer.  Und ich mache es unter freiwilliger Aufsicht, wo jede Linie, der ich folge.  Dementsprechend wollte ich nicht nur, sondern ich musste alles richtig machen.  Eines der ‚Äûrichtigen‚Äú war ‚ÄûRespektieren Sie die Kapselung und n√§hern Sie sich dem Maximum, weil Sie immer Zeit zum √ñffnen haben und es dann zu sp√§t ist, um es wieder zu schlie√üen‚Äú.  Und deshalb begann ich, wo immer ich konnte, den internen Zugriffsmodifikator anstelle des √∂ffentlichen f√ºr Klassen zu verwenden.  Und nat√ºrlich treten einige Nuancen auf, wenn Sie beginnen, eine neue Sprachfunktion aktiv f√ºr Sie zu verwenden.  Ich m√∂chte der Reihe nach dar√ºber sprechen. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Offensive Grundhilfe</b> <div class="spoiler_text"><p>  Nur zum Erinnern und Beschriften. </p><br><ul><li>  Assembly ist die kleinste Bereitstellungseinheit in .NET und eine der grundlegenden Kompilierungseinheiten.  Dies ist entweder .dll oder .exe.  Sie sagen, dass es in mehrere Dateien unterteilt werden kann, die Module genannt werden. </li><li>  public - access modifier, was bedeutet, dass er f√ºr alle mit ihm gekennzeichneten zug√§nglich ist. </li><li>  Modifikator f√ºr internen Zugriff, dh, er ist nur innerhalb der Baugruppe verf√ºgbar. </li><li>  protected - Ein Zugriffsmodifikator, der angibt, dass die Markierung nur den Erben der Klasse zur Verf√ºgung steht, in der sich die Markierung befindet. </li><li>  privat - Ein Zugriffsmodifikator, der angibt, dass er nur f√ºr die Klasse verf√ºgbar ist, in der er sich befindet.  Und sonst niemand. </li></ul><br></div></div><br><h2>  Unit Tests und Friendly Builds </h2><br><p>  In C ++ gab es eine so seltsame Funktion wie freundliche Klassen.  Klassen konnten als Freunde zugewiesen werden, und dann wurde die Grenze der Kapselung zwischen ihnen gel√∂scht.  Ich vermute, dass dies nicht die seltsamste Funktion in C ++ ist.  Vielleicht sind sogar die zehn seltsamsten nicht enthalten.  Es ist jedoch zu einfach, sich durch die enge Verkn√ºpfung mehrerer Klassen in den Fu√ü zu schie√üen, und es ist sehr schwierig, einen geeigneten Fall f√ºr diese Funktion zu finden. </p><br><p>  Umso √ºberraschender war es zu erfahren, dass es in .NET freundliche Assemblys gibt, eine Art Umdenken.  Das hei√üt, Sie k√∂nnen einer Baugruppe zeigen lassen, was in einer anderen Baugruppe hinter dem internen Schloss verborgen ist.  Als ich davon erfuhr, war ich etwas √ºberrascht.  Nun, wie w√ºrde, warum?  Was ist der Punkt?  Wer wird die beiden Versammlungen, die an ihrer Trennung beteiligt sind, fest verbinden?  F√§lle, in denen sie in einer unverst√§ndlichen Situation √∂ffentlich werden, werden in diesem Artikel nicht ber√ºcksichtigt. </p><br><p>  Und dann begann ich im selben Projekt, einen der Zweige des Weges eines echten Samurai zu lernen: Unit-Tests.  Und im Feng Shui sollten Unit-Tests in einer separaten Baugruppe durchgef√ºhrt werden.  F√ºr dasselbe Feng Shui m√ºssen Sie alles, was in der Baugruppe verborgen werden kann, in der Baugruppe verstecken.  Ich stand vor einer sehr, sehr unangenehmen Wahl.  Entweder liegen die Tests nebeneinander und gehen zusammen mit dem f√ºr ihn n√ºtzlichen Code an den Kunden, oder alles wird durch das Schl√ºsselwort public abgedeckt, wie lange das Brot in der Feuchtigkeit gelegen hat. </p><br><p>  Und hier, irgendwo in den Beh√§ltern meiner Erinnerung, wurde etwas √ºber freundliche Versammlungen erhalten.  Es stellte sich heraus, dass Sie mit der Assembly "YourAssemblyName" folgenderma√üen schreiben k√∂nnen: </p><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">assembly: InternalsVisibleTo(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"YourAssemblyName.Tests"</span></span></span><span class="hljs-meta">)</span></span>]</code> </pre> <br><p>  In der Assembly "YourAssemblyName.Tests" wird angezeigt, was in "YourAssemblyName" mit dem internen Schl√ºsselwort gekennzeichnet ist.  Diese Zeile kann nur ein wenig in AssemblyInfo.cs eingegeben werden, das VS speziell zum Speichern solcher Attribute erstellt. </p><br><div class="spoiler">  <b class="spoiler_title">Kehren Sie missbr√§uchlich zur grundlegenden Hilfe zur√ºck</b> <div class="spoiler_text">  In .NET k√∂nnen Sie zus√§tzlich zu bereits integrierten Attributen oder Schl√ºsselw√∂rtern wie abstrakt, √∂ffentlich, intern und statisch eigene Attribute erstellen.  Und h√§ngen Sie sie an alles, was Sie wollen: Felder, Eigenschaften, Klassen, Methoden, Ereignisse und ganze Assemblys.  In C # schreiben Sie dazu einfach den Attributnamen in eckige Klammern, bevor Sie daran festhalten.  Die Ausnahme ist die Assembly selbst, da es im Code keinen direkten Hinweis darauf gibt, dass "Assembly beginnt hier".  Dort m√ºssen Sie vor dem Attributnamen eine Assembly hinzuf√ºgen: <br></div></div><br><p>  So bleiben die W√∂lfe voll, die Schafe sind in Sicherheit, alles, was m√∂glich ist, versteckt sich immer noch in der Baugruppe, Unit-Tests werden in einer separaten Baugruppe durchgef√ºhrt, wie es sein sollte, und eine Funktion, an die ich mich kaum erinnerte, bekommt einen Grund, sie zu verwenden.  Vielleicht der einzige existierende Grund. </p><br><p>  Ich habe fast einen wichtigen Punkt vergessen.  Die Attributaktion InternalsVisibleTo ist einseitig. </p><br><h2>  gesch√ºtzt &lt;intern? </h2><br><p>  Also die Situation: A und B sa√üen auf einer Pfeife. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String SomeProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> { <span class="hljs-comment"><span class="hljs-comment">//ERROR!!! The accessibility modifier of the 'B.OtherProperty.set' accessor must be more //restrictive than the property or indexer 'B.OtherProperty' internal String OtherProperty { get; protected set; } } }</span></span></code> </pre><br><p>  A wurde bei der Code√ºberpr√ºfung zerst√∂rt, da es nicht au√üerhalb der Assembly verwendet wird, sondern sich aus irgendeinem Grund einen Modifikator f√ºr den √∂ffentlichen Zugriff zul√§sst. B verursachte einen Kompilierungsfehler, der in den ersten Minuten zu einer Bet√§ubung f√ºhren kann. </p><br><p>  Grunds√§tzlich ist die Fehlermeldung logisch.  Der Immobilien-Accessor kann nicht mehr als die Immobilie selbst preisgeben.  Jeder wird mit Verst√§ndnis reagieren, wenn der Compiler einen Header daf√ºr angibt: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br><p>  Aber Behauptungen zu dieser Linie brechen sofort das Gehirn: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br><p>  Ich stelle fest, dass es zu dieser Zeile keine Beschwerden geben wird: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br><p>  Wenn Sie nicht viel nachdenken, wird die folgende Hierarchie in Ihrem Kopf aufgebaut: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span></code> </pre> <br><p>  Und diese Hierarchie scheint sogar zu funktionieren.  Bis auf einen Ort.  Wo intern&gt; gesch√ºtzt.  Um das Wesentliche der Anspr√ºche des Compilers zu verstehen, erinnern wir uns daran, welche Einschr√§nkungen durch interne und gesch√ºtzte auferlegt werden.  intern - nur innerhalb der Baugruppe.  gesch√ºtzt - nur Erben.  Beachten Sie alle Erben.  Und wenn Klasse B als √∂ffentlich markiert ist, k√∂nnen Sie in einer anderen Assembly ihre Nachkommen definieren.  Und dann bekommt der Set-Accessor wirklich Zugriff darauf, wo die gesamte Eigenschaft es nicht hat.  Da der C # -Compiler paranoid ist, kann er eine solche M√∂glichkeit nicht einmal zulassen. </p><br><p>  Vielen Dank an ihn daf√ºr, aber wir m√ºssen den Erben Zugang zum Accessor gew√§hren.  Und speziell f√ºr solche F√§lle gibt es einen gesch√ºtzten internen Zugriffsmodifikator. </p><br><div class="spoiler">  <b class="spoiler_title">Diese Hilfe ist nicht so anst√∂√üig</b> <div class="spoiler_text"><ul><li>  protected internal - Ein Zugriffsmodifikator, der angibt, dass der markierte innerhalb der Assembly <strong>oder f√ºr die</strong> Erben der Klasse verf√ºgbar ist, in der sich der markierte befindet. </li></ul><br></div></div><br><p>  Wenn wir also m√∂chten, dass der Compiler uns erlaubt, diese Eigenschaft zu verwenden und sie in den Erben festzulegen, m√ºssen wir Folgendes tun: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } }</code> </pre><br><p>  Und die richtige Hierarchie der Zugriffsmodifikatoren sieht ungef√§hr so ‚Äã‚Äãaus: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span></code> </pre><br><h2>  Schnittstellen </h2><br><p>  Also die Situation: A, ich, B sa√üen auf der Pfeife. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//'A' does not implement interface member 'I.SomeMethod()'. //'A.SomeMethod()' cannot implement an interface member because it is not public. } } internal class B : I { internal void SomeMethod() { //'B' does not implement interface member 'I.SomeMethod()'. //'B.SomeMethod()' cannot implement an interface member because it is not public. } } }</span></span></code> </pre><br><p>  Wir sa√üen genau und mischten uns nicht au√üerhalb der Versammlung ein.  Sie wurden jedoch vom Compiler abgelehnt.  Hier wird das Wesentliche der Anspr√ºche aus der Fehlermeldung deutlich.  Die Implementierung der Schnittstelle muss offen sein.  Auch wenn die Schnittstelle selbst geschlossen ist.  Es w√§re logisch, den Zugriff auf die Implementierung der Schnittstelle an ihre Verf√ºgbarkeit zu binden, aber was nicht ist, ist nicht.  Die Implementierung der Schnittstelle muss √∂ffentlich sein. </p><br><p>  Und wir haben zwei Auswege.  Erstens: H√§ngen Sie durch Knarren und Z√§hneknirschen einen Modifikator f√ºr den √∂ffentlichen Zugriff an die Implementierung der Schnittstelle.  Zweitens: explizite Implementierung der Schnittstelle.  Es sieht so aus: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> I.SomeMethod() { } } }</code> </pre><br><p>  Bitte beachten Sie, dass im zweiten Fall kein Zugriffsmodifikator vorhanden ist.  Wem steht in diesem Fall die Implementierung der Methode zur Verf√ºgung?  Sagen wir einfach niemand.  Es ist einfacher, mit einem Beispiel zu zeigen: </p><br><pre> <code class="cs hljs">B b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); <span class="hljs-comment"><span class="hljs-comment">//'B' does not contain a definition for 'SomeMethod' and no accessible extension method //'SomeMethod' accepting a first argument of type 'B' could be found //(are you missing a using directive or an assembly reference?) b.SomeMethod(); //OK (b as I).SomeMethod();</span></span></code> </pre><br><p>  Die explizite Implementierung von Schnittstelle I bedeutet, dass es keine Methoden gibt, die diese Schnittstelle implementieren, bis wir die Variable explizit in Typ I umwandeln.  Das Schreiben (b als I) .SomeMethod () kann jedes Mal eine √úberlastung sein.  Wie ((I) b) .SomeMethod ().  Und ich habe zwei Wege gefunden, um das zu umgehen.  Ich dachte selbst an einen und googelte ehrlich den zweiten. </p><br><p>  Der erste Weg ist die Fabrik: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Factory</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> I </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); } }</code> </pre><br><p>  Nun, oder irgendein anderes Muster, mit dem Sie diese Nuance verbergen k√∂nnen. </p><br><p>  Methode zwei - Erweiterungsmethoden: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> I i</span></span></span><span class="hljs-function">)</span></span> { i.SomeMethod(); } }</code> </pre><br><p>  √úberraschenderweise funktioniert es.  Diese Zeilen geben keinen Fehler mehr aus: </p><br><pre> <code class="cs hljs">B b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); b.SomeMethod();</code> </pre><br><p>  Schlie√ülich kommt der Aufruf, wie IntelliSense in Visual Studio mitteilt, nicht zu Methoden zur expliziten Implementierung der Schnittstelle, sondern zu Erweiterungsmethoden.  Und niemand verbietet es, sich an sie zu wenden.  Und Schnittstellenerweiterungsmethoden k√∂nnen f√ºr alle Implementierungen aufgerufen werden. </p><br><p>  Es bleibt jedoch eine Einschr√§nkung.  Innerhalb der Klasse selbst m√ºssen Sie √ºber das Schl√ºsselwort this auf diese Methode zugreifen, da der Compiler sonst nicht versteht, dass wir auf die Erweiterungsmethode verweisen m√∂chten: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OtherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Error!!! SomeMethod(); //OK this.SomeMethod(); } void I.SomeMethod() { } }</span></span></code> </pre><br><p>  Und so und so haben wir oder √∂ffentlich, wo es nicht sein sollte, aber dort <em>scheint</em> es keinen Schaden zuzuf√ºgen, oder ein wenig zus√§tzlichen Code f√ºr jede interne Schnittstelle.  W√§hlen Sie das kleinere √úbel nach Ihren W√ºnschen. </p><br><h2>  Reflexion </h2><br><p>  Ich traf dies schmerzhaft, als ich versuchte, durch Reflexion einen Konstruktor zu finden, der nat√ºrlich in der internen Klasse als intern markiert war.  Und es stellte sich heraus, dass Reflexion nichts preisgibt, was nicht √∂ffentlich w√§re.  Und das ist im Prinzip logisch. </p><br><p>  Erstens, wenn ich mich richtig erinnere, was intelligente Leute in intelligenten B√ºchern geschrieben haben, geht es darum, Informationen in den Assembly-Metadaten zu finden.  Was theoretisch nicht zu viel geben sollte (zumindest dachte ich das).  Zweitens besteht die Hauptanwendung von Reflection darin, Ihr Programm erweiterbar zu machen.  Sie bieten Au√üenstehenden eine Art Schnittstelle (vielleicht sogar in Form von Schnittstellen, fiy-ha!).  Und sie implementieren es und stellen Plugins, Mods und Erweiterungen in Form einer Assembly bereit, die unterwegs geladen wird und von der Reflexion sie erh√§lt.  Und an sich wird Ihre API √∂ffentlich sein.  Das hei√üt, das Betrachten von Innen durch Reflexion ist aus praktischer Sicht technisch und sinnlos nicht. </p><br><p>  <strong>Update</strong>  Hier in den Kommentaren stellte sich heraus, dass Reflexion es erlaubt, wenn Sie explizit danach fragen, alles zu reflektieren.  Sei es sogar intern, sogar privat.  Wenn Sie kein Code-Analyse-Tool schreiben, versuchen Sie dies bitte nicht.  Der folgende Text ist weiterhin relevant f√ºr F√§lle, in denen wir nach offenen Mitgliedertypen suchen.  Und im Allgemeinen keine Kommentare weitergeben, es gibt viele interessante Dinge. </p><br><p>  Dies k√∂nnte mit Reflexion beendet werden, aber kehren wir zum vorherigen Beispiel zur√ºck, in dem A, I, B auf einem Rohr sa√üen: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> I i</span></span></span><span class="hljs-function">)</span></span> { i.SomeMethod(); } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OtherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OtherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> I.SomeMethod() { } } }</code> </pre><br><p>  Der Autor der Klasse A entschied, dass nichts Schlimmes passieren w√ºrde, wenn die Methode der internen Klasse als √∂ffentlich markiert w√ºrde, so dass der Compiler keine Schmerzen hatte und kein weiterer Code eingef√ºgt werden musste.  Die Schnittstelle ist als intern markiert, die Klasse, die sie implementiert, ist als intern markiert. Von au√üen scheint es keine M√∂glichkeit zu geben, zu der als √∂ffentlich gekennzeichneten Methode zu gelangen. </p><br><p>  Und dann √∂ffnet sich die T√ºr und das Spiegelbild schleicht sich leise ein: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pipe; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Reflection; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">EncapsulationTest</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(I), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IExtensions), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(A), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(A), <span class="hljs-string"><span class="hljs-string">"OtherMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(B), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(B), <span class="hljs-string"><span class="hljs-string">"OtherMethod"</span></span>); Console.ReadLine(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindThroughReflection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type type, String methodName</span></span></span><span class="hljs-function">)</span></span> { MethodInfo methodInfo = type.GetMethod(methodName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (methodInfo != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"In type </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{type.Name}</span></span></span><span class="hljs-string"> we found </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{methodInfo}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"NULL! Can't find method </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{methodName}</span></span></span><span class="hljs-string"> in type </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{type.Name}</span></span></span><span class="hljs-string">"</span></span>); } } }</code> </pre><br><p>  Studieren Sie diesen Code und fahren Sie ihn ins Studio, wenn Sie dies w√ºnschen.  Hier versuchen wir, mithilfe der Reflexion alle Methoden aus allen Arten unserer Pipe (Namespace Pipe) zu finden.  Und hier sind die Ergebnisse, die es uns gibt: </p><br><blockquote>  In Typ I fanden wir Void SomeMethod () <br>  NULL!  Die Methode SomeMethod kann vom Typ IExtensions nicht gefunden werden <br>  In Typ A fanden wir Void SomeMethod () <br>  NULL!  Die Methode OtherMethod in Typ A kann nicht gefunden werden <br>  NULL!  Die Methode SomeMethod in Typ B kann nicht gefunden werden <br>  NULL!  Die Methode OtherMethod in Typ B kann nicht gefunden werden <br></blockquote><br><p>  Ich muss sofort sagen, dass mit einem Objekt vom Typ MethodInfo die gefundene Methode aufgerufen werden kann.  Das hei√üt, wenn die Reflexion etwas gefunden hat, kann die Einkapselung rein theoretisch verletzt werden.  Und wir haben etwas gefunden.  Erstens, die gleiche √∂ffentliche Leere SomeMethod () aus Klasse A. Es wurde erwartet, was noch zu sagen ist.  Dieser Genuss kann immer noch Konsequenzen haben.  Zweitens void SomeMethod () von Schnittstelle I. Dies ist bereits interessanter.  Unabh√§ngig davon, wie wir uns einsperren, sind die abstrakten Methoden in der Schnittstelle (oder was die CLR tats√§chlich dort platziert) tats√§chlich offen.  Daher die Schlussfolgerung in einem separaten Absatz: </p><br><p>  <em>Schauen Sie sich genau an, wen und welche Art von System.Type-Typ Sie verschenken.</em> </p><br><p>  Bei diesen beiden Methoden gibt es jedoch noch eine weitere Nuance, die ich ber√ºcksichtigen m√∂chte.  Interne Schnittstellenmethoden und √∂ffentliche Methoden interner Klassen k√∂nnen mithilfe von Reflection gefunden werden.  Als vern√ºnftige Person werde ich zu dem Schluss kommen, dass sie in die Metadaten fallen.  Als erfahrene Person werde ich diese Schlussfolgerung √ºberpr√ºfen.  Und in diesem ILDasm wird uns helfen. </p><br><div class="spoiler">  <b class="spoiler_title">Werfen Sie einen Blick auf das Kaninchenloch in den Metadaten unserer Pipe</b> <div class="spoiler_text"><p>  Montage wurde in Release montiert </p><br> <code>TypeDef #2 (02000003) <br> ------------------------------------------------------- <br> TypDefName: Pipe.I (02000003) <br> Flags : [NotPublic] [AutoLayout] [Interface] [Abstract] [AnsiClass] (000000a0) <br> Extends : 01000000 [TypeRef] <br> Method #1 (06000004) <br> ------------------------------------------------------- <br> MethodName: SomeMethod (06000004) <br> Flags : [Public] [Virtual] [HideBySig] [NewSlot] [Abstract] (000005c6) <br> RVA : 0x00000000 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> TypeDef #3 (02000004) <br> ------------------------------------------------------- <br> TypDefName: Pipe.IExtensions (02000004) <br> Flags : [NotPublic] [AutoLayout] [Class] [Abstract] [Sealed] [AnsiClass] [BeforeFieldInit] (00100180) <br> Extends : 01000011 [TypeRef] System.Object <br> Method #1 (06000005) <br> ------------------------------------------------------- <br> MethodName: SomeMethod (06000005) <br> Flags : [Assem] [Static] [HideBySig] [ReuseSlot] (00000093) <br> RVA : 0x00002134 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> ReturnType: Void <br> 1 Arguments <br> Argument #1: Class Pipe.I <br> 1 Parameters <br> (1) ParamToken : (08000004) Name : i flags: [none] (00000000) <br> CustomAttribute #1 (0c000011) <br> ------------------------------------------------------- <br> CustomAttribute Type: 0a000001 <br> CustomAttributeName: System.Runtime.CompilerServices.ExtensionAttribute :: instance void .ctor() <br> Length: 4 <br> Value : 01 00 00 00 &gt; &lt; <br> ctor args: () <br> <br> CustomAttribute #1 (0c000010) <br> ------------------------------------------------------- <br> CustomAttribute Type: 0a000001 <br> CustomAttributeName: System.Runtime.CompilerServices.ExtensionAttribute :: instance void .ctor() <br> Length: 4 <br> Value : 01 00 00 00 &gt; &lt; <br> ctor args: () <br> <br> TypeDef #4 (02000005) <br> ------------------------------------------------------- <br> TypDefName: Pipe.A (02000005) <br> Flags : [NotPublic] [AutoLayout] [Class] [AnsiClass] [BeforeFieldInit] (00100000) <br> Extends : 01000011 [TypeRef] System.Object <br> Method #1 (06000006) <br> ------------------------------------------------------- <br> MethodName: SomeMethod (06000006) <br> Flags : [Public] [Final] [Virtual] [HideBySig] [NewSlot] (000001e6) <br> RVA : 0x0000213c <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #2 (06000007) <br> ------------------------------------------------------- <br> MethodName: OtherMethod (06000007) <br> Flags : [Assem] [HideBySig] [ReuseSlot] (00000083) <br> RVA : 0x0000213e <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #3 (06000008) <br> ------------------------------------------------------- <br> MethodName: .ctor (06000008) <br> Flags : [Public] [HideBySig] [ReuseSlot] [SpecialName] [RTSpecialName] [.ctor] (00001886) <br> RVA : 0x00002140 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> InterfaceImpl #1 (09000001) <br> ------------------------------------------------------- <br> Class : Pipe.A <br> Token : 02000003 [TypeDef] Pipe.I <br> <br> TypeDef #5 (02000006) <br> ------------------------------------------------------- <br> TypDefName: Pipe.B (02000006) <br> Flags : [NotPublic] [AutoLayout] [Class] [AnsiClass] [BeforeFieldInit] (00100000) <br> Extends : 01000011 [TypeRef] System.Object <br> Method #1 (06000009) <br> ------------------------------------------------------- <br> MethodName: OtherMethod (06000009) <br> Flags : [Assem] [HideBySig] [ReuseSlot] (00000083) <br> RVA : 0x00002148 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #2 (0600000a) <br> ------------------------------------------------------- <br> MethodName: Pipe.I.SomeMethod (0600000A) <br> Flags : [Private] [Final] [Virtual] [HideBySig] [NewSlot] (000001e1) <br> RVA : 0x0000214a <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #3 (0600000b) <br> ------------------------------------------------------- <br> MethodName: .ctor (0600000B) <br> Flags : [Public] [HideBySig] [ReuseSlot] [SpecialName] [RTSpecialName] [.ctor] (00001886) <br> RVA : 0x0000214c <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> MethodImpl #1 (00000001) <br> ------------------------------------------------------- <br> Method Body Token : 0x0600000a <br> Method Declaration Token : 0x06000004 <br> <br> InterfaceImpl #1 (09000002) <br> ------------------------------------------------------- <br> Class : Pipe.B <br> Token : 02000003 [TypeDef] Pipe.I <br></code> <br></div></div><br><p>  Ein kurzer Blick zeigt, dass <strong>alles</strong> in die Metadaten gelangt, egal wie sie markiert sind.  Reflexion verbirgt uns immer noch sorgf√§ltig, dass Au√üenstehende nicht sehen sollen.  Es kann also durchaus sein, dass die zus√§tzlichen f√ºnf Codezeilen f√ºr jede Methode der internen Schnittstelle kein so gro√ües √úbel sind.  Die Hauptschlussfolgerung bleibt jedoch dieselbe: </p><br><p>  <em>Schauen Sie sich genau an, wen und welche Art von System.Type-Typ Sie verschenken.</em> </p><br><p>  Dies ist nat√ºrlich die n√§chste Stufe nach dem Zugriff auf das interne Schl√ºsselwort an allen Stellen, an denen keine √∂ffentliche Notwendigkeit besteht. </p><br><h2>  PS </h2><br><p>  Sie wissen, dass das Coolste an der Verwendung des internen Schl√ºsselworts √ºberall in der Assembly ist?  Wenn es w√§chst, m√ºssen Sie es in zwei oder mehr teilen.  Dabei m√ºssen Sie eine Pause einlegen, um einige Typen zu √∂ffnen.  Und Sie m√ºssen genau dar√ºber nachdenken, welche Typen es wert sind, offen zu werden.  Zumindest kurz. </p><br><p>  Dies bedeutet Folgendes: <em>Diese Praxis des Schreibens von Code l√§sst Sie erneut dar√ºber nachdenken, wie die architektonische Grenze zwischen neugeborenen Baugruppen aussehen wird.</em>  Was k√∂nnte sch√∂ner sein? </p><br><h2>  PPS </h2><br><p>  Ab Version C # 7.2 wurde ein neuer, privat gesch√ºtzter Zugriffsmodifikator angezeigt.  Und ich habe immer noch keine Ahnung, was es ist und womit es gegessen wird.  Da in der Praxis nicht angetroffen.  Aber ich werde es gerne in den Kommentaren wissen.  Aber nicht Kopieren und Einf√ºgen aus der Dokumentation, sondern echte F√§lle, in denen dieser Zugriffsmodifikator m√∂glicherweise ben√∂tigt wird. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445804/">https://habr.com/ru/post/de445804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445794/index.html">IT-Giganten stellen eine hybride Hybrid-Cloud-Bereitstellungsl√∂sung vor</a></li>
<li><a href="../de445796/index.html">Fintech Digest: Dorsey zahlt mit Bitcoins, Australiens Blockchain-Strategie, Levis B√∂rsengang, B√ºrgermeister von Chicago und der Unvermeidlichkeit von Bitcoin</a></li>
<li><a href="../de445798/index.html">Nashorn in der Katze - F√ºhren Sie die Firmware im Kopycat-Emulator aus</a></li>
<li><a href="../de445800/index.html">Monaden in 15 Minuten</a></li>
<li><a href="../de445802/index.html">5 Dinge, √ºber die Internet-Trends jeder wissen sollte</a></li>
<li><a href="../de445806/index.html">Wie k√ºnstliche Intelligenz die Wissenschaft ver√§ndert</a></li>
<li><a href="../de445808/index.html">Wir hassen und jagen: das gef√§hrliche Leben eines Virus-Crackers, der sich m√§chtige Feinde macht</a></li>
<li><a href="../de445814/index.html">Wie ein Lieferroboter die kulinarischen Gewohnheiten amerikanischer Studenten ver√§ndert hat</a></li>
<li><a href="../de445816/index.html">Wie wir Server-Rendering gesehen haben und was daraus wurde</a></li>
<li><a href="../de445820/index.html">MVCC-3. Zeilenversionen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>