<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐🏿 🏌️ ⁉️ Kapselung für echte Samurai oder die Nuancen, die mit dem internen Schlüsselwort in C # verbunden sind 👷🏻 🔞 👍🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prolog: intern ist neue Öffentlichkeit 


 Jeder von uns träumte von einem Projekt, bei dem alles richtig gemacht würde. Es scheint ganz natürlich. So...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kapselung für echte Samurai oder die Nuancen, die mit dem internen Schlüsselwort in C # verbunden sind</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445804/"><h2>  Prolog: intern ist neue Öffentlichkeit </h2><br><p>  Jeder von uns träumte von einem Projekt, bei dem alles richtig gemacht würde.  Es scheint ganz natürlich.  Sobald Sie von der Möglichkeit erfahren, guten Code zu schreiben, und sobald Sie Legenden über den Code hören, der leicht gelesen und geändert werden kann, leuchten Sie sofort auf: "Nun, jetzt mache ich es richtig, ich bin schlau und lese McConnell." </p><br><img src="https://habrastorage.org/getpro/habr/post_images/d7e/34f/ba6/d7e34fba6115e561d2016fa85f7a846a.jpg" alt="Bild"><br><br><p>  Ein solches Projekt ist in meinem Leben passiert.  Noch einer.  Und ich mache es unter freiwilliger Aufsicht, wo jede Linie, der ich folge.  Dementsprechend wollte ich nicht nur, sondern ich musste alles richtig machen.  Eines der „richtigen“ war „Respektieren Sie die Kapselung und nähern Sie sich dem Maximum, weil Sie immer Zeit zum Öffnen haben und es dann zu spät ist, um es wieder zu schließen“.  Und deshalb begann ich, wo immer ich konnte, den internen Zugriffsmodifikator anstelle des öffentlichen für Klassen zu verwenden.  Und natürlich treten einige Nuancen auf, wenn Sie beginnen, eine neue Sprachfunktion aktiv für Sie zu verwenden.  Ich möchte der Reihe nach darüber sprechen. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Offensive Grundhilfe</b> <div class="spoiler_text"><p>  Nur zum Erinnern und Beschriften. </p><br><ul><li>  Assembly ist die kleinste Bereitstellungseinheit in .NET und eine der grundlegenden Kompilierungseinheiten.  Dies ist entweder .dll oder .exe.  Sie sagen, dass es in mehrere Dateien unterteilt werden kann, die Module genannt werden. </li><li>  public - access modifier, was bedeutet, dass er für alle mit ihm gekennzeichneten zugänglich ist. </li><li>  Modifikator für internen Zugriff, dh, er ist nur innerhalb der Baugruppe verfügbar. </li><li>  protected - Ein Zugriffsmodifikator, der angibt, dass die Markierung nur den Erben der Klasse zur Verfügung steht, in der sich die Markierung befindet. </li><li>  privat - Ein Zugriffsmodifikator, der angibt, dass er nur für die Klasse verfügbar ist, in der er sich befindet.  Und sonst niemand. </li></ul><br></div></div><br><h2>  Unit Tests und Friendly Builds </h2><br><p>  In C ++ gab es eine so seltsame Funktion wie freundliche Klassen.  Klassen konnten als Freunde zugewiesen werden, und dann wurde die Grenze der Kapselung zwischen ihnen gelöscht.  Ich vermute, dass dies nicht die seltsamste Funktion in C ++ ist.  Vielleicht sind sogar die zehn seltsamsten nicht enthalten.  Es ist jedoch zu einfach, sich durch die enge Verknüpfung mehrerer Klassen in den Fuß zu schießen, und es ist sehr schwierig, einen geeigneten Fall für diese Funktion zu finden. </p><br><p>  Umso überraschender war es zu erfahren, dass es in .NET freundliche Assemblys gibt, eine Art Umdenken.  Das heißt, Sie können einer Baugruppe zeigen lassen, was in einer anderen Baugruppe hinter dem internen Schloss verborgen ist.  Als ich davon erfuhr, war ich etwas überrascht.  Nun, wie würde, warum?  Was ist der Punkt?  Wer wird die beiden Versammlungen, die an ihrer Trennung beteiligt sind, fest verbinden?  Fälle, in denen sie in einer unverständlichen Situation öffentlich werden, werden in diesem Artikel nicht berücksichtigt. </p><br><p>  Und dann begann ich im selben Projekt, einen der Zweige des Weges eines echten Samurai zu lernen: Unit-Tests.  Und im Feng Shui sollten Unit-Tests in einer separaten Baugruppe durchgeführt werden.  Für dasselbe Feng Shui müssen Sie alles, was in der Baugruppe verborgen werden kann, in der Baugruppe verstecken.  Ich stand vor einer sehr, sehr unangenehmen Wahl.  Entweder liegen die Tests nebeneinander und gehen zusammen mit dem für ihn nützlichen Code an den Kunden, oder alles wird durch das Schlüsselwort public abgedeckt, wie lange das Brot in der Feuchtigkeit gelegen hat. </p><br><p>  Und hier, irgendwo in den Behältern meiner Erinnerung, wurde etwas über freundliche Versammlungen erhalten.  Es stellte sich heraus, dass Sie mit der Assembly "YourAssemblyName" folgendermaßen schreiben können: </p><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">assembly: InternalsVisibleTo(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"YourAssemblyName.Tests"</span></span></span><span class="hljs-meta">)</span></span>]</code> </pre> <br><p>  In der Assembly "YourAssemblyName.Tests" wird angezeigt, was in "YourAssemblyName" mit dem internen Schlüsselwort gekennzeichnet ist.  Diese Zeile kann nur ein wenig in AssemblyInfo.cs eingegeben werden, das VS speziell zum Speichern solcher Attribute erstellt. </p><br><div class="spoiler">  <b class="spoiler_title">Kehren Sie missbräuchlich zur grundlegenden Hilfe zurück</b> <div class="spoiler_text">  In .NET können Sie zusätzlich zu bereits integrierten Attributen oder Schlüsselwörtern wie abstrakt, öffentlich, intern und statisch eigene Attribute erstellen.  Und hängen Sie sie an alles, was Sie wollen: Felder, Eigenschaften, Klassen, Methoden, Ereignisse und ganze Assemblys.  In C # schreiben Sie dazu einfach den Attributnamen in eckige Klammern, bevor Sie daran festhalten.  Die Ausnahme ist die Assembly selbst, da es im Code keinen direkten Hinweis darauf gibt, dass "Assembly beginnt hier".  Dort müssen Sie vor dem Attributnamen eine Assembly hinzufügen: <br></div></div><br><p>  So bleiben die Wölfe voll, die Schafe sind in Sicherheit, alles, was möglich ist, versteckt sich immer noch in der Baugruppe, Unit-Tests werden in einer separaten Baugruppe durchgeführt, wie es sein sollte, und eine Funktion, an die ich mich kaum erinnerte, bekommt einen Grund, sie zu verwenden.  Vielleicht der einzige existierende Grund. </p><br><p>  Ich habe fast einen wichtigen Punkt vergessen.  Die Attributaktion InternalsVisibleTo ist einseitig. </p><br><h2>  geschützt &lt;intern? </h2><br><p>  Also die Situation: A und B saßen auf einer Pfeife. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String SomeProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> { <span class="hljs-comment"><span class="hljs-comment">//ERROR!!! The accessibility modifier of the 'B.OtherProperty.set' accessor must be more //restrictive than the property or indexer 'B.OtherProperty' internal String OtherProperty { get; protected set; } } }</span></span></code> </pre><br><p>  A wurde bei der Codeüberprüfung zerstört, da es nicht außerhalb der Assembly verwendet wird, sondern sich aus irgendeinem Grund einen Modifikator für den öffentlichen Zugriff zulässt. B verursachte einen Kompilierungsfehler, der in den ersten Minuten zu einer Betäubung führen kann. </p><br><p>  Grundsätzlich ist die Fehlermeldung logisch.  Der Immobilien-Accessor kann nicht mehr als die Immobilie selbst preisgeben.  Jeder wird mit Verständnis reagieren, wenn der Compiler einen Header dafür angibt: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br><p>  Aber Behauptungen zu dieser Linie brechen sofort das Gehirn: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br><p>  Ich stelle fest, dass es zu dieser Zeile keine Beschwerden geben wird: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br><p>  Wenn Sie nicht viel nachdenken, wird die folgende Hierarchie in Ihrem Kopf aufgebaut: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span></code> </pre> <br><p>  Und diese Hierarchie scheint sogar zu funktionieren.  Bis auf einen Ort.  Wo intern&gt; geschützt.  Um das Wesentliche der Ansprüche des Compilers zu verstehen, erinnern wir uns daran, welche Einschränkungen durch interne und geschützte auferlegt werden.  intern - nur innerhalb der Baugruppe.  geschützt - nur Erben.  Beachten Sie alle Erben.  Und wenn Klasse B als öffentlich markiert ist, können Sie in einer anderen Assembly ihre Nachkommen definieren.  Und dann bekommt der Set-Accessor wirklich Zugriff darauf, wo die gesamte Eigenschaft es nicht hat.  Da der C # -Compiler paranoid ist, kann er eine solche Möglichkeit nicht einmal zulassen. </p><br><p>  Vielen Dank an ihn dafür, aber wir müssen den Erben Zugang zum Accessor gewähren.  Und speziell für solche Fälle gibt es einen geschützten internen Zugriffsmodifikator. </p><br><div class="spoiler">  <b class="spoiler_title">Diese Hilfe ist nicht so anstößig</b> <div class="spoiler_text"><ul><li>  protected internal - Ein Zugriffsmodifikator, der angibt, dass der markierte innerhalb der Assembly <strong>oder für die</strong> Erben der Klasse verfügbar ist, in der sich der markierte befindet. </li></ul><br></div></div><br><p>  Wenn wir also möchten, dass der Compiler uns erlaubt, diese Eigenschaft zu verwenden und sie in den Erben festzulegen, müssen wir Folgendes tun: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } }</code> </pre><br><p>  Und die richtige Hierarchie der Zugriffsmodifikatoren sieht ungefähr so ​​aus: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span></code> </pre><br><h2>  Schnittstellen </h2><br><p>  Also die Situation: A, ich, B saßen auf der Pfeife. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//'A' does not implement interface member 'I.SomeMethod()'. //'A.SomeMethod()' cannot implement an interface member because it is not public. } } internal class B : I { internal void SomeMethod() { //'B' does not implement interface member 'I.SomeMethod()'. //'B.SomeMethod()' cannot implement an interface member because it is not public. } } }</span></span></code> </pre><br><p>  Wir saßen genau und mischten uns nicht außerhalb der Versammlung ein.  Sie wurden jedoch vom Compiler abgelehnt.  Hier wird das Wesentliche der Ansprüche aus der Fehlermeldung deutlich.  Die Implementierung der Schnittstelle muss offen sein.  Auch wenn die Schnittstelle selbst geschlossen ist.  Es wäre logisch, den Zugriff auf die Implementierung der Schnittstelle an ihre Verfügbarkeit zu binden, aber was nicht ist, ist nicht.  Die Implementierung der Schnittstelle muss öffentlich sein. </p><br><p>  Und wir haben zwei Auswege.  Erstens: Hängen Sie durch Knarren und Zähneknirschen einen Modifikator für den öffentlichen Zugriff an die Implementierung der Schnittstelle.  Zweitens: explizite Implementierung der Schnittstelle.  Es sieht so aus: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> I.SomeMethod() { } } }</code> </pre><br><p>  Bitte beachten Sie, dass im zweiten Fall kein Zugriffsmodifikator vorhanden ist.  Wem steht in diesem Fall die Implementierung der Methode zur Verfügung?  Sagen wir einfach niemand.  Es ist einfacher, mit einem Beispiel zu zeigen: </p><br><pre> <code class="cs hljs">B b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); <span class="hljs-comment"><span class="hljs-comment">//'B' does not contain a definition for 'SomeMethod' and no accessible extension method //'SomeMethod' accepting a first argument of type 'B' could be found //(are you missing a using directive or an assembly reference?) b.SomeMethod(); //OK (b as I).SomeMethod();</span></span></code> </pre><br><p>  Die explizite Implementierung von Schnittstelle I bedeutet, dass es keine Methoden gibt, die diese Schnittstelle implementieren, bis wir die Variable explizit in Typ I umwandeln.  Das Schreiben (b als I) .SomeMethod () kann jedes Mal eine Überlastung sein.  Wie ((I) b) .SomeMethod ().  Und ich habe zwei Wege gefunden, um das zu umgehen.  Ich dachte selbst an einen und googelte ehrlich den zweiten. </p><br><p>  Der erste Weg ist die Fabrik: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Factory</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> I </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); } }</code> </pre><br><p>  Nun, oder irgendein anderes Muster, mit dem Sie diese Nuance verbergen können. </p><br><p>  Methode zwei - Erweiterungsmethoden: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> I i</span></span></span><span class="hljs-function">)</span></span> { i.SomeMethod(); } }</code> </pre><br><p>  Überraschenderweise funktioniert es.  Diese Zeilen geben keinen Fehler mehr aus: </p><br><pre> <code class="cs hljs">B b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); b.SomeMethod();</code> </pre><br><p>  Schließlich kommt der Aufruf, wie IntelliSense in Visual Studio mitteilt, nicht zu Methoden zur expliziten Implementierung der Schnittstelle, sondern zu Erweiterungsmethoden.  Und niemand verbietet es, sich an sie zu wenden.  Und Schnittstellenerweiterungsmethoden können für alle Implementierungen aufgerufen werden. </p><br><p>  Es bleibt jedoch eine Einschränkung.  Innerhalb der Klasse selbst müssen Sie über das Schlüsselwort this auf diese Methode zugreifen, da der Compiler sonst nicht versteht, dass wir auf die Erweiterungsmethode verweisen möchten: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OtherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Error!!! SomeMethod(); //OK this.SomeMethod(); } void I.SomeMethod() { } }</span></span></code> </pre><br><p>  Und so und so haben wir oder öffentlich, wo es nicht sein sollte, aber dort <em>scheint</em> es keinen Schaden zuzufügen, oder ein wenig zusätzlichen Code für jede interne Schnittstelle.  Wählen Sie das kleinere Übel nach Ihren Wünschen. </p><br><h2>  Reflexion </h2><br><p>  Ich traf dies schmerzhaft, als ich versuchte, durch Reflexion einen Konstruktor zu finden, der natürlich in der internen Klasse als intern markiert war.  Und es stellte sich heraus, dass Reflexion nichts preisgibt, was nicht öffentlich wäre.  Und das ist im Prinzip logisch. </p><br><p>  Erstens, wenn ich mich richtig erinnere, was intelligente Leute in intelligenten Büchern geschrieben haben, geht es darum, Informationen in den Assembly-Metadaten zu finden.  Was theoretisch nicht zu viel geben sollte (zumindest dachte ich das).  Zweitens besteht die Hauptanwendung von Reflection darin, Ihr Programm erweiterbar zu machen.  Sie bieten Außenstehenden eine Art Schnittstelle (vielleicht sogar in Form von Schnittstellen, fiy-ha!).  Und sie implementieren es und stellen Plugins, Mods und Erweiterungen in Form einer Assembly bereit, die unterwegs geladen wird und von der Reflexion sie erhält.  Und an sich wird Ihre API öffentlich sein.  Das heißt, das Betrachten von Innen durch Reflexion ist aus praktischer Sicht technisch und sinnlos nicht. </p><br><p>  <strong>Update</strong>  Hier in den Kommentaren stellte sich heraus, dass Reflexion es erlaubt, wenn Sie explizit danach fragen, alles zu reflektieren.  Sei es sogar intern, sogar privat.  Wenn Sie kein Code-Analyse-Tool schreiben, versuchen Sie dies bitte nicht.  Der folgende Text ist weiterhin relevant für Fälle, in denen wir nach offenen Mitgliedertypen suchen.  Und im Allgemeinen keine Kommentare weitergeben, es gibt viele interessante Dinge. </p><br><p>  Dies könnte mit Reflexion beendet werden, aber kehren wir zum vorherigen Beispiel zurück, in dem A, I, B auf einem Rohr saßen: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> I i</span></span></span><span class="hljs-function">)</span></span> { i.SomeMethod(); } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OtherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OtherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> I.SomeMethod() { } } }</code> </pre><br><p>  Der Autor der Klasse A entschied, dass nichts Schlimmes passieren würde, wenn die Methode der internen Klasse als öffentlich markiert würde, so dass der Compiler keine Schmerzen hatte und kein weiterer Code eingefügt werden musste.  Die Schnittstelle ist als intern markiert, die Klasse, die sie implementiert, ist als intern markiert. Von außen scheint es keine Möglichkeit zu geben, zu der als öffentlich gekennzeichneten Methode zu gelangen. </p><br><p>  Und dann öffnet sich die Tür und das Spiegelbild schleicht sich leise ein: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pipe; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Reflection; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">EncapsulationTest</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(I), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IExtensions), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(A), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(A), <span class="hljs-string"><span class="hljs-string">"OtherMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(B), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(B), <span class="hljs-string"><span class="hljs-string">"OtherMethod"</span></span>); Console.ReadLine(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindThroughReflection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type type, String methodName</span></span></span><span class="hljs-function">)</span></span> { MethodInfo methodInfo = type.GetMethod(methodName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (methodInfo != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"In type </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{type.Name}</span></span></span><span class="hljs-string"> we found </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{methodInfo}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"NULL! Can't find method </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{methodName}</span></span></span><span class="hljs-string"> in type </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{type.Name}</span></span></span><span class="hljs-string">"</span></span>); } } }</code> </pre><br><p>  Studieren Sie diesen Code und fahren Sie ihn ins Studio, wenn Sie dies wünschen.  Hier versuchen wir, mithilfe der Reflexion alle Methoden aus allen Arten unserer Pipe (Namespace Pipe) zu finden.  Und hier sind die Ergebnisse, die es uns gibt: </p><br><blockquote>  In Typ I fanden wir Void SomeMethod () <br>  NULL!  Die Methode SomeMethod kann vom Typ IExtensions nicht gefunden werden <br>  In Typ A fanden wir Void SomeMethod () <br>  NULL!  Die Methode OtherMethod in Typ A kann nicht gefunden werden <br>  NULL!  Die Methode SomeMethod in Typ B kann nicht gefunden werden <br>  NULL!  Die Methode OtherMethod in Typ B kann nicht gefunden werden <br></blockquote><br><p>  Ich muss sofort sagen, dass mit einem Objekt vom Typ MethodInfo die gefundene Methode aufgerufen werden kann.  Das heißt, wenn die Reflexion etwas gefunden hat, kann die Einkapselung rein theoretisch verletzt werden.  Und wir haben etwas gefunden.  Erstens, die gleiche öffentliche Leere SomeMethod () aus Klasse A. Es wurde erwartet, was noch zu sagen ist.  Dieser Genuss kann immer noch Konsequenzen haben.  Zweitens void SomeMethod () von Schnittstelle I. Dies ist bereits interessanter.  Unabhängig davon, wie wir uns einsperren, sind die abstrakten Methoden in der Schnittstelle (oder was die CLR tatsächlich dort platziert) tatsächlich offen.  Daher die Schlussfolgerung in einem separaten Absatz: </p><br><p>  <em>Schauen Sie sich genau an, wen und welche Art von System.Type-Typ Sie verschenken.</em> </p><br><p>  Bei diesen beiden Methoden gibt es jedoch noch eine weitere Nuance, die ich berücksichtigen möchte.  Interne Schnittstellenmethoden und öffentliche Methoden interner Klassen können mithilfe von Reflection gefunden werden.  Als vernünftige Person werde ich zu dem Schluss kommen, dass sie in die Metadaten fallen.  Als erfahrene Person werde ich diese Schlussfolgerung überprüfen.  Und in diesem ILDasm wird uns helfen. </p><br><div class="spoiler">  <b class="spoiler_title">Werfen Sie einen Blick auf das Kaninchenloch in den Metadaten unserer Pipe</b> <div class="spoiler_text"><p>  Montage wurde in Release montiert </p><br> <code>TypeDef #2 (02000003) <br> ------------------------------------------------------- <br> TypDefName: Pipe.I (02000003) <br> Flags : [NotPublic] [AutoLayout] [Interface] [Abstract] [AnsiClass] (000000a0) <br> Extends : 01000000 [TypeRef] <br> Method #1 (06000004) <br> ------------------------------------------------------- <br> MethodName: SomeMethod (06000004) <br> Flags : [Public] [Virtual] [HideBySig] [NewSlot] [Abstract] (000005c6) <br> RVA : 0x00000000 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> TypeDef #3 (02000004) <br> ------------------------------------------------------- <br> TypDefName: Pipe.IExtensions (02000004) <br> Flags : [NotPublic] [AutoLayout] [Class] [Abstract] [Sealed] [AnsiClass] [BeforeFieldInit] (00100180) <br> Extends : 01000011 [TypeRef] System.Object <br> Method #1 (06000005) <br> ------------------------------------------------------- <br> MethodName: SomeMethod (06000005) <br> Flags : [Assem] [Static] [HideBySig] [ReuseSlot] (00000093) <br> RVA : 0x00002134 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> ReturnType: Void <br> 1 Arguments <br> Argument #1: Class Pipe.I <br> 1 Parameters <br> (1) ParamToken : (08000004) Name : i flags: [none] (00000000) <br> CustomAttribute #1 (0c000011) <br> ------------------------------------------------------- <br> CustomAttribute Type: 0a000001 <br> CustomAttributeName: System.Runtime.CompilerServices.ExtensionAttribute :: instance void .ctor() <br> Length: 4 <br> Value : 01 00 00 00 &gt; &lt; <br> ctor args: () <br> <br> CustomAttribute #1 (0c000010) <br> ------------------------------------------------------- <br> CustomAttribute Type: 0a000001 <br> CustomAttributeName: System.Runtime.CompilerServices.ExtensionAttribute :: instance void .ctor() <br> Length: 4 <br> Value : 01 00 00 00 &gt; &lt; <br> ctor args: () <br> <br> TypeDef #4 (02000005) <br> ------------------------------------------------------- <br> TypDefName: Pipe.A (02000005) <br> Flags : [NotPublic] [AutoLayout] [Class] [AnsiClass] [BeforeFieldInit] (00100000) <br> Extends : 01000011 [TypeRef] System.Object <br> Method #1 (06000006) <br> ------------------------------------------------------- <br> MethodName: SomeMethod (06000006) <br> Flags : [Public] [Final] [Virtual] [HideBySig] [NewSlot] (000001e6) <br> RVA : 0x0000213c <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #2 (06000007) <br> ------------------------------------------------------- <br> MethodName: OtherMethod (06000007) <br> Flags : [Assem] [HideBySig] [ReuseSlot] (00000083) <br> RVA : 0x0000213e <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #3 (06000008) <br> ------------------------------------------------------- <br> MethodName: .ctor (06000008) <br> Flags : [Public] [HideBySig] [ReuseSlot] [SpecialName] [RTSpecialName] [.ctor] (00001886) <br> RVA : 0x00002140 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> InterfaceImpl #1 (09000001) <br> ------------------------------------------------------- <br> Class : Pipe.A <br> Token : 02000003 [TypeDef] Pipe.I <br> <br> TypeDef #5 (02000006) <br> ------------------------------------------------------- <br> TypDefName: Pipe.B (02000006) <br> Flags : [NotPublic] [AutoLayout] [Class] [AnsiClass] [BeforeFieldInit] (00100000) <br> Extends : 01000011 [TypeRef] System.Object <br> Method #1 (06000009) <br> ------------------------------------------------------- <br> MethodName: OtherMethod (06000009) <br> Flags : [Assem] [HideBySig] [ReuseSlot] (00000083) <br> RVA : 0x00002148 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #2 (0600000a) <br> ------------------------------------------------------- <br> MethodName: Pipe.I.SomeMethod (0600000A) <br> Flags : [Private] [Final] [Virtual] [HideBySig] [NewSlot] (000001e1) <br> RVA : 0x0000214a <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #3 (0600000b) <br> ------------------------------------------------------- <br> MethodName: .ctor (0600000B) <br> Flags : [Public] [HideBySig] [ReuseSlot] [SpecialName] [RTSpecialName] [.ctor] (00001886) <br> RVA : 0x0000214c <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> MethodImpl #1 (00000001) <br> ------------------------------------------------------- <br> Method Body Token : 0x0600000a <br> Method Declaration Token : 0x06000004 <br> <br> InterfaceImpl #1 (09000002) <br> ------------------------------------------------------- <br> Class : Pipe.B <br> Token : 02000003 [TypeDef] Pipe.I <br></code> <br></div></div><br><p>  Ein kurzer Blick zeigt, dass <strong>alles</strong> in die Metadaten gelangt, egal wie sie markiert sind.  Reflexion verbirgt uns immer noch sorgfältig, dass Außenstehende nicht sehen sollen.  Es kann also durchaus sein, dass die zusätzlichen fünf Codezeilen für jede Methode der internen Schnittstelle kein so großes Übel sind.  Die Hauptschlussfolgerung bleibt jedoch dieselbe: </p><br><p>  <em>Schauen Sie sich genau an, wen und welche Art von System.Type-Typ Sie verschenken.</em> </p><br><p>  Dies ist natürlich die nächste Stufe nach dem Zugriff auf das interne Schlüsselwort an allen Stellen, an denen keine öffentliche Notwendigkeit besteht. </p><br><h2>  PS </h2><br><p>  Sie wissen, dass das Coolste an der Verwendung des internen Schlüsselworts überall in der Assembly ist?  Wenn es wächst, müssen Sie es in zwei oder mehr teilen.  Dabei müssen Sie eine Pause einlegen, um einige Typen zu öffnen.  Und Sie müssen genau darüber nachdenken, welche Typen es wert sind, offen zu werden.  Zumindest kurz. </p><br><p>  Dies bedeutet Folgendes: <em>Diese Praxis des Schreibens von Code lässt Sie erneut darüber nachdenken, wie die architektonische Grenze zwischen neugeborenen Baugruppen aussehen wird.</em>  Was könnte schöner sein? </p><br><h2>  PPS </h2><br><p>  Ab Version C # 7.2 wurde ein neuer, privat geschützter Zugriffsmodifikator angezeigt.  Und ich habe immer noch keine Ahnung, was es ist und womit es gegessen wird.  Da in der Praxis nicht angetroffen.  Aber ich werde es gerne in den Kommentaren wissen.  Aber nicht Kopieren und Einfügen aus der Dokumentation, sondern echte Fälle, in denen dieser Zugriffsmodifikator möglicherweise benötigt wird. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445804/">https://habr.com/ru/post/de445804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445794/index.html">IT-Giganten stellen eine hybride Hybrid-Cloud-Bereitstellungslösung vor</a></li>
<li><a href="../de445796/index.html">Fintech Digest: Dorsey zahlt mit Bitcoins, Australiens Blockchain-Strategie, Levis Börsengang, Bürgermeister von Chicago und der Unvermeidlichkeit von Bitcoin</a></li>
<li><a href="../de445798/index.html">Nashorn in der Katze - Führen Sie die Firmware im Kopycat-Emulator aus</a></li>
<li><a href="../de445800/index.html">Monaden in 15 Minuten</a></li>
<li><a href="../de445802/index.html">5 Dinge, über die Internet-Trends jeder wissen sollte</a></li>
<li><a href="../de445806/index.html">Wie künstliche Intelligenz die Wissenschaft verändert</a></li>
<li><a href="../de445808/index.html">Wir hassen und jagen: das gefährliche Leben eines Virus-Crackers, der sich mächtige Feinde macht</a></li>
<li><a href="../de445814/index.html">Wie ein Lieferroboter die kulinarischen Gewohnheiten amerikanischer Studenten verändert hat</a></li>
<li><a href="../de445816/index.html">Wie wir Server-Rendering gesehen haben und was daraus wurde</a></li>
<li><a href="../de445820/index.html">MVCC-3. Zeilenversionen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>