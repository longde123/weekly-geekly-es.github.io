<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí¨ üì∞ üëá Saisie dynamique statiquement s√©curis√©e √† la Python üë©‚Äçüåæ ü§öüèø üßìüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, Habr. 


 L'autre jour, dans l'un de mes projets de bricolage, la t√¢che s'est pos√©e d'√©crire un r√©f√©rentiel de m√©triques. 


 La t√¢che elle-m√™m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Saisie dynamique statiquement s√©curis√©e √† la Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457930/"><p>  Salut, Habr. </p><br><p>  L'autre jour, dans l'un de mes projets de bricolage, la t√¢che s'est pos√©e d'√©crire un r√©f√©rentiel de m√©triques. </p><br><p>  La t√¢che elle-m√™me est r√©solue tr√®s simplement, mais mon probl√®me avec le Haskell (en particulier dans les projets pour mon propre divertissement) est qu'il est impossible de simplement prendre et r√©soudre le probl√®me.  Il est n√©cessaire de d√©cider, d'√©largir, d'abstraire, d'abstraire puis de d√©velopper davantage.  Par cons√©quent, je voulais rendre le stockage des m√©triques extensible afin de ne pas sp√©cifier √† l'avance ce qu'elles seraient l√†.  C'est en soi un sujet pour un article s√©par√©, et aujourd'hui nous allons consid√©rer un petit ingr√©dient: √©crire un wrapper de type s√ªr pour les types inconnus auparavant.  Quelque chose comme la frappe dynamique, mais avec des garanties statiques que nous ne ferons pas de b√™tises. </p><br><p>  L'article, je pense, n'ouvrira rien de nouveau pour les Haskellistes exp√©riment√©s, mais maintenant nous allons au moins mettre cet ingr√©dient hors de la bo√Æte et ne nous en distraire pas dans les articles suivants.  Eh bien, ou vous ne pouvez pas √™tre si modeste et dire que j'ai d√©j√† propos√© un mod√®le de conception entier. </p><a name="habracut"></a><br><p>  Donc, nous formulons d'abord le probl√®me.  Nous devons √™tre capables d'associer certains objets √† des valeurs de types inconnus auparavant.  Ou, en d'autres termes, il est n√©cessaire que les valeurs de types pr√©c√©demment inconnus agissent comme des cl√©s dans une sorte de carte. </p><br><p> Naturellement, nous ne sommes pas fous et nous n'aurons pas besoin du soutien de valeurs de tout type.  Nous exigeons que le type (m√™me s'il est inconnu) prenne en charge la comparaison dans le sens de la commande.  En termes Haskell, cela signifie que nous prenons en charge les types <code>a</code> qui impl√©mentent la classe <code>Ord a</code> . </p><br><p>  Notez que nous pourrions demander de l'aide pour prendre un hachage et v√©rifier l'√©galit√©, mais pour un certain nombre de raisons, il serait plus pratique et clair de se limiter √† la comparaison. </p><br><p>  Lorsqu'il s'agit de stocker des valeurs connues pour impl√©menter un certain type de classe, les types existentiels sont g√©n√©ralement utilis√©s dans le Haskell: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeOrd</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkSomeOrd</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> a =&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeOrd</span></span></span></span></code> </pre> <br><p>  Donc, si on nous donne un objet de type <code>SomeOrd</code> et que nous faisons une correspondance de motifs pour cela: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foo</span></span> :: <span class="hljs-type"><span class="hljs-type">SomeOrd</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bar</span></span> foo (<span class="hljs-type"><span class="hljs-type">MkSomeOrd</span></span> val) = ... (<span class="hljs-number"><span class="hljs-number">1</span></span>) ...</code> </pre> <br><p>  puis au point <code>(1)</code> nous ne savons pas quel type <code>val</code> a, mais nous savons (et, surtout, le temporisateur sait √©galement) que <code>val</code> impl√©mente la classe temporelle <code>Ord</code> . </p><br><p>  Cependant, si les fonctions de type de la classe impliquent deux (ou plus) arguments, alors l'utilisation d'un tel enregistrement est de peu d'utilit√©: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">tryCompare</span></span> :: <span class="hljs-type"><span class="hljs-type">SomeOrd</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SomeOrd</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> tryCompare (<span class="hljs-type"><span class="hljs-type">MkSomeOrd</span></span> val1) (<span class="hljs-type"><span class="hljs-type">MkSomeOrd</span></span> val2) = ?</code> </pre> <br><p>  Pour utiliser les m√©thodes <code>Ord</code> , il faut que <code>val</code> et <code>val2</code> m√™me type, mais cela ne doit pas du tout √™tre fait!  Il s'av√®re que notre <code>SomeOrd</code> inutile.  Que faire? </p><br><p>  Malgr√© le fait que le Haskell est un langage compil√© avec un effacement de type agressif (apr√®s la compilation, ils ne sont pas l√† en g√©n√©ral), le compilateur peut toujours g√©n√©rer des repr√©sentants de type d'ex√©cution si on le lui demande.  Le r√¥le repr√©sentatif du type <code>a</code> est la valeur du type <code>TypeRep a</code> , et <del>  demande </del>  g√©n√©ration est r√©pondu par Typeclass <code>Typeable</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Au fait</b> <div class="spoiler_text"><p>  Soit dit en passant, <code>a</code> ne doit pas n√©cessairement √™tre un type au sens habituel, c'est-√†-dire appartenir √† une vari√©t√© <code>*</code> .  Il peut s'agir de tout autre type de <code>k</code> , qui vous permet th√©oriquement de faire des choses int√©ressantes en stockant des repr√©sentants d'ex√©cution des types appris et similaires, mais je n'ai pas compris quoi exactement. </p></div></div><br><p>  De plus, si nous avons deux instances diff√©rentes de <code>rep1 :: TypeRep a, rep2 :: TypeRep b</code> , alors nous pouvons les comparer et v√©rifier si elles repr√©sentent le m√™me type ou non.  De plus, s'ils repr√©sentent r√©ellement le m√™me type, alors √©videmment <code>a</code> co√Øncide avec <code>b</code> .  Et, plus important encore, la fonction de v√©rification de l'√©galit√© des repr√©sentations de type renvoie un r√©sultat qui peut convaincre le typeur de ceci: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">eqTypeRep</span></span> :: <span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> k1 k2 (a :: k1) (b :: k2). <span class="hljs-type"><span class="hljs-type">TypeRep</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">TypeRep</span></span> b -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> (a :~~: b)</code> </pre> <br><p>  Quel non-sens est √©crit ici? </p><br><p>  Tout d'abord, <code>eqTypeRep</code> est une fonction. </p><br><p>  Deuxi√®mement, il est polymorphe, mais non seulement par type, mais aussi par vari√©t√©s de ces types.  Ceci est indiqu√© par la partie pour tous les <code>forall k1 k2 (a :: k1) (b :: k2)</code> - cela signifie que <code>a</code> et <code>b</code> peuvent √™tre non seulement des types ordinaires comme <code>Int</code> ou <code>[String]</code> , mais aussi, par exemple, des constructeurs notoires (voir DataKinds et autres tentatives de certification Haskell).  Mais nous n'avons pas besoin de tout cela. </p><br><p>  Troisi√®mement, il accepte deux repr√©sentations d'ex√©cution de types potentiellement diff√©rents, <code>TypeRep a</code> et <code>TypeRep b</code> . </p><br><p>  Quatri√®mement, il renvoie une valeur de type <code>Maybe (a :~~: b)</code> .  La chose la plus int√©ressante se produit ici. </p><br><p>  Si les types ne correspondent pas, la fonction retourne le <code>Nothing</code> habituel et tout va bien.  Si les types correspondent, alors la fonction renvoie <code>Just val</code> , o√π <code>val</code> est de type <code>a :~~: b</code> .  Voyons de quel type il s'agit: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | Kind heterogeneous propositional equality. Like ':~:', @a :~~: b@ is -- inhabited by a terminating value if and only if @a@ is the same type as @b@. -- -- @since 4.10.0.0 data (a :: k1) :~~: (b :: k2) where HRefl :: a :~~: a</span></span></code> </pre> <br><p>  Parlons maintenant.  Supposons que nous obtenions une valeur <code>val</code> de type <code>a :~~: b</code> .  Comment pourrait-il √™tre construit?  La seule fa√ßon est avec le constructeur <code>HRefl</code> , et ce constructeur requiert que des deux c√¥t√©s de l'ic√¥ne <code>:~~:</code> ce soit la m√™me chose.  Par cons√©quent, <code>a</code> co√Øncide avec <code>b</code> .  De plus, si nous zapternnom-match sur <code>val</code> , le taypcheker le saura √©galement.  Par cons√©quent, oui, la fonction <code>eqTypeRep</code> renvoie la preuve que deux types potentiellement diff√©rents sont identiques s'ils sont r√©ellement √©gaux. </p><br><p>  Cependant, dans le paragraphe ci-dessus, j'ai menti.  Personne ne nous emp√™che <em>d'√©crire dans Haskell</em> quelque chose comme </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">wrong</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> :~~: <span class="hljs-type"><span class="hljs-type">String</span></span> wrong = wrong <span class="hljs-comment"><span class="hljs-comment">--   </span></span></code> </pre> <br><p>  ou </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">wrong</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> :~~: <span class="hljs-type"><span class="hljs-type">String</span></span> wrong = undefined</code> </pre> <br><p>  ou briser le syst√®me avec un tas de moyens l√©g√®rement moins √©vidents.  C'est l'une des manifestations du bien connu dans les cercles √©troits disant que le Haskell n'est pas coh√©rent en tant que logique.  Dans les langues avec des syst√®mes de types plus forts, ces d√©finitions ne sont pas estampill√©es. </p><br><p>  C'est pourquoi dans la documentation cit√©e ci-dessus, la <em>valeur finale est</em> mentionn√©e.  Les deux variantes de l'impl√©mentation de <code>wrong</code> ci-dessus ne produisent pas cette valeur tr√®s finale, ce qui nous donne un peu de raison et de confiance: si notre programme sur le Haskell s'est <em>termin√©</em> (et ne s'est pas ex√©cut√© en <code>undefined</code> ), alors son r√©sultat correspond aux types √©crits.  Ici, cependant, il y a quelques d√©tails li√©s √† la paresse, mais nous n'ouvrirons pas ce sujet. </p><br><p>  Et en passant, la deuxi√®me manifestation de la faiblesse de Haskell dans le code ci-dessus est le type de la fonction <code>eqTypeRep</code> .  Dans des langages plus forts, cela retournerait une valeur d'un type plus fort, ce qui prouverait non seulement l'√©galit√© des types s'ils sont r√©ellement √©gaux, mais prouverait √©galement leur <em>in√©galit√©</em> s'ils sont r√©ellement in√©gaux.  L'incoh√©rence de la logique Haskell, cependant, rend ces fonctions un peu inutiles: tout cela est important lorsque vous utilisez le langage comme prouveur de th√©or√®mes, et non pas comme langage de programmation, et n'utilisez pas Haskell comme prouveur. </p><br><p>  Eh bien, assez de la th√©orie des journaux et des types, revenons √† nos mesures. <del>  Maintenant, dessinez simplement un hibou </del>  La discussion ci-dessus laisse entendre qu'il suffit de stocker dans notre type existentiel √©galement c'est la repr√©sentation la plus runtime du type, et tout ira bien. </p><br><p>  Cela nous am√®ne √† l'impl√©mentation suivante de notre type de wrapper: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TypeRep</span></span></span><span class="hljs-class"> a -&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> toDyn :: (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Typeable</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) =&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> toDyn val = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeOf</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class">) val</span></span></code> </pre> <br><p>  Maintenant, nous √©crivons une fonction qui prend ce qui suit: </p><br><ol><li>  deux valeurs de type <code>Dyn</code> ; </li><li>  une fonction qui produit quelque chose pour deux valeurs de <em>tout type</em> , <br>  bas√© uniquement sur les constantes mentionn√©es lors de la cr√©ation de <code>Dyn</code> ( <code>forall</code> est responsable), <br>  et qui est appel√©e si les deux <code>Dyn</code> stockent des valeurs du m√™me type; </li><li>  et la fonction de secours, qui est appel√©e √† la place de la pr√©c√©dente, si les types sont toujours diff√©rents: </li></ol><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">withDyns</span></span> :: (<span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> a. <span class="hljs-type"><span class="hljs-type">Ord</span></span> a =&gt; a -&gt; a -&gt; b) -&gt; (<span class="hljs-type"><span class="hljs-type">SomeTypeRep</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SomeTypeRep</span></span> -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Dyn</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Dyn</span></span> -&gt; b withDyns f def (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> ty1 v1) (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> ty2 v2) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> eqTypeRep ty1 ty2 <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; def (<span class="hljs-type"><span class="hljs-type">SomeTypeRep</span></span> ty1) (<span class="hljs-type"><span class="hljs-type">SomeTypeRep</span></span> ty2) <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-type"><span class="hljs-type">HRefl</span></span> -&gt; f v1 v2</code> </pre> <br><p>  <code>SomeTypeRep</code> est un wrapper existentiel sur <code>TypeRep a</code> pour tout <code>a</code> . </p><br><p>  Nous pouvons maintenant impl√©menter, par exemple, la v√©rification et la comparaison d'√©galit√©: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (==) = withDyns (==) (\_ _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span> <span class="hljs-type"><span class="hljs-type">Dyn</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> compare = withDyns compare compare</code> </pre> <br><p>  Ici, nous avons profit√© du fait que <code>SomeTypeRep</code> peut √™tre compar√© les uns aux autres, donc la fonction de secours pour la commande est √©galement <code>compare</code> . </p><br><p>  C'est fait. </p><br><p>  Seulement maintenant, c'est un p√©ch√© de ne pas g√©n√©raliser: nous notons qu'√† l'int√©rieur de <code>Dyn</code> , <code>toDyn</code> , <code>withDyns</code> nous n'utilisons pas <code>Ord</code> sp√©cifiquement, et cela pourrait √™tre tout autre ensemble de constantes, nous pouvons donc activer l'extension <code>ConstraintKinds</code> et <em>g√©n√©raliser</em> en param√©trant <code>Dyn</code> ensemble sp√©cifique de restrictions que nous n√©cessaire dans notre t√¢che sp√©cifique: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> :: ctx a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TypeRep</span></span></span><span class="hljs-class"> a -&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx toDyn :: (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Typeable</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) =&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx toDyn val = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeOf</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class">) val withDyns :: (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">forall</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">. </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> =&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeTypeRep</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeTypeRep</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx -&gt; b withDyns (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ty1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v1</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ty2</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v2</span></span></span><span class="hljs-class">) f def = case eqTypeRep ty1 ty2 of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class"> -&gt; def (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeTypeRep</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ty1</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeTypeRep</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ty2</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Just</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HRefl</span></span></span><span class="hljs-class"> -&gt; f v1 v2</span></span></code> </pre> <br><p>  Ensuite, <code>Dyn Ord</code> sera notre type de <code>Dyn Monoid</code> , et, disons, <code>Dyn Monoid</code> vous permettra de stocker des mono√Ødes arbitraires et de faire quelque chose de mono√Ødal avec eux. </p><br><p>  √âcrivons les instances dont nous avons besoin pour notre nouveau <code>Dyn</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (==) = withDyns (==) (\_ _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span> (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> compare = withDyns compare compare</code> </pre> <br><p>  ... seulement cela ne fonctionne pas.  Le typeur ne sait pas que <code>Dyn Ord</code> impl√©mente √©galement <code>Eq</code> , <br>  vous devez donc copier toute la hi√©rarchie: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (==) = withDyns d1 d2 (==) (\_ _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Eq</span></span> (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> (==) = withDyns d1 d2 (==) (\_ _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span> (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> compare = withDyns d1 d2 compare compare</code> </pre> <br><p>  Eh bien, maintenant c'est s√ªr. </p><br><p>  ... peut-√™tre, dans un Haskell moderne, vous pouvez faire en sorte que le minuteur lui-m√™me affiche les instances du formulaire </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C_i</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C_1</span></span></span><span class="hljs-class">, ... </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C_n</span></span></span><span class="hljs-class">)) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> ...</code> </pre> <br><p>  parce que quelque chose de prologique sort, mais je ne l'ai pas encore fait, je vais devoir m'asseoir pour le cueillir.  Restez √† l'√©coute. </p><br><p>  Et aussi, si vous plissez les yeux, vous pouvez voir que notre <code>Dyn</code> ressemble √©trangement √† une paire d√©pendante du type <code>(ty : Type ** val : ty)</code> des langages cryptiques.  Mais seulement dans les langues que je connais, il est impossible de faire correspondre le type, car la param√©tricit√© (qui dans ce cas, √† mon humble avis, est interpr√©t√©e trop largement), mais ici cela semble possible. </p><br><p>  Mais la chose la plus importante - maintenant vous pouvez avoir en toute s√©curit√© quelque chose comme <code>Map (Dyn Ord) SomeValue</code> et utiliser toutes les valeurs comme cl√©s, tant qu'elles prennent elles-m√™mes en charge la comparaison.  Par exemple, les identifiants avec des descriptions de mesures peuvent √™tre utilis√©s comme cl√©s, mais ceci est un sujet pour l'article suivant. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr457930/">https://habr.com/ru/post/fr457930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr457904/index.html">Radio atomique - la toute premi√®re √©mission musicale</a></li>
<li><a href="../fr457906/index.html">Les m√©decins pensent que dans un avenir proche, des dispositifs de fabrication de vaccins appara√Ætront dans les maisons et les pharmacies</a></li>
<li><a href="../fr457910/index.html">WebFPGA - D√©veloppement Verilog dans le navigateur</a></li>
<li><a href="../fr457920/index.html">Jet world: acc√®s libre et gratuit aux rapports de la conf√©rence Joker 2018 + bilan du top 10</a></li>
<li><a href="../fr457928/index.html">Classement d√©taill√© pour comparer deux images</a></li>
<li><a href="../fr457932/index.html">Analyse du concours IDS Bypass aux Positive Hack Days 9</a></li>
<li><a href="../fr457936/index.html">Nous vous invitons √† la premi√®re conf√©rence Zabbix en Russie</a></li>
<li><a href="../fr457940/index.html">Comment scruter la contrepartie</a></li>
<li><a href="../fr457942/index.html">Ce que j'ai appris sur l'optimisation en Python</a></li>
<li><a href="../fr457946/index.html">10 meilleures biblioth√®ques JavaScript pour visualiser les donn√©es sur des graphiques et des tableaux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>