<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💬 📰 👇 Saisie dynamique statiquement sécurisée à la Python 👩‍🌾 🤚🏿 🧓🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, Habr. 


 L'autre jour, dans l'un de mes projets de bricolage, la tâche s'est posée d'écrire un référentiel de métriques. 


 La tâche elle-mêm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Saisie dynamique statiquement sécurisée à la Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457930/"><p>  Salut, Habr. </p><br><p>  L'autre jour, dans l'un de mes projets de bricolage, la tâche s'est posée d'écrire un référentiel de métriques. </p><br><p>  La tâche elle-même est résolue très simplement, mais mon problème avec le Haskell (en particulier dans les projets pour mon propre divertissement) est qu'il est impossible de simplement prendre et résoudre le problème.  Il est nécessaire de décider, d'élargir, d'abstraire, d'abstraire puis de développer davantage.  Par conséquent, je voulais rendre le stockage des métriques extensible afin de ne pas spécifier à l'avance ce qu'elles seraient là.  C'est en soi un sujet pour un article séparé, et aujourd'hui nous allons considérer un petit ingrédient: écrire un wrapper de type sûr pour les types inconnus auparavant.  Quelque chose comme la frappe dynamique, mais avec des garanties statiques que nous ne ferons pas de bêtises. </p><br><p>  L'article, je pense, n'ouvrira rien de nouveau pour les Haskellistes expérimentés, mais maintenant nous allons au moins mettre cet ingrédient hors de la boîte et ne nous en distraire pas dans les articles suivants.  Eh bien, ou vous ne pouvez pas être si modeste et dire que j'ai déjà proposé un modèle de conception entier. </p><a name="habracut"></a><br><p>  Donc, nous formulons d'abord le problème.  Nous devons être capables d'associer certains objets à des valeurs de types inconnus auparavant.  Ou, en d'autres termes, il est nécessaire que les valeurs de types précédemment inconnus agissent comme des clés dans une sorte de carte. </p><br><p> Naturellement, nous ne sommes pas fous et nous n'aurons pas besoin du soutien de valeurs de tout type.  Nous exigeons que le type (même s'il est inconnu) prenne en charge la comparaison dans le sens de la commande.  En termes Haskell, cela signifie que nous prenons en charge les types <code>a</code> qui implémentent la classe <code>Ord a</code> . </p><br><p>  Notez que nous pourrions demander de l'aide pour prendre un hachage et vérifier l'égalité, mais pour un certain nombre de raisons, il serait plus pratique et clair de se limiter à la comparaison. </p><br><p>  Lorsqu'il s'agit de stocker des valeurs connues pour implémenter un certain type de classe, les types existentiels sont généralement utilisés dans le Haskell: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeOrd</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkSomeOrd</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> a =&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeOrd</span></span></span></span></code> </pre> <br><p>  Donc, si on nous donne un objet de type <code>SomeOrd</code> et que nous faisons une correspondance de motifs pour cela: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foo</span></span> :: <span class="hljs-type"><span class="hljs-type">SomeOrd</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bar</span></span> foo (<span class="hljs-type"><span class="hljs-type">MkSomeOrd</span></span> val) = ... (<span class="hljs-number"><span class="hljs-number">1</span></span>) ...</code> </pre> <br><p>  puis au point <code>(1)</code> nous ne savons pas quel type <code>val</code> a, mais nous savons (et, surtout, le temporisateur sait également) que <code>val</code> implémente la classe temporelle <code>Ord</code> . </p><br><p>  Cependant, si les fonctions de type de la classe impliquent deux (ou plus) arguments, alors l'utilisation d'un tel enregistrement est de peu d'utilité: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">tryCompare</span></span> :: <span class="hljs-type"><span class="hljs-type">SomeOrd</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SomeOrd</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> tryCompare (<span class="hljs-type"><span class="hljs-type">MkSomeOrd</span></span> val1) (<span class="hljs-type"><span class="hljs-type">MkSomeOrd</span></span> val2) = ?</code> </pre> <br><p>  Pour utiliser les méthodes <code>Ord</code> , il faut que <code>val</code> et <code>val2</code> même type, mais cela ne doit pas du tout être fait!  Il s'avère que notre <code>SomeOrd</code> inutile.  Que faire? </p><br><p>  Malgré le fait que le Haskell est un langage compilé avec un effacement de type agressif (après la compilation, ils ne sont pas là en général), le compilateur peut toujours générer des représentants de type d'exécution si on le lui demande.  Le rôle représentatif du type <code>a</code> est la valeur du type <code>TypeRep a</code> , et <del>  demande </del>  génération est répondu par Typeclass <code>Typeable</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Au fait</b> <div class="spoiler_text"><p>  Soit dit en passant, <code>a</code> ne doit pas nécessairement être un type au sens habituel, c'est-à-dire appartenir à une variété <code>*</code> .  Il peut s'agir de tout autre type de <code>k</code> , qui vous permet théoriquement de faire des choses intéressantes en stockant des représentants d'exécution des types appris et similaires, mais je n'ai pas compris quoi exactement. </p></div></div><br><p>  De plus, si nous avons deux instances différentes de <code>rep1 :: TypeRep a, rep2 :: TypeRep b</code> , alors nous pouvons les comparer et vérifier si elles représentent le même type ou non.  De plus, s'ils représentent réellement le même type, alors évidemment <code>a</code> coïncide avec <code>b</code> .  Et, plus important encore, la fonction de vérification de l'égalité des représentations de type renvoie un résultat qui peut convaincre le typeur de ceci: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">eqTypeRep</span></span> :: <span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> k1 k2 (a :: k1) (b :: k2). <span class="hljs-type"><span class="hljs-type">TypeRep</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">TypeRep</span></span> b -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> (a :~~: b)</code> </pre> <br><p>  Quel non-sens est écrit ici? </p><br><p>  Tout d'abord, <code>eqTypeRep</code> est une fonction. </p><br><p>  Deuxièmement, il est polymorphe, mais non seulement par type, mais aussi par variétés de ces types.  Ceci est indiqué par la partie pour tous les <code>forall k1 k2 (a :: k1) (b :: k2)</code> - cela signifie que <code>a</code> et <code>b</code> peuvent être non seulement des types ordinaires comme <code>Int</code> ou <code>[String]</code> , mais aussi, par exemple, des constructeurs notoires (voir DataKinds et autres tentatives de certification Haskell).  Mais nous n'avons pas besoin de tout cela. </p><br><p>  Troisièmement, il accepte deux représentations d'exécution de types potentiellement différents, <code>TypeRep a</code> et <code>TypeRep b</code> . </p><br><p>  Quatrièmement, il renvoie une valeur de type <code>Maybe (a :~~: b)</code> .  La chose la plus intéressante se produit ici. </p><br><p>  Si les types ne correspondent pas, la fonction retourne le <code>Nothing</code> habituel et tout va bien.  Si les types correspondent, alors la fonction renvoie <code>Just val</code> , où <code>val</code> est de type <code>a :~~: b</code> .  Voyons de quel type il s'agit: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | Kind heterogeneous propositional equality. Like ':~:', @a :~~: b@ is -- inhabited by a terminating value if and only if @a@ is the same type as @b@. -- -- @since 4.10.0.0 data (a :: k1) :~~: (b :: k2) where HRefl :: a :~~: a</span></span></code> </pre> <br><p>  Parlons maintenant.  Supposons que nous obtenions une valeur <code>val</code> de type <code>a :~~: b</code> .  Comment pourrait-il être construit?  La seule façon est avec le constructeur <code>HRefl</code> , et ce constructeur requiert que des deux côtés de l'icône <code>:~~:</code> ce soit la même chose.  Par conséquent, <code>a</code> coïncide avec <code>b</code> .  De plus, si nous zapternnom-match sur <code>val</code> , le taypcheker le saura également.  Par conséquent, oui, la fonction <code>eqTypeRep</code> renvoie la preuve que deux types potentiellement différents sont identiques s'ils sont réellement égaux. </p><br><p>  Cependant, dans le paragraphe ci-dessus, j'ai menti.  Personne ne nous empêche <em>d'écrire dans Haskell</em> quelque chose comme </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">wrong</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> :~~: <span class="hljs-type"><span class="hljs-type">String</span></span> wrong = wrong <span class="hljs-comment"><span class="hljs-comment">--   </span></span></code> </pre> <br><p>  ou </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">wrong</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> :~~: <span class="hljs-type"><span class="hljs-type">String</span></span> wrong = undefined</code> </pre> <br><p>  ou briser le système avec un tas de moyens légèrement moins évidents.  C'est l'une des manifestations du bien connu dans les cercles étroits disant que le Haskell n'est pas cohérent en tant que logique.  Dans les langues avec des systèmes de types plus forts, ces définitions ne sont pas estampillées. </p><br><p>  C'est pourquoi dans la documentation citée ci-dessus, la <em>valeur finale est</em> mentionnée.  Les deux variantes de l'implémentation de <code>wrong</code> ci-dessus ne produisent pas cette valeur très finale, ce qui nous donne un peu de raison et de confiance: si notre programme sur le Haskell s'est <em>terminé</em> (et ne s'est pas exécuté en <code>undefined</code> ), alors son résultat correspond aux types écrits.  Ici, cependant, il y a quelques détails liés à la paresse, mais nous n'ouvrirons pas ce sujet. </p><br><p>  Et en passant, la deuxième manifestation de la faiblesse de Haskell dans le code ci-dessus est le type de la fonction <code>eqTypeRep</code> .  Dans des langages plus forts, cela retournerait une valeur d'un type plus fort, ce qui prouverait non seulement l'égalité des types s'ils sont réellement égaux, mais prouverait également leur <em>inégalité</em> s'ils sont réellement inégaux.  L'incohérence de la logique Haskell, cependant, rend ces fonctions un peu inutiles: tout cela est important lorsque vous utilisez le langage comme prouveur de théorèmes, et non pas comme langage de programmation, et n'utilisez pas Haskell comme prouveur. </p><br><p>  Eh bien, assez de la théorie des journaux et des types, revenons à nos mesures. <del>  Maintenant, dessinez simplement un hibou </del>  La discussion ci-dessus laisse entendre qu'il suffit de stocker dans notre type existentiel également c'est la représentation la plus runtime du type, et tout ira bien. </p><br><p>  Cela nous amène à l'implémentation suivante de notre type de wrapper: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TypeRep</span></span></span><span class="hljs-class"> a -&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> toDyn :: (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Typeable</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) =&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> toDyn val = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeOf</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class">) val</span></span></code> </pre> <br><p>  Maintenant, nous écrivons une fonction qui prend ce qui suit: </p><br><ol><li>  deux valeurs de type <code>Dyn</code> ; </li><li>  une fonction qui produit quelque chose pour deux valeurs de <em>tout type</em> , <br>  basé uniquement sur les constantes mentionnées lors de la création de <code>Dyn</code> ( <code>forall</code> est responsable), <br>  et qui est appelée si les deux <code>Dyn</code> stockent des valeurs du même type; </li><li>  et la fonction de secours, qui est appelée à la place de la précédente, si les types sont toujours différents: </li></ol><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">withDyns</span></span> :: (<span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> a. <span class="hljs-type"><span class="hljs-type">Ord</span></span> a =&gt; a -&gt; a -&gt; b) -&gt; (<span class="hljs-type"><span class="hljs-type">SomeTypeRep</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SomeTypeRep</span></span> -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Dyn</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Dyn</span></span> -&gt; b withDyns f def (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> ty1 v1) (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> ty2 v2) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> eqTypeRep ty1 ty2 <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; def (<span class="hljs-type"><span class="hljs-type">SomeTypeRep</span></span> ty1) (<span class="hljs-type"><span class="hljs-type">SomeTypeRep</span></span> ty2) <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-type"><span class="hljs-type">HRefl</span></span> -&gt; f v1 v2</code> </pre> <br><p>  <code>SomeTypeRep</code> est un wrapper existentiel sur <code>TypeRep a</code> pour tout <code>a</code> . </p><br><p>  Nous pouvons maintenant implémenter, par exemple, la vérification et la comparaison d'égalité: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (==) = withDyns (==) (\_ _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span> <span class="hljs-type"><span class="hljs-type">Dyn</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> compare = withDyns compare compare</code> </pre> <br><p>  Ici, nous avons profité du fait que <code>SomeTypeRep</code> peut être comparé les uns aux autres, donc la fonction de secours pour la commande est également <code>compare</code> . </p><br><p>  C'est fait. </p><br><p>  Seulement maintenant, c'est un péché de ne pas généraliser: nous notons qu'à l'intérieur de <code>Dyn</code> , <code>toDyn</code> , <code>withDyns</code> nous n'utilisons pas <code>Ord</code> spécifiquement, et cela pourrait être tout autre ensemble de constantes, nous pouvons donc activer l'extension <code>ConstraintKinds</code> et <em>généraliser</em> en paramétrant <code>Dyn</code> ensemble spécifique de restrictions que nous nécessaire dans notre tâche spécifique: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> :: ctx a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TypeRep</span></span></span><span class="hljs-class"> a -&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx toDyn :: (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Typeable</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) =&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx toDyn val = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeOf</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class">) val withDyns :: (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">forall</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">. </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> =&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeTypeRep</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeTypeRep</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx -&gt; b withDyns (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ty1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v1</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ty2</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v2</span></span></span><span class="hljs-class">) f def = case eqTypeRep ty1 ty2 of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class"> -&gt; def (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeTypeRep</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ty1</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeTypeRep</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ty2</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Just</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HRefl</span></span></span><span class="hljs-class"> -&gt; f v1 v2</span></span></code> </pre> <br><p>  Ensuite, <code>Dyn Ord</code> sera notre type de <code>Dyn Monoid</code> , et, disons, <code>Dyn Monoid</code> vous permettra de stocker des monoïdes arbitraires et de faire quelque chose de monoïdal avec eux. </p><br><p>  Écrivons les instances dont nous avons besoin pour notre nouveau <code>Dyn</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (==) = withDyns (==) (\_ _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span> (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> compare = withDyns compare compare</code> </pre> <br><p>  ... seulement cela ne fonctionne pas.  Le typeur ne sait pas que <code>Dyn Ord</code> implémente également <code>Eq</code> , <br>  vous devez donc copier toute la hiérarchie: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (==) = withDyns d1 d2 (==) (\_ _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Eq</span></span> (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> (==) = withDyns d1 d2 (==) (\_ _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span> (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> compare = withDyns d1 d2 compare compare</code> </pre> <br><p>  Eh bien, maintenant c'est sûr. </p><br><p>  ... peut-être, dans un Haskell moderne, vous pouvez faire en sorte que le minuteur lui-même affiche les instances du formulaire </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C_i</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C_1</span></span></span><span class="hljs-class">, ... </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C_n</span></span></span><span class="hljs-class">)) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> ...</code> </pre> <br><p>  parce que quelque chose de prologique sort, mais je ne l'ai pas encore fait, je vais devoir m'asseoir pour le cueillir.  Restez à l'écoute. </p><br><p>  Et aussi, si vous plissez les yeux, vous pouvez voir que notre <code>Dyn</code> ressemble étrangement à une paire dépendante du type <code>(ty : Type ** val : ty)</code> des langages cryptiques.  Mais seulement dans les langues que je connais, il est impossible de faire correspondre le type, car la paramétricité (qui dans ce cas, à mon humble avis, est interprétée trop largement), mais ici cela semble possible. </p><br><p>  Mais la chose la plus importante - maintenant vous pouvez avoir en toute sécurité quelque chose comme <code>Map (Dyn Ord) SomeValue</code> et utiliser toutes les valeurs comme clés, tant qu'elles prennent elles-mêmes en charge la comparaison.  Par exemple, les identifiants avec des descriptions de mesures peuvent être utilisés comme clés, mais ceci est un sujet pour l'article suivant. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr457930/">https://habr.com/ru/post/fr457930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr457904/index.html">Radio atomique - la toute première émission musicale</a></li>
<li><a href="../fr457906/index.html">Les médecins pensent que dans un avenir proche, des dispositifs de fabrication de vaccins apparaîtront dans les maisons et les pharmacies</a></li>
<li><a href="../fr457910/index.html">WebFPGA - Développement Verilog dans le navigateur</a></li>
<li><a href="../fr457920/index.html">Jet world: accès libre et gratuit aux rapports de la conférence Joker 2018 + bilan du top 10</a></li>
<li><a href="../fr457928/index.html">Classement détaillé pour comparer deux images</a></li>
<li><a href="../fr457932/index.html">Analyse du concours IDS Bypass aux Positive Hack Days 9</a></li>
<li><a href="../fr457936/index.html">Nous vous invitons à la première conférence Zabbix en Russie</a></li>
<li><a href="../fr457940/index.html">Comment scruter la contrepartie</a></li>
<li><a href="../fr457942/index.html">Ce que j'ai appris sur l'optimisation en Python</a></li>
<li><a href="../fr457946/index.html">10 meilleures bibliothèques JavaScript pour visualiser les données sur des graphiques et des tableaux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>