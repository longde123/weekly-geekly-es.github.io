<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêà üßïüèª üõ£Ô∏è Como funciona o Chrome sem cabe√ßa üóæ üè∫ ü§ù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J√° est√° claro pelo nome que um navegador sem cabe√ßa √© algo sem cabe√ßa. No contexto de um front-end, √© uma ferramenta indispens√°vel para um desenvolved...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como funciona o Chrome sem cabe√ßa</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/421137/">  J√° est√° claro pelo nome que um navegador sem cabe√ßa √© algo sem cabe√ßa.  No contexto de um front-end, √© uma ferramenta indispens√°vel para um desenvolvedor, com a qual voc√™ pode testar o c√≥digo, verificar a qualidade e a conformidade com o layout.  Vitaliy Slobodin, do Frontend Conf, decidiu que era necess√°rio conhecer o dispositivo dessa ferramenta mais de perto. <br><br>  Sob os componentes e recursos de corte do Headless Chrome, cen√°rios interessantes para o uso do Headless Chrome.  A segunda parte sobre o Puppeteer √© uma conveniente biblioteca Node.js. para gerenciar o modo sem cabe√ßa no Google Chrome e Chromium. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WPcahL2K27w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Sobre o palestrante:</strong> Vitaliy Slobodin - um ex-desenvolvedor do PhantomJS - quem o fechou e o enterrou.  √Äs vezes, ajuda o Konstantin Tokarev ( <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">anulen</a></u> ) na vers√£o "ressuscitada" do QtWebKit - o pr√≥prio QtWebKit, onde h√° suporte para ES6, Flexbox e muitos outros padr√µes modernos. <br><br>  Vitaliy adora explorar navegadores, pesquisar no WebKit, Chrome etc. em seu tempo livre e muito mais.  Hoje falaremos sobre navegadores, ou seja, sobre navegadores sem cabe√ßa e toda a sua fam√≠lia fantasma. <a name="habracut"></a><br><br><h2>  <strong>O que √© um navegador sem cabe√ßa?</strong> <br></h2><br>  J√° pelo nome, est√° claro que isso √© algo sem cabe√ßa.  Em um contexto de navegador, isso significa o seguinte. <br><br><ol><li>  N√£o <strong>possui uma renderiza√ß√£o real do conte√∫do</strong> , ou seja, <strong>desenha</strong> tudo na mem√≥ria. </li><li> Devido a isso, <strong>consome menos mem√≥ria</strong> , porque n√£o h√° necessidade de desenhar imagens ou PNGs de gigabyte que as pessoas tentam colocar no back-end usando uma bomba. </li><li>  Ele <strong>funciona mais r√°pido</strong> porque n√£o precisa renderizar nada na tela real. </li><li>  Possui uma <strong>interface de programa√ß√£o para gerenciamento</strong> .  Voc√™ pergunta - ele n√£o tem uma interface, bot√µes, janelas?  Como administrar isso?  Portanto, √© claro, ele tem uma interface para gerenciamento. </li><li>  Uma propriedade importante √© a <strong>capacidade de instalar em um servidor Linux simples</strong> .  Isso √© necess√°rio para que, se voc√™ tiver um Ubuntu ou Red Hat instalado recentemente, solte o bin√°rio ou coloque o pacote nele, e o navegador funcione imediatamente.  N√£o √© necess√°rio xamanismo ou magia vodu. </li></ol><br>  Este √© um navegador t√≠pico baseado no WebKit.  Voc√™ n√£o pode entender os componentes - esta √© apenas uma imagem visual. <br><br><img src="https://habrastorage.org/webt/un/7p/zj/un7pzjwjsn1a3psu2augn59jmj0.jpeg"><br><br>  Estamos interessados ‚Äã‚Äãapenas no componente principal da interface do navegador.  Essa √© a mesma interface do usu√°rio - janelas, menus, notifica√ß√µes pop-up e tudo mais. <br><br><img src="https://habrastorage.org/webt/14/ds/oa/14dsoabrnydhu5hb6iovu_gd2m8.jpeg"><br><br>  √â assim que o navegador sem cabe√ßa se parece.  Percebe a diferen√ßa?  Removemos completamente a interface do usu√°rio.  Ele n√£o existe mais.  <strong>Somente o navegador permanece</strong> . <br><br>  Hoje falaremos sobre o Headless Chrome ().  Qual √© a diferen√ßa entre eles?  De fato, o Chrome √© uma vers√£o com marca do Chromium, que possui codecs propriet√°rios, o mesmo H.264, integra√ß√£o com os servi√ßos do Google e tudo mais.  O Chromium √© apenas uma implementa√ß√£o de c√≥digo aberto. <br><br><img src="https://habrastorage.org/webt/ti/14/-e/ti14-etgpuf8lm5euapnu1qk3rs.jpeg"><br><br>  Data de nascimento do Chrome sem cabe√ßa: 2016.  Se voc√™ se deparar com ele, poder√° me fazer uma pergunta complicada: "Como assim, eu me lembro das not√≠cias de 2017?"  O fato √© que uma equipe de engenheiros do Google entrou em contato com os desenvolvedores do PhantomJS em 2016, quando eles estavam apenas come√ßando a implementar o modo Sem Cabe√ßa no Chrome.  Escrevemos o Google Docks inteiro, como implementaremos a interface e assim por diante.  Ent√£o o Google queria tornar uma interface totalmente compat√≠vel com o PhantomJS.  Foi s√≥ ent√£o que a equipe de engenheiros decidiu n√£o fazer essa compatibilidade. <br><br>  Falaremos sobre a interface de gerenciamento (API), que √© o protocolo Chrome DevTools, mais tarde e veremos o que voc√™ pode fazer com ele. <br><br>  Este artigo ser√° constru√≠do com base no princ√≠pio da pir√¢mide de marionetistas (do marionetista ingl√™s).  Um bom nome √© escolhido - o marionetista √© quem controla todos os outros! <br><br><img src="https://habrastorage.org/webt/4y/2i/lq/4y2ilqrqu3fxx8lrinrjp90zgfq.jpeg"><br><br>  Na base da pir√¢mide est√° o Headless Chrome - Headless Chrome - o que √©? <br><br><h2>  <strong>Cromo sem cabe√ßa</strong> <br></h2><br><img src="https://habrastorage.org/webt/tx/id/ql/txidqlimkcdam_vcyah-fu4vlk0.jpeg"><br><br>  No centro - navegador sem cabe√ßa - o mesmo Chromium ou Chrome (geralmente Chromium).  Possui os chamados renderizadores (RENDERER) - processos que desenham o conte√∫do da p√°gina (sua janela).  Al√©m disso, cada guia precisa de seu pr√≥prio renderizador; portanto, se voc√™ abrir muitas guias, o Chrome iniciar√° tantos processos para renderiza√ß√£o. <br><br>  Al√©m disso, est√° sua aplica√ß√£o.  Se usarmos o Chromium ou o Headless Chrome, o Chrome estar√° em cima dele ou em algum aplicativo no qual voc√™ possa incorpor√°-lo.  O anal√≥gico mais pr√≥ximo pode ser chamado de Steam.  Todo mundo sabe que, em ess√™ncia, o Steam √© apenas um navegador para o site do Steam.  Ele, √© claro, n√£o √© decapitado, mas semelhante a esse esquema. <br><br>  Existem duas maneiras de incorporar o Chrome sem cabe√ßa no seu aplicativo (ou us√°-lo): <br><br><ol><li>  Padr√£o quando voc√™ usa o <strong>Puppeteer</strong> e usa o Headless Chrome. <br></li><li>  Quando voc√™ pega o componente de <strong>biblioteca Sem Cabe√ßa</strong> , ou seja, uma biblioteca que implementa o modo sem cabe√ßa e o incorpora ao seu aplicativo, por exemplo, em C ++. <br></li></ol><br>  Voc√™ pode perguntar, por que o C ++ est√° no front end?  A resposta √© a API do DevTools C ++.  Voc√™ pode implementar e usar os recursos do Chrome sem cabe√ßa de diferentes maneiras.  Se voc√™ usar o Puppeteer, a comunica√ß√£o com um navegador sem cabe√ßa ser√° feita atrav√©s de soquetes da web.  Se voc√™ incorporar a biblioteca Headless em um aplicativo da √°rea de trabalho, usar√° a interface nativa, escrita em C ++. <br><br>  Mas, al√©m de tudo isso, voc√™ ainda tem outras coisas, incluindo: <br><br><ul><li>  <strong>Rede</strong> personalizada - implementa√ß√£o personalizada de intera√ß√£o com a rede.  Suponha que voc√™ trabalhe em um banco ou em uma ag√™ncia governamental que consista em tr√™s letras e comece com "F" e use um protocolo de autentica√ß√£o ou autoriza√ß√£o muito complicado, que n√£o √© suportado pelos navegadores.  Portanto, voc√™ pode precisar de um manipulador personalizado para sua rede.  Voc√™ pode simplesmente pegar sua biblioteca j√° implementada e us√°-la no Chrome. </li><li>  <strong>M√≥dulos Mojo</strong> .  O an√°logo mais pr√≥ximo do Mojo s√£o os binders nativos no Node.js para as bibliotecas nativas escritas em C ++.  O Mojo faz o mesmo - voc√™ pega sua biblioteca nativa, escreve uma interface Mojo para ela e pode chamar os m√©todos da sua biblioteca nativa no seu navegador. </li></ul><br><h3>  Componentes de cromo <br></h3><br><img src="https://habrastorage.org/webt/zh/-x/jf/zh-xjfbpq4mjz2ntcwr_tjriuhe.jpeg"><br><br>  Novamente, ou√ßo uma pergunta delicada: ‚ÄúPor que preciso desse esquema terr√≠vel?  Escrevo em (insira o nome da sua estrutura favorita). ‚Äù <br><br><blockquote>  Eu acredito que um desenvolvedor deve saber como sua ferramenta funciona.  Se voc√™ escreve em React, deve saber como o React funciona.  Se voc√™ escreve em Angular, deve saber o que o Angular tem sob o cap√¥. <br></blockquote><br>  Porque, no caso de algo, por exemplo, um erro fatal ou um bug muito s√©rio na produ√ß√£o, voc√™ precisa lidar com a coragem e pode se perder por a√≠ - onde, o que e como.  Se voc√™, por exemplo, escreve testes ou usa o Headless Chrome, tamb√©m pode encontrar alguns de seus comportamentos e erros estranhos.  Portanto, explicarei brevemente o que o Chromium possui componentes.  Quando voc√™ v√™ um rastreamento de pilha grande, j√° sabe qual caminho cavar e como corrigi-lo. <br><br>  O n√≠vel mais baixo da <strong>camada Plataforma</strong> .  Seus componentes: <br><br><ul><li>  <strong>Ozone</strong> , o gerenciador de janelas abstratas do Chrome, √© o que interage com o gerenciador de janelas do sistema operacional.  No Linux, √© um servidor X ou Wayland.  No Windows, √© um gerenciador de janelas do Windows. </li><li>  <strong>O agendador</strong> √© o mesmo agendador sem o qual n√£o estamos em lugar algum, porque todos sabemos que o Chrome √© um aplicativo com v√°rios processos e precisamos resolver de alguma forma todos os threads, processos e tudo mais. </li><li>  <strong>Rede</strong> - o navegador sempre deve ter um componente para trabalhar com a rede, por exemplo, analisar HTTP, criar cabe√ßalhos, editar etc. </li></ul><br>  A <strong>camada de conte√∫do</strong> √© o maior componente que o Chrome possui.  Inclui: <br><br><ul><li>  <strong>O Blink</strong> √© um mecanismo da Web baseado no WebCore do WebKit.  Pode levar HTML como uma string, analisar, executar JavaScript - e √© isso.  Ele n√£o sabe mais fazer nada: nem trabalha com a rede nem desenha - tudo isso acontece em cima do Blink. <br>  O Blink inclui: uma vers√£o altamente modificada do WebCore - um mecanismo da web para trabalhar com HTML e CSS;  V8 (mecanismo JavaScript);  bem como uma API para todas as extens√µes que usamos no Chrome, como um bloqueador de an√∫ncios.  Ele tamb√©m inclui o protocolo DevTools. <br></li><li>  <strong>A API de conte√∫do</strong> √© uma interface com a qual voc√™ pode facilmente usar todos os recursos do mecanismo da web.  Como existem muitas coisas no Blink (provavelmente mais de um milh√£o de interfaces), para n√£o se perder em todos esses m√©todos e fun√ß√µes, voc√™ precisa de uma API de conte√∫do.  Voc√™ digita HTML, o mecanismo o processa automaticamente, analisa o DOM, cria CSS OM, executa JavaScript, executa cron√¥metros, manipuladores e tudo mais. <br></li></ul><br>  N√≠vel da <strong>camada</strong> sem cabe√ßa - n√≠vel do navegador sem cabe√ßa: <br><br><ul><li>  <strong>Biblioteca sem cabe√ßa</strong> . </li><li>  <strong>Interface da API</strong> do incorporador para incorporar a biblioteca Headless no aplicativo. </li><li>  <strong>A API do cliente</strong> √© uma interface que o Puppeteer usa. </li></ul><br>  <strong>Camada de aplica√ß√£o Camada de aplica√ß√£o</strong> : <br><br><ul><li>  Sua aplica√ß√£o ( <strong>aplicativo de incorpora√ß√£o</strong> ); </li><li>  Gadgets, por exemplo, <strong>Shell sem cabe√ßa</strong> . </li></ul><br>  Agora vamos subir das profundezas um pouco mais alto, ativar - agora o frontend ir√°. <br><br><img src="https://habrastorage.org/webt/_p/p6/10/_pp610df2doffm9nfysj-62ioea.jpeg"><br><br><h3>  Protocolo Chrome DevTools <br></h3><br>  Todos nos deparamos com o protocolo Chrome DevTools, porque usamos o painel do desenvolvedor no Chrome ou o depurador remoto - as mesmas ferramentas de desenvolvimento.  Se voc√™ executar as ferramentas do desenvolvedor remotamente, a comunica√ß√£o com o navegador ocorrer√° usando o protocolo DevTools.  Ao instalar o depurador, veja a cobertura do c√≥digo, use a localiza√ß√£o geogr√°fica ou algo mais - tudo isso √© controlado usando o DevTools. <br><br><img src="https://habrastorage.org/webt/qe/wy/2b/qewy2b3vwphvwanus0zqqnnxeq4.jpeg"><br><br>  De fato, o pr√≥prio protocolo DevTools possui um grande n√∫mero de m√©todos.  Sua ferramenta de desenvolvedor n√£o tem acesso, provavelmente a 80% deles.  Realmente, voc√™ pode fazer tudo l√°! <br><br>  Vamos ver o que √© esse protocolo.  De fato, √© muito simples.  Possui 2 componentes: <br><br><ol><li>  Destino do DevTools - a guia que voc√™ est√° inspecionando; <br></li><li>  Cliente do DevTools - digamos que este √© um painel do desenvolvedor que √© iniciado remotamente. <br></li></ol><br><img src="https://habrastorage.org/webt/-a/t8/ch/-at8chx2k1wsarzbzqhxtftflay.jpeg"><br><br>  Eles se comunicam usando JSON simples: <br><br><ul><li>  H√° um identificador para o comando, o nome do m√©todo a ser executado e alguns par√¢metros. </li><li>  Enviamos uma solicita√ß√£o e obtemos uma resposta que tamb√©m parece muito simples: um identificador necess√°rio porque todos os comandos executados usando o protocolo s√£o ass√≠ncronos.  Para podermos sempre comparar qual resposta a qual equipe recebemos, precisamos de um identificador. </li><li>  Existe um resultado.  No nosso caso, √© um objeto de resultado com os seguintes atributos: <strong>tipo:</strong> <strong>"n√∫mero",</strong> <strong>valor:</strong> <strong>2,</strong> <strong>descri√ß√£o:</strong> <strong>"2"</strong> , nenhuma exce√ß√£o foi lan√ßada: <strong>wasThrown:</strong> <strong>false.</strong> <br></li></ul><br>  Mas, entre outras coisas, sua guia pode enviar eventos de volta para voc√™.  Suponha que quando um evento em uma p√°gina ocorreu ou houve uma exce√ß√£o em uma p√°gina, voc√™ receber√° uma notifica√ß√£o atrav√©s deste protocolo. <br><br><img src="https://habrastorage.org/webt/-f/nc/8g/-fnc8gvu6h9dy5p5ovh3wf0v6ua.jpeg"><br><br><img src="https://habrastorage.org/webt/h0/tx/ud/h0txudupxhjb8brbckihbe7wzum.jpeg"><br><br><h2>  <strong>Marionetista</strong> <br></h2><br>  Voc√™ pode instalar o Puppeteer usando seu gerenciador de pacotes favorito - seja fio, npm ou qualquer outro. <br><br>  Tamb√©m √© f√°cil us√°-lo - basta solicit√°-lo no seu script Node.js. Voc√™ j√° pode us√°-lo. <br><br><img src="https://habrastorage.org/webt/pi/ia/or/piiaoriro3hvbrm_yhvd1h-scq4.jpeg"><br><br>  Usando o link <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://try-puppeteer.appspot.com,</a> voc√™ pode escrever um script diretamente no site, execut√°-lo e obter o resultado diretamente no navegador.  Tudo isso ser√° implementado usando o Chrome sem cabe√ßa. <br><br>  Considere o script mais simples em Node.js: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span>); <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">async</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch() ; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> page = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.newPage(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.goto(<span class="hljs-string"><span class="hljs-string">'http://devconf.ru/'</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.emulateMedia(<span class="hljs-string"><span class="hljs-string">'screen'</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.pdf({ <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'./devconf.pdf, printBackground: true }); await browser.close() ; })();</span></span></code> </pre> <br>  Aqui, basta abrir a p√°gina e imprimi-la em PDF.  Vamos ver a opera√ß√£o desse script em tempo real: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WPcahL2K27w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Tudo ficar√° legal, mas n√£o est√° claro o que est√° dentro.  Obviamente, temos um navegador sem cabe√ßa, mas n√£o vemos nada.  Portanto, o Puppeteer possui uma bandeira especial chamada headless: false: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch({ <span class="hljs-attr"><span class="hljs-attr">headless</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> });</code> </pre><br>  √â necess√°rio iniciar o navegador sem cabe√ßalho no modo completo, quando voc√™ pode ver alguma janela e ver o que acontece com a sua p√°gina em tempo real, ou seja, como o script interage com a sua p√°gina. <br><br><img src="https://habrastorage.org/webt/qz/oo/ie/qzooiejebek5gqaww2gw9tv0sgc.jpeg"><br><br>  Isso parecer√° o mesmo script quando adicionarmos esse sinalizador.  Uma janela do navegador aparece √† esquerda - mais claramente. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WPcahL2K27w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Profissionais do marionetista:</strong> <br><br>  + Esta √© a biblioteca Node.js. para o Chrome sem cabe√ßa. <br>  + Suporte para vers√µes herdadas do Node.js&gt; = 6. <br>  + F√°cil instala√ß√£o. <br>  + API de alto n√≠vel para gerenciar toda essa m√°quina gigante. <br><br>  O Chrome sem cabe√ßa √© instalado facilmente e sem interven√ß√£o do sistema.  Na primeira instala√ß√£o, o Puppeteer baixa a vers√£o do Chromium e a instala diretamente na pasta node_modules especificamente para sua arquitetura e sistema operacional.  Voc√™ n√£o precisa baixar nada extra, ele faz isso automaticamente.  Voc√™ tamb√©m pode usar sua vers√£o favorita do Chrome, instalada no seu sistema.  Voc√™ tamb√©m pode fazer isso - o Puppeteer fornece essa API. <br><br>  Infelizmente, tamb√©m existem desvantagens, se tomarmos apenas a instala√ß√£o b√°sica. <br><br>  <strong>Contras Titereiro</strong> : <br><br>  - <strong>Sem fun√ß√µes de n√≠vel superior</strong> : sincroniza√ß√£o de marcadores e senhas;  suporte de perfil;  acelera√ß√£o de hardware etc. <br>  - <strong>Renderiza√ß√£o de software</strong> √© o menos significativo.  Todos os c√°lculos e renderiza√ß√µes ocorrem na sua CPU.  Mas aqui, os engenheiros do Google nos surpreender√£o em breve - o trabalho de implementa√ß√£o da acelera√ß√£o de hardware j√° est√° em andamento.  Agora voc√™ pode tentar us√°-lo se for corajoso e corajoso. <br>  - At√© recentemente, n√£o havia suporte para extens√µes - agora existe!  Se voc√™ √© um desenvolvedor astuto, pode usar seu AdBlock favorito, especificar como o Puppeteer o usar√° e todos os an√∫ncios ser√£o bloqueados. <br>  - <strong>Sem suporte de √°udio / v√≠deo</strong> .  Porque, bem, por que √°udio e v√≠deo em navegadores sem cabe√ßa? <br><br>  <strong>O que pode Puppeteer:</strong> <br><br><ul><li>  Sess√µes de isolamento. </li><li>  Temporizadores virtuais. </li><li>  Intercepta√ß√£o de solicita√ß√µes de rede. </li></ul><br>  E algumas coisas legais que vou mostrar um pouco mais. <br><br><h4>  Isolamento da sess√£o <br></h4><br>  O que √©, o que √© comido e n√£o vamos sufocar?  - N√£o engasgue! <br><br>  O isolamento da sess√£o √© um <strong>"reposit√≥rio" separado para cada guia</strong> .  Ao iniciar o Puppeteer, voc√™ pode criar uma nova p√°gina e cada nova p√°gina pode ter seu pr√≥prio reposit√≥rio, incluindo: <br><br><ul><li>  cozinheiros <br></li><li>  armazenamento local; <br></li><li>  cache. <br></li></ul><br>  Todas as p√°ginas viver√£o independentemente uma da outra.  Isso √© necess√°rio, por exemplo, para manter a atomicidade dos testes. <br><br>  O isolamento da sess√£o <strong>economiza recursos e tempo ao iniciar sess√µes paralelas</strong> .  Suponha que voc√™ esteja testando um site que est√° sendo constru√≠do no modo de desenvolvimento, ou seja, o pacote configur√°vel n√£o √© minimizado e pesa 20 MB.  Se voc√™ quiser apenas armazen√°-lo em cache, pode pedir ao Puppeteer para usar um cache comum a todas as p√°ginas criadas, e esse pacote ser√° armazenado em cache. <br><br>  Voc√™ pode <strong>serializar sess√µes para uso posterior</strong> .  Voc√™ escreve um teste que verifica uma determinada a√ß√£o no seu site.  Mas voc√™ tem um problema - o site requer autoriza√ß√£o.  Voc√™ n√£o adicionar√° constantemente antes em cada teste para autoriza√ß√£o no site.  O Puppeteer permite que voc√™ fa√ßa login no site uma vez e depois reutilize esta sess√£o no futuro. <br><br><h4>  Temporizadores virtuais <br></h4><br>  Voc√™ j√° pode estar usando temporizadores virtuais.  Se voc√™ moveu o controle deslizante em uma ferramenta de desenvolvedor que acelera ou desacelera a anima√ß√£o (e lava as m√£os depois disso, √© claro!), Nesse momento voc√™ usava temporizadores virtuais no navegador. <br><br>  O navegador pode usar temporizadores virtuais em vez de reais para <strong>"rolar" o tempo a frente</strong> para acelerar o carregamento da p√°gina ou concluir a anima√ß√£o.  Suponha que voc√™ tenha o mesmo teste, v√° para a p√°gina principal e a anima√ß√£o por 30 segundos.  N√£o √© ben√©fico para algu√©m esperar o teste todo esse tempo.  Portanto, voc√™ pode simplesmente acelerar a anima√ß√£o para que ela seja conclu√≠da instantaneamente quando a p√°gina carregar, e seu teste continuar√°. <br><br>  Voc√™ pode <strong>parar o tempo enquanto a solicita√ß√£o de rede estiver em execu√ß√£o</strong> .  Por exemplo, voc√™ testa a rea√ß√£o do seu aplicativo para quando uma solicita√ß√£o enviada para o back-end demora muito tempo para ser executada ou retorna com um erro.  Voc√™ pode parar o tempo - o Puppeteer permite. <br><br>  No slide abaixo, h√° outra op√ß√£o: <strong>parar e continuar o</strong> renderizador.  No modo experimental, foi poss√≠vel dizer ao navegador para n√£o renderizar e, posteriormente, se necess√°rio, solicitar uma captura de tela.  O Chrome decapitado renderizaria tudo rapidamente, faria uma captura de tela e deixaria de desenhar qualquer coisa.  Infelizmente, os desenvolvedores j√° conseguiram alterar o princ√≠pio de funcionamento desta API e n√£o existe mais essa fun√ß√£o. <br><br>  Uma vis√£o esquem√°tica dos cron√¥metros virtuais abaixo. <br><br><img src="https://habrastorage.org/webt/dy/zm/bu/dyzmbucfttmfjlbsdkpmlk6bypq.jpeg"><br><br>  A linha superior possui dois cron√¥metros regulares: o primeiro inicia na primeira unidade de tempo e √© executado em uma unidade de tempo, o segundo come√ßa na terceira unidade de tempo e √© executado em tr√™s unidades de tempo. <br><br>  Acelerando os temporizadores - eles come√ßam um ap√≥s o outro.  Quando os pausamos, temos um per√≠odo de tempo ap√≥s o qual todos os temporizadores s√£o iniciados. <br><br>  Considere isso como um exemplo.  Abaixo est√° um trecho de c√≥digo que basicamente carrega a p√°gina de anima√ß√£o do codepen.io e aguarda: <br><br><pre> <code class="javascript hljs">(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span>() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> page = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.newPage(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">'https ://codepen.o/ajerez/full/EaEEOW/'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// # 1 await page.goto(url, { waitUnitl: 'load' }); // # 2 })();</span></span></code> </pre><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Esta</a> demonstra√ß√£o de implementa√ß√£o durante a apresenta√ß√£o √© apenas anima√ß√£o. <br><br>  Agora, usando o protocolo Chrome DevTools, enviaremos um m√©todo chamado Animation.setPlaybackRate, passaremos a playbackRate com um valor de 12 como par√¢metros: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">'https://codepen.o/ajerez/full/EaEEOW/'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// # 1 await page._client.send('Animation.setPlaybackRate', { playbackRate: 12 }); // # 3 await page.goto(url, { waitUntil: 'load' }); // # 2</span></span></code> </pre><br>  Carregamos o mesmo link e o animashka come√ßou a trabalhar muito mais r√°pido.  Isso se deve ao fato de termos usado um timer virtual e acelerado a reprodu√ß√£o da anima√ß√£o em 12 vezes. <br><br>  Vamos fazer um experimento agora - passe playbackRate: 0 - e veja o que acontece.  E aqui vai ser isso: n√£o h√° anima√ß√£o alguma, ela n√£o toca.  Valores zero e negativos simplesmente pausam toda a anima√ß√£o completamente. <br><br><h4>  Trabalhar com solicita√ß√µes de rede <br></h4><br>  Voc√™ pode <strong>interceptar solicita√ß√µes de rede</strong> , definindo o seguinte sinalizador: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.setRequestlnterception(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Nesse modo, aparece um evento adicional que √© acionado quando uma solicita√ß√£o de rede √© enviada ou recebida. <br><br>  Voc√™ pode <strong>alterar a solicita√ß√£o rapidamente</strong> .  Isso significa que voc√™ pode alterar completamente todo o seu conte√∫do (corpo) e seus cabe√ßalhos, inspecionar e at√© cancelar a solicita√ß√£o. <br><br>  Isso √© necess√°rio para <strong>processar a autoriza√ß√£o ou autentica√ß√£o</strong> , incluindo autentica√ß√£o b√°sica via HTTP. <br><br>  Voc√™ tamb√©m pode fazer a <strong>cobertura</strong> do <strong>c√≥digo (JS / CSS)</strong> .  Com o Puppeteer, voc√™ pode automatizar tudo isso.  Todos conhecemos utilit√°rios que podem carregar uma p√°gina, mostrar quais classes s√£o usadas nela, etc.  Mas estamos satisfeitos com eles?  Eu acho que n√£o. <br><br><blockquote>  O navegador sabe melhor quais seletores e classes s√£o usados ‚Äã‚Äã- √© um navegador!  Ele sempre sabe qual JavaScript foi executado, qual n√£o, qual CSS √© usado e qual n√£o. <br></blockquote><br>  O protocolo Chrome DevTools vem em socorro: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all ( [ page.coverage.startJSCoverage(), page.coverage.startCSSCoverage() ]); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.goto(<span class="hljs-string"><span class="hljs-string">'https://example.com'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [jsCoverage, cssCoverage] = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>,all([ page.coverage.stopJSCoverage(), page.coverage.stopCSSCoverage() ]):</code> </pre><br>  Nas duas primeiras linhas, lan√ßamos um recurso relativamente novo que permite descobrir a cobertura do c√≥digo.  Execute JS e CSS, v√° para alguma p√°gina e diga - pare - e podemos ver os resultados.  E esses n√£o s√£o alguns resultados imagin√°rios, mas aqueles que o navegador v√™ devido ao mecanismo. <br><br>  Entre outras coisas, j√° existe um plugin que para Puppeteer exporta tudo para Istambul. <br><br>  No topo da pir√¢mide de marionetistas, h√° um script que voc√™ escreveu no Node.js - √© como o padrinho de todos os pontos mais importantes. <br><br><img src="https://habrastorage.org/webt/gx/j6/xl/gxj6xlxcpfwiuekgcszpnijrzf8.jpeg"><br><br>  Mas ... "nem tudo est√° calmo no reino dinamarqu√™s ..." - como William Shakespeare escreveu. <br><br><h2>  <strong>O que h√° de errado com navegadores sem cabe√ßa?</strong> <br></h2><br>  Os navegadores sem cabe√ßa t√™m problemas, embora todos os seus recursos interessantes possam fazer muito. <br><br><h4>  Diferen√ßa na renderiza√ß√£o da p√°gina em diferentes plataformas <br></h4><br>  Eu realmente amo esse item e falo constantemente sobre ele.  Vamos olhar para esta foto. <br><br><img src="https://habrastorage.org/webt/62/r2/rj/62r2rjsc0ggbgpedb5lhp_tceki.jpeg"><br><br>  Aqui est√° uma p√°gina comum com texto simples: √† direita - renderiza√ß√£o no Chrome no Linux, √† esquerda - no Windows.  Aqueles que testam com capturas de tela sabem que um valor √© sempre definido, chamado de ‚Äúmargem de erro‚Äù, que determina quando a captura de tela √© considerada id√™ntica e quando n√£o. <br><br>  De fato, o problema √© que, n√£o importa como voc√™ tente definir esse limite, o erro sempre ultrapassar√° essa linha e voc√™ ainda receber√° resultados falsos positivos.  Isso se deve ao fato de que todas as p√°ginas e at√© fontes da Web s√£o renderizadas de maneira diferente nas tr√™s plataformas - no Windows de acordo com um algoritmo, no MacOS de maneira diferente, no Linux em geral, em um zool√≥gico.  <strong>Voc√™ n√£o pode simplesmente tirar e testar com capturas de tela</strong> . <br><br>  Voc√™ dir√°: "Eu s√≥ preciso de uma m√°quina de refer√™ncia onde eu execute todos esses testes e compare as capturas de tela".  Mas, na verdade, isso √© extremamente inconveniente, porque voc√™ precisa aguardar o IC e deseja verificar aqui localmente na sua m√°quina se quebrou alguma coisa.  Se voc√™ tiver capturas de tela de refer√™ncia tiradas em uma m√°quina Linux e tiver um Mac, haver√° resultados falsos. <br><br><blockquote>  Portanto, eu digo que n√£o teste com screenshots - esque√ßa. <br></blockquote><br>  A prop√≥sito, se voc√™ ainda deseja testar com capturas de tela, h√° um maravilhoso artigo de Roman Dvornov, ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teste de unidade com capturas de tela: quebrando a barreira do som</a> ‚Äù.  Isso √© pura fic√ß√£o policial. <br><br><h4>  Fechaduras <br></h4><br>  Muitos grandes provedores de conte√∫do n√£o gostam quando voc√™ raspa ou obt√©m o conte√∫do de maneira ilegal.  Imagine que eu sou um grande provedor de conte√∫do e quero jogar o mesmo jogo com voc√™.  Existem duas solicita√ß√µes GET em dois navegadores diferentes. <br><img src="https://habrastorage.org/webt/ku/ys/5e/kuys5eq81wzsqfci9kpddrd-ahm.jpeg"><br><br>  Voc√™ consegue adivinhar onde est√° o Chrome?  A op√ß√£o "both" n√£o √© aceita - o Chrome √© apenas um.  Provavelmente, voc√™ n√£o conseguir√° responder a essa pergunta e eu, como principal fornecedor de conte√∫do, posso: √† direita - PhantomJS e √† esquerda - Chrome. <br><img src="https://habrastorage.org/webt/l8/vc/lt/l8vcltt3bh-ccdysbg3azvqjxxe.jpeg"><br><br>  Posso chegar ao ponto em que detectarei seus navegadores (o que exatamente √© o Chrome ou o FireFox), correspondendo √† ordem dos cabe√ßalhos HTTP em suas solicita√ß√µes.  Se o host for o primeiro - eu sei claramente - esse √© o Chrome.  Ent√£o eu n√£o posso comparar.  Sim, √© claro, existem algoritmos mais complexos - verificamos n√£o apenas a ordem, mas tamb√©m os valores, etc.  etc.  Mas √© importante que eu possa lan√ßar seus cabe√ßalhos, verificar quem voc√™ √© e depois apenas bloquear ou n√£o. <br><br><h4>  N√£o foi poss√≠vel implementar alguns recursos (Flash) <br></h4><br>  Voc√™ j√° estudou em profundidade, diretamente hardcore, Flash em navegadores?  De alguma forma, procurei - e n√£o dormi por seis meses. <br><br>  Todos nos lembramos de como costum√°vamos assistir ao YouTube quando ainda havia o Flash: o v√≠deo est√° girando, est√° tudo bem.  Por√©m, no momento em que um objeto incorporado √© criado em uma p√°gina como o Flash, ele sempre solicita uma janela real do seu sistema operacional.  Ou seja, al√©m da janela do navegador, havia outra janela do seu sistema operacional dentro da janela do Flash do YouTube.  O Flash n√£o funciona, a menos que voc√™ forne√ßa uma janela real - n√£o apenas uma janela real, mas uma janela vis√≠vel na tela.  Portanto, algumas fun√ß√µes n√£o podem ser implementadas em navegadores sem cabe√ßa, incluindo o Flash. <br><br><h4>  Automa√ß√£o completa e bots <br></h4><br>  Como eu disse anteriormente, grandes provedores de conte√∫do t√™m muito medo quando voc√™ escreve aranhas ou pegadas que simplesmente roubam informa√ß√µes fornecidas por uma taxa. <br><br>  V√°rios truques s√£o usados.  Existem artigos sobre como ainda detectar navegadores sem cabe√ßa.  Posso dizer que <strong>voc√™ n√£o poder√° detectar navegadores sem cabe√ßa</strong> .  Todos os m√©todos descritos l√° s√£o ignorados.  Por exemplo, havia m√©todos de detec√ß√£o usando o Canvas.  Lembro que havia at√© um script que assistiu o mouse se mover pela tela e encheu a tela.  Somos pessoas e movemos o mouse lentamente, e o Headless Chrome √© muito mais r√°pido.  O script entendeu que o Canvas √© preenchido muito rapidamente - o que significa que provavelmente √© o Chrome sem cabe√ßa.  Tamb√©m contornamos isso, apenas desacelerar o navegador n√£o √© um problema. <br><br><h4>  N√£o h√° API (√∫nica) padr√£o <br></h4><br>  Se voc√™ assistiu a implementa√ß√µes decapitadas em outros navegadores - seja Safari ou FireFox -, tudo √© implementado usando a API do driver da web.  O Chrome possui o protocolo Chrome DevTools.  No Edge, nada est√° claro - o que est√° l√°, o que n√£o est√°. <br><br><h4>  WebGL? <br></h4><br>  As pessoas tamb√©m pedem o WebGL no modo sem cabe√ßa.  Este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link permite</a> acessar o rastreador de erros do Google Chrome.  L√°, os desenvolvedores est√£o votando ativamente na implementa√ß√£o do modo sem cabe√ßa para o WebGL, e ele j√° pode desenhar algo.  Agora eles s√£o simplesmente restringidos pela renderiza√ß√£o de hardware.  Assim que a implementa√ß√£o da renderiza√ß√£o do hardware for conclu√≠da, o WebGL estar√° automaticamente dispon√≠vel, ou seja, algo poder√° ser feito em segundo plano. <br><br>  Mas nem tudo √© t√£o ruim! <br><br>  Temos um segundo player no mercado - em 11 de maio de 2018, havia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">not√≠cias de</a> que a Microsoft em seu navegador Edge decidiu implementar quase o mesmo protocolo usado no Google Chrome.  Eles criaram um cons√≥rcio especialmente onde est√£o discutindo um protocolo que desejam trazer para um padr√£o do setor, para que voc√™ possa pegar seu script e execut√°-lo no Edge, Chrome e FireFox. <br><br>  Mas existe um "mas" - o Microsoft Edge n√£o possui um modo sem cabe√ßa, infelizmente.  Eles t√™m uma c√©dula de vota√ß√£o onde as pessoas escrevem: "D√™-nos um modo sem cabe√ßa!"  - mas eles est√£o calados.  Provavelmente vendo algo em segredo. <br><br><h2>  <strong>TODO (conclus√£o)</strong> <br></h2><br>  Eu contei tudo isso para que voc√™ possa procurar seu gerente ou, se voc√™ √© gerente, o desenvolvedor e dizer: ‚Äú√â isso!  <strong>N√£o queremos mais o sel√™nio - d√™-nos marionetista!</strong>  Vamos testar nele. "  Se isso acontecer, ficarei feliz. <br><br>  Mas se voc√™ puder aprender, como eu, navegadores usando o Puppeteer, postar bugs ativamente ou enviar uma solicita√ß√£o de recebimento, ficarei feliz ainda mais.  Essa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ferramenta</a> no OpenSource encontra-se no GitHub, est√° escrita no Node.js - voc√™ pode simplesmente pedir emprestado e contribuir com ele. <br><br>  O caso do Puppeteer √© √∫nico, pois existem duas equipes trabalhando no Google: uma lida especificamente com o Puppeteer, a outra com o modo sem cabe√ßa.  Se um usu√°rio encontrar um bug e escrever sobre ele no GitHub, se esse bug n√£o estiver no Puppeteer, mas no Headless Chrome, o bug ir√° para o comando Headless Chrome.  Se eles o corrigirem, o Puppeteer √© atualizado rapidamente.  Isso resulta em um √∫nico ecossistema quando a comunidade ajuda a melhorar o navegador. <br><br>  Portanto, pe√ßo que voc√™ ajude a melhorar a ferramenta, usada n√£o apenas por voc√™, mas tamb√©m por outros desenvolvedores e testadores. <br><br>  Detalhes de contato: <br><br><ul><li>  github.com/vitallium </li><li>  vk.com/vitallium </li><li>  twitter.com/vitalliumm </li></ul><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Frontend Conf Moscow</a> - uma confer√™ncia especializada de desenvolvedores front-end ser√° realizada <strong>nos dias 4 e 5 de outubro em Moscou</strong> , na Infospace.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Uma lista de</a> relat√≥rios aceitos j√° foi publicada no site da confer√™ncia. <br><br>  Em nosso boletim informativo, fazemos regularmente revis√µes tem√°ticas de discursos, conversamos sobre as transcri√ß√µes lan√ßadas e os eventos futuros - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">inscreva-se</a> para receber as not√≠cias primeiro. <br><br>  E este √© um link para o nosso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">canal do Youtube</a> no front end, cont√©m todos os discursos relacionados ao desenvolvimento da parte do cliente dos projetos. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt421137/">https://habr.com/ru/post/pt421137/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt421127/index.html">Semin√°rios on-line na Skillbox Friday: Design e Desenvolvedores</a></li>
<li><a href="../pt421129/index.html">Como reduzir a revis√£o de c√≥digo de duas semanas para v√°rias horas. A experi√™ncia da equipe Yandex.Market</a></li>
<li><a href="../pt421131/index.html">Vulnerabilidade cr√≠tica dos servidores 1Cloud</a></li>
<li><a href="../pt421133/index.html">LINKa. Teclado de papel. Bot√µes extra grandes</a></li>
<li><a href="../pt421135/index.html">Au / Ni / MgO: transfer√™ncia de calor em nanoescala</a></li>
<li><a href="../pt421139/index.html">Frontend Conf - cuidando do usu√°rio</a></li>
<li><a href="../pt421141/index.html">An√°lise de muta√ß√£o ou como testar testes</a></li>
<li><a href="../pt421143/index.html">Aurora Labs Impressora 3D mini-metal S-Titanium Pro</a></li>
<li><a href="../pt421147/index.html">Monstros ap√≥s as f√©rias: AMD Threadripper 2990WX 32-Core e 2950X 16-Core</a></li>
<li><a href="../pt421149/index.html">Algumas palavras sobre gradientes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>