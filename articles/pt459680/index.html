<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>➗ 👩🏿‍🤝‍👨🏽 🚵🏿 Seguindo o Highload ++ Siberia 2019 - 8 Oracle Tasks 🏻 💪🏼 🍺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oi 

 De 24 a 25 de junho, a conferência Highload ++ Siberia 2019 foi realizada em Novosibirsk. Nossos funcionários também estavam no relatório "Oracl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seguindo o Highload ++ Siberia 2019 - 8 Oracle Tasks</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sportmaster_lab/blog/459680/">  Oi <br><br>  De 24 a 25 de junho, a conferência Highload ++ Siberia 2019 foi realizada em Novosibirsk. Nossos funcionários também estavam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no relatório</a> "Oracle Container Bases (CDB / PDB) e seu uso prático para desenvolvimento de software", publicaremos uma versão em texto um pouco mais tarde.  Foi legal, obrigado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">olegbunin</a> pela organização, assim como a todos que vieram. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-7/k4/u1/-7k4u1btcjxquu515qeoyxnxigu.jpeg" width="350"></div><br>  Nesta postagem, gostaríamos de compartilhar com você as tarefas que estavam em nosso estande para que você possa testar seus conhecimentos no Oracle.  Sob o corte - 8 tarefas, responda às opções e explicações. <br><a name="habracut"></a><br><h3>  Qual é o valor máximo da sequência que veremos como resultado do script a seguir? </h3><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sequence</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> s.currval, s.nextval, s.currval, s.nextval, s.currval <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><ul><li>  1 </li><li>  5 </li><li>  10 </li><li>  25 </li><li>  Não, haverá um erro </li></ul><br><div class="spoiler">  <b class="spoiler_title">A resposta</b> <div class="spoiler_text">  De acordo com a documentação da Oracle (citada em 8.1.6): <br>  Dentro de uma única instrução SQL, o Oracle incrementará a sequência apenas uma vez por linha.  Se uma instrução contiver mais de uma referência ao NEXTVAL para uma sequência, o Oracle incrementará a sequência uma vez e retornará o mesmo valor para todas as ocorrências do NEXTVAL.  Se uma instrução contiver referências a CURRVAL e NEXTVAL, o Oracle incrementará a sequência e retornará o mesmo valor para CURRVAL e NEXTVAL, independentemente de sua ordem na instrução. <br><br>  Assim, o <b>valor máximo corresponderá ao número de linhas, ou seja, 5</b> . <br></div></div><br><h3>  Quantas linhas estarão na tabela como resultado do seguinte script? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t(i <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> p(p_from <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, p_to <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> p_from .. p_to <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (i); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; / exec p(1, 3); exec p(4, 6); exec p(7, 9);</code> </pre> <br><ul><li>  0 0 </li><li>  3 </li><li>  4 </li><li>  5 </li><li>  6 </li><li>  9 </li></ul><br><div class="spoiler">  <b class="spoiler_title">A resposta</b> <div class="spoiler_text">  De acordo com a documentação da Oracle (citada em 11.2): <br><br>  Antes de executar qualquer instrução SQL, o Oracle marca um ponto de salvamento implícito (não disponível para você).  Em seguida, se a instrução falhar, o Oracle reverte automaticamente e retorna o código de erro aplicável para SQLCODE no SQLCA.  Por exemplo, se uma instrução INSERT causar um erro ao tentar inserir um valor duplicado em um índice exclusivo, a instrução será revertida. <br><br>  Uma chamada do cliente também é considerada e processada como uma única declaração.  Portanto, a primeira chamada para a HP é concluída com êxito, inserindo três registros;  a segunda chamada para a HP termina com um erro e reverte o quarto registro, que eu consegui inserir;  a terceira chamada falha <b>e três entradas aparecem na tabela</b> . <br></div></div><br><h3>  Quantas linhas estarão na tabela como resultado do seguinte script? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t(i <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> i_ch <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">5</span></span>); exception when others then dbms_output.put_line('Oops!'); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; /</code> </pre> <br><ul><li>  1 </li><li>  2 </li><li>  3 </li><li>  4 </li><li>  5 </li><li>  6 </li><li>  7 </li></ul><br><div class="spoiler">  <b class="spoiler_title">A resposta</b> <div class="spoiler_text">  De acordo com a documentação da Oracle (citada em 11.2): <br><br>  Uma restrição de verificação permite especificar uma condição que cada linha da tabela deve atender.  Para satisfazer a restrição, cada linha da tabela deve tornar a condição TRUE ou desconhecida (devido a um nulo).  Quando o Oracle avalia uma condição de restrição de verificação para uma linha específica, qualquer nome de coluna na condição se refere aos valores da coluna nessa linha. <br><br>  Assim, o valor nulo passará no teste e o bloco anônimo será executado com êxito até a tentativa de inserir o valor 3. Depois disso, o bloco de processamento de erros lançará a exceção, a reversão não ocorrerá e <b>a tabela terá quatro linhas</b> com os valores 1, nulo, 2 e nulo novamente. <br></div></div><br><h3>  Quais pares de valores ocuparão a mesma quantidade de espaço no bloco? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t ( a <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), b <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), c <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), i <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>), j <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>(<span class="hljs-number"><span class="hljs-number">14</span></span>), k <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>(<span class="hljs-number"><span class="hljs-number">24</span></span>), x varchar2(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), y varchar2(<span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), z varchar2(<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t (a, b, i, j, x, y) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'Y'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>);</code> </pre><br><ul><li>  A e X </li><li>  B e Y </li><li>  C e K </li><li>  C e Z </li><li>  K e Z </li><li>  Eu e J </li><li>  J e X </li><li>  Todos listados </li></ul><br><div class="spoiler">  <b class="spoiler_title">A resposta</b> <div class="spoiler_text">  Aqui estão trechos da documentação (12.1.0.2) para armazenar vários tipos de dados no Oracle. <br><br>  <b>Tipo de dados Char</b> <br>  O tipo de dados CHAR especifica uma cadeia de caracteres de comprimento fixo no conjunto de caracteres do banco de dados.  Você especifica o conjunto de caracteres do banco de dados ao criar seu banco de dados.  O Oracle garante que todos os valores armazenados em uma coluna CHAR tenham o comprimento especificado por tamanho na semântica de comprimento selecionada.  Se você inserir um valor menor que o comprimento da coluna, o Oracle colocará em branco o valor no comprimento da coluna. <br><br>  <b>Tipo de Dados VARCHAR2</b> <br>  O tipo de dados VARCHAR2 especifica uma cadeia de caracteres de comprimento variável no conjunto de caracteres do banco de dados.  Você especifica o conjunto de caracteres do banco de dados ao criar seu banco de dados.  O Oracle armazena um valor de caractere em uma coluna VARCHAR2 exatamente como você o especifica, sem preenchimento em branco, desde que o valor não exceda o comprimento da coluna. <br><br>  <b>NUMBER Tipo de Dados</b> <br>  O tipo de dados NUMBER armazena zero e números fixos positivos e negativos com valores absolutos de 1,0 x 10-130 a mas sem incluir 1,0 x 10126. Se você especificar uma expressão aritmética cujo valor possua um valor absoluto maior ou igual a 1,0 x 10126, o Oracle retorna um erro.  Cada valor NUMBER requer de 1 a 22 bytes.  Levando isso em consideração, o tamanho da coluna em bytes para um determinado valor numérico de dados NUMBER (p), em que p é a precisão de um determinado valor, pode ser calculado usando a seguinte fórmula: <i>ROUND ((length (p) + s) / 2)) + 1</i> onde s é igual a zero se o número for positivo es s é igual a 1 se o número for negativo. <br><br>  Além disso, extraímos um trecho da documentação sobre o armazenamento de valores nulos. <br><br>  Um nulo é a ausência de um valor em uma coluna.  Nulos indicam dados ausentes, desconhecidos ou inaplicáveis.  Os nulos são armazenados no banco de dados se eles caírem entre colunas com valores de dados.  Nesses casos, eles exigem 1 byte para armazenar o comprimento da coluna (zero).  O nulo à direita em uma linha não requer armazenamento, porque um novo cabeçalho de linha sinaliza que as colunas restantes na linha anterior são nulas.  Por exemplo, se as últimas três colunas de uma tabela forem nulas, nenhum dado será armazenado para essas colunas. <br><br>  Com base nesses dados, criamos raciocínio.  Acreditamos que o banco de dados usa a codificação AL32UTF8.  Nessa codificação, as letras russas ocuparão 2 bytes. <br><br>  1) A e X, o valor do campo a 'Y' é 1 byte, o valor do campo x 'D' é 2 bytes <br>  2) B e Y, 'Vasya' no valor b será complementado com espaços de até 10 caracteres e ocupará 14 bytes, 'Vasya' em d - terá 8 bytes. <br>  3) C e K. Ambos os campos são NULL; depois deles, existem campos significativos; portanto, eles ocupam 1 byte. <br>  4) C e Z. Os dois campos são NULL, mas o campo Z é o último da tabela, portanto, não ocupa espaço (0 bytes).  O campo C ocupa 1 byte. <br>  5) K e Z. Semelhante ao caso anterior.  O valor no campo K é de 1 byte, em Z - 0. <br>  6) I e J. De acordo com a documentação, ambos os valores terão 2 bytes cada.  Consideramos o comprimento de acordo com a fórmula obtida na documentação: round ((1 + 0) / 2) +1 = 1 + 1 = 2. <br>  7) J e X. O valor no campo J terá 2 bytes, o valor no campo X terá 2 bytes. <br><br>  <b>No total, as opções corretas são: C e K, I e J, J e X.</b> <br></div></div><br><br><h3>  Qual será o fator de cluster do índice T_I aproximadamente? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t (i <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rownum</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">10000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> t_i <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(i);</code> </pre><br><ul><li>  Cerca de dezenas </li><li>  Cerca de centenas </li><li>  Da ordem dos milhares </li><li>  Da ordem de dezenas de milhares </li></ul><br><div class="spoiler">  <b class="spoiler_title">A resposta</b> <div class="spoiler_text">  De acordo com a documentação do Oracle (citada em 12.1): <br><br>  Para um índice de árvore B, o fator de cluster de índice mede o agrupamento físico de linhas em relação a um valor de índice. <br><br>  O fator de cluster de índice ajuda o otimizador a decidir se uma varredura de índice ou varredura de tabela completa é mais eficiente para determinadas consultas).  Um baixo fator de cluster indica uma verificação eficiente do índice. <br><br>  Um fator de cluster próximo ao número de blocos em uma tabela indica que as linhas estão ordenadas fisicamente nos blocos da tabela pela chave de índice.  Se o banco de dados executar uma varredura completa da tabela, o banco de dados tende a recuperar as linhas à medida que são armazenadas no disco, classificadas pela chave de índice.  Um fator de cluster próximo ao número de linhas indica que as linhas estão espalhadas aleatoriamente pelos blocos do banco de dados em relação à chave de índice.  Se o banco de dados executar uma verificação completa da tabela, o banco de dados não recuperará linhas em nenhuma ordem classificada por essa chave de índice. <br><br>  Nesse caso, os dados são classificados de maneira ideal, portanto, o fator de agrupamento será igual ou próximo ao número de blocos ocupados na tabela.  Para um tamanho de bloco padrão de 8 kilobytes, você pode esperar que cerca de mil valores de número restrito caibam em um bloco, portanto, o número de blocos e, como resultado, o fator de agrupamento será da <b>ordem de dezenas</b> . <br></div></div><br><h3>  Em que valores de N, o script a seguir será executado com êxito em um banco de dados regular com configurações padrão? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t ( a varchar2(N <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), b varchar2(N <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), c varchar2(N <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), d varchar2(N <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> t_i <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t (a, b, c, d);</code> </pre><br><ul><li>  100 </li><li>  200 </li><li>  400 </li><li>  800 </li><li>  1600 </li><li>  3200 </li><li>  6400 </li></ul><br><div class="spoiler">  <b class="spoiler_title">A resposta</b> <div class="spoiler_text">  De acordo com a documentação da Oracle (citada em 11.2): <br><br>  Limites de banco de dados lógicos <br><br><div class="scrollable-table"><table><thead><tr><td>  <strong>Item</strong> </td><td>  <strong>Tipo de limite</strong> </td><td>  <strong>Valor limite</strong> </td></tr></thead><tbody><tr><td>  Índices </td><td>  Tamanho total da coluna indexada </td><td>  75% do tamanho do bloco do banco de dados menos alguma sobrecarga </td></tr></tbody></table></div><br>  Portanto, o tamanho total das colunas indexadas não deve exceder 6 KB.  Depende ainda da base de codificação selecionada.  Para a codificação AL32UTF8, um caractere pode ocupar no máximo 4 bytes; portanto, no pior cenário, 6 kilobytes caberão cerca de 1.500 caracteres.  Portanto, a Oracle proibirá a criação de um índice em N = 400 (quando o comprimento da chave, na pior das hipóteses, for 1600 caracteres * 4 bytes + comprimento da linha), enquanto <b>em N = 200 (ou menos) a</b> criação do índice funcionará sem problemas. <br></div></div><br><h3>  A instrução INSERT com a dica APPEND foi projetada para carregar dados no modo direto.  O que acontece se for aplicado à tabela na qual o gatilho trava? </h3><br><ul><li>  Os dados serão carregados no modo direto, o gatilho funcionará como deveria </li><li>  Os dados serão carregados no modo direto, mas o gatilho não será executado </li><li>  Os dados serão carregados no modo convencional, o gatilho funcionará como deveria </li><li>  Os dados serão carregados no modo convencional, mas o gatilho não será executado </li><li>  Os dados não serão enviados, o erro será corrigido </li></ul><br><div class="spoiler">  <b class="spoiler_title">A resposta</b> <div class="spoiler_text">  Em princípio, isso é mais uma questão de lógica.  Para encontrar a resposta certa, sugiro o seguinte modelo de raciocínio: <br><br><ol><li>  A inserção no modo direto é realizada pela formação direta de um bloco de dados, além do mecanismo SQL, que garante alta velocidade.  Portanto, garantir a execução do gatilho é muito difícil, se possível, e não faz sentido, pois isso diminuirá drasticamente a inserção. </li><li>  A falha no acionamento levará ao fato de que, com os mesmos dados na tabela, o estado do banco de dados como um todo (de outras tabelas) dependerá de qual modo os dados são inseridos.  Obviamente, isso destruirá a integridade dos dados e não poderá ser aplicado como uma solução na produção. </li><li>  A incapacidade de executar a operação solicitada, em geral, é tratada como um erro.  Mas aqui deve ser lembrado que APPEND é uma dica, e a lógica geral das dicas é que elas são levadas em consideração se possível, se não, o operador é executado sem levar em conta a dica. </li></ol><br>  Portanto, a resposta esperada é que os <b>dados sejam carregados no modo normal (SQL), o gatilho será acionado.</b> <br><br>  De acordo com a documentação da Oracle (citada em 8.04): <br><br>  As violações das restrições farão com que a instrução seja executada em série, usando o caminho de inserção convencional, sem avisos ou mensagens de erro.  Uma exceção é a restrição de instruções que acessam a mesma tabela mais de uma vez em uma transação, o que pode causar mensagens de erro. <br>  Por exemplo, se gatilhos ou integridade referencial estiverem presentes na tabela, a dica APPEND será ignorada quando você tentar usar o INSERT de carregamento direto (serial ou paralelo), bem como a dica ou cláusula PARALLEL, se houver. </div></div><br><h3>  O que acontece ao executar o seguinte script? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t(i <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>, j <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">references</span></span> t); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">trigger</span></span> t_a_i <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pragma</span></span> autonomous_transaction; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (:new.i + <span class="hljs-number"><span class="hljs-number">1</span></span>, :new.i); <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; / <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>);</code> </pre><br><ul><li>  Execução bem sucedida </li><li>  Erro de sintaxe falhou </li><li>  Erro de transação offline inválido </li><li>  Erro relacionado a exceder o aninhamento máximo de chamadas </li><li>  Erro de violação de chave estrangeira </li><li>  Erro de bloqueio </li></ul><br><div class="spoiler">  <b class="spoiler_title">A resposta</b> <div class="spoiler_text">  A tabela e o gatilho foram criados corretamente e esta operação não deve causar problemas.  Também são permitidas transações autônomas no acionador, caso contrário, seria impossível, por exemplo, o log. <br><br>  Após inserir a primeira linha, um acionador bem-sucedido levaria à inserção da segunda linha, em conexão com a qual o acionador funcionaria novamente, inseriria a terceira linha e assim por diante até que a instrução caia devido a exceder o aninhamento máximo de chamadas.  No entanto, outro ponto sutil é acionado.  No momento em que o gatilho é executado, a confirmação ainda não é executada para o primeiro registro inserido.  Portanto, um gatilho que trabalha em uma transação autônoma tenta inserir uma linha na tabela que se refere por uma chave estrangeira a um registro que ainda não foi confirmado.  Isso leva a uma espera (uma transação autônoma aguarda a confirmação principal para entender se é possível inserir dados) e, ao mesmo tempo, a transação principal aguarda a confirmação autônoma continuar trabalhando após o acionador.  <b>O conflito ocorre e, como resultado, uma transação autônoma é revertida pelo motivo associado aos bloqueios</b> . <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt459680/">https://habr.com/ru/post/pt459680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt459662/index.html">O PVS-Studio queria, mas não conseguiu encontrar erros no robots.txt</a></li>
<li><a href="../pt459668/index.html">Como reconhecer texto de uma foto: novos recursos da estrutura Vision</a></li>
<li><a href="../pt459670/index.html">Goto amsterdam</a></li>
<li><a href="../pt459672/index.html">Sublinhado em Python</a></li>
<li><a href="../pt459674/index.html">Saga épica de inteligência sobre ameaças</a></li>
<li><a href="../pt459682/index.html">Qualidade dos dados em armazenamento</a></li>
<li><a href="../pt459684/index.html">Mapa do metrô de Moscou e do mundo inteiro para Android</a></li>
<li><a href="../pt459688/index.html">Urbanismo na China: menos descolados, mais ciência e TI</a></li>
<li><a href="../pt459692/index.html">Como descobrimos modificações de materiais que contradizem os princípios químicos estabelecidos</a></li>
<li><a href="../pt459694/index.html">Museum DataArt. Descompacte e inicie o Radio 86RK</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>