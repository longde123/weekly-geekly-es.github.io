<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤲🏾 👨‍🏭 💤 Go中的静态分析：如何在检查代码时节省时间 🎅🏼 👨🏻‍🏭 🚣🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha 我叫Sergey Rudachenko，我是Roistat的技术专家。 在过去的两年中，我们的团队一直在将项目的各个部分转换为Go微服务。 它们是由几个团队开发的，因此我们需要设置硬代码质量标准。 为此，我们使用了几种工具，在本文中，我们将重点介绍其中一种工具-静态分析。 


 静态分析是...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Go中的静态分析：如何在检查代码时节省时间</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/roistat/blog/413175/"><p><img src="https://habrastorage.org/webt/ax/ky/rf/axkyrfxrmccrmh-vbn83run9wpe.jpeg"></p><br><p>哈Ha 我叫Sergey Rudachenko，我是Roistat的技术专家。 在过去的两年中，我们的团队一直在将项目的各个部分转换为Go微服务。 它们是由几个团队开发的，因此我们需要设置硬代码质量标准。 为此，我们使用了几种工具，在本文中，我们将重点介绍其中一种工具-静态分析。 </p><br><p> 静态分析是使用特殊工具自动检查源代码的过程。 本文将讨论其好处，简要介绍流行的工具并提供实施说明。 如果您根本没有遇到过类似的工具或没有系统地使用它们，则值得阅读。 </p><br><p> 在有关此主题的文章中，经常会找到“ linter”一词。 对于我们来说，这是用于静态分析的简单工具的方便名称。  linter的任务是搜索简单的错误和不正确的设计。 </p><a name="habracut"></a><br><h2 id="zachem-nuzhny-lintery"> 为什么需要短绒呢？ </h2><br><p>在团队中工作时，您最有可能执行代码审查。 审查中跳过的错误是潜在的错误。 错过了未处理的<code>error</code> -不会收到提示性消息，您将盲目查找问题。 错误地进行类型转换或转换为nil map-更糟糕的是，二进制文件会因恐慌而掉线。 </p><br><p> 上面描述的错误可以添加到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代码约定中</a> ，但是在读取请求请求时查找它们并不是那么简单，因为审阅者必须读取代码。 如果您的头脑中没有编译器，那么无论如何，有些问题还是会解决。 另外，对较小错误的搜索分散了检查逻辑和体系结构的注意力。 在某种程度上，支持这样的代码将变得更加昂贵。 我们用静态类型的语言编写，奇怪的是不使用它。 </p><br><h2 id="populyarnye-instrumenty"> 热门工具 </h2><br><p> 大多数用于静态分析的工具都使用<code>go/ast</code>和<code>go/parser</code>软件包。 它们提供了解析.go文件语法的功能。 标准执行线程（例如，用于golint实用程序）如下： </p><br><ul><li> 所需软件包的文件列表已加载 </li><li> 对每个文件执行<code>parser.ParseFile(...) (*ast.File, error)</code> </li><li> 检查每个文件或包的受支持规则 </li><li> 验证通过每条指令，例如，如下所示： </li></ul><br><pre> <code class="go hljs">f, err := parser.ParseFile(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) ast.Walk(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n *ast.Node)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> v := node.(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *ast.FuncDecl: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> strings.Contains(v.Name, <span class="hljs-string"><span class="hljs-string">"_"</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(<span class="hljs-string"><span class="hljs-string">"wrong function naming"</span></span>) } } }, f)</code> </pre> <br><p> 除了AST，还有单一静态分配（SSA）。 这是解析与执行线程（而不是语法构造）一起工作的代码的更复杂的方式。 在本文中，我们不会对其进行详细考虑，您可以阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a>并查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">stackcheck</a>实用程序<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">示例</a> 。 </p><br><p> 接下来，将仅考虑对我们执行有用检查的流行实用程序。 </p><br><h3 id="gofmt">  gofmt </h3><br><p> 这是go软件包中的标准实用程序，用于检查样式匹配并可以自动对其进行修复。 遵守样式是我们的强制性要求，因此gofmt验证包含在我们的所有项目中。 </p><br><h3 id="typecheck"> 类型检查 </h3><br><p>  Typecheck检查代码中的类型匹配并支持供应商（与gotype不同）。 需要启动它才能检查编译，但不能完全保证。 </p><br><h3 id="go-vet"> 去兽医 </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Go vet</a>实用程序是标准软件包的一部分，建议Go团队使用。 检查许多常见错误，例如： </p><br><ul><li> 滥用printf和类似功能 </li><li> 错误的构建标签 </li><li> 比较功能和零 </li></ul><br><h3 id="golint">  lin </h3><br><p>  Golint由Go团队开发，并根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Effective Go</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CodeReviewComments文档</a>验证代码。 不幸的是，没有详细的文档，但是<a href="">代码显示</a>选中了以下内容： </p><br><pre> <code class="go hljs">f.lintPackageComment() f.lintImports() f.lintBlankImports() f.lintExported() f.lintNames() f.lintVarDecls() f.lintElses() f.lintRanges() f.lintErrorf() f.lintErrors() f.lintErrorStrings() f.lintReceiverNames() f.lintIncDec() f.lintErrorReturn() f.lintUnexportedReturn() f.lintTimeNames() f.lintContextKeyTypes() f.lintContextArgs()</code> </pre> <br><h3 id="staticcheck"> 静态检查 </h3><br><p> 开发人员自己将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">staticcheck</a>作为改进的兽医。 有很多检查，它们分为几组： </p><br><ul><li> 滥用标准库 </li><li> 多线程问题 </li><li> 测试问题 </li><li> 无用的代码 </li><li> 性能问题 </li><li> 可疑的设计 </li></ul><br><h3 id="gosimple">  s </h3><br><p> 它专门研究寻找值得简化的结构，例如： </p><br><p>  <strong>之前</strong> （ <a href="">golint源代码</a> ） </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f *file)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isMain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ffName.Name == <span class="hljs-string"><span class="hljs-string">"main"</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br><p>  <strong>之后</strong> </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f *file)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isMain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ffName.Name == <span class="hljs-string"><span class="hljs-string">"main"</span></span> }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">该文档</a>类似于staticcheck，并包含详细的示例。 </p><br><h3 id="errcheck"> 错误检查 </h3><br><p> 函数返回的错误不能忽略。 原因在装订文件<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Effective Go</a>中有详细描述。  Errcheck将不会跳过以下代码： </p><br><pre> <code class="go hljs">json.Unmarshal(text, &amp;val) f, _ := os.OpenFile(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>)</code> </pre> <br><h3 id="gas"> 气 </h3><br><p> 查找代码中的漏洞：硬编码访问，SQL注入和不安全哈希函数的使用。 </p><br><p> 错误示例： </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//    IP  l, err := net.Listen("tcp", ":2000") //  sql  q := fmt.Sprintf("SELECT * FROM foo where name = '%s'", name) q := "SELECT * FROM foo where name = " + name //     import "crypto/md5"</span></span></code> </pre> <br><h2 id="maligned"> 恶心的 </h2><br><p> 在Go中，结构中字段的顺序会影响内存消耗。  Maligned查找非最佳排序。 使用此字段顺序： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { a <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> }</code> </pre> <br><p> 由于在字段a和c之后添加了空位，因此该结构将在内存中占用32位。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9b9/3e3/b67/9b93e3b6777d84459548ac9247b4e76f.jpg" alt="图片"></p><br><p> 如果我们更改排序并将两个布尔字段放在一起，则该结构将仅占用24位： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ec5/557/62b/ec555762b87fc61b410675ad4fbd8ac2.jpg" alt="图片"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Stackoverflow上的原始图像</a> </p><br><h3 id="goconst">  Goconst </h3><br><p> 代码中的不可思议的变量不能反映含义并使阅读变得复杂。  Goconst查找在代码中出现2次或更多次的文字和数字。 请注意，通常即使一次使用也可能是一个错误。 </p><br><h3 id="gocyclo">  Gocyclo </h3><br><p> 我们认为代码的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">循环复杂度</a>是一个重要的指标。  Gocycle显示了每个功能的复杂性。 只能显示超过指定值的功能。 </p><br><pre> <code class="hljs pgsql">gocyclo -<span class="hljs-keyword"><span class="hljs-keyword">over</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> package/<span class="hljs-type"><span class="hljs-type">name</span></span></code> </pre> <br><p> 我们为自己选择了一个阈值7，因为我们没有找到不需要重构的复杂性更高的代码。 </p><br><h3 id="mertvyy-kod"> 死码 </h3><br><p> 有几种实用程序可用于查找未使用的代码；它们的功能可能会部分重叠。 </p><br><ul><li>  ineffassign：检查无用的分配 </li></ul><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} log.Println(res) res, err := loadData() <span class="hljs-comment"><span class="hljs-comment">//  res    return err }</span></span></code> </pre> <br><ul><li> 死代码：查找未使用的函数 </li><li> 未使用：查找未使用的函数，但比死代码更好 </li></ul><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unusedFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { formallyUsedFunc() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">formallyUsedFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { }</code> </pre> <br><p> 结果，未使用的将立即指向两个函数，而死代码仅指向未使用的功能。 因此，一次删除了多余的代码。 未使用的也会查找未使用的变量和结构字段。 </p><br><ul><li>  varcheck：查找未使用的变量 </li><li> 取消转换：查找无用的类型转换 </li></ul><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(res) <span class="hljs-comment"><span class="hljs-comment">// unconvert error</span></span></code> </pre> <br><p> 如果没有任务可以节省启动检查的时间，则最好将它们全部运行在一起。 如果需要优化，我建议使用未使用和未转换的文件。 </p><br><h2 id="kak-eto-vse-udobno-nastroit"> 配置有多方便 </h2><br><p> 依次运行上述工具很不方便：错误是以不同的格式发布的，执行需要很多时间。 检查大约8000行代码大小的我们的一项服务花费了超过两分钟的时间。 您还必须单独安装实用程序。 </p><br><p> 有聚合工具可以解决此问题，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">goreporter</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gometalinter</a> 。  Goreporter使用html呈现报告，而gometalinter写入控制台。 </p><br><p>  Gometalinter仍在某些大型项目中使用（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">docker</a> ）。 他知道如何使用单个命令安装所有实用程序，并行运行它们以及根据模板格式化错误。 上述服务的执行时间减少到一分半钟。 </p><br><p> 聚合仅通过错误文本的确切重合起作用，因此，输出中不可避免地会出现重复错误。 </p><br><p>  2018年5月， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">golangci-lint</a>项目出现在github上，在便利性上大大超越了gometalinter： </p><br><ul><li> 同一项目的执行时间减少到16秒（8次） </li><li> 几乎没有重复的错误 </li><li> 清除yaml配置 </li><li> 很好的错误输出，带有一行代码和一个指向问题的指针 <br><img src="https://habrastorage.org/webt/nu/ro/vi/nuroviwafnlgpzkyijvsucjwzme.png"></li><li> 无需安装其他实用程序 </li></ul><br><p> 现在，速度的提高是通过重用SSA和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">loader.Program来实现的</a> ，将来还计划重用AST树，这是我在“工具”部分开始时写的。 </p><br><p> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">hub.docker.com</a>上撰写本文时，没有包含文档的图像，因此我们根据对方便的想法进行了定制。 将来，配置将更改，因此对于生产环境，我们建议您用自己的配置替换。 为此，只需将.golangci.yaml文件添加到项目的根目录（golangci-lint存储库中就是<a href="">一个示例</a> ）。 </p><br><pre> <code class="bash hljs">PACKAGE=package/name docker run --rm -t \ -v $(GOPATH)/src/$(PACKAGE):/go/src/$(PACKAGE) \ -w /go/src/$(PACKAGE) \ roistat/golangci-lint</code> </pre> <br><p> 此命令可以测试整个项目。 例如，如果它在<code>~/go/src/project</code> ，则将变量的值更改为<code>PACKAGE=project</code> 。 验证在所有内部包上递归进行。 </p><br><p> 请注意，此命令仅在使用供应商时才能正确运行。 </p><br><h1 id="vnedrenie"> 实作 </h1><br><p> 我们所有的开发服务都使用docker。 任何项目都在未安装go环境的情况下运行。 要运行命令，请使用Makefile并向其中添加lint命令： </p><br><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">lint:</span></span> @docker run --rm -t -v $(GOPATH)/src/$(PACKAGE)<span class="hljs-symbol"><span class="hljs-symbol">:/go/src/</span></span>$(PACKAGE) -w /go/src/$(PACKAGE) roistat/golangci-lint</code> </pre> <br><p> 现在使用以下命令开始检查： </p><br><pre> <code class="bash hljs">make lint</code> </pre> <br><p> 有一种简单的方法可以阻止带有错误的代码进入主服务器-创建一个预接收钩子。 适用于以下情况： </p><br><ol><li> 您的项目很小，依赖项很少（或者它们在存储库中） </li><li> 等待几分钟来执行<code>git push</code>命令不是问题 </li></ol><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">挂钩</a>配置说明： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Gitlab</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Bitbucket服务器</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Github Enterprise</a> 。 </p><br><p> 在其他情况下，最好使用CI并禁止存在至少一个错误的合并代码。 我们就是这样做的，在测试之前添加了linter的启动。 </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 引入系统评价大大缩短了评审时间。 但是，另一件事更为重要：现在，我们大多数时间可以讨论全局和体系结构。 这使您可以考虑项目的开发，而不是堵塞漏洞。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN413175/">https://habr.com/ru/post/zh-CN413175/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN413165/index.html">SRTP说明</a></li>
<li><a href="../zh-CN413167/index.html">如何将Zimbra与DLP系统集成？</a></li>
<li><a href="../zh-CN413169/index.html">JavaScript中有用的数组和对象方法</a></li>
<li><a href="../zh-CN413171/index.html">托卡马克JET启动新的氘Tri运动</a></li>
<li><a href="../zh-CN413173/index.html">使用window.onerror监视JavaScript错误</a></li>
<li><a href="../zh-CN413177/index.html">6月4日至10日在莫斯科举行的数字活动</a></li>
<li><a href="../zh-CN413181/index.html">当外部函数调用比本地C调用快时</a></li>
<li><a href="../zh-CN413183/index.html">Optane DC永久性内存-DIMM格式的Optane</a></li>
<li><a href="../zh-CN413185/index.html">犯规行为或抽奖的组织者如何欺骗我们</a></li>
<li><a href="../zh-CN413187/index.html">Node.js的创建者Ryan Dahl访谈</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>