<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ˜§ ğŸ¤¸ğŸ½ ğŸ‘ğŸ¼ Tes murni dalam PHP dan PHPUnit ğŸ† ğŸ§ğŸ» ğŸ‘©ğŸ»â€ğŸ¤â€ğŸ‘¨ğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ada banyak alat dalam ekosistem PHP yang menyediakan pengujian PHP yang nyaman. Salah satu yang paling terkenal adalah PHPUnit , yang hampir merupakan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tes murni dalam PHP dan PHPUnit</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/485124/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/jx/3y/zg/jx3yzg2jnznn0kwnk6oe6ikvlzw.jpeg" width="400"></div><br>  Ada banyak alat dalam ekosistem PHP yang menyediakan pengujian PHP yang nyaman.  Salah satu yang paling terkenal adalah <a href="https://github.com/sebastianbergmann/phpunit">PHPUnit</a> , yang hampir merupakan sinonim untuk pengujian dalam bahasa ini.  Namun, tidak banyak yang ditulis tentang metode pengujian yang baik.  Ada banyak pilihan mengapa dan kapan menulis tes, tes seperti apa, dan sebagainya.  Tetapi jujur â€‹â€‹saja, <b>tidak masuk akal untuk menulis ujian jika Anda tidak bisa membacanya nanti</b> . <br><br>  Tes adalah jenis dokumentasi khusus.  Seperti yang <a href="https://thephp.website/en/issue/real-life-tdd-php/">saya tulis sebelumnya tentang TDD dalam PHP</a> , tes akan selalu (atau setidaknya harus) dengan jelas berbicara tentang apa tugas dari sepotong kode tertentu. <br><br>  Jika satu tes tidak dapat mengungkapkan ide ini, maka tes tersebut buruk. <br><br>  Saya telah menyiapkan serangkaian teknik yang akan membantu pengembang PHP menulis tes yang baik, mudah dibaca dan bermanfaat. <br><a name="habracut"></a><br><h2>  Mari kita mulai dengan dasar-dasarnya </h2><br>  Ada serangkaian teknik standar yang banyak diikuti tanpa pertanyaan.  Saya akan menyebutkan banyak dari mereka dan mencoba menjelaskan mengapa mereka dibutuhkan. <br><br><h3>  1. Tes tidak boleh mengandung operasi input-output </h3><br>  <b>Alasan utama</b> : operasi I / O lambat dan tidak dapat diandalkan. <br><br>  <b>Lambat</b> : walaupun Anda memiliki perangkat keras terbaik di dunia, I / O masih akan lebih lambat daripada akses memori.  Tes harus selalu bekerja cepat, jika tidak orang akan menjalankannya terlalu jarang. <br><br>  <b>Tidak dapat diandalkan</b> : beberapa file, binari, soket, folder, dan catatan DNS mungkin tidak tersedia di beberapa mesin yang Anda uji.  Semakin Anda mengandalkan pengujian untuk I / O, semakin banyak tes Anda terkait dengan infrastruktur. <br><br>  Apa yang terkait dengan operasi I / O: <br><br><ul><li>  Membaca dan menulis file. <br></li><li>  Panggilan jaringan. <br></li><li> Panggilan ke proses eksternal (menggunakan <code>exec</code> , <code>proc_open</code> , dll.). <br></li></ul><br>  Ada situasi ketika kehadiran operasi input-output memungkinkan Anda untuk menulis tes lebih cepat.  Tapi hati-hati: periksa apakah operasi seperti itu bekerja pada mesin Anda untuk pengembangan, perakitan dan penyebaran, jika tidak, Anda mungkin memiliki masalah serius. <br><br>  Mengisolasi tes sehingga mereka tidak membutuhkan operasi I / O: Saya telah memberikan solusi arsitektur di bawah ini yang mencegah tes dari melakukan operasi I / O dengan berbagi tanggung jawab antara antarmuka. <br><br>  Contoh: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPeople</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ $rawPeople = file_get_contents( <span class="hljs-string"><span class="hljs-string">'people.json'</span></span> ) ?? <span class="hljs-string"><span class="hljs-string">'[]'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json_decode( $rawPeople, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ); }</code> </pre><br>  Ketika Anda mulai menguji menggunakan metode ini, file lokal akan dibuat, dan dari waktu ke waktu snapshot akan dibuat: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testGetPeopleReturnsPeopleList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ $people = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;peopleService -&gt;getPeople(); <span class="hljs-comment"><span class="hljs-comment">// assert it contains people }</span></span></code> </pre> <br>  Untuk melakukan ini, kita perlu mengkonfigurasi prasyarat untuk menjalankan tes.  Sepintas, semuanya terlihat masuk akal, tetapi kenyataannya mengerikan. <br><br>  Melewati tes karena fakta bahwa prasyarat tidak terpenuhi tidak menjamin kualitas perangkat lunak kami.  Ini hanya akan menyembunyikan bug! <br><br>  <b>Kami memperbaiki situasi</b> : kami mengisolasi operasi I / O dengan mengalihkan tanggung jawab ke antarmuka. <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// extract the fetching // logic to a specialized // interface interface PeopleProvider { public function getPeople(): array; } // create a concrete implementation class JsonFilePeopleProvider implements PeopleProvider { private const PEOPLE_JSON = 'people.json'; public function getPeople(): array { $rawPeople = file_get_contents( self::PEOPLE_JSON ) ?? '[]'; return json_decode( $rawPeople, true ); } } class PeopleService { // inject via __construct() private PeopleProvider $peopleProvider; public function getPeople(): array { return $this-&gt;peopleProvider -&gt;getPeople(); } }</span></span></code> </pre> <br>  Sekarang saya tahu bahwa <code>JsonFilePeopleProvider</code> akan menggunakan I / O dalam hal apa pun. <br><br>  Alih-alih <code>file_get_contents()</code> Anda dapat menggunakan lapisan abstraksi seperti <a href="https://flysystem.thephpleague.com/docs/adapter/local/">sistem file Flysystem</a> , yang dengan mudah membuat stubs. <br><br>  Lalu mengapa kita membutuhkan <code>PeopleService</code> ?  Pertanyaan yang bagus  Untuk ini, tes diperlukan: untuk menantang arsitektur dan menghapus kode yang tidak berguna. <br><br><h3>  2. Tes harus sadar dan bermakna. </h3><br>  <b>Alasan utama</b> : tes adalah bentuk dokumentasi.  Jaga agar jelas, ringkas, dan mudah dibaca. <br><br>  <b>Kejelasan dan singkatnya</b> : tidak berantakan, tidak ada ribuan baris bertopik, tidak ada urutan pernyataan. <br><br>  <b>Keterbacaan</b> : Tes harus menceritakan sebuah kisah.  Struktur "diberikan, kapan, lalu" sangat bagus untuk ini. <br><br>  Karakteristik tes yang baik dan mudah dibaca: <br><br><ul><li>  Berisi hanya panggilan yang diperlukan ke metode <code>assert</code> (lebih disukai satu). <br></li><li>  Dia dengan sangat jelas menjelaskan apa yang harus terjadi dalam kondisi tertentu. <br></li><li>  Ini menguji hanya satu cabang dari eksekusi metode. <br></li><li>  Dia tidak membuat rintisan untuk seluruh alam semesta demi pernyataan apa pun. <br></li></ul><br>  Penting untuk dicatat bahwa jika implementasi Anda mengandung ekspresi bersyarat, operator transisi, atau loop, maka semuanya harus secara eksplisit dicakup oleh pengujian.  Misalnya, agar jawaban awal selalu berisi tes. <br><br>  Saya ulangi: ini bukan masalah cakupan, tetapi dokumentasi. <br><br>  Berikut ini adalah contoh dari tes yang membingungkan: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCanFly</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ $noWings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertEquals( <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, $noWings-&gt;canFly() ); $singleWing = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertTrue( !$singleWing-&gt;canFly() ); $twoWings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertTrue( $twoWings-&gt;canFly() ); }</code> </pre> <br>  Mari kita adaptasi format "diberikan kapan, lalu" dan lihat apa yang terjadi: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCanFly</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Given $person = $this-&gt;givenAPersonHasNoWings(); // Then $this-&gt;assertEquals( false, $person-&gt;canFly() ); // Further cases... } private function givenAPersonHasNoWings(): Person { return new Person(0); }</span></span></code> </pre> <br>  Seperti bagian "Diberi", "kapan" dan "kemudian" dapat ditransfer ke metode pribadi.  Ini akan membuat tes Anda lebih mudah dibaca. <br><br>  <code>assertEquals</code> berantakan tidak berguna.  Orang yang membaca ini harus melacak pernyataan untuk memahami apa artinya. <br><br>  Menggunakan pernyataan spesifik akan membuat tes Anda lebih mudah dibaca.  <code>assertTrue()</code> harus menerima variabel Boolean, bukan ekspresi seperti <code>canFly() !== true</code> . <br><br>  Pada contoh sebelumnya, kami mengganti <code>assertEquals</code> antara <code>false</code> dan <code>$person-&gt;canFly()</code> dengan <code>assertFalse</code> sederhana: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// ... $person = $this-&gt;givenAPersonHasNoWings(); $this-&gt;assertFalse( $person-&gt;canFly() ); // Further cases...</span></span></code> </pre> <br>  Sekarang semuanya sangat jelas!  Jika seseorang tidak memiliki sayap, dia pasti tidak bisa terbang!  Baca seperti puisi <br><br>  Sekarang bagian "Kasus selanjutnya", yang muncul dua kali dalam teks kami, merupakan indikasi yang jelas bahwa tes membuat terlalu banyak pernyataan.  Metode <code>testCanFly()</code> sama sekali tidak berguna. <br><br>  Mari kita tingkatkan tes lagi: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCanFlyIsFalsyWhenPersonHasNoWings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ $person = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;givenAPersonHasNoWings(); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertFalse( $person-&gt;canFly() ); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCanFlyIsTruthyWhenPersonHasTwoWings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ $person = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;givenAPersonHasTwoWings(); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertTrue( $person-&gt;canFly() ); } <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre> <br>  Kami bahkan dapat mengganti nama metode pengujian sehingga cocok dengan skenario nyata, misalnya, di <code>testPersonCantFlyWithoutWings</code> , tetapi semuanya <code>testPersonCantFlyWithoutWings</code> cocok untuk saya. <br><br><h3>  3. Tes tidak harus tergantung pada tes lain </h3><br>  <b>Alasan utama</b> : tes harus berjalan dan berjalan dengan sukses dalam urutan apa pun. <br><br>  Saya tidak melihat alasan yang cukup untuk membuat interkoneksi antar tes.  Baru-baru ini saya diminta untuk melakukan tes fungsi login, saya akan memberikannya di sini sebagai contoh yang baik. <br><br>  Tes harus: <br><br><ul><li>  Hasilkan token JWT untuk masuk. <br></li><li>  Jalankan fungsi login. <br></li><li>  Menyetujui perubahan status. <br></li></ul><br>  Seperti ini: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testGenerateJWTToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... $token $this-&gt;token = $token; } // @depends testGenerateJWTToken public function testExecuteAnAmazingFeature(): void { // Execute using $this-&gt;token } // @depends testExecuteAnAmazingFeature public function testStateIsBlah(): void { // Poll for state changes on // Logged-in interface }</span></span></code> </pre> <br>  Ini buruk karena beberapa alasan: <br><br><ul><li>  PHPUnit tidak dapat menjamin urutan eksekusi ini. <br></li><li>  Tes harus dapat berjalan secara independen. <br></li><li>  Tes paralel mungkin gagal secara acak. <br></li></ul><br>  Cara termudah untuk menyiasatinya adalah dengan menggunakan skema yang diberikan, kapan, kemudian.  Jadi tes akan lebih bijaksana, mereka akan bercerita, jelas menunjukkan ketergantungan mereka, menjelaskan fungsi yang sedang diuji. <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testAmazingFeatureChangesState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Given $token = $this-&gt;givenImAuthenticated(); // When $this-&gt;whenIExecuteMyAmazingFeature( $token ); $newState = $this-&gt;pollStateFromInterface( $token ); // Then $this-&gt;assertEquals( 'my-state', $newState ); }</span></span></code> </pre> <br>  Kami juga perlu menambahkan tes untuk otentikasi, dll. Struktur ini sangat bagus sehingga <a href="https://behat.org/en/latest/quick_start.html">Behat digunakan secara default</a> . <br><br><h3>  4. Selalu menerapkan dependensi </h3><br>  <b>Alasan utama</b> : nada yang sangat buruk - untuk membuat rintisan bagi negara global.  Ketidakmampuan untuk membuat stubs untuk dependensi tidak memungkinkan pengujian fungsi. <br><br>  Petunjuk Bermanfaat: <b>Lupakan kelas statis stateful dan instance tunggal</b> .  Jika kelas Anda bergantung pada sesuatu, maka buatlah agar itu dapat diimplementasikan. <br><br>  Ini adalah contoh yang menyedihkan: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeatureToggle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isActive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Id $feature )</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{ $cookieName = $feature-&gt;getCookieName(); <span class="hljs-comment"><span class="hljs-comment">// Early return if cookie // override is present if (Cookies::exists( $cookieName )) { return Cookies::get( $cookieName ); } // Evaluate feature toggle... } }</span></span></code> </pre> <br>  Bagaimana saya bisa menguji jawaban awal ini? <br><br>  Benar juga.  Tidak mungkin. <br><br>  Untuk mengujinya, kita perlu memahami perilaku kelas <code>Cookies</code> dan memastikan bahwa kita dapat mereproduksi semua lingkungan yang terkait dengannya, menghasilkan jawaban tertentu. <br><br>  Jangan lakukan ini. <br><br>  Situasi dapat diperbaiki jika Anda menerapkan instance dari <code>Cookies</code> sebagai ketergantungan.  Tes akan terlihat seperti ini: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// Test class... private Cookies $cookieMock; private FeatureToggle $service; // Preparing our service and dependencies public function setUp(): void { $this-&gt;cookieMock = $this-&gt;prophesize( Cookies::class ); $this-&gt;service = new FeatureToggle( $this-&gt;cookieMock-&gt;reveal() ); } public function testIsActiveIsOverriddenByCookies(): void { // Given $feature = $this-&gt;givenFeatureXExists(); // When $this-&gt;whenCookieOverridesFeatureWithTrue( $feature ); // Then $this-&gt;assertTrue( $this-&gt;service-&gt;isActive($feature) ); // additionally we can assert // no other methods were called } private function givenFeatureXExists(): Id { // ... return $feature; } private function whenCookieOverridesFeatureWithTrue( Id $feature ): void { $cookieName = $feature-&gt;getCookieName(); $this-&gt;cookieMock-&gt;exists($cookieName) -&gt;shouldBeCalledOnce() -&gt;willReturn(true); $this-&gt;cookieMock-&gt;get($cookieName) -&gt;shouldBeCalledOnce() -&gt;willReturn(true); }</span></span></code> </pre> <br>  Hal yang sama berlaku untuk lajang.  Jadi, jika Anda ingin membuat objek menjadi unik, konfigurasikan dengan benar injector dependensi Anda, daripada menggunakan pola (anti) tunggal.  Jika tidak, Anda akan menulis metode yang hanya berguna untuk kasus seperti <code>reset()</code> atau <code>setInstance()</code> .  Menurut saya, ini gila. <br><br>  Sangat normal untuk mengubah arsitektur untuk membuat pengujian lebih mudah!  Dan menciptakan metode untuk memfasilitasi pengujian tidak normal. <br><br><h3>  5. Jangan Pernah Menguji Metode yang Dilindungi / Privat </h3><br>  <b>Alasan utama</b> : mereka mempengaruhi cara kita menguji fungsi dengan menentukan tanda tangan perilaku: dalam kondisi seperti itu, ketika saya memasuki A, saya berharap untuk mendapatkan B. <b>Metode pribadi / dilindungi bukan bagian dari tanda tangan fungsi</b> . <br><br>  Saya bahkan tidak ingin menunjukkan cara untuk "menguji" metode pribadi, tetapi saya akan memberikan petunjuk: Anda hanya dapat melakukan ini menggunakan API <a href="https://www.php.net/manual/en/book.reflection.php">refleksi</a> . <br><br>  Selalu menghukum diri Anda entah bagaimana ketika Anda berpikir tentang menggunakan refleksi untuk menguji metode pribadi!  Pengembang buruk, buruk! <br><br>  Menurut definisi, metode pribadi hanya disebut secara internal.  Artinya, mereka tidak tersedia untuk umum.  Ini berarti bahwa hanya metode publik dari kelas yang sama yang dapat memanggil metode tersebut. <br><br>  <b>Jika Anda menguji semua metode publik Anda, maka Anda juga menguji semua metode pribadi / dilindungi</b> .  Jika ini bukan masalahnya, maka bebaskan metode privat / terlindungi, toh tidak ada yang menggunakannya. <br><br><h2>  Kiat lanjutan </h2><br>  Saya harap kamu belum bosan.  Tetap saja, saya harus berbicara tentang dasar-dasarnya.  Sekarang saya akan membagikan pendapat saya tentang penulisan tes bersih dan keputusan yang memengaruhi proses pengembangan saya. <br><br>  Hal terpenting yang tidak saya lupakan saat menulis tes: <br><br><ul><li>  Belajar. <br></li><li>  Umpan balik cepat. <br></li><li>  Dokumentasi <br></li><li>  Refactoring <br></li><li>  Desain selama pengujian. <br></li></ul><br><h3>  1. Tes di awal, bukan di akhir </h3><br>  <b>Nilai</b> : belajar, umpan balik cepat, dokumentasi, refactoring, desain selama pengujian. <br><br>  Ini adalah dasar dari segalanya.  Aspek yang paling penting, yang mencakup semua nilai yang tercantum.  Saat Anda menulis tes sebelumnya, ini membantu Anda terlebih dahulu memahami bagaimana skema "diberikan, kapan, kemudian" harus disusun.  Dengan melakukan itu, Anda pertama kali mendokumentasikan, dan, yang lebih penting, mengingat dan menetapkan persyaratan Anda sebagai aspek yang paling penting. <br><br>  Apakah aneh mendengar tentang tes menulis sebelum implementasi?  Dan bayangkan betapa anehnya menerapkan sesuatu, dan ketika menguji untuk mengetahuinya, semua ekspresi Anda "diberikan kapan, kemudian" tidak masuk akal. <br><br>  Juga, pendekatan ini akan memeriksa harapan Anda setiap dua detik.  Anda mendapatkan umpan balik secepat mungkin.  Tidak peduli seberapa besar atau kecil tampilannya. <br><br>  Tes hijau adalah area yang ideal untuk refactoring.  Gagasan utama: tidak ada tes - tidak ada refactoring.  Refactoring tanpa tes sangat berbahaya. <br><br>  Akhirnya, mengatur struktur "diberikan ketika, lalu", akan menjadi jelas bagi Anda apa antarmuka yang harus dimiliki metode Anda dan bagaimana mereka harus bersikap.  Menjaga tes tetap bersih juga akan memaksa Anda untuk terus membuat keputusan arsitektur yang berbeda.  Ini akan memaksa Anda untuk membuat pabrik, antarmuka, mengganggu warisan, dll. Dan ya, pengujian akan menjadi lebih mudah! <br><br>  Jika tes Anda adalah dokumen langsung yang menjelaskan cara kerja aplikasi, sangat penting untuk membuatnya jelas. <br><br><h3>  2. Lebih baik tanpa tes daripada dengan tes buruk </h3><br>  <b>Nilai</b> : studi, dokumentasi, refactoring. <br><br>  Banyak pengembang memikirkan tes dengan cara ini: Saya akan menulis fitur, saya akan mengarahkan kerangka pengujian sampai tes mencakup sejumlah baris baru, dan mengirimkannya ke dalam operasi. <br><br>  Menurut saya, Anda perlu lebih memperhatikan situasi ketika pengembang baru mulai bekerja dengan fitur ini.  <b>Apa yang akan tes katakan kepada orang ini?</b> <br><br>  Tes sering membingungkan jika nama tidak cukup detail.  Apa yang lebih jelas: <code>testCanFly</code> atau <code>testCanFlyReturnsFalseWhenPersonHasNoWings</code> ? <br><br>  Jika tes Anda hanya kode berantakan yang membuat kerangka mencakup lebih banyak garis, dengan contoh yang tidak masuk akal, maka sekarang saatnya untuk berhenti dan memikirkan apakah akan menulis tes ini sama sekali. <br><br>  Bahkan omong kosong seperti menetapkan <code>$a</code> dan <code>$b</code> variabel, atau menetapkan nama yang tidak terkait dengan penggunaan tertentu. <br><br>  <b>Ingat</b> : tes Anda adalah dokumen langsung yang mencoba menjelaskan bagaimana aplikasi Anda harus bersikap.  <code>assertFalse($a-&gt;canFly())</code> banyak mendokumentasikan.  Dan <code>assertFalse($personWithNoWings-&gt;canFly())</code> sudah cukup banyak. <br><br><h3>  3. Jalankan tes secara intrusi </h3><br>  <b>Nilai</b> : belajar, umpan balik cepat, refactoring. <br><br>  Sebelum Anda mulai mengerjakan fitur, jalankan tes.  Jika gagal sebelum Anda mulai berbisnis, Anda akan mengetahuinya <i>sebelum</i> Anda menulis kode, dan Anda tidak perlu menghabiskan menit-menit berharga men-debug tes yang rusak yang bahkan tidak Anda pedulikan. <br><br>  Setelah menyimpan file, jalankan tes.  Semakin cepat Anda menemukan bahwa ada sesuatu yang rusak, semakin cepat Anda memperbaikinya dan melanjutkan.  Jika gangguan alur kerja untuk menyelesaikan masalah tampaknya tidak produktif bagi Anda, bayangkan bahwa nanti Anda harus kembali banyak langkah jika Anda tidak tahu tentang masalah tersebut. <br><br>  Setelah mengobrol dengan rekan kerja selama lima menit atau memeriksa notifikasi dari Github, jalankan tes.  Jika memerah, maka Anda tahu di mana Anda tinggalkan.  Jika tes berwarna hijau, Anda dapat terus bekerja. <br>  Setelah refactoring, bahkan nama variabel, jalankan tes. <br><br>  Serius, jalankan tes sialan itu.  Sesering Anda menekan tombol simpan. <br>  <a href="https://github.com/spatie/phpunit-watcher">Pengamat PHPUnit</a> dapat melakukan ini untuk Anda, dan bahkan mengirim pemberitahuan! <br><br><h3>  4. Tes besar - tanggung jawab besar </h3><br>  <b>Nilai</b> : belajar, refactoring, desain selama pengujian. <br><br>  Idealnya, setiap kelas harus memiliki satu tes.  Tes ini harus mencakup semua metode publik di kelas ini, serta setiap ekspresi kondisional atau operator transisi ... <br><br>  Anda dapat mengambil sesuatu seperti ini: <br><br><ul><li>  Satu kelas = satu test case. <br></li><li>  Satu metode = satu atau lebih tes. <br></li><li>  Satu cabang alternatif (jika / switch / coba-tangkap / pengecualian) = satu tes. <br></li></ul><br>  Jadi untuk kode sederhana ini Anda perlu empat tes: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// class Person public function eatSlice(Pizza $pizza): void { // test exception if ([] === $pizza-&gt;slices()) { throw new LogicException('...'); } // test exception if (true === $this-&gt;isFull()) { throw new LogicException('...'); } // test default path (slices = 1) $slices = 1; // test alternative path (slices = 2) if (true === $this-&gt;isVeryHungry()) { $slices = 2; } $pizza-&gt;removeSlices($slices); }</span></span></code> </pre> <br>  Semakin banyak metode publik yang Anda miliki, semakin banyak tes yang dibutuhkan. <br><br>  Tidak ada yang suka membaca dokumentasi panjang.  Karena tes Anda juga dokumen, ukuran kecil dan keberartiannya hanya akan meningkatkan kualitas dan kegunaannya. <br><br>  Ini juga merupakan sinyal penting bahwa kelas Anda mengumpulkan tanggung jawab dan sekarang saatnya untuk memperbaikinya dengan mentransfer sejumlah fungsi ke kelas lain, atau mendesain ulang sistem. <br><br><h3>  5. Mendukung serangkaian tes untuk menyelesaikan masalah regresi </h3><br>  <b>Nilai</b> : belajar, dokumentasi, umpan balik cepat. <br><br>  Pertimbangkan fungsinya: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $id)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">object</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fromDb((int) $id); }</code> </pre> <br>  Anda berpikir bahwa seseorang mentransmisikan "10", tetapi sebenarnya "10 pisang" sedang dikirim.  Yaitu, dua nilai datang, tetapi satu berlebihan.  Anda memiliki bug. <br><br>  Apa yang akan kamu lakukan pertama kali?  Tulis tes yang akan menandai perilaku seperti itu salah !!! <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFindByIdAcceptsOnlyNumericIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;expectException(InvalidArgumentException::class); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;expectExceptionMessage( <span class="hljs-string"><span class="hljs-string">'Only numeric IDs are allowed.'</span></span> ); findById(<span class="hljs-string"><span class="hljs-string">"10 bananas"</span></span>); }</code> </pre> <br>  Tentu saja, tes tidak mengirimkan apa pun.  Tapi sekarang Anda tahu apa yang perlu dilakukan agar mereka mengirimkan.  Perbaiki kesalahan, lakukan pengujian hijau, gunakan aplikasi dan berbahagia. <br><br>  Simpan tes ini bersamamu.  Kapan saja memungkinkan, dalam serangkaian tes yang dirancang untuk menyelesaikan masalah dengan regresi. <br><br>  Itu saja!  Umpan balik cepat, perbaikan bug, dokumentasi, kode tahan regresi dan kebahagiaan. <br><br><h2>  Kata terakhir </h2><br>  Banyak hal di atas hanyalah pendapat pribadi saya, yang dikembangkan selama karier saya.  Ini tidak berarti bahwa nasihat itu benar atau salah, itu hanya pendapat. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485124/">https://habr.com/ru/post/id485124/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485104/index.html">Membuat kunci RFID universal untuk interkom</a></li>
<li><a href="../id485108/index.html">Statistik spesialis PMI bersertifikat di Rusia pada 01/10/2020</a></li>
<li><a href="../id485110/index.html">Pengalaman saya tentang pekerjaan jarak jauh yang efektif</a></li>
<li><a href="../id485118/index.html">Clean Code oleh Robert Martin. Abstrak. Bagaimana cara menulis kode yang jelas dan indah?</a></li>
<li><a href="../id485122/index.html">Judul "Baca artikel untuk Anda." Oktober - Desember 2019</a></li>
<li><a href="../id485126/index.html">Mu-mu, pakan-pakan, dukun: evolusi komunikasi akustik</a></li>
<li><a href="../id485128/index.html">Menghemat lisensi Mikrotik CHR</a></li>
<li><a href="../id485132/index.html">Bergabung dengan Google Play Indie Games Festival</a></li>
<li><a href="../id485136/index.html">Pelacakan dan Pemantauan Istio: Layanan Mikro dan Prinsip Ketidakpastian</a></li>
<li><a href="../id485138/index.html">Pelokalan aplikasi: bagaimana kami membuat terjemahan dan pengembangan teman</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>