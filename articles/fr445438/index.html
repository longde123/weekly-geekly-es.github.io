<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😃 🦀 👩🏿‍🤝‍👨🏼 Connaissance des éléments éclairés et des composants Web basés sur celui-ci 👩🏾‍🔬 👨‍❤️‍💋‍👨 ⚗️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="À un moment donné, j'ai dû me familiariser de toute urgence avec les composants Web et trouver un moyen de les développer facilement. J'ai l'intention...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Connaissance des éléments éclairés et des composants Web basés sur celui-ci</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445438/"><p>  À un moment donné, j'ai dû me familiariser de toute urgence avec les composants Web et trouver un moyen de les développer facilement.  J'ai l'intention d'écrire une série d'articles qui <br>  organiser en quelque sorte la connaissance des composants Web, des éléments lit et donner une brève introduction à cette technologie pour les autres. <a name="habracut"></a>  Je ne suis pas un expert de cette technologie et j'accepterai volontiers tout commentaire. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lit-element</a> est un wrapper (modèle de base) pour les composants Web natifs.  Il implémente de nombreuses méthodes pratiques qui ne figurent pas dans la spécification.  En raison de sa proximité avec l'implémentation native, lit-element affiche de très bons résultats dans divers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">benchmarks par</a> rapport à d'autres approches (au 02/06/2019). </p><br><p>  Avantages que j'observe en utilisant lit-element comme classe de base de composants Web: </p><br><ol><li>  Cette technologie implémente déjà la deuxième version et «est tombée malade des maladies infantiles», qui sont propres aux instruments qui viennent d'apparaître. </li><li>  L'assemblage peut être réalisé à la fois en polymère et en webpack, dactylographié, rollup, etc., cela vous permet d'intégrer l'élément éclairé dans n'importe quel projet moderne sans aucun problème. </li><li>  L'élément lit possède un système très pratique de travail avec les propriétés en termes de saisie, de lancement et de conversion de valeurs. </li><li>  lit-element implémente presque la même logique que la réaction, c'est-à-dire  il fournit le minimum - un modèle unique pour construire des composants et son rendu et ne limite pas le développeur dans le choix d'un écosystème et de bibliothèques supplémentaires. </li></ol><br><p>  Créez un simple composant Web sur un élément lit.  Passons à la documentation.  Nous avons besoin des éléments suivants: </p><br><ol><li>  Ajouter le package npm avec l'élément lit à notre assemblage <br><br><pre><code class="plaintext hljs">npm install --save lit-element</code> </pre> </li><li>  Créez notre composant. </li></ol><br><p>  Par exemple, nous devons créer un composant Web initialisé dans la balise <code>my-component</code> .  Pour ce faire, créez le fichier js <code>my-component.js</code> et définissez son modèle de base: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//       lit-element import { } from ''; //      class MyComponent { } //      customElements.define();</span></span></code> </pre><br><p>  Tout d'abord, nous importons notre modèle de base: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { LitElement, html } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// LitElement -    ()   - // html -  lit-html,     ,  //    html   </span></span></code> </pre><br><p>  Deuxièmement, créez le composant Web lui-même à l'aide de <code>LitElement</code> </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,    //  LitElement    HTMLElement class MyComponent extends LitElement { //    LitElement   //      constructor  connectedCallback //           //    ,       // shadowDOM   {mode: 'open'} render() { return html`&lt;p&gt;Hello World!&lt;/p&gt;` } }</span></span></code> </pre><br><p>  Et la dernière chose est d'enregistrer le composant Web dans le navigateur </p><br><pre> <code class="javascript hljs">customElements.define(<span class="hljs-string"><span class="hljs-string">'my-component'</span></span>, MyComponent);</code> </pre><br><p>  En conséquence, nous obtenons ce qui suit: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { LitElement, html } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LitElement</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> html<span class="hljs-string"><span class="hljs-string">`&lt;p&gt;Hello World!&lt;/p&gt;`</span></span> } } customElements.define(<span class="hljs-string"><span class="hljs-string">'my-component'</span></span>, MyComponent);</code> </pre><br><p>  Si vous excluez la nécessité de connecter <code>my-component.js</code> au html, alors c'est tout.  Le composant le plus simple est prêt. </p><br><p>  Je propose de ne pas réinventer la roue et de prendre l'assemblage fini de l'élément-build-roll-rollup.  Suivez les instructions: </p><br><pre> <code class="plaintext hljs">git clone https://github.com/PolymerLabs/lit-element-build-rollup.git cd lit-element-build-rollup npm install npm run build npm run start</code> </pre><br><p>  Une fois toutes les commandes terminées, nous allons sur la page du navigateur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http: // localhost: 5000 /</a> . </p><br><p>  Si nous jetons un coup d'œil en html, nous verrons que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">webcomponents-loader.js</a> est devant la balise de fermeture.  Il s'agit d'un ensemble de polyfills pour les composants Web, et pour un fonctionnement multi-navigateur du composant Web, il est souhaitable que ce polyfill soit présent.  Regardons le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tableau des navigateurs</a> qui implémentent toutes les normes pour travailler avec les composants Web, il dit qu'EDGE n'implémente toujours pas complètement les normes (je ne parle pas d'IE11, qui doit toujours être pris en charge). </p><br><img src="https://habrastorage.org/webt/q1/g2/6w/q1g26wcj65en1zl0z0d4d2ar67c.png"><br><p>  Implémentation de 2 options pour ce polyfill: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">webcomponents-bundle.js</a> - cette version contient toutes les options possibles pour le polyfill, elles sont toutes lancées, mais chaque polyfill ne fonctionnera que sur la base des signes détectés. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">webcomponents-loader.js</a> est un chargeur de démarrage minimal qui, en fonction des symptômes détectés, charge les polyfills nécessaires </li></ol><br><p>  Je vous demande également de prêter attention à un autre polyfill - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">custom-elements-es5-adapter.js</a> .  Selon la spécification, seules les classes ES6 peuvent être ajoutées à customElements.define natif.  Pour de meilleures performances, le code ES6 doit être transmis uniquement aux navigateurs qui le prennent en charge, et ES5 à tout le monde.  Il n'est pas toujours possible de le faire, par conséquent, pour une meilleure compatibilité entre les navigateurs, il est recommandé de convertir tout le code ES6 en ES5.  Mais dans ce cas, les composants Web sur ES5 ne pourront pas fonctionner dans les navigateurs.  Pour résoudre ce problème, il existe custom-elements-es5-adapter.js. </p><br><p>  <code>./src/my-element.js</code> fichier <code>./src/my-element.js</code> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {html, LitElement, property} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LitElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// @property - ,    babel  ts //         //  ,   @property({type: String}) myProp = 'stuff'; render() { return html` &lt;p&gt;Hello World&lt;/p&gt; ${this.myProp} `; } } customElements.define('my-element', MyElement);</span></span></code> </pre><br><p>  Le moteur de modèle lit-html peut traiter une chaîne différemment.  Je vais vous donner plusieurs options: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  : html`&lt;div&gt;Hi&lt;/div&gt;` // : html`&lt;div&gt;${this.disabled ? 'Off' : 'On'}&lt;/div&gt;` // : html`&lt;x-foo .bar="${this.bar}"&gt;&lt;/x-foo&gt;` // : html`&lt;div class="${this.color} special"&gt;&lt;/div&gt;` //   boolean,  checked === false, //        HTML: html`&lt;input type="checkbox" ?checked=${checked}&gt;` //  : html`&lt;button @click="${this._clickHandler}"&gt;&lt;/button&gt;`</span></span></code> </pre><br><p>  Conseils pour optimiser la fonction render (): </p><br><ul><li>  ne doit pas changer l'état d'un élément, </li><li>  ne devrait pas avoir d'effets secondaires, </li><li>  ne devrait dépendre que des propriétés de l'élément, </li><li>  devrait retourner le même résultat lors de la transmission des mêmes valeurs. </li></ul><br><p>  Ne mettez pas à jour le DOM en dehors de la fonction render (). </p><br><p>  Lit-html est responsable du rendu de l'élément lit - c'est une façon déclarative de décrire comment le composant Web doit être affiché.  lit-html garantit des mises à jour rapides en ne modifiant que les parties du DOM qui doivent être modifiées. </p><br><p>  Presque tout ce code était dans un exemple simple, mais le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">décorateur</a> <code>@property</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">été</a> ajouté pour la propriété <code>myProp</code> .  Ce décorateur indique que nous attendons un attribut nommé <code>myprop</code> dans notre <code>my-element</code> .  Si aucun attribut de ce type n'est défini, la valeur de chaîne est définie sur <code>stuff</code> par défaut. </p><br><pre> <code class="html hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!--  myProp  ,       -   'stuff' --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-element</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-element</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--  myprop         lowerCamelCase .. myProp   -      'else' --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-element</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">myprop</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"else"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-element</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><p>  lit-element propose 2 façons de travailler avec une <code>property</code> : </p><br><ol><li>  Par le décorateur. </li><li>  Via un getter statique <code>properties</code> . </li></ol><br><p>  La première option permet de spécifier chaque propriété séparément: </p><br><pre> <code class="javascript hljs">@property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>}) prop1 = <span class="hljs-string"><span class="hljs-string">''</span></span>; @property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>}) prop2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; @property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>}) prop3 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; @property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>}) prop4 = []; @property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>}) prop5 = {};</code> </pre><br><p>  La seconde consiste à tout spécifier au même endroit, mais dans ce cas, si la propriété a une valeur par défaut, elle doit être écrite dans la méthode du constructeur de classe: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get properties() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">prop1</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>}, <span class="hljs-attr"><span class="hljs-attr">prop2</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>}, <span class="hljs-attr"><span class="hljs-attr">prop3</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>}, <span class="hljs-attr"><span class="hljs-attr">prop4</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>}, <span class="hljs-attr"><span class="hljs-attr">prop5</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>} }; } <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop1 = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop3 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop4 = []; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop5 = {}; }</code> </pre><br><p>  L'API pour travailler avec les propriétés dans lit-element est assez étendue: </p><br><ul><li>  <b>attribut</b> : si une propriété peut devenir un attribut observable.  S'il est <code>false</code> , l'attribut sera exclu de l'observation; aucun getter ne sera créé pour lui.  Si <code>true</code> ou l' <code>attribute</code> absent, la propriété spécifiée dans le getter au format lowerCamelCase correspondra à l'attribut au format de chaîne.  Si une chaîne est spécifiée, par exemple <code>my-prop</code> , alors elle correspondra au même nom dans les attributs. </li><li>  <b>convertisseur</b> : contient une description de la façon de convertir une valeur de / vers un attribut / propriété.  La valeur peut être une fonction qui fonctionne pour sérialiser et désérialiser la valeur, ou elle peut être un objet avec les clés <code>fromAttribute</code> et <code>toAttribute</code> , ces clés contiennent des fonctions distinctes pour convertir les valeurs.  Par défaut, la propriété contient une conversion vers les types de base <code>Boolean</code> , <code>String</code> , <code>Number</code> , <code>Object</code> et <code>Array</code> .  Les règles de conversion sont répertoriées <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </li><li>  <b>type</b> : indique l'un des types de base que cette propriété contiendra.  Il est utilisé comme «indice» pour le convertisseur sur le type que la propriété doit contenir. </li><li>  <b>refléter</b> : indique si l'attribut doit être associé à la propriété ( <code>true</code> ) et modifié selon les règles de <code>type</code> et de <code>converter</code> . </li><li>  <b>hasChanged</b> : chaque propriété l'a, contient une fonction qui détermine s'il y a un changement entre l'ancienne et la nouvelle valeur, renvoie respectivement un <code>Boolean</code> .  Si <code>true</code> , il commence à mettre à jour l'élément. </li><li>  <b>noAccessor</b> : cette propriété accepte un <code>Boolean</code> et par défaut <code>false</code> .  Il interdit la génération de getters et setters pour chaque propriété pour y accéder depuis la classe.  Cela n'annule pas la conversion. </li></ul><br><p>  Prenons un exemple hypothétique: nous allons écrire un composant Web qui contient un paramètre qui contient une chaîne, ce mot doit être dessiné à l'écran, dans lequel chaque lettre est plus grande que la précédente. <br></p><br><pre> <code class="html hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- index.html --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ladder-of-letters</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">letters</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">""</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ladder-of-letters</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//ladder-of-letters.js import {html, LitElement, property} from 'lit-element'; class LadderOfLetters extends LitElement { @property({ type: Array, converter: { fromAttribute: (val) =&gt; { // console.log('in fromAttribute', val); return val.split(''); } }, hasChanged: (value, oldValue) =&gt; { if(value === undefined || oldValue === undefined) { return false; } // console.log('in hasChanged', value, oldValue.join('')); return value !== oldValue; }, reflect: true }) letters = []; changeLetter() { this.letters = ['','','','','']; } render() { // console.log('in render', this.letters); //    ,    //        return html` &lt;div&gt;${this.letters.map((i, idx) =&gt; html`&lt;span style="font-size: ${idx + 2}em"&gt;${i}&lt;/span&gt;`)}&lt;/div&gt; // @click     ,     //   'click'    &lt;button @click=${this.changeLetter}&gt;  ''&lt;/button&gt; `; } } customElements.define('ladder-of-letters', LadderOfLetters);</span></span></code> </pre><br><p>  à la fin on obtient: </p><br><img src="https://habrastorage.org/webt/fu/jt/ka/fujtka5wih6jghe9wfdwktv8pqw.png"><br><p>  lorsque le bouton a été cliqué, la propriété a été modifiée, ce qui a provoqué la vérification en premier, puis a été envoyée pour être redessinée. </p><br><img src="https://habrastorage.org/webt/sx/wi/bs/sxwibswpdvdynof2p9adjxt2ysq.png"><br><p>  et en utilisant la <code>reflect</code> nous pouvons également voir les changements html </p><br><img src="https://habrastorage.org/webt/z1/oy/i9/z1oyi9lbcznkigdcmr7acffgsca.png"><br><p>  Si vous modifiez cet attribut avec du code en dehors de ce composant Web, nous provoquerons également un nouveau dessin du composant Web. </p><br><p>  Considérez maintenant le style du composant.  Nous avons 2 façons de styliser l'élément lit: </p><br><ol><li>  Styliser en ajoutant une balise de style à la méthode de rendu <br><br><pre> <code class="javascript hljs">render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> html<span class="hljs-string"><span class="hljs-string">` &lt;style&gt; p { color: green; } &lt;/style&gt; &lt;p&gt;Hello World&lt;/p&gt; `</span></span>; }</code> </pre><br><img src="https://habrastorage.org/webt/6r/70/ba/6r70bawofzxkhbtbx8pif2fu_au.png"><br></li><li>  Via des <code>styles</code> getter statiques <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {html, LitElement, css} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LitElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get styles() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ css<span class="hljs-string"><span class="hljs-string">` p { color: red; } `</span></span> ]; } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> html<span class="hljs-string"><span class="hljs-string">` &lt;p&gt;Hello World&lt;/p&gt; `</span></span>; } } customElements.define(<span class="hljs-string"><span class="hljs-string">'my-element'</span></span>, MyElement);</code> </pre><br></li></ol><br><p>  En conséquence, nous obtenons qu'une balise avec des styles n'est pas créée, mais est écrite ( <code>&gt;= Chrome 73</code> ) dans le <code>Shadow DOM</code> élément conformément à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">spécification</a> .  Cela améliore les performances avec un grand nombre d'éléments, car  lors de l'enregistrement d'un nouveau composant, il sait déjà quelles propriétés ses styles déterminent; elles n'ont pas besoin d'être enregistrées à chaque fois et recomptées. </p><br><img src="https://habrastorage.org/webt/tc/ew/rs/tcewrs9bnnmopzuprmi3kgapbam.png"><br><br><p>  De plus, si cette spécification n'est pas prise en charge, une balise de <code>style</code> régulière est créée dans le composant. </p><br><img src="https://habrastorage.org/webt/ah/kl/9h/ahkl9hm7c8wmkevk8fctarpkdao.png"><br><br><p>  De plus, n'oubliez pas que de cette manière, nous pouvons également séparer les styles qui seront ajoutés et calculés sur la page.  Par exemple, pour utiliser des requêtes multimédias non pas en CSS, mais en JS et implémenter uniquement le style souhaité, par exemple (c'est sauvage, mais cela doit l'être): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get styles() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mobileStyle = css<span class="hljs-string"><span class="hljs-string">`p { color: red; }`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> desktopStyle = css<span class="hljs-string"><span class="hljs-string">`p { color: green; }`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.matchMedia(<span class="hljs-string"><span class="hljs-string">"(min-width: 400px)"</span></span>).matches ? desktopStyle : mobileStyle ]; }</code> </pre><br><p>  En conséquence, nous verrons cela si l'utilisateur s'est connecté à un appareil avec une largeur d'écran de plus de 400 pixels. </p><br><img src="https://habrastorage.org/webt/k5/cu/it/k5cuitrmqpwb-76qid-1qamtpuw.png"><br><p>  Et c'est si l'utilisateur a visité le site à partir d'un appareil d'une largeur inférieure à 400 pixels. </p><br><img src="https://habrastorage.org/webt/z-/jy/jw/z-jyjw7canilafm3cmsjfuxtv6g.png"><br><p>  Mon avis: il n'y a pratiquement pas de cas adéquat lorsqu'un utilisateur, travaillant sur un appareil mobile, fait soudain face à un moniteur à part entière avec une largeur d'écran de 1920 pixels.  Ajoutez à cela le chargement paresseux des composants.  En conséquence, nous obtenons un front très optimisé avec un rendu rapide des composants.  Le seul problème est la difficulté à supporter. </p><br><p>  Maintenant, je propose de me familiariser avec les méthodes du cycle de vie de l'élément lit: </p><br><ul><li>  <b>render ()</b> : implémente une description de l'élément DOM en utilisant <code>lit-html</code> .  Idéalement, la fonction de <code>render</code> est une fonction pure qui utilise uniquement les propriétés actuelles de l'élément.  La méthode <code>render()</code> est appelée par la fonction <code>update()</code> . </li><li>  <b>shouldUpdate (changedProperties)</b> : implémenté s'il est nécessaire de contrôler la mise à jour et le rendu, lorsque les propriétés ont été modifiées ou que <code>requestUpdate()</code> appelée.  L'argument de la fonction <code>changedProperties</code> est une <code>Map</code> contenant les clés des propriétés modifiées.  Par défaut, cette méthode renvoie toujours <code>true</code> , mais la logique de la méthode peut être modifiée pour contrôler la mise à jour du composant. </li><li>  <b>performUpdate ()</b> : implémenté pour contrôler le temps de mise à jour, par exemple, pour s'intégrer au planificateur. </li><li>  <b>update (changedProperties)</b> : cette méthode appelle <code>render()</code> .  Il met également à jour les attributs d'un élément en fonction de la valeur de la propriété.  La définition des propriétés à l'intérieur de cette méthode ne provoquera pas une autre mise à jour. </li><li>  <b>firstUpdated (changedProperties)</b> : appelé après la première mise à jour de l'élément DOM immédiatement avant l'appel à <code>updated()</code> .  Cette méthode peut être utile pour capturer des liens vers des nœuds statiques visualisés avec lesquels vous devez travailler directement, par exemple, dans <code>updated()</code> . </li><li>  <b>updated (changedProperties)</b> : appelé chaque fois que le DOM d'un élément est mis à jour et affiché.  Une implémentation pour effectuer des tâches après la mise à jour via l'API DOM, par exemple, en se concentrant sur un élément. </li><li>  <b>requestUpdate (name, oldValue)</b> : appelle une demande de mise à jour asynchrone pour un élément.  Cela doit être appelé lorsque l'élément doit être mis à jour en fonction d'un état non provoqué par la définition de la propriété. </li><li>  <b>createRenderRoot ()</b> : crée par défaut une racine fantôme pour l'élément.  Si l'utilisation du Shadow DOM n'est pas nécessaire, la méthode doit renvoyer <code>this</code> . </li></ul><br><p>  Comment l'élément se met-il à jour: </p><br><ul><li>  La propriété reçoit une nouvelle valeur. </li><li>  Si la <code>hasChanged(value, oldValue)</code> renvoie <code>false</code> , l'élément n'est pas mis à jour.  Sinon, une mise à jour est planifiée en appelant <code>requestUpdate()</code> . </li><li>  <b>requestUpdate ()</b> : met à jour l'élément après la microtâche (à la fin de la boucle d'événement et avant le prochain rafraîchissement). </li><li>  <b>performUpdate ()</b> : la mise à jour est en cours et se poursuit avec le reste de l'API de mise à jour. </li><li>  <b>shouldUpdate (changedProperties)</b> : la mise à jour continue si <code>true</code> retourné. </li><li>  <b>firstUpdated (changedProperties)</b> : appelé lorsque l'élément est mis à jour pour la première fois, immédiatement avant d'appeler <code>updated()</code> . </li><li>  <b>update (changedProperties)</b> : met à jour l'élément.  La modification des propriétés dans cette méthode ne provoque pas une autre mise à jour. <br><ul><li>  <b>render ()</b> : renvoie un modèle <code>lit-html</code> pour le rendu d'un élément dans le DOM.  La modification des propriétés dans cette méthode ne provoque pas une autre mise à jour. </li></ul><br></li><li>  <b>updated (changedProperties)</b> : appelé chaque fois qu'un élément est mis à jour. </li></ul><br><p>  Pour comprendre toutes les nuances du cycle de vie des composants, je vous conseille de consulter la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> . </p><br><p>  Au travail, j'ai un projet sur Adobe Experience Manager (AEM), dans sa création, l'utilisateur peut faire glisser et déposer des composants sur la page, et selon l'idéologie AEM, ce composant contient une balise de <code>script</code> qui contient tout ce qui est nécessaire pour implémenter la logique de ce composant.  Mais en fait, cette approche a engendré de nombreuses ressources bloquantes et des difficultés avec la mise en place du front dans ce système.  Pour implémenter le front, les composants Web ont été choisis comme un moyen de ne pas modifier le rendu côté serveur (ce qu'il a très bien fait), ainsi que d'enrichir l'ancienne implémentation avec une nouvelle approche en douceur, au niveau du bit.  À mon avis, il existe plusieurs options pour implémenter le chargement des composants Web pour ce système: collecter un bundle (il peut devenir très volumineux) ou le diviser en morceaux (beaucoup de petits fichiers, un chargement dynamique est nécessaire), ou utiliser l'approche actuelle avec l'incorporation d'un script dans chaque un composant qui est rendu côté serveur (je ne veux vraiment pas y revenir).  À mon avis, la première et la troisième option ne sont pas une option.  Pour le second, vous avez besoin d'un chargeur de démarrage dynamique, comme dans le gabarit.  Mais pour l'élément éclairé dans la "boîte", cela n'est pas fourni.  Il y a eu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une tentative</a> de la part des développeurs d'éléments éclairés <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de créer un chargeur dynamique</a> , mais c'est une expérience, et il n'est pas recommandé de l'utiliser en production.  De la part des développeurs d'éléments éclairés, il y a un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">problème</a> dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le référentiel de spécifications des composants Web</a> avec une proposition d'ajouter à la spécification la possibilité de charger dynamiquement les js nécessaires pour le composant Web en fonction du balisage html sur la page.  Et, à mon avis, cet outil natif est une très bonne idée qui vous permettra de créer un point d'initialisation des composants web et de simplement l'ajouter à toutes les pages du site. </p><br><p>  Pour charger dynamiquement des composants Web d'éléments éclairés de manière dynamique avec les types PolymerLabs, un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">élément divisé a</a> été développé.  Il s'agit d'une solution expérimentale.  Cela fonctionne de la manière suivante: </p><br><ul><li>  Pour créer un SplitElement, vous écrivez deux définitions d'élément dans deux modules. </li><li>  L'un d'eux est un stub, qui définit les parties chargées d'un élément: il s'agit généralement du nom et des propriétés.  Les propriétés doivent être définies avec un stub afin que lit-element puisse générer des attributs observables en temps opportun pour appeler <code>customElements.define()</code> . </li><li>  Le stub doit également avoir une méthode de chargement asynchrone statique qui renvoie une classe d'implémentation. </li><li>  Une autre classe est "l'implémentation", qui contient tout le reste. </li><li>  Le constructeur <code>SplitElement</code> charge la classe d'implémentation et exécute <code>upgrade()</code> . </li></ul><br><p>  Exemple de talon: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {SplitElement, property} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../split-element.js'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SplitElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// MyElement    load   //      connectedCallback()   static async load() { //        //      MyElement return (await import('./my-element-impl.js')).MyElementImpl; } //      //   - @property() message: string; } customElements.define('my-element', MyElement);</span></span></code> </pre><br><p>  Exemple d'implémentation: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {MyElement} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./my-element.js'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {html} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../split-element.js'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// MyElementImpl  render    - export class MyElementImpl extends MyElement { render() { return html` &lt;h1&gt;I've been upgraded&lt;/h1&gt; My message is ${this.message}. `; } }</span></span></code> </pre><br><p>  Exemple de SplitElement sur ES6: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {LitElement, html} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    LitElement  SplitElement //       export class SplitElement extends LitElement { static load; static _resolveLoaded; static _rejectLoaded; static _loadedPromise; static implClass; static loaded() { if (!this.hasOwnProperty('_loadedPromise')) { this._loadedPromise = new Promise((resolve, reject) =&gt; { this._resolveLoaded = resolve; this._rejectLoaded = reject; }); } return this._loadedPromise; } //      - //      static _upgrade(element, klass) { SplitElement._upgradingElement = element; Object.setPrototypeOf(element, klass.prototype); new klass(); SplitElement._upgradingElement = undefined; element.requestUpdate(); if (element.isConnected) { element.connectedCallback(); } } static _upgradingElement; constructor() { if (SplitElement._upgradingElement !== undefined) { return SplitElement._upgradingElement; } super(); const ctor = this.constructor; if (ctor.hasOwnProperty('implClass')) { //   ,   ctor._upgrade(this, ctor.implClass); } else { //    if (typeof ctor.load !== 'function') { throw new Error('A SplitElement must have a static `load` method'); } (async () =&gt; { ctor.implClass = await ctor.load(); ctor._upgrade(this, ctor.implClass); })(); } } //       render() { return html``; } }</span></span></code> </pre><br><p>  Si vous utilisez toujours l'assemblage suggéré ci-dessus dans Rollup, assurez-vous de définir babel pour pouvoir gérer les importations dynamiques </p><br><pre> <code class="plaintext hljs">npm install @babel/plugin-syntax-dynamic-import</code> </pre> <br><p>  Et dans les paramètres .babelrc, ajoutez </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"plugins"</span></span>: [<span class="hljs-string"><span class="hljs-string">"@babel/plugin-syntax-dynamic-import"</span></span>] }</code> </pre><br><p>  Ici, j'ai fait un petit exemple de la mise en œuvre de composants Web avec un chargement retardé: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/malay76a/elbrus-split-litelement-web-components</a> </p><br><p>  J'ai essayé d'appliquer l'approche du chargement dynamique des composants Web, je suis arrivé à la conclusion suivante: l'outil fonctionne assez bien, vous devez collecter toutes les définitions des composants Web dans un seul fichier et connecter la description du composant lui-même via des morceaux séparément.  Sans http2, cette approche ne fonctionne pas, car  Un très grand pool de petits fichiers décrivant les composants est formé.  Sur la base du principe de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conception atomique</a> , l'importation d'atomes doit être déterminée dans le corps, mais le corps doit déjà être connecté en tant que composant distinct.  L'un des goulots d'étranglement est que l'utilisateur recevra un grand nombre de définitions d'éléments utilisateur dans le navigateur qui seront initialisées d'une manière ou d'une autre dans le navigateur et l'état initial sera déterminé.  Une telle solution est redondante.  L'une des options pour une solution simple pour le chargeur de composants est l'algorithme suivant: </p><br><ol><li>  charger les utilitaires requis, </li><li>  charger des polyfills, </li><li>  assembler des éléments personnalisés à partir de DOM léger: <br><ol><li>  tous les éléments DOM contenant un trait d'union dans le nom de la balise sont sélectionnés </li><li>  la liste est filtrée et une liste est formée des premiers éléments. </li></ol></li><li>       : <br><ol><li>    Intersection Observer, </li><li>        +- 100px      import. </li></ol></li><li><ol><li>     3       shadowDOM, </li><li>  ,   shadowDOM  ,     ,  import   JS. </li></ol><br></li></ol><br><p>      -  lit-element        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">open-wc.org</a> .        webpack  rollup,    -      storybook,          IDE. </p><br><h2>  : </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Let's Build Web Components! Part 5: LitElement</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Web Component Essentials</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">A night experimenting with Lit-HTML…</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LitElement To Do App</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LitElement app tutorial part 1: Getting started</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LitElement tutorial part 2: Templating, properties, and events</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LitElement tutorial part 3: State management with Redux</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LitElement tutorial part 4: Navigation and code splitting</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LitElement tutorial part 5: PWA and offline</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lit-html workshop</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Awesome lit-html</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr445438/">https://habr.com/ru/post/fr445438/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr445426/index.html">Optimisation pour l'application PostgreSQL servant des Rails</a></li>
<li><a href="../fr445428/index.html">Wi-Fi de haute qualité - la base de l'hospitalité moderne et le moteur des affaires</a></li>
<li><a href="../fr445432/index.html">Gestionnaire de packages Unity</a></li>
<li><a href="../fr445434/index.html">Meilleur pire travail au monde: à la recherche d'un Habraautor</a></li>
<li><a href="../fr445436/index.html">Recyclage dans DevOps - à quoi vous préparer</a></li>
<li><a href="../fr445440/index.html">Revue de code: mauvais conseils pour le contributeur et le réviseur</a></li>
<li><a href="../fr445444/index.html">Mise à jour des modules solaires haute performance de REC et Trina (solaire)</a></li>
<li><a href="../fr445446/index.html">Comment nous avons utilisé la réplication différée pour la reprise après sinistre avec PostgreSQL</a></li>
<li><a href="../fr445448/index.html">Configuration de la réception automatique des certificats Letsencrypt à l'aide de Docker sous Linux</a></li>
<li><a href="../fr445450/index.html">Extension de navigateur pour toster.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>