<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå† ‚Ü©Ô∏è ‚úãüèª Wavelet-Analyse Teil 1 üôå ‚òùüèæ üçê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Betrachten Sie die diskrete Wavelet-Transformation (DWT), die in der PyWavelets PyWavelets 1.0.3- Bibliothek implementiert ist. PyWavelet...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wavelet-Analyse Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451278/"><h3>  Einf√ºhrung </h3><br>  Betrachten Sie die diskrete Wavelet-Transformation (DWT), die in der PyWavelets <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PyWavelets 1.0.3-</a> Bibliothek implementiert ist.  PyWavelets ist eine kostenlose Open-Source-Software, die unter der MIT-Lizenz ver√∂ffentlicht wird. <br><br>  Bei der Verarbeitung von Daten auf einem Computer kann eine diskretisierte Version der kontinuierlichen Wavelet-Transformation durchgef√ºhrt werden, deren Grundlagen in meinem vorherigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel beschrieben wurden</a> .  Das Spezifizieren diskreter Werte der Parameter (a, b) von Wavelets mit einem beliebigen Schritt &amp; Dgr; a und &amp; Dgr; b erfordert jedoch eine gro√üe Anzahl von Berechnungen. <br><br>  Dar√ºber hinaus ist das Ergebnis eine √ºberm√§√üige Anzahl von Koeffizienten, die die Anzahl von Abtastwerten des urspr√ºnglichen Signals weit √ºbersteigt, was f√ºr seine Rekonstruktion nicht erforderlich ist. <br><br>  Die in der PyWavelets-Bibliothek implementierte diskrete Wavelet-Transformation (DWT) liefert gen√ºgend Informationen sowohl f√ºr die Signalanalyse als auch f√ºr ihre Synthese und ist gleichzeitig wirtschaftlich in Bezug auf die Anzahl der Operationen und den erforderlichen Speicher. <br><br><h3>  Wann wird die Wavelet-Transformation anstelle der Fourier-Transformation verwendet? </h3><br>  Die Fourier-Transformation funktioniert sehr gut, wenn das Frequenzspektrum station√§r ist.  In diesem Fall sind die im Signal vorhandenen Frequenzen unabh√§ngig von der Zeit, und das Signal enth√§lt die Frequenzen xHz, die irgendwo im Signal vorhanden sind.  Je instabil das Signal ist, desto schlechter sind die Ergebnisse.  Dies ist ein Problem, da die meisten Signale, die wir im wirklichen Leben sehen, von Natur aus instabil sind. <br><a name="habracut"></a><br>  Die Fourier-Transformation hat im Frequenzbereich eine hohe Aufl√∂sung, im Zeitbereich jedoch keine Aufl√∂sung.  Wir zeigen dies in den folgenden zwei Beispielen. <br><br><div class="spoiler">  <b class="spoiler_title">Auflistung</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> fftpack <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pylab <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>* N=<span class="hljs-number"><span class="hljs-number">100000</span></span> dt = <span class="hljs-number"><span class="hljs-number">1e-5</span></span> xa = np.linspace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, num=N) xb = np.linspace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">4</span></span>, num=N/<span class="hljs-number"><span class="hljs-number">4</span></span>) frequencies = [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">90</span></span>] y1a, y1b = np.sin(<span class="hljs-number"><span class="hljs-number">2</span></span>*np.pi*frequencies[<span class="hljs-number"><span class="hljs-number">0</span></span>]*xa), np.sin(<span class="hljs-number"><span class="hljs-number">2</span></span>*np.pi*frequencies[<span class="hljs-number"><span class="hljs-number">0</span></span>]*xb) y2a, y2b = np.sin(<span class="hljs-number"><span class="hljs-number">2</span></span>*np.pi*frequencies[<span class="hljs-number"><span class="hljs-number">1</span></span>]*xa), np.sin(<span class="hljs-number"><span class="hljs-number">2</span></span>*np.pi*frequencies[<span class="hljs-number"><span class="hljs-number">1</span></span>]*xb) y3a, y3b = np.sin(<span class="hljs-number"><span class="hljs-number">2</span></span>*np.pi*frequencies[<span class="hljs-number"><span class="hljs-number">2</span></span>]*xa), np.sin(<span class="hljs-number"><span class="hljs-number">2</span></span>*np.pi*frequencies[<span class="hljs-number"><span class="hljs-number">2</span></span>]*xb) y4a, y4b = np.sin(<span class="hljs-number"><span class="hljs-number">2</span></span>*np.pi*frequencies[<span class="hljs-number"><span class="hljs-number">3</span></span>]*xa), np.sin(<span class="hljs-number"><span class="hljs-number">2</span></span>*np.pi*frequencies[<span class="hljs-number"><span class="hljs-number">3</span></span>]*xb) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spectrum_wavelet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(y)</span></span></span><span class="hljs-function">:</span></span> Fs = <span class="hljs-number"><span class="hljs-number">1</span></span> / dt <span class="hljs-comment"><span class="hljs-comment"># sampling rate, Fs = 0,1 MHz n = len(y) # length of the signal k = np.arange(n) T = n / Fs frq = k / T # two sides frequency range frq = frq[range(n // 2)] # one side frequency range Y = fftpack.fft(y) / n # fft computing and normalization Y = Y[range(n // 2)] / max(Y[range(n // 2)]) # plotting the data subplot(2, 1, 1) plot(k/N , y, 'b') ylabel('Amplitude') grid() # plotting the spectrum subplot(2, 1, 2) plot(frq[0:140], abs(Y[0:140]), 'r') xlabel('Freq') plt.ylabel('|Y(freq)|') grid() y= y1a + y2a + y3a + y4a spectrum_wavelet(y) show()</span></span></code> </pre> </div></div><br><img src="https://habrastorage.org/webt/7e/aq/2z/7eaq2ze30fydxk5lt6zxrkaqe6c.png"><br>  In diesem Diagramm sind alle vier Frequenzen w√§hrend der gesamten Betriebszeit im Signal vorhanden. <br><br><div class="spoiler">  <b class="spoiler_title">Auflistung</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> fftpack <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pylab <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>* N=<span class="hljs-number"><span class="hljs-number">100000</span></span> dt = <span class="hljs-number"><span class="hljs-number">1e-5</span></span> xa = np.linspace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, num=N) xb = np.linspace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">4</span></span>, num=N/<span class="hljs-number"><span class="hljs-number">4</span></span>) frequencies = [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">90</span></span>] y1a, y1b = np.sin(<span class="hljs-number"><span class="hljs-number">2</span></span>*np.pi*frequencies[<span class="hljs-number"><span class="hljs-number">0</span></span>]*xa), np.sin(<span class="hljs-number"><span class="hljs-number">2</span></span>*np.pi*frequencies[<span class="hljs-number"><span class="hljs-number">0</span></span>]*xb) y2a, y2b = np.sin(<span class="hljs-number"><span class="hljs-number">2</span></span>*np.pi*frequencies[<span class="hljs-number"><span class="hljs-number">1</span></span>]*xa), np.sin(<span class="hljs-number"><span class="hljs-number">2</span></span>*np.pi*frequencies[<span class="hljs-number"><span class="hljs-number">1</span></span>]*xb) y3a, y3b = np.sin(<span class="hljs-number"><span class="hljs-number">2</span></span>*np.pi*frequencies[<span class="hljs-number"><span class="hljs-number">2</span></span>]*xa), np.sin(<span class="hljs-number"><span class="hljs-number">2</span></span>*np.pi*frequencies[<span class="hljs-number"><span class="hljs-number">2</span></span>]*xb) y4a, y4b = np.sin(<span class="hljs-number"><span class="hljs-number">2</span></span>*np.pi*frequencies[<span class="hljs-number"><span class="hljs-number">3</span></span>]*xa), np.sin(<span class="hljs-number"><span class="hljs-number">2</span></span>*np.pi*frequencies[<span class="hljs-number"><span class="hljs-number">3</span></span>]*xb) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spectrum_wavelet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(y)</span></span></span><span class="hljs-function">:</span></span> Fs = <span class="hljs-number"><span class="hljs-number">1</span></span> / dt <span class="hljs-comment"><span class="hljs-comment"># sampling rate, Fs = 0,1 MHz n = len(y) # length of the signal k = np.arange(n) T = n / Fs frq = k / T # two sides frequency range frq = frq[range(n // 2)] # one side frequency range Y = fftpack.fft(y) / n # fft computing and normalization Y = Y[range(n // 2)] / max(Y[range(n // 2)]) # plotting the data subplot(2, 1, 1) plot(k/N , y, 'b') ylabel('Amplitude') grid() # plotting the spectrum subplot(2, 1, 2) plot(frq[0:140], abs(Y[0:140]), 'r') xlabel('Freq') plt.ylabel('|Y(freq)|') grid() y = np.concatenate([y1b, y2b, y3b, y4b]) spectrum_wavelet(y) show()</span></span></code> </pre> </div></div><br><img src="https://habrastorage.org/webt/s9/xu/8x/s9xu8xjsx_kvubqfw8jldx4dhse.png"><br><br>  In diesem Diagramm √ºberlappen sich die Signale nicht zeitlich, die Nebenkeulen sind auf eine L√ºcke zwischen vier verschiedenen Frequenzen zur√ºckzuf√ºhren. <br><br>  F√ºr zwei Frequenzspektren, die genau die gleichen vier Peaks enthalten, kann die Fourier-Transformation nicht bestimmen, wo diese Frequenzen im Signal vorhanden sind.  Der beste Ansatz zur Analyse von Signalen mit einem dynamischen Frequenzspektrum ist die Wavelet-Transformation. <br><br><h3>  Die Haupteigenschaften von Wavelets </h3><br>  Die Wahl des Typs und damit der Eigenschaften des Wavelets h√§ngt von der Analyseaufgabe ab. Um beispielsweise die effektiven Str√∂me in der Elektroindustrie zu bestimmen, bieten die Wellenformen h√∂herer Ordnung von Ingrid Daubechies eine gr√∂√üere Genauigkeit.  Wavelet-Eigenschaften k√∂nnen mit der Funktion pywt.DiscreteContinuousWavelet () in der folgenden Liste erhalten werden: <br><br><div class="spoiler">  <b class="spoiler_title">Auflistung</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pywt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pylab <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * discrete_wavelets = [<span class="hljs-string"><span class="hljs-string">'db5'</span></span>, <span class="hljs-string"><span class="hljs-string">'sym5'</span></span>, <span class="hljs-string"><span class="hljs-string">'coif5'</span></span>, <span class="hljs-string"><span class="hljs-string">'haar'</span></span>] print(<span class="hljs-string"><span class="hljs-string">'discrete_wavelets-%s'</span></span>%discrete_wavelets ) st=<span class="hljs-string"><span class="hljs-string">'db20'</span></span> wavelet = pywt.DiscreteContinuousWavelet(st) print(wavelet) i=<span class="hljs-number"><span class="hljs-number">1</span></span> phi, psi, x = wavelet.wavefun(level=i) subplot(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) title(<span class="hljs-string"><span class="hljs-string">"   -  -%s"</span></span>%st) plot(x,psi,linewidth=<span class="hljs-number"><span class="hljs-number">2</span></span>, label=<span class="hljs-string"><span class="hljs-string">'level=%s'</span></span>%i) grid() legend(loc=<span class="hljs-string"><span class="hljs-string">'best'</span></span>) subplot(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) title(<span class="hljs-string"><span class="hljs-string">"  - -%s"</span></span>%st) plt.plot(x,phi,linewidth=<span class="hljs-number"><span class="hljs-number">2</span></span>, label=<span class="hljs-string"><span class="hljs-string">'level=%s'</span></span>%i) legend(loc=<span class="hljs-string"><span class="hljs-string">'best'</span></span>) grid() show()</code> </pre> </div></div><br>  Wir bekommen: <br><br>  discrete_wavelets - ['db5', 'sym5', 'coif5', 'haar'] <br><br><pre> <code class="plaintext hljs">Wavelet db20 Family name: Daubechies Short name: db Filters length: 40 Orthogonal: True Biorthogonal: True Symmetry: asymmetric DWT: True CWT: False</code> </pre> <br><img src="https://habrastorage.org/webt/vv/44/ex/vv44exv9jbfwqoocqkeoaffy-zs.png"><br><br>  In einer Reihe von praktischen F√§llen wird es notwendig, Informationen √ºber die Mittenfrequenz des psi-Wavelets zu erhalten, eine Funktion, die beispielsweise bei der Wavelet-Analyse von Signalen zur Erkennung von Defekten in Zahnr√§dern verwendet wird: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pywt f=pywt.central_frequency(<span class="hljs-string"><span class="hljs-string">'haar'</span></span>, precision=<span class="hljs-number"><span class="hljs-number">8</span></span> ) print(f) <span class="hljs-comment"><span class="hljs-comment">#  : scale=1 f1=pywt.scale2frequency('haar',scale) print(f1)</span></span></code> </pre> <br><pre> <code class="plaintext hljs">0.9961089494163424 0.9961089494163424</code> </pre> <br>  Mit der Mittenfrequenz <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>f</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>c</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.083ex" height="2.419ex" viewBox="0 -780.1 897 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/451278/&amp;usg=ALkJrhj3Sa3QuTdeeCfo2Vh3mgLBWeG15A#MJMATHI-66" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/451278/&amp;usg=ALkJrhj3Sa3QuTdeeCfo2Vh3mgLBWeG15A#MJMATHI-63" x="693" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>f</mi><mrow class="MJX-TeXAtom-ORD"><mi>c</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-1"> f_ {c} </script>  Das m√ºtterliche Wavelet und der Skalierungsfaktor ‚Äûa‚Äú k√∂nnen Skalen in Pseudofrequenzen umwandeln <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>f</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>a</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.241ex" height="2.419ex" viewBox="0 -780.1 964.9 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/451278/&amp;usg=ALkJrhj3Sa3QuTdeeCfo2Vh3mgLBWeG15A#MJMATHI-66" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/451278/&amp;usg=ALkJrhj3Sa3QuTdeeCfo2Vh3mgLBWeG15A#MJMATHI-61" x="693" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>f</mi><mrow class="MJX-TeXAtom-ORD"><mi>a</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-2"> f_ {a} </script>  unter Verwendung der Gleichung: <br><br><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>f</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>a</mi></mrow></msub><mo>=</mo><mtext>&amp;#xA0;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>f</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>c</mi></mrow></msub></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>a</mi></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="13.797ex" height="2.419ex" viewBox="0 -780.1 5940.5 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/451278/&amp;usg=ALkJrhj3Sa3QuTdeeCfo2Vh3mgLBWeG15A#MJMATHI-66" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/451278/&amp;usg=ALkJrhj3Sa3QuTdeeCfo2Vh3mgLBWeG15A#MJMATHI-61" x="693" y="-213"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/451278/&amp;usg=ALkJrhj3Sa3QuTdeeCfo2Vh3mgLBWeG15A#MJMAIN-3D" x="1242" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/451278/&amp;usg=ALkJrhj3Sa3QuTdeeCfo2Vh3mgLBWeG15A#MJMATHI-66" x="2548" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/451278/&amp;usg=ALkJrhj3Sa3QuTdeeCfo2Vh3mgLBWeG15A#MJMATHI-72" x="3099" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/451278/&amp;usg=ALkJrhj3Sa3QuTdeeCfo2Vh3mgLBWeG15A#MJMATHI-61" x="3550" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/451278/&amp;usg=ALkJrhj3Sa3QuTdeeCfo2Vh3mgLBWeG15A#MJMATHI-63" x="4080" y="0"></use><g transform="translate(4513,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/451278/&amp;usg=ALkJrhj3Sa3QuTdeeCfo2Vh3mgLBWeG15A#MJMATHI-66" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/451278/&amp;usg=ALkJrhj3Sa3QuTdeeCfo2Vh3mgLBWeG15A#MJMATHI-63" x="693" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/451278/&amp;usg=ALkJrhj3Sa3QuTdeeCfo2Vh3mgLBWeG15A#MJMATHI-61" x="5410" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>f</mi><mrow class="MJX-TeXAtom-ORD"><mi>a</mi></mrow></msub><mo>=</mo><mtext>&nbsp;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><msub><mi>f</mi><mrow class="MJX-TeXAtom-ORD"><mi>c</mi></mrow></msub></mrow><mrow class="MJX-TeXAtom-ORD"><mi>a</mi></mrow></math></span></span><script type="math/tex" id="MathJax-Element-3"> f_ {a} = \ frac {f_ {c}} {a} </script><br><br><h3>  Signalerweiterungsmodi </h3><br>  Vor der Berechnung der diskreten Wavelet-Transformation unter Verwendung von <b>Filterb√§nken</b> muss <b>das Signal verl√§ngert werden</b> .  Abh√§ngig von der Extrapolationsmethode k√∂nnen an den Signalgrenzen signifikante Artefakte auftreten, die zu Ungenauigkeiten in der DWT-Transformation f√ºhren. <br><br>  PyWavelets bietet verschiedene Signalextrapolationstechniken, mit denen dieser negative Effekt minimiert werden kann.  Verwenden Sie die folgende Auflistung, um solche Methoden zu demonstrieren: <br><br><div class="spoiler">  <b class="spoiler_title">Auflistung der Demonstration von Signalerweiterungsmethoden</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> matplotlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pywt._doc_utils <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> boundary_mode_subplot <span class="hljs-comment"><span class="hljs-comment"># synthetic test signal x = 5 - np.linspace(-1.9, 1.1, 9)**2 # Create a figure with one subplots per boundary mode fig, axes = plt.subplots(3, 3, figsize=(10, 6)) plt.subplots_adjust(hspace=0.5) axes = axes.ravel() boundary_mode_subplot(x, 'symmetric', axes[0], symw=False) boundary_mode_subplot(x, 'reflect', axes[1], symw=True) boundary_mode_subplot(x, 'periodic', axes[2], symw=False) boundary_mode_subplot(x, 'antisymmetric', axes[3], symw=False) boundary_mode_subplot(x, 'antireflect', axes[4], symw=True) boundary_mode_subplot(x, 'periodization', axes[5], symw=False) boundary_mode_subplot(x, 'smooth', axes[6], symw=False) boundary_mode_subplot(x, 'constant', axes[7], symw=False) boundary_mode_subplot(x, 'zeros', axes[8], symw=False) plt.show()</span></span></code> </pre> </div></div><br><img src="https://habrastorage.org/webt/rz/6j/r1/rz6jr1mmajwk4vhqjfupalwewtq.png"><br><br>  Die Grafiken zeigen, wie sich ein kurzes Signal (rot) (schwarz) √ºber seine urspr√ºngliche L√§nge hinaus ausdehnt. <br><br><h3>  Diskrete Wavelet-Transformation </h3><br>  Um die DWT zu demonstrieren, verwenden wir ein Signal mit einem dynamischen Frequenzspektrum, das mit der Zeit zunimmt.  Der Anfang des Signals enth√§lt niederfrequente Werte und das Ende des Signals enth√§lt Frequenzen des kurzwelligen Bereichs.  Auf diese Weise k√∂nnen wir leicht bestimmen, welcher Teil des Frequenzspektrums herausgefiltert wird, indem wir einfach auf die Zeitachse schauen: <br><br><div class="spoiler">  <b class="spoiler_title">Auflistung</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pylab <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>* x = linspace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, num=<span class="hljs-number"><span class="hljs-number">2048</span></span>) chirp_signal = sin(<span class="hljs-number"><span class="hljs-number">250</span></span> * pi * x**<span class="hljs-number"><span class="hljs-number">2</span></span>) fig, ax = subplots(figsize=(<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) ax.set_title(<span class="hljs-string"><span class="hljs-string">"     "</span></span>) ax.plot(chirp_signal) show()</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/b_/jv/pi/b_jvpixdshjjgyptmtxu779lce8.png"><br><br>  Die diskrete Wavelet-Transformation in PyWavelets 1.0.3 ist die Funktion pywt.dwt (), die die Approximationskoeffizienten cA und die detaillierten Koeffizienten cD der Wavelet-Transformation der ersten Ebene des durch den Vektor angegebenen Signals berechnet: <br><br><div class="spoiler">  <b class="spoiler_title">Transformation Level One Listing</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pywt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pylab <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * x = linspace (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, num = <span class="hljs-number"><span class="hljs-number">2048</span></span>) y = sin (<span class="hljs-number"><span class="hljs-number">250</span></span> * pi * x**<span class="hljs-number"><span class="hljs-number">2</span></span>) st=<span class="hljs-string"><span class="hljs-string">'sym5'</span></span> (cA, cD) = pywt.dwt(y,st) subplot(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) plot(cA,<span class="hljs-string"><span class="hljs-string">'b'</span></span>,linewidth=<span class="hljs-number"><span class="hljs-number">2</span></span>, label=<span class="hljs-string"><span class="hljs-string">'cA,level-1'</span></span>) grid() legend(loc=<span class="hljs-string"><span class="hljs-string">'best'</span></span>) subplot(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) plot(cD,<span class="hljs-string"><span class="hljs-string">'r'</span></span>,linewidth=<span class="hljs-number"><span class="hljs-number">2</span></span>, label=<span class="hljs-string"><span class="hljs-string">'cD,level-1'</span></span>) grid() legend(loc=<span class="hljs-string"><span class="hljs-string">'best'</span></span>) show()</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/pj/fn/qo/pjfnqopkqpdpraf0h_e_kfiu6kq.png"><br><br><div class="spoiler">  <b class="spoiler_title">Transformation Level 5 Listing</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pywt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pylab <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * x = linspace (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, num = <span class="hljs-number"><span class="hljs-number">2048</span></span>) y = sin (<span class="hljs-number"><span class="hljs-number">250</span></span> * pi * x**<span class="hljs-number"><span class="hljs-number">2</span></span>) st=<span class="hljs-string"><span class="hljs-string">'sym5'</span></span> (cA, cD) = pywt.dwt(y,st) (cA, cD) = pywt.dwt(cA,st) (cA, cD) = pywt.dwt(cA,st) (cA, cD) = pywt.dwt(cA,st) (cA, cD) = pywt.dwt(cA,st) subplot(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) plot(cA,<span class="hljs-string"><span class="hljs-string">'b'</span></span>,linewidth=<span class="hljs-number"><span class="hljs-number">2</span></span>, label=<span class="hljs-string"><span class="hljs-string">'cA,level-5'</span></span>) grid() legend(loc=<span class="hljs-string"><span class="hljs-string">'best'</span></span>) subplot(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) plot(cD,<span class="hljs-string"><span class="hljs-string">'r'</span></span>,linewidth=<span class="hljs-number"><span class="hljs-number">2</span></span>, label=<span class="hljs-string"><span class="hljs-string">'cD,level-5'</span></span>) grid() legend(loc=<span class="hljs-string"><span class="hljs-string">'best'</span></span>) show()</code> </pre> </div></div><br><img src="https://habrastorage.org/webt/gp/hy/nl/gphynlxwrnlm18jfajqwe74lm4k.png"><br><br>  Die Approximationskoeffizienten (cA) repr√§sentieren die Ausgabe des Tiefpassfilters (Mittelungsfilter) DWT.  Die Detailkoeffizienten (cD) repr√§sentieren die Ausgabe des Hochpassfilters (Differenzfilter) DWT. <br><br>  Mit der Funktion pywt.wavedec () k√∂nnen Sie sofort √ºbergeordnete Koeffizienten berechnen.  Diese Funktion nimmt das Eingangssignal und den Pegel als Eingang und gibt einen Satz von Approximationskoeffizienten (n-ten Pegel) und n S√§tze von Detailkoeffizienten (von 1 bis n-ten Pegel) zur√ºck.  Hier ist ein Beispiel f√ºr die f√ºnfte Ebene: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pywt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wavedec <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pylab <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * x = linspace (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, num = <span class="hljs-number"><span class="hljs-number">2048</span></span>) y = sin (<span class="hljs-number"><span class="hljs-number">250</span></span> * pi * x**<span class="hljs-number"><span class="hljs-number">2</span></span>) st=<span class="hljs-string"><span class="hljs-string">'sym5'</span></span> coeffs = wavedec(y, st, level=<span class="hljs-number"><span class="hljs-number">5</span></span>) subplot(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) plot(coeffs[<span class="hljs-number"><span class="hljs-number">0</span></span>],<span class="hljs-string"><span class="hljs-string">'b'</span></span>,linewidth=<span class="hljs-number"><span class="hljs-number">2</span></span>, label=<span class="hljs-string"><span class="hljs-string">'cA,level-5'</span></span>) grid() legend(loc=<span class="hljs-string"><span class="hljs-string">'best'</span></span>) subplot(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) plot(coeffs[<span class="hljs-number"><span class="hljs-number">1</span></span>],<span class="hljs-string"><span class="hljs-string">'r'</span></span>,linewidth=<span class="hljs-number"><span class="hljs-number">2</span></span>, label=<span class="hljs-string"><span class="hljs-string">'cD,level-5'</span></span>) grid() legend(loc=<span class="hljs-string"><span class="hljs-string">'best'</span></span>) show()</code> </pre> <br>  Als Ergebnis erhalten wir die gleichen Grafiken wie im vorherigen Beispiel.  Die Koeffizienten cA und cD k√∂nnen getrennt erhalten werden: <br><br>  F√ºr cA: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pywt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pylab <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>* x = linspace (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, num = <span class="hljs-number"><span class="hljs-number">2048</span></span>) data = sin (<span class="hljs-number"><span class="hljs-number">250</span></span> * pi * x**<span class="hljs-number"><span class="hljs-number">2</span></span>) coefs=pywt.downcoef(<span class="hljs-string"><span class="hljs-string">'a'</span></span>, data, <span class="hljs-string"><span class="hljs-string">'db20'</span></span>, mode=<span class="hljs-string"><span class="hljs-string">'symmetric'</span></span>, level=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  F√ºr cD: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pywt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pylab <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>* x = linspace (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, num = <span class="hljs-number"><span class="hljs-number">2048</span></span>) data = sin (<span class="hljs-number"><span class="hljs-number">250</span></span> * pi * x**<span class="hljs-number"><span class="hljs-number">2</span></span>) coefs=pywt.downcoef(<span class="hljs-string"><span class="hljs-string">'d'</span></span>, data, <span class="hljs-string"><span class="hljs-string">'db20'</span></span>, mode=<span class="hljs-string"><span class="hljs-string">'symmetric'</span></span>, level=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br><h3>  Filterbank </h3><br>  Einige der Probleme im Zusammenhang mit Conversion-Levels wurden im vorherigen Abschnitt erl√§utert.  DWT wird jedoch immer als Filterbank in Form einer Kaskade von Hochpass- und Tiefpassfiltern implementiert.  Filterb√§nke sind eine sehr effektive Methode, um ein Signal in mehrere Frequenzteilb√§nder zu unterteilen. <br><br>  In der ersten Phase mit kleinem Ma√üstab wird das Hochfrequenzverhalten des Signals analysiert.  In der zweiten Stufe nimmt die Skala um den Faktor zwei zu (die Frequenz nimmt um den Faktor zwei ab), und wir analysieren das Verhalten von etwa der H√§lfte der maximalen Frequenz.  In der dritten Stufe betr√§gt der Skalierungsfaktor vier, und wir analysieren das Frequenzverhalten von etwa einem Viertel der Maximalfrequenz.  Und das geht so weiter, bis wir das maximale Zersetzungsniveau erreicht haben. <br><br>  Der maximale Zerlegungsgrad kann mit der Funktion pywt.wavedec () berechnet werden, w√§hrend Zerlegung und Detail wie folgt aussehen: <br><br><div class="spoiler">  <b class="spoiler_title">Auflistung</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pywt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pywt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wavedec <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pylab <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>* x = linspace (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, num = <span class="hljs-number"><span class="hljs-number">2048</span></span>) data= sin (<span class="hljs-number"><span class="hljs-number">250</span></span> * pi * x**<span class="hljs-number"><span class="hljs-number">2</span></span>) n_level=pywt.dwt_max_level(len(data), <span class="hljs-string"><span class="hljs-string">'sym5'</span></span>) print(<span class="hljs-string"><span class="hljs-string">'  : %s'</span></span>%n_level) x = linspace (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, num = <span class="hljs-number"><span class="hljs-number">2048</span></span>) y = sin (<span class="hljs-number"><span class="hljs-number">250</span></span> * pi * x**<span class="hljs-number"><span class="hljs-number">2</span></span>) st=<span class="hljs-string"><span class="hljs-string">'sym5'</span></span> coeffs = wavedec(y, st, level=<span class="hljs-number"><span class="hljs-number">7</span></span>) subplot(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) plot(coeffs[<span class="hljs-number"><span class="hljs-number">0</span></span>],<span class="hljs-string"><span class="hljs-string">'b'</span></span>,linewidth=<span class="hljs-number"><span class="hljs-number">2</span></span>, label=<span class="hljs-string"><span class="hljs-string">'cA,level-7'</span></span>) grid() legend(loc=<span class="hljs-string"><span class="hljs-string">'best'</span></span>) subplot(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) plot(coeffs[<span class="hljs-number"><span class="hljs-number">1</span></span>],<span class="hljs-string"><span class="hljs-string">'r'</span></span>,linewidth=<span class="hljs-number"><span class="hljs-number">2</span></span>, label=<span class="hljs-string"><span class="hljs-string">'cD,level-7'</span></span>) grid() legend(loc=<span class="hljs-string"><span class="hljs-string">'best'</span></span>) show()</code> </pre><br></div></div><br>  Wir bekommen: <br><br>  Maximale Zersetzungsstufe: 7 <br><br><img src="https://habrastorage.org/webt/kn/dg/mr/kndgmrrygbypxosisoh6uwdw6xg.png"><br><br>  Die Zerlegung stoppt, wenn das Signal f√ºr ein gegebenes sym5-Wavelet k√ºrzer als die Filterl√§nge wird.  Angenommen, wir haben ein Signal mit Frequenzen bis zu 1000 Hz.  In der ersten Stufe trennen wir unser Signal in niederfrequente und hochfrequente Teile, d. H. 0-500 Hz und 500-1000 Hz.  In der zweiten Stufe nehmen wir den niederfrequenten Teil und teilen ihn erneut in zwei Teile: 0-250 Hz und 250-500 Hz.  In der dritten Stufe haben wir den Teil 0-250 Hz in den Teil 0-125 Hz und den Teil 125-250 Hz unterteilt.  Dies setzt sich fort, bis wir das maximale Zersetzungsniveau erreicht haben. <br><br><h3>  Analyse von WAV-Dateien mit fft Fourier- und Wavelet-Skalogrammen </h3><br>  Verwenden Sie zur Analyse die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebSDR-Datei</a> .  Betrachten Sie die Analyse des reduzierten Signals mit triang aus scipy.signal und die Implementierung der diskreten Fourier-Transformation in Python (fft aus scipy.fftpack).  Wenn die L√§nge der Sequenz fft nicht gleich 2n ist, wird anstelle der schnellen Fourier-Transformation (fft) eine diskrete Fourier-Transformation (dft) durchgef√ºhrt.  So arbeitet dieses Team. <br><br>  Wir verwenden den schnellen Fourier-Transformationspuffer nach folgendem Schema (z. B. numerische Daten): <br><br>  fftbuffer = np.zeros (15);  Erstellen Sie einen mit Nullen gef√ºllten Puffer. <br>  fftbuffer [: 8] = x [7:];  Verschieben Sie das Ende des Signals in den ersten Teil des Puffers.  fftbuffer [8:] = x [: 7] - Wir verschieben den Anfang des Signals zum letzten Teil des Puffers.  X = fft (fftbuffer) - Wir betrachten die Fourier-Transformation eines mit Signalwerten gef√ºllten Puffers. <br><br>  Um das Phasenspektrum besser lesbar zu machen, ist die Phasenbereitstellung anwendbar.  √Ñndern Sie dazu die Linie mit der Berechnung der Phasenkennlinie: pX = np.unwrap (np.angle (X)). <br><br><div class="spoiler">  <b class="spoiler_title">Auflistung f√ºr die fft-Signalfragmentanalyse</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pylab <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scipy.io.wavfile <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wavfile M=<span class="hljs-number"><span class="hljs-number">501</span></span> hM1=int(np.floor((<span class="hljs-number"><span class="hljs-number">1</span></span>+M)/<span class="hljs-number"><span class="hljs-number">2</span></span>)) hM2=int(np.floor(M/<span class="hljs-number"><span class="hljs-number">2</span></span>)) (fs,x)=wavfile.read(<span class="hljs-string"><span class="hljs-string">'WebSDR.wav'</span></span>) x1=x[<span class="hljs-number"><span class="hljs-number">5000</span></span>:<span class="hljs-number"><span class="hljs-number">5000</span></span>+M]*np.hamming(M) N=<span class="hljs-number"><span class="hljs-number">511</span></span> fftbuffer=np.zeros([N]) fftbuffer[:hM1]=x1[hM2:] fftbuffer[N-hM2:]=x1[:hM2] X=fft(fftbuffer) mX=abs(X) pX=np.angle(X) suptitle(<span class="hljs-string"><span class="hljs-string">" WebSDR"</span></span>) subplot(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) st=<span class="hljs-string"><span class="hljs-string">'  (WebSDR.wav)'</span></span> plot(x,linewidth=<span class="hljs-number"><span class="hljs-number">2</span></span>, label=st) legend(loc=<span class="hljs-string"><span class="hljs-string">'center'</span></span>) subplot(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) st=<span class="hljs-string"><span class="hljs-string">'    '</span></span> plot(mX,linewidth=<span class="hljs-number"><span class="hljs-number">2</span></span>, label=st) legend(loc=<span class="hljs-string"><span class="hljs-string">'best'</span></span>) subplot(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) st=<span class="hljs-string"><span class="hljs-string">'    '</span></span> pX=np.unwrap(np.angle(X)) plot(pX,linewidth=<span class="hljs-number"><span class="hljs-number">2</span></span>, label=st) legend(loc=<span class="hljs-string"><span class="hljs-string">'best'</span></span>) show()</code> </pre> </div></div><br><img src="https://habrastorage.org/webt/so/yl/po/soylpo5p_r_ni2qryz-a_p88kze.png"><br><br>  F√ºr die vergleichende Analyse verwenden wir ein Wavelet- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Skalogramm</a> , das mit der Funktion tree = pywt.wavedec (Signal, 'coif5') in matplotlib erstellt werden kann. <br><br><div class="spoiler">  <b class="spoiler_title">Auflisten von Wavelet-Skalogrammen</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pylab <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pywt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scipy.io.wavfile <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wavfile <span class="hljs-comment"><span class="hljs-comment">#     ,     . def lepow2(x): return int(2 ** floor(log2(x))) #    MRA. def scalogram(data): bottom = 0 vmin = min(map(lambda x: min(abs(x)), data)) vmax = max(map(lambda x: max(abs(x)), data)) gca().set_autoscale_on(False) for row in range(0, len(data)): scale = 2.0 ** (row - len(data)) imshow( array([abs(data[row])]), interpolation = 'nearest', vmin = vmin, vmax = vmax, extent = [0, 1, bottom, bottom + scale]) bottom += scale #  ,   . rate, signal = wavfile.read('WebSDR.wav') signal = signal[0:lepow2(len(signal))] tree = pywt.wavedec(signal, 'coif5') gray() scalogram(tree) show()</span></span></code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/jt/gu/cc/jtguccuy2qjlt3x1b1h1fk0edl0.png"><br><br>  Somit gibt das Skalogramm eine detailliertere Antwort auf die Frage der Verteilung der Frequenzen √ºber die Zeit, und die schnelle Fourier-Transformation ist f√ºr die Frequenzen selbst verantwortlich.  Es h√§ngt alles von der Aufgabe ab, auch f√ºr ein so einfaches Beispiel. <br><br><h3>  Schlussfolgerungen </h3><br><ol><li>  Die Gr√ºnde f√ºr die Verwendung einer diskreten Wavelet-Transformation f√ºr dynamische Signale werden angegeben. </li><li>  Beispiele f√ºr die Wavelet-Analyse mit PyWavelets 1.0.3, einer kostenlosen Open Source-Software, die unter der MIT-Lizenz ver√∂ffentlicht wurde, werden bereitgestellt. </li><li>  Software-Tools f√ºr die praktische Verwendung der PyWavelets-Bibliothek werden ber√ºcksichtigt. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451278/">https://habr.com/ru/post/de451278/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451268/index.html">Victor Gamov √ºber Kafka Streams IQ auf jug.msk.ru</a></li>
<li><a href="../de451270/index.html">B = Aufmerksamkeit oder wie man Zeit schafft</a></li>
<li><a href="../de451272/index.html">Wenn Sie bereits an die T√ºr geklopft haben: So sch√ºtzen Sie Informationen auf Ger√§ten</a></li>
<li><a href="../de451274/index.html">Perfekte Waffe, Krieg der Perspektiven und ein Mensch, der die Decke erreicht</a></li>
<li><a href="../de451276/index.html">Wie baue ich eine Marke auf?</a></li>
<li><a href="../de451280/index.html">Die interessantesten Metalle</a></li>
<li><a href="../de451282/index.html">Schwarze L√∂cher in der Webanalyse: Wie viele Daten gehen in GA verloren und warum?</a></li>
<li><a href="../de451286/index.html">Roskomnadzor, den wir verdienen</a></li>
<li><a href="../de451292/index.html">RxDart: magische Transformationen von Fl√ºssen</a></li>
<li><a href="../de451294/index.html">Da ich dem Auto Funktionen √ºber CAN hinzugef√ºgt habe, konnte ich nicht programmieren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>