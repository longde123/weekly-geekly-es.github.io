<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸŒ«ï¸ ğŸ‡ğŸ¼ â†™ï¸ Sespan untuk pemecahan kode ğŸ•Œ â›°ï¸ ğŸˆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pemecahan kode. Pemecahan kode ada di mana-mana. Namun mengapa? Hanya karena ada terlalu banyak javascript saat ini, dan tidak semua digunakan pada sa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sespan untuk pemecahan kode</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450942/"><p><img src="https://habrastorage.org/webt/ts/bi/e4/tsbie49wsfunvcztrdwhlnik6ge.jpeg"></p><br><p>  Pemecahan kode.  Pemecahan kode ada di mana-mana.  Namun mengapa?  Hanya karena ada <strong>terlalu banyak javascript</strong> saat ini, dan tidak semua digunakan pada saat yang sama. </p><br><p>  JS adalah hal yang sangat <em>berat</em> .  Bukan untuk iPhone Xs atau laptop i9 baru Anda, tetapi untuk jutaan (mungkin miliaran) pemilik perangkat yang <em>lebih lambat</em> .  Atau, setidaknya, untuk jam tangan Anda. </p><br><p>  Jadi - JS itu buruk, tetapi apa yang akan terjadi jika kita <strong>menonaktifkannya</strong> - masalahnya akan hilang ... untuk beberapa situs, dan hilang "dengan situs" untuk yang berbasiskan Bereaksi.  Tapi bagaimanapun - ada situs, yang bisa berfungsi tanpa JS ... dan ada sesuatu yang harus kita pelajari dari mereka ... </p><a name="habracut"></a><br><h1 id="code-splitting">  Pemecahan kode </h1><br><p>  Hari ini kita memiliki dua cara untuk maju, dua cara untuk membuatnya lebih baik, atau untuk tidak memperburuknya: </p><br><h2 id="1-write-less-code">  1. Tulis lebih sedikit kode </h2><br><p> Itu hal terbaik yang bisa Anda lakukan.  Sementara <code>React Hooks</code> memungkinkan Anda mengirimkan kode sedikit lebih sedikit, dan solusi seperti <code>Svelte</code> memungkinkan Anda menghasilkan kode lebih sedikit dari <em>biasanya</em> , itu tidak mudah dilakukan. </p><br><p>  Ini bukan hanya tentang kode, tetapi juga tentang <em>fungsionalitas</em> - untuk menjaga kode "kompak" Anda harus tetap "kompak".  Tidak ada cara untuk menjaga bundel aplikasi tetap kecil jika ia melakukan banyak hal (dan dikirimkan dalam 20 bahasa). </p><br><p>  Ada cara untuk menulis kode <em>pendek dan suara</em> , dan ada cara untuk menulis implementasi yang berlawanan - <em>perusahaan berdarah</em> .  Dan, Anda tahu, keduanya sah. </p><br><p><img src="https://habrastorage.org/webt/dz/fc/kn/dzfcknugbqrpbxturkjjae2v2se.jpeg"></p><br><p>  Tetapi masalah utama - kode itu sendiri.  Aplikasi reaksi sederhana dapat dengan mudah memotong 250kb "direkomendasikan".  Dan Anda mungkin menghabiskan satu bulan untuk mengoptimalkannya dan membuatnya lebih kecil.  Optimalisasi "Kecil" didokumentasikan dengan baik dan cukup bermanfaat - dapatkan <code>bundle-analyzer</code> dengan <code>size-limit</code> dan kembalilah ke bentuk semula. <br>  Ada banyak pustaka, yang berjuang untuk setiap byte, mencoba membuat Anda dalam batas Anda - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">preact</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">storeon</a> , untuk menyebutkan beberapa. </p><br><p>  Tetapi aplikasi kami sedikit melebihi 200kb.  Lebih dekat ke <strong>100Mb</strong> .  Menghapus kilobyte tidak masuk akal.  Bahkan menghapus megabita tidak masuk akal. </p><br><blockquote>  Setelah beberapa saat, aplikasi Anda tetap kecil.  Ini akan tumbuh lebih besar seiring waktu. </blockquote><br><h2 id="2-ship-less-code">  2. Kirimkan kode lebih sedikit </h2><br><p>  Atau, <code>code split</code> .  Dengan kata lain - <strong>menyerah</strong> .  Ambil 100mb bundel Anda, dan buat dua puluh 5mb bundel darinya.  Jujur - itu satu-satunya cara yang mungkin untuk menangani aplikasi Anda jika itu besar - buat paket aplikasi yang lebih kecil darinya. </p><br><p>  Tetapi ada satu hal yang harus Anda ketahui saat ini: opsi apa pun yang Anda pilih, itu adalah detail implementasi, sementara kami sedang mencari sesuatu yang lebih dapat diandalkan. </p><br><h1 id="the-truth-about-code-splitting">  Kebenaran tentang Pemecahan Kode </h1><br><p>  Kebenaran tentang pemisahan kode adalah sifatnya adalah <strong>SEPARASI WAKTU</strong> .  Anda tidak hanya <em>membelah</em> kode Anda, Anda membaginya dengan cara di mana Anda akan <strong>menggunakan</strong> sesedikit mungkin dalam satu titik waktu. </p><br><p>  Hanya saja, jangan mengirim kode yang tidak Anda butuhkan saat ini.  Singkirkan itu. </p><br><p><img src="https://habrastorage.org/webt/py/eg/mi/pyegmilj0w2cshkxcj8nwqxhpg0.jpeg"></p><br><p>  Mudah dikatakan, sulit dilakukan.  Saya memiliki beberapa aplikasi berat, tetapi tidak cukup terpecah, di mana setiap halaman memuat 50% dari segalanya.  Kadang-kadang <code>code splitting</code> menjadi <code>code separation</code> , maksud saya - Anda dapat memindahkan kode ke potongan yang berbeda, tetapi tetap saja, gunakan semuanya.  Ingatlah kembali bahwa <em>"Jangan kirimkan kode yang tidak Anda butuhkan saat ini"</em> , - Saya <em>membutuhkan</em> 50% dari kode itu, dan itulah masalah sebenarnya. </p><br><blockquote>  Terkadang hanya menambahkan <code>import</code> di sana-sini tidak cukup.  Sampai ini bukan pemisahan <strong>waktu</strong> , tetapi hanya pemisahan <strong>ruang</strong> - tidak masalah sama sekali. </blockquote><p>  Ada 3 cara umum untuk membagi kode: </p><br><ol><li>  <code>import</code> dinamis saja.  Hampir tidak digunakan sendirian hari ini.  Ini lebih tentang masalah dengan melacak <em>negara</em> . </li><li>  Komponen <code>Lazy</code> , ketika Anda mungkin menunda rendering dan memuat Komponen Bereaksi.  Mungkin 90% dari "reaksi pemecahan kode" hari ini. </li><li>  <em>Lazy</em> <code>Library</code> , yang sebenarnya adalah <code>.1</code> , tetapi Anda akan diberikan kode pustaka melalui React render props.  Diimplementasikan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komponen reaksi-impor</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komponen yang</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dapat dimuat</a> .  Cukup bermanfaat, tetapi tidak terkenal. </li></ol><br><h2 id="component-level-code-splitting">  Pemecahan Kode Level Komponen </h2><br><p>  Yang ini paling populer.  Sebagai pemisahan kode per rute, atau pemisahan kode per komponen.  Tidak mudah melakukannya dan mempertahankan <em>hasil persepsi yang</em> baik sebagai hasilnya.  Ini kematian dari <code>Flash of Loading Content</code> . </p><br><p>  Teknik yang baik adalah: </p><br><ul><li>  memuat <code>js chunk</code> dan <code>data</code> untuk rute secara paralel. </li><li>  gunakan <code>skeleton</code> untuk menampilkan sesuatu yang mirip dengan halaman sebelum memuat halaman (seperti Facebook). </li><li>  potongan <code>prefetch</code> , Anda bahkan dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tebak-js</a> untuk prediksi yang lebih baik. </li><li>  gunakan beberapa penundaan, memuat indikator, <code>animations</code> dan <code>Suspense</code> (di masa depan) untuk melunakkan transisi. </li></ul><br><p>  Dan, Anda tahu, itu semua tentang kinerja <em>perseptual</em> . </p><br><p><img src="https://habrastorage.org/webt/yk/4o/s1/yk4os1fia5xv28cfdsoccss6nr0.png"></p><br><blockquote>  Gambar dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://blog.angularindepth.com/">Peningkatan UX dengan Elemen Hantu</a> </blockquote><br><h1 id="that-doesnt-sound-good">  Kedengarannya tidak bagus </h1><br><p>  Anda tahu, saya bisa menyebut diri saya seorang ahli dalam pemecahan kode - tetapi saya memiliki kegagalan sendiri. </p><br><p>  Kadang-kadang saya bisa gagal mengurangi ukuran bundel.  Kadang-kadang saya bisa gagal meningkatkan kinerja yang dihasilkan, selama <code>the _more_ code splitting you are introducing - the more you spatially split your page - the more time you need to _reassemble_ your page back</code> *.  Ini disebut <strong>gelombang pemuatan</strong> . </p><br><ul><li>  tanpa SSR atau pra-rendering.  SSR yang tepat adalah pengubah game saat ini. </li></ul><br><p><img src="https://habrastorage.org/webt/fl/kn/hn/flknhn-kd8_aad9ro7g6fisrpqy.jpeg"></p><br><p>  Minggu lalu saya mengalami dua kegagalan: </p><br><ul><li>  Saya telah kehilangan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu perbandingan perpustakaan</a> , selama perpustakaan saya lebih baik, tetapi JAUH lebih besar dari yang lain.  Saya gagal <strong>"1. Tulis lebih sedikit kode"</strong> . </li><li>  mengoptimalkan situs kecil, dibuat di Bereaksi oleh istri saya.  Itu menggunakan pemisahan komponen berbasis rute, tetapi <code>header</code> dan <code>footer</code> disimpan dalam bundel utama untuk membuat transisi lebih "dapat diterima".  Hanya beberapa hal, yang <strong>erat dipasangkan</strong> dengan sisi bundel yang meroket hingga 320 kb (sebelum gzip).  Tidak ada yang penting, dan tidak ada yang bisa saya singkirkan.  <strong>Kematian dengan seribu luka</strong> .  Saya gagal <strong>mengirim kode lebih sedikit</strong> . </li></ul><br><blockquote>  React-Dom adalah 20%, core-js adalah 10%, react-router, jsLingui, react-powerplug ... 20% dari kode sendiri ... Kita sudah selesai. </blockquote><p><img src="https://habrastorage.org/webt/ec/zx/xo/eczxxohgulg4yvyjdeyxvzwi3g0.png"></p><br><h2 id="the-solution">  Solusinya </h2><br><p>  Saya mulai berpikir tentang bagaimana menyelesaikan masalah saya, dan mengapa <em>solusi umum</em> tidak berfungsi dengan baik untuk use case saya. </p><br><blockquote>  Apa yang saya lakukan?  Saya telah membuat daftar semua lokasi penting, yang tanpanya aplikasi tidak akan berfungsi sama sekali, dan mencoba memahami mengapa saya memiliki sisanya. </blockquote><p>  Itu mengejutkan.  Tapi masalah saya ada di CSS.  Dalam transisi CSS vanilla. </p><br><p>  Ini kodenya </p><br><ul><li>  variabel <em>kontrol</em> - <code>componentControl</code> , akhirnya akan diatur ke sesuatu yang <code>DisplayData</code> harus tampilkan. </li><li>  begitu nilai ditetapkan - <code>DisplayData</code> menjadi terlihat, mengubah <code>className</code> , sehingga memicu transisi mewah.  Secara simultan <code>FocusLock</code> menjadi aktif menjadikan <code>DisplayData</code> sebagai <strong>modal</strong> . <br><pre> <code class="javascript hljs">&lt;FocusLock enabled={componentControl.value} <span class="hljs-comment"><span class="hljs-comment">// ^ it's "disabled". When it's disabled - it's dead. &gt; {componentControl.value &amp;&amp; &lt;PageTitle title={componentControl.value.title}/&gt;} // ^ it's does not exists. Also dead &lt;DisplayData data={componentControl.value} visible={componentControl.value !== null} // ^ would change a className basing on visible state /&gt; // ^ that is just not visible, but NOT dead &lt;/FocusLock&gt;</span></span></code> </pre> </li></ul><br><p>  Saya ingin memecah kode bagian ini secara keseluruhan, tetapi ini adalah sesuatu yang tidak dapat saya lakukan, karena dua alasan: </p><br><ol><li>  informasi harus segera terlihat, sekali diperlukan, tanpa penundaan.  Persyaratan bisnis. </li><li>  informasi "chrome" harus ada sebelumnya, untuk menangani transisi properti. </li></ol><br><p>  Masalah ini sebagian dapat diselesaikan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CSSTransitionGroup</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rekondisi</a> .  Tapi, Anda tahu, memperbaiki <em>satu kode dengan</em> menambahkan <em>kode lain</em> terdengar aneh, walaupun sebenarnya cukup.  Maksud saya menambahkan lebih banyak kode dapat membantu menghilangkan lebih banyak kode.  Tapi ... tapi ... </p><br><blockquote>  Harus ada cara yang lebih baik! </blockquote><p>  TL; DR - ada dua poin utama di sini: </p><br><ul><li>  <code>DisplayData</code> harus <strong>dipasang</strong> , dan ada di DOM sebelumnya. </li><li>  <code>FocusLock</code> juga harus ada sebelumnya, bukan untuk menyebabkan <code>DisplayData</code> remount, tetapi <strong>otak itu tidak diperlukan</strong> di awal. </li></ul><br><hr><br><p>  Jadi mari kita ubah model mental kita </p><br><h1 id="batman-and-robin">  Batman dan robin </h1><br><p>  Anggap kode kita adalah Batman dan Robin.  Batman dapat menangani sebagian besar orang jahat, tetapi ketika dia tidak bisa, sahabat karibnya Robin datang untuk menyelamatkan .. </p><br><blockquote>  Sekali lagi Batman akan terlibat pertempuran, Robin akan tiba nanti. </blockquote><p>  Ini Batman: </p><br><pre> <code class="diff hljs"><span class="hljs-addition"><span class="hljs-addition">+&lt;FocusLock - enabled={componentControl.value} +&gt; - {componentControl.value &amp;&amp; &lt;PageTitle title={componentControl.value.title}/&gt;} + &lt;DisplayData + data={componentControl.value} + visible={componentControl.value !== null} + /&gt; +&lt;/FocusLock&gt;</span></span></code> </pre> <br><p>  Ini adalah sahabat karibnya, Robin :: </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">-&lt;FocusLock + enabled={componentControl.value} -&gt; + {componentControl.value &amp;&amp; &lt;PageTitle title={componentControl.value.title}/&gt;} - &lt;DisplayData - data={componentControl.value} - visible={componentControl.value !== null} - /&gt; -&lt;/FocusLock&gt;</span></span></code> </pre> <br><p>  Batman dan Robin dapat membentuk <em>TIM</em> , tetapi mereka sebenarnya, adalah dua orang yang berbeda. </p><br><p>  Dan jangan lupa - kita masih berbicara tentang <strong>pemecahan kode</strong> .  Dan, dalam hal pemisahan kode, di mana sidekick itu?  Dimana Robin? </p><br><p><img src="https://habrastorage.org/webt/m3/3a/fu/m33afuxsi_rirx3uwjusiprzj94.jpeg"></p><br><blockquote>  di sespan.  Robin sedang menunggu di bagian <strong>sespan</strong> . </blockquote><br><h1 id="sidecar">  Sespan </h1><br><ul><li>  <code>Batman</code> sini adalah semua barang visual yang harus dilihat pelanggan Anda sesegera mungkin.  Idealnya secara instan. </li><li>  <code>Robin</code> sini adalah semua logika, dan fitur interaktif yang mewah, yang mungkin tersedia setelah kedua, tetapi tidak di awal. </li></ul><br><p>  Akan lebih baik untuk menyebutnya <strong>pemisahan kode vertikal di</strong> mana cabang kode ada secara paralel, berlawanan dengan <strong>pemisahan kode horisontal</strong> umum di mana cabang kode <em>dipotong</em> . </p><br><p>  Di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa negeri</a> , trio ini dikenal sebagai <code>replace reducer</code> atau cara lain untuk memuat logika reduks dan efek samping. </p><br><p>  Di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa negara lain</a> , ini dikenal sebagai <code>"3 Phased" code splitting</code> . </p><br><blockquote>  Ini hanyalah pemisahan dari kekhawatiran, hanya berlaku untuk kasus, di mana Anda dapat menunda memuat beberapa bagian dari suatu komponen, tetapi bukan bagian lain. </blockquote><p><img src="https://habrastorage.org/webt/sw/fq/if/swfqifrldpp0n6o7qcfr6osdunk.jpeg" alt="fase 3"></p><br><blockquote>  gambar dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Membangun Facebook.com Baru dengan Bereaksi, GraphQL dan Relay</a> , di mana <code>importForInteractions</code> , atau <code>importAfter</code> <strong>adalah <code>sidecar</code></strong> . </blockquote><p>  Dan ada pengamatan yang <strong>menarik</strong> - sementara <code>Batman</code> lebih berharga untuk pelanggan, selama itu sesuatu yang mungkin <em>dilihat</em> pelanggan, dia selalu bugar ... Sementara <code>Robin</code> , Anda tahu, dia mungkin sedikit <em>kelebihan berat badan</em> , dan membutuhkan lebih banyak byte untuk hidup. </p><br><p>  Akibatnya - Batman sendiri adalah sesuatu yang jauh lebih bisa diterima oleh seorang pelanggan - ia memberikan nilai lebih dengan biaya lebih rendah.  Anda adalah pahlawan saya Kelelawar! </p><br><h2 id="what-could-be-moved-to-a-sidecar">  Apa yang bisa dipindahkan ke sespan: </h2><br><ul><li>  mayoritas <code>useEffect</code> , <code>componentDidMount</code> , dan teman-teman. </li><li>  seperti semua efek <em>Modal</em> .  Yakni <code>focus</code> dan <code>scroll</code> kunci.  Anda mungkin pertama kali menampilkan modal, dan <strong>baru kemudian</strong> membuat Modal <em>modal</em> , yaitu "mengunci" perhatian pelanggan. </li><li>  Bentuk  Memindahkan semua logika dan validasi ke sespan, dan memblokir pengiriman formulir sampai logika itu dimuat.  Pelanggan bisa mulai mengisi formulir, tidak tahu bahwa itu hanya <code>Batman</code> . </li><li>  Beberapa animasi.  Seluruh <code>react-spring</code> dalam kasus saya. </li><li>  Beberapa hal visual.  Seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bilah gulir Kustom</a> , yang mungkin menampilkan bilah gulir mewah sedetik kemudian. </li></ul><br><p>  Juga, jangan lupa - Setiap bagian dari kode, diturunkan ke sespan, juga lepas dari hal-hal seperti core-js poly- dan ponyfill, yang digunakan oleh kode yang dihapus. </p><br><p>  Pemecahan Kode bisa lebih pintar daripada yang ada di aplikasi kita hari ini.  Kita harus menyadari ada 2 macam <em>kode</em> untuk dibagi: 1) aspek visual 2) aspek interaktif.  Yang terakhir dapat datang beberapa saat kemudian.  <code>Sidecar</code> membuatnya mulus untuk membagi dua tugas, memberikan <em>persepsi bahwa semuanya dimuat lebih cepat</em> .  Dan itu akan terjadi. </p><br><h2 id="the-oldest-way-to-code-split">  Cara terlama untuk memisahkan kode </h2><br><p>  Meskipun masih belum jelas kapan dan apa <code>sidecar</code> , saya akan memberikan penjelasan sederhana: </p><br><blockquote>  <code>Sidecar</code> adalah <strong>SEMUA TULISAN ANDA</strong> .  Sidecar adalah cara kita <em>menempatkan kode</em> sebelum semua hal frontend yang kita dapatkan hari ini. </blockquote><p>  Saya berbicara tentang Server Side Rendering ( <strong>SSR</strong> ), atau hanya <strong>HTML</strong> biasa, kita semua terbiasa kemarin.  <code>Sidecar</code> membuat semuanya semudah dulu ketika halaman yang berisi HTML dan logika hidup terpisah dalam skrip eksternal yang dapat disematkan (pemisahan kekhawatiran). </p><br><p>  Kami memiliki HTML, <strong>plus</strong> CSS, <strong>ditambah</strong> beberapa skrip yang diuraikan, <strong>ditambah</strong> skrip lainnya diekstraksi ke file <code>.js</code> . </p><br><p>  <code>HTML</code> + <code>CSS</code> + <code>inlined-js</code> adalah <code>Batman</code> , sedangkan skrip eksternal adalah <code>Robin</code> , dan situs tersebut dapat berfungsi tanpa Robin, dan, jujur, sebagian tanpa Batman (ia akan melanjutkan pertarungan dengan kedua kaki (skrip inline) rusak).  Itu baru kemarin, dan banyak situs "non modern dan keren" adalah sama hari ini. </p><br><hr><br><p>  Jika aplikasi Anda mendukung SSR - cobalah untuk <strong>menonaktifkan js</strong> dan membuatnya berfungsi tanpa itu.  Maka akan menjadi jelas apa yang bisa dipindahkan ke sespan. <br>  Jika aplikasi Anda hanya SPA sisi klien - coba bayangkan cara kerjanya, jika SSR ada. </p><br><blockquote>  Misalnya - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">theurge.com</a> , ditulis dalam React, berfungsi penuh <strong>tanpa mengaktifkan js</strong> . </blockquote><p>  Ada banyak hal yang bisa Anda keluarkan ke sespan.  Sebagai contoh: </p><br><ul><li>  komentar.  Anda mungkin mengirim kode untuk <code>display</code> komentar, tetapi tidak <code>answer</code> , selama mungkin memerlukan lebih banyak kode (termasuk editor WYSIWYG), yang pada awalnya tidak diperlukan.  Lebih baik menunda <em>kotak komentar</em> , atau bahkan hanya menyembunyikan pemuatan kode di balik animasi, daripada menunda seluruh halaman. </li><li>  pemutar video.  Kirimkan "video" tanpa "kontrol".  Load mereka sedetik kemudian, mereka pelanggan mungkin mencoba untuk berinteraksi dengannya. </li><li>  galeri gambar, seperti <code>slick</code> .  Ini bukan masalah besar untuk <strong>menggambarnya</strong> , tetapi jauh lebih sulit untuk menghidupkan dan mengelola.  Jelas apa yang bisa dipindahkan ke sespan. </li></ul><br><blockquote>  Pikirkan saja apa yang penting untuk aplikasi Anda, dan apa yang tidak cukup ... </blockquote><br><h1 id="implementation-details">  Detail implementasi </h1><br><h2 id="di-component-code-splitting">  (DI) Pemecahan kode komponen </h2><br><p>  Bentuk <code>sidecar</code> paling sederhana adalah mudah diimplementasikan - cukup pindahkan semuanya ke sub komponen, Anda dapat memecah kode menggunakan cara "lama".  Ini hampir merupakan pemisahan antara komponen Smart dan Dumb, tetapi kali ini Smart tidak memiliki <em>komponen</em> Dumb - justru sebaliknya. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SmartComponent = React.lazy( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./SmartComponent'</span></span>)); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DumbComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;React.Fragment&gt; &lt;SmartComponent ref={this} /&gt; // &lt;-- move smart one inside &lt;TheActualMarkup /&gt; // &lt;-- the "real" stuff is here &lt;/React.Fragment&gt; } }</code> </pre> <br><p>  Itu juga membutuhkan pemindahan kode <em>inisialisasi</em> ke kode Dumb, tetapi Anda masih dapat membagi kode bagian <em>terberat</em> dari suatu kode. </p><br><blockquote>  Bisakah Anda melihat pola pemisah kode <code>parallel</code> atau <code>vertical</code> sekarang? </blockquote><br><h2 id="usesidecar">  useSidecar </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Membangun Facebook.com Baru dengan React, GraphQL dan Relay</a> , saya sudah sebutkan di sini, memiliki konsep <code>loadAfter</code> atau <code>importForInteractivity</code> , yang merupakan konsep sespan yang sangat mirip. </p><br><p>  Pada saat yang sama, saya tidak akan merekomendasikan membuat sesuatu seperti <code>useSidecar</code> selama Anda mungkin sengaja mencoba menggunakan <code>hooks</code> di dalamnya, tetapi pemecahan kode dalam bentuk ini akan melanggar <em>aturan kait</em> . </p><br><p>  Silakan pilih cara komponen yang lebih deklaratif.  Dan Anda mungkin menggunakan <code>hooks</code> di dalam komponen <code>SideCar</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Controller = React.lazy( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./Controller'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DumbComponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ref = useRef(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state = useState(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;&gt; &lt;Controller componentRef={ref} state={state} /&gt; &lt;TheRealStuff ref={ref} state={state[0]} /&gt; &lt;/&gt; ) }</code> </pre> <br><h2 id="prefetching">  Prefetching </h2><br><p>  Jangan lupa - Anda mungkin menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">petunjuk memuat prioritas</a> untuk preload atau prefetch <code>sidecar</code> dan membuatnya pengiriman lebih transparan dan tidak terlihat. </p><br><p>  Hal-hal penting - skrip prefetching akan memuatnya melalui <strong>jaringan</strong> , tetapi tidak mengeksekusi (dan menghabiskan CPU) kecuali itu benar-benar diperlukan. </p><br><h2 id="ssr">  SSR </h2><br><p>  Tidak seperti pemisahan kode <em>normal</em> , tidak ada tindakan khusus yang diperlukan untuk SSR.  <code>Sidecar</code> mungkin bukan bagian dari proses SSR dan tidak diperlukan sebelum langkah <code>hydration</code> .  Itu bisa ditunda "oleh desain". </p><br><p>  Dengan demikian - jangan ragu untuk menggunakan <code>React.lazy</code> (idealnya sesuatu <strong>tanpa</strong> <code>Suspense</code> , Anda tidak memerlukan indikator failback (memuat) di sini), atau pustaka lainnya, dengan, tetapi lebih baik tanpa dukungan SSR untuk <em>melewati</em> potongan sespan selama proses SSR. </p><br><h1 id="the-bad-parts">  Bagian yang buruk </h1><br><p>  Tetapi ada beberapa bagian buruk dari ide ini </p><br><h2 id="batman-is-not-a-production-name">  Batman bukan nama produksi </h2><br><p>  Sementara <code>Batman</code> / <code>Robin</code> mungkin konsep pikiran yang baik, dan <code>sidecar</code> adalah pasangan yang sempurna untuk teknologi itu sendiri - tidak ada nama "baik" untuk <code>maincar</code> .  Tidak ada yang namanya <code>maincar</code> , dan jelas <code>Batman</code> , <code>Lonely Wolf</code> , <code>Solitude</code> , <code>Driver</code> , dan <code>Solo</code> tidak akan digunakan untuk menyebut bagian yang bukan sespan. </p><br><p>  Facebook telah menggunakan <code>display</code> dan <code>interactivity</code> , dan itu mungkin pilihan terbaik bagi kita semua. </p><br><blockquote>  Jika Anda memiliki nama baik untuk saya - tinggalkan di komentar </blockquote><br><h2 id="tree-shaking">  Pohon bergetar </h2><br><p>  Ini lebih tentang pemisahan keprihatinan dari sudut pandang <em>bundler</em> .  Bayangkan Anda memiliki <code>Batman</code> dan <code>Robin</code> .  Dan <code>stuff.js</code> </p><br><ul><li> <code>stuff.js</code> <br> <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">`./batman.js`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">`./robin.js`</span></span></code> </pre> </li></ul><br><p>  Kemudian Anda dapat mencoba pemecahan kode <em>komponen komponen</em> untuk menerapkan sespan </p><br><ul><li><p> <code>main.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {batman} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./stuff.js'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Robin = React.lazy( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./sidecar.js'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Component = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Robin</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> // sidecar </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Batman</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> // main content </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/&gt;</span></span></span><span class="xml"> )</span></span></code> </pre> <br></li><li><p> <code>sidecar.js</code> </p> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// and sidecar.js... that's another chunk as long as we `import` it import {robin} from './stuff.js' .....</span></span></code> </pre> <br></li></ul><br><p>  Singkatnya - kode di atas akan berfungsi, tetapi tidak akan melakukan "pekerjaan". </p><br><ul><li>  jika Anda hanya menggunakan <code>batman</code> dari <code>stuff.js</code> - pohon goyang hanya akan menyimpannya. </li><li>  jika Anda hanya menggunakan <code>robin</code> dari <code>stuff.js</code> - gemetar pohon hanya akan membuatnya. </li><li>  <strong>tetapi</strong> jika Anda menggunakan keduanya, bahkan dalam potongan yang berbeda - keduanya akan dibundel dalam kemunculan <strong>pertama</strong> <code>stuff.js</code> , yaitu <strong>bundel utama</strong> . </li></ul><br><blockquote>  Mengguncang pohon tidak ramah pemecahan kode.  Anda harus memisahkan masalah dengan file. </blockquote><br><h2 id="un-import">  Batalkan impor </h2><br><p>  Hal lain, dilupakan oleh semua orang, adalah biaya javascript.  Itu cukup umum di era jQuery, era payload <code>jsonp</code> untuk memuat script (dengan payload <code>json</code> ), mendapatkan payload, dan <strong>menghapus</strong> script. </p><br><blockquote>  Saat ini kita semua <code>import</code> skrip, dan itu akan selamanya diimpor, bahkan jika tidak lagi diperlukan. </blockquote><p>  Seperti yang saya katakan sebelumnya - ada terlalu banyak JS, dan cepat atau lambat, dengan <em>navigasi terus menerus</em> Anda akan memuat semuanya.  Kita harus menemukan cara untuk membatalkan impor yang tidak perlu lagi dilakukan chunk, membersihkan semua cache internal dan membebaskan memori untuk membuat web lebih andal, dan tidak menghancurkan aplikasi tanpa pengecualian memori. </p><br><p>  Mungkin kemampuan untuk <code>un-import</code> (webpack <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dapat melakukannya</a> ) adalah salah satu alasan kami harus tetap menggunakan API <em>berbasis komponen</em> , selama itu memberi kami kemampuan untuk menangani <code>unmount</code> . </p><br><p>  Sejauh ini - standar modul ESM tidak memiliki hal-hal seperti ini - atau tentang kontrol cache, atau tentang membalikkan tindakan impor. </p><br><h2 id="creating-a-sidecar-enabled-library">  Membuat Perpustakaan yang mendukung sespan </h2><br><p>  Sampai hari ini hanya ada satu cara untuk membuat pustaka yang diaktifkan <code>sidecar</code> : </p><br><ul><li>  pisahkan komponen Anda menjadi beberapa bagian </li><li>  mengekspos bagian <code>main</code> dan bagian yang <code>connected</code> (tidak merusak API) melalui <code>index</code> </li><li>  mengekspos <code>sidecar</code> melalui titik masuk yang terpisah. </li><li>  dalam kode target - impor bagian <code>main</code> dan <code>sidecar</code> - goyangan pohon harus memotong bagian yang <code>connected</code> . </li></ul><br><p>  Goyang pohon waktu ini harus bekerja dengan baik, dan satu-satunya masalah - adalah bagaimana menyebutkan bagian <code>main</code> . </p><br><ul><li> <code>main.js</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Main = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{sidecar, ...props}</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {sidecar} .... </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> );</code> </pre> <br><ul><li> <code>connected.js</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Main <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Component'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Sidecar <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Sidecar'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Connected = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Main</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">sidecar</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Sidecar</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">} {...props} /&gt; );</span></span></code> </pre> <br><ul><li> <code>index.js</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Main'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Connected'</span></span>;</code> </pre> <br><ul><li> <code>sidecar.js</code> </li> </ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Sidecar'</span></span>;</code> </pre> <br><p>  Singkatnya, perubahan dapat diwakili melalui perbandingan kecil </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//your app BEFORE import {Connected} from 'library'; // // ------------------------- //your app AFTER, compare this core to `connected.js` import {Main} from 'library'; const Sidecar = React.lazy(import( () =&gt; import('library/sidecar'))); // ^ all the difference ^ export SideConnected = props =&gt; ( &lt;Main sidecar={&lt;Sidecar /&gt;} {...props} /&gt; ); // ^ you will load only Main, Sidecar will arrive later.</span></span></code> </pre> <br><p>  <code>dynamic import</code> teoritis dapat digunakan di dalam node_modules, membuat <em>proses assemble</em> lebih transparan. </p><br><blockquote>  Pokoknya - itu tidak lebih dari pola <code>children</code> - <code>children</code> / <code>slot</code> , sangat umum di React. </blockquote><br><h1 id="the-future">  Masa depan </h1><br><p>  <code>Facebook</code> membuktikan bahwa idenya benar.  Jika Anda belum melihat video itu - lakukan sekarang.  Saya baru saja menjelaskan ide yang sama dari sudut yang sedikit berbeda (dan mulai menulis artikel ini seminggu sebelum konferensi F8). </p><br><p>  Saat ini diperlukan beberapa perubahan kode untuk diterapkan ke basis kode Anda.  Dibutuhkan pemisahan keprihatinan yang lebih eksplisit untuk benar-benar memisahkannya, dan membiarkan kode tidak diletakkan secara horizontal, tetapi secara vertikal, mengirimkan kode yang <em>lebih kecil</em> untuk pengalaman pengguna yang <em>lebih besar</em> . </p><br><p>  <code>Sidecar</code> , mungkin, adalah satu-satunya cara, kecuali SSR sekolah lama, untuk menangani basis kode BIG.  Kesempatan terakhir untuk mengirimkan kode dalam jumlah minimal, ketika Anda memiliki banyak kode. </p><br><blockquote>  Itu bisa membuat aplikasi BESAR lebih kecil, dan aplikasi KECIL bahkan lebih kecil. </blockquote><p>  10 tahun yang lalu situs web medium "siap" dalam 300 ms, dan <em>benar</em> - <em>benar</em> siap beberapa milidetik setelahnya.  Detik hari ini dan bahkan lebih dari 10 detik adalah angka umum.  Sayang sekali. </p><br><p>  Mari kita berhenti sejenak, dan berpikir - bagaimana kita bisa menyelesaikan masalah, dan membuat UX hebat lagi ... </p><br><p><img src="https://habrastorage.org/webt/8_/5u/7e/8_5u7ehdn7nkcjiaqfv1-rzadfa.jpeg"></p><br><h1 id="overall">  Secara keseluruhan </h1><br><ul><li>  Pemecahan kode komponen adalah alat yang paling ampuh, memberi Anda kemampuan untuk <em>benar</em> - <em>benar</em> memecah sesuatu, tetapi ada biaya - Anda mungkin tidak menampilkan apa pun kecuali halaman kosong, atau <em>kerangka</em> untuk sementara waktu.  Itu pemisahan horizontal. </li><li>  Pemisahan kode perpustakaan dapat membantu ketika pemisahan komponen tidak.  Itu pemisahan horizontal. </li><li>  Kode, diturunkan ke sespan akan melengkapi gambar, dan mungkin membiarkan Anda memberikan pengalaman pengguna yang jauh lebih baik.  Tetapi juga akan membutuhkan beberapa upaya rekayasa.  Itu pemisahan vertikal. </li></ul><br><p>  <strong>Mari kita bicara tentang ini</strong> . </p><br><h2 id="stop-so-what-about-the-problems-you-tried-to-solve">  Berhenti!  Jadi bagaimana dengan masalah yang Anda coba selesaikan? </h2><br><p>  Ya, itu baru bagian pertama.  <strong>Kami berada di endgame sekarang</strong> , akan butuh beberapa minggu lagi untuk menuliskan bagian kedua dari proposal ini.  Sementara itu ... dapatkan sespan! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id450942/">https://habr.com/ru/post/id450942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id450924/index.html">Semua Tentang Animasi SVG</a></li>
<li><a href="../id450926/index.html">Game 3D di three.js, nw.js</a></li>
<li><a href="../id450928/index.html">Bagaimana pusat data menghemat hari libur</a></li>
<li><a href="../id450930/index.html">Bagaimana kami mengembangkan # bigdataX5 dan siapa yang dibutuhkan di Big Data</a></li>
<li><a href="../id450938/index.html">Linux Instal Fest 05.19 di Nizhny Novgorod 18 Mei 2019</a></li>
<li><a href="../id450946/index.html">Disk Cell Phone di LPC810</a></li>
<li><a href="../id450948/index.html">MU-MIMO: salah satu algoritma implementasi</a></li>
<li><a href="../id450950/index.html">Dasar-Dasar Aliran Dart</a></li>
<li><a href="../id450952/index.html">Indeks Sedang dan Antibank</a></li>
<li><a href="../id450954/index.html">Bagaimana kami belajar mengeksploitasi Java di Docker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>