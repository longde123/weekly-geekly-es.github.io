<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüè´ ‚ôüÔ∏è ü§üüèª RESTinio es un servidor HTTP as√≠ncrono. Asincr√≥nico üîñ üßôüèø üè¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace un par de a√±os publicamos RESTinio , nuestro peque√±o marco OpenSource C ++ para incrustar un servidor HTTP en aplicaciones C ++. RESTinio no se v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RESTinio es un servidor HTTP as√≠ncrono. Asincr√≥nico</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451728/"><p>  Hace un par de a√±os <a href="">publicamos RESTinio</a> , nuestro peque√±o marco OpenSource C ++ para incrustar un servidor HTTP en aplicaciones C ++.  RESTinio no se volvi√≥ mega popular durante este tiempo, pero no se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">perdi√≥</a> .  Alguien lo elige por el soporte "nativo" para Windows, alguien por algunas caracter√≠sticas individuales (como el soporte de sendfile), alguien por la proporci√≥n de caracter√≠sticas, facilidad de uso y personalizaci√≥n.  Pero, creo, inicialmente muchos RESTinio se sienten atra√≠dos por este lac√≥nico "Hola, Mundo": </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;restinio/all.hpp&gt; int main() { restinio::run( restinio::on_this_thread() .port(8080) .address("localhost") .request_handler([](auto req) { return req-&gt;create_response().set_body("Hello, World!").done(); })); return 0; }</span></span></span></span></code> </pre> <br><p>  Esto es realmente todo lo que se necesita para ejecutar el servidor HTTP dentro de una aplicaci√≥n C ++. </p><br><p>  Y aunque siempre tratamos de decir que la caracter√≠stica clave para la que generalmente participamos en RESTinio era el procesamiento asincr√≥nico de las solicitudes entrantes, todav√≠a ocasionalmente encontramos preguntas sobre qu√© hacer si dentro de request_handler tiene que realizar operaciones largas. </p><br><p>  Y dado que dicha pregunta es relevante, puede volver a hablar sobre ella y dar un par de peque√±os ejemplos. </p><a name="habracut"></a><br><h1 id="nebolshaya-otsylka-k-istokam">  Una peque√±a referencia a los or√≠genes. </h1><br><p>  Decidimos hacer que nuestro servidor HTTP incorporable despu√©s de varias veces seguidas enfrentara tareas muy similares: era necesario organizar una entrada HTTP para una aplicaci√≥n C ++ existente o era necesario escribir un microservicio en el que era necesario reutilizar el C ++ "pesado" ya existente c√≥digo ny  Una caracter√≠stica com√∫n de estas tareas era que el procesamiento de la solicitud de la solicitud pod√≠a extenderse por decenas de segundos. </p><br><p>  En t√©rminos generales, durante un milisegundo, el servidor HTTP estaba clasificando una nueva solicitud HTTP, pero para emitir una respuesta HTTP, era necesario recurrir a otros servicios o realizar algunos c√°lculos largos.  Si procesa solicitudes HTTP en modo s√≠ncrono, entonces el servidor HTTP necesitar√° un conjunto de miles de hilos de trabajo, lo que dif√≠cilmente puede considerarse una buena idea incluso en condiciones modernas. </p><br><p>  Es mucho m√°s conveniente cuando el servidor HTTP puede funcionar en un solo subproceso de trabajo, en el que se realiza la E / S y se llama a los manejadores de solicitudes.  El controlador de solicitudes simplemente delega el procesamiento real de alg√∫n otro hilo de trabajo y devuelve el control al servidor HTTP.  Cuando, mucho m√°s tarde, en alg√∫n lugar de otro hilo de trabajo, la informaci√≥n est√° lista para responder a la solicitud, simplemente se genera una respuesta HTTP que recoge autom√°ticamente el servidor HTTP y env√≠a esta respuesta al cliente apropiado. </p><br><p>  Como nunca encontramos una versi√≥n lista para usar que fuera simple y conveniente de usar, era multiplataforma y admit√≠a Windows como plataforma "nativa", proporcionar√≠a un rendimiento m√°s o menos decente y, lo m√°s importante, se mejorar√≠a espec√≠ficamente para asincr√≥nico trabajo, luego a principios de 2017 comenzamos a desarrollar RESTinio. </p><br><p>  Quer√≠amos hacer un servidor HTTP embebido as√≠ncrono, f√°cil de usar, que liberara al usuario de algunas preocupaciones de rutina, mientras era m√°s o menos productivo, multiplataforma y permit√≠a una configuraci√≥n flexible para diferentes condiciones.  Parece estar funcionando, pero dejemos que los usuarios juzguen ... </p><br><h1 id="itak-est-vhodyaschiy-zapros-trebuyuschiy-mnogo-vremeni-na-obrabotku-chto-delat">  Por lo tanto, hay una solicitud entrante que requiere mucho tiempo de procesamiento.  Que hacer </h1><br><h2 id="rabochie-niti-restinioasio">  Hilos de trabajo RESTinio / Asio </h2><br><p>  A veces, los usuarios de RESTinio no piensan qu√© hilos de trabajo y c√≥mo utiliza RESTinio exactamente.  Por ejemplo, alguien podr√≠a considerar que cuando RESTinio se inicia en un hilo de trabajo (usando <code>run(on_this_thread(...))</code> , como en el ejemplo anterior), en este hilo de trabajo RESTinio solo llama a los manejadores de solicitudes.  Mientras que para I / O RESTinio crea un hilo separado debajo del cap√≥.  Y este hilo separado contin√∫a sirviendo nuevas conexiones cuando el hilo principal de trabajo est√° ocupado por request_handler. </p><br><p>  De hecho, todos los hilos que el usuario asigna a RESTinio se usan tanto para realizar operaciones de E / S como para llamar a request_handlers.  Por lo tanto, si inici√≥ el servidor RESTinio a trav√©s de <code>run(on_this_thread(...))</code> , luego dentro de <code>run()</code> en el hilo actual, se realizar√°n los manejadores de E / S y de solicitud. </p><br><p>  En t√©rminos generales, RESTinio lanza un bucle de eventos Asio, dentro del cual procesa nuevas conexiones, lee y analiza datos de conexiones existentes, escribe datos listos para enviar, maneja el cierre de conexiones, etc.  Entre otras cosas, despu√©s de leer y analizar completamente la solicitud entrante desde la siguiente conexi√≥n, se llama al request_handler especificado por el usuario para procesar esta solicitud. </p><br><p>  En consecuencia, si request_handler bloquea la operaci√≥n del subproceso actual, tambi√©n se bloquea el bucle de eventos Asio-action que trabaja en el mismo subproceso.  Todo es simple </p><br><p>  Si RESTinio se inicia en un grupo de subprocesos de trabajo (es decir, mediante <code>run(on_thread_pool(...))</code> , como <a href="">en este ejemplo</a> ), sucede casi lo mismo: se inicia un bucle de evento de evento Asio en cada subproceso del grupo.  Por lo tanto, si alg√∫n request_handler comienza a multiplicar matrices grandes, esto bloquear√° el subproceso de trabajo en el grupo y las operaciones de E / S ya no se servir√°n en este subproceso. </p><br><p>  Por lo tanto, cuando se usa RESTinio, la tarea del desarrollador es completar sus request_handlers en un tiempo razonable y, preferiblemente, no muy largo. </p><br><h2 id="nuzhen-li-vam-pul-rabochih-potokov-dlya-restinioasio">  ¬øNecesita un grupo de flujo de trabajo para RESTinio / Asio? </h2><br><p>  Entonces, cuando el request_handler especificado por el usuario bloquea el hilo de trabajo en el que se lo llama durante mucho tiempo, este hilo pierde la capacidad de procesar operaciones de E / S.  Pero, ¬øqu√© pasa si request_handler necesita mucho tiempo para formar una respuesta?  Supongamos que realiza alg√∫n tipo de operaci√≥n inform√°tica pesada, cuyo tiempo, en principio, no puede acortarse a unos pocos milisegundos. </p><br><p>  Uno de los usuarios podr√≠a pensar que, dado que RESTinio puede trabajar en un grupo de subprocesos de trabajo, simplemente especifique el tama√±o de grupo m√°s grande y listo. </p><br><p>  Desafortunadamente, esto solo funcionar√° en casos simples cuando tenga pocas conexiones paralelas.  Y la intensidad de la consulta es baja.  Si el recuento de consultas paralelas llega a miles (al menos solo unos pocos cientos), es f√°cil obtener una situaci√≥n en la que todos los subprocesos de trabajo del grupo estar√°n ocupados procesando solicitudes ya aceptadas.  Y no habr√° m√°s subprocesos para realizar operaciones de E / S.  Como resultado, el servidor perder√° su capacidad de respuesta.  La inclusi√≥n de RESTinio perder√° la capacidad de procesar tiempos de espera que RESTinio cuenta autom√°ticamente cuando recibe nuevas conexiones y al procesar solicitudes. </p><br><p>  Por lo tanto, si necesita realizar operaciones de bloqueo prolongadas para atender las solicitudes entrantes, es mejor asignar solo un hilo de trabajo para RESTinio, pero asignar un gran grupo de flujos de trabajo para realizar estas mismas operaciones.  El controlador de solicitudes solo colocar√° la siguiente solicitud en alguna cola, desde donde la solicitud se recuperar√° y se enviar√° para su procesamiento. </p><br><p>  Observamos un ejemplo de este esquema en detalle cuando hablamos sobre nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">proyecto de demostraci√≥n de camarones</a> en este art√≠culo: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Camarones: escale y distribuya im√°genes HTTP en C ++ moderno usando ImageMagic ++, SObjectizer y RESTinio</a> ". </p><br><h2 id="primery-delegirovaniya-obrabotki-zaprosov-na-otdelnye-rabochie-niti">  Ejemplos de delegaci√≥n de procesamiento de solicitudes a subprocesos de trabajo individuales </h2><br><p>  Arriba, trat√© de explicar por qu√© no es necesario realizar un procesamiento prolongado dentro del request_handler.  ¬øDe d√≥nde viene el resultado obvio? El procesamiento de solicitudes prolongado debe delegarse en alg√∫n otro hilo de trabajo.  Veamos c√≥mo podr√≠a verse esto. </p><br><p>  En los dos ejemplos a continuaci√≥n, necesitamos un √∫nico subproceso de trabajo para ejecutar RESTinio y otro subproceso de trabajo para simular un procesamiento de solicitud prolongado.  Y tambi√©n necesitamos alg√∫n tipo de cola de mensajes para transferir solicitudes del hilo RESTinio a un hilo de trabajo separado. </p><br><p>  No fue f√°cil para m√≠ hacer una nueva implementaci√≥n de la cola de mensajes segura para subprocesos en mi rodilla para estos dos ejemplos, as√≠ que utilic√© mi SObjectizer nativo y sus mchains, que son canales CSP.  Puede leer m√°s sobre mchain aqu√≠: "¬ø <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Intercambio de informaci√≥n entre hilos de trabajo sin problemas? Canales CSP para ayudarnos"</a> . </p><br><h3 id="sohranenie-obekta-request_handle">  Guardar objeto request_handle </h3><br><p>  La t√©cnica b√°sica sobre la cual se construye la delegaci√≥n del procesamiento de solicitudes es la transferencia del objeto <code>request_handle_t</code> alguna parte. </p><br><p>  Cuando RESTinio llama al request_handler especificado por el usuario para procesar una solicitud entrante, un objeto de tipo <code>request_handle_t</code> se pasa a este <code>request_handle_t</code> .  Este tipo no es m√°s que un puntero inteligente a los par√°metros de la solicitud recibida.  Entonces, si es conveniente que alguien piense que <code>shared_ptr</code> es <code>shared_ptr</code> , entonces puede pensarlo con seguridad.  Este <code>shared_ptr</code> es. </p><br><p>  Y dado que <code>shared_ptr</code> es <code>shared_ptr</code> , podemos pasar con seguridad este puntero inteligente a alguna parte.  Lo que haremos en los ejemplos a continuaci√≥n. </p><br><p>  Por lo tanto, necesitamos un hilo de trabajo y un canal separados para comunicarnos con √©l.  Vamos a crearlo todo: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  SObjectizer. so_5::wrapped_env_t sobj; //  std::thread    . std::thread processing_thread; //    main      join. //    RAII. auto processing_thread_joiner = so_5::auto_join(processing_thread); //      . auto req_ch = so_5::create_mchain(sobj); //       main. //    RAII. auto ch_closer = so_5::auto_close_drop_content(req_ch); //     . //      main()  - , //     ,      join(). processing_thread = std::thread{ processing_thread_func, req_ch };</span></span></code> </pre> <br><p>  El cuerpo del subproceso de trabajo en s√≠ se encuentra dentro de la funci√≥n <code>processing_thread_func()</code> , que discutiremos m√°s adelante. </p><br><p>  Ahora ya tenemos un hilo de trabajo separado y un canal para la comunicaci√≥n con √©l.  Puede iniciar el servidor RESTinio: </p><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ,     . struct traits_t : public restinio::default_traits_t { using logger_t = restinio::shared_ostream_logger_t; }; restinio::run( restinio::on_this_thread&lt;traits_t&gt;() .port(8080) .address("localhost") .request_handler([req_ch](auto req) { //   GET-   . if(restinio::http_method_t::http_get == req-&gt;header().method() &amp;&amp; "/" == req-&gt;header().path()) { //    . so_5::send&lt;handle_request&gt;(req_ch, req); return restinio::request_accepted(); } else return restinio::request_rejected(); }) .cleanup_func([&amp;] { //      . //    , ..  req_ch //          //     . so_5::close_drop_content(req_ch); }));</span></span></code> </pre> <br><p>  La l√≥gica de este servidor es muy simple.  Si ha llegado una solicitud GET para '/', delegamos el procesamiento de la solicitud de un solo hilo.  Para hacer esto, realizamos dos operaciones importantes: </p><br><ul><li>  env√≠e el objeto <code>request_handle_t</code> al canal CSP.  Mientras este objeto se almacena dentro del canal CSP o en otro lugar, RESTinio sabe que la solicitud a√∫n est√° activa; </li><li>  devolvemos el valor <code>restinio::request_accepted()</code> del manejador de solicitudes.  Esto hace que RESTinio comprenda que la solicitud ha sido aceptada para su procesamiento y que la conexi√≥n con el cliente no se puede cerrar. </li></ul><br><p>  El hecho de que request_handler no haya generado inmediatamente una respuesta RESTinio no molesta.  Una vez que <code>restinio::request_accepted()</code> fue devuelto, el usuario asumi√≥ la responsabilidad de procesar la solicitud y alg√∫n d√≠a se generar√° la respuesta a la solicitud. </p><br><p>  Si el controlador de solicitudes devolvi√≥ <code>restinio::request_rejected()</code> , RESTinio comprende que la solicitud no se procesar√° y devolver√° un error 501 al cliente. </p><br><p>  Entonces, arreglamos el resultado preliminar: la instancia <code>request_handle_t</code> se puede pasar a alg√∫n lado, ya que de hecho es <code>std::shared_ptr</code> .  Mientras esta instancia est√° activa, RESTinio considera que la solicitud se est√° procesando.  Si el controlador de solicitudes devolvi√≥ <code>restinio::request_accepted()</code> , RESTinio no se preocupar√° de que la respuesta a la solicitud no se haya generado en este momento. </p><br><p>  Ahora podemos ver la implementaci√≥n de este hilo muy separado: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processing_thread_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req_ch)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       //    . std::random_device rd; std::mt19937 generator{rd()}; std::uniform_int_distribution&lt;&gt; pause_generator{350, 3500}; //      timeout_elapsed. auto delayed_ch = so_5::create_mchain(req_ch-&gt;environment()); //     -  . bool stop = false; select( so_5::from_all() //      . .on_close([&amp;stop](const auto &amp;) { stop = true; }) //     select(). //  select()     . .stop_on([&amp;stop]{ return stop; }), //   handle_request     RESTinio. case_(req_ch, [&amp;](handle_request cmd) { //     . const std::chrono::milliseconds pause{pause_generator(generator)}; //     . so_5::send_delayed&lt;timeout_elapsed&gt;(delayed_ch, //    timeout_elapsed. pause, //      timeout_elapsed. cmd.m_req, pause); }), //   timeout_elapsed. case_(delayed_ch, [](timeout_elapsed cmd) { //     . cmd.m_req-&gt;create_response() .set_body("Hello, World! (pause:" + std::to_string(cmd.m_pause.count()) + "ms)") .done(); }) ); }</span></span></code> </pre> <br><p>  La l√≥gica aqu√≠ es muy simple: recibimos la solicitud inicial en forma de un mensaje <code>handle_request</code> y la <code>handle_request</code> a nosotros mismos en forma de un mensaje <code>timeout_elapsed</code> retrasado por un tiempo aleatorio.  Realizamos el procesamiento real de la solicitud solo despu√©s de recibir <code>timeout_elapsed</code> . </p><br><p>  <strong>Upd.</strong>  Cuando se llama al m√©todo <code>done()</code> en un hilo de trabajo separado, RESTinio es notificado de que ha aparecido una respuesta preparada que debe escribirse en la conexi√≥n TCP.  RESTinio inicia la operaci√≥n de escritura, pero la operaci√≥n de E / S en s√≠ no se ejecutar√° donde <code>done()</code> llama <code>done()</code> , sino donde RESTinio realiza la E / S y llama a request_handlers.  Es decir  en este ejemplo, <code>done()</code> se llama en un subproceso de trabajo separado, y la operaci√≥n de escritura se realizar√° en el subproceso principal, donde funciona <code>restinio::run()</code> . </p><br><p>  Los mensajes en s√≠ son los siguientes: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handle_request</span></span></span><span class="hljs-class"> {</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> m_req; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeout_elapsed</span></span></span><span class="hljs-class"> {</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> m_req; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds m_pause; };</code> </pre> <br><p>  Es decir  un hilo de trabajo separado toma <code>request_handle_t</code> y lo guarda hasta que surja la oportunidad de formar una respuesta completa.  Y cuando surge esta oportunidad, se llama a <code>create_response()</code> en el objeto de solicitud guardado y la respuesta se devuelve a RESTinio.  Entonces RESTinio ya en su contexto de trabajo escribe la respuesta en relaci√≥n con el cliente correspondiente. </p><br><p>  Aqu√≠, la instancia <code>timeout_elapsed</code> se almacena en un mensaje retrasado <code>timeout_elapsed</code> , ya que no hay un procesamiento real en este ejemplo primitivo.  En una aplicaci√≥n real, <code>request_handle_t</code> puede almacenarse en alg√∫n tipo de cola o dentro de alg√∫n objeto creado para procesar la solicitud. </p><br><p>  El c√≥digo completo para este ejemplo se puede encontrar <a href="">entre los ejemplos regulares de RESTinio</a> . </p><br><h4 id="neskolko-nebolshih-poyasneniy-po-kodu">  Algunas notas de c√≥digo peque√±o </h4><br><p>  Esta construcci√≥n establece las propiedades RESTinio que debe tener un servidor RESTinio: </p><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ,     . struct traits_t : public restinio::default_traits_t { using logger_t = restinio::shared_ostream_logger_t; }; restinio::run( restinio::on_this_thread&lt;traits_t&gt;()</span></span></code> </pre> <br><p>  Para este ejemplo, necesito RESTinio para registrar sus acciones de procesamiento de solicitudes.  Por lo tanto, configuro <code>logger_t</code> sea ‚Äã‚Äãdiferente del <code>null_logger_t</code> predeterminado.  Pero desde  RESTinio funcionar√°, de hecho, en varios subprocesos (RESTinio procesa las solicitudes entrantes en el subproceso principal, pero las respuestas provienen de un subproceso de trabajo separado), entonces necesita un registrador seguro para subprocesos, que es <code>shared_ostream_logger_t</code> . </p><br><p>  Dentro de <code>processing_thread_func()</code> , se utiliza la funci√≥n SObjectizer <code>select()</code> , que es algo similar a la construcci√≥n Go select: puede leer y procesar mensajes de varios canales a la vez.  La funci√≥n <code>select()</code> funciona hasta que todos los canales que se le pasan est√©n cerrados.  O hasta que le digan a la fuerza que es hora de terminar. </p><br><p>  Al mismo tiempo, si el canal para la comunicaci√≥n con el servidor RESTinio est√° cerrado, entonces no tiene sentido continuar el trabajo.  Por lo tanto, en <code>select()</code> , se determina la respuesta al cierre de cualquiera de los canales: tan pronto como se cierra un canal, se levanta el indicador de detenci√≥n.  Y esto llevar√° a la finalizaci√≥n de <code>select()</code> y a salir de <code>processing_thread_func()</code> . </p><br><h3 id="sohranenie-obekta-response_builder">  Guardar el objeto response_builder </h3><br><p>  En el ejemplo anterior, consideramos un caso simple cuando es posible guardar <code>request_handle_t</code> hasta que podamos dar inmediatamente la respuesta completa a la solicitud. </p><br><p>  Pero puede haber escenarios m√°s complejos cuando, por ejemplo, necesita dar una respuesta en partes.  Es decir, recibimos una solicitud, podemos formar inmediatamente solo la primera parte de la respuesta.  Nosotros lo formamos.  Luego, despu√©s de un tiempo, tenemos la oportunidad de formar la segunda parte de la respuesta.  Luego, despu√©s de m√°s tiempo, podemos formar la siguiente parte, etc. </p><br><p>  Adem√°s, puede ser deseable para nosotros que todas estas partes desaparezcan a medida que las formemos.  Es decir  Primero, la primera parte de la respuesta para que el cliente pueda restarla, luego la segunda, luego la tercera, etc. </p><br><p>  RESTinio le permite hacer esto debido a los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">diferentes tipos de Responce_builders</a> .  En particular, tipos como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">user_controlled_output</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">chunked_output</a> . </p><br><p>  En este caso, no es suficiente guardar <code>request_handle_t</code> , porque <code>request_handle_t</code> ser√° √∫til hasta la primera llamada a <code>create_reponse()</code> .  Luego tenemos que trabajar con response_builder.  Bueno ... </p><br><p>  Bueno, esta bien.  Response_builder es un tipo m√≥vil, algo similar a unique_ptr.  Por lo tanto, tambi√©n podemos conservarlo mientras lo necesitemos.  Y para mostrar c√≥mo se ve, rehacemos ligeramente el ejemplo anterior.  Deje que la funci√≥n <code>processing_thread_func()</code> forme la respuesta en partes. </p><br><p>  Esto no es del todo dif√≠cil. </p><br><p>  Primero necesitamos decidir sobre los tipos que necesitar√° new <code>processing_thread_func()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handle_request</span></span></span><span class="hljs-class"> {</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> m_req; }; <span class="hljs-comment"><span class="hljs-comment">//     . using output_t = restinio::chunked_output_t; //   reponse_builder-   . using response_t = restinio::response_builder_t&lt;output_t&gt;; //     . struct timeout_elapsed { response_t m_resp; int m_counter; };</span></span></code> </pre> <br><p>  El mensaje <code>handle_request</code> permanece sin cambios.  Pero en el mensaje <code>timeout_elapsed</code> ahora almacenamos no <code>request_handle_t</code> , sino response_builder del tipo que necesitamos.  Adem√°s de un contador de las partes restantes.  Tan pronto como se restablezca este contador, finaliza el servicio de solicitud. </p><br><p>  Ahora podemos ver una nueva versi√≥n de la funci√≥n <code>processing_thread_func()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processing_thread_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req_ch)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::random_device rd; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mt19937 generator{rd()}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::uniform_int_distribution&lt;&gt; pause_generator{<span class="hljs-number"><span class="hljs-number">350</span></span>, <span class="hljs-number"><span class="hljs-number">3500</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> delayed_ch = so_5::create_mchain(req_ch-&gt;environment()); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> stop = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; select( so_5::from_all() .on_close([&amp;stop](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;) { stop = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }) .stop_on([&amp;stop]{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stop; }), case_(req_ch, [&amp;](handle_request cmd) { <span class="hljs-comment"><span class="hljs-comment">//    ,    . auto resp = cmd.m_req-&gt;create_response&lt;output_t&gt;(); resp.append_header( restinio::http_field::server, "RESTinio" ) .append_header_date_field() .append_header( restinio::http_field::content_type, "text/plain; charset=utf-8" ); //    ,  RESTinio //   . resp.flush(); //       . so_5::send_delayed&lt;so_5::mutable_msg&lt;timeout_elapsed&gt;&gt;(delayed_ch, //     . std::chrono::milliseconds{pause_generator(generator)}, //    timeout_elapsed. //     response_builder-  . std::move(resp), 3); }), case_(delayed_ch, [&amp;](so_5::mutable_mhood_t&lt;timeout_elapsed&gt; cmd) { //      . cmd-&gt;m_resp.append_chunk( "this is the next part of the response\n" ); //  RESTinio   . cmd-&gt;m_resp.flush(); cmd-&gt;m_counter -= 1; if( 0 != cmd-&gt;m_counter ) { //        . so_5::send_delayed( delayed_ch, std::chrono::milliseconds{pause_generator(generator)}, std::move(cmd)); } else // ,   . cmd-&gt;m_resp.done(); }) ); }</span></span></code> </pre> <br><p>  Es decir     ,        .       .         . </p><br><p> <strong>Upd.</strong>   <code>flush()</code>   ,     <code>done()</code> : RESTinio   ,   I/O-    ,   <code>flush()</code> ,  ,  RESTinio  -   request_handler-.  Es decir    <code>flush()</code>     ,        , ,   <code>restinio::run()</code> . </p><br><p>       ,    RESTinio    : </p><br><pre> <code class="plaintext hljs">[2019-05-13 15:02:35.106] TRACE: starting server on 127.0.0.1:8080 [2019-05-13 15:02:35.106] INFO: init accept #0 [2019-05-13 15:02:35.106] INFO: server started on 127.0.0.1:8080 [2019-05-13 15:02:39.050] TRACE: accept connection from 127.0.0.1:49280 on socket #0 [2019-05-13 15:02:39.050] TRACE: [connection:1] start connection with 127.0.0.1:49280 [2019-05-13 15:02:39.050] TRACE: [connection:1] start waiting for request [2019-05-13 15:02:39.050] TRACE: [connection:1] continue reading request [2019-05-13 15:02:39.050] TRACE: [connection:1] received 78 bytes [2019-05-13 15:02:39.050] TRACE: [connection:1] request received (#0): GET / [2019-05-13 15:02:39.050] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 1 [2019-05-13 15:02:39.050] TRACE: [connection:1] start next write group for response (#0), size: 1 [2019-05-13 15:02:39.050] TRACE: [connection:1] start response (#0): HTTP/1.1 200 OK [2019-05-13 15:02:39.050] TRACE: [connection:1] sending resp data, buf count: 1, total size: 167 [2019-05-13 15:02:39.050] TRACE: [connection:1] outgoing data was sent: 167 bytes [2019-05-13 15:02:39.050] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:39.050] TRACE: [connection:1] should keep alive [2019-05-13 15:02:40.190] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 3 [2019-05-13 15:02:40.190] TRACE: [connection:1] start next write group for response (#0), size: 3 [2019-05-13 15:02:40.190] TRACE: [connection:1] sending resp data, buf count: 3, total size: 42 [2019-05-13 15:02:40.190] TRACE: [connection:1] outgoing data was sent: 42 bytes [2019-05-13 15:02:40.190] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:40.190] TRACE: [connection:1] should keep alive [2019-05-13 15:02:43.542] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 3 [2019-05-13 15:02:43.542] TRACE: [connection:1] start next write group for response (#0), size: 3 [2019-05-13 15:02:43.542] TRACE: [connection:1] sending resp data, buf count: 3, total size: 42 [2019-05-13 15:02:43.542] TRACE: [connection:1] outgoing data was sent: 42 bytes [2019-05-13 15:02:43.542] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:43.542] TRACE: [connection:1] should keep alive [2019-05-13 15:02:46.297] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 3 [2019-05-13 15:02:46.297] TRACE: [connection:1] start next write group for response (#0), size: 3 [2019-05-13 15:02:46.297] TRACE: [connection:1] sending resp data, buf count: 3, total size: 42 [2019-05-13 15:02:46.297] TRACE: [connection:1] append response (#0), flags: { final_parts, connection_keepalive }, write group size: 1 [2019-05-13 15:02:46.297] TRACE: [connection:1] outgoing data was sent: 42 bytes [2019-05-13 15:02:46.298] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:46.298] TRACE: [connection:1] should keep alive [2019-05-13 15:02:46.298] TRACE: [connection:1] start next write group for response (#0), size: 1 [2019-05-13 15:02:46.298] TRACE: [connection:1] sending resp data, buf count: 1, total size: 5 [2019-05-13 15:02:46.298] TRACE: [connection:1] outgoing data was sent: 5 bytes [2019-05-13 15:02:46.298] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:46.298] TRACE: [connection:1] should keep alive [2019-05-13 15:02:46.298] TRACE: [connection:1] start waiting for request [2019-05-13 15:02:46.298] TRACE: [connection:1] continue reading request [2019-05-13 15:02:46.298] TRACE: [connection:1] EOF and no request, close connection [2019-05-13 15:02:46.298] TRACE: [connection:1] close [2019-05-13 15:02:46.298] TRACE: [connection:1] close: close socket [2019-05-13 15:02:46.298] TRACE: [connection:1] close: timer canceled [2019-05-13 15:02:46.298] TRACE: [connection:1] close: reset responses data [2019-05-13 15:02:46.298] TRACE: [connection:1] destructor called</code> </pre> <br><p>   ,  RESTinio           167 .          ,           , RESTinio          . </p><br><p>   ,    RESTinio   -     response_builder     ,        . </p><br><p>      .        , ,     .       response_builder   .     ,   responce_builder       ,          .. </p><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . </p><br><h2 id="chto-budet-esli-obrabotka-zaprosa-zaymet-slishkom-mnogo-vremeni">  ,       ? </h2><br><p> ,   request_handler-     -   .  ,      ,           ? </p><br><p>  RESTinio    ,   -  request_handler-.    - ,     , RESTinio       . ,         . , : </p><br><pre> <code class="plaintext hljs">[2019-05-13 15:32:23.618] TRACE: starting server on 127.0.0.1:8080 [2019-05-13 15:32:23.618] INFO: init accept #0 [2019-05-13 15:32:23.618] INFO: server started on 127.0.0.1:8080 [2019-05-13 15:32:26.768] TRACE: accept connection from 127.0.0.1:49502 on socket #0 [2019-05-13 15:32:26.768] TRACE: [connection:1] start connection with 127.0.0.1:49502 [2019-05-13 15:32:26.768] TRACE: [connection:1] start waiting for request [2019-05-13 15:32:26.768] TRACE: [connection:1] continue reading request [2019-05-13 15:32:26.768] TRACE: [connection:1] received 78 bytes [2019-05-13 15:32:26.768] TRACE: [connection:1] request received (#0): GET / [2019-05-13 15:32:30.768] TRACE: [connection:1] handle request timed out [2019-05-13 15:32:30.768] TRACE: [connection:1] close [2019-05-13 15:32:30.768] TRACE: [connection:1] close: close socket [2019-05-13 15:32:30.768] TRACE: [connection:1] close: timer canceled [2019-05-13 15:32:30.768] TRACE: [connection:1] close: reset responses data [2019-05-13 15:32:31.768] WARN: [connection:1] try to write response, while socket is closed [2019-05-13 15:32:31.768] TRACE: [connection:1] destructor called</code> </pre> <br><p>   -       . ,      ,  RESTinio   , ..     . </p><br><p>   -    <code>handle_request_timeout</code> ,     RESTinio- ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> ). </p><br><h1 id="zaklyuchenie">  Conclusi√≥n </h1><br><p> ,   ,      RESTinio ‚Äî   ,   .  ,     RESTinio,    ,        RESTinio,     . </p><br><p>      RESTinio        ,  , ,  :  ? -  ? -  ? - -  ? </p><br><p>  PS.    RESTinio     ,   SObjectizer,    .  ,  -   RESTinio ,     : " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> C++      HTTP-   </a> ", " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> HTTP-  C++:   RESTinio,   libcurl.  1</a> ", " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Shrimp:     HTTP    C++  ImageMagic++, SObjectizer  RESTinio</a> " </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/451728/">https://habr.com/ru/post/451728/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../451718/index.html">Crear asistente de voz</a></li>
<li><a href="../451720/index.html">FIAS cargando en la base de datos en MSSQLSERVER por medios improvisados ‚Äã‚Äã(SQLXMLBULKLOAD). C√≥mo (probablemente) no necesita hacerse</a></li>
<li><a href="../451722/index.html">Biblioteca de widgets as√≠ncronos Qt-async</a></li>
<li><a href="../451724/index.html">Skyrmion a skyrmion discord: skyrmions polares tridimensionales en ferroelastia</a></li>
<li><a href="../451726/index.html">Buscando trabajo en el extranjero: 7 consejos simples para profesionales de TI</a></li>
<li><a href="../451738/index.html">Breve rese√±a del art√≠culo "DeViSE: un modelo de inclusi√≥n visual-sem√°ntica profunda"</a></li>
<li><a href="../451742/index.html">Un d√≠a antes de DotNext 2019 Piter. Anuncio de transmisi√≥n gratuita</a></li>
<li><a href="../451746/index.html">MegaSlerm para ingenieros y arquitectos Kubernetes</a></li>
<li><a href="../451748/index.html">Supervisi√≥n del estado de SSD en matrices Qsan</a></li>
<li><a href="../451750/index.html">Libro "Elasticsearch, Kibana, Logstash y los motores de b√∫squeda de la pr√≥xima generaci√≥n"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>