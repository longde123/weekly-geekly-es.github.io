<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêô ‚úçüèæ üôáüèø ¬øQu√© hacer cuando el procesador no tiene nada que hacer? üëºüèæ ‚èØÔ∏è üë©‚Äçüîß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ser√≠a razonable suponer que para el n√∫cleo ser√≠a bastante f√°cil no hacer nada, pero no lo es. En la conferencia Kernel Recipes 2018 , Rafael Vysotsky ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øQu√© hacer cuando el procesador no tiene nada que hacer?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427419/"><img src="https://habrastorage.org/getpro/habr/post_images/4d6/056/8ed/4d60568ede6023ffb669539747f5e46f.jpg" align="left">  Ser√≠a razonable suponer que para el n√∫cleo ser√≠a bastante f√°cil no hacer nada, pero no lo es.  En la conferencia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kernel Recipes 2018</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rafael Vysotsky</a> habl√≥ sobre lo que hacen los procesadores, cu√°ndo no tienen nada que hacer, c√≥mo lo procesa el n√∫cleo, cu√°l es su estrategia actual y c√≥mo su trabajo reciente en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ciclo inactivo ha</a> mejorado la situaci√≥n energ√©tica de los sistemas que no hacen nada. . <br><br>  El ciclo de inactividad, uno de los subsistemas del n√∫cleo que admite Vysotsky, controla lo que hace la CPU cuando no necesita ejecutar ning√∫n proceso.  Vysotsky dio todas las definiciones con mucha precisi√≥n: una CPU es una entidad que puede recibir instrucciones de la memoria y ejecutarlas simult√°neamente con otras entidades del mismo sistema que se ocupan de lo mismo.  En el sistema de procesador √∫nico m√°s simple con un n√∫cleo, este n√∫cleo es la CPU.  Si el procesador tiene varios n√∫cleos, cada uno de estos n√∫cleos es una CPU.  Si cada uno de los n√∫cleos tiene varias interfaces para ejecutar instrucciones simult√°neamente, Intel llama a este sistema " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hyperthreading</a> ", entonces cada uno de estos hilos ser√° una CPU. <br><a name="habracut"></a><br>  La CPU est√° inactiva cuando no tiene tareas que realizar.  O, m√°s precisamente, el kernel de Linux tiene varias clases internas para despachar, una de las cuales es una clase inactiva especial.  Si no hay tareas en esta CPU en ninguna de las clases, excepto en la clase de inactividad, la CPU se considera inactiva.  Si el equipo no permite esto, entonces la CPU tendr√° que llevar a cabo instrucciones in√∫tiles hasta que el trabajo real aparezca.  Sin embargo, este es un uso extremadamente ineficiente de la electricidad, por lo que la mayor√≠a de los procesadores admiten varios estados de baja energ√≠a en los que el n√∫cleo los transfiere hasta que se necesitan para realizar un trabajo √∫til. <br><br>  No puede simplemente entrar o salir de un estado de inacci√≥n.  Toma tiempo ingresar y salir, y adem√°s, cuando ingresa a este estado, el consumo de energ√≠a del estado actual aumenta ligeramente, y cuando sale, consume el estado en el que entra el procesador.  Y aunque cuanto m√°s profundo es el estado de inactividad, menos energ√≠a consume el procesador, aumenta el costo de entrar y salir a tales estados.  Esto significa que en el caso de per√≠odos cortos de inactividad, el mejor uso de los recursos de la computadora ser√° una inacci√≥n superficial;  durante per√≠odos m√°s largos, el costo de pasar a un estado m√°s profundo de inacci√≥n se justificar√° por un aumento en la cantidad de energ√≠a ahorrada.  Por lo tanto, le interesa al kernel predecir cu√°nto tiempo estar√° inactivo el procesador antes de decidir qu√© tan profundo necesita el estado de inactividad.  Esta es la tarea del ciclo de inacci√≥n. <br><br>  En este ciclo, el planificador se da cuenta de que la CPU est√° inactiva, ya que no tiene ninguna tarea que se le pueda asignar.  Luego, el programador llama al regulador, que intenta dar la mejor predicci√≥n del estado de inacci√≥n apropiado, en el que puede ingresar.  Ahora en el kernel hay dos controles, men√∫ y escalera.  Se usan en diferentes casos, pero ambos intentan hacer aproximadamente lo mismo: monitorear el estado del sistema cuando la CPU pasa a estado inactivo y el tiempo que pas√≥ inactivo.  Esto se hace para predecir cu√°nto tiempo la CPU pasar√° a un estado inactivo y, por lo tanto, qu√© estado es el m√°s adecuado para esta situaci√≥n. <br><br>  Este trabajo es especialmente complicado por el temporizador del planificador de la CPU.  El programador inicia este temporizador para dividir el tiempo de acceso a la CPU: si es necesario realizar varias tareas en un procesador, cada una de ellas puede realizarse solo un poco y luego posponerse peri√≥dicamente en favor de otra tarea.  No es necesario realizar este temporizador en una CPU inactiva, ya que no hay tareas entre las que deba dividirse la CPU.  Adem√°s, si se permite que el temporizador se ejecute en una CPU inactiva, esto evitar√° que el controlador seleccione estados inactivos profundos, limitando los intervalos durante los cuales la CPU est√° inactiva.  Por lo tanto, en n√∫cleos hasta 4.16, el programador apag√≥ el temporizador antes de llamar al regulador.  Cuando la CPU se despert√≥ tras la interrupci√≥n, el planificador decidi√≥ si hab√≠a tareas necesarias para la ejecuci√≥n y, si hubo alguna, reinici√≥ el temporizador. <br><br>  Si el controlador predice un largo per√≠odo de inactividad, y este per√≠odo realmente resulta ser largo, entonces el controlador "gana": la CPU entra en un estado de inactividad profunda y se ahorra energ√≠a.  Pero si el regulador predice un largo per√≠odo de inactividad, y este per√≠odo resulta corto, entonces el regulador "pierde", ya que el costo de entrar en una inacci√≥n profunda no vale la pena ahorrando energ√≠a por un corto per√≠odo de inactividad.  Peor a√∫n, cuando el regulador predice un corto tiempo de inactividad, entonces "pierde" sin importar el tiempo de inactividad: si el per√≠odo result√≥ ser largo, se perdi√≥ la oportunidad de ahorrar, y si fue corto, se desperdiciaron los costos de detener y reiniciar el temporizador.  O, en otras palabras, dado que se gastan recursos para detener e iniciar el temporizador, no tiene sentido detenerlo cuando el controlador predice un breve tiempo de inactividad. <br><br>  Vysotsky decidi√≥ intentar cambiar el funcionamiento del regulador, pero lleg√≥ a la conclusi√≥n de que el problema principal es que el temporizador se detiene antes de que se llame al regulador, es decir, antes de que se conozca el estado de inactividad recomendado.  Regres√≥ un ciclo inactivo en el kernel 4.17 para que la decisi√≥n de detener el temporizador se tomara despu√©s de que el regulador hiciera su recomendaci√≥n.  Si predijo un largo tiempo de inactividad, el temporizador se detiene para no despertar la CPU con anticipaci√≥n.  Si se supone que el tiempo de inactividad es corto, se deja el temporizador para no desperdiciar recursos en paradas.  Esto significa que el temporizador tambi√©n realiza una funci√≥n de seguridad, despertando la CPU si el tiempo de inactividad result√≥ ser m√°s largo de lo previsto, y le da al regulador una segunda oportunidad para la decisi√≥n correcta. <br><br>  Cuando una CPU inactiva se activa a trav√©s de una interrupci√≥n, ya sea un temporizador imparable u otro evento, el programador decide inmediatamente si hay trabajo.  Si hay trabajo, el temporizador se reinicia seg√∫n sea necesario.  Si no, se llama al controlador.  Como esto significa que ahora se puede llamar al regulador tanto cuando el temporizador est√° funcionando como cuando no est√° funcionando, se debe llamar al regulador para tener esto en cuenta. <br><br>  Despu√©s de estudiar la tabla de victorias y derrotas, Vysotsky cree que sus cambios mejorar√°n la imagen.  En el caso de predecir un largo per√≠odo de inactividad, el temporizador a√∫n se detiene, por lo que aqu√≠ no cambia nada;  ganamos si el tiempo de inactividad es largo y perdemos si es corto.  Pero si se predice un corto per√≠odo de inactividad, ganamos: si el per√≠odo realmente resulta ser corto, ahorraremos en detener e iniciar el temporizador, y si es largo, el temporizador sin parar nos despertar√° y nos dar√° la oportunidad de hacer otra predicci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/989/c12/2dc/989c122dcc3ec2c085e65f4e057c05a0.jpg"></div><br>  Dado que la teor√≠a de juegos no puede servir como un reemplazo completo para la situaci√≥n real, Vysotsky prob√≥ este enfoque en muchos sistemas.  El gr√°fico anterior es t√≠pico para todos los sistemas probados;  muestra la dependencia del tiempo del consumo de energ√≠a en un sistema inactivo.  La l√≠nea verde es el antiguo ciclo de inacci√≥n, la l√≠nea roja es el nuevo.  Seg√∫n el nuevo esquema, se consume menos energ√≠a, adem√°s, es m√°s predecible.  No todas las CPU probadas tuvieron una brecha tan grande entre las l√≠neas, sin embargo, todas mostraron una l√≠nea roja plana debajo de un verde desigual.  Como dijo Vysotsky, es menos probable que este nuevo esquema prediga per√≠odos cortos de inactividad, pero a menudo resulta ser correcto acerca de su corta duraci√≥n. <br><br>  Respondiendo una pregunta de la audiencia, Vysotsky dijo que este trabajo depende de la arquitectura.  En particular, los procesadores Intel se beneficiar√°n de √©l, ya que tienen una gran variedad de estados de inactividad de los cuales el regulador puede elegir el que le dar√° la mejor oportunidad de √©xito si la predicci√≥n es correcta;  pero los procesadores ARM tambi√©n se beneficiar√°n de los nuevos circuitos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/648/97d/331/64897d33160279143469c00ef7041157.png"></div><br>  Una ca√≠da del 20% en el consumo de energ√≠a cuando est√° inactivo puede parecer un logro insignificante, pero en realidad no lo es.  Cualquier sistema que quiera hacer frente bastante bien a las cargas m√°ximas debe tener una reserva de energ√≠a en modo normal, que se manifestar√° durante la inactividad.  El gr√°fico anterior muestra el uso del procesador para el a√±o en mi servidor, que se ocupa del correo, la transferencia de archivos, VPN, NTP, etc.  Amarillo significa tiempo simple.  A mi proveedor le gustar√≠a ahorrar un 20% de esta energ√≠a, y para el planeta ser√≠a mejor. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es427419/">https://habr.com/ru/post/es427419/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es427407/index.html">Meta-clustering con minimizaci√≥n de errores, y por qu√© creo que el cerebro funciona de esta manera</a></li>
<li><a href="../es427409/index.html">El libro "El √°gil brillante. Gesti√≥n de proyectos flexible con Agile, Scrum y Kanban ¬ª</a></li>
<li><a href="../es427413/index.html">Luchando por los recursos, parte 4: genial</a></li>
<li><a href="../es427415/index.html">Usamos Node.js para trabajar con archivos grandes y conjuntos de datos sin procesar.</a></li>
<li><a href="../es427417/index.html">Con humor sobre los disquetes de 8 pulgadas (en los a√±os 70 solo hab√≠a tales)</a></li>
<li><a href="../es427421/index.html">C√≥mo los sitios de genealog√≠a facilitan la captura de asesinos</a></li>
<li><a href="../es427423/index.html">City2Share: autos electr√≥nicos y aut√≥nomos en los centros log√≠sticos de Munich</a></li>
<li><a href="../es427427/index.html">C√≥mo llegan a TI: sobre pasantes y joons (el resultado de la encuesta "Mi c√≠rculo")</a></li>
<li><a href="../es427429/index.html">Marcos de GUI - por hilo</a></li>
<li><a href="../es427431/index.html">C√≥mo funciona Android, parte 4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>