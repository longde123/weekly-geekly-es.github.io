<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∂ üë©üèø‚Äçüöí üëêüèº Escribimos bajo FPGA sin HDL. Comparaci√≥n de herramientas de desarrollo de alto nivel. üë©üèæ‚Äçü§ù‚Äçüë®üèΩ ‚≠êÔ∏è üë©üèø‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente, los fabricantes de FPGA y compa√±√≠as de terceros han estado desarrollando activamente m√©todos de desarrollo para FPGA que difieren de lo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escribimos bajo FPGA sin HDL. Comparaci√≥n de herramientas de desarrollo de alto nivel.</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455668/">  Recientemente, los fabricantes de FPGA y compa√±√≠as de terceros han estado desarrollando activamente m√©todos de desarrollo para FPGA que difieren de los enfoques convencionales utilizando herramientas de desarrollo de alto nivel. <br><br>  Como desarrollador de FPGA, utilizo el lenguaje de descripci√≥n de hardware ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HDL</a> ) de Verilog como la herramienta principal, pero la creciente popularidad de los nuevos m√©todos despert√≥ mi gran inter√©s, por lo que en este art√≠culo decid√≠ entender lo que estaba sucediendo. <br><br>  Este art√≠culo no es una gu√≠a o instrucci√≥n de uso, esta es mi revisi√≥n y conclusiones sobre lo que varias herramientas de desarrollo de alto nivel pueden dar a un desarrollador o programador de FPGA que quiera sumergirse en el mundo de FPGA.  Para comparar las herramientas de desarrollo m√°s interesantes en mi opini√≥n, escrib√≠ varias pruebas y analic√© los resultados.  Debajo del corte, lo que sali√≥ de √©l. <br><a name="habracut"></a><br><h2>  ¬øPor qu√© necesita herramientas de desarrollo de alto nivel para FPGA? </h2><br><ul><li>  Acelerar el desarrollo del proyecto <br>  - debido a la reutilizaci√≥n de c√≥digo ya escrito en idiomas de alto nivel; <br>  - mediante el uso de todas las ventajas de los lenguajes de alto nivel, al escribir c√≥digo desde cero; <br>  - Al reducir el tiempo de compilaci√≥n y la verificaci√≥n del c√≥digo. <br></li><li>  Capacidad para crear c√≥digo universal que funcionar√° en cualquier familia FPGA. </li><li>  Reduzca el umbral de desarrollo para FPGA, por ejemplo, evitando los conceptos de "velocidad de reloj" y otras entidades de bajo nivel.  Capacidad para escribir c√≥digo para FPGA a un desarrollador que no est√© familiarizado con HDL. </li></ul><br><h2>  ¬øDe d√≥nde vienen las herramientas de desarrollo de alto nivel? </h2><br>  Ahora muchos se sienten atra√≠dos por la idea del desarrollo de alto nivel.  Ambos entusiastas, como, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Quokka</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el generador de c√≥digo Python</a> , y corporaciones, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mathworks</a> , y los fabricantes de FPGA <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Intel</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Xilinx</a> est√°n involucrados en esto. <br><br>  Todos usan sus m√©todos y herramientas para lograr su objetivo.  Los entusiastas en la lucha por un mundo perfecto y hermoso usan sus lenguajes de desarrollo favoritos, como Python o C #.  Las corporaciones, que intentan complacer al cliente, ofrecen sus propias herramientas o las adaptan.  Mathworks ofrece su propia herramienta de codificaci√≥n HDL para generar c√≥digo HDL a partir de m-scripts y modelos Simulink, mientras que Intel y Xilinx ofrecen compiladores para el C / C ++ com√∫n. <br><br>  Por el momento, las empresas con importantes recursos financieros y humanos han logrado un mayor √©xito, mientras que los entusiastas est√°n algo retrasados.  Este art√≠culo estar√° dedicado a la consideraci√≥n del codificador HDL de producto de Mathworks y el compilador HLS de Intel. <br><br><div class="spoiler">  <b class="spoiler_title">¬øQu√© hay de Xilinx?</b> <div class="spoiler_text">  En este art√≠culo, no considero HIL de Xilinx, debido a las diferentes arquitecturas y sistemas CAD de Intel y Xilinx, lo que hace imposible hacer una comparaci√≥n inequ√≠voca de los resultados.  Pero quiero se√±alar que Xilinx HLS, como Intel HLS, proporciona un compilador C / C ++ y son conceptualmente similares. <br></div></div><br>  Comencemos comparando el codificador HDL de Mathworks y el Compilador Intel HLS, despu√©s de haber resuelto varios problemas usando diferentes enfoques. <br><br><h2>  Comparaci√≥n de herramientas de desarrollo de alto nivel. </h2><br><h3>  Prueba uno.  ‚ÄúDos multiplicadores y una sumadora‚Äù </h3><br>  La soluci√≥n a este problema no tiene valor pr√°ctico, pero es muy adecuada como primera prueba.  La funci√≥n toma 4 par√°metros, multiplica el primero con el segundo, el tercero con el cuarto y agrega los resultados de la multiplicaci√≥n.  Nada complicado, pero veamos c√≥mo nuestros sujetos lidian con esto. <br><br><h4>  Codificador HDL por Mathworks </h4><br>  Para resolver este problema, el script m tiene el siguiente aspecto: <br><br><pre><code class="matlab hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[out]</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TwoMultAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a,b,c,d)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a*b)</span></span></span><span class="hljs-function">+</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c*d)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre> <br>  Veamos qu√© nos ofrece Mathworks para convertir c√≥digo a HDL. <br><br>  No considerar√© el trabajo con HDL-codificador en detalle, me detendr√© solo en la configuraci√≥n que cambiar√© en el futuro para obtener diferentes resultados en FPGA, y los cambios de los cuales deber√° ser considerado por el programador de MATLAB que necesita ejecutar su c√≥digo en FPGA. <br><br>  Entonces, lo primero que debe hacer es establecer el tipo y el rango de valores de entrada.  No hay char, int, float, double familiares en FPGA.  La profundidad de bits del n√∫mero puede ser cualquiera, es l√≥gico elegirlo, en funci√≥n del rango de valores de entrada que planea utilizar. <br><br><img src="https://habrastorage.org/webt/yi/vt/rm/yivtrmsrseix9d6-r5ktf7q4i98.png" alt="imagen"><br>  <i>Figura 1</i> <br><br>  MATLAB verifica los tipos de variables, sus valores y selecciona los tama√±os de bits correctos para buses y registros, lo cual es realmente conveniente.  Si no hay problemas con la profundidad de bits y la escritura, puede pasar a los siguientes puntos. <br><br> <a href=""><img src="https://habrastorage.org/webt/hy/bw/zv/hybwzvt-w0xzsta5gkf-0oapcrq.png" alt="imagen"></a> <br>  <i>Figura 2</i> <br><br>  Hay varias pesta√±as en la Generaci√≥n de c√≥digo HDL donde puede elegir el idioma para convertir (Verilog o VHDL);  estilo de c√≥digo  nombres de se√±ales.  La pesta√±a m√°s interesante, en mi opini√≥n, es Optimizaci√≥n, y experimentar√© con ella, pero m√°s adelante, por ahora, dejemos todos los valores predeterminados y veamos qu√© sucede con el codificador HDL "listo para usar". <br><br>  Presione el bot√≥n Ejecutar y obtenga el siguiente c√≥digo: <br><br><pre> <code class="plaintext hljs">`timescale 1 ns / 1 ns module TwoMultAdd_fixpt (a, b, c, d, out); input [7:0] a; // ufix8 input [7:0] b; // ufix8 input [7:0] c; // ufix8 input [7:0] d; // ufix8 output [16:0] out; // ufix17 wire [15:0] TwoMultAdd_fixpt_mul_temp; // ufix16 wire [16:0] TwoMultAdd_fixpt_2; // ufix17 wire [15:0] TwoMultAdd_fixpt_mul_temp_1; // ufix16 wire [16:0] TwoMultAdd_fixpt_3; // ufix17 //HDL code generation from MATLAB function: TwoMultAdd_fixpt //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% // % // Generated by MATLAB 9.2 and Fixed-Point Designer 5.4 % // % //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% assign TwoMultAdd_fixpt_mul_temp = a * b; assign TwoMultAdd_fixpt_2 = {1'b0, TwoMultAdd_fixpt_mul_temp}; assign TwoMultAdd_fixpt_mul_temp_1 = c * d; assign TwoMultAdd_fixpt_3 = {1'b0, TwoMultAdd_fixpt_mul_temp_1}; assign out = TwoMultAdd_fixpt_2 + TwoMultAdd_fixpt_3; endmodule // TwoMultAdd_fixpt</code> </pre><br>  El c√≥digo se ve bien.  MATLAB entiende que escribir la expresi√≥n completa en una sola l√≠nea en Verilog es una mala pr√°ctica.  Crea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cables</a> separados para el multiplicador y el sumador, no hay nada de qu√© quejarse. <br><br>  Es alarmante que falte la descripci√≥n de los registros.  Esto sucedi√≥ porque no le preguntamos al HDL-codificador sobre esto, y dejamos todos los campos en la configuraci√≥n a sus valores predeterminados. <br><br>  Esto es lo que Quartus sintetiza a partir de dicho c√≥digo. <br><br><img src="https://habrastorage.org/webt/zf/af/ja/zfafjaezynolikraaha86gadp-e.png"><br>  <i>Figura 3</i> <br><br>  Sin problemas, todo fue seg√∫n lo planeado. <br><br>  En FPGA implementamos circuitos sincr√≥nicos, y todav√≠a me gustar√≠a ver los registros.  HDL-coder ofrece un mecanismo para colocar registros, pero d√≥nde ubicarlos depende del desarrollador.  Podemos colocar los registros en la entrada de los multiplicadores, en la salida de los multiplicadores frente al sumador, o en la salida del sumador. <br><br>  Para sintetizar los ejemplos, eleg√≠ la familia FPGA Cyclone V, donde se usan bloques DSP especiales con sumadores y multiplicadores incorporados para implementar operaciones aritm√©ticas.  El bloque DSP se ve as√≠: <br><br> <a href=""><img src="https://habrastorage.org/webt/zf/5s/bt/zf5sbts5ke1t_pw3dsmrc4uhtrc.png"></a> <br>  <i>Figura 4</i> <br><br>  El bloque DSP tiene registros de entrada y salida.  No es necesario intentar ajustar los resultados de la multiplicaci√≥n en el registro antes de la adici√≥n, esto solo violar√° la arquitectura (en ciertos casos, esta opci√≥n es posible e incluso necesaria).  Depende del desarrollador decidir c√≥mo manejar el registro de entrada y salida en funci√≥n de los requisitos de latencia y la frecuencia m√°xima requerida.  Decid√≠ usar solo el registro de salida.  Para que este registro se describa en el c√≥digo generado por el codificador HDL, en la pesta√±a Opciones del codificador HDL debe marcar la casilla de verificaci√≥n Registrar salida y reiniciar la conversi√≥n. <br><br>  Resulta el siguiente c√≥digo: <br><br><pre> <code class="plaintext hljs">`timescale 1 ns / 1 ns module TwoMultAdd_fixpt (clk, reset, clke_ena_i, a, b, c, d, clke_ena_o, out); input clk; input reset; input clke_ena_i; input [7:0] a; // ufix8 input [7:0] b; // ufix8 input [7:0] c; // ufix8 input [7:0] d; // ufix8 output clke_ena_o; output [16:0] out; // ufix17 wire enb; wire [16:0] out_1; // ufix17 wire [15:0] TwoMultAdd_fixpt_mul_temp; // ufix16 wire [16:0] TwoMultAdd_fixpt_2; // ufix17 wire [15:0] TwoMultAdd_fixpt_mul_temp_1; // ufix16 wire [16:0] TwoMultAdd_fixpt_3; // ufix17 reg [16:0] out_2; // ufix17 //HDL code generation from MATLAB function: TwoMultAdd_fixpt //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% // % // Generated by MATLAB 9.2 and Fixed-Point Designer 5.4 % // % //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% assign TwoMultAdd_fixpt_mul_temp = a * b; assign TwoMultAdd_fixpt_2 = {1'b0, TwoMultAdd_fixpt_mul_temp}; assign TwoMultAdd_fixpt_mul_temp_1 = c * d; assign TwoMultAdd_fixpt_3 = {1'b0, TwoMultAdd_fixpt_mul_temp_1}; assign out_1 = TwoMultAdd_fixpt_2 + TwoMultAdd_fixpt_3; assign enb = clke_ena_i; always @(posedge clk or posedge reset) begin : out_reg_process if (reset == 1'b1) begin out_2 &lt;= 17'b00000000000000000; end else begin if (enb) begin out_2 &lt;= out_1; end end end assign clke_ena_o = clke_ena_i; assign out = out_2; endmodule // TwoMultAdd_fixpt</code> </pre><br>  Como puede ver, el c√≥digo tiene diferencias fundamentales en comparaci√≥n con la versi√≥n anterior.  Siempre apareci√≥ un bloque, que es una descripci√≥n del registro (justo lo que quer√≠amos).  Para la operaci√≥n de siempre bloqueo, tambi√©n aparecieron las entradas del m√≥dulo clk (frecuencia de reloj) y reinicio (reinicio).  Se puede ver que la salida del sumador est√° bloqueada en el disparador descrito en siempre.  Tambi√©n hay un par de se√±ales de permiso ena, pero no son muy interesantes para nosotros. <br><br>  Veamos el diagrama que Quartus ahora sintetiza. <br><br><img src="https://habrastorage.org/webt/ro/we/px/rowepxxw-fun6ey4x2tpw4cfjyg.png"><br>  <i>Figura 5</i> <br><br>  Y nuevamente, los resultados son buenos y esperados. <br><br>  La siguiente tabla muestra la tabla de recursos utilizados; lo tenemos en cuenta. <br><br><img src="https://habrastorage.org/webt/_z/wy/lk/_zwylksweoc_mhrps-rqhwankbe.png"><br>  <i>Figura 6</i> <br><br>  Para esta primera b√∫squeda, Mathworks recibe un cr√©dito.  Todo no es complicado, predecible y con el resultado deseado. <br><br>  Describ√≠ en detalle un ejemplo simple, proporcion√© un diagrama de un bloque DSP y describ√≠ las posibilidades de usar la configuraci√≥n de uso de registro en HDL-codificador, que son diferentes de la configuraci√≥n "predeterminada".  Esto se hace por una raz√≥n.  Con esto me gustar√≠a enfatizar que incluso en un ejemplo tan simple, cuando se usa el codificador HDL, es necesario el conocimiento de la arquitectura FPGA y los fundamentos de los circuitos digitales, y la configuraci√≥n debe cambiarse conscientemente. <br><br><h4>  Compilador Intel HLS </h4><br>  Intentemos compilar c√≥digo con la misma funcionalidad escrita en C ++ y ver qu√© se sintetiza finalmente en FPGA utilizando el compilador HLS. <br><br>  Entonces el c√≥digo C ++ <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">component </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TwoMultAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> d)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a*b)+(c*d); }</code> </pre><br>  Eleg√≠ los tipos de datos para evitar el desbordamiento de las variables. <br><br>  Existen m√©todos avanzados para establecer profundidades de bits, pero nuestro objetivo es probar la capacidad de ensamblar funciones escritas en estilo C / C ++ bajo FPGA sin hacer ning√∫n cambio, todo listo para usar. <br><br>  Dado que el compilador HLS es una herramienta nativa de Intel, recopilamos el c√≥digo con un compilador especial y verificamos el resultado inmediatamente en Quartus. <br><br>  Veamos el circuito que Quartus sintetiza. <br><br><img src="https://habrastorage.org/webt/ra/wy/bg/rawybgvk1yirtlaxi5yfmqjk6mi.png"><br>  <i>Figura 7</i> <br><br>  El compilador cre√≥ registros en la entrada y salida, pero la esencia est√° oculta en el m√≥dulo contenedor.  Comenzamos a implementar el contenedor y ... vemos m√°s, m√°s y m√°s m√≥dulos anidados. <br><br>  La estructura del proyecto se ve as√≠. <br><br> <a href=""><img src="https://habrastorage.org/webt/x6/3x/pi/x63xpin-73wlqtuear-rhyhcpcy.png"></a> <br>  <i>Figura 8</i> <br><br>  Una pista obvia de Intel es "¬°no lo tengas en tus manos!".  Pero lo intentaremos, especialmente la funcionalidad no es complicada. <br><br>  En las entra√±as del √°rbol del proyecto | quartus_compile | TwoMultAdd: TwoMultAdd_inst | TwoMultAdd_internal: twomultadd_internal_inst | TwoMultAdd_fu <br>  nction_wrapper: TwoMultAdd_internal | TwoMultAdd_function: theTwoMultAdd_function | bb_TwoMultAdd_B1_start: <br>  thebb_TwoMultAdd_B1_start | bb_TwoMultAdd_B1_start_stall_region: thebb_TwoMultAdd_B1_start_stall_region | i <br>  _sfc_c1_wt_entry_twomultadd_c1_enter_twomultadd: thei_sfc_c1_wt_entry_twomultadd_c1_enter_twomultad <br>  d_aunroll_x | i_sfc_logic_c1_wt_entry_twomultadd_c1_enter_twomultadd13: thei_sfc_logic_c1_wt_entry_twom <br>  ultadd_c1_enter_twomultadd13_aunroll_x | Mult1 es el m√≥dulo que est√° buscando. <br><br>  Podemos ver el diagrama del m√≥dulo deseado sintetizado por Quartus. <br><br> <a href=""><img src="https://habrastorage.org/webt/4m/e8/_c/4me8_cxojdb6zyvo0mkvc-i7a60.png"></a> <br>  <i>Figura 9</i> <br><br>  ¬øQu√© conclusiones se pueden sacar de este esquema? <br><br>  Es evidente que sucedi√≥ algo que intentamos evitar al trabajar en MATLAB: se sintetiz√≥ el caso en la salida del multiplicador; esto no es muy bueno.  Se puede ver en el diagrama de bloques DSP (Figura 4) que solo hay un registro en su salida, lo que significa que cada multiplicaci√≥n tendr√° que hacerse en un bloque separado. <br><br>  La tabla de recursos utilizados muestra a qu√© conduce esto. <br><br><img src="https://habrastorage.org/webt/es/eu/tj/eseutjlsyur_gibiank94suhhca.png"><br>  <i>Figura 10</i> <br><br>  Compare los resultados con la tabla de codificador HDL (Figura 6). <br><br>  Si utiliza una mayor cantidad de registros que puede soportar, gastar preciosos bloques DSP en una funcionalidad tan simple es muy desagradable. <br><br>  Pero hay una gran ventaja en Intel HLS en comparaci√≥n con el codificador HDL.  Con la configuraci√≥n predeterminada, el compilador HLS desarroll√≥ un dise√±o s√≠ncrono en FPGA, aunque gast√≥ m√°s recursos.  Tal arquitectura es posible, est√° claro que Intel HLS est√° configurado para lograr el m√°ximo rendimiento y no para ahorrar recursos. <br><br>  Veamos c√≥mo se comportan nuestros sujetos con proyectos m√°s complejos. <br><br><h3>  La segunda prueba.  "Multiplicaci√≥n de matrices por elementos con la suma del resultado" </h3><br>  Esta funci√≥n es ampliamente utilizada en el procesamiento de im√°genes: el llamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"filtro matricial"</a> .  Lo vendemos con herramientas de alto nivel. <br><br><h4>  Codificador HDL por Mathwork </h4><br>  El trabajo comienza inmediatamente con una limitaci√≥n.  HDL Coder no puede aceptar funciones de matriz 2D como entradas.  Dado que MATLAB es una herramienta para trabajar con matrices, este es un duro golpe para todo el c√≥digo heredado, que puede convertirse en un problema grave.  Si el c√≥digo est√° escrito desde cero, esta es una caracter√≠stica desagradable que debe considerarse.  Por lo tanto, debe implementar todas las matrices en un vector e implementar las funciones teniendo en cuenta los vectores de entrada. <br><br>  El c√≥digo para la funci√≥n en MATLAB es el siguiente <br><br><pre> <code class="matlab hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[out]</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mhls_conv2_manually</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target,kernel)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(kernel)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mult</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">target</span></span></span><span class="hljs-function">.*</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kernel</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mult)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  El c√≥digo HDL generado result√≥ ser muy hinchado y contiene cientos de l√≠neas, por lo que no lo dar√© aqu√≠.  Veamos qu√© esquema sintetiza Quartus a partir de este c√≥digo. <br><br> <a href=""><img src="https://habrastorage.org/webt/6d/3z/cd/6d3zcdcx0yzcqp-ht6fhz_mtx2i.png"></a> <br>  <i>Figura 11</i> <br><br>  Este esquema parece fracasado.  Formalmente, est√° funcionando, pero supongo que funcionar√° a una frecuencia muy baja y dif√≠cilmente se puede usar en hardware real.  Pero cualquier suposici√≥n debe ser verificada.  Para hacer esto, colocaremos los registros en la entrada y salida de este circuito y con la ayuda de Timing Analyzer evaluaremos la situaci√≥n real.  Para llevar a cabo el an√°lisis, debe especificar la frecuencia de operaci√≥n deseada del circuito para que Quartus sepa qu√© esforzarse al cablear y, en caso de falla, proporcionar informes de violaciones. <br><br>  Establecemos la frecuencia en 100 MHz, veamos qu√© puede extraer Quartus del circuito propuesto. <br><br><img src="https://habrastorage.org/webt/r7/zv/xy/r7zvxygef12ws12mmyfwgxc0plk.png"><br>  <i>Figura 12</i> <br><br>  Se puede ver que result√≥ un poco: 33 MHz parecen fr√≠volos.  El retraso en la cadena de multiplicadores y sumadores es de aproximadamente 30 ns.  Para deshacerse de este "cuello de botella", debe utilizar el transportador: insertar registros despu√©s de las operaciones aritm√©ticas, reduciendo as√≠ la ruta cr√≠tica. <br><br>  El codificador HDL nos brinda esta oportunidad.  En la pesta√±a Opciones, puede establecer variables de canalizaci√≥n.  Dado que el c√≥digo en cuesti√≥n est√° escrito en el estilo MATLAB, no hay forma de canalizar las variables (excepto las variables mult y summ), lo que no nos conviene.  Es necesario insertar los registros en los circuitos intermedios ocultos en nuestro c√≥digo HDL. <br><br>  Adem√°s, la situaci√≥n con la optimizaci√≥n podr√≠a ser peor.  Por ejemplo, nada nos impide escribir c√≥digo <br><br><pre> <code class="matlab hljs">out = (sum(target.*kernel))/len;</code> </pre> <br>  Es bastante adecuado para MATLAB, pero nos priva por completo de la posibilidad de optimizar HDL. <br><br>  La siguiente salida es editar el c√≥digo a mano.  Este es un punto muy importante, ya que nos negamos a heredar y comenzamos a reescribir el script m, y NO en el estilo MATLAB. <br><br>  El nuevo c√≥digo es el siguiente <br><br><pre> <code class="matlab hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[out]</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mhls_conv2_manually</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target,kernel)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(kernel)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mult</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">target</span></span></span><span class="hljs-function">.*</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kernel</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_1</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zeros</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([1,(len/2)</span></span></span><span class="hljs-function">]); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_2</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zeros</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([1,(len/4)</span></span></span><span class="hljs-function">]); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_3</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zeros</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([1,(len/8)</span></span></span><span class="hljs-function">]); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function">=0:1:</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(len/2)</span></span></span><span class="hljs-function">-1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i+1)</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mult(i*2+1)</span></span></span><span class="hljs-function">+</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i*2+2)</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function">=0:1:</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(len/4)</span></span></span><span class="hljs-function">-1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i+1)</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(summ_1(i*2+1)</span></span></span><span class="hljs-function">+</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i*2+2)</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function">=0:1:</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(len/8)</span></span></span><span class="hljs-function">-1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i+1)</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(summ_2(i*2+1)</span></span></span><span class="hljs-function">+</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i*2+2)</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_3</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  En Quartus, recopilamos el c√≥digo generado por el HDL Coder.  Se puede ver que el n√∫mero de capas con primitivas ha disminuido, y el esquema se ve mucho mejor. <br><br> <a href=""><img src="https://habrastorage.org/webt/nd/7j/sr/nd7jsrm1hiursvzgredphpuvr7k.png"></a> <br>  <i>Figura 12</i> <br><br>  Con el dise√±o correcto de primitivas, la frecuencia crece casi 3 veces, hasta 88 MHz. <br><br><img src="https://habrastorage.org/webt/3z/4s/o3/3z4so3o-whcbn8jct8y-wtfsja4.png"><br>  <i>Figura 13</i> <br><br>  Ahora el toque final: en la configuraci√≥n de Optimizaci√≥n, especifique summ_1, summ_2 y summ_3 como elementos de la tuber√≠a.  Recopilamos el c√≥digo resultante en Quartus.  El esquema cambia de la siguiente manera: <br><br> <a href=""><img src="https://habrastorage.org/webt/cu/kr/ua/cukruasropyfoifoib6er-fhck4.png"></a> <br>  <i>Figura 14</i> <br><br>  La frecuencia m√°xima aumenta nuevamente y ahora su valor es de aproximadamente 195 MHz. <br><br><img src="https://habrastorage.org/webt/tl/gg/dd/tlggddvndao-cm0bavadgbuxx30.png"><br>  <i>Figura 15</i> <br><br>  ¬øCu√°ntos recursos en el chip tomar√°n tal dise√±o?  La Figura 16 muestra la tabla de recursos utilizados para el caso descrito. <br><br><img src="https://habrastorage.org/webt/vl/ju/io/vljuioe1zmgnc-zr-nxvyv0lawu.png"><br>  <i>Figura 16</i> <br><br>  ¬øQu√© conclusiones se pueden sacar despu√©s de considerar este ejemplo? <br><br>  La principal desventaja del codificador HDL es que es poco probable que use el c√≥digo MATLAB en su forma pura. <br>  No hay soporte para matrices como entradas de funci√≥n, el dise√±o del c√≥digo en el estilo MATLAB es mediocre. <br><br>  El principal peligro es la falta de registros en el c√≥digo generado sin configuraciones adicionales.  Sin estos registros, incluso habiendo recibido c√≥digo HDL que funciona formalmente sin errores de sintaxis, el uso de dicho c√≥digo en las realidades y desarrollos modernos es indeseable. <br><br>  Es aconsejable escribir inmediatamente el c√≥digo para la conversi√≥n a HDL.  En este caso, puede obtener resultados bastante aceptables en t√©rminos de velocidad e intensidad de recursos. <br><br>  Si es un desarrollador de MATLAB, no se apresure a hacer clic en el bot√≥n Ejecutar y compilar su c√≥digo bajo FPGA, recuerde que su c√≥digo se sintetizar√° en un circuito real.  =) <br><br><h4>  Compilador Intel HLS </h4><br>  Para la misma funcionalidad, escrib√≠ el siguiente c√≥digo C / C ++ <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">component </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">conv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *kernel)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mult_res[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> summl; summl = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; i++) { mult_res[i] = data[i] * kernel[i]; summl = summl+mult_res[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> summl/<span class="hljs-number"><span class="hljs-number">16</span></span>; }</code> </pre><br>  Lo primero que llama la atenci√≥n es la cantidad de recursos utilizados. <br><br><img src="https://habrastorage.org/webt/yg/t1/zq/ygt1zq3p67hkkly29pneur9x6bu.png"><br>  <i>Figura 17</i> <br><br>  Se puede ver en la tabla que solo se us√≥ 1 bloque DSP, por lo que algo sali√≥ mal y las multiplicaciones no se realizan en paralelo.  El n√∫mero de registros utilizados tambi√©n es sorprendente, e incluso la memoria est√° involucrada, pero dejaremos esto a la conciencia del compilador HLS. <br><br>  Vale la pena se√±alar que el compilador HLS ha desarrollado un sub√≥ptimo, utilizando una gran cantidad de recursos adicionales, pero sigue siendo un circuito de trabajo que, seg√∫n los informes de Quartus, funcionar√° a una frecuencia aceptable, y un fallo como el codificador HDL no lo har√°. <br><br><img src="https://habrastorage.org/webt/y-/wg/fa/y-wgfaigf6zgbaljoez__xzxuqm.png"><br>  <i>Figura 18</i> <br><br>  Intentemos mejorar la situaci√≥n.  ¬øQu√© se necesita para esto?  As√≠ es, cierra los ojos a la herencia y m√©tete en el c√≥digo, pero hasta ahora no es mucho. <br><br>  HLS tiene directivas especiales para optimizar el c√≥digo para FPGA.  Insertamos la directiva de desenrollado, que deber√≠a expandir nuestro bucle en paralelo: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> unroll for (int i = 0; i &lt; 16; i++) { mult_res[i] = data[i] * kernel[i]; }</span></span></code> </pre><br><br>  Veamos c√≥mo reaccion√≥ Quartus. <br><br><img src="https://habrastorage.org/webt/fi/7j/nk/fi7jnkhaoeals29m0pfk38shv70.png"><br>  <i>Figura 19</i> <br><br>  En primer lugar, preste atenci√≥n a la cantidad de bloques DSP: hay 16 de ellos, lo que significa que las multiplicaciones se realizan en paralelo. <br><br>  ¬°Hurra!  desenrollar funciona!  Pero ya es dif√≠cil soportar cu√°nto ha crecido la utilizaci√≥n de otros recursos.  El circuito se ha vuelto completamente ilegible. <br><br> <a href=""><img src="https://habrastorage.org/webt/vj/gs/tu/vjgstugdk5a661jnk281gys8-qo.png"></a> <br>  <i>Figura 20</i> <br><br>  Creo que esto se debi√≥ al hecho de que nadie le se√±al√≥ al compilador que los c√°lculos en n√∫meros de punto fijo son muy adecuados para nosotros, e honestamente implement√≥ todas las matem√°ticas de punto flotante en l√≥gica y registros.  Necesitamos explicarle al compilador qu√© se requiere de √©l, y para esto volvemos a sumergirnos en el c√≥digo. <br><br>  Con el fin de usar punto fijo, se implementan clases de plantilla. <br><br><img src="https://habrastorage.org/webt/0a/a8/dj/0aa8djn0cwvyf8tplhtay6lymdg.png"><br>  <i>Figura 21</i> <br><br>  Hablando en nuestras propias palabras, podemos usar variables cuya profundidad de bits se establece manualmente hasta un bit.  Para aquellos que escriben en HDL, no pueden acostumbrarse, pero los programadores de C / C ++ probablemente se aferrar√°n a sus ideas.  Profundidades de bits, como en MATLAB, en este caso, nadie lo dir√°, y el desarrollador mismo debe contar la cantidad de bits. <br><br>  Veamos c√≥mo se ve en la pr√°ctica. <br><br>  Editamos el c√≥digo de la siguiente manera: <br><br><pre> <code class="cpp hljs">component ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt; conv(ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt; *data, ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt; *kernel) { ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt;mult_res[<span class="hljs-number"><span class="hljs-number">16</span></span>]; ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">32</span></span>,<span class="hljs-number"><span class="hljs-number">32</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt;summl; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> unroll for (int i = 0; i &lt; 16; i++) { mult_res[i] = data[i] * kernel[i]; } for (int i = 0; i &lt; 16; i++) { summl = summl+mult_res[i]; } return summl/16; }</span></span></code> </pre><br>  Y en lugar de la espeluznante pasta de la Figura 20, obtenemos esta belleza: <br><br> <a href=""><img src="https://habrastorage.org/webt/kg/v0/ot/kgv0ot9el2l5a3u4wawqsbw4hli.png"></a> <br>  <i>Figura 22</i> <br><br>  Desafortunadamente, algo extra√±o contin√∫a sucediendo con los recursos utilizados. <br><br><img src="https://habrastorage.org/webt/my/dk/bk/mydkbkemq-dzzzhk53gky-zix00.png"><br>  <i>Figura 23</i> <br><br>  Pero una revisi√≥n detallada de los informes muestra que el m√≥dulo que nos interesa directamente parece m√°s que adecuado: <br><br> <a href=""><img src="https://habrastorage.org/webt/tn/t0/da/tnt0daffouamtkyozxnrnu_zoku.png"></a> <br>  <i>Figura 24</i> <br><br>  El gran consumo de registros y memoria de bloque est√° asociado con una gran cantidad de m√≥dulos perif√©ricos.  Todav√≠a no entiendo completamente el significado profundo de su existencia, y esto tendr√° que resolverse, pero el problema est√° resuelto.  En un caso extremo, puede cortar cuidadosamente un m√≥dulo que nos interese de la estructura general del proyecto, lo que nos salvar√° de los m√≥dulos perif√©ricos que devoran recursos. <br><br><h3>  La tercera prueba.  "Transici√≥n de RGB a HSV" </h3><br>  Comenzando a escribir este art√≠culo, no esperaba que fuera tan voluminoso.  Pero no puedo rechazar el tercero y el √∫ltimo en el marco de este art√≠culo, un ejemplo. <br><br>  En primer lugar, este es un ejemplo real de mi pr√°ctica, y fue por eso que comenc√© a buscar herramientas de desarrollo de alto nivel. <br><br>  En segundo lugar, a partir de los dos primeros ejemplos, podr√≠amos suponer que cuanto m√°s complejo es el dise√±o, peor son las herramientas de alto nivel para hacer frente a la tarea. <br><br>  Quiero demostrar que este juicio es err√≥neo y, de hecho, cuanto m√°s compleja es la tarea, m√°s se manifiestan las ventajas de las herramientas de desarrollo de alto nivel. <br><br>  El a√±o pasado, cuando trabajaba en uno de los proyectos, no me gust√≥ la c√°mara comprada en Aliexpress, es decir, los colores no estaban lo suficientemente saturados.  Una de las formas populares de variar la saturaci√≥n de color es cambiar del espacio de color RGB al espacio HSV, donde uno de los par√°metros es la saturaci√≥n.  Recuerdo c√≥mo abr√≠ la f√≥rmula de transici√≥n y respir√© profundamente ... Implementar tales c√°lculos en FPGA no es algo extraordinario, pero por supuesto tomar√° tiempo escribir el c√≥digo.  Entonces, la f√≥rmula para cambiar de RGB a HSV es la siguiente: <br><br><img src="https://habrastorage.org/webt/z_/6u/_t/z_6u_tufgvs_wkbknmisu_gtn1e.png"><br>  <i>Figura 25</i> <br><br>  La implementaci√≥n de tal algoritmo en FPGA no llevar√° d√≠as, sino horas, y todo esto debe hacerse con mucho cuidado debido a los detalles de HDL, y la implementaci√≥n en C ++ o en MATLAB tomar√°, creo, minutos. <br><br>  En C ++, puede escribir c√≥digo directamente en la frente y a√∫n as√≠ obtener un resultado funcional. <br>  Escrib√≠ la siguiente opci√≥n en C ++ <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">color_space</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> rh; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> gs; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> bv; }; <span class="hljs-function"><span class="hljs-function">component color_space </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rgb2hsv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(color_space rgb_0)</span></span></span><span class="hljs-function"> </span></span>{ color_space hsv; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> h,s,v,r,g,b; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> max_col, min_col; r = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(rgb_0.rh)/<span class="hljs-number"><span class="hljs-number">255</span></span>; g = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(rgb_0.gs)/<span class="hljs-number"><span class="hljs-number">255</span></span>; b = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(rgb_0.bv)/<span class="hljs-number"><span class="hljs-number">255</span></span>; max_col = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(r,g),b); min_col = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(r,g),b); <span class="hljs-comment"><span class="hljs-comment">// H if (max_col == min_col) h = 0; else if (max_col==r &amp;&amp; g&gt;=b) h = 60*((gb)/(max_col-min_col)); else if (max_col==r &amp;&amp; g&lt;b) h = 60*((gb)/(max_col-min_col))+360; else if (max_col==g) h = 60*((br)/(max_col-min_col))+120; else if (max_col==b) h = 60*((rg)/(max_col-min_col))+240; // S if (max_col == 0) s = 0; else { s = (1-(min_col/max_col))*100; } // V v = max_col*100; hsv.rh = static_cast&lt;char&gt;(h); hsv.gs = static_cast&lt;char&gt;(s); hsv.bv = static_cast&lt;char&gt;(v); return hsv; }</span></span></code> </pre><br>  Y Quartus implement√≥ con √©xito el resultado, como se puede ver en la tabla de recursos utilizados. <br><br><img src="https://habrastorage.org/webt/us/bs/qx/usbsqx6dg4ncv_kkefii6ul8msq.png"><br>  <i>Dibujo 26</i> <br><br>  La frecuencia es muy buena. <br><br><img src="https://habrastorage.org/webt/t-/tk/hd/t-tkhdxq-d1yr7uo28m5_k7sfaa.png"><br>  <i>Dibujo 27</i> <br><br>  Con el codificador HDL, las cosas son un poco m√°s complicadas. <br><br>  Para no inflar el art√≠culo, no proporcionar√© un script m para esta tarea, no deber√≠a causar dificultades.  Un script m escrito en la frente dif√≠cilmente se puede usar con √©xito, pero si edita el c√≥digo y especifica correctamente los lugares para la canalizaci√≥n, obtenemos un resultado funcional.  Esto, por supuesto, tomar√° varias decenas de minutos, pero no horas. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En C ++, tambi√©n es deseable establecer las directivas y traducir los c√°lculos a un punto fijo, lo que tambi√©n tomar√° muy poco tiempo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, al usar herramientas de desarrollo de alto nivel, ahorramos tiempo, y cuanto m√°s complicado sea el algoritmo, m√°s tiempo ahorrar√°; esto continuar√° hasta que nos encontremos con l√≠mites de recursos FPGA o l√≠mites de velocidad computacionales estrictos en los que debe abordar HDL.</font></font><br><br><h2>  Conclusi√≥n </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo que se puede decir en conclusi√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, el martillo dorado a√∫n no se ha inventado, pero existen herramientas adicionales que se pueden utilizar en el desarrollo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La principal ventaja de las herramientas de alto nivel, en mi opini√≥n, es la velocidad de desarrollo. Es una realidad obtener suficiente calidad en t√©rminos de tiempo, a veces un orden de magnitud menor que cuando se desarrolla utilizando HDL. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ante tales ventajas como usar c√≥digo heredado para FPGA y conectar programadores al desarrollo de FPGA sin preparaci√≥n preliminar, soy cauteloso. Para obtener resultados satisfactorios, deber√° abandonar muchas t√©cnicas de programaci√≥n familiares. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una vez m√°s, quiero se√±alar que este art√≠culo es solo una mirada superficial a las herramientas de desarrollo de alto nivel para FPGA.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El compilador HLS tiene grandes oportunidades para optimizaciones: pragmas, bibliotecas especiales con funciones optimizadas, descripciones de interfaz, muchos art√≠culos en Internet sobre "mejores pr√°cticas", etc. El chip MATLAB, que no se ha considerado, es la capacidad de generar directamente, por ejemplo, un filtro desde la GUI sin escribir una sola l√≠nea de c√≥digo, simplemente indicando las caracter√≠sticas deseadas, lo que acelera a√∫n m√°s el tiempo de desarrollo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQui√©n gan√≥ el estudio de hoy? Mi opini√≥n es el compilador Intel HLS. Genera un dise√±o funcional incluso a partir de c√≥digo no optimizado. Codificador de HDL sin an√°lisis cuidadoso y procesamiento de c√≥digo que me dar√≠a miedo usar. Tambi√©n quiero se√±alar que el codificador HDL es una herramienta bastante antigua, pero como s√©, no ha ganado un amplio reconocimiento. Pero HLS, aunque joven, est√° claro que los fabricantes de FPGA est√°n apostando por √©l, creo que veremos su mayor desarrollo y crecimiento en popularidad.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los representantes de Xilinx aseguran que el desarrollo e implementaci√≥n de herramientas de alto nivel es la √∫nica oportunidad en el futuro para desarrollar chips FPGA cada vez m√°s grandes. Las herramientas tradicionales simplemente no podr√°n hacer frente a esto, y Verilog / VHDL probablemente est√© destinado al ensamblador, pero esto es en el futuro. Y ahora tenemos en nuestras manos herramientas de desarrollo (con sus pros y sus contras), que debemos elegir en funci√≥n de la tarea. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øUsar√© herramientas de desarrollo de alto nivel en mi trabajo? M√°s bien, s√≠, ahora su desarrollo avanza a pasos agigantados, por lo que al menos debemos seguir el ritmo, pero no veo razones objetivas para abandonar inmediatamente el HDL.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Al final, quiero se√±alar una vez m√°s que en esta etapa del desarrollo de herramientas de dise√±o de alto nivel, el usuario no debe olvidar por un minuto que escribe un programa que no es ejecutable en el procesador, sino que crea un circuito con cables reales, disparadores y elementos l√≥gicos. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/455668/">https://habr.com/ru/post/455668/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455650/index.html">C√≥mo entrenamos una red neuronal para clasificar tornillos</a></li>
<li><a href="../455652/index.html">Aprendizaje profundo vs sentido com√∫n: desarrollar un bot de chat</a></li>
<li><a href="../455658/index.html">El legendario Intel Core i7-2600K: prueba de Sandy Bridge en 2019 (parte 3)</a></li>
<li><a href="../455662/index.html">Gran pantalla mec√°nica con mecanismo de leva como decodificador.</a></li>
<li><a href="../455666/index.html">Creaci√≥n de ventas salientes en una empresa de servicios de TI</a></li>
<li><a href="../455670/index.html">C√≥mo las impresoras 3D imprimen huesos, vasos sangu√≠neos y √≥rganos</a></li>
<li><a href="../455676/index.html">¬øEstall√≥ la burbuja de aprendizaje autom√°tico o el comienzo de un nuevo amanecer?</a></li>
<li><a href="../455678/index.html">En el camino de Sergey Pavlovich Korolev. Proyecto tripulado ruso moderno. Parte 1. "Federaci√≥n"</a></li>
<li><a href="../455682/index.html">¬øCu√°nto gastas en infraestructura? ¬øY c√≥mo ahorrar en esto?</a></li>
<li><a href="../455684/index.html">¬øPor qu√© realizamos un hackathon para probadores?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>