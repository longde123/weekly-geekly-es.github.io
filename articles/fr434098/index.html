<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👩‍👧‍👦 🚦 🏊 Post et pré-traitement CSS 🌞 💰 👩🏻‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour lecteur. Sur le chemin de l'apprentissage des mises en page, avez-vous appris le CSS et souhaitez-vous passer à autre chose? Alors à toi sous ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Post et pré-traitement CSS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434098/">  Bonjour lecteur.  Sur le chemin de l'apprentissage des mises en page, avez-vous appris le CSS et souhaitez-vous passer à autre chose?  Alors à toi sous chat.  Attention, beaucoup de code. <a name="habracut"></a><br><br>  Dans cet article, je passerai en revue les préprocesseurs et les postprocesseurs (s?). <br><br>  Je n'entrerai pas dans les détails sur CSS, ce qui implique que vous le connaissez déjà.  Je nommerai les classes en notation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BEM</a> .  De plus, je ne m'attarderai pas sur l'installation et la configuration de tout ce que j'écrirai, mais je laisserai néanmoins des liens que vous pourrez suivre et apprendre à le faire vous-même. <br><br>  Commençons par les préprocesseurs. <br><br><h2>  Préprocesseurs </h2><br>  Qu'est-ce qu'un préprocesseur hors contexte avec CSS?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vicki</a> connaît la réponse. <br><br>  Qu'est-ce qu'un préprocesseur dans le contexte de CSS?  Dans notre cas, le préprocesseur est un programme qui reçoit du code écrit dans la langue du préprocesseur pour l'entrée, et à la sortie nous obtenons du CSS que nous pouvons donner à notre navigateur. <br><br>  Quels sont les préprocesseurs?  Il y a plusieurs représentants, par exemple: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sass</a> (.sass, .scss), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Less</a> (.less) et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Stylys</a> (.stylus). <br>  Parmi les préprocesseurs, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PostCSS</a> (ou plutôt son analyseur SugarSS et son plugin PreCSS) peuvent être distingués séparément.  Pour l'avenir, je dirai que oui, PostCSS n'est pas seulement un post-processeur. <br><br>  Je ferai un examen sur l'exemple de Sass.  Plus précisément, sur sa nouvelle syntaxe - SCSS, car elle est plus proche de CSS que de l'ancienne syntaxe.  Commençons par les capacités ajoutées par les préprocesseurs qui ne sont pas en CSS et terminons par les problèmes en cours de résolution. <br><br><h3>  Les possibilités </h3><br><h4>  Variables </h4><br><pre><code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-id"><span class="hljs-selector-id">#fff</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: $color; <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: $color; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-number"><span class="hljs-number">#fff</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: <span class="hljs-number"><span class="hljs-number">#fff</span></span>; }</code> </pre> <br>  L'utilité des variables est difficile à surestimer.  Maintenant, vous pouvez donner des noms significatifs aux couleurs ($ tomato: rgb (255,99,71)), calculer des valeurs non pas à travers des constantes, mais à travers des variables (hauteur: $ body_height - $ footer_height) et bien plus encore.  Beaucoup peuvent affirmer qu'il existe des variables dans CSS.  Mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Can I Use</a> dit qu'il n'y a pas de support pour IE (et pour des raisons évidentes, ce n'est pas prévu). <br><br><h4>  Imbrication </h4><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.chat-area</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">40%</span></span>; &amp;__button { // &amp; -    (   &amp; = .chat-area) <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: inline-block; <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>:<span class="hljs-number"><span class="hljs-number">36px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; } } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.chat-area</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">40%</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.chat-area__button</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: inline-block; <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>:<span class="hljs-number"><span class="hljs-number">36px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.chat-area</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; }</code> </pre><br>  Au début de l'article, j'ai fait référence à BEM.  Dans cet exemple, l'élément avec la classe de zone de conversation est un bloc.  Dans le cas où il y a un besoin soudain de le renommer, il sera maintenant possible de le faire au même endroit, et cela devient une routine si plusieurs dizaines de sélecteurs sont tapés dans un fichier contenant le nom du bloc.  Je veux également noter qu'il s'agit d'une sorte de protection contre les fautes de frappe, car le nom du bloc est écrit une fois. <br><br><h4>  Mixins </h4><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">mixin</span></span> border-radius($radius) { <span class="hljs-selector-tag"><span class="hljs-selector-tag">-webkit-border-radius</span></span>: $<span class="hljs-selector-tag"><span class="hljs-selector-tag">radius</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">-moz-border-radius</span></span>: $<span class="hljs-selector-tag"><span class="hljs-selector-tag">radius</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">-ms-border-radius</span></span>: $<span class="hljs-selector-tag"><span class="hljs-selector-tag">radius</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">border-radius</span></span>: $<span class="hljs-selector-tag"><span class="hljs-selector-tag">radius</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.box</span></span> { @include border-radius(10px); } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.box</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">-webkit-border-radius</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">-moz-border-radius</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">-ms-border-radius</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">border-radius</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; }</code> </pre><br>  Les mixins sont l'un des sujets les plus difficiles à comprendre.  En gros, un mixin est une fonction qui prend des arguments et applique des règles qui dépendent de ces arguments à un sélecteur donné.  Dans cet exemple, le mixage border-radius a été appliqué au sélecteur .box <br><br><h4>  Fonctions supplémentaires </h4><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-id"><span class="hljs-selector-id">#202020</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">h1</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">h2</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">lighten</span></span>($color, 40%); } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">h1</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">h2</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-number"><span class="hljs-number">#868686</span></span>; }</code> </pre><br>  Fondamentalement, les nouvelles fonctionnalités facilitent le travail avec la couleur.  Par exemple, la fonction éclaircir - éclaircit la couleur du nombre spécifié de pour cent (l'opposé est la fonction assombrir). <br><br><h3>  Problèmes résolus </h3><br><h4>  Modularité </h4><br>  Le problème avec l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">importation</a> standard est qu'elle crée une demande supplémentaire au serveur, ce qui est une opération coûteuse.  Ce serait bien si l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">importation</a> insérait immédiatement tout le texte de l'import dans le fichier source, non? <br><br>  D'une manière ou d'une autre, il n'y avait pas de préprocesseurs auparavant et le problème devait être résolu d'une manière ou d'une autre.  Par exemple, vous pouvez écrire tout le code dans un fichier. <br><br><div class="spoiler">  <b class="spoiler_title">À quoi ça ressemble</b> <div class="spoiler_text"><pre> <code class="css hljs"> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">À quoi ça ressemble vraiment</b> <div class="spoiler_text"><pre> <code class="css hljs"> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* -  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  -  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span></code> </pre><br></div></div><br></div></div><br>  Cependant, nous avons des préprocesseurs et ils vont résoudre ce problème pour nous.  Le préprocesseur remplace l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">importation</a> standard et maintenant au lieu de demander le serveur, il insère l'importation dans le fichier source, comme je le voulais. <br><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"selector1"</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"selector2"</span></span>; //<span class="hljs-selector-tag"><span class="hljs-selector-tag">selector1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: white; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">selector2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: gold; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: gold; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: white; }</code> </pre><br>  Veuillez noter que les fichiers source ont été convertis en un seul.  Une demande au serveur pour la statique - une réponse. <br><br><h4>  Héritage </h4><br>  &lt;sarcasm&gt; Nous avons des classes, mais pas d'héritage, comment ça? &lt;/sarcasm&gt;.  Il est maintenant possible de sélectionner les soi-disant «sélecteurs de modèles» et de les étendre avec d'autres sélecteurs. <br><br><pre> <code class="css hljs">// <span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> %<span class="hljs-selector-tag"><span class="hljs-selector-tag">equal-heights</span></span> { //   <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>: <span class="hljs-number"><span class="hljs-number">100%</span></span>; } %<span class="hljs-selector-tag"><span class="hljs-selector-tag">message</span></span> { //   <span class="hljs-attribute"><span class="hljs-attribute">padding</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.success</span></span> { @extend %message; <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: green; } <span class="hljs-selector-class"><span class="hljs-selector-class">.error</span></span> { @extend %message; <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; } // <span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.success</span></span>, <span class="hljs-selector-class"><span class="hljs-selector-class">.error</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">padding</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.success</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: green; } <span class="hljs-selector-class"><span class="hljs-selector-class">.error</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; }</code> </pre><br>  La beauté des sélecteurs de modèles est qu'ils ne correspondent pas aux styles générés.  L'égaliseur de modèle% égal-hauteur n'était pas impliqué dans le code et n'a laissé aucune trace dans CSS.  Le message selector% s'est reflété sous la forme de règles pour les sélecteurs qui l'ont développé.  Vous pouvez hériter des sélecteurs ordinaires, mais il est préférable d’utiliser des sélecteurs de modèles afin qu’il n’y ait pas de déchets excessifs. <br><br><h4>  Formatage </h4><br>  Une fois le code écrit, il doit être formaté (compressé pour la production).  Vous pouvez le faire avec l'aide de collectionneurs comme webpack, ou vous pouvez utiliser des outils standard. <br><br>  Il existe 4 types de formatage dans Sass. <br><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">expanded</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: gold; <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: block; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">nested</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: gold; <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: block; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">compact</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: gold; <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: block; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">compressed</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span>{<span class="hljs-attribute"><span class="hljs-attribute">color</span></span>:gold;<span class="hljs-attribute"><span class="hljs-attribute">display</span></span>:block}<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span>{<span class="hljs-attribute"><span class="hljs-attribute">color</span></span>:red}</code> </pre><br>  étendu - Le plus similaire au code écrit par l'homme. <br>  imbriqué - Approximatif au format de l'ancienne syntaxe.  La lisibilité n'est pas perdue, mais c'est un problème hollywoodien. <br>  compact - Maintient toujours la lisibilité, mais avec difficulté.  Utile pour déterminer à l'oeil nu le nombre de sélecteurs d'un projet. <br>  compressé - Format déjà complètement illisible.  Tous les caractères pouvant être supprimés sont supprimés.  Convient pour alimenter le navigateur. <br><br><h3>  Postscript </h3><br>  Je n'ai pas compris certaines des fonctionnalités ajoutées par Sass.  Par exemple, des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">boucles</a> ou des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">caractéristiques d'opérateurs arithmétiques</a> .  Je vous les laisserai vous familiariser. <br><br><h2>  Post-processeurs </h2><br>  Après avoir traité des préprocesseurs, nous passons aux postprocesseurs. <br><br>  Dans le contexte de Css, le postprocesseur est essentiellement le même que le préprocesseur, mais l'entrée dans le postprocesseur ne reçoit pas de code écrit dans le langage du préprocesseur, mais également css.  Autrement dit, le postprocesseur est un programme à l'entrée duquel css est donné, et la sortie est css.  Il n'est pas très clair pourquoi cela est nécessaire. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">J'expliquerai</a> sur un exemple concret du fonctionnement de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PostCSS</a> - le seul représentant des post-processeurs dans le contexte du CSS. <br><br>  PostCSS prêt à l'emploi ne fait vraiment rien avec CSS.  Il retourne simplement le fichier qui lui a été donné en entrée.  Les changements commencent lorsque les plugins sont connectés à PostCSS. <br><br>  Le cycle complet de PostCSS peut être décrit comme suit: <br><br><ul><li>  Le fichier source est donné à l'entrée PostCSS et analysé. </li><li>  Le plugin 1 fait quelque chose </li><li>  ... </li><li>  Le plugin n fait quelque chose </li><li>  Le résultat est converti en chaîne et écrit dans le fichier de sortie. </li></ul><br>  Considérez les principaux plugins qui existent dans l'écosystème PostCSS <br><br><h3>  Plugins </h3><br><h4>  Autoprefixer </h4><br>  Ce plugin est si populaire que beaucoup de gens pensent qu'ils utilisent ce plugin mais n'utilisent pas PostCSS.  Ils ont tort. <br><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: flex } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: -webkit-box; <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: -webkit-flex; <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: -moz-box; <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: -ms-flexbox; <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: flex }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le préfixe automatique</a> ajoute des préfixes de navigateur à vos règles.  L'un des plugins les plus importants qui a commencé l'histoire de PostCSS avec rien de remplaçable.  Vous pourriez même dire qu'il est logique de mettre PostCss juste pour le plaisir de ce plugin. <br><br><h2>  Preset env </h2><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">custom</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">media</span></span> --med (width &lt;= <span class="hljs-number"><span class="hljs-number">50rem</span></span>); @<span class="hljs-keyword"><span class="hljs-keyword">media</span></span> (--med) { <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:hover</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">color-mod</span></span>(black alpha(54%)); } } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">media</span></span> (max-width: <span class="hljs-number"><span class="hljs-number">50rem</span></span>) { <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:hover</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rgba</span></span>(0, 0, 0, 0.54); } }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PostCSS Preset Env</a> ajoute des fonctionnalités qui ne sont discutées que dans les versions préliminaires des développeurs CSS.  Dans cet exemple, la directive @ custom-media a été implémentée, ainsi que la fonction color-mod.  Commencez à utiliser le CSS du futur dès aujourd'hui! <br><br><h4>  Modules CSS </h4><br>  Tous ces BEM ne sont pas pour vous, mais y a-t-il toujours un problème avec les conflits de nom de classe?  PostCSS propose alors une solution différente. <br><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.name</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: gray; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.Logo__name__SVK0g</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: gray; }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les modules CSS</a> modifient les noms de classe selon un certain modèle (tout est personnalisable).  Maintenant, nous ne connaissons pas à l'avance le nom de la classe, car il est déterminé dynamiquement.  Comment classer maintenant les éléments si on ne les connaît pas à l'avance?  En combinant PostCSS, Webpack et ES6, je peux offrir cette solution: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./style.css'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  import styles from './style.css'; // </span></span></code> </pre><br>  Maintenant, nous importons non seulement un fichier avec des styles (par exemple, dans le fichier React d'un composant) et nous substituons des valeurs que nous connaissions auparavant, mais nous importons un objet.  Les clés de cet objet seront les sélecteurs d'origine et les valeurs seront converties.  Autrement dit, dans cet exemple, styles ['name'] = 'Logo__name__SVK0g'. <br><br><h4>  Court </h4><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.icon</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">size</span></span>: <span class="hljs-number"><span class="hljs-number">48px</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.canvas</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-number"><span class="hljs-number">#abccfc</span></span> <span class="hljs-number"><span class="hljs-number">#212231</span></span>; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.icon</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">48px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>: <span class="hljs-number"><span class="hljs-number">48px</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.canvas</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-number"><span class="hljs-number">#abccfc</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">background-color</span></span>: <span class="hljs-number"><span class="hljs-number">#212231</span></span>; }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PostCSS Short</a> ajoute un tas d'entrées raccourcies pour diverses règles.  Le code se raccourcit et il y a donc moins de place pour les erreurs.  Plus augmente la lisibilité. <br><br><h4>  Réinitialisation automatique </h4><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">margin</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: blue; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">all</span></span>: initial; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">margin</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: blue; }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PostCSS Auto Reset</a> nous permet de ne pas créer de fichier séparé avec une réinitialisation de tous les styles.  Le plugin crée un grand sélecteur pour tous les sélecteurs, où il place les règles, réinitialisant tous les styles.  Par défaut, seule la règle all est créée avec la valeur initiale.  Ceci est utile en combinaison avec le plugin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">postcss-initial</a> , qui à son tour transforme cette règle en un sac de règles pour 4 écrans.  Cependant, tout peut être configuré et réinitialisé par exemple comme ceci: <br><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">margin</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">padding</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">margin</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: blue; }</code> </pre><br>  Rappelez-vous au début de l'article, j'ai dit que PostCSS n'est pas seulement un post-processeur? <br><br><h3>  PostCSS - préprocesseur? </h3><br>  Considérez un analyseur et un plugin, après quoi vous changerez votre opinion actuelle sur PostCSS. <br><br><h4>  Sugararss </h4><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.sss</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">white</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> &gt; <span class="hljs-selector-class"><span class="hljs-selector-class">.child</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">black</span></span> //<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: white } <span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> &gt; <span class="hljs-selector-class"><span class="hljs-selector-class">.child</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: black }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SugarSS</a> est un analyseur (pas un plugin!), Qui est basé sur l' <u>indentation</u> , et non sur les accolades, en standard.  Il a une extension séparée ".sss".  Le code écrit à l'aide de SugarSS est similaire dans le style à l'ancienne syntaxe Sass, mais sans ses lotions comme les variables, les mixins, l'héritage, etc. <br><br>  Vous avez deviné ce que le prochain plugin va ajouter? <br><br><h4>  Precss </h4><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.sss</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">black</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.child</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span> //  <span class="hljs-selector-tag"><span class="hljs-selector-tag">SugarSS</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">black</span></span>; <span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> { .child { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: $color } } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.child</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: black }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PreCSS</a> ajoute simplement les capacités mêmes des préprocesseurs qui sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">décrites</a> dans la première moitié de l'article. <br><br>  Et pourquoi PostCSS n'est-il pas un préprocesseur maintenant? <br><br><h3>  Stylelint </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Beaucoup</a> a déjà été <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">écrit</a> sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Stylelint</a> .  Il est entré dans cette revue car il utilise PostCSS comme analyseur de lignes de fichiers CSS.  Supposons que nous ayons un tel fichier. <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rgb</span></span>(1, 1, 1) } <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rgb</span></span>(0, 0, 0) }</code> </pre><br>  Voici sa sortie pour le fichier actuel: <br><br><pre> <code class="plaintext hljs"> 2:21 Expected a trailing semicolon declaration-block-trailing-semicolon 6:21 Expected a trailing semicolon declaration-block-trailing-semicolon 7:1 Unexpected missing end-of-source newline no-missing-end-of-source-newline</code> </pre><br>  L'utilité de cet outil est assez difficile à surestimer. <br><br><h2>  Conclusions </h2><br>  Les préprocesseurs ajoutent beaucoup de nouvelles fonctionnalités qui ne sont pas en CSS.  Une fois que vous l'essayez, vous ne reviendrez guère au CSS standard. <br><br>  PostCSS est beaucoup plus proche du CSS d'origine que les préprocesseurs, mais néanmoins, avec certains plugins connectés, il peut avoir la même fonctionnalité (et même une syntaxe similaire).  Les compositeurs débutants peuvent composer sans même penser que les mises en page ne sont pas en CSS pur.  Certains plugins (par exemple Autoprefixer) n'ont pas d'analogues dans le monde du préprocesseur. <br><br>  Personne ne prend la peine d'utiliser des préprocesseurs et PostCSS conjointement.  L'option est assez bonne pour les projets qui utilisent déjà des préprocesseurs et ont un lieu de vie. <br><br>  Pour les nouveaux projets, je recommanderais d'utiliser uniquement PostCSS.  Les concepteurs de mise en page sont habitués à la syntaxe du préprocesseur?  Installez le plugin PreCSS et l'analyseur SugarSS.  Besoin d'une compatibilité multi-navigateur?  Installez le plugin Autoprefixer.  La compatibilité entre navigateurs n'est plus nécessaire (par exemple, votre projet a été enveloppé dans un électron et il est devenu un ordinateur de bureau)?  Désinstallez simplement Autoprefixer!  Avec PostCSS, vous pouvez, comme avec le constructeur, construire exactement ce dont votre projet a besoin. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr434098/">https://habr.com/ru/post/fr434098/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr434086/index.html">Déploiement intégré Windows et Linux</a></li>
<li><a href="../fr434088/index.html">Comment aider les employés distants à éviter la solitude et l'épuisement professionnel</a></li>
<li><a href="../fr434090/index.html">Présentation d'un transistor à vide: un appareil fabriqué à partir de vide</a></li>
<li><a href="../fr434092/index.html">Les gens qui ont sauvé 1968</a></li>
<li><a href="../fr434096/index.html">Heisenbug 2018 Moscou: une vue de la foule</a></li>
<li><a href="../fr434100/index.html">Présentation de l'imprimante 3D Anet A6 et Anet A8</a></li>
<li><a href="../fr434102/index.html">Animation magnifique et informative: cas de mouvements circulaires et de vibrations</a></li>
<li><a href="../fr434104/index.html">Masse VHF ou démystification d'antennes carrées doubles / triples</a></li>
<li><a href="../fr434106/index.html">Faites confiance aux SDK mobiles</a></li>
<li><a href="../fr434110/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 344 (17-23 décembre 2018)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>