<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐧 ⛵️ 🌍 Jika data tidak sesuai dengan memori. Metode paling sederhana 🤙🏽 ⛪️ 😟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aardvark betina dengan cub. Foto: Scotto Bear , CC BY-SA 2.0 

 Anda menulis sebuah program untuk pemrosesan data, ia lulus tes dengan sempurna pada f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jika data tidak sesuai dengan memori. Metode paling sederhana</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dcmiran/blog/479282/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d9/123/a92/6d9123a92cd8eaa7935353ab9ed3f029.jpg"></div><br>  <i><font color="gray">Aardvark betina dengan cub.</font></i>  <i><font color="gray">Foto: <a href="">Scotto Bear</a> , CC BY-SA 2.0</font></i> <br><br>  Anda menulis sebuah program untuk pemrosesan data, ia lulus tes dengan sempurna pada file kecil, tetapi crash pada beban nyata. <br><br>  Masalahnya adalah kehabisan memori.  Jika Anda memiliki RAM 16 gigabyte, Anda tidak akan dapat mengunduh file seratus gigabyte di sana.  Pada titik tertentu, OS akan kehabisan memori, tidak akan dapat mengalokasikan yang baru, dan program akan macet. <br><br>  Apa yang harus dilakukan <br><a name="habracut"></a><br>  Nah, Anda bisa menggunakan cluster Big Data, cukup: <br><br><ul><li>  Temukan sekelompok komputer. <br></li><li>  Atur dalam seminggu. <br></li><li>  Pelajari API baru dan tulis ulang kode Anda. </li></ul><br>  Itu mahal dan tidak menyenangkan.  Untungnya, seringkali tidak perlu. <br><br>  <b>Kami membutuhkan solusi sederhana dan mudah: untuk memproses data pada satu komputer, dengan pengaturan minimal dan penggunaan maksimum perpustakaan yang sudah terhubung.</b>  Ini hampir selalu mungkin dengan bantuan metode paling sederhana, kadang-kadang disebut komputasi out-of-core. <br><br>  Pada artikel ini kita membahas: <br><br><ul><li>  Mengapa kita membutuhkan RAM sama sekali. <br></li><li>  Cara termudah untuk memproses data yang tidak sesuai dengan memori adalah menghabiskan sedikit uang. <br></li><li>  Tiga metode perangkat lunak utama untuk memproses jumlah data yang berlebihan: kompresi, pemblokiran, dan pengindeksan. </li></ul><br>  Artikel mendatang akan menunjukkan dalam praktiknya bagaimana menerapkan metode ini dengan perpustakaan tertentu seperti NumPy dan Panda.  Tapi pertama-tama, teorinya. <br><br><h2>  Mengapa RAM diperlukan? </h2><br>  Sebelum kita membahas solusi, mari kita perjelas mengapa masalah ini ada.  Anda dapat menulis data ke memori akses acak (RAM), tetapi juga ke hard drive Anda, jadi mengapa Anda perlu RAM?  Disk lebih murah, biasanya tidak memiliki masalah dengan ruang yang terbatas, mengapa tidak membatasi diri Anda untuk membaca dan menulis dari disk? <br><br>  Secara teoritis, ini mungkin berhasil.  Tetapi bahkan SSD cepat modern bekerja <a href="https://people.eecs.berkeley.edu/~rcs/research/interactive_latency.html">banyak, jauh lebih lambat</a> daripada RAM: <br><br><ul><li>  Baca dari SSD: ~ 16.000 nanodetik <br></li><li>  Baca dari RAM: ~ 100 nanodetik </li></ul><br>  Untuk perhitungan cepat, kami tidak punya pilihan: data harus ditulis ke RAM, jika tidak, kode akan melambat 150 kali. <br><br><h2>  Solusi termudah: lebih banyak RAM </h2><br>  Solusi termudah untuk masalah kehabisan RAM adalah menghabiskan uang.  Anda dapat membeli komputer yang kuat, server atau menyewa mesin virtual dengan banyak memori.  Pada November 2019, pencarian cepat dan perbandingan harga yang sangat singkat memberikan opsi berikut: <br><br><ul><li>  <b>Beli</b> Thinkpad M720 Tower dengan 6 core dan 64 GB RAM seharga $ 1074 <br></li><li>  <b>Sewa</b> mesin virtual di cloud dengan 64 core dan RAM 432 GB untuk $ 3,62 / jam </li></ul><br>  Ini hanya angka setelah pencarian cepat.  Setelah melakukan penelitian yang baik, Anda pasti akan menemukan penawaran yang lebih baik. <br><br>  <b>Menghabiskan sedikit uang pada perangkat keras untuk memasukkan data ke dalam RAM seringkali merupakan solusi termurah.</b>  <b>Lagipula, waktu kita mahal.</b>  Tetapi terkadang ini tidak cukup. <br><br>  Misalnya, jika Anda melakukan banyak tugas pemrosesan data selama periode waktu tertentu, komputasi awan dapat menjadi solusi alami, tetapi juga bisa mahal.  Pada salah satu proyek kami, biaya komputasi seperti itu akan menghabiskan semua pendapatan yang diproyeksikan dari produk, termasuk pendapatan paling penting yang diperlukan untuk membayar gaji saya. <br><br>  <b>Jika membeli / menyewa sejumlah besar RAM tidak menyelesaikan masalah atau tidak mungkin, langkah selanjutnya adalah mengoptimalkan aplikasi itu sendiri sehingga menghabiskan lebih sedikit memori.</b> <br><br><h2>  Teknik nomor 1. Kompresi </h2><br>  Kompresi memungkinkan Anda untuk memasukkan data yang sama dalam memori lebih sedikit.  Ada dua bentuk kompresi: <br><br><ul><li>  <b>Lossless</b> : setelah kompresi, informasi yang persis sama disimpan seperti dalam data asli. <br></li><li>  <b>Rugi</b> : data yang disimpan kehilangan beberapa detail, tetapi idealnya ini tidak terlalu mempengaruhi hasil perhitungan. </li></ul><br>  Hanya untuk kejelasan, ini bukan tentang file zip atau gzip ketika data dikompres <i>pada disk</i> .  Untuk memproses data dari file ZIP, Anda biasanya perlu unzip, dan kemudian memuat file ke dalam memori.  Jadi ini tidak akan membantu. <br><br>  <b>Yang kita butuhkan adalah kompresi representasi data dalam <i>memori</i> .</b> <br><br>  Misalkan data Anda hanya menyimpan dua nilai yang mungkin, dan tidak ada yang lain: <code>"AVAILABLE"</code> dan <code>"UNAVAILABLE"</code> <code>"AVAILABLE"</code> <code>"UNAVAILABLE"</code> .  Alih-alih menyimpan string dengan 10 byte atau lebih per catatan, Anda dapat menyimpannya sebagai nilai Boolean <code>True</code> atau <code>False</code> , yang dikodekan hanya satu byte.  Anda dapat memampatkan informasi bahkan menjadi satu bit, mengurangi konsumsi memori sebanyak delapan kali. <br><br><h2>  Teknik No. 2. Membelah menjadi blok, memuat data satu blok pada suatu waktu </h2><br>  Fragmentasi berguna dalam situasi di mana data tidak harus dimuat ke memori pada saat bersamaan.  Sebagai gantinya, kita dapat memuatnya dalam beberapa bagian, memproses satu fragmen pada satu waktu (atau, seperti yang akan kita bahas di artikel berikutnya, beberapa bagian secara paralel). <br><br>  Misalkan Anda ingin menemukan kata terbesar dalam sebuah buku.  Anda dapat memuat semua data ke dalam memori sekaligus: <br><br><pre> <code class="python hljs">largest_word = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> word <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> book.get_text().split(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(word) &gt; len(largest_word): largest_word = word</code> </pre> <br>  Tetapi jika buku itu tidak sesuai dengan memori, Anda dapat memuatnya halaman demi halaman: <br><br><pre> <code class="python hljs">largest_word = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> page <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> book.iterpages(): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> word <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> page.get_text().split(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(word) &gt; len(largest_word): largest_word = word</code> </pre> <br>  Ini sangat mengurangi konsumsi memori karena hanya satu halaman buku dimuat sekaligus.  Dalam hal ini, hasilnya akan menjadi jawaban yang sama. <br><br><h2>  Teknik No. 3. Pengindeksan hanya jika diperlukan subset data </h2><br>  Pengindeksan berguna jika Anda ingin menggunakan hanya sebagian dari data dan Anda akan memuat subset yang berbeda pada waktu yang berbeda. <br><br>  Pada prinsipnya, dalam situasi seperti itu, Anda dapat menyaring bagian yang diperlukan dan membuang yang tidak perlu.  Tetapi penyaringan lambat dan tidak optimal, karena Anda harus memuat banyak data tambahan ke dalam memori sebelum menjatuhkannya. <br><br>  <b>Jika Anda hanya memerlukan sebagian data, alih-alih fragmentasi, lebih baik menggunakan indeks - <i>pemerasan</i> data yang menunjukkan lokasi sebenarnya.</b> <br><br>  Bayangkan Anda hanya ingin membaca bagian-bagian dari sebuah buku yang menyebutkan aardvark (mamalia imut di foto di awal artikel).  Jika Anda memeriksa semua halaman secara bergantian, seluruh buku akan dimuat dalam bagian, halaman demi halaman, untuk mencari aardvarks - dan ini akan memakan banyak waktu. <br><br>  Atau Anda dapat segera membuka indeks alfabet di akhir buku - dan menemukan kata "aardvark".  Ini menyatakan bahwa kata tersebut disebutkan pada halaman 7, 19 dan 120-123.  Sekarang Anda dapat membaca halaman-halaman ini, dan hanya mereka, yang jauh lebih cepat. <br><br>  Ini adalah metode yang efektif karena indeksnya jauh lebih kecil dari keseluruhan buku, jadi lebih mudah memuat indeks saja ke dalam memori untuk menemukan data yang relevan. <br><br><h4>  Metode pengindeksan termudah </h4><br>  Cara termudah dan paling umum untuk mengindeks adalah menamai file dalam direktori: <br><br><pre> <code class="plaintext hljs">mydata/ 2019-Jan.csv 2019-Feb.csv 2019-Mar.csv 2019-Apr.csv ...</code> </pre> <br>  Jika Anda memerlukan data untuk Maret 2019, Anda cukup mengunggah file <code>2019-Mar.csv</code> - tidak perlu mengunduh data untuk Februari, Juli atau bulan lainnya. <br><br><h2>  Berikutnya: menerapkan metode ini </h2><br>  Masalah kurangnya RAM paling mudah diselesaikan dengan bantuan uang, setelah membeli RAM.  Tetapi jika ini tidak mungkin atau tidak cukup, Anda akan tetap menggunakan kompresi, fragmentasi, atau pengindeksan. <br><br>  <b>Metode yang sama digunakan dalam berbagai paket dan alat perangkat lunak</b> .  Bahkan sistem Big Data berkinerja tinggi dibangun di atasnya: misalnya, pemrosesan paralel fragmen data individual. <br><br>  Dalam artikel berikut, kita akan melihat bagaimana menerapkan metode ini di perpustakaan dan alat tertentu, termasuk NumPy dan Panda. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id479282/">https://habr.com/ru/post/id479282/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id479270/index.html">Apa yang baru dapat Anda harapkan dari Node.js pada tahun 2020?</a></li>
<li><a href="../id479272/index.html">[bookmark] 9 alat yang meningkatkan produktivitas pengembang web</a></li>
<li><a href="../id479274/index.html">10 Trik Python untuk Diketahui</a></li>
<li><a href="../id479276/index.html">Tiga Metode Pandas yang Mungkin Tidak Anda Ketahui</a></li>
<li><a href="../id479278/index.html">Seratus hingga lima ratus digit angka pi di lutut</a></li>
<li><a href="../id479284/index.html">Rumah yang dibangun robot</a></li>
<li><a href="../id479286/index.html">Menulis aplikasi web sederhana menggunakan Spring MVC, Spring Data JPA dan Hibernate</a></li>
<li><a href="../id479288/index.html">Mengapa menerapkan Service Desk dan bagaimana memilih solusi untuk perusahaan Anda</a></li>
<li><a href="../id479290/index.html">Algoritma untuk mencari volume dan pusat massa polihedron</a></li>
<li><a href="../id479292/index.html">Bagaimana cara mengajar jaringan saraf untuk mereproduksi fisika game</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>