<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¾â€ğŸ“ ğŸšï¸ ğŸ’ Tes otomatis UI: cara melakukannya tidak sepadan ğŸ˜ˆ ğŸ‘¨ğŸ¿â€ğŸ¨ ğŸ‘°ğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo Habr. Nama saya Vitaliy Kotov, saya bekerja di departemen pengujian Badoo. Saya menulis banyak tes otomatis UI, tetapi saya bekerja lebih banyak ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tes otomatis UI: cara melakukannya tidak sepadan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/419419/">  Halo Habr.  Nama saya Vitaliy Kotov, saya bekerja di departemen pengujian Badoo.  Saya menulis banyak tes otomatis UI, tetapi saya bekerja lebih banyak dengan mereka yang telah melakukan ini belum lama ini dan belum berhasil menginjak semua garu. <br><br>  Jadi, setelah menambahkan pengalaman dan pengamatan saya sendiri terhadap orang lain, saya memutuskan untuk menyiapkan bagi Anda kumpulan "cara menulis tes tidak sepadan".  Saya mendukung setiap contoh dengan uraian terperinci, contoh kode, dan tangkapan layar. <br><br>  Artikel ini akan menarik bagi para penulis pemula tes UI, tetapi orang-orang tua dalam topik ini mungkin akan mempelajari sesuatu yang baru, atau hanya tersenyum, mengingat diri mereka sendiri "di masa muda mereka".  :) <br><br>  Ayo pergi! <br><br><img width="651" src="https://habrastorage.org/webt/gn/un/vn/gnunvna-dpyr8dzj9gwsh-xinlm.jpeg"><br><br><a name="habracut"></a><br><h2>  Isi </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pelacak tanpa atribut</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Periksa item yang hilang</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Periksa item</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Data acak</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Atomicity tes (bagian 1)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Atomitas pengujian (bagian 2)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kesalahan mengklik item yang ada</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Teks salah</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ringkasan</a> </li></ul><a name="locators"></a><br><h2>  Pelacak tanpa atribut </h2><br>  Mari kita mulai dengan contoh sederhana.  Karena kita berbicara tentang tes UI, pelacak memainkan peran penting di dalamnya.  Locator adalah garis yang disusun berdasarkan aturan tertentu dan menjelaskan satu atau lebih elemen XML (khususnya HTML). <br><br>  Ada beberapa jenis pelacak.  Misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pencari css</a> digunakan untuk lembar gaya kaskade.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pelacak XPath</a> digunakan untuk bekerja dengan dokumen XML.  Dan sebagainya. <br><br>  Daftar lengkap jenis pelacak yang digunakan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Selenium</a> dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seleniumhq.github.io</a> . <br><br>  Dalam pengujian UI, pelacak digunakan untuk menggambarkan elemen-elemen yang dengannya pengemudi harus berinteraksi. <br><br>  Di hampir semua inspektur browser, dimungkinkan untuk memilih elemen yang menarik bagi kami dan menyalin XPath-nya.  Itu terlihat seperti ini: <br><br><img width="650" src="https://habrastorage.org/webt/mw/oi/fz/mwoifzz6ukpjltmexvq6sasxw2c.png"><br><br>  Ternyata pelacak seperti itu: <br><br> <code>/html/body/div[3]/div[1]/div[2]/div/div/div[2]/div[1]/a <br></code> <br>  Tampaknya tidak ada yang salah dengan pencari lokasi seperti itu.  Bagaimanapun, kita dapat menyimpannya dalam konstanta atau bidang kelas, yang dengan namanya akan menyampaikan esensi elemen: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FindBy</span></span>(xpath = <span class="hljs-string"><span class="hljs-string">"/html/body/div[3]/div[1]/div[2]/div/div/div[2]/div[1]/a"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> WebElement createAccountButton;</code> </pre><br>  Dan bungkus teks kesalahan yang sesuai jika elemen tidak ditemukan: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waitForCreateAccountButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ By by = By.xpath(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createAccountButton); WebDriverWait wait = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebDriverWait(driver, timeoutInSeconds); wait .withMessage(â€œCannot find Create Account button.â€) .until( ExpectedConditions.presenceOfElementLocated(by) ); }</code> </pre><br>  Pendekatan ini memiliki nilai tambah: tidak perlu mempelajari XPath. <br><br>  Namun, ada sejumlah kelemahan.  Pertama, ketika mengubah tata letak tidak ada jaminan bahwa elemen pada locator akan tetap sama.  Mungkin saja orang lain akan menggantikannya, yang akan mengarah pada keadaan yang tidak terduga.  Kedua, tugas autotest adalah mencari bug, dan tidak memantau perubahan tata letak.  Oleh karena itu, penambahan beberapa pembungkus atau beberapa elemen lain yang lebih tinggi di pohon seharusnya tidak mempengaruhi pengujian kami.  Kalau tidak, kami butuh cukup banyak waktu untuk memperbarui lokasi. <br><br>  Kesimpulan: Anda harus membuat pencari lokasi yang menggambarkan elemen dengan benar dan tahan terhadap perubahan tata letak di luar bagian yang diuji dari aplikasi kami.  Misalnya, Anda dapat mengikat ke satu atau beberapa atribut elemen: <br><br> <code>//a[@rel=â€createAccountâ€] <br></code> <br>  Pencari seperti itu lebih mudah dilihat dalam kode, dan itu akan rusak hanya jika "rel" menghilang. <br><br>  Kelebihan lain dari locator tersebut adalah kemampuan untuk mencari di repositori template dengan atribut yang ditentukan.  Tetapi apa yang harus dicari jika locator terlihat seperti dalam contoh aslinya?  :) <br><br>  Jika pada awalnya dalam aplikasi elemen tidak memiliki atribut atau mereka diatur secara otomatis (misalnya, karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kebingungan</a> kelas), ini layak untuk didiskusikan dengan pengembang.  Mereka seharusnya tidak kurang tertarik dalam mengotomatisasi pengujian produk dan pasti akan bertemu dengan Anda dan menawarkan solusi. <br><a name="no_element"></a><br><h2>  Periksa item yang hilang </h2><br>  Setiap pengguna Badoo memiliki profilnya sendiri.  Ini berisi informasi tentang pengguna: (nama, umur, foto) dan informasi tentang dengan siapa pengguna ingin mengobrol.  Selain itu, dimungkinkan untuk menunjukkan minat Anda. <br><br>  Misalkan kita pernah memiliki bug (walaupun, tentu saja, ini tidak begitu :)).  Pengguna di profilnya memilih minat.  Tidak menemukan minat yang sesuai dari daftar, ia memutuskan untuk mengklik "Lainnya" untuk memperbarui daftar. <br><br>  Perilaku yang diharapkan: minat lama akan hilang, minat baru akan muncul.  Melainkan, muncul "Kesalahan Tidak Terduga": <br><br><img width="550" src="https://habrastorage.org/webt/tz/fp/lt/tzfpltsr9rkjpk-qtmoj4ustqjc.png"><br><br>  Ternyata ada masalah di sisi server, jawabannya tidak sama, dan klien memproses masalah ini dengan menunjukkan pemberitahuan. <br><br>  Tugas kita adalah menulis autotest yang akan memeriksa kasus ini. <br><br>  Kami menulis sekitar skrip berikut: <br><br><ul><li>  Buka profil </li><li>  Buka daftar minat </li><li>  Klik tombol "Lainnya" </li><li>  Pastikan bahwa kesalahan tidak muncul (misalnya, tidak ada elemen div.error) </li></ul><br>  Kami menjalankan tes seperti itu.  Namun, hal berikut terjadi: setelah beberapa hari / bulan / tahun, bug muncul kembali, meskipun tes tidak menangkap apa pun.  Mengapa <br><br>  Semuanya cukup sederhana: selama lulus tes yang berhasil, pelacak elemen tempat kami mencari teks kesalahan telah berubah.  Ada refactoring dari template dan alih-alih kelas "error" kami mendapat kelas "error_new". <br><br>  Selama refactoring, tes terus bekerja seperti yang diharapkan.  Elemen div.error tidak muncul, tidak ada alasan untuk jatuh.  Tetapi sekarang elemen "div.error" tidak ada sama sekali - oleh karena itu, tes tidak akan pernah gagal, apa pun yang terjadi dalam aplikasi. <br><br>  Kesimpulan: lebih baik untuk menguji operabilitas antarmuka dengan pemeriksaan positif.  Dalam contoh kita, kita harus berharap bahwa daftar minat telah berubah. <br><br>  Ada situasi ketika tes negatif tidak dapat digantikan dengan tes positif.  Misalnya, ketika berinteraksi dengan beberapa elemen, tidak ada yang terjadi dalam situasi "baik", dan kesalahan muncul dalam situasi "buruk".  Dalam hal ini, Anda harus menemukan cara untuk mensimulasikan skenario "buruk" dan menulis autotest juga.  Jadi, kami memverifikasi bahwa elemen kesalahan muncul dalam kasus negatif, dan dengan demikian kami memantau relevansi locator. <br><a name="element_exists"></a><br><h2>  Periksa item </h2><br>  Bagaimana memastikan bahwa interaksi pengujian dengan antarmuka berhasil dan semuanya berfungsi?  Ini paling sering terlihat pada perubahan yang terjadi pada antarmuka ini. <br><br>  Pertimbangkan sebuah contoh.  Anda perlu memastikan bahwa ketika mengirim pesan, pesan itu muncul di obrolan: <br><br><img width="350" src="https://habrastorage.org/webt/ac/uy/ww/acuywwe6rttek93vzdcf0n66th4.png"><br><br>  Scriptnya terlihat seperti ini: <br><br><ul><li>  Buka profil pengguna </li><li>  Buka obrolan dengannya </li><li>  Tulis pesan </li><li>  Kirim </li><li>  Tunggu hingga pesan muncul. </li></ul><br>  Kami menggambarkan skenario seperti itu dalam pengujian kami.  Misalkan pesan obrolan cocok dengan locator: <br><br> <code>p.message_text <br></code> <br>  Ini adalah cara kami memverifikasi bahwa elemen muncul: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.waitForPresence(By.css(<span class="hljs-string"><span class="hljs-string">'p.message_text'</span></span>), <span class="hljs-string"><span class="hljs-string">"Cannot find sent message."</span></span>);</code> </pre><br>  Jika menunggu kami berfungsi, maka semuanya beres: pesan obrolan dibuat. <br><br>  Seperti yang mungkin sudah Anda duga, setelah beberapa saat, pengiriman pesan obrolan berhenti, tetapi pengujian kami terus berfungsi tanpa gangguan.  Mari kita perbaiki. <br><br>  Ternyata sehari sebelum elemen baru muncul di obrolan: beberapa teks yang meminta pengguna untuk menyorot pesan jika tiba-tiba tidak diperhatikan: <br><br><img width="550" src="https://habrastorage.org/webt/ie/yc/82/ieyc82alpp-8kcoblkwyvup60my.png"><br><br>  Dan, yang paling lucu, itu juga berada di bawah locator kami.  Hanya ia memiliki kelas tambahan yang membedakannya dari pesan yang dikirim: <br><br> <code>p.message_text.highlight <br></code> <br>  Tes kami tidak pecah ketika blok ini muncul, tetapi tanda centang "tunggu sampai pesan muncul" tidak lagi relevan.  Elemen yang tadinya merupakan indikator dari acara yang sukses sekarang selalu ada. <br><br>  Kesimpulan: jika logika tes didasarkan pada memeriksa penampilan beberapa elemen, perlu untuk memeriksa bahwa tidak ada elemen seperti itu sebelum interaksi kita dengan UI. <br><br><ul><li>  Buka profil pengguna </li><li>  Buka obrolan dengannya </li><li>  <b>Pastikan tidak ada pesan terkirim</b> </li><li>  Tulis pesan </li><li>  Kirim </li><li>  Tunggu hingga pesan muncul. </li></ul><br><a name="random_data"></a><h2>  Data acak </h2><br>  Cukup sering, tes UI berfungsi dengan formulir tempat mereka memasukkan data.  Misalnya, kami memiliki formulir pendaftaran: <br><br><img width="550" src="https://habrastorage.org/webt/dd/gv/z2/ddgvz2ss4i8juyv7c5jrgqahd84.png"><br><br>  Data untuk tes tersebut dapat disimpan dalam konfigurasi atau hardcode dalam suatu pengujian.  Tetapi kadang-kadang muncul pikiran: mengapa tidak mengacak data?  Ini bagus, kami akan membahas lebih banyak kasus! <br><br>  Saran saya: jangan.  Dan sekarang saya akan memberi tahu Anda alasannya. <br><br>  Misalkan pengujian kami terdaftar di Badoo.  Kami memutuskan bahwa kami akan memilih jenis kelamin pengguna secara acak.  Pada saat menulis tes, arus pendaftaran untuk anak perempuan dan untuk anak laki-laki tidak berbeda, sehingga ujian kami berhasil. <br><br>  Sekarang bayangkan bahwa setelah beberapa saat aliran registrasi menjadi berbeda.  Misalnya, kami memberikan bonus gratis kepada gadis itu segera setelah pendaftaran, yang kami beri tahu dia dengan hamparan khusus. <br><br>  Dalam tes, tidak ada logika untuk menutup overlay, tetapi pada gilirannya, mengganggu tindakan lebih lanjut yang ditentukan dalam tes.  Kami mendapatkan tes yang masuk dalam 50% kasus.  Alat otomatisasi apa pun akan mengonfirmasi bahwa tes UI pada dasarnya tidak stabil secara alami.  Dan ini normal, kita harus hidup dengannya, terus-menerus menempel di antara logika berlebih "untuk semua kesempatan" (yang terasa merusak pembacaan kode dan mempersulit dukungannya) dan ketidakstabilan ini sendiri. <br><br>  Lain kali, ketika tes jatuh, kita mungkin tidak punya waktu untuk menghadapinya.  Kami baru saja restart dan melihat bahwa itu telah berlalu.  Kami memutuskan bahwa dalam aplikasi kami semuanya berfungsi sebagaimana mestinya dan masalahnya adalah tes yang tidak stabil.  Dan tenanglah. <br><br>  Sekarang mari kita lanjutkan.  Bagaimana jika hamparan ini rusak?  Tes akan terus lulus dalam 50% kasus, yang secara signifikan menunda menemukan masalah. <br><br>  Dan ada baiknya ketika, karena pengacakan data, kami menciptakan situasi "50 kali 50".  Tetapi itu terjadi secara berbeda.  Misalnya, sebelum mendaftar, kata sandi dianggap dapat diterima setidaknya tiga karakter.  Kami menulis kode yang muncul dengan kata sandi acak tidak lebih pendek dari tiga karakter (kadang-kadang tiga karakter, dan kadang-kadang lebih).  Dan kemudian aturannya berubah - dan kata sandi seharusnya sudah mengandung setidaknya empat karakter.  Berapa probabilitas jatuh dalam kasus ini?  Dan, jika pengujian kami menemukan bug nyata, seberapa cepat kami akan mengetahuinya? <br><br>  Terutama sulit untuk bekerja dengan tes di mana banyak data acak dimasukkan: nama, jenis kelamin, kata sandi, dan sebagainya ... Dalam hal ini, ada juga banyak kombinasi yang berbeda, dan jika terjadi kesalahan pada salah satu dari mereka, biasanya sulit untuk diperhatikan. <br><br>  Kesimpulan  Seperti yang saya tulis di atas, mengacak data itu buruk.  Lebih baik untuk menutupi lebih banyak kasus dengan mengorbankan penyedia data, tanpa melupakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelas kesetaraan</a> , tentu saja.  Lulus tes akan memakan waktu lebih lama, tetapi Anda bisa melawannya.  Tetapi kami akan yakin bahwa jika ada masalah, itu akan terdeteksi. <br><a name="atom_tests_1"></a><br><h2>  Atomicity tes (bagian 1) </h2><br>  Mari kita lihat contoh berikut ini.  Kami sedang menulis tes yang memeriksa penghitung pengguna di footer. <br><br><img width="651" src="https://habrastorage.org/webt/9j/n4/ws/9jn4wsd3jlh_wdnoiwrkjdfho9s.png"><br><br>  Skenarionya sederhana: <br><br><ul><li>  Buka aplikasi </li><li>  Temukan penghitung footer </li><li>  Pastikan itu terlihat </li></ul><br>  Kami menyebutnya testFooterCounter tes dan menjalankannya.  Maka menjadi perlu untuk memeriksa bahwa penghitung tidak menunjukkan nol.  Kami menambahkan tes ini ke tes yang ada, mengapa tidak? <br><br>  Tetapi kemudian menjadi perlu untuk memverifikasi bahwa di catatan kaki ada tautan ke deskripsi proyek (tautan "Tentang Kami").  Tulis tes baru atau tambahkan yang sudah ada?  Dalam hal pengujian baru, kami harus menaikkan kembali aplikasi, menyiapkan pengguna (jika kami memeriksa catatan kaki di halaman yang diotorisasi), masuk - secara umum, habiskan waktu berharga.  Dalam situasi seperti itu, mengganti nama tes menjadi testFooterCounterAndLinks sepertinya ide yang bagus. <br><br>  Di satu sisi, pendekatan ini memiliki kelebihan: menghemat waktu, menyimpan semua cek dari beberapa bagian aplikasi kita (dalam hal ini, footer) di satu tempat. <br><br>  Tetapi ada minus yang nyata.  Jika pengujian gagal pada pengujian pertama, kami tidak akan memeriksa sisa komponen.  Misalkan tes mogok di beberapa cabang, bukan karena ketidakstabilan, tetapi karena bug.  Apa yang harus dilakukan  Mengembalikan tugas yang hanya menjelaskan masalah ini?  Kemudian kami menjalankan risiko mendapatkan tugas dengan memperbaiki hanya bug ini, menjalankan tes dan mengetahui bahwa komponen juga rusak lebih lanjut, di tempat lain.  Dan mungkin ada banyak iterasi seperti itu.  Menendang tiket bolak-balik dalam kasus ini akan memakan banyak waktu dan tidak akan efektif. <br><br>  Kesimpulan: jika memungkinkan, lakukan atomisasi pada cek.  Dalam hal ini, walaupun memiliki masalah dalam satu kasus, kami akan memeriksa yang lainnya.  Dan, jika Anda harus mengembalikan tiket, kami dapat segera menggambarkan semua area masalah. <br><a name="atom_tests_2"></a><br><h2>  Atomitas pengujian (bagian 2) </h2><br>  Pertimbangkan contoh lain.  Kami sedang menulis tes obrolan yang memeriksa logika berikut.  Jika pengguna memiliki simpati timbal balik, promoblock berikut ini muncul di obrolan: <br><br><img width="550" src="https://habrastorage.org/webt/2o/v8/kp/2ov8kp9mojel1g_txzatwy91nig.png"><br><br>  Skenarionya adalah sebagai berikut: <br><br><ul><li>  Vote oleh pengguna A untuk pengguna B </li><li>  Vote oleh pengguna B untuk pengguna A </li><li>  Pengguna Obrolan terbuka dengan pengguna B </li><li>  Konfirmasikan bahwa unit ada di tempatnya </li></ul><br>  Untuk beberapa waktu, tes berhasil, tetapi kemudian terjadi ... Tidak, kali ini tes tidak melewatkan bug apa pun.  :) <br><br>  Setelah beberapa waktu, kami mengetahui bahwa ada bug lain yang tidak terkait dengan pengujian kami: jika Anda membuka obrolan, segera tutup dan buka lagi, blok tersebut hilang.  Bukan kasus yang paling jelas, dan dalam ujian kami, tentu saja, tidak memperkirakannya.  Tetapi kami memutuskan bahwa kami perlu menutupinya juga. <br><br>  Pertanyaan yang sama muncul: tulis tes lain atau masukkan tes ke yang sudah ada?  Menulis yang baru tampaknya tidak pantas, karena 99% dari waktu dia akan melakukan hal yang sama dengan yang sudah ada.  Dan kami memutuskan untuk menambahkan tes ke tes yang sudah ada: <br><br><ul><li>  Vote oleh pengguna A untuk pengguna B </li><li>  Vote oleh pengguna B untuk pengguna A </li><li>  Pengguna Obrolan terbuka dengan pengguna B </li><li>  Konfirmasikan bahwa unit ada di tempatnya </li><li>  <b>Tutup obrolan</b> </li><li>  <b>Buka obrolan</b> </li><li>  Konfirmasikan bahwa unit ada di tempatnya </li></ul><br>  Masalah dapat muncul ketika, misalnya, kami melakukan refactor setelah beberapa lama.  Misalnya, desain ulang akan terjadi pada proyek - dan Anda harus menulis ulang banyak tes. <br><br>  Kami akan membuka tes dan mencoba mengingat apa yang diperiksa.  Misalnya, tes disebut testPromoAfterMutualAttraction.  Apakah kita mengerti mengapa pembukaan dan penutupan obrolan ditulis di akhir?  Kemungkinan besar tidak.  Apalagi jika tes ini tidak ditulis oleh kami.  Akankah kita meninggalkan bagian ini?  Mungkin ya, tetapi jika ada masalah dengannya, kemungkinan kami hanya akan menghapusnya.  Dan verifikasi akan hilang hanya karena artinya tidak akan jelas. <br><br>  Saya melihat dua solusi di sini.  Pertama: masih melakukan tes kedua dan menyebutnya testCheckBlockPresentAfterOpenAndCloseChat.  Dengan nama seperti itu, akan menjadi jelas bahwa kita tidak hanya melakukan serangkaian tindakan tertentu, tetapi melakukan pemeriksaan yang sangat sadar, karena ada pengalaman negatif.  Solusi kedua adalah menulis komentar terperinci dalam kode tentang mengapa kami melakukan tes ini dalam tes khusus ini.  Disarankan juga untuk menunjukkan nomor bug dalam komentar. <br><a name="click_error"></a><br><h2>  Kesalahan mengklik item yang ada </h2><br>  Contoh berikut melemparkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">bbidox kepada</a> saya, yang mana ia merupakan nilai tambah besar dalam karma! <br><br>  Ada situasi yang sangat menarik ketika kode uji menjadi ... sebuah kerangka kerja.  Misalkan kita memiliki metode seperti ini: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clickSomeButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ WebElement button_element = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.waitForButtonToAppear(); button_element.click(); }</code> </pre><br>  Pada titik tertentu, sesuatu yang aneh mulai terjadi pada metode ini: tes macet ketika Anda mencoba mengklik tombol.  Kami membuka tangkapan layar yang diambil pada saat tes mogok, dan kami melihat bahwa ada tombol di tangkapan layar dan metode waitForButtonToAppear bekerja dengan sukses.  Pertanyaan: apa yang salah dengan klik? <br><br>  Bagian tersulit dalam situasi ini adalah bahwa tes kadang-kadang bisa berhasil.  :) <br><br>  Mari kita perbaiki.  Misalkan tombol yang dipertimbangkan dalam contoh terletak pada hamparan seperti itu: <br><br><img width="550" src="https://habrastorage.org/webt/pe/77/bd/pe77bddhspi2hdw1eagnzk8iydm.png"><br><br>  Ini adalah hamparan khusus di mana pengguna di situs web kami dapat mengisi informasi tentang dirinya.  Ketika Anda mengklik tombol overlay yang disorot, blok berikutnya muncul untuk mengisi. <br><br>  Untuk bersenang-senang, mari tambahkan kelas OLOLO tambahan untuk tombol ini: <br><br><img width="550" src="https://habrastorage.org/webt/ul/qv/fj/ulqvfjphig982sp-ntzfcmwdc0q.png"><br><br>  Setelah itu kita klik tombol ini.  Secara visual, tidak ada yang berubah, tetapi tombol itu sendiri tetap ada: <br><br><img width="550" src="https://habrastorage.org/webt/86/os/3x/86os3xs2ycobeqm75psth6xuidk.png"><br><br>  Apa yang terjadi  Faktanya, ketika JS menggambar ulang blok untuk kami, ia menggambar ulang tombol juga.  Itu masih tersedia di locator yang sama, tetapi ini adalah tombol lain.  Ini dibuktikan dengan kurangnya kelas OLOLO yang kami tambahkan. <br><br>  Dalam kode di atas, kami menyimpan elemen dalam variabel $ element.  Jika sebuah elemen dibuat ulang selama waktu ini, mungkin tidak terlihat secara visual, tetapi Anda tidak dapat mengkliknya lagi - metode klik () akan gagal. <br><br>  Ada beberapa solusi: <br><br><ul><li>  Bungkus klik di blok coba dan dalam elemen membangun kembali </li><li>  Tambahkan tombol ke atribut untuk memberi sinyal bahwa itu telah berubah </li></ul><br><a name="error_message"></a><h2>  Teks salah </h2><br>  Akhirnya, poin yang sederhana, tetapi tidak kalah pentingnya. <br><br>  Contoh ini tidak hanya berlaku untuk tes UI, tetapi juga sangat sering terjadi di dalamnya.  Biasanya, ketika Anda menulis tes, Anda berada dalam konteks apa yang terjadi: Anda menggambarkan verifikasi setelah verifikasi dan memahami artinya.  Dan Anda menulis teks kesalahan dalam konteks yang sama: <br><br><pre> <code class="java hljs">WebElement element = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.waitForPresence(By.css(<span class="hljs-string"><span class="hljs-string">"a.link"</span></span>), <span class="hljs-string"><span class="hljs-string">"Cannot find button"</span></span>);</code> </pre><br>  Apa yang mungkin tidak bisa dipahami dalam kode ini?  Tes mengharapkan tampilan tombol dan, jika tidak ada di sana, secara alami jatuh. <br><br>  Sekarang bayangkan penulis tes cuti sakit, dan rekannya sedang mengurus tes.  Dan kemudian dia menjatuhkan tes testQuestionsOnProfile dan menulis pesan ini: "Tidak dapat menemukan tombol".  Seorang kolega perlu memahami apa yang terjadi secepat mungkin, karena rilis akan segera datang. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ba/pe/dv/bapedvs1g2gplrhebyipl0p7cl0.gif"></div><br><br>  Apa yang harus dia lakukan? <br><br>  Tidak ada gunanya membuka halaman tempat tes jatuh dan memeriksa "a.link" locator - tidak ada elemen.  Karena itu, Anda harus mempelajari tes dengan cermat dan mencari tahu apa yang diperiksa. <br><br>  Akan jauh lebih sederhana dengan teks kesalahan yang lebih terperinci: "Tidak dapat menemukan tombol kirim pada hamparan pertanyaan".  Dengan kesalahan seperti itu, Anda dapat segera membuka overlay dan melihat ke mana tombolnya. <br><br>  Keluaran dua.  Pertama, perlu mengirimkan teks kesalahan ke metode kerangka kerja pengujian Anda apa pun, dan ini merupakan parameter yang diperlukan sehingga tidak ada godaan untuk melupakannya.  Kedua, teks kesalahan harus dibuat rinci.  Ini tidak selalu berarti bahwa itu harus panjang, cukup untuk membuatnya jelas tentang apa yang salah dalam tes. <br><br>  Bagaimana memahami bahwa teks kesalahan ditulis dengan baik?  Sangat sederhana.  Bayangkan aplikasi Anda rusak dan Anda harus pergi ke pengembang dan menjelaskan apa dan di mana rusak.  Jika Anda memberi tahu mereka hanya apa yang tertulis dalam teks kesalahan, apakah mereka akan mengerti? <br><a name="summary"></a><br><h2>  Ringkasan </h2><br>  Menulis skrip ujian seringkali merupakan kegiatan yang menarik.  Pada saat yang sama, kami mengejar banyak tujuan.  Tes kami harus: <br><br><ul><li>  tutupi sebanyak mungkin kasus </li><li>  bekerja secepat mungkin </li><li>  untuk dipahami </li><li>  perluas saja </li><li>  mudah dirawat </li><li>  memesan pizza </li><li>  dan seterusnya ... </li></ul><br>  Sangat menarik untuk bekerja dengan tes dalam proyek yang terus berkembang dan berubah, di mana mereka harus terus diperbarui: menambahkan sesuatu dan memotong sesuatu.  Itulah sebabnya penting untuk memikirkan beberapa poin sebelumnya dan tidak selalu terburu-buru dengan keputusan.  :) <br><br>  Saya harap tips saya akan membantu Anda menghindari beberapa masalah dan membuat Anda lebih bijaksana dalam studi kasus.  Jika audiens menyukai artikel ini, saya akan mencoba mengumpulkan beberapa contoh yang lebih membosankan.  Sementara itu - sampai jumpa! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419419/">https://habr.com/ru/post/id419419/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419409/index.html">NUC Intel Baru Berbasis Prosesor Danau Kopi</a></li>
<li><a href="../id419411/index.html">Tentang api di gedung pencakar langit. Sinema dan kenyataan</a></li>
<li><a href="../id419413/index.html">Pahat - (tidak cukup) pendekatan baru untuk pengembangan logika digital</a></li>
<li><a href="../id419415/index.html">Mattermost dan Powershell - kekuatan besar, atau otomatisasi kecil di rumah</a></li>
<li><a href="../id419417/index.html">GDPR: Pemetaan data atau bagaimana pelanggan menemukan laptop yang sudah lama terlupakan</a></li>
<li><a href="../id419423/index.html">Kami dijanjikan video waktu-nyata tanpa jalur dan kerutan</a></li>
<li><a href="../id419425/index.html">Pekan Keamanan 29. Peretasan Reddit, dompet untuk router cryptocurrency dan MikroTik</a></li>
<li><a href="../id419427/index.html">Epson mengundang semua orang ke piknik untuk Geeks 2018</a></li>
<li><a href="../id419429/index.html">Saya berusia 57 dan saya seorang ahli scrum</a></li>
<li><a href="../id419433/index.html">Laporan DSW - Pembuat Laporan DeepSeeWeb</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>