<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🍳 🕰️ 🍔 Mengapa Kaldi bagus untuk pengenalan ucapan? (diperbarui 12.25.2019) 📄 📿 🎡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mengapa saya (dan saya harap Anda) tertarik pada pengenalan ucapan? Pertama, arah ini adalah salah satu yang paling populer dibandingkan dengan tugas-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengapa Kaldi bagus untuk pengenalan ucapan? (diperbarui 12.25.2019)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470696/"><img src="https://habrastorage.org/webt/u6/kw/t0/u6kwt05e-r1amvb5tgew7dby6fk.jpeg"><br><br>  Mengapa saya (dan saya harap Anda) tertarik pada pengenalan ucapan?  Pertama, arah ini adalah salah satu yang paling populer dibandingkan dengan tugas-tugas lain dari linguistik komputer, karena teknologi pengenalan suara sekarang digunakan hampir di mana-mana - mulai dari mengenali ya / tidak di call center otomatis bank hingga kemampuan untuk mendukung "obrolan ringan" di "Kolom pintar" seperti "Alice".  Kedua, agar sistem pengenalan ucapan berkualitas tinggi, perlu untuk menemukan cara yang paling efektif untuk membuat dan mengonfigurasi sistem semacam itu (artikel ini dikhususkan untuk salah satu alat tersebut).  Akhirnya, "plus" yang tidak diragukan lagi dalam memilih spesialisasi di bidang pengenalan ucapan untuk saya secara pribadi adalah bahwa untuk penelitian di bidang ini perlu memiliki keahlian programmer dan linguistik.  Ini sangat merangsang, memaksa untuk memperoleh pengetahuan dalam berbagai disiplin ilmu. <br><a name="habracut"></a><br><h3>  Lagi pula, mengapa Kaldi ada kerangka kerja lain untuk pengenalan ucapan? </h3><br>  Untuk menjawab pertanyaan ini, ada baiknya mempertimbangkan analog yang ada dan algoritma dan teknologi yang digunakan oleh mereka (algoritma yang digunakan dalam Kaldi dijelaskan lebih lanjut dalam artikel): <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">CMU Sphinx</a> <br>  CMU Sphinx (jangan bingung dengan mesin pencari Sphinx!) Adalah sistem pengenalan ucapan yang dibuat oleh pengembang dari Universitas Carnegie Mellon dan terdiri dari berbagai modul untuk mengekstraksi fitur pidato, pengenalan suara (termasuk pada perangkat seluler) dan pelatihan untuk pengenalan seperti itu.  CMU Sphinx menggunakan model Markov tersembunyi pada tingkat pengenalan akustik-fonetik dan model statistik N-gram pada tingkat pengenalan linguistik.  Sistem ini juga memiliki sejumlah fitur menarik: pengenalan ucapan panjang (misalnya, transkrip atau rekaman suara wawancara), kemampuan untuk menghubungkan kamus besar ratusan ribu bentuk kata, dll. Penting untuk dicatat bahwa sistem ini terus berkembang, dengan setiap versi, kualitas dan kinerja pengakuan ditingkatkan .  Juga ada dokumentasi lintas platform dan nyaman.  Di antara kekurangan menggunakan sistem ini, adalah mungkin untuk memilih ketidakmampuan untuk memulai CMU Sphinx "out of the box", karena  bahkan memecahkan masalah sederhana membutuhkan pengetahuan tentang mengadaptasi model akustik, di bidang pemodelan bahasa, dll. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Julius</a> <br>  Julius telah dikembangkan oleh pengembang Jepang sejak 1997, dan sekarang proyek ini didukung oleh Institut Penelitian Sains, Teknologi &amp; Manajemen Tingkat Lanjut Kyoto.  Model ini didasarkan pada N-gram dan model Markov tersembunyi yang peka konteks, sistem ini mampu mengenali pembicaraan secara real time.  Kelemahannya adalah distribusi hanya untuk model bahasa Jepang (walaupun ada proyek VoxForge yang membuat model akustik untuk bahasa lain, khususnya untuk bahasa Inggris) dan kurangnya pembaruan yang stabil. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">RWTH ASR</a> <br>  Model ini telah dikembangkan oleh spesialis dari Universitas Teknik Rhine-Westphalian sejak tahun 2001, terdiri dari beberapa perpustakaan dan alat yang ditulis dalam C ++.  Proyek ini juga mencakup dokumentasi instalasi, berbagai sistem pelatihan, templat, model akustik, model bahasa, dukungan untuk jaringan saraf, dll. Selain itu, RWTH ASR praktis lintas platform dan memiliki kecepatan rendah. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Htk</a> <br>  HTK (Hidden Markov Model Toolkit) adalah seperangkat alat pengenalan ucapan yang dibuat di Universitas Cambridge pada tahun 1989.  Toolkit berdasarkan pada model Markov tersembunyi paling sering digunakan sebagai alat tambahan untuk membuat sistem pengenalan ucapan (misalnya, kerangka kerja ini digunakan oleh pengembang Julius).  Terlepas dari kenyataan bahwa kode sumber tersedia untuk umum, penggunaan HTK untuk membuat sistem untuk pengguna akhir dilarang oleh lisensi, itulah sebabnya toolkit ini tidak populer saat ini.  Sistem ini juga memiliki kecepatan dan akurasi yang relatif rendah. </li></ul><br>  Dalam artikel "Analisis komparatif sistem pengenalan ucapan sumber terbuka" ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">https://research-journal.org/technical/sravnitelnyj-analiz-sistem-raspoznavaniya-rechi-s-otkrytym-kodom/</a> ), sebuah penelitian dilakukan selama semua sistem dilatih dalam kasus bahasa Inggris (160 jam) dan diterapkan dalam kasus uji kecil 10 jam.  Alhasil, ternyata Kaldi memiliki akurasi pengenalan tertinggi, sedikit lebih cepat dari kompetitornya dalam hal kecepatan.  Selain itu, sistem Kaldi mampu menyediakan pengguna dengan pilihan algoritma terkaya untuk berbagai tugas dan sangat mudah digunakan.  Pada saat yang sama, penekanan diberikan pada fakta bahwa bekerja dengan dokumentasi mungkin tidak nyaman bagi pengguna yang tidak berpengalaman, karena  Ini dirancang untuk para profesional pengenalan suara.  Tetapi secara umum, Kaldi lebih cocok untuk penelitian ilmiah daripada rekan-rekannya. <br><cut></cut><br><h3>  Cara menginstal Kaldi </h3><br><ol><li>  Unduh arsip dari repositori di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">https://github.com/kaldi-asr/kaldi</a> : <br><img src="https://habrastorage.org/webt/2-/2q/wh/2-2qwhrs79zle9ze1jsmqrdeg3k.jpeg"></li><li>  Buka paket arsip, buka kaldi-master / tools / ekstra. </li><li>  Kami menjalankan ./check_dependencies.sh: <br><img src="https://habrastorage.org/webt/hr/nm/ug/hrnmugjo9pswjvy-vnnbz2unasc.png"><br>  Jika setelah itu Anda melihat tidak "semua baik-baik saja", maka buka file kaldi-master / tools / INSTALL dan ikuti instruksi di sana. </li><li>  Kami mengeksekusi make (berada di kaldi-master / tools, bukan di kaldi-master / tools / ekstra): <br><img src="https://habrastorage.org/webt/pl/6w/qz/pl6wqzcxloc93pat9ddwbvpdd-g.png"></li><li>  Pergi ke kaldi-master / src. </li><li>  Kami menjalankan ./configure - shared, dan Anda dapat mengonfigurasi instalasi dengan atau tanpa teknologi CUDA dengan menentukan path ke CUDA yang terinstal (./configure --cudatk-dir = / usr / local / cuda-8.0) atau mengubah nilai awal “ya "To" no "(./ configure --use-cuda = no) secara berurutan. <br><br>  Jika pada saat yang sama Anda melihat: <br><br><img src="https://habrastorage.org/webt/0o/fo/fk/0ofofk6kgbhousqfpnzagxh5lze.png"><br><br>  baik Anda tidak mengikuti langkah 4, atau Anda perlu mengunduh dan menginstal OpenFst sendiri: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">http://www.openfst.org/twiki/bin/view/FST/FstDownload</a> . </li><li>  Kami membuat ketergantungan. </li><li>  Kami menjalankan make -j.  Disarankan agar Anda memasukkan jumlah inti prosesor yang benar yang akan Anda gunakan saat membangun, misalnya, membuat -j 2. </li><li>  Sebagai hasilnya, kita mendapatkan: <br><img src="https://habrastorage.org/webt/h4/bs/zb/h4bszbrxejdjz02pxg7jx110v78.png"></li></ol><cut></cut><br><h3>  Contoh menggunakan model dengan Kaldi diinstal </h3><br>  Sebagai contoh, saya menggunakan model kaldi-ru versi 0.6, <a href="" rel="nofollow">Anda dapat mengunduhnya dari tautan ini</a> : <br><br><ol><li>  Setelah mengunduh, buka file kaldi-ru-0.6 / decode.sh dan tentukan path ke Kaldi yang terinstal, sepertinya ini untuk saya: <br><br><img src="https://habrastorage.org/webt/g6/a_/ah/g6a_ahhtdnva3mmlhbu5fn7yqii.png"><br></li><li>  Kami meluncurkan model, menunjukkan file di mana pidato akan dikenali.  Anda dapat menggunakan file decoder-test.wav, ini adalah file khusus untuk tes, itu sudah ada di folder ini: <br><br><img src="https://habrastorage.org/webt/gq/er/gt/gqergtoumyqfba4uhvo_j--cydm.png"><br></li><li>  Dan inilah yang diakui oleh model: <br><img src="https://habrastorage.org/webt/8g/sh/kj/8gshkjtdsxzh_lj8xl7djhoen1k.png"></li></ol><br><h3>  Algoritma apa yang digunakan, apa yang mendasari pekerjaan? </h3><br>  Informasi lengkap tentang proyek ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">http://kaldi-asr.org/doc/</a> , di sini saya akan menyoroti beberapa poin utama: <br><br><ul><li>  Baik MFCC akustik (Koefisien Koefisien Frekuensi Mel) atau PLP yang sedikit kurang populer (Prediksi Linier Perseptual - lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">H. Hermansky, “Analisis perkalian linear prediktif (PLP)”</a> digunakan untuk mengekstraksi fitur akustik dari sinyal input.  Pada metode pertama, spektrum sinyal asli dikonversi dari skala Hertz ke skala chalk, dan kemudian koefisien cepstral dihitung menggunakan invers cosine transform (https://habr.com/en/post/140828/).  Metode kedua didasarkan pada representasi regresi pidato: model sinyal dibangun yang menggambarkan prediksi sampel sinyal saat ini dengan kombinasi linier - produk sampel input dan output sinyal yang diketahui dan koefisien prediksi linier.  Tugas menghitung tanda-tanda bicara dikurangi untuk menemukan koefisien-koefisien ini dalam kondisi tertentu. </li><li>  Modul pemodelan akustik mencakup model Markov tersembunyi (HMM), model campuran distribusi Gaussian (GMM), jaringan saraf dalam, yaitu Time-Delay Neural Networks (TDNN). </li><li>  Pemodelan bahasa dilakukan dengan menggunakan mesin negara terbatas, atau FST (finite-state transducer).  FST mengkodekan pemetaan dari urutan karakter input ke urutan karakter output, dan ada bobot untuk transisi yang menentukan kemungkinan menghitung karakter input dalam output. </li><li>  Decoding dilakukan menggunakan algoritma forward-reverse. </li></ul><br><h3>  Tentang membuat model kaldi-ru-0.6 </h3><br>  Untuk bahasa Rusia, ada model pengenalan pra-terlatih yang dibuat oleh Nikolai Shmyryov, juga dikenal di banyak situs dan forum sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">nsh</a> . <br><br><ul><li>  Untuk mengekstraksi fitur, metode MFCC digunakan, dan model akustik-fonetik itu sendiri didasarkan pada jaringan saraf tipe TDNN. </li><li>  Sampel pelatihan adalah soundtrack video dalam bahasa Rusia, diunduh dari YouTube. </li><li>  Untuk membuat model bahasa, kami menggunakan kamus CMUdict dan persis kosa kata yang ada di set pelatihan.  Karena fakta bahwa kamus berisi pengucapan yang sama dari kata-kata yang berbeda, diputuskan untuk menetapkan nilai "probabilitas" pada setiap kata dan menormalkannya. </li><li>  Untuk mempelajari model bahasa, kerangka kerja RNNLM (model bahasa jaringan saraf berulang) digunakan, berdasarkan, seperti namanya, pada jaringan saraf berulang (bukan N-gram lama yang baik). </li></ul><br><cut></cut><br><h3>  Perbandingan dengan Google Speech API dan Yandex Speech Kit </h3><br>  Tentunya, salah satu pembaca, ketika membaca paragraf sebelumnya, memiliki pertanyaan: oke, kami tahu bahwa Kaldi lebih unggul daripada rekan-rekan langsungnya, tetapi bagaimana dengan sistem pengenalan dari Google dan Yandex?  Mungkin relevansi kerangka kerja yang dijelaskan sebelumnya diragukan jika ada alat dari dua raksasa ini?  Pertanyaannya sangat bagus, jadi mari kita coba! <br><br><ul><li>  Sebagai dataset, kami mengambil catatan dan dekripsi teks yang sesuai dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">VoxForge yang</a> terkenal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">jahat</a> .  Akibatnya, setelah setiap sistem mengenali 3677 file suara, saya menerima nilai WER (Word Error Rate) berikut: <br><br><img src="https://habrastorage.org/webt/ca/s9/vr/cas9vriacqyf-xrvijr3-dxu3_s.jpeg"><br></li><li>  Rekaman dari VoxForge kira-kira serupa dengan tidak adanya kebisingan latar belakang, intonasi, kecepatan bicara, dll.  Mari menyulitkan tugas: ambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">suborpus</a> validasi open_stt, yang mencakup percakapan telepon, klip audio dari video YouTube dan buku audio, dan evaluasi kinerja menggunakan WER dan CER (Character Error Rate). <br><br>  Setelah menerima transkrip teks, saya perhatikan bahwa Google dan Yandex (tidak seperti Kaldi) mengenali kata-kata seperti <br>  "Satu" sebagai "1".  Oleh karena itu, ada kebutuhan untuk memperbaiki kasus-kasus seperti itu (seperti dalam transkrip referensi yang disediakan oleh penulis open_stt, semuanya disajikan dalam bentuk surat), yang mempengaruhi hasil akhir: <br><br><img src="https://habrastorage.org/webt/1e/si/iw/1esiiwizr_zz5y1p7vdc6ye_ao8.png"><br></li></ul><br>  Kesimpulannya, kita dapat mengatakan bahwa semua sistem mengatasi tugas pada tingkat yang kira-kira sama, dan Kaldi tidak kalah dengan Yandex Speech Kit dan Google Speech API.  Dalam kasus kedua, Yandex Speech Kit memiliki kinerja terbaik, seperti  itu paling baik mengenali file audio pendek dibandingkan dengan pesaing yang tidak dapat mengenali bagian mana pun dari mereka (untuk Google, jumlah file ini bahkan terlalu besar).  Akhirnya, perlu dicatat bahwa Kaldi membutuhkan waktu lebih dari 12 jam untuk mengenali 28111 file, sistem lain dikelola dalam waktu yang jauh lebih sedikit.  Tetapi pada saat yang sama, Yandex Speech Kit dan Google Speech API adalah "kotak hitam" yang bekerja di tempat yang jauh, jauh di server orang lain dan tidak dapat diakses untuk penyetelan, tetapi Kaldi dapat disesuaikan dengan spesifikasi tugas yang ada - kosa kata khas (profesionalisme, jargon, bahasa gaul sehari-hari), fitur pengucapan, dll.  Dan semua ini gratis dan tanpa SMS!  Sistemnya adalah semacam perancang, yang kita semua dapat gunakan untuk membuat sesuatu yang tidak biasa dan menarik. <br><br>  Saya mengucapkan terima kasih kepada tim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Yandex.Cloud</a> , yang membantu saya dalam implementasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">pengenalan</a> kasus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">open_stt</a> . <br><br>  Saya bekerja di laboratorium APDiMO NSU: <br>  Situs web: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">https://bigdata.nsu.ru/</a> <br>  VK Group: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">https://vk.com/lapdimo</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470696/">https://habr.com/ru/post/id470696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470684/index.html">Apa yang harus ditulis dalam resume jika tidak ada pengalaman kerja</a></li>
<li><a href="../id470686/index.html">Teknologi untuk kota pintar. Akankah St. Petersburg menjadi kota metropolis pertama yang nyaman bagi orang buta?</a></li>
<li><a href="../id470688/index.html">Apa yang diketahui tentang VMworld 2019</a></li>
<li><a href="../id470692/index.html">Bagaimana kami membuat situs web Rosbank baru, dan apa yang terjadi</a></li>
<li><a href="../id470694/index.html">Memilih platform pemasaran email: apa yang harus diperhatikan perusahaan Rusia</a></li>
<li><a href="../id470700/index.html">Meja. Logam Diam Milikmu</a></li>
<li><a href="../id470706/index.html">Python + Keras + LSTM: lakukan penerjemah teks dalam waktu setengah jam</a></li>
<li><a href="../id470710/index.html">Pembelajaran Mesin untuk berburu flat Anda. Bagian 2</a></li>
<li><a href="../id470714/index.html">Bagaimana saya pergi ke Final Terobosan Digital</a></li>
<li><a href="../id470718/index.html">"Efek aljabar" dalam bahasa manusia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>