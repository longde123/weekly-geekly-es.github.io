<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐸 🤞🏼 👰 该代码是活的还是死的。 第二部分 动作和属性 🚽 📈 🥂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="上次我写道对象的名称非常重要，必须仔细选择它们并注意细节。 坏名吓坏了，不允许理解正在发生的事情的本质。 但是，这的本质是什么？ 


 不了解英雄的“状态”和“能力”就很难评估英雄。 他能做的和他能做的是我们必须深入的下一个难度级别。 靠一个确切的名字来反映对象的内部保护区是不够的，您还需要确保这...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>该代码是活的还是死的。 第二部分 动作和属性</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447674/"><p> 上次我写道对象的名称非常重要，必须仔细选择它们并注意细节。 坏名吓坏了，不允许理解正在发生的事情的本质。 但是，这的本质是什么？ </p><br><p> 不了解英雄的<em>“状态”</em>和<em>“能力”</em>就很难评估英雄。 他能做的和他能做的是我们必须深入的下一个难度级别。 靠一个确切的名字来反映对象的内部保护区是不够的，您还需要确保这是相同的<em>保护区</em> ，而不是来自吸气剂的马s。 </p><br><p> 关于此-在文章中。 </p><a name="habracut"></a><br><h2 id="oglavlenie-cikla"> 循环目录 </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对象</a> </li><li> 动作和属性 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文字编码</a> </li></ol><br><h2 id="deystviya"> 动作 </h2><br><p>角色攻击，防守，躲避，从弓箭射击，使用咒语，挥动剑刃。 名称反映了对象，但是对象本身在运动，反应，活动中。 否则，我们将讨论Excel中的表格。 </p><br><p> 在C＃中，动作是方法和函数。 对于我们来说：动词，言语运动的原子。 动词会随着时间的流逝而运动，因为它们存在并相互作用。 有变化的地方-必须有动词。 </p><br><h3 id="settery"> 二传手 </h3><br><p> 在所有更改中，分配最少是所有可移动的。 它严格而数学地描述了数量是什么以及它们等于什么，但从未像动词那样向文本传达生命和活力。 </p><br><p>例如，存在具有<code>Status</code>属性的<code>IPullRequest</code> ，可以将其<code>Approved</code> ， <code>Declined</code>或<code>Merged</code> 。 您可以编写<code>pullRequest.Status = Status.Declined</code> ，但这与说<em>“将池请求设置为取消状态”相同，这</em>是必须的。  <code>pullRequest.Decline()</code>以及相应的<code>pullRequest.Approve()</code> ， <code>pullRequest.Merge()</code>更强大。 </p><br><p> 主动动词比二传手更可取，但并非所有动词都可以。 </p><br><h3 id="passivnyy-zalog"> 被动语态 </h3><br><p>  <code>PerformPurchase</code> ， <code>DoDelete</code> ， <code>MakeCall</code> 。 </p><br><p> 就像在<code>HeroManager</code>一个重要的名词会被毫无意义的<code>Manager</code>所遮盖，因此在<code>PerformMigration</code> - <code>Perform</code>中<code>PerformMigration</code>如此。 毕竟，还活着-只需<code>Migrate</code> ！ </p><br><p> 主动动词刷新文本：不是<em>“ hit”</em> ，而是<em>“ hit”</em> ； 不是<em>“摇摆”</em> ，而是<em>“挥手”</em> ； 不是<em>“决定”</em> ，而是<em>“决定”</em> 。 因此在代码中： <code>PerformApplication</code> → <code>Apply</code> ;  <code>DoDelete</code> → <code>Delete</code> ；  <code>PerformPurchase</code> → <code>Purchase</code> ， <code>Buy</code> 。  <em>（但</em> <code>DealDamage</code> <em>解决，尽管在极少数情况下，可能意味着</em> <code>Attack</code> <em>。）</em> </p><br><p> 避免被动语态，我们开发了故事，移动了角色，但我们还需要确保电影不以黑白显示。 </p><br><h3 id="silnye-glagoly"> 强动词 </h3><br><p> 有些词比其他词更好地表达了含义。 如果您写<em>“他喝了一杯水”</em> ，它将很简单明了。 但是<em>“排干了一杯水”</em> -比喻更坚固。 </p><br><p> 因此，玩家的健康状况变化可以通过<code>player.Health = X</code>或<code>player.Health = X</code>来表示，但更加生动的是<code>player.RestoreHealth</code> 。 </p><br><p> 或者，例如，我们不是通过<code>Add/Remove</code>而是通过<code>Push/Pop</code>了解<code>Stack</code> 。 </p><br><p> 如果动词不太具体，则强而有力的动词会使对象充满行为。 </p><br><h3 id="izbytochnye-detali"> 冗余部分 </h3><br><p> 与<code>ManualResetEvent</code> ，我们越接近.NET的技术内部结构，这些结构就复杂了，只要简单地表达它们，API的细节和多余的内容就越丰富。 </p><br><p> 碰巧您需要在另一个线程上做一些工作，但是不要为创建和停止它而烦恼。 在C＃中<code>ThreadPool</code>于此的<code>ThreadPool</code> 。 这里只有一个简单的<em>“工作”</em> <code>QueueUserWorkItem</code> ！ 不清楚工作项（ <code>WorkItem</code> ）是什么类型，如果不是用户（ <code>User</code> ）则可以是什么。 容易<code>ThreadPool.Run</code>或<code>ThreadPool.Execute</code> 。 </p><br><p> 另一个例子。 记住并知道有一个原子<em>比较和交换（CAS）</em>指令是好的，但是将其干净地移植到代码中并不是最佳的解决方案。  <code>Interlocked.CompareExchange(ref x, newX, oldX)</code>不如<code>Interlocked.CompareExchange(ref x, newX, oldX)</code> <code>Atomically.Change(ref x, from: oldX, to: newX)</code> （使用命名参数）。 </p><br><p> 该代码不是使用量子计算机的博士学位，也不是数学计算的应用程序，但读者有时对所谓的低级指令完全无所谓。 日常使用很重要。 </p><br><h3 id="povtoreniya"> 重复次数 </h3><br><p>  <code>UsersRepository.AddUser</code> ， <code>Benchmark.ExecuteBenchmark</code> ， <code>AppInitializer.Initialize</code> ， <code>UniversalMarshaller.Marshal</code> ， <code>Logger.LogError</code> 。 </p><br><p> 正如我在最后一部分中所述，重复会削弱含义，压缩空间。 </p><br><p> 不是<code>UsersRepository.AddUser</code> ，而是<code>UsersRepository.Add</code> ; 不是<code>Directory.CreateDirectory</code> ，而是<code>Directory.Create</code> ； 不是<code>HttpWebResponse.GetResponseStream</code> ，而是<code>HttpWebResponse.Stream</code> ; 不是<code>Logger.LogError</code> ，而是<code>Log.Error</code> 。 </p><br><h3 id="melkiy-sor"> 细垃圾 </h3><br><p>  <code>Check</code>是一个多方面的词。 如果用户的名称太长，则<code>CheckHasLongName</code>可以返回<code>bool</code>或引发异常。 更好的是<code>bool HasLongName</code>或<code>void EnsureHasShortName</code> 。 我什至遇到了<code>CheckRebootCounter</code> ，它在里面的某个地方重新启动了IIS！ </p><br><p>  <code>Enumerate</code> -来自同一系列。 在.NET中，有一个<code>Directory.EnumerateDirectories(path)</code>方法：出于某种原因，尽管<code>Directories.Of(path)</code>或<code>path.Directories()</code> ，但指定将列出文件夹。 </p><br><p>  <code>Calc</code>尽管看起来更像钙沉积物，但通常减少<code>Calculate</code> 。 </p><br><p>  <code>Proc</code>是<code>Process</code>另一个花哨的缩写。 </p><br><p> 表示对象复杂性的<code>Base</code> ， <code>Impl</code> ， <code>Internal</code> ， <code>Raw</code>寄生词。 </p><br><h3 id="itogo"> 合计 </h3><br><p> 细心的读者会再次注意到，所有这些都归结为简化，自然语言的比喻，而且技巧本身不仅与代码有关，而且与一般编写有关。 通过使用它们，开发人员可以将代码既作为文本又作为文本本身进行修饰，以简化透明，平滑的外观。 </p><br><p> 现在我们已经弄清楚了运动和<em>“特殊效果”，</em>让我们看看如何描述对象之间的关系。 </p><br><h2 id="svoystva"> 属性 </h2><br><p> 角色有健康和法力； 物品在购物篮中； 太阳系由行星组成。 对象不仅会无私地行动，而且还会关联：层次结构（祖先继承人），结构化（整数部分），空间上（存储元素）等。 </p><br><p> 在C＃中，属性和关系是方法（通常以<code>Get</code>开头），getter（具有特定<code>get</code>正文的属性）和字段。 但对我们而言，它是：单词加法，表示一个对象对另一个对象的归属。 例如，玩家的健康状况<code>Player.Health</code>几乎与英语<em>“玩家的健康状况”</em>相对应。 </p><br><p> 今天最困惑的是动作方法和属性方法。 </p><br><h3 id="glagol-vmesto-suschestvitelnogo"> 动词代替名词 </h3><br><p>  <code>GetDiscount</code> ， <code>CalculateDamage</code> ， <code>FetchResult</code> ， <code>ComputeFov</code> ， <code>CreateMap</code> 。 </p><br><p> 解决方法无处不在：方法必须以动词开头。 您很少看到有人对此表示怀疑：这是真的吗？ 毕竟， <code>Player.Health</code>和<code>Player.Health()</code>之间不会有显着差异。 让记录在语法上有所不同，它们<em>意味着</em>同一件事。 </p><br><p> 假设在<code>IUsersRepository</code>中很容易期望有一些<code>GetUser(int id)</code> 。 为什么要代表用户考虑某种收据（ <code>Get</code> ）？ 它将更加准确- <code>User(int id)</code> ！ </p><br><p> 实际上：不是<code>FetchResult()</code> ，而是<code>Result()</code> ； 不是<code>GetResponse()</code> ，而是<code>Response()</code> ； 不是<code>CalculateDamage()</code> ，而是<code>Damage()</code> 。 </p><br><p> 一个DDD演讲给出了一个“好”代码的示例：具有<code>CalculateDiscountBy(int customerId)</code>方法的<code>DiscountCalculator</code> 。 不仅在脸上有一个对称的重复<code>DiscountCalculator.CalculateDiscount</code> ，而且他们还指定了折扣的<em>计算</em> 。 还有人问她要做什么？ </p><br><p> 从实体本身出发-带有<code>static decimal Of(Customer customer, Order order)</code>方法的<code>Discount.Of(customer, order)</code>调用<code>Discount.Of(customer, order)</code> -比<code>_discountCalculator.CalculateDiscountBy(customerId)</code>更简单，并且对应于一种语言。 </p><br><p> 有时，省略动词会丢失一些内容，例如在<code>CreateMap()</code> ：用<code>Map()</code>直接替换可能不够。 然后最好的解决方案是<code>NewMap()</code> ：同样，对象在<code>NewMap()</code> ，而不是动作。 </p><br><p> 使用空的空动词是过时的命令式文化的特征，其中算法是主要的，并且领先于概念。 在这里，您经常会发现<em>“已回火的刀片”而</em>不是<em>“硬化的刀片”</em> 。 但是有关詹姆斯·邦德的书籍的风格并不适合描述风景。 没有动静的地方，动词就没有位置。 </p><br><h3 id="drugoe"> 其他 </h3><br><p> 表达对象之间的关系的属性和方法也是对象，因此，上述内容在许多方面都适用于它们。 </p><br><p> 例如，属性中的重复：不是<code>Thread.CurrentThread</code> ，而是<code>Thread.Current</code> ； 不是<code>Inventory.InventoryItems</code> ，而是<code>Inventory.Items</code>等。 </p><br><h2 id="itogo-1"> 合计 </h2><br><p> 简单易懂的单词不会混淆，因此由它们组成的代码也不会混淆。 在写作中，轻松写作同样重要：避免被动介词，大量副词和形容词，重复项，因为动作比名词更喜欢动词。 一个著名的例子： <em>“他点了头，同意了”，</em>而不是<em>“他点了点头”，</em>引起了微笑，我记得<code>QueueUserWorkItem</code> 。 </p><br><p> 代码中的文字也有所不同，在第一种情况下，如果<em>房子是站立的，淹没在夕阳的照耀</em>下，您将获得报酬； 第二点-如果房子是<em>站立的</em> ; 但是值得记住的是： <em>房子</em>应该立起来，而不是被助手们粘住。 </p><br><p> 在本系列的前两篇文章中，我想展示不仅在算法上而且在单词上工作的重要性。 名称是如何确定所称内容的； 冗余和过于复杂的代码如何驱使读者离开。 </p><br><p> 除此之外，好名字只是笔记。 要<em>播放</em> ，必须将它们写成音乐并体现出来。 我将在下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇</a>最后的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章中</a>告诉您更多信息。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN447674/">https://habr.com/ru/post/zh-CN447674/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN447664/index.html">跨领域业务分析销售</a></li>
<li><a href="../zh-CN447666/index.html">MS SQL Backup：并不是每个人都知道的几个有用的Commvault功能</a></li>
<li><a href="../zh-CN447668/index.html">MSH口译员</a></li>
<li><a href="../zh-CN447670/index.html">在实践中采用进口替代。 第2部分。开始。 管理程序</a></li>
<li><a href="../zh-CN447672/index.html">公司IT系统目录</a></li>
<li><a href="../zh-CN447676/index.html">新Mail.ru邮件以及章鱼与它有什么关系</a></li>
<li><a href="../zh-CN447678/index.html">简要百科全书的概念</a></li>
<li><a href="../zh-CN447680/index.html">仿真练习：Xbox 360 FMA手册</a></li>
<li><a href="../zh-CN447682/index.html">太空数据中心：发射前24小时</a></li>
<li><a href="../zh-CN447684/index.html">如何在办公室中显示公司价值（没有海报和标语）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>