<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑 🥋 🎉 应嵌入式开发人员的要求：在Amazon FreeRTOS中检测错误 🐈 🏫 🙌🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="对微控制器进行编程的任何人都可能了解FreeRTOS，或者至少听说过该操作系统。 亚马逊开发人员决定增强该操作系统与AWS Internet of Things服务一起使用的能力。 这就是Amazon FreeRTOS出现的方式。 我们是PVS-Studio静态代码分析器的开发人员，已通过邮件和评论...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>应嵌入式开发人员的要求：在Amazon FreeRTOS中检测错误</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/473966/"> 对微控制器进行编程的任何人都可能了解FreeRTOS，或者至少听说过该操作系统。 亚马逊开发人员决定增强该操作系统与AWS Internet of Things服务一起使用的能力。 这就是Amazon FreeRTOS出现的方式。 我们是PVS-Studio静态代码分析器的开发人员，已通过邮件和评论的形式要求我们检查这些项目。 好了，现在就满足您的要求。 继续阅读以找出其中的内容。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cee/9b7/a98/cee9b7a984f45dc365b4baea89adb019.png"></div><br><a name="habracut"></a><br><h2> 简要介绍项目 </h2><br> 首先，我将向您介绍一些正在测试的项目的先驱-FreeRTOS（源代码可在此处通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">link获得</a> ）。 如Wikipedia所述，FreeRTOS是嵌入式系统的实时多任务操作系统。 <br><br> 它是用旧的C语言编写的，这并不奇怪-该操作系统应在微控制器的典型条件下工作：处理能力低，RAM量少等。  C语言允许您以较低的级别使用资源并具有高性能，因此最适合开发这样的OS。 <br><br> 现在回到亚马逊，亚马逊一直在发展各种有前途的方向。 例如，亚马逊正在开发Amazon Lumberyard AAA引擎，我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">也</a>对此<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">进行了检查</a> 。 <br><br> 这样的方向之一是物联网（IoT）。 为了在此领域发展，亚马逊决定编写自己的操作系统-他们以FreeRTOS核心为基础。 <br><br> 最终的系统Amazon FreeRTOS被定位为“提供与Amazon Web Services的安全连接，例如AWS IoT Core或AWS IoT Greengrass”。 该项目的源代码<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可</a>在Github上获得。 <br><br> 在本文中，我们将了解FreeRTOS中是否存在错误以及就静态代码分析而言，Amazon操作系统的安全性如何。 <br><br><h2> 检查过程 </h2><br> 使用自动错误查找工具-PVS-Studio静态代码分析器执行检查。 它能够检测用C，C ++，C＃和Java编写的程序中的错误。 <br><br> 在分析之前，我们必须构建项目。 这样，我将确信我具有所有需要的依赖项，并且可以检查该项目了。 人们可以通过多种方式检查项目，例如，使用编译监视系统。 在这种情况下，我使用Visual Studio插件进行了分析-很好的是，两个项目的存储库都包含可轻松在Windows下构建的项目文件集。 <br><br> 我只需要构建项目以确保已准备好一切即可进行检查。 接下来，我进行分析，瞧！  -我面前有一份现成的分析仪报告。 <br><br> 这些项目中包含的第三方库也可能包含错误，它们当然也会影响程序。 但是，为了叙述的纯正，我从分析中排除了它们。 <br><br> 因此，分析了项目，收到了报告，突出了有趣的错误。 现在该得到他们的评论！ <br><br><h2>  FreeRTOS隐藏了什么 </h2><br> 最初，我希望写两篇单独的文章：每个操作系统一篇。 我已经在搓手了吗？ 当我准备写一篇关于FreeRTOS的好文章时。 预计至少会发现两个多汁的bug（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CWE-457</a> ），我正在查看分析仪的稀疏警告，却发现什么都没有。 我没有发现任何有趣的错误。 <br><br> 分析仪发出的许多警告与FreeRTOS不相关。 例如，此类警告是64位缺陷，例如将<i>size_t转换</i>为<i>uint32_t</i> 。 这与FreeRTOS旨在在指针大小不大于32位的设备上工作有关。 <br><br> 我已经彻底检查了所有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V1027</a>警告，这些警告指示在指向不相关结构的指针之间进行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">强制转换</a> 。 如果铸造结构具有相同的对齐方式，则这种铸造是错误的。 而且我还没有发现任何危险的铸件！ <br><br> 所有其他可疑的地方要么与编码风格相关联，要么配备了注释，解释了为什么这样做和为什么不是错误。 <br><br> 因此，我想吸引FreeRTOS开发人员。 伙计们，您真棒！ 我们几乎看不到像您这样干净，高质量的项目。 很高兴阅读干净，整洁且有据可查的代码。 向你们致敬。 <br><br> 即使那天我找不到任何有趣的错误，但我知道我不会止步于此。 我怀着坚定的信心回到家，因为亚马逊的版本将100％具有有趣之处，而且明天我肯定会为本文找到足够的bug。 您可能已经猜到了，我是对的。 <br><br><h2>  Amazon FreeRTOS隐藏的内容 </h2><br> 事实证明，亚马逊的系统版本是...稍微说得有点差。  FreeRTOS的遗产仍然很干净，而新的改进隐藏了许多有趣的问题。 <br><br> 有些片段破坏了程序逻辑，有些错误地处理了指针。 在某些地方，代码可能导致未定义的行为，并且在某些情况下，程序员根本不了解他所犯错误的模式。 我什至发现了几个严重的潜在漏洞。 <br><br> 似乎我已经加强了介绍。 让我们开始找出错误！ <br><br><h3> 程序逻辑的破坏 </h3><br> 让我们从有问题的地方开始，这些地方显然表明程序的工作方式与程序员预期的不同。 可疑数组处理将首先出现： <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @brief Pool of request and associated response buffers, * handles, and configurations. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> _requestPool_t _requestPool = { <span class="hljs-number"><span class="hljs-number">0</span></span> }; .... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _scheduleAsyncRequest(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> reqIndex, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> currentRange) { .... <span class="hljs-comment"><span class="hljs-comment">/* Set the user private data to use in the asynchronous callback context. */</span></span> _requestPool.pRequestDatas[reqIndex].pConnHandle = &amp;_connHandle; _requestPool.pRequestDatas[reqIndex].pConnConfig = &amp;_connConfig; _requestPool.pRequestDatas[reqIndex].reqNum = reqIndex; _requestPool.pRequestDatas[reqIndex].currRange = currentRange; _requestPool.pRequestDatas[reqIndex].currDownloaded = <span class="hljs-number"><span class="hljs-number">0</span></span>; _requestPool.pRequestDatas[reqIndex].numReqBytes = numReqBytes; .... _requestPool.pRequestDatas-&gt;scheduled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; .... }</code> </pre> <br>  PVS-Studio为此段代码发出了两个警告： <br><br><ul><li>  V619数组'_requestPool.pRequestDatas'被用作指向单个对象的指针。  iot_demo_https_s3_download_async.c 973 </li><li>  V574'_requestPool.pRequestDatas'指针同时用作数组和指向单个对象的指针。 检查行：931、973。iot_demo_https_s3_download_async.c 973 </li></ul><br> 以防万一，让我提醒您：数组名称是指向其第一个元素的指针。 也就是说，如果<i>_requestPool.pRequestDatas</i>是一个结构数组，则<i>_requestPool.pRequestDatas [i] .scheduled</i>是对<i>i</i>数组结构的已<i>调度</i>成员的评估。如果我们编写<i>_requestPool.pRequestDatas-&gt; chedule</i> ，结果将是第一个数组结构的成员将被访问。 <br><br> 在上面的代码摘录中，就是这样。 在最后一行中，仅第一个数组结构的成员的值被更改。 就其本身而言，这样的访问已经是可疑的，但是在这种情况下甚至更加清楚： <i>_requestPool.pRequestDatas</i>数组由整个函数主体中的索引评估。 但是最后，索引操作被遗忘了。 <br><br> 据我了解，最后一行应如下所示： <br><br><pre> <code class="cpp hljs">_requestPool.pRequestDatas[reqIndex].scheduled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br> 下一个错误在于一个小的函数，因此我将对其进行完整介绍： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Return true if the string " pcString" is found * inside the token pxTok in JSON file pcJson. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prvGGDJsoneq</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pcJson, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">jsmntok_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pxTok, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pcString )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ulStringSize = ( <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ) pxTok-&gt;end - ( <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ) pxTok-&gt;start; BaseType_t xStatus = pdFALSE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( pxTok-&gt;type == JSMN_STRING ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ) <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>( pcString ) == ulStringSize ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> ) <span class="hljs-built_in"><span class="hljs-built_in">strncmp</span></span>( &amp;pcJson[ pxTok-&gt;start ], <span class="hljs-comment"><span class="hljs-comment">// &lt;= pcString, ulStringSize ) == 0 ) { xStatus = pdTRUE; } } } return xStatus; }</span></span></code> </pre> <br>  <b>PVS-Studio警告：</b> V642 [CWE-197]将'strncmp'函数结果保存在'short'类型变量中是不合适的。 有效位可能会丢失，从而破坏程序的逻辑。 第637章 <br><br> 让我们看一下strncmp函数的定义： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strncmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *lhs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *rhs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count )</span></span></span></span>;</code> </pre> <br> 在该示例中，大小为32位的<i>int</i>类型的结果将转换为<i>int16_t</i>类型的变量。 通过这种“缩小”转换，将丢失返回值的旧位。 例如，如果<i>strncmp</i>函数返回<i>0x00010000</i> ，则在转换过程中单元将丢失，条件将被执行。 <br><br> 看到这种情况真的很奇怪。 如果普通<i>int</i>可以与零进行比较，为什么在这里需要它？ 另一方面，如果程序员希望此函数有时即使不应该返回<i>true</i> ，为什么不通过注释支持这种棘手的行为呢？ 但是这种方式有点后门。 无论如何，我倾向于认为这是一个错误。 你觉得呢 <br><br><h3> 未定义的行为和指针 </h3><br> 这是一个大例子。 它掩盖了潜在的空指针取消引用： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _networkReceiveCallback(....) { IotHttpsReturnCode_t status = IOT_HTTPS_OK; _httpsResponse_t* pCurrentHttpsResponse = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; IotLink_t* pQItem = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; .... <span class="hljs-comment"><span class="hljs-comment">/* Get the response from the response queue. */</span></span> IotMutex_Lock(&amp;(pHttpsConnection-&gt;connectionMutex)); pQItem = IotDeQueue_PeekHead(&amp;(pHttpsConnection-&gt;respQ)); IotMutex_Unlock(&amp;(pHttpsConnection-&gt;connectionMutex)); <span class="hljs-comment"><span class="hljs-comment">/* If the receive callback is invoked * and there is no response expected, * then this a violation of the HTTP/1.1 protocol. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pQItem == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { IotLogError(....); fatalDisconnect = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; status = IOT_HTTPS_NETWORK_ERROR; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> iotCleanup; } .... iotCleanup : <span class="hljs-comment"><span class="hljs-comment">/* Report errors back to the application. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status != IOT_HTTPS_OK) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( pCurrentHttpsResponse-&gt;isAsync &amp;&amp; pCurrentHttpsResponse-&gt;pCallbacks-&gt;errorCallback) { pCurrentHttpsResponse-&gt;pCallbacks-&gt;errorCallback(....); } pCurrentHttpsResponse-&gt;syncStatus = status; } .... }</code> </pre> <br>  <b>PVS-Studio警告：</b> V522 [CWE-690]可能会取消引用潜在的空指针'pCurrentHttpsResponse'。  iot_https_client.c 1184 <br><br> 最后一个<i>if</i>块包含有问题的取消引用。 让我们找出这里发生了什么。 <br><br> 该函数以<i>pCurrentHttpsResponse</i>和<i>pQItem</i>变量（由<i>NULL</i>值初始化）和<i>status</i>变量（由<i>IOT_HTTPS_OK</i>值）初始化<i>开始</i> ，这意味着它们都是正确的。 <br><br> 进一步为<i>pQItem</i>分配了从<i>IotDeQueue_PeekHead</i>函数返回的值，该函数返回指向双向链接队列开头的指针。 <br><br> 如果队列为空会怎样？ 在这种情况下， <i>IotDeQueue_PeekHead</i>函数将返回<i>NULL：</i> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> IotLink_t* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IotDeQueue_PeekHead</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IotDeQueue_t* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pQueue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IotListDouble_PeekHead(pQueue); } .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> IotLink_t* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IotListDouble_PeekHead</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IotListDouble_t* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pList)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/* @[declare_linear_containers_list_double_peekhead] */</span></span></span><span class="hljs-function"> </span></span>{ IotLink_t* pHead = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pList != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IotListDouble_IsEmpty(pList) == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { pHead = pList-&gt;pNext; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pHead; }</code> </pre> <br> 此外，条件<i>pQItem == NULL</i>将变为true，并且控制流将通过<i>goto</i>传递到函数的下部。 到此时， <i>pCurrentHttpsResponse</i>指针将保持为空，而<i>状态</i>将不等于<i>IOT_HTTPS_OK</i> 。 最后， <i>如果</i>分支，我们将达到相同的目标，……繁荣！ 好吧，您知道这种取消引用的后果。 <br><br> 好吧 这是一个有点棘手的例子。 现在，我建议您看一下一个非常简单且可以理解的潜在取消引用： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PKI_mbedTLSSignatureToPkcs11Signature</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pxSignaturePKCS, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pxMbedSignature )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xReturn = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> * pxNextLength; <span class="hljs-comment"><span class="hljs-comment">/* The 4th byte contains the length of the R component */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ucSigComponentLength = pxMbedSignature[ <span class="hljs-number"><span class="hljs-number">3</span></span> ]; <span class="hljs-comment"><span class="hljs-comment">// &lt;= if( ( pxSignaturePKCS == NULL ) || ( pxMbedSignature == NULL ) ) { xReturn = FAILURE; } .... }</span></span></code> </pre> <br>  <b>PVS-Studio警告：</b> V595 [CWE-476]在针对nullptr进行验证之前，已使用“ pxMbedSignature”指针。 检查行：52，54。iot_pki_utils.c 52 <br><br> 该函数接收指向<i>uint8_t的指针</i> 。 都检查两个指针​​是否为<i>NULL</i> ，这是一个好习惯-应该立即解决这种情况。 <br><br> 但这是问题所在：选中<i>pxMbedSignature时</i> ，它实际上已经在上面的一行中被取消引用。 塔达！ <br><br> 投机代码的另一个示例： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">CK_RV </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vAppendSHA256AlgorithmIdentifierSequence</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * x32ByteHashedMessage, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * x51ByteHashOidBuffer )</span></span></span><span class="hljs-function"> </span></span>{ CK_RV xResult = CKR_OK; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> xOidSequence[] = pkcs11STUFF_APPENDED_TO_RSA_SIG; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( x32ByteHashedMessage == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) || ( x51ByteHashOidBuffer == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) ) { xResult = CKR_ARGUMENTS_BAD; } <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>( x51ByteHashOidBuffer, xOidSequence, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( xOidSequence ) ); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>( &amp;x51ByteHashOidBuffer[ <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( xOidSequence ) ], x32ByteHashedMessage, <span class="hljs-number"><span class="hljs-number">32</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xResult; }</code> </pre> <br>  <b>PVS-Studio警告：</b> <br><br><ul><li>  V1004 [CWE-628]在针对nullptr对其进行验证后，不安全地使用了x51ByteHashOidBuffer指针。 检查行：275、280。iot_pkcs11.c 280 </li><li>  V1004 [CWE-628]在针对nullptr进行验证之后，不安全地使用了x32ByteHashedMessage指针。 检查行：275、281。iot_pkcs11.c 281 </li></ul><br> 分析器警告在检查<i>NULL</i>后不安全地使用作为指针的函数参数。 实际上，已检查了参数。 但是，如果其中任何一个都不为<i>NULL</i> ，则除了写入<i>xResult</i>之外，不会采取任何其他措施<i>。</i> 代码的这一部分说：“是的，因此论据证明是不好的。 我们现在要记录下来，您-继续前进，继续前进。” <br><br> 结果： <i>NULL</i>将被传递给<i>memcpy。</i> 它能带来什么？ 值将复制到哪里以及哪些值被复制？ 实际上，猜测将无济于事，因为标准<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">明确指出</a> ，这样的调用会导致未定义的行为（请参见第1节）。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf7/7d6/856/cf77d6856666f6a1529a1744832bd5bf.png" alt="图3"></div><br><br>  Amazon FreeRTOS的分析器报告中还有其他不正确的指针处理示例，但我认为，给出的示例足以显示PVS-Studio检测此类错误的功能。 让我们来看看一些新东西。 <br><br><h3>  TRUE！= 1 </h3><br> 与模式有关的错误有很多，但不幸的是，这些错误经常被忽略。 <br><br> 事实是， <i>布尔</i>类型（来自C ++）不同于<i>布尔</i>类型（通常用于C语言）。 第一个只能包含<i>true</i>或<i>false</i>值。 第二个是整数类型（ <i>int</i> ， <i>long</i>和其他类型）的typedef。  <i>0</i>值为“ false”，其他任何与零不同的值为“ true”。 <br><br> 由于C中没有内置的布尔类型，为方便起见定义了以下常量： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FALSE 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TRUE 1</span></span></code> </pre> <br> 让我们来看一个例子。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mbedtls_hardware_poll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* output, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* olen)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lStatus = MBEDTLS_ERR_ENTROPY_SOURCE_FAILED; HCRYPTPROV hProv = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Unferenced parameter. */</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)data; <span class="hljs-comment"><span class="hljs-comment">/* * This is port-specific for the Windows simulator, * so just use Crypto API. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TRUE == CryptAcquireContextA( &amp;hProv, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TRUE == CryptGenRandom(hProv, len, output)) { lStatus = <span class="hljs-number"><span class="hljs-number">0</span></span>; *olen = len; } CryptReleaseContext(hProv, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lStatus; }</code> </pre> <br>  <b>PVS-Studio警告：</b> <br><br><ul><li>  V676 [CWE-253]比较BOOL类型的变量和TRUE是不正确的。  aws_entropy_hardware_poll.c 48 </li><li>  V676 [CWE-253]比较BOOL类型的变量和TRUE是不正确的。 正确的表达式是：“ FALSE！= CryptGenRandom（hProv，len，输出）”。  aws_entropy_hardware_poll.c 51 </li></ul><br> 发现错误了吗？ 毫无疑问，它在这里：) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i>CryptAcquireContextA</i></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i>CryptGenRandom</i></a>函数是<i>wincrypt.h</i>标头中的标准函数。 如果成功，它们将返回非零值。 让我强调一下，它是<i>非零的</i> 。 因此，理论上，它可以是不同于零的任何值： <i>1、314、42、420</i> 。 <br><br> 显然，从示例中编写函数的程序员没有考虑这一点，最后，将结果值与一个进行比较。 <br><br>  <i>TRUE == CryptGenRandom（....）</i>条件<i>不满足的</i>可能性有<i>多大</i> ？ 很难说。 也许， <i>CryptGenRandom</i>可能比其他值返回1的频率更高，但是也许它可能仅返回1。我们不能肯定地知道这一点：加密功能的实现对凡人程序员是隐藏的：) <br><br> 重要的是要记住，这样的比较有潜在的危险。 代替： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TRUE == GetBOOL())</code> </pre> <br> 使用更安全的代码版本： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FALSE != GetBOOL())</code> </pre> <br><h3> 优化问题 </h3><br> 分析仪的一些警告与运行缓慢的结构有关。 例如： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _IotHttpsDemo_GetS3ObjectFileSize(....) { .... pFileSizeStr = <span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>(contentRangeValStr, <span class="hljs-string"><span class="hljs-string">"/"</span></span>); .... }</code> </pre> <br>  <b>PVS-Studio警告：</b> V817查找'/'字符而不是字符串更有效。  iot_demo_https_common.c 205 <br><br> 简短而简单，不是吗？ 在这里， <i>strstr</i>函数仅用于搜索一个字符，该字符作为字符串传入参数中（用双引号引起来）。 <br><br> 可以通过将<i>strstr</i>替换为<i>strchr</i>来优化该位置： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _IotHttpsDemo_GetS3ObjectFileSize(....) { .... pFileSizeStr = <span class="hljs-built_in"><span class="hljs-built_in">strchr</span></span>(contentRangeValStr, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); .... }</code> </pre> <br> 这样，搜索将工作得更快。 一件很小但是很好的事情。 <br><br> 好的，这样的优化是好的，但是分析仪还找到了另一个地方，可以用更加明显的方式对其进行优化： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vRunOTAUpdateDemo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; ; ) { .... xConnectInfo.cleanSession = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; xConnectInfo.clientIdentifierLength = (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>)<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(clientcredentialIOT_THING_NAME); xConnectInfo.pClientIdentifier = clientcredentialIOT_THING_NAME; .... } }</code> </pre> <br>  <b>PVS-Studio警告：</b> V814性能下降。 在循环体内多次调用了“ strlen”函数。  aws_iot_ota_update_demo.c 235 <br><br> 嗯...在循环内部，每次迭代都会调用<i>strlen</i> ，每次都评估同一行的长度。 不是最有效的操作:) <br><br> 让我们看一下<i>clientcredentialIOT_THING_NAME</i>的定义： <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * @brief Host name. * * @todo Set this to the unique name of your IoT Thing. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> clientcredentialIOT_THING_NAME </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span></span></code> </pre> <br> 要求用户在此处输入其设备的名称。 默认情况下，它是空的，在这种情况下，一切都很好。 如果用户想在此处输入一个长而优美的名称怎么办？ 例如，我很想将自己的<i>想法</i>称为“ <i>热情而精致的咖啡机BarBarista-N061E Ultimate Edition”</i> 。 您能想象如果我那台漂亮的咖啡机在那之后开始工作慢一点，会给我带来什么惊喜？ 讨厌 <br><br> 要更正错误，值得在体循环之外<i>大吃一惊</i> 。 毕竟，程序运行期间设备的名称不会更改。 哦，C ++的<i>constexpr</i>非常适合这里... <br><br> 好吧，好吧，让我们不要为百合花镀金。 正如我的同事安德烈·卡波夫（Andrey Karpov）所指出的那样，现代编译器知道有什么<i>奇怪的东西</i> ，他亲自用二进制代码中的常量监视它们，如果它们知道行的长度不能改变。 因此，很有可能在发行版本构建模式中，将使用预先评估的值来代替实际的行长评估。 但是，这并不总是可行的，因此编写这样的代码不是一个好习惯。 <br><br><h2> 关于MISRA的几句话 </h2><br>  PVS-Studio分析仪具有大量规则，可检查您的代码是否符合MISRA C和MISRA C标准。 这些标准是什么？ <br><br>  MISRA是高度负责的嵌入式系统的编码标准。 它包含一组用于编写代码和建立开发过程的严格规则和准则。 这些规则很多，它们不仅旨在消除严重的错误，而且还针对各种“代码味道”。 它还旨在编写最易懂和易读的代码。 <br><br> 因此，遵循MISRA标准不仅有助于避免错误和漏洞，而且还可以大大减少错误和漏洞在已经存在的代码中出现的可能性。 <br><br>  MISRA用于航空，医疗，汽车和军事行业，在这些行业中，人们的生活取决于嵌入式软件的质量。 <br><br> 显然，Amazon FreeRTOS开发人员了解此标准，并且在大多数情况下都遵循它。 这种方法绝对合理：如果您为嵌入式系统编写基础广泛的OS，则必须考虑安全性。 <br><br> 但是，我发现很多违反MISRA标准的行为。 我将不提供“不使用联合”或“功能只能在身体尽头获得回报”之类的规则示例-不幸的是，它们不像大多数MISRA规则那样引人注目。 我想举几个例子，说明可能会导致严重后果的违规行为。 <br><br> 让我们从宏开始： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FreeRTOS_ms_to_tick(ms) ( ( ms * configTICK_RATE_HZ + 500 ) / 1000 )</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SOCKETS_htonl( ulIn ) ( ( uint32_t ) \ ( ( ( ulIn &amp; 0xFF ) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 24 ) | ( ( ulIn &amp; 0xFF00 ) &lt;&lt; 8 ) \ | ( ( ulIn &amp; 0xFF0000 ) &gt;&gt; 8 ) | ( ( ulIn &amp; 0xFF000000 ) &gt;&gt; 24 ) ) )</span></span></span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LEFT_ROTATE( x, c ) ( ( x </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; c ) | ( x &gt;&gt; ( 32 - c ) ) )</span></span></span></span></code> </pre> <br>  <b>PVS-Studio警告：</b> <br><br><ul><li>  V2546 [MISRA C 20.7]宏及其参数应放在括号中。 考虑检查“ FreeRTOS_ms_to_tick”宏的“ ms”参数。  FreeRTOS_IP.h 201 </li><li>  V2546 [MISRA C 20.7]宏及其参数应放在括号中。 考虑检查“ SOCKETS_htonl”宏的“ ulIn”参数。  iot_secure_sockets.h 512 </li><li>  V2546 [MISRA C 20.7]宏及其参数应放在括号中。 考虑检查“ LEFT_ROTATE”宏的参数“ x”，“ c”。  iot_device_metrics.c 90 </li></ul><br> 是的，这正是您的想法。 这些宏的参数未括在方括号中。 如果有人不小心写了类似 <br><br><pre> <code class="cpp hljs">val = LEFT_ROTATE(A[i] | <span class="hljs-number"><span class="hljs-number">1</span></span>, B);</code> </pre> <br> 这样的宏“调用”将扩展为： <br><br><pre> <code class="cpp hljs">val = ( ( A[i] | <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; B ) | ( A[i] | <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt; ( <span class="hljs-number"><span class="hljs-number">32</span></span> - B ) ) );</code> </pre> <br> 还记得运营的重点吗？ 首先，进行按位移位，并且只有在此之后才进行按位“或”。 因此，该程序的逻辑将被破坏。 一个简单的例子：如果在<i>FreeRTOS_ms_to_tick</i>宏中传递表达式“ <i>x + y</i> ”，将会发生什么？  MISRA的主要目标之一就是预防这种情况。 <br><br> 有人可能会争辩说：“如果您有对此一无所知的程序员，那么没有任何标准可以帮助您！” 我不同意。 程序员也是人，无论一个人的经验如何，他们最终都会感到疲倦并犯错。 这就是MISRA强烈建议使用自动分析工具来测试项目符合性的原因之一。 <br><br> 让我向Amazon FreeRTOS的开发人员致辞：PVS-Studio发现了12个更多不安全的宏，因此您需要谨慎对待它们：) <br><br> 另一个有趣的MISRA违规行为： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @brief Callback for an asynchronous request to notify * that the response is complete. * * @param[in] 0pPrivData - User private data configured * with the HTTPS Client library request configuration. * @param[in] respHandle - Identifier for the current response finished. * @param[in] rc - Return code from the HTTPS Client Library * signaling a possible error. * @param[in] status - The HTTP response status. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _responseCompleteCallback(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* pPrivData, IotHttpsResponseHandle_t respHandle, IotHttpsReturnCode_t rc, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> status) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>* pUploadSuccess = (<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>*)pPrivData; <span class="hljs-comment"><span class="hljs-comment">/* When the remote server response with 200 OK, the file was successfully uploaded. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status == IOT_HTTPS_STATUS_OK) { *pUploadSuccess = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { *pUploadSuccess = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* Post to the semaphore that the upload is finished. */</span></span> IotSemaphore_Post(&amp;(_uploadFinishedSem)); }</code> </pre> <br> 您可以自己找到错误吗？ <br><br>  <b>PVS-Studio警告：</b> V2537 [MISRA C 2.7]功能中不应包含未使用的参数。 考虑检查参数：“ rc”。  iot_demo_https_s3_upload_async.c 234 <br><br> 仔细看看： <i>rc</i>参数未在函数主体中的任何地方使用。 该函数的注释清楚地表明该参数是另一个函数的返回码，并且它可能表示错误。 为什么不以任何方式处理此参数？ 显然这里有些错误。 <br><br> 但是，即使没有这些注释，未使用的参数也经常指向程序的逻辑中断。 否则，为什么在功能签名中需要它们？ <br><br> 在这里，我给出了一个小的函数，该函数对于本文中的示例非常有用。 除此之外，我发现了10个其他未使用的参数。 它们中的许多都用于较大的功能，因此检测起来并不容易。 <br><br> 可疑的是，以前没有找到它们。 毕竟，编译器很容易检测到这种情况。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b80/6c7/bb9/b806c7bb94c335ce2712e9b46cffc560.png" alt="图1"></div><br><br><h2> 结论 </h2><br> 这些不是分析仪发现的所有问题，但文章原来已经很大。 我希望借此，亚马逊FreeRTOS开发人员将能够纠正一些缺陷，甚至可能希望自己<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">尝试PVS-Studio</a> 。 这样，彻底调查警告将更加方便。 事实上，使用便捷的界面比查看文本报告要容易得多。 <br><br> 感谢您阅读我们的文章！ 下次见：D <br><br>  PS恰巧，这篇文章于10月31日发表。万圣节快乐，男孩和女孩！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN473966/">https://habr.com/ru/post/zh-CN473966/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN473952/index.html">当我为回合制策略编写AI时</a></li>
<li><a href="../zh-CN473956/index.html">来自毒贩电话公司的秘密信息</a></li>
<li><a href="../zh-CN473958/index.html">来自NICT的日本人推出了工作带宽为1 Pbit / s的光纤集群</a></li>
<li><a href="../zh-CN473960/index.html">内容本地化策略</a></li>
<li><a href="../zh-CN473962/index.html">黑暗模式现在无处不在。 这样有用吗？ （在后期调查之后）</a></li>
<li><a href="../zh-CN473972/index.html">按嵌入式开发人员的顺序：在Amazon FreeRTOS中查找错误</a></li>
<li><a href="../zh-CN473974/index.html">Intercom'19-Voximplant的通信自动化会议将于11月14日举行</a></li>
<li><a href="../zh-CN473976/index.html">AWS Elasticsearch：基本缺陷产品</a></li>
<li><a href="../zh-CN473978/index.html">这样的痛苦，这样的痛苦，收银机服务2：0</a></li>
<li><a href="../zh-CN473980/index.html">技术与现实世界：4家正在改变室内设计未来的初创企业</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>