<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüë¶ üëãüèø üë®üèº‚Äçüî¨ OpenSceneGraph: Integrasi dengan Qt Framework üë©üèº‚Äçüéì üë©üèΩ‚Äçüåæ üåµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Di satu sisi, mesin OpenSceneGraph sendiri memiliki subsistem canggih untuk mengelola windows, memproses peristiwa input pengguna, mengi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Integrasi dengan Qt Framework</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438654/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg"><br><br><h1>  Pendahuluan </h1><br>  Di satu sisi, mesin OpenSceneGraph sendiri memiliki subsistem canggih untuk mengelola windows, memproses peristiwa input pengguna, mengirim dan menerima pesan pengguna.  Kami membicarakan hal ini secara mendetail dalam artikel-artikel sebelumnya dari seri ini.  Secara umum, bersama dengan kemampuan C ++ / STL, ini cukup untuk mengembangkan aplikasi yang kompleks dan semena-mena. <br><br>  <i>Contoh mengintegrasikan OSG ke dalam aplikasi yang dikembangkan oleh QtDesigner.</i>  <i>Contoh ini akan dibahas secara rinci di bawah ini.</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1LWLSxAUWwU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Di sisi lain, untuk mempercepat pengembangan di C ++, kedua pustaka pihak ketiga digunakan yang memperluas kemampuan bahasa ini (seperti boost), dan seluruh kerangka kerja memungkinkan Anda untuk dengan mudah dan alami mengembangkan aplikasi lintas platform dari tujuan fungsional yang luas.  Salah satu kerangka kerja tersebut adalah Qt yang sangat populer.  Tidak peduli bagaimana mereka memarahi Qt untuk kompiler meta-objek dan kekurangan dan ketidaknyamanan lainnya, kekuatan Qt ada di perpustakaan kelas yang luas yang menyelesaikan semua tugas yang mungkin terjadi dalam pengembangan lintas-platform, serta dalam konsep "sinyal - slot" yang mengimplementasikan subsistem pesan antar kelas.  Sinyal dan slot juga didasarkan pada metode interaksi antara aplikasi dan sistem operasi, serta komunikasi antarproses. <br><br>  Dan sungguh, akan sangat menarik untuk menggabungkan dua teknologi: Qt dan OSG.  Tim saya harus menyelesaikan masalah serupa, yang sudah saya tulis di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">salah satu publikasi saya</a> .  Namun, saya ingin membuka pertanyaan ini sedikit lebih luas, dan artikel ini akan membahas topik ini. <br><a name="habracut"></a><br>  Ada dua opsi untuk mengintegrasikan OSG dan Qt: <br><br><ol><li>  Menggunakan Qt Sinyal dan Slot untuk Berinteraksi Objek dalam Aplikasi OSG <br></li><li>  Integrasi penampil OSG ke antarmuka grafis yang dikembangkan dalam C ++ / Qt, termasuk penggunaan perancang formulir QtDesigner <br></li></ol><br>  Opsi pertama berlaku ketika Anda tidak perlu menggunakan elemen GUI yang disediakan oleh Qt, tetapi Anda ingin memastikan interaksi komponen aplikasi melalui sinyal dan slot.  Misalnya, kebutuhan seperti itu muncul bagi saya untuk mengintegrasikan aplikasi OSG dengan perpustakaan komunikasi antarproses melalui soket TCP menggunakan Qt. <br><br>  Opsi kedua diperlukan ketika integrasi mesin OSG dan aplikasi grafis yang dikembangkan menggunakan Qt diperlukan.  Sinyal dan slot tersedia untuk kita, dan selain itu, seluruh jajaran elemen GUI standar yang disediakan oleh Qt. <br><br><h1>  1. Sinyal Qt dalam Sistem Jendela OSG </h1><br>  Contoh pertama akan agak sintetik: kita menulis aplikasi OSG sederhana dengan adegan primitif;  buat dua kelas, yang satu akan menangani penekanan tombol, dan yang lainnya untuk menampilkan pesan ke konsol tentang tombol mana yang ditekan.  Dalam hal ini, pawang akan menghasilkan sinyal Qt, dengan pesan tentang tombol yang ditekan sebagai parameter. <br><br>  Untuk berintegrasi dengan Qt, cukup untuk memenuhi tiga kondisi berikut <br><br><ol><li>  Mewarisi kelas yang berinteraksi dari QObject <br></li><li>  Atur loop pemrosesan sinyal <br></li><li>  Buat turunan dari kelas QApplication (atau QCoreApplication) yang ada di memori selama operasi aplikasi <br></li></ol><br>  Kode contoh lengkap dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori OSG-lesson saya</a> , yang berisi semua pelajaran untuk siklus ini. <br><br>  Pertama, buat kelas yang akan "memutar" antrian pemrosesan sinyal. <br><br>  <strong>qt-events.h</strong> <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> QT_EVENTS_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> QT_EVENTS_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgGA/GUIEventHandler&gt; #include &lt;QCoreApplication&gt; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class QtEventsHandler : public osgGA::GUIEventHandler { public: QtEventsHandler(); virtual bool handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa); protected: }; #endif // QT_EVENTS_H</span></span></span></span></code> </pre> <br>  <strong>qt-events.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"qt-events.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ QtEventsHandler::QtEventsHandler() { } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ bool QtEventsHandler::handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa) { Q_UNUSED(aa) switch (ea.getEventType()) { case osgGA::GUIEventAdapter::FRAME: { // Process qt signals and event QCoreApplication::processEvents(QEventLoop::AllEvents); break; } default: break; } return false; }</span></span></span></span></code> </pre><br>  Semuanya sangat sederhana - kelas ini adalah pengendali event OSG standar yang, ketika merender bingkai, memulai pemrosesan antrian sinyal Qt dengan memanggil <br><br><pre> <code class="cpp hljs">QCoreApplication::processEvents(QEventLoop::AllEvents);</code> </pre><br>  Sekarang mari kita buat kelas yang memproses keyboard, sekali lagi, menggunakan mekanisme yang dibangun ke dalam OSG, tetapi pada saat yang sama dapat mengirim sinyal Qt.  Untuk melakukan ini, kita akan menggunakan multiple inheritance yang baru-baru ini dianalisa <br><br>  <strong>keyhandler.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> KEY_HANDLER_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> KEY_HANDLER_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgGA/GUIEventHandler&gt; #include &lt;QObject&gt; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class KeyboardHandler : public QObject, public osgGA::GUIEventHandler { Q_OBJECT public: KeyboardHandler(QObject *parent = Q_NULLPTR) : QObject(parent) , osgGA::GUIEventHandler () { } bool handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa) { switch (ea.getEventType()) { case osgGA::GUIEventAdapter::KEYDOWN: emit sendMessage("Pressed key " + QString(ea.getKey())); break; default: break; } return false; } signals: void sendMessage(QString msg); private: }; #endif // KEY_HANDLER_H</span></span></span></span></code> </pre><br>  Kelas akan memproses pesan tentang tombol yang ditekan dan mengirim sinyal dengan pesan yang berisi kode tombol yang ditekan.  Sinyal ini akan diterima oleh kelas yang tidak terhubung dengan OSG, yang merupakan turunan dari QObject dan berisi satu slot tunggal yang mencetak pesan ke output standar <br><br>  <strong>penerima. h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> RECEIVER_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RECEIVER_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QObject&gt; #include &lt;iostream&gt; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class Receiver : public QObject { Q_OBJECT public: Receiver(QObject *parent = Q_NULLPTR) : QObject(parent) {} public slots: void printMessage(QString msg) { std::cout &lt;&lt; msg.toStdString() &lt;&lt; std::endl; } }; #endif // RECEIVER_H</span></span></span></span></code> </pre><br>  Sekarang kumpulkan semuanya dengan menulis aplikasi OSG <br><br>  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgViewer/Viewer&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;QCoreApplication&gt; #include "qt-events.h" #include "keyhandler.h" #include "receiver.h" #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { QCoreApplication app(argc, argv); osg::ref_ptr&lt;osg::Node&gt; scene = osgDB::readNodeFile("../data/cessnafire.osg"); osgViewer::Viewer viewer; viewer.setSceneData(scene.get()); viewer.addEventHandler(new QtEventsHandler); viewer.setUpViewInWindow(0, 0, 1024, 768); KeyboardHandler *keyboardHandler = new KeyboardHandler; Receiver *receiver = new Receiver; QObject::connect(keyboardHandler, &amp;KeyboardHandler::sendMessage, receiver, &amp;Receiver::printMessage); viewer.addEventHandler(keyboardHandler); return viewer.run(); }</span></span></span></span></code> </pre><br>  Pertama, kami membuat turunan dari kelas QCoreApplication. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">QCoreApplication </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">app</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(argc, argv)</span></span></span></span>;</code> </pre><br>  Ini diperlukan agar teknologi yang dijelaskan itu berfungsi.  Namun, kami <em>tidak akan memanggil metode QCoreApplication :: exec ()</em> !  Sebagai gantinya, loop pemrosesan sinyal akan berputar di dalam loop osgViewer :: Viewer :: run () kami, tempat kami membuat dan mendaftarkan handler yang sesuai <br><br><pre> <code class="cpp hljs">viewer.addEventHandler(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QtEventsHandler);</code> </pre><br>  Kami membuat instance kelas yang akan berinteraksi melalui sinyal Qt, menghubungkan sinyal satu dengan slot lainnya <br><br><pre> <code class="cpp hljs">KeyboardHandler *keyboardHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyboardHandler; Receiver *receiver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Receiver; QObject::connect(keyboardHandler, &amp;KeyboardHandler::sendMessage, receiver, &amp;Receiver::printMessage);</code> </pre><br>  Daftarkan pengendali keyboard <br><br><pre> <code class="cpp hljs">viewer.addEventHandler(keyboardHandler);</code> </pre><br>  Semua menjalankan penampil <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  dan melihat gambar seperti itu <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HKJJb0cMl7I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Ya, contohnya agak dibuat-buat, tetapi itu menggambarkan prinsip-prinsip utama mengintegrasikan kode menggunakan mekanisme Qt ke dalam aplikasi menggunakan OSG.  Gagasan ini, diperoleh dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenSceneGraph 3. Cookbook</a> , menghemat banyak waktu dan keberanian bagi saya dan tim pengembangan saya, memungkinkan saya untuk menggunakan modul berbasis Qt yang didebug dan dibakukan dalam basis kode kami di basis kode kami. <br><br>  Tetapi bagaimana jika kita masih ingin menggunakan OSG di dalam aplikasi Qt GUI? <br><br><h1>  2. pustaka osgQt </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">osgQt</a> adalah perpustakaan integrasi yang dirancang untuk: <br><br><ol><li>  Menanamkan adegan 3D diimplementasikan pada OSG dalam antarmuka grafis dari aplikasi yang dikembangkan di Qt </li><li>  Menyematkan widget Qt pada permukaan geometri 3D di dalam adegan OSG.  Ya, Anda dengar - Widget Qt dapat bekerja dengan tenang di dalam dunia virtual.  Suatu hari saya pasti akan menunjukkannya </li></ol><br>  Ada beberapa masalah dengan perpustakaan ini, yang kami atasi dengan mempelajari contoh-contoh terlampir dan membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenSceneGraph 3. Cookbook yang</a> telah disebutkan sebelumnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">.</a> <br><br>  Perpustakaan harus dikumpulkan, dan proses ini mirip dengan perakitan mesin itu sendiri, dijelaskan secara rinci dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel pertama siklus</a> .  Satu-satunya komentar adalah bahwa -DCMAKE_INSTALL_PREFIX harus dipilih dengan yang sama yang ditentukan saat membangun mesin - jadi osgQt akan dipasang di sebelah mesin, dan akan nyaman digunakan selama pengembangan. <br><br><h1>  3. Integrasi osgViewer :: Viewer ke dalam GUI Qt </h1><br>  Contoh berikut akan sangat berguna.  Kami akan menulis penampil yang memungkinkan Anda memuat model format * .osg menggunakan kontrol Qt standar.  Selain itu, untuk mengembangkan antarmuka grafis, kami menggunakan QtDeisgner. <br><br>  Mari kita buat proyek baru seperti "Aplikasi Qt Widgets" <br><br><img src="https://habrastorage.org/webt/hk/t5/sj/hkt5sjllzcuqyfyfm08ugnag0bw.png"><br><br>  Dalam hal ini, jendela aplikasi utama akan dihasilkan dengan bilah menu, bilah alat dan bilah status.  Di QtDesigner, tambahkan komponen QFrame ke jendela ini. <br><br> <a href=""><img src="https://habrastorage.org/webt/ek/4r/8c/ek4r8can5b5v63ex03jbw0v4czu.png"></a> <br><br>  Kami akan menempatkan penampil OSG di bingkai ini.  Penampil OSG pada dasarnya akan menjadi widget Qt, untuk implementasinya kita akan menulis kelas QViewerWidget.  Saya akan meletakkan sumber lengkap di spoiler, agar tidak mengaburkan presentasi dengan lembar kode <br><br><div class="spoiler">  <b class="spoiler_title">qviewerwidget.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> QVIEWER_WIDGET_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> QVIEWER_WIDGET_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QWidget&gt; #include &lt;osgViewer/Viewer&gt; #include &lt;osgQt/GraphicsWindowQt&gt; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class QViewerWidget : public QWidget { public: QViewerWidget(const QRect &amp;geometry); virtual ~QViewerWidget(); osg::Group *getScene(); osgViewer::Viewer *getViewer(); protected: osg::ref_ptr&lt;osg::Group&gt; scene; osgViewer::Viewer viewer; private: osgQt::GraphicsWindowQt *createGraphicsWindow(const QRect &amp;geometry); void initCamera(const QRect &amp;geometry); void paintEvent(QPaintEvent *); }; #endif // QVIEWER_WIDGET_H</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">qviewerwidget.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs">include <span class="hljs-string"><span class="hljs-string">"qviewerwidget.h"</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgViewer/ViewerEventHandlers&gt; #include &lt;osgGA/TrackballManipulator&gt; #include &lt;QGridLayout&gt; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ QViewerWidget::QViewerWidget(const QRect &amp;geometry) : QWidget() , scene(new osg::Group) { initCamera(geometry); viewer.setSceneData(scene); viewer.addEventHandler(new osgViewer::StatsHandler); viewer.setCameraManipulator(new osgGA::TrackballManipulator); viewer.setThreadingModel(osgViewer::Viewer::SingleThreaded); osgQt::GraphicsWindowQt *gw = static_cast&lt;osgQt::GraphicsWindowQt *&gt;(viewer.getCamera()-&gt;getGraphicsContext()); QGridLayout *layout = new QGridLayout; if (layout != Q_NULLPTR) { layout-&gt;addWidget(gw-&gt;getGLWidget()); this-&gt;setLayout(layout); } } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ QViewerWidget::~QViewerWidget() { } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osg::Group *QViewerWidget::getScene() { return scene.get(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osgViewer::Viewer *QViewerWidget::getViewer() { return &amp;viewer; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osgQt::GraphicsWindowQt *QViewerWidget::createGraphicsWindow(const QRect &amp;geometry) { osg::DisplaySettings *ds = osg::DisplaySettings::instance().get(); osg::ref_ptr&lt;osg::GraphicsContext::Traits&gt; traits = new osg::GraphicsContext::Traits; traits-&gt;windowName = ""; traits-&gt;windowDecoration = false; traits-&gt;x = geometry.x(); traits-&gt;y = geometry.y(); traits-&gt;width = geometry.width(); traits-&gt;height = geometry.height(); if (traits-&gt;height == 0) traits-&gt;height = 1; traits-&gt;doubleBuffer = true; traits-&gt;alpha = ds-&gt;getMinimumNumAlphaBits(); traits-&gt;stencil = ds-&gt;getMinimumNumStencilBits(); traits-&gt;sampleBuffers = ds-&gt;getMultiSamples(); traits-&gt;samples = ds-&gt;getNumMultiSamples(); return new osgQt::GraphicsWindowQt(traits.get()); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void QViewerWidget::initCamera(const QRect &amp;geometry) { osg::Camera *camera = viewer.getCamera(); osg::ref_ptr&lt;osgQt::GraphicsWindowQt&gt; gw = createGraphicsWindow(geometry); gw-&gt;setTouchEventsEnabled(true); camera-&gt;setGraphicsContext(gw.get()); const osg::GraphicsContext::Traits *traits = gw-&gt;getTraits(); camera-&gt;setClearColor(osg::Vec4(0.7f, 0.7f, 0.7f, 1.0f)); camera-&gt;setViewport(0, 0, traits-&gt;width, traits-&gt;height); double aspect = static_cast&lt;double&gt;(traits-&gt;width) / static_cast&lt;double&gt;(traits-&gt;height); camera-&gt;setProjectionMatrixAsPerspective(30.0, aspect, 1.0, 1000.0); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void QViewerWidget::paintEvent(QPaintEvent *) { viewer.frame(); }</span></span></span></span></code> </pre><br></div></div><br>  Gagasan utama penerapannya adalah menggunakan kelas osgQt :: GraphicsWindow, yang menciptakan jendela grafis berdasarkan kelas QGLWidget.  Untuk membuat jendela ini, gunakan metode ini <br><br><pre> <code class="cpp hljs">osgQt::GraphicsWindowQt *QViewerWidget::createGraphicsWindow(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QRect &amp;geometry) { osg::DisplaySettings *ds = osg::DisplaySettings::instance().get(); osg::ref_ptr&lt;osg::GraphicsContext::Traits&gt; traits = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::GraphicsContext::Traits; traits-&gt;windowName = <span class="hljs-string"><span class="hljs-string">""</span></span>; traits-&gt;windowDecoration = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; traits-&gt;x = geometry.x(); traits-&gt;y = geometry.y(); traits-&gt;width = geometry.width(); traits-&gt;height = geometry.height(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (traits-&gt;height == <span class="hljs-number"><span class="hljs-number">0</span></span>) traits-&gt;height = <span class="hljs-number"><span class="hljs-number">1</span></span>; traits-&gt;doubleBuffer = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; traits-&gt;alpha = ds-&gt;getMinimumNumAlphaBits(); traits-&gt;stencil = ds-&gt;getMinimumNumStencilBits(); traits-&gt;sampleBuffers = ds-&gt;getMultiSamples(); traits-&gt;samples = ds-&gt;getNumMultiSamples(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgQt::GraphicsWindowQt(traits.get()); }</code> </pre><br>  Jendela dikonfigurasikan sesuai dengan parameter geometri yang dikirim ke input dan pengaturan yang diperlukan untuk rendering 3D OSG.  Pointer yang dikembalikan adalah konteks grafis OSG yang harus diteruskan ke kamera.  Karena itu, langkah selanjutnya adalah menginisialisasi kamera <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QViewerWidget::initCamera(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QRect &amp;geometry) { osg::Camera *camera = viewer.getCamera(); osg::ref_ptr&lt;osgQt::GraphicsWindowQt&gt; gw = createGraphicsWindow(geometry); gw-&gt;setTouchEventsEnabled(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); camera-&gt;setGraphicsContext(gw.get()); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osg::GraphicsContext::Traits *traits = gw-&gt;getTraits(); camera-&gt;setClearColor(osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); camera-&gt;setViewport(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, traits-&gt;width, traits-&gt;height); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> aspect = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(traits-&gt;width) / <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(traits-&gt;height); camera-&gt;setProjectionMatrixAsPerspective(<span class="hljs-number"><span class="hljs-number">30.0</span></span>, aspect, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1000.0</span></span>); }</code> </pre><br>  Panggilan yang sebenarnya <br><br><pre> <code class="cpp hljs">camera-&gt;setGraphicsContext(gw.get());</code> </pre><br>  dan meneruskan konteks yang diinginkan terkait dengan widget QGLWidget ke kamera.  Kami menempatkan seluruh widget rutin di konstruktor kelas <br><br><pre> <code class="cpp hljs">QViewerWidget::QViewerWidget(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QRect &amp;geometry) : QWidget() , scene(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group) { initCamera(geometry); viewer.setSceneData(scene); viewer.addEventHandler(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgViewer::StatsHandler); viewer.setCameraManipulator(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgGA::TrackballManipulator); viewer.setThreadingModel(osgViewer::Viewer::SingleThreaded); osgQt::GraphicsWindowQt *gw = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osgQt::GraphicsWindowQt *&gt;(viewer.getCamera()-&gt;getGraphicsContext()); QGridLayout *layout = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QGridLayout; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (layout != Q_NULLPTR) { layout-&gt;addWidget(gw-&gt;getGLWidget()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;setLayout(layout); } }</code> </pre><br>  Di sini kita mengonfigurasi pemirsa dan memberi perhatian khusus pada tantangan <br><br><pre> <code class="cpp hljs">viewer.setThreadingModel(osgViewer::Viewer::SingleThreaded);</code> </pre><br>  Mengalihkan penampil ke mode single-threaded.  Ini adalah langkah yang perlu ketika mengintegrasikan OSG ke Qt, karena pada beberapa distribusi Linux program akan macet ketika menggunakan rendering multi-threaded yang digunakan oleh OSG secara default.  Alasan untuk ini memerlukan pembekalan terpisah, jadi lanjutkan dan perhatikan kode ini <br><br><pre> <code class="cpp hljs">osgQt::GraphicsWindowQt *gw = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osgQt::GraphicsWindowQt *&gt;(viewer.getCamera()-&gt;getGraphicsContext()); QGridLayout *layout = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QGridLayout; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (layout != Q_NULLPTR) { layout-&gt;addWidget(gw-&gt;getGLWidget()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;setLayout(layout); }</code> </pre><br>  di mana kami membuat layer, mengganggu QGLWidget yang dikembalikan dari konteks grafik kamera, dikonversi ke pointer osgQt :: GraphicsWindows.  Kami menambahkan layer yang dibuat ke widget QViewerWidget kami dengan menelepon <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;setLayout(layout);</code> </pre><br>  Agar widget kami, dan dengan itu, adegan harus diperbarui ketika jendela diperbarui, Anda perlu mendefinisikan kembali pengendali event QPaintEvent <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QViewerWidget::paintEvent(QPaintEvent *) { viewer.frame(); }</code> </pre><br>  di mana kita memulai rendering frame dengan memanggil metode osgViewer :: Viewer :: frame (). <br><br>  Oke, kode widget kami sudah siap, sekarang kami menyematkannya dalam bingkai yang terletak di formulir.  Untuk melakukan ini, dalam konstruktor kelas MainWindow kita menulis kode seperti itu <br><br><pre> <code class="cpp hljs">MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Ui::MainWindow) , qviewer(Q_NULLPTR) { ui-&gt;setupUi(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); QGridLayout *layout = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QGridLayout; qviewer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QViewerWidget(QRect(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ui-&gt;frame-&gt;width(), ui-&gt;frame-&gt;height())); layout-&gt;addWidget(qviewer); ui-&gt;frame-&gt;setLayout(layout); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;setCentralWidget(ui-&gt;frame); connect(&amp;timer, &amp;QTimer::timeout, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;MainWindow::update); timer.start(<span class="hljs-number"><span class="hljs-number">40</span></span>); connect(ui-&gt;actionQuit, &amp;QAction::triggered, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;MainWindow::quit); connect(ui-&gt;actionClean, &amp;QAction::triggered, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;MainWindow::clean); connect(ui-&gt;actionOpen, &amp;QAction::triggered, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;MainWindow::open); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;setWindowTitle(<span class="hljs-string"><span class="hljs-string">"QViewerWidget example"</span></span>); }</code> </pre><br>  atau lebih tepatnya, kami masih tertarik pada bagian ini <br><br><pre> <code class="cpp hljs">QGridLayout *layout = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QGridLayout; qviewer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QViewerWidget(QRect(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ui-&gt;frame-&gt;width(), ui-&gt;frame-&gt;height())); layout-&gt;addWidget(qviewer); ui-&gt;frame-&gt;setLayout(layout); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;setCentralWidget(ui-&gt;frame);</code> </pre><br>  tempat kami membuat layer, buat widget kami, dengan dimensi yang sama dengan ukuran frame, tambahkan widget yang dibuat ke layer, dan lampirkan layer ke frame.  Dan, agar tidak repot dengan tata letak dalam contoh ini, kami meregangkan bingkai ke seluruh area klien dari jendela, menjadikannya widget pusat. <br><br>  Untuk merender, Anda harus mengatur pembaruan jendela secara periodik oleh penghitung waktu.  Untuk melakukan ini, buat timer dengan interval 40 milidetik (25 frame per detik) dan kaitkan sinyal timeout-nya dengan slot pembaruan jendela.  Saya melakukannya dengan cara ini menggunakan sintaks Qt5 <br><br><pre> <code class="cpp hljs">connect(&amp;timer, &amp;QTimer::timeout, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;MainWindow::update); timer.start(<span class="hljs-number"><span class="hljs-number">40</span></span>);</code> </pre><br>  setelah sebelumnya menetapkan slot pembaruan untuk kelas jendela dengan cara ini <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MainWindow::update() { QMainWindow::update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;geometry()); }</code> </pre><br>  Mengapa demikian, karena Anda dapat secara langsung mengaitkan sinyal timer dengan slot QMainWindow :: update dengan cara yang sama seperti yang ditunjukkan oleh sebagian besar contoh osgQt <br><br><pre> <code class="plaintext hljs">connect(&amp;timer, SIGNAL(timeout), this, SLOT(update));</code> </pre><br>  Faktanya adalah bahwa sintaks dengan makro SIGNAL () dan SLOT () sudah usang, dan untuk mengantisipasi transisi ke Qt6, itu harus ditinggalkan.  Pada saat yang sama, kelas QMainWindow tidak memiliki kelebihan pembaruan () slot tanpa parameter, yang akan menyebabkan kesalahan pada panggilan yang mengikat selama kompilasi.  Untuk melakukan ini, saya harus mendefinisikan slot update () saya tanpa parameter, memanggil basis QMainWindow :: update () di dalamnya, melewati area klien dari jendela di sana. <br><br>  Menambahkan ke tempat ini dan menjalankan program, kami akan mendapatkan hasil tertentu <br><br><img src="https://habrastorage.org/webt/s4/hb/h7/s4hbh78isikshkekfsbefaht8wg.png"><br><br>  Dengan menekan "S" kita dapat mengaktifkan monitor statistik OSG dan memastikan bahwa widget kita berfungsi sebagaimana mestinya, menggambar adegan kosong. <br><br><div class="spoiler">  <b class="spoiler_title">Statistik apa yang dipantau?</b> <div class="spoiler_text">  Agar tidak membebani artikel saya akan menulis di sini.  OSG memiliki monitor internal yang menampilkan statistik mesin secara real time.  Untuk menambahkannya ke penampil, kami menyertakan file header <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgViewer/ViewerEventHandlers&gt;</span></span></span></span></code> </pre><br>  dan menambahkan penangan ke penampil <br><br><pre> <code class="cpp hljs">viewer.addEventHandler(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgViewer::StatsHandler);</code> </pre><br>  lalu kapan saja dengan menekan "S" untuk menampilkan banyak informasi berguna. <br></div></div><br><h1>  4. Selesai pemirsa kami: tambahkan menu </h1><br>  Di perancang formulir, kami mengubahsuaikan menu menggunakan pemrograman "berorientasi mouse" (yang saya acuhkan, tapi ya, terkadang itu nyaman).  Pada akhirnya kita akan mendapatkan sesuatu seperti ini <br><br> <a href=""><img src="https://habrastorage.org/webt/5h/lg/4y/5hlg4ynz134k85tyg9gko_mzjlm.png"></a> <br><br>  Sekarang kita akan memulai slot prosesor yang sesuai, memungkinkan Anda untuk memuat model di sepanjang jalur yang dipilih dari kotak dialog, menghapus adegan dan keluar dari aplikasi <br><br><div class="spoiler">  <b class="spoiler_title">Kode Menu Handler</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void MainWindow::open() { osg::Group *scene = qviewer-&gt;getScene(); if (scene == nullptr) return; QString path = QFileDialog::getOpenFileName(Q_NULLPTR, tr("Open model file"), "./", tr("OpenSceneGraph (*.osg *.osgt *.osgb *.ivi)")); if (path.isEmpty()) return; scene-&gt;removeChildren(0, scene-&gt;getNumChildren()); osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(path.toStdString()); scene-&gt;addChild(model.get()); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void MainWindow::clean() { osg::Group *scene = qviewer-&gt;getScene(); if (scene == nullptr) return; scene-&gt;removeChildren(0, scene-&gt;getNumChildren()); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void MainWindow::quit() { QApplication::quit(); }</span></span></code> </pre><br></div></div><br>  Setelah itu, kita akan mendapatkan viewer model format * .osg yang sangat nyaman. <br><br><img src="https://habrastorage.org/webt/vj/ub/ml/vjubmllisl3w25nyca0dn90udv0.png"><br><br>  Peragaan karyanya ditampilkan dalam video di awal artikel.  Kode sumber lengkap untuk contoh ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tersedia di sini.</a> <br><br><h1>  Kesimpulan </h1><br>  Seperti yang telah kita lihat, integrasi OSG dan Qt tidak terlalu sulit baik dalam pemahaman maupun implementasi.  Ini sangat membantu untuk membuat aplikasi lintas platform untuk visualisasi teknis, dan mungkin game. <br><br>  Artikel ini membuka kelanjutan dari seri OSG, yang akan menguraikan teknik pengembangan yang kompleks.  Saya pikir dia berhasil keluar.  Terima kasih dan sampai jumpa lagi! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438654/">https://habr.com/ru/post/id438654/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438644/index.html">Keamanan algoritma pembelajaran mesin. Melindungi dan Menguji Model Menggunakan Python</a></li>
<li><a href="../id438646/index.html">Tentang membuat gambar stereo anggaran dengan jari (stereogram, anaglyph, stereoscope)</a></li>
<li><a href="../id438648/index.html">Perbandingan sistem BI (Tableau, Power BI, Oracle, Qlik)</a></li>
<li><a href="../id438650/index.html">Roket 9M729. Beberapa kata tentang "pelanggar" Perjanjian INF</a></li>
<li><a href="../id438652/index.html">Portabelisasi IDA</a></li>
<li><a href="../id438658/index.html">Cara belajar belajar</a></li>
<li><a href="../id438662/index.html">Hari dimana aku jatuh cinta pada bulu mata</a></li>
<li><a href="../id438664/index.html">Perangkat kompiler Swift. Bagian 2</a></li>
<li><a href="../id438666/index.html">Manajer vs Programmer</a></li>
<li><a href="../id438668/index.html">"Cari cerita yang mendorong": podcast tentang podcast, pekerjaan editorial, dan karier media</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>