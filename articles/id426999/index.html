<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéá üìò üëèüèø Mengikuti tren, atau bergerak menuju RxJava dan LiveData üé¢ ü§öüèª üßú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di halaman 2018 tahun. Semakin banyak kata-kata RxJava dan LiveData ditemukan. Tetapi jika itu terjadi bahwa aplikasi Anda masih dikuasai oleh solusi ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengikuti tren, atau bergerak menuju RxJava dan LiveData</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/426999/"><img src="https://habrastorage.org/webt/lj/pj/f1/ljpjf1hot4fwrgj1ww2z5-7qt7o.jpeg"><br><br>  Di halaman 2018 tahun.  Semakin banyak kata-kata RxJava dan LiveData ditemukan.  Tetapi jika itu terjadi bahwa aplikasi Anda masih dikuasai oleh solusi kuno seperti perpustakaan android-priority-jobqueue atau AsyncTask (ya, itu terjadi), maka artikel ini khusus untuk Anda.  Saya berbagi pendekatan ini berdasarkan filosofi mereka.  Yang pertama melibatkan ketergantungan tertentu dari pekerjaan pada tampilan, yang kedua - pelaksanaan tugas di mana View mendengarkannya dan itu tidak mengganggu tergantung pada peristiwa dalam siklus hidup (misalnya, ketika layar diputar).  Di bawah potongan, saya sarankan mempertimbangkan migrasi ke sekelompok RxJava dan LiveData untuk kedua pendekatan. <br><a name="habracut"></a><br>  Sebagai ilustrasi, saya akan menggunakan kelas Work kecil, yang merupakan beberapa operasi panjang yang perlu dipindahkan ke utas latar belakang.  Dalam aplikasi pengujian, saya meletakkan ProgressBar yang berputar di layar untuk melihat kapan pekerjaan akan dilakukan di utas utama. <br><br><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Work</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> until <span class="hljs-number"><span class="hljs-number">10</span></span>) { Thread.sleep(<span class="hljs-number"><span class="hljs-number">500</span></span>) } <span class="hljs-string"><span class="hljs-string">"work is done"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: InterruptedException) { <span class="hljs-string"><span class="hljs-string">"work is cancelled"</span></span> } }</code> </pre> <br><h1>  AsyncTask </h1><br>  Dengan pendekatan ini, setiap AsyncTask dibuat untuk setiap tugas, yang dibatalkan di onPause () atau onStop ().  Ini dilakukan agar konteks aktivitas tidak bocor.  Untuk menunjukkan apa yang dimaksud dengan ini, saya membuat sketsa contoh kecil. <br><br>  Pertama, kami memodifikasi AsyncTask standar sedikit sehingga dapat dibatalkan dan mengembalikan kesalahan dari itu: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncTaskCancellable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Params, Result</span></span></span><span class="hljs-class">&gt;</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job: Job&lt;Params, Result&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callback: AsyncTaskCallback&lt;Result&gt;?) : AsyncTask&lt;Params, <span class="hljs-built_in"><span class="hljs-built_in">Void</span></span>, AsyncTaskCancellable.ResultContainer&lt;Result&gt;&gt;(), WorkManager.Cancellable { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Params, Result</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(params: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Params</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: Result } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doInBackground</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vararg</span></span></span></span><span class="hljs-function"><span class="hljs-params"> params: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Params</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: AsyncTaskCancellable.ResultContainer&lt;Result&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ResultContainer(job.execute(params)) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (throwable: Throwable) { ResultContainer(throwable) } } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onPostExecute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(result: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AsyncTaskCancellable</span></span></span></span><span class="hljs-function"><span class="hljs-params">.</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ResultContainer</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Result</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onPostExecute(result) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.error != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { callback?.onError(result.error!!) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { callback?.onDone(result.result!!) } } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { cancel(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) callback = <span class="hljs-literal"><span class="hljs-literal">null</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResultContainer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> error: Throwable? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result: T? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(result: T) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.result = result } <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(error: Throwable) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.error = error } } }</code> </pre><br>  Tambahkan peluncuran pekerjaan ke manajer: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkManager</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doWorkInAsyncTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(asyncTaskCallback: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AsyncTaskCallback</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: Cancellable { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AsyncTaskCancellable(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : AsyncTaskCancellable.Job&lt;<span class="hljs-built_in"><span class="hljs-built_in">Void</span></span>, String&gt; { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(params: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Void</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> = Work().doWork() }, asyncTaskCallback).apply { execute() } } }</code> </pre><br>  Kami memulai tugas, sebelumnya membatalkan yang sekarang, jika ada: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span></span>() { ... loadWithAsyncTask.setOnClickListener { asyncTaskCancellable?.cancel() asyncTaskCancellable = workManager.doWorkInAsyncTask(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : AsyncTaskCallback&lt;String&gt; { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(result: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { onSuccess(result) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(throwable: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-symbol"><span class="hljs-symbol">@MainActivity</span></span>.onError(throwable) } }) } ... }</code> </pre><br>  Jangan lupa untuk membatalkannya di onPause (): <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onPause</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { asyncTaskCancellable?.cancel() <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onPause() }</code> </pre><br>  Di sini AsyncTask berhenti dan panggilan balik diatur ulang untuk menghapus tautan ke MainActivity.  Pendekatan ini berlaku ketika Anda perlu melakukan tugas yang cepat dan tidak signifikan, yang hasilnya tidak menakutkan untuk hilang (misalnya, ketika Anda membalik layar saat aktivitas akan diciptakan kembali). <br><br>  Pada RxJava, implementasi serupa tidak akan jauh berbeda. <br><br>  Kami juga membuat Observable, yang akan dieksekusi di <i>Schedulers.computation ()</i> , dan mengembalikannya untuk berlangganan lebih lanjut. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkManager</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doWorkInRxJava</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Observable&lt;String&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.fromCallable { Work().doWork() }.subscribeOn(Schedulers.computation()) } ... }</code> </pre><br>  Kami mengirim panggilan balik ke aliran utama dan berlangganan untuk bekerja: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MainActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span><span class="hljs-class">() { ... loadWithRx.setOnClickListener { _ -&gt; rxJavaSubscription?.dispose() rxJavaSubscription = workManager.doWorkInRxJava() .observeOn(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AndroidSchedulers</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mainThread</span></span></span><span class="hljs-class">()) .subscribe({ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">onSuccess</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">it</span></span></span><span class="hljs-class">) }, { onError(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">it</span></span></span><span class="hljs-class">) }) } ... }</span></span></code> </pre><br>  Jangan lupa untuk membersihkan sendiri di onPause (): <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onPause</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { rxJavaSubscription?.dispose() <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onPause() }</code> </pre><br>  Secara umum, implementasi dengan RxJava dapat sedikit ditambah menggunakan perpustakaan RxBinding.  Ini memberikan binding reaktif untuk komponen Android.  Secara khusus, dalam hal ini, Anda dapat menggunakan <i>RxView.clicks ()</i> untuk mendapatkan Observable yang memungkinkan Anda mendengarkan klik tombol: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MainActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span><span class="hljs-class">() { ... rxJavaSubscription = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RxView</span></span></span><span class="hljs-class">.clicks(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">loadWithRx</span></span></span><span class="hljs-class">) .concatMap { workManager.doWorkInRxJava() .observeOn(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AndroidSchedulers</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mainThread</span></span></span><span class="hljs-class">()) .doOnNext { result -&gt; onSuccess(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">result</span></span></span><span class="hljs-class">) } .onErrorReturn { error -&gt; onError(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error</span></span></span><span class="hljs-class">) "" } } .subscribe() ... }</span></span></code> </pre><br>  Penanganan kesalahan terjadi dalam pernyataan onErrorReturn agar tidak menghentikan aliran acara klik pada tombol.  Jadi, jika kesalahan terjadi selama pelaksanaan pekerjaan, maka itu tidak akan mencapai berlangganan akhir, dan klik akan terus diproses. <br>  Ketika menerapkan pendekatan ini, harus diingat bahwa penyimpanan Disposable, yang mengembalikan subscribe (), secara statis harus didekati dengan hati-hati.  Sampai metode dispose () dipanggil, ia dapat menyimpan tautan implisit ke pelanggan Anda, yang dapat menyebabkan kebocoran memori. <br>  Anda juga harus berhati-hati dengan penanganan kesalahan agar tidak secara tidak sengaja menyelesaikan aliran asli. <br><br><h1>  android-priority-jobqueue </h1><br>  Di sini kami memiliki manajer tertentu yang mengelola operasi, dan tampilan berlangganan statusnya saat ini.  LiveData, yang terkait dengan siklus hidup, sangat baik untuk peran lapisan antara manajer dan UI tersebut.  Untuk melakukan pekerjaan secara langsung dalam contoh ini, saya sarankan menggunakan RxJava, yang membuatnya mudah untuk mentransfer eksekusi kode ke utas latar belakang. <br><br>  Kita juga akan memerlukan kelas wrapper Resource tambahan, yang akan berisi informasi tentang status operasi, kesalahan, dan hasil. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Resource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">private</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> status: Status, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: T?, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> error: Throwable?) { <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: T) : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(Status.SUCCESS, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(error: Throwable) : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(Status.ERROR, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, error) <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(Status.LOADING, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Status</span></span></span><span class="hljs-class"> </span></span>{ SUCCESS, ERROR, LOADING } }</code> </pre><br>  Sekarang kita siap untuk menulis kelas WorkViewModel yang akan berisi instance LiveData dan memberitahukannya tentang perubahan status pekerjaan menggunakan Resource.  Dalam contoh, saya sedikit curang dan baru saja membuat WorkViewModel sebuah singleton.  Saya menggunakan RxJava dalam statika, tapi saya akan berlangganan melalui LiveData, jadi tidak akan ada kebocoran. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkViewModel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">private</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> instance = WorkViewModel() } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> liveData: MutableLiveData&lt;Resource&lt;String&gt;&gt; = MutableLiveData() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> workSubscription: Disposable? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(work: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Work</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { liveData.value = Resource() workSubscription?.dispose() workSubscription = Observable.fromCallable { work.doWork() } .subscribeOn(Schedulers.computation()) .observeOn(AndroidSchedulers.mainThread()) .subscribe({ liveData.value = Resource(it) }, { liveData.value = Resource(it) }) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: LiveData&lt;Resource&lt;String&gt;&gt; = liveData }</code> </pre><br>  Kami melengkapi WorkManager dengan meluncurkan pekerjaan untuk menjaga keseragaman, mis.  sehingga pekerjaan selalu dimulai melalui manajer ini: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkManager</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doOnLiveData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { WorkViewModel.instance.startWork(Work()) } ... }</code> </pre><br>  Dan kami menambahkan interaksi dengan semua ini di MainActivity.  Dari WorkViewModel, kami mendapatkan status pekerjaan saat ini, sementara tampilan hidup, dan kami memulai pekerjaan baru dengan menekan tombol: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MainActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span><span class="hljs-class">() { ... </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WorkViewModel</span></span></span><span class="hljs-class">.</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class">.getWork().observe(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Observer</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">when</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">it</span></span></span><span class="hljs-class">?.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">status</span></span></span><span class="hljs-class"> == </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Resource</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Status</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SUCCESS</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">onSuccess</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">it</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">!!) it?.status == </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Resource</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Status</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ERROR</span></span></span><span class="hljs-class"> -&gt; onError(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">it</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error</span></span></span><span class="hljs-class">!!) it?.status == </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Resource</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Status</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LOADING</span></span></span><span class="hljs-class"> -&gt; loadWithLiveData.isEnabled = false } }) loadWithLiveData.setOnClickListener { workManager.doOnLiveData() } ... }</span></span></code> </pre><br>  Dengan cara yang kira-kira sama, ini dapat diimplementasikan menggunakan Subjek dari RxJava.  Namun, menurut saya, LiveData menangani pemrosesan siklus hidup dengan lebih baik, karena ini awalnya disetel untuk ini, sementara dengan Subjek Anda dapat mengalami banyak masalah dengan menghentikan aliran dan penanganan kesalahan.  Saya berpikir bahwa simbiosis RxJava dan LiveData adalah yang paling layak: yang pertama menerima dan memproses aliran data dan memberi tahu tentang perubahan yang kedua, yang Anda sudah bisa berlangganan dengan memperhatikan siklus kehidupan. <br><br>  Dengan demikian, kami memeriksa transisi dari perpustakaan kuno ke lebih modern untuk dua metode paling umum melakukan pekerjaan di latar belakang.  Untuk operasi kecil satu kali, RxJava telanjang sempurna, karena memungkinkan Anda untuk bekerja dengan sangat fleksibel dengan data dan mengontrol aliran di mana ini harus terjadi.  Pada saat yang sama, jika interaksi yang lebih baik dengan siklus hidup diperlukan, lebih baik menggunakan LiveData, yang awalnya dirancang untuk menyelesaikan masalah seperti itu. <br><br>  Versi lengkap dari sumber dapat ditemukan di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> <br><br>  Saya akan dengan senang hati menjawab pertanyaan Anda di komentar! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426999/">https://habr.com/ru/post/id426999/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426987/index.html">Pelajari OpenGL. Pelajaran 6.3 - Pencahayaan Berbasis Gambar. Iradiasi difus</a></li>
<li><a href="../id426991/index.html">Startup Digest: 10 acara IT mendatang di Moskow</a></li>
<li><a href="../id426993/index.html">Apakah saya perlu belajar C untuk memahami cara kerja komputer?</a></li>
<li><a href="../id426995/index.html">Daur ulang membahayakan produk dan karyawan</a></li>
<li><a href="../id426997/index.html">Cara membuat bentuk khusus menggunakan MaterialShapeDrawable</a></li>
<li><a href="../id427003/index.html">Hexagon maps in Unity: kabut perang, riset peta, pembuatan prosedural</a></li>
<li><a href="../id427005/index.html">Pengembang AI - profesi jutawan?</a></li>
<li><a href="../id427009/index.html">"Berjalan" dari elektron: manipulasi dengan muatan di dalam struktur ikatan tak jenuh</a></li>
<li><a href="../id427011/index.html">"Hello World!" pada FPGA atau versi UART berikutnya</a></li>
<li><a href="../id427013/index.html">Tatap muka NeoQUEST-2018: ingat bagaimana itu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>