<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§µ üìó üëå Index dans PostgreSQL - 1 üëáüèΩ üëô üßïüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 
 Cette s√©rie d'articles concerne en grande partie les index de PostgreSQL. 

 Tout sujet peut √™tre consid√©r√© sous diff√©rents angles. Nou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Index dans PostgreSQL - 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/441962/"><h1>  Pr√©sentation </h1><br>  Cette s√©rie d'articles concerne en grande partie les index de PostgreSQL. <br><br>  Tout sujet peut √™tre consid√©r√© sous diff√©rents angles.  Nous discuterons des sujets qui devraient int√©resser un d√©veloppeur d'applications qui utilise un SGBD: quels index sont disponibles, pourquoi il y en a tellement diff√©rents et comment les utiliser pour acc√©l√©rer les requ√™tes.  Le sujet peut probablement √™tre couvert en moins de mots, mais en secret, nous esp√©rons un d√©veloppeur curieux, qui s'int√©resse √©galement aux d√©tails des √©l√©ments internes, d'autant plus que la compr√©hension de ces d√©tails vous permet non seulement de vous en remettre au jugement des autres, mais aussi de tirer des conclusions. de votre choix. <br><br>  Le d√©veloppement de nouveaux types d'index n'entre pas dans le champ d'application.  Cela n√©cessite une connaissance du langage de programmation C et rel√®ve de l'expertise d'un programmeur syst√®me plut√¥t que d'un d√©veloppeur d'applications.  Pour la m√™me raison, nous ne discuterons presque pas des interfaces de programmation, mais nous nous concentrerons uniquement sur ce qui compte pour travailler avec des index pr√™ts √† l'emploi. <br><br>  Dans cet article, nous discuterons de la r√©partition des responsabilit√©s entre le <strong>moteur d'indexation g√©n√©ral</strong> li√© au c≈ìur du SGBD et les m√©thodes d'acc√®s aux index individuels, que PostgreSQL nous permet d'ajouter en tant qu'extensions.  Dans le prochain article, nous discuterons de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">interface de la m√©thode d'acc√®s</a> et des concepts critiques tels que les classes et les familles d'op√©rateurs.  Apr√®s cette introduction longue mais n√©cessaire, nous examinerons les d√©tails de la structure et de l'application des diff√©rents types d'index: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hash</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">B-tree</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SP-GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GIN</a> and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RUM</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BRIN</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bloom</a> . <br><br><blockquote>  Avant de commencer, je voudrais remercier Elena Indrupskaya d'avoir traduit les articles en anglais. <br>  Les choses ont un peu chang√© depuis la publication originale.  Mes commentaires sur l'√©tat actuel des choses sont indiqu√©s comme ceci. </blockquote><a name="habracut"></a><br><h2>  Index </h2><br>  Dans PostgreSQL, les index sont des objets de base de donn√©es sp√©ciaux principalement con√ßus pour acc√©l√©rer l'acc√®s aux donn√©es.  Ce sont des structures auxiliaires: chaque index peut √™tre supprim√© et recr√©√© √† partir des informations du tableau.  Vous pouvez parfois entendre qu'un SGBD peut fonctionner sans index bien que lentement.  Cependant, ce n'est pas le cas, car les index servent √©galement √† appliquer certaines contraintes d'int√©grit√©. <br><br>  √Ä l'heure actuelle, six types d'index diff√©rents sont int√©gr√©s √† PostgreSQL 9.6, et un index suppl√©mentaire est disponible en tant qu'extension - gr√¢ce √† d'importants changements dans la version 9.6.  Attendez-vous donc √† de nouveaux types d'index dans un avenir proche. <br><br>  Malgr√© toutes les diff√©rences entre les types d'index (√©galement appel√©s m√©thodes d'acc√®s), chacun d'eux finit par associer une cl√© (par exemple, la valeur de la colonne index√©e) aux lignes de table qui contiennent cette cl√©.  Chaque ligne est identifi√©e par TID (tuple id), qui se compose du nombre de blocs dans le fichier et de la position de la ligne √† l'int√©rieur du bloc.  Cela dit, avec la cl√© connue ou certaines informations √† ce sujet, nous pouvons lire rapidement les lignes qui peuvent contenir les informations qui nous int√©ressent sans parcourir la table enti√®re. <br><br>  Il est important de comprendre qu'un index acc√©l√®re l'acc√®s aux donn√©es √† un certain co√ªt de maintenance.  Pour chaque op√©ration sur les donn√©es index√©es, que ce soit l'insertion, la suppression ou la mise √† jour des lignes de table, les index de cette table doivent √©galement √™tre mis √† jour et dans la m√™me transaction.  Notez que la mise √† jour des champs de table pour lesquels les index n'ont pas √©t√© cr√©√©s n'entra√Æne pas de mise √† jour d'index;  cette technique est appel√©e HOT (Heap-Only Tuples). <br><br>  L'extensibilit√© comporte certaines implications.  Pour permettre l'ajout facile d'une nouvelle m√©thode d'acc√®s au syst√®me, une interface du moteur d'indexation g√©n√©ral a √©t√© impl√©ment√©e.  Sa t√¢che principale est d'obtenir les TID de la m√©thode d'acc√®s et de travailler avec eux: <br><br><ul><li>  Lisez les donn√©es des versions correspondantes des lignes du tableau. </li><li>  R√©cup√©rez les versions de ligne TID par TID ou dans un lot √† l'aide d'un bitmap pr√©d√©fini. </li><li>  V√©rifiez la visibilit√© des versions de ligne pour la transaction en cours en tenant compte de son niveau d'isolement. </li></ul><br>  Le moteur d'indexation est impliqu√© dans l'ex√©cution des requ√™tes.  Il est appel√© selon un plan cr√©√© au stade de l'optimisation.  L'optimiseur, triant et √©valuant les diff√©rentes mani√®res d'ex√©cuter la requ√™te, doit comprendre les capacit√©s de toutes les m√©thodes d'acc√®s potentiellement applicables.  La m√©thode pourra-t-elle renvoyer les donn√©es dans l'ordre requis ou devrions-nous anticiper le tri?  Pouvons-nous utiliser cette m√©thode pour rechercher NULL?  Ce sont des probl√®mes que l'optimiseur r√©sout r√©guli√®rement. <br><br>  Non seulement l'optimiseur a besoin d'informations sur la m√©thode d'acc√®s.  Lors de la construction d'un index, le syst√®me doit d√©cider si l'index peut √™tre construit sur plusieurs colonnes et si cet index garantit l'unicit√©. <br><br>  Ainsi, chaque m√©thode d'acc√®s doit fournir toutes les informations n√©cessaires sur elle-m√™me.  Les versions inf√©rieures √† 9.6 utilisaient pour cela la table "pg_am", tandis qu'√† partir de la version 9.6 les donn√©es √©taient d√©plac√©es √† des niveaux plus profonds, √† l'int√©rieur de fonctions sp√©ciales.  Nous nous familiariserons un peu plus avec cette interface. <br><br>  Tout le reste est la t√¢che de la m√©thode d'acc√®s: <br><br><ul><li>  Impl√©mentez un algorithme pour construire l'index et mapper les donn√©es en pages (pour que le gestionnaire de cache de tampon traite uniform√©ment chaque index). </li><li>  Rechercher des informations dans l'index par un pr√©dicat sous la forme " <em>expression d'op√©rateur de champ index√©</em> ". </li><li>  √âvaluez le co√ªt d'utilisation de l'index. </li><li>  Manipulez les verrous requis pour un traitement parall√®le correct. </li><li> G√©n√©rez des enregistrements de journal d'√©criture anticip√©e (WAL). </li></ul><br>  Nous examinerons d'abord les capacit√©s du moteur d'indexation g√©n√©ral, puis nous examinerons diff√©rentes m√©thodes d'acc√®s. <br><br><h2>  Moteur d'indexation </h2><br>  Le moteur d'indexation permet √† PostgreSQL de travailler de mani√®re uniforme avec diverses m√©thodes d'acc√®s, mais en tenant compte de leurs fonctionnalit√©s. <br><br><h3>  Principales techniques de num√©risation </h3><br><h4>  Balayage d'index </h4><br>  Nous pouvons travailler diff√©remment avec les TID fournis par un index.  Prenons un exemple: <br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t(a <span class="hljs-type"><span class="hljs-type">integer</span></span>, b <span class="hljs-type"><span class="hljs-type">text</span></span>, c <span class="hljs-type"><span class="hljs-type">boolean</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t(a,b,c) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> s.id, chr((<span class="hljs-number"><span class="hljs-number">32</span></span>+random()*<span class="hljs-number"><span class="hljs-number">94</span></span>)::<span class="hljs-type"><span class="hljs-type">integer</span></span>), random() &lt; <span class="hljs-number"><span class="hljs-number">0.01</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">100000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> s(id) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> random(); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(a); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t;</code> </pre> <br>  Nous avons cr√©√© une table √† trois champs.  Le premier champ contient des nombres de 1 √† 100 000 et un index (quel que soit le type) est cr√©√© sur ce champ.  Le deuxi√®me champ contient divers caract√®res ASCII √† l'exception de ceux non imprimables.  Enfin, le troisi√®me champ contient une valeur logique qui est vraie pour environ 1% des lignes et fausse pour le reste.  Les lignes sont ins√©r√©es dans le tableau dans un ordre al√©atoire. <br><br>  Essayons de s√©lectionner une valeur par la condition "a = 1".  Notez que la condition ressemble √† " <em>expression d'op√©rateur de champ index√©</em> ", o√π l' <em>op√©rateur</em> est "√©gal" et l' <em>expression</em> (cl√© de recherche) est "1".  Dans la plupart des cas, la condition doit ressembler √† ceci pour que l'index soit utilis√©. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------- Index Scan using t_a_idx on t Index Cond: (a = 1) (2 rows)</code> </pre><br>  Dans ce cas, l'optimiseur a d√©cid√© d'utiliser le <em>scan d'index</em> .  Avec l'analyse d'index, la m√©thode d'acc√®s renvoie les valeurs TID une par une jusqu'√† ce que la derni√®re ligne correspondante soit atteinte.  Le moteur d'indexation acc√®de √† tour de r√¥le aux lignes de table indiqu√©es par les TID, obtient la version de ligne, v√©rifie sa visibilit√© par rapport aux r√®gles de concurrence multiversionnelles et renvoie les donn√©es obtenues. <br><br><h4>  Num√©risation bitmap </h4><br>  L'analyse d'index fonctionne correctement lorsque nous ne traitons que de quelques valeurs.  Cependant, √† mesure que le nombre de lignes r√©cup√©r√©es augmente, il est plus probable qu'il revienne plusieurs fois sur la m√™me page de table.  Par cons√©quent, l'optimiseur passe √† l' <em>analyse bitmap</em> . <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------ Bitmap Heap Scan on t Recheck Cond: (a &lt;= 100) -&gt; Bitmap Index Scan on t_a_idx Index Cond: (a &lt;= 100) (4 rows)</code> </pre><br>  La m√©thode d'acc√®s renvoie d'abord tous les TID qui correspondent √† la condition (n≈ìud Bitmap Index Scan), et le bitmap des versions de ligne est construit √† partir de ces TID.  Les versions des lignes sont ensuite lues √† partir du tableau (Bitmap Heap Scan), chaque page √©tant lue une seule fois. <br><br>  Notez que dans la deuxi√®me √©tape, la condition peut √™tre rev√©rifi√©e (Recheck Cond).  Le nombre de lignes r√©cup√©r√©es peut √™tre trop grand pour que le bitmap des versions de lignes s'adapte parfaitement √† la RAM (limit√© par le param√®tre "work_mem").  Dans ce cas, le bitmap est uniquement cr√©√© pour les pages qui contiennent au moins une version de ligne correspondante.  Ce bitmap "avec perte" n√©cessite moins d'espace, mais lors de la lecture d'une page, nous devons rev√©rifier les conditions pour chaque ligne qu'il contient.  Notez que m√™me pour un petit nombre de lignes r√©cup√©r√©es et donc le bitmap "exact" (comme dans notre exemple), l'√©tape "Recheck Cond" est de toute fa√ßon repr√©sent√©e dans le plan, bien qu'elle ne soit pas r√©ellement effectu√©e. <br><br>  Si des conditions sont impos√©es sur plusieurs champs de table et que ces champs sont index√©s, le scan bitmap permet d'utiliser plusieurs index simultan√©ment (si l'optimiseur le juge efficace).  Pour chaque index, des bitmaps de versions de lignes sont cr√©√©s, pour lesquels une multiplication bool√©enne au niveau du bit (si les expressions sont jointes par AND) ou une addition bool√©enne (si les expressions sont jointes par OR) est ensuite effectu√©e.  Par exemple: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(b); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> b = <span class="hljs-string"><span class="hljs-string">'a'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------- Bitmap Heap Scan on t Recheck Cond: ((a &lt;= 100) AND (b = 'a'::text)) -&gt; BitmapAnd -&gt; Bitmap Index Scan on t_a_idx Index Cond: (a &lt;= 100) -&gt; Bitmap Index Scan on t_b_idx Index Cond: (b = 'a'::text) (7 rows)</code> </pre><br>  Ici, le n≈ìud BitmapAnd joint deux bitmaps par l'op√©ration "et" au niveau du bit. <br><br>  Le scan bitmap nous permet d'√©viter les acc√®s r√©p√©t√©s √† la m√™me page de donn√©es.  Mais que se passe-t-il si les donn√©es des pages de table sont ordonn√©es physiquement exactement de la m√™me mani√®re que les enregistrements d'index?  Il ne fait aucun doute que nous ne pouvons pas enti√®rement nous fier √† l'ordre physique des donn√©es dans les pages.  Si des donn√©es tri√©es sont n√©cessaires, nous devons explicitement sp√©cifier la clause ORDER BY dans la requ√™te.  Mais des situations sont susceptibles o√π en fait "presque toutes" les donn√©es sont ordonn√©es: par exemple, si des lignes sont ajout√©es dans l'ordre n√©cessaire et ne changent pas apr√®s cela ou apr√®s avoir ex√©cut√© la commande CLUSTER.  Dans des cas comme celui-ci, la construction d'un bitmap est une √©tape excessive, et un scan d'index r√©gulier sera tout aussi bon (sauf si nous prenons en compte la possibilit√© de joindre plusieurs index).  Par cons√©quent, lors du choix d'une m√©thode d'acc√®s, le planificateur examine une statistique sp√©ciale qui montre la corr√©lation entre l'ordre des lignes physiques et l'ordre logique des valeurs des colonnes: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> attname, correlation <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_stats <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'t'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> attname | correlation ---------+------------- b | 0.533512 c | 0.942365 a | -0.00768816 (3 rows)</code> </pre><br>  Des valeurs absolues proches de un indiquent une corr√©lation √©lev√©e (comme pour la colonne "c"), tandis que des valeurs proches de z√©ro, au contraire, indiquent une distribution chaotique (colonne "a"). <br><br><h4>  Balayage s√©quentiel </h4><br>  Pour compl√©ter l'image, il faut noter qu'avec une condition non s√©lective, l'optimiseur aura raison de pr√©f√©rer le scan s√©quentiel de la table enti√®re √† l'utilisation de l'index: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt;= <span class="hljs-number"><span class="hljs-number">40000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------ Seq Scan on t Filter: (a &lt;= 40000) (2 rows)</code> </pre><br>  Le fait est que les index fonctionnent mieux, plus la s√©lectivit√© de la condition est √©lev√©e, c'est-√†-dire que moins de lignes y correspondent.  La croissance du nombre de lignes r√©cup√©r√©es augmente les frais g√©n√©raux de lecture des pages d'index. <br><br>  Les analyses s√©quentielles √©tant plus rapides que les analyses al√©atoires aggravent la situation.  Cela vaut particuli√®rement pour les disques durs, o√π l'op√©ration m√©canique consistant √† amener une t√™te magn√©tique sur une piste prend beaucoup plus de temps que la lecture des donn√©es elle-m√™me.  Cet effet est moins visible pour les SSD.  Deux param√®tres sont disponibles pour prendre en compte les diff√©rences de co√ªts d'acc√®s, "seq_page_cost" et "random_page_cost", que nous pouvons d√©finir non seulement globalement, mais au niveau des tablespaces, de cette mani√®re en ajustant les caract√©ristiques des diff√©rents sous-syst√®mes de disques. <br><br><h3>  Index de couverture </h3><br>  En r√®gle g√©n√©rale, la t√¢che principale d'une m√©thode d'acc√®s consiste √† renvoyer les identificateurs des lignes de table correspondantes pour que le moteur d'indexation puisse lire les donn√©es n√©cessaires √† partir de ces lignes.  Mais que faire si l'index contient d√©j√† toutes les donn√©es n√©cessaires √† la requ√™te?  Un tel index est appel√© <em>couverture</em> , et dans ce cas, l'optimiseur peut appliquer l' <em>analyse d'index uniquement</em> : <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">vacuum</span></span> t; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------ Index Only Scan using t_a_idx on t Index Cond: (a &lt; 100) (2 rows)</code> </pre><br>  Ce nom peut donner une id√©e que le moteur d'indexation n'acc√®de pas du tout √† la table et obtient toutes les informations n√©cessaires uniquement √† partir de la m√©thode d'acc√®s.  Mais ce n'est pas exactement le cas puisque les index dans PostgreSQL ne stockent pas d'informations qui nous permettent de juger de la visibilit√© des lignes.  Par cons√©quent, une m√©thode d'acc√®s renvoie des versions de lignes qui correspondent √† la condition de recherche quelle que soit leur visibilit√© dans la transaction en cours. <br><br>  Cependant, si le moteur d'indexation devait examiner la table √† des fins de visibilit√© √† chaque fois, cette m√©thode d'analyse n'aurait pas √©t√© diff√©rente d'une analyse d'index standard. <br><br>  Pour r√©soudre le probl√®me, pour les tables, PostgreSQL maintient une soi-disant <em>carte de visibilit√©</em> dans laquelle la mise √† vide marque les pages o√π les donn√©es n'ont pas √©t√© modifi√©es suffisamment longtemps pour que ces donn√©es soient visibles par toutes les transactions ind√©pendamment de l'heure de d√©but et du niveau d'isolement.  Si l'identifiant d'une ligne retourn√©e par l'index se rapporte √† une telle page, le contr√¥le de visibilit√© peut √™tre √©vit√©. <br><br>  Par cons√©quent, une aspiration r√©guli√®re augmente l'efficacit√© des indices de couverture.  De plus, l'optimiseur prend en compte le nombre de tuples morts et peut d√©cider de ne pas utiliser l'analyse d'index uniquement s'il pr√©voit des frais g√©n√©raux √©lev√©s pour le contr√¥le de visibilit√©. <br><br>  Nous pouvons conna√Ætre le nombre d'acc√®s forc√©s √† une table √† l'aide de la commande EXPLAIN ANALYZE: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------- Index Only Scan using t_a_idx on t (actual time=0.025..0.036 rows=99 loops=1) Index Cond: (a &lt; 100) Heap Fetches: 0 Planning time: 0.092 ms Execution time: 0.059 ms (5 rows)</code> </pre><br>  Dans ce cas, il n'√©tait pas n√©cessaire d'acc√©der √† la table (Heap Fetches: 0), car l'aspiration vient d'√™tre effectu√©e.  En g√©n√©ral, plus ce nombre est proche de z√©ro, mieux c'est. <br><br>  Tous les index ne stockent pas les valeurs index√©es avec les identificateurs de ligne.  Si la m√©thode d'acc√®s ne peut pas renvoyer les donn√©es, elle ne peut pas √™tre utilis√©e pour les analyses d'index uniquement. <br><br><blockquote>  PostgreSQL 11 a introduit une nouvelle fonctionnalit√©: INCLUDE-indexes.  Que se passe-t-il s'il existe un index unique qui manque de colonnes pour √™tre utilis√© comme index de couverture pour une requ√™te?  Vous ne pouvez pas simplement ajouter les colonnes √† l'index car cela romprait son caract√®re unique.  La fonctionnalit√© permet d'inclure <em>des</em> colonnes <em>non cl√©s</em> qui n'affectent pas l'unicit√© et ne peuvent pas √™tre utilis√©es dans les pr√©dicats de recherche, mais peuvent toujours servir aux analyses d'index uniquement.  Le patch a √©t√© d√©velopp√© par ma coll√®gue Anastasia Lubennikova. <br></blockquote><br><h3>  Null </h3><br>  Les valeurs NULL jouent un r√¥le important dans les bases de donn√©es relationnelles en tant que moyen pratique de repr√©senter une valeur inexistante ou inconnue. <br><br>  Mais une valeur sp√©ciale est sp√©ciale √† g√©rer.  Une alg√®bre bool√©enne r√©guli√®re devient ternaire;  il n'est pas clair si NULL doit √™tre plus petit ou plus grand que les valeurs normales (cela n√©cessite des constructions sp√©ciales pour le tri, NULLS FIRST et NULLS LAST);  il n'est pas √©vident si les fonctions d'agr√©gation doivent consid√©rer les valeurs NULL ou non;  une statistique sp√©ciale est n√©cessaire pour le planificateur ... <br><br>  Du point de vue de la prise en charge de l'index, il est √©galement difficile de savoir si nous devons indexer ces valeurs ou non.  Si les valeurs NULL ne sont pas index√©es, l'index peut √™tre plus compact.  Mais si les valeurs NULL sont index√©es, nous serons en mesure d'utiliser l'index pour des conditions telles que " <em>champ index√©</em> IS [NOT] NULL" et √©galement comme index de couverture lorsqu'aucune condition n'est sp√©cifi√©e pour la table (car dans ce cas, le param√®tre index doit renvoyer les donn√©es de toutes les lignes de table, y compris celles avec des valeurs NULL). <br><br>  Pour chaque m√©thode d'acc√®s, les d√©veloppeurs d√©cident individuellement d'indexer les NULL ou non.  Mais en r√®gle g√©n√©rale, ils sont index√©s. <br><br><h3>  Index sur plusieurs domaines </h3><br>  Pour prendre en charge les conditions de plusieurs champs, <em>des index multicolonnes</em> peuvent √™tre utilis√©s.  Par exemple, nous pouvons cr√©er un index sur deux champs de notre table: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(a,b); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t;</code> </pre><br>  L'optimiseur pr√©f√©rera tr√®s probablement cet index √† la jonction de bitmaps car ici nous obtenons facilement les TID n√©cessaires sans aucune op√©ration auxiliaire: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> b = <span class="hljs-string"><span class="hljs-string">'a'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------ Index Scan using t_a_b_idx on t Index Cond: ((a &lt;= 100) AND (b = 'a'::text)) (2 rows)</code> </pre><br>  Un index multicolonne peut √©galement √™tre utilis√© pour acc√©l√©rer la r√©cup√©ration des donn√©es par une condition pour certains des champs, en commen√ßant par le premier: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------- Bitmap Heap Scan on t Recheck Cond: (a &lt;= 100) -&gt; Bitmap Index Scan on t_a_b_idx Index Cond: (a &lt;= 100) (4 rows)</code> </pre><br>  En g√©n√©ral, si la condition n'est pas impos√©e au premier champ, l'index ne sera pas utilis√©.  Mais parfois, l'optimiseur peut consid√©rer l'utilisation de l'index comme plus efficace que l'analyse s√©quentielle.  Nous d√©velopperons ce sujet lors de l'examen des index "btree". <br><br>  Toutes les m√©thodes d'acc√®s ne prennent pas en charge la cr√©ation d'index sur plusieurs colonnes. <br><br><h3>  Index sur les expressions </h3><br>  Nous avons d√©j√† mentionn√© que la condition de recherche doit ressembler √† une " <em>expression d'op√©rateur de champ index√©</em> ".  Dans l'exemple ci-dessous, l'index ne sera pas utilis√© car une expression contenant le nom de champ est utilis√©e √† la place du nom de champ lui-m√™me: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> lower(b) = <span class="hljs-string"><span class="hljs-string">'a'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------ Seq Scan on t Filter: (lower((b)::text) = 'a'::text) (2 rows)</code> </pre><br>  Il ne faut pas grand-chose pour r√©√©crire cette requ√™te sp√©cifique afin que seul le nom du champ soit √©crit √† gauche de l'op√©rateur.  Mais si cela n'est pas possible, les index sur les expressions (index fonctionnels) aideront: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(lower(b)); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> lower(b) = <span class="hljs-string"><span class="hljs-string">'a'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------- Bitmap Heap Scan on t Recheck Cond: (lower((b)::text) = 'a'::text) -&gt; Bitmap Index Scan on t_lower_idx Index Cond: (lower((b)::text) = 'a'::text) (4 rows)</code> </pre><br>  L'index fonctionnel est construit non pas sur un champ de table, mais sur une expression arbitraire.  L'optimiseur consid√©rera cet index pour des conditions telles que " <em>expression d'op√©rateur d'expression index√©e</em> ".  Si le calcul de l'expression √† indexer est une op√©ration co√ªteuse, la mise √† jour de l'index n√©cessitera √©galement des ressources de calcul importantes. <br><br>  Veuillez √©galement garder √† l'esprit qu'une statistique individuelle est collect√©e pour l'expression index√©e.  Nous pouvons conna√Ætre cette statistique dans la vue "pg_stats" par le nom de l'index: <br><br><pre> <code class="pgsql hljs">postgres=# \dt</code> </pre><pre> <code class="plaintext hljs"> Table "public.t" Column | Type | Modifiers --------+---------+----------- a | integer | b | text | c | boolean | Indexes: "t_a_b_idx" btree (a, b) "t_a_idx" btree (a) "t_b_idx" btree (b) "t_lower_idx" btree (lower(b))</code> </pre><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_stats <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'t_lower_idx'</span></span>;</code> </pre><br>  Il est possible, si n√©cessaire, de contr√¥ler le nombre de paniers d'histogramme de la m√™me mani√®re que pour les champs de donn√©es normaux (en notant que le nom de la colonne peut diff√©rer selon l'expression index√©e): <br><br><pre> <code class="pgsql hljs">postgres=# \d t_lower_idx</code> </pre><pre> <code class="plaintext hljs"> Index "public.t_lower_idx" Column | Type | Definition --------+------+------------ lower | text | lower(b) btree, for table "public.t"</code> </pre><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> t_lower_idx <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> "lower" <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">statistics</span></span> <span class="hljs-number"><span class="hljs-number">69</span></span>;</code> </pre><br><blockquote>  PostgreSQL 11 a introduit un moyen plus propre de contr√¥ler la cible des statistiques pour les index en sp√©cifiant le <em>num√©ro de</em> colonne dans la commande ALTER INDEX ... SET STATISTICS.  Le patch a √©t√© d√©velopp√© par mon coll√®gue Alexander Korotkov et Adrien Nayrat. </blockquote><br><h3>  Index partiels </h3><br>  Parfois, il est n√©cessaire d'indexer uniquement une partie des lignes de table.  Ceci est g√©n√©ralement li√© √† une distribution tr√®s non uniforme: il est logique de rechercher une valeur peu fr√©quente par un index, mais il est plus facile de trouver une valeur fr√©quente en parcourant compl√®tement la table. <br><br>  Nous pouvons certainement construire un index r√©gulier sur la colonne ¬´c¬ª, qui fonctionnera comme nous l'attendons: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(c); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------- Index Scan using t_c_idx on t Index Cond: (c = true) Filter: c (3 rows)</code> </pre><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> c;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------- Seq Scan on t Filter: (NOT c) (2 rows)</code> </pre><br>  Et la taille de l'index est de 276 pages: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> relpages <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> relname=<span class="hljs-string"><span class="hljs-string">'t_c_idx'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relpages ---------- 276 (1 row)</code> </pre><br>  Mais comme la colonne ¬´c¬ª n'a la valeur true que pour 1% des lignes, 99% de l'index n'est en fait jamais utilis√©.  Dans ce cas, nous pouvons construire un index partiel: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(c) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t;</code> </pre><br>  La taille de l'index est r√©duite √† 5 pages: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> relpages <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> relname=<span class="hljs-string"><span class="hljs-string">'t_c_idx1'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relpages ---------- 5 (1 row)</code> </pre><br>  Parfois, la diff√©rence de taille et de performances peut √™tre assez importante. <br><br><h3>  Tri </h3><br>  Si une m√©thode d'acc√®s renvoie des identificateurs de ligne dans un ordre particulier, cela fournit √† l'optimiseur des options suppl√©mentaires pour effectuer la requ√™te. <br><br>  Nous pouvons scanner le tableau puis trier les donn√©es: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_indexscan=<span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> a;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------- Sort Sort Key: a -&gt; Seq Scan on t (3 rows)</code> </pre><br>  Mais nous pouvons lire les donn√©es en utilisant l'index facilement dans un ordre souhait√©: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_indexscan=<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> a;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------- Index Scan using t_a_idx on t (1 row)</code> </pre><br>  Seul ¬´btree¬ª sur toutes les m√©thodes d'acc√®s peut renvoyer des donn√©es tri√©es, alors reportons une discussion plus d√©taill√©e jusqu'√† ce que nous consid√©rions ce type d'index. <br><br><h3>  B√¢timent simultan√© </h3><br>  Habituellement, la construction d'un index acquiert un verrou SHARE pour la table.  Ce verrou permet de lire les donn√©es de la table, mais interdit toute modification pendant la construction de l'index. <br><br>  Nous pouvons nous en assurer si, par exemple, lors de la construction d'un index sur la table "t", nous effectuons la requ√™te ci-dessous dans une autre session: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> mode, granted <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> relation = <span class="hljs-string"><span class="hljs-string">'t'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> mode | granted -----------+--------- ShareLock | t (1 row)</code> </pre><br>  Si la table est suffisamment grande et largement utilis√©e pour l'insertion, la mise √† jour ou la suppression, cela peut sembler inadmissible car les processus de modification attendront une lib√©ration du verrou pendant longtemps. <br><br>  Dans ce cas, nous pouvons utiliser la construction simultan√©e d'un index. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">concurrently</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(a);</code> </pre><br>  Cette commande verrouille la table en mode SHARE UPDATE EXCLUSIVE, ce qui permet √† la fois la lecture et la mise √† jour (seule la modification de la structure de la table est interdite, ainsi que la mise sous vide, l'analyse ou la construction d'un autre index sur cette table). <br><br>  Cependant, il y a aussi un revers.  Tout d'abord, l'index sera construit plus lentement que d'habitude car deux passages √† travers la table sont effectu√©s au lieu d'un, et il est √©galement n√©cessaire d'attendre la fin des transactions parall√®les qui modifient les donn√©es. <br><br>  Deuxi√®mement, avec la construction simultan√©e de l'index, un blocage peut se produire ou des contraintes uniques peuvent √™tre viol√©es.  Cependant, l'index sera construit, bien qu'il ne fonctionne pas.  Un tel index doit √™tre supprim√© et reconstruit.  Les index non op√©rationnels sont marqu√©s avec le mot INVALID dans la sortie de la commande psql \ d, et la requ√™te ci-dessous renvoie une liste compl√®te de ceux-ci: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> indexrelid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> index_name, indrelid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-built_in"><span class="hljs-built_in">table_name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_index <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> indisvalid;</code> </pre><pre> <code class="plaintext hljs"> index_name | table_name ------------+------------ t_a_idx | t (1 row)</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Continuez √† lire</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441962/">https://habr.com/ru/post/fr441962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr441946/index.html">API REST sur Laravel en 100 lignes de code</a></li>
<li><a href="../fr441950/index.html">Eclipse Che 7 est d√©j√† l√†</a></li>
<li><a href="../fr441952/index.html">Choisir un syst√®me de stockage de fichiers pour le travail d'√©quipe</a></li>
<li><a href="../fr441954/index.html">R√©compense utilisateur aux auteurs de Habr</a></li>
<li><a href="../fr441956/index.html">Gestion des erreurs unifi√©e (option C ++ pour microcontr√¥leurs)</a></li>
<li><a href="../fr441964/index.html">Trucs et astuces Kubernetes: d√©placement des ressources de cluster vers Helm 2</a></li>
<li><a href="../fr441966/index.html">Kit de d√©marrage des tests de s√©curit√© Web</a></li>
<li><a href="../fr441968/index.html">D√©veloppement d'une nouvelle branche produit: comment se d√©barrasser de l'impraticable et rester utile</a></li>
<li><a href="../fr441970/index.html">Analyse FinFisher Butkit</a></li>
<li><a href="../fr441972/index.html">Invidious - Frontend YouTube alternatif</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>