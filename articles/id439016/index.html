<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüè≠ üçç ‚òùüèæ Tabel Generik Statis ‚è≥ üë©‚Äçüè´ üîß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kita semua sering harus berurusan dengan tabel statis, mereka dapat menjadi pengaturan aplikasi kita, layar otorisasi, layar "tentang kita", dan banya...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tabel Generik Statis</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439016/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a6/15a/4f2/6a615a4f2323c53913f33aca999fd661.png" alt="gambar"></div><br>  Kita semua sering harus berurusan dengan tabel statis, mereka dapat menjadi pengaturan aplikasi kita, layar otorisasi, layar "tentang kita", dan banyak lainnya.  Namun seringkali, pengembang pemula tidak menerapkan pola pengembangan untuk tabel tersebut dan menulis semua dalam satu kelas sistem yang tidak dapat diskalakan dan tidak fleksibel. <br><br>  Tentang bagaimana saya mengatasi masalah ini - di bawah potongan. <br><a name="habracut"></a><br><h4>  Apa yang kamu bicarakan </h4><br>  Sebelum Anda memecahkan masalah tabel statis, Anda harus memahami apa itu tabel.  Tabel statis adalah tabel di mana Anda sudah tahu jumlah baris dan konten yang ada di dalamnya.  Contoh tabel serupa di bawah ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/635/327/f7c/635327f7cf51ff06df260af777dba8eb.png" alt="gambar"><br><br><h4>  Masalah </h4><br>  Untuk mulai dengan, ada baiknya mengidentifikasi masalah: mengapa kita tidak bisa hanya membuat ViewController yang akan menjadi UITableViewDelegate dan UITableViewDatasource dan cukup jelaskan semua sel yang Anda butuhkan?  Setidaknya - ada 5 masalah dengan tabel kami: <br><br><ol><li> Sulit untuk diukur </li><li>  Tergantung indeks </li><li>  Tidak fleksibel </li><li>  Kurangnya penggunaan kembali </li><li>  Membutuhkan banyak kode untuk diinisialisasi </li></ol><br><h4>  Solusi </h4><br>  Metode untuk memecahkan masalah didasarkan pada fondasi berikut: <br><br><ol><li>  Penghapusan tanggung jawab konfigurasi tabel di kelas yang terpisah ( <b>Konstruktor</b> ) </li><li>  Wrapper khusus di atas <b>UITableViewDelegate</b> dan <b>UITableViewDataSource</b> </li><li>  Menghubungkan sel ke protokol khusus untuk digunakan kembali </li><li>  Membuat model data Anda sendiri untuk setiap tabel </li></ol><br>  Pertama saya ingin menunjukkan bagaimana ini digunakan dalam praktek - maka saya akan menunjukkan bagaimana semuanya diterapkan di bawah tenda. <br><br><h4>  Implementasi </h4><br>  Tugasnya adalah membuat tabel dengan dua sel teks dan satu kosong di antaranya. <br><br>  Pertama-tama, saya membuat <b>TextTableViewCell</b> biasa dengan <b>UILabel</b> . <br>  Selanjutnya, setiap UIViewController dengan tabel statis memerlukan Konstruktornya sendiri, mari kita buat: <br><br><pre><code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ViewControllerConstructor: StaticConstructorContainer { typealias ModelType = &lt;<span class="hljs-meta"><span class="hljs-meta">#type#&gt; }</span></span></code> </pre> <br>  Ketika kita mewarisinya dari <b>StaticConstructorContainer</b> , pertama-tama, protokol Generic mengharuskan kita untuk mengetik model ( <b>ModelType</b> ) - ini adalah jenis model sel yang juga perlu kita buat, mari kita lakukan. <br><br>  Saya menggunakan enum untuk ini, karena lebih cocok untuk tugas kami dan di sini kesenangan dimulai.  Kami akan mengisi tabel kami dengan konten menggunakan protokol seperti: <i>Judul, Subtitle, Berwarna, Berwarna</i> dan sebagainya.  Seperti yang bisa Anda tebak, protokol-protokol ini bertanggung jawab untuk menampilkan teks.  Katakanlah protokol Titled memerlukan <b>judul: String?</b>  , dan jika sel kami mendukung tampilan <b>judul</b> , itu akan mengisinya.  Mari kita lihat seperti apa: <br><br><pre> <code class="objectivec hljs">protocol Fonted { var font: <span class="hljs-built_in"><span class="hljs-built_in">UIFont</span></span>? { get } } protocol FontedConfigurable { func configure(by model: Fonted) } protocol Titled { var title: String? { get } } protocol TitledConfigurable { func configure(by model: Titled) } protocol Subtitled { var subtitle: String? { get } } protocol SubtitledConfigurable { func configure(by model: Subtitled) } protocol Imaged { var image: <span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span>? { get } } protocol ImagedConfigurable { func configure(by model: Imaged) }</code> </pre><br>  Oleh karena itu, hanya sebagian kecil dari protokol tersebut yang disajikan di sini, Anda dapat membuatnya sendiri, seperti yang Anda lihat - sangat sederhana.  Saya mengingatkan Anda bahwa kami membuat mereka 1 kali untuk 1 tujuan dan kemudian melupakan mereka dan dengan tenang menggunakannya. <br><br>  Sel kita ( <i>dengan teks</i> ) pada dasarnya mendukung hal-hal berikut: Font teks, teks itu sendiri, warna teks, warna latar belakang sel, dan umumnya segala hal yang terlintas dalam pikiran. <br><br>  Kami hanya membutuhkan <b>gelar</b> sejauh ini.  Oleh karena itu, kami mewarisi model kami dari Titled.  Di dalam model dalam kasus, kami menunjukkan jenis sel apa yang akan kita miliki. <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CellModel: Titled { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> firstText <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> emptyMiddle <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> secondText var title: String? { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .firstText: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">" - "</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .secondText: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">" - "</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } }</code> </pre><br>  Karena tidak ada label di tengah (sel kosong), Anda dapat mengembalikan nol. <br>  Kami menyelesaikan sel C dan Anda dapat memasukkannya ke konstruktor kami. <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ViewControllerConstructor: StaticConstructorContainer { typealias ModelType = CellModel var models: [CellModel] <span class="hljs-comment"><span class="hljs-comment">//        ,    func cellType(for model: CellModel) -&gt; Self.StaticTableViewCellClass.Type { //      ,    } func configure(cell: UITableViewCell, by model: CellModel) { //      ,   ,      } func itemSelected(item: CellModel) { //  didSelect,     } }</span></span></code> </pre> <br>  Dan sebenarnya, ini semua kode kita.  Kita dapat mengatakan bahwa meja kita sudah siap.  Mari kita mengisi data dan melihat apa yang terjadi. <br><br>  Oh ya, aku hampir lupa.  Kita perlu mewarisi sel kita dari protokol TitledConfigurable sehingga bisa memasukkan judul ke dirinya sendiri.  Sel juga mendukung ketinggian dinamis. <br><br><pre> <code class="objectivec hljs">extension TextTableViewCell: TitledConfigurable { func configure(by model: Titled) { label.text = model.title } }</code> </pre><br>  Seperti apa konstruktor yang diisi: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ViewControllerConstructor: StaticConstructorContainer { typealias ModelType = CellModel var models: [CellModel] = [.firstText, .emptyMiddle, .secondText] func cellType(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> model: CellModel) -&gt; StaticTableViewCellClass.Type { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> model { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .emptyMiddle: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EmptyTableViewCell.self <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .firstText, .secondText: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TextTableViewCell.self } } func configure(cell: <span class="hljs-built_in"><span class="hljs-built_in">UITableViewCell</span></span>, by model: CellModel) { cell.selectionStyle = .none } func itemSelected(item: CellModel) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> item { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .emptyMiddle: print(<span class="hljs-string"><span class="hljs-string">"  "</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: print(<span class="hljs-string"><span class="hljs-string">"  ..."</span></span>) } } }</code> </pre><br>  Terlihat sangat kompak, bukan? <br><br>  Sebenarnya, hal terakhir yang harus kita lakukan adalah menghubungkan semuanya ke ViewController'e: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ViewController: <span class="hljs-built_in"><span class="hljs-built_in">UIViewController</span></span> { private let tableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span> = { let tableView = <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tableView }() private let constructor = ViewControllerConstructor() private lazy var delegateDataSource = constructor.delegateDataSource() override func viewDidLoad() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() constructor.setup(at: tableView, dataSource: delegateDataSource) } }</code> </pre> <br>  Semuanya siap, kita harus menjadikan <b>delegateDataSource</b> sebagai properti terpisah di kelas kita sehingga tautan yang lemah tidak merusak fungsi apa pun. <br><br>  Kita dapat berlari dan menguji: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5f7/3e8/905/5f73e890597d805b3a341ee2a26f53d8.png" alt="gambar"><br><br>  Seperti yang Anda lihat, semuanya berfungsi. <br><br>  Sekarang mari kita simpulkan dan pahami apa yang telah kita capai: <br><br><ol><li>  Jika kami membuat sel baru dan ingin mengganti yang sekarang dengan itu, maka kami melakukan ini dengan mengubah satu variabel.  Kami memiliki sistem tabel yang sangat fleksibel </li><li>  Kami menggunakan kembali semua sel.  Semakin banyak sel yang Anda tautkan ke tabel ini, semakin mudah dan mudah untuk bekerja dengannya.  Bagus untuk proyek besar. </li><li>  Kami telah mengurangi jumlah kode untuk membuat tabel.  Dan kita harus menulis lebih sedikit ketika kita memiliki banyak protokol dan sel statis di proyek. </li><li>  Kami membawa konstruksi tabel statis dari <b>UIViewController</b> ke <b>Konstruktor</b> </li><li>  Kami telah berhenti bergantung pada indeks, kami dapat dengan aman menukar sel dalam array dan logika tidak akan pecah. </li></ol><br>  Kode untuk proyek uji di akhir artikel. <br><br><h4>  Bagaimana cara kerjanya dari dalam ke luar? </h4><br>  Cara kerja protokol sudah kita bahas.  Sekarang kita perlu memahami bagaimana seluruh konstruktor dan kelas terkait bekerja. <br><br>  Mari kita mulai dengan konstruktor itu sendiri: <br><pre> <code class="objectivec hljs">protocol StaticConstructorContainer { associatedtype ModelType var models: [ModelType] { get } func cellType(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> model: ModelType) -&gt; StaticTableViewCellClass.Type func configure(cell: <span class="hljs-built_in"><span class="hljs-built_in">UITableViewCell</span></span>, by model: ModelType) func itemSelected(item: ModelType) }</code> </pre> <br>  Ini adalah protokol umum yang membutuhkan fungsi yang sudah akrab bagi kita. <br><br>  Lebih menarik adalah <b>ekstensi</b> : <br><br><pre> <code class="objectivec hljs">extension StaticConstructorContainer { typealias StaticTableViewCellClass = StaticCell &amp; NibLoadable func delegateDataSource() -&gt; StaticDataSourceDelegate&lt;Self&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StaticDataSourceDelegate&lt;Self&gt;.init(container: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) } func setup&lt;T: StaticConstructorContainer&gt;(at tableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>, dataSource: StaticDataSourceDelegate&lt;T&gt;) { models.forEach { (model) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> let type = cellType(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: model) tableView.register(type.nib, forCellReuseIdentifier: type.name) } tableView.delegate = dataSource tableView.dataSource = dataSource dataSource.tableView = tableView } }</code> </pre> <br>  Fungsi <i>pengaturan</i> yang kami panggil di ViewController kami mendaftarkan semua sel untuk kami dan mendelegasikan <b>dataSource</b> dan <b>mendelegasikan</b> . <br><br>  Dan <i><b>delegateDataSource ()</b></i> menciptakan bagi kami <b>UITableViewDataSource</b> wrapper dan <b>UITableViewDelegate</b> .  Mari kita melihatnya: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> StaticDataSourceDelegate&lt;Container: StaticConstructorContainer&gt;: <span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">UITableViewDelegate</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">UITableViewDataSource</span></span> { private let container: Container <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> var tableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>? init(container: Container) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.container = container } func reload() { tableView?.reloadData() } func tableView(_ tableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>, estimatedHeightForRowAt indexPath: IndexPath) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span> { let type = container.cellType(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: container.models[indexPath.row]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type.estimatedHeight ?? type.height } func tableView(_ tableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>, heightForRowAt indexPath: IndexPath) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span> { let type = container.cellType(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: container.models[indexPath.row]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type.height } func tableView(_ tableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>, numberOfRowsInSection section: Int) -&gt; Int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container.models.count } func tableView(_ tableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>, cellForRowAt indexPath: IndexPath) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">UITableViewCell</span></span> { let model = container.models[indexPath.row] let type = container.cellType(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: model) let cell = tableView.dequeueReusableCell(withIdentifier: type.name, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: indexPath) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let typedCell = cell as? TitledConfigurable, let titled = model as? Titled { typedCell.configure(by: titled) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let typedCell = cell as? SubtitledConfigurable, let subtitle = model as? Subtitled { typedCell.configure(by: subtitle) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let typedCell = cell as? ImagedConfigurable, let imaged = model as? Imaged { typedCell.configure(by: imaged) } container.configure(cell: cell, by: model) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell } func tableView(_ tableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>, didSelectRowAt indexPath: IndexPath) { let model = container.models[indexPath.row] container.itemSelected(item: model) } }</code> </pre> <br>  Saya pikir tidak ada pertanyaan tentang fungsi <b>heightForRowAt</b> , <b>numberOfRowsInSection</b> , <b>didSelectRowAt</b> , mereka hanya mengimplementasikan fungsionalitas yang jelas.  Metode yang paling menarik di sini adalah <b>cellForRowAt</b> . <br><br>  Di dalamnya, kami tidak menerapkan logika yang paling indah.  Kami dipaksa untuk menulis setiap protokol baru ke sel di sini, tetapi kami melakukannya sekali - jadi tidak begitu menakutkan.  Jika model sesuai dengan protokol, sama seperti sel kita, maka kita akan mengkonfigurasinya.  Jika ada yang punya ide tentang cara mengotomatisasi ini, saya akan senang mendengarkan komentar. <br><br>  Ini mengakhiri logika.  Saya tidak menyentuh kelas utilitarian pihak ketiga dalam sistem ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anda dapat membaca kode lengkapnya di sini</a> . <br><br>  Terima kasih atas perhatian anda! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439016/">https://habr.com/ru/post/id439016/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439000/index.html">Manipulasi Spasial 2D dengan Bidang Jarak Bertanda</a></li>
<li><a href="../id439002/index.html">Bagaimana cara berhenti "menulis TK" dan mulai bekerja?</a></li>
<li><a href="../id439006/index.html">Bagaimana AI Membantu Mempelajari Bahasa Isyarat</a></li>
<li><a href="../id439010/index.html">Cara konsolidasi arsip bekerja di DeviceLock DLP</a></li>
<li><a href="../id439012/index.html">Direktori telepon organisasi - versi cetak</a></li>
<li><a href="../id439018/index.html">Konfigurasikan Pencarian Sphinx untuk Toko Online</a></li>
<li><a href="../id439020/index.html">Tiket untuk Naik Eropa - Aritmatika, Bagian Dua</a></li>
<li><a href="../id439022/index.html">CNC dalam lokakarya hobi (bagian 3)</a></li>
<li><a href="../id439024/index.html">Slurm 3 Hasil</a></li>
<li><a href="../id439026/index.html">Pelajari Taktik Adversarial, Teknik & Pengetahuan Umum (ATT @ CK). Taktik Perusahaan. Bagian 8</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>