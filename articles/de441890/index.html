<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶Ü ü§ô üë®üèæ‚Äçüéì Alles, was Sie √ºber iOS App Extensions wissen m√ºssen üö£üèº üå∑ üëï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="App-Erweiterungen wurden in iOS 8 ver√∂ffentlicht und machten das System f√ºr Benutzer flexibler, leistungsf√§higer und erschwinglicher. Anwendungen k√∂nn...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Alles, was Sie √ºber iOS App Extensions wissen m√ºssen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mobileup/blog/441890/"><img src="https://habrastorage.org/webt/2n/jy/99/2njy99obhw-o7fthqzpd0f5ncxm.png"><br><br>  App-Erweiterungen wurden in iOS 8 ver√∂ffentlicht und machten das System f√ºr Benutzer flexibler, leistungsf√§higer und erschwinglicher.  Anwendungen k√∂nnen als Widget im Benachrichtigungscenter angezeigt werden, bieten ihre Filter f√ºr Fotos in Fotos an, zeigen eine neue Systemtastatur an und vieles mehr.  Gleichzeitig wurde die Sicherheit der Benutzerdaten und des Systems gewahrt.  Die Funktionen der Arbeit von App Extensions werden unten erl√§utert. <br><a name="habracut"></a><br>  Apple hat immer versucht, Anwendungen sorgf√§ltig voneinander zu isolieren.  Dies ist der beste Weg, um die Sicherheit der Benutzer zu gew√§hrleisten und ihre Daten zu sch√ºtzen.  Jede Anwendung erh√§lt einen separaten Platz im Dateisystem mit eingeschr√§nktem Zugriff.  App-Erweiterungen erm√∂glichten die Interaktion mit der Anwendung, ohne sie zu starten oder auf dem Bildschirm anzuzeigen.  Somit steht ein Teil seiner Funktionalit√§t Benutzern zur Verf√ºgung, wenn sie mit anderen Anwendungen oder dem System interagieren. <br><br>  App-Erweiterungen sind ausf√ºhrbare Dateien, die unabh√§ngig von der enthaltenen Anwendung ausgef√ºhrt werden - <b>Enth√§lt App</b> .  Sie k√∂nnen nicht allein mit der enthaltenen App im App Store ver√∂ffentlicht werden.  Alle App-Erweiterungen f√ºhren eine bestimmte Aufgabe aus und sind je nach Typ nur an einen Bereich von iOS gebunden.  Beispiel: Benutzerdefinierte Tastaturerweiterungen dienen zum Ersetzen der Standardtastatur und Fotobearbeitungserweiterungen zum Bearbeiten von Fotos in Fotos.  Derzeit gibt es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">25 Arten von</a> App-Erweiterungen. <br><br><h1>  Life Extension App Extension </h1><br>  Die Anwendung, mit der der Benutzer die App-Erweiterung startet, wird als <b>Host-App bezeichnet</b> .  Die Host-App startet den Lebenszyklus der App-Erweiterung und sendet eine Anfrage als Antwort auf eine Benutzeraktion: <br><br><img src="https://habrastorage.org/webt/jp/kl/vj/jpklvjv3yd2-5e3q_ownsx4d9my.png"><br><br><ul><li>  Der Benutzer w√§hlt die App-Erweiterung √ºber die Host-App aus. <br></li><li>  Die Host-App sendet eine App-Erweiterungsanforderung. <br></li><li>  iOS startet die App-Erweiterung im Kontext der Host-App und richtet einen Kommunikationskanal zwischen ihnen ein. <br></li><li>  Der Benutzer f√ºhrt eine Aktion in der App-Erweiterung aus. <br></li><li>  Die App-Erweiterung schlie√üt die Anforderung von der Host-App ab, f√ºhrt eine Aufgabe aus oder startet einen Hintergrundprozess, um sie abzuschlie√üen.  Nach Abschluss der Aufgabe kann das Ergebnis an die Host-App zur√ºckgegeben werden. <br></li><li>  Sobald die App-Erweiterung ihren Code ausf√ºhrt, beendet das System diese App-Erweiterung. <br></li></ul><br>  Wenn Sie beispielsweise ein Foto von Fotos mit der Facebook-Freigabeerweiterung freigeben, ist Facebook die enthaltende App und Fotos die Host-App.  In diesem Fall startet Fotos den Lebenszyklus der Facebook-Freigabeerweiterung, wenn der Benutzer ihn im Freigabemen√º ausw√§hlt: <br><br><img src="https://habrastorage.org/webt/65/11/9a/65119akk96p0z1dqrmltolv73ss.png"><br><br><h1>  Interaktion mit der App-Erweiterung </h1><br><img src="https://habrastorage.org/webt/o_/wn/mg/o_wnmgqodkshdtrb7vgnakhymse.png"><br><br><ul><li>  <b>Enth√§lt App - Host App</b> <br>  Interagiere nicht miteinander. <br></li><li> <b>App-Erweiterung - Host-App</b> <br>  Interagiere mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IPC</a> . <br></li><li>  <b>App-Erweiterung - Enth√§lt App</b> <br>  Indirekte Interaktion.  <b>App-Gruppen</b> werden f√ºr den Datenaustausch verwendet, und <b>Embedded Frameworks</b> werden f√ºr allgemeinen Code verwendet.  Sie k√∂nnen die enthaltende App √ºber die App-Erweiterung mithilfe der <b>URL-Schemata</b> starten. <br></li></ul><br><h2>  Generischer Code: dynamische Frameworks </h2><br>  Wenn die enthaltende App und die App-Erweiterung denselben Code verwenden, sollte dieser in einem dynamischen Framework platziert werden. <br><br>  Beispielsweise kann eine Fotobearbeitungserweiterung einer benutzerdefinierten Fotobearbeitungsanwendung zugeordnet sein, die einige Filter aus der enthaltenen App verwendet.  Eine gute L√∂sung w√§re, ein dynamisches Framework f√ºr diese Filter zu erstellen. <br><br>  F√ºgen Sie dazu ein neues <b>Ziel hinzu</b> und w√§hlen Sie das <b>Cocoa Touch Framework aus</b> : <br><br><img src="https://habrastorage.org/webt/4o/-i/65/4o-i65s30q1srdwldrhhrj8sfuw.png"><br><br>  Geben Sie einen Namen an (z. B. <b>ImageFilters</b> ), und im Navigatorfenster wird ein neuer Ordner mit dem Namen des erstellten Frameworks angezeigt: <br><br><img src="https://habrastorage.org/webt/k5/ih/nn/k5ihnnf83plqtwrwqquhe3pxzuq.png" align="left" width="270" height="377">  Sie m√ºssen sicherstellen, dass das Framework keine APIs verwendet, die f√ºr App-Erweiterungen nicht verf√ºgbar sind: <br><br><ul><li>  Geteilt von UIApplication. <br></li><li>  Mit Unzug√§nglichkeitsmakros gekennzeichnete APIs. <br></li><li>  Kamera und Mikrofon (au√üer iMessage Extension). <br></li><li>  Ausf√ºhren langwieriger Hintergrundaufgaben (Funktionen dieser Einschr√§nkung variieren je nach Art der App-Erweiterung). <br></li><li>  Daten mit AirDrop empfangen. <br></li></ul><br>  Die Verwendung einer dieser Listen in App-Erweiterungen f√ºhrt zu deren Ablehnung, wenn sie im App Store ver√∂ffentlicht werden. <br><br>  In den Framework-Einstellungen unter <b>Allgemein m√ºssen</b> Sie das Kontrollk√§stchen neben <b>"Nur App-Erweiterungs-API zulassen" aktivieren</b> : <br><br><img src="https://habrastorage.org/webt/6v/bz/ky/6vbzkycc0py7axwtcx2nji1oevk.png"><br><br>  Im Framework-Code m√ºssen alle Klassen, Methoden und Eigenschaften, die in der Containing App und den App Extensions verwendet werden, <code>public</code> .  Wo immer Sie das Framework verwenden m√ºssen, <code>import</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ImageFilters</code> </pre> <br><h2>  Datenaustausch: App-Gruppen </h2><br>  Die Containing App und die App Extension haben ihre eigenen begrenzten Abschnitte des Dateisystems und nur sie haben Zugriff darauf.  Damit die enthaltende App und die App-Erweiterung einen gemeinsamen Container mit Lese- und Schreibzugriff haben, m√ºssen Sie eine App-Gruppe f√ºr sie erstellen. <br><br>  Die App-Gruppe wird im <b>Apple Developer Portal erstellt</b> : <br><br><img src="https://habrastorage.org/webt/sw/ax/od/swaxodkpniu6gd_qdce6kh7bjj8.png"><br><br>  Klicken Sie in der oberen rechten Ecke auf "+". Geben Sie im angezeigten Fenster die erforderlichen Daten ein: <br><br><img src="https://habrastorage.org/webt/db/bt/m8/dbbtm8iuqbihyixcsz7n79hm95e.png"><br><br>  Weiter <b>Weiter -&gt; Registrieren -&gt; Fertig</b> . <br><br>  Wechseln Sie in den Einstellungen der enthaltenen App zur Registerkarte Funktionen, aktivieren Sie App-Gruppen und w√§hlen Sie die erstellte Gruppe aus: <br><br><img src="https://habrastorage.org/webt/cr/tu/_r/crtu_rzlbyzuhb67tp9yqxv4s0k.png"><br><br>  √Ñhnliches gilt f√ºr die App-Erweiterung: <br><br><img src="https://habrastorage.org/webt/cy/nd/pm/cyndpm2qzr49uk-lye8ahysbdkc.png"><br><br>  Jetzt teilen sich die Containing App und die App Extension einen Container.  Als n√§chstes werden wir dar√ºber sprechen, wie man es liest und schreibt. <br><br><h3>  UserDefaults </h3><br>  Um eine kleine Datenmenge auszutauschen, ist es praktisch, <code>UserDefaults</code> zu verwenden. Sie m√ºssen lediglich den Namen der App-Gruppe angeben: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sharedDefaults = <span class="hljs-type"><span class="hljs-type">UserDefaults</span></span>(suiteName: <span class="hljs-string"><span class="hljs-string">"group.com.maxial.onemoreapp"</span></span>)</code> </pre> <br><h3>  NSFileCoordinator und NSFilePresenter </h3><br>  F√ºr Big Data ist <code>NSFileCoordinator</code> besser geeignet, um die Lese- / Schreibkonsistenz sicherzustellen.  Dadurch wird eine Besch√§digung der Daten vermieden, da m√∂glicherweise mehrere Prozesse gleichzeitig darauf zugreifen k√∂nnen. <br><br>  Die URL des freigegebenen Containers wird wie folgt abgerufen: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sharedUrl = <span class="hljs-type"><span class="hljs-type">FileManager</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>.containerURL(forSecurityApplicationGroupIdentifier: <span class="hljs-string"><span class="hljs-string">"group.com.maxial.onemoreapp"</span></span>)</code> </pre> <br>  Aufzeichnung: <br><br><pre> <code class="swift hljs">fileCoordinator.coordinate(writingItemAt: sharedUrl, options: [], error: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { [<span class="hljs-keyword"><span class="hljs-keyword">unowned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] newUrl <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-type"><span class="hljs-type">NSKeyedArchiver</span></span>.archivedData(withRootObject: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.object, requiringSecureCoding: <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> data.write(to: newUrl, options: .atomic) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(error) } }</code> </pre> <br>  Lesen: <br><br><pre> <code class="swift hljs">fileCoordinator.coordinate(readingItemAt: sharedUrl, options: [], error: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { newUrl <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-type"><span class="hljs-type">Data</span></span>(contentsOf: newUrl) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> object = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-type"><span class="hljs-type">NSKeyedUnarchiver</span></span>.unarchivedObject(ofClass: <span class="hljs-type"><span class="hljs-type">NSString</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, from: data) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-type"><span class="hljs-type">String?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.object = object } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(error) } }</code> </pre> <br>  Es ist zu beachten, dass <code>NSFileCoordinator</code> synchron arbeitet.  W√§hrend einige Dateien von einem Prozess belegt werden, m√ºssen andere warten, bis sie freigegeben werden. <br><br>  Wenn die App-Erweiterung wissen soll, wann die Containing App den Datenstatus √§ndert, wird <code>NSFilePresenter</code> verwendet.  Dies ist ein Protokoll, dessen Implementierung folgenderma√üen aussehen kann: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodayViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSFilePresenter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> presentedItemURL: <span class="hljs-type"><span class="hljs-type">URL?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sharedUrl = <span class="hljs-type"><span class="hljs-type">FileManager</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>.containerURL(forSecurityApplicationGroupIdentifier: <span class="hljs-string"><span class="hljs-string">"group.com.maxial.onemoreapp"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sharedUrl?.appendingPathComponent(<span class="hljs-string"><span class="hljs-string">"Items"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> presentedItemOperationQueue: <span class="hljs-type"><span class="hljs-type">OperationQueue</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .main } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">presentedItemDidChange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { } }</code> </pre> <br>  Die Eigenschaft presentItemOperationQueue gibt eine Warteschlange zur√ºck, die f√ºr R√ºckrufe beim √Ñndern von Dateien verwendet wird.  Die Methode <b><code>presentedItemDidChange()</code></b> wird aufgerufen, wenn ein Prozess, in diesem Fall die Containing App, den Inhalt der Daten √§ndert.  Wenn √Ñnderungen direkt mithilfe von Schreibaufrufen auf niedriger Ebene vorgenommen wurden, wird <b><code>presentedItemDidChange()</code></b> nicht aufgerufen.  Es werden nur √Ñnderungen gez√§hlt, die den <code>NSFileCoordinator</code> . <br><br>  Beim Initialisieren eines <code>NSFileCoordinator</code> Objekts <code>NSFileCoordinator</code> empfohlen, das <code>NSFilePresenter</code> Objekt zu √ºbergeben, insbesondere wenn eine Dateioperation <code>NSFilePresenter</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fileCoordinator = <span class="hljs-type"><span class="hljs-type">NSFileCoordinator</span></span>(filePresenter: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)</code> </pre> <br>  Andernfalls erh√§lt das <code>NSFilePresenter</code> Objekt Benachrichtigungen √ºber diese Vorg√§nge, die zu Deadlocks f√ºhren k√∂nnen, wenn Sie im selben Thread arbeiten. <br><br>  Um den Status der Daten zu √ºberwachen, m√ºssen Sie die Methode <b><code>addFilePresenter(_:)</code></b> mit dem entsprechenden Objekt aufrufen: <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">NSFileCoordinator</span></span>.addFilePresenter(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)</code> </pre> <br>  Alle sp√§ter erstellten <code>NSFileCoordinator</code> Objekte kennen dieses <code>NSFilePresenter</code> Objekt automatisch und benachrichtigen √ºber √Ñnderungen in seinem Verzeichnis. <br><br>  Verwenden Sie <b><code>removeFilePresenter(_:)</code></b> um die √úberwachung des Datenstatus zu <b><code>removeFilePresenter(_:)</code></b> : <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">NSFileCoordinator</span></span>.removeFilePresenter(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)</code> </pre> <br><h3>  Kerndaten </h3><br>  F√ºr die gemeinsame Nutzung von Daten k√∂nnen Sie SQLite und entsprechend Core Data verwenden.  Sie k√∂nnen Prozesse verwalten, die mit gemeinsam genutzten Daten arbeiten.  Um Core Data f√ºr die gemeinsame <code>NSPersistentContainer</code> zwischen der Containing App und der App Extension zu konfigurieren, erstellen Sie eine Unterklasse von <code>NSPersistentContainer</code> und √ºberschreiben Sie die <b><code>defaultDirectoryURL</code></b> Methode, die die Datenspeicheradresse zur√ºckgeben soll: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SharedPersistentContainer</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSPersistentContainer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">func</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">defaultDirectoryURL</span></span></span><span class="hljs-class">() -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> storeURL = <span class="hljs-type"><span class="hljs-type">FileManager</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>.containerURL(forSecurityApplicationGroupIdentifier: <span class="hljs-string"><span class="hljs-string">"group.com.maxial.onemoreapp"</span></span>) storeURL = storeURL?.appendingPathComponent(<span class="hljs-string"><span class="hljs-string">"OneMoreApp.sqlite"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> storeURL! } }</code> </pre> <br>  <code>AppDelegate</code> in <code>AppDelegate</code> die Eigenschaft <b><code>persistentContainer</code></b> .  Es wird automatisch erstellt, wenn beim Erstellen eines Projekts das Kontrollk√§stchen <b>Kerndaten verwenden</b> aktiviert ist.  Jetzt geben wir ein Objekt der <code>SharedPersistentContainer</code> Klasse zur√ºck: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> persistentContainer: <span class="hljs-type"><span class="hljs-type">NSPersistentContainer</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> container = <span class="hljs-type"><span class="hljs-type">SharedPersistentContainer</span></span>(name: <span class="hljs-string"><span class="hljs-string">"OneMoreApp"</span></span>) container.loadPersistentStores(completionHandler: { (storeDescription, error) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = error <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-type"><span class="hljs-type">NSError?</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"Unresolved error \(error), \(error.userInfo)"</span></span>) } }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container }()</code> </pre> <br>  Sie m√ºssen <b>lediglich .xcdatamodeld</b> zur App-Erweiterung hinzuf√ºgen.  W√§hlen Sie im Navigatorbereich die Datei .xcdatamodeld aus.  <b>Aktivieren Sie im Dateiinspektor im</b> Abschnitt Zielmitgliedschaft das Kontrollk√§stchen neben App-Erweiterung: <br><br><img src="https://habrastorage.org/webt/71/mb/t8/71mbt8ggk9msftndb3q2f0obvvu.png" width="270" height="386"><br><br>  Somit k√∂nnen die enthaltende App und die App-Erweiterung Daten in denselben Speicher lesen und schreiben und dasselbe Modell verwenden. <br><br><h2>  Starten der enthaltenen App √ºber die App-Erweiterung </h2><br>  Wenn die Host-App eine App-Erweiterungsanforderung sendet, stellt sie einen <b><code>extensionContext</code></b> bereit.  Dieses Objekt verf√ºgt √ºber eine <b><code>open(_:completionHandler:)</code></b> -Methode, mit der Sie die Containing App √∂ffnen k√∂nnen.  Diese Methode ist jedoch nicht f√ºr alle Arten von App-Erweiterungen verf√ºgbar.  Unter iOS wird es von Today Extension und iMessage Extension unterst√ºtzt.  iMessage Extension kann damit nur die Containing App √∂ffnen.  Wenn die Today Extension eine andere Anwendung damit √∂ffnet, ist m√∂glicherweise eine zus√§tzliche √úberpr√ºfung erforderlich, um sie an den App Store zu senden. <br><br>  Um die Anwendung √ºber die App-Erweiterung zu √∂ffnen, m√ºssen Sie das URL-Schema in der enthaltenen App definieren: <br><br><img src="https://habrastorage.org/webt/vh/zy/hi/vhzyhilxsny61ctuynhqhzfwvos.png"><br><br>  Rufen Sie als N√§chstes die Methode <b><code>open(_:completionHandler:)</code></b> mit diesem Diagramm aus der App-Erweiterung auf: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = <span class="hljs-type"><span class="hljs-type">URL</span></span>(string: <span class="hljs-string"><span class="hljs-string">"OneMoreAppUrl://"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } extensionContext?.<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(url, completionHandler: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br>  F√ºr die Arten von App-Erweiterungen, die die Methode <b><code>open(_:completionHandler:)</code></b> aufrufen, gibt es auch eine M√∂glichkeit.  Es besteht jedoch die M√∂glichkeit, dass die Anwendung beim Einchecken im App Store abgelehnt wird.  Das Wesentliche der Methode besteht darin <code>UIResponder</code> die Kette der <code>UIResponder</code> Objekte zu <code>UIResponder</code> , bis eine <code>UIApplication</code> <code>UIResponder</code> vorhanden ist, die den <b><code>openURL</code></b> Aufruf akzeptiert: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = <span class="hljs-type"><span class="hljs-type">URL</span></span>(string: <span class="hljs-string"><span class="hljs-string">"OneMoreAppUrl://"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> selectorOpenURL = sel_registerName(<span class="hljs-string"><span class="hljs-string">"openURL:"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> responder: <span class="hljs-type"><span class="hljs-type">UIResponder?</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> responder != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> responder?.responds(to: selectorOpenURL) == <span class="hljs-literal"><span class="hljs-literal">true</span></span> { responder?.perform(selectorOpenURL, with: url) } responder = responder?.next }</code> </pre> <br><h1>  Zuk√ºnftige App-Erweiterungen </h1><br>  App Extensions hat viel zur iOS-Entwicklung beigetragen.  Allm√§hlich erscheinen mehr Arten von App-Erweiterungen, deren Funktionen sich weiterentwickeln.  Mit der Ver√∂ffentlichung des iOS 12 SDK k√∂nnen Sie jetzt beispielsweise mit dem Inhaltsbereich in Benachrichtigungen interagieren, der so lange fehlte. <br><br>  Daher entwickelt Apple dieses Tool weiter, was Optimismus in Bezug auf seine Zukunft hervorruft. <br><br>  <b>N√ºtzliche Links:</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Offizielle Dokumentation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Daten zwischen iOS-Apps und App-Erweiterungen austauschen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tipps zur Entwicklung von iOS 8-App-Erweiterungen</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441890/">https://habr.com/ru/post/de441890/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441870/index.html">Solidprint Sign 3D-Drucker</a></li>
<li><a href="../de441878/index.html">Du wie du willst, aber ich habe es getan</a></li>
<li><a href="../de441882/index.html">VMware NSX f√ºr die Kleinsten. Teil 3. DHCP konfigurieren</a></li>
<li><a href="../de441886/index.html">In den letzten 12 Jahren habe ich nie einen Lebenslauf gezeigt</a></li>
<li><a href="../de441888/index.html">SIP von Megaphone zu Hause Rate</a></li>
<li><a href="../de441892/index.html">Erstellen einer Datenflussvorlage zum Streamen von Daten von Pub / Sub zu BigQuery basierend auf GCP mit dem Apache Beam SDK und Python</a></li>
<li><a href="../de441896/index.html">Lernen Sie kontroverse Taktiken, Techniken und allgemeines Wissen (ATT @ CK). Unternehmenstaktik. Teil 9</a></li>
<li><a href="../de441898/index.html">Sketch + Node.js: Generieren von Symbolen f√ºr viele Plattformen und Marken</a></li>
<li><a href="../de441900/index.html">Satya Nadella sprach √ºber die Zusammenarbeit mit dem Pentagon</a></li>
<li><a href="../de441902/index.html">Wie Technologie neue Realit√§ten schafft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>