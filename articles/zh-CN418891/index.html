<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😡 🔲 🈷️ 我们使用PVS-Studio检查了Android源代码，否则没人能完美 🍝 👩🏾‍🍳 👈🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A． 
 不使用编程方法和工具来帮助控制代码质量，就不可能开发大型复杂项目。 首先，它是一个合格的编码标准，代码审查，单元测试，静态和动态代码分析器。 所有这些都有助于在开发的最早阶段识别代码中的缺陷。 本文演示了PVS-Studio静态分析器检测Android操作系统代码中的错误和潜在漏洞的功能。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们使用PVS-Studio检查了Android源代码，否则没人能完美</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/418891/">  A． <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d66/7b5/688/d667b56886adb4c140b623e5c14d4fd5.png" alt="Android和Unicorn PVS-Studio"></div><br> 不使用编程方法和工具来帮助控制代码质量，就不可能开发大型复杂项目。 首先，它是一个合格的编码标准，代码审查，单元测试，静态和动态代码分析器。 所有这些都有助于在开发的最早阶段识别代码中的缺陷。 本文演示了PVS-Studio静态分析器检测Android操作系统代码中的错误和潜在漏洞的功能。 我们希望本文能够吸引读者使用静态代码分析的方法，并且希望在开发自己的项目的过程中实现它。 <br><a name="habracut"></a><br><h2> 引言 </h2><br> 自从撰写有关Tizen操作系统错误的大型<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a>以来已经过去了一年，我想再次对某些操作系统进行同样有趣的研究。 选择落在Android上。 <br><br>  Android操作系统代码质量良好，经过了良好的测试。 在开发过程中，至少使用Coverity静态代码分析器，如以下形式的注释所示： <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Coverity: [FALSE-POSITIVE error] intended fall through */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Missing break statement between cases in switch statement */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* fall through */</span></span></code> </pre> <br> 通常，这是一个有趣的高质量项目，对于我们的PVS-Studio静态分析仪而言，发现错误是一项挑战。 <br><br> 我认为，仅从文章的数量上，读者就可以了解PVS-Studio分析仪的出色工作，并发现该操作系统代码中的许多缺陷。 <br><br><h2> 常见弱点列举 </h2><br> 在本文中，您将找到对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">常见弱点枚举</a> （CWE）的引用。 让我们从安全的角度解释引用此列表的原因以及为什么它很重要。 <br><br> 通常，程序漏洞的原因不是某些棘手的情况，而是常见的软件错误。 在这里引用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">prqa.com的</a>报价是适当的： <br><br> 美国国家标准技术研究院（NIST）报告说，64％的软件漏洞源于编程错误，而不是缺乏安全功能。 <br><br> 您可以阅读文章“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PVS-Studio如何帮助发现漏洞？</a> ”，其中包含一些简单错误的示例，这些错误导致了MySQL，iOS，NAS，illumos-gate等项目中的漏洞。 <br><br> 因此，可以通过及时检测并修复常见错误来消除许多漏洞。 在这里，普通弱点枚举进入了场景。 <br><br> 错误是不同的，并且从安全角度来看，并非所有错误都是危险的。 常见弱点枚举中收集了可能导致漏洞的错误。 此列表正在更新中，可能存在可能导致漏洞的错误，但尚未包含在此列表中。 <br><br> 但是，如果错误是根据CWE分类的，则从理论上讲它有可能被利用为漏洞（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CVE</a> ）。 是的，这种可能性很小。  CWE很少变成CVE。 但是，如果您想保护代码免受漏洞侵害，则应尽可能找到CWE中描述的错误并加以修复。 <br><br> 示意图中，PVS-Studio，错误，CWE和CVE之间的关系如图所示： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/06f/5b9/142/06f5b9142918167cf4e0951f3affbaa6.png" alt="CWE，CVE，PVS-Studio"></div><br><br> 一些错误被分类为CWE。  PVS-Studio可以检测到许多此类错误，从而防止其中一些缺陷成为漏洞（CVE）。 <br><br> 可以说，PVS-Studio在潜在危害造成危害之前就已将其识别出来。 因此，PVS-Studio是静态应用程序安全测试工具（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SAST</a> ）。 <br><br> 现在，我认为，很清楚为什么在描述错误时，我认为重要的是要注意根据CWE对错误进行分类。 这样一来，很容易显示在操作系统与之明显相关的关键项目中使用静态代码分析器的重要性。 <br><br><h2>  Android检查 </h2><br> 为了分析该项目，我使用了PVS-Studio分析仪版本6.24。 该分析器当前支持以下语言和编译器： <br><br><ul><li> 窗户  Visual Studio 2010-2017 C，C ++，C ++ / CLI，C ++ / CX（WinRT），C＃ </li><li> 窗户  IAR嵌入式工作台，用于ARM C，C ++的C / C ++编译器 </li><li>  Windows / Linux  Keil µVision，DS-MDK，ARM编译器5/6 C，C ++ </li><li>  Windows / Linux 德州仪器Code Composer Studio，ARM代码生成工具C，C ++ </li><li>  Windows / Linux / macOS。  Clang C，C ++ </li><li>  Linux / macOS。  GCC C，C ++ </li><li> 窗户  MinGW C，C ++ </li></ul><br> 注意事项 也许有些读者错过了我们支持macOS环境下工作的消息，他们会对本出版物感兴趣：“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">针对MacOS的PVS-Studio版本：Apple XNU Kernel的64个弱点</a> ”。 <br><br> 检查Android源代码的过程不是问题，因此我不再赘述。 相反，问题是我全神贯注于其他任务，这就是为什么我没有找到时间和精力来尽我所能仔细地查看报告。 但是，即使快速浏览，也不足以为可靠的文章收集大量有趣的错误。 <br><br> 最重要的是：我要求Android开发人员不仅要纠正文章中描述的错误，还要进行更仔细的独立分析。 我从表面上看了分析仪报告，可能错过了很多严重的错误。 <br><br> 在第一次测试时，分析仪会产生很多误报，但这<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不是问题</a> 。 我们的团队随时准备提供有关配置分析仪以减少误报次数的建议。 如果需要，我们还准备提供一个月或更长时间的许可证密钥。 通常， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">给我们写信</a> ，我们将帮助您。 <br><br> 现在，让我们看看我设法找到了哪些错误和潜在漏洞。 希望您喜欢PVS-Studio静态代码分析器可以找到的东西。 阅读愉快。 <br><br><h2> 无意义的比较 </h2><br> 如果表达式始终为true或false，则分析器认为它们为异常。 根据常见弱点枚举，此类警告分类为： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CWE-570</a> ：表达式始终为假 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CWE-571</a> ：表达始终为真 </li></ul><br> 分析器会生成许多这样的警告，但不幸的是，大多数警告对于Android代码都是错误的。 在这种情况下，不要责怪分析仪。 只是代码是这样写的。 <br> 我将通过一个简单的示例对此进行演示。 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> GENERIC_TARGET const char alternative_config_path[] = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/data/nfc/"</span></span></span><span class="hljs-meta">; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> const char alternative_config_path[] = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> CNxpNfcConfig&amp; CNxpNfcConfig::GetInstance() { .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (alternative_config_path[0] != </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'\0'</span></span></span><span class="hljs-meta">) { .... }</span></span></code> </pre> <br> 分析器在此处生成警告：V547 CWE-570表达式'alternative_config_path [0]！='\ 0''始终为false。  phNxpConfig.cpp 401 <br><br> 事实是未定义<i>GENERIC_TARGET</i>宏，并且从分析器的角度来看，代码如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> alternative_config_path[] = <span class="hljs-string"><span class="hljs-string">""</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (alternative_config_path[<span class="hljs-number"><span class="hljs-number">0</span></span>] != <span class="hljs-string"><span class="hljs-string">'\0'</span></span>) {</code> </pre> <br> 由于该行为空，并且端子零始终位于零偏移处，因此分析仪只需发出警告。 因此，分析仪在发出警告时是正确的。 但是，从实际的角度来看，此警告没有任何好处。 <br><br> 不幸的是，在这种情况下什么也做不了。 我们将必须系统地审查所有此类警告，并将许多地方标记为误报，以使分析仪不再在这些行上发出消息。 确实需要这样做，因为除了无意义的消息外，还会发现很多实际的缺陷。 <br><br> 我坦诚地承认，我对仔细查看这种类型的警告不感兴趣，因此我对这些警告进行了简要介绍。 但是，即使这样也足以表明此类诊断非常有用并找到有趣的错误。 <br><br> 我想从经典情况开始，即比较两个对象的功能未正确实现。 为什么要经典？ 这是我们在各种项目中经常遇到的典型错误模式。 最可能的原因有以下三个： <br><br><ol><li> 比较功能很简单，并使用“复制粘贴”技术“自动”编写。 当编写这样的代码时，一个人会不专心，经常打错字。 </li><li> 通常，对于此类功能不执行代码审查，因为它太懒了，无法查看简单而乏味的功能。 </li><li> 通常不对此类功能进行单元测试。 因为懒惰。 另外，这些函数很简单，并且程序员认为它们中可能没有错误。 </li></ol><br> 这些想法和示例在“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">邪恶生活在比较功能中</a> ”一文中有更详细的描述。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAudioPlaybackRateEqual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AudioPlaybackRate &amp;pr1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AudioPlaybackRate &amp;pr2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">fabs</span></span>(pr1.mSpeed - pr2.mSpeed) &lt; AUDIO_TIMESTRETCH_SPEED_MIN_DELTA &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">fabs</span></span>(pr1.mPitch - pr2.mPitch) &lt; AUDIO_TIMESTRETCH_PITCH_MIN_DELTA &amp;&amp; pr2.mStretchMode == pr2.mStretchMode &amp;&amp; pr2.mFallbackMode == pr2.mFallbackMode; }</code> </pre> <br> 因此，这是比较两个<i>AudioPlaybackRate</i>类型的对象的经典函数。 而且，正如我认为的那样，读者猜测这是错误的。  PVS-Studio分析仪会立即注意到两种错别字： <br><br><ul><li>  V501 CWE-571“ ==”运算符的左侧和右侧有相同的子表达式：pr2.mStretchMode == pr2.mStretchMode AudioResamplerPublic.h 107 </li><li>  V501 CWE-571“ ==”运算符的左侧和右侧有相同的子表达式：pr2.mFallbackMode == pr2.mFallbackMode AudioResamplerPublic.h 108 </li></ul><br> 将<i>pr2.mStretchMode</i>字段和<i>pr2.mFallbackMode</i>字段<i>进行</i>比较。 事实证明，该功能不能足够准确地比较对象。 <br><br> 以下无意义的比较存在于将指纹信息存储在文件中的函数中。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveFingerprint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">worker_thread_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* listener, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idx)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ns = fwrite(&amp;listener-&gt;secureid[idx], <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, fp); .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nf = fwrite(&amp;listener-&gt;fingerid[idx], <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, fp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ns != <span class="hljs-number"><span class="hljs-number">1</span></span> || ns !=<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;= ALOGW("Corrupt emulator fingerprints storage; " "could not save fingerprints"); fclose(fp); return; }</span></span></code> </pre> <br> 一次通过两个诊断程序在此代码中检测到异常： <br><br><ul><li>  V501 CWE-570'||'的左侧和右侧有相同的子表达式 运算符：ns！= 1 ||  ns！= 1个指纹.c 126 </li><li>  V560 CWE-570条件表达式的一部分始终为false：ns！= 1. Fingerprint.c 126 </li></ul><br> 当第二次调用<i>fwrite</i>函数无法将数据写入文件时，将无法处理这种情况。 换句话说，不检查变量<i>nf</i>的值。 正确的检查应如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ns != <span class="hljs-number"><span class="hljs-number">1</span></span> || nf != <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br> 我们继续处理与<i>＆</i>运算符相关的下一个错误。 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> O_RDONLY 00000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> O_WRONLY 00000001 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> O_RDWR 00000002 static ssize_t verity_read(fec_handle *f, ....) { .... </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* if we are in read-only mode and expect to read a zero block, skip reading and just return zeros */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (f-&gt;mode &amp; O_RDONLY &amp;&amp; expect_zeros) { memset(data, 0, FEC_BLOCKSIZE); goto valid; } .... }</span></span></code> </pre> <br>  PVS-Studio警告：V560 CWE-570条件表达式的一部分始终为false：f-&gt; mode＆00000000。fec_read.cpp 322 <br><br> 注意常数<i>O_RDONLY</i>为零。 这使表达式<i>f-&gt; mode＆O_RDONLY</i>毫无意义，因为它始终为0。事实证明， <i>if语句</i>的条件从不满足，而statement-true是无效代码。 <br><br> 正确的检查应如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f-&gt;mode == O_RDONLY &amp;&amp; expect_zeros) {</code> </pre> <br> 现在让我们看一下当我们忘记写条件的一部分时的经典错字。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { .... CHANGE_DISPLAY_INFO = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>, .... }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RotaryEncoderInputMapper::configure(<span class="hljs-keyword"><span class="hljs-keyword">nsecs_t</span></span> when, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InputReaderConfiguration* config, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> changes) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!changes || (InputReaderConfiguration::CHANGE_DISPLAY_INFO)) { .... }</code> </pre> <br>  PVS-Studio警告：V768 CWE-571枚举常量'CHANGE_DISPLAY_INFO'用作布尔型变量。  InputReader.cpp 3016 <br><br> 该条件始终为true，因为操作数<i>InputReaderConfiguration :: CHANGE_DISPLAY_INFO</i>是等于4的常数。 <br><br> 如果您查看附近的代码编写方式，那么很明显，实际上条件应该是这样的： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!changes || (changes &amp; InputReaderConfiguration::CHANGE_DISPLAY_INFO)) {</code> </pre> <br> 下面的比较是没有意义的，我在循环运算符中遇到了。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_printerAttributes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">ipp_t</span></span> *collection = ippGetCollection(attrptr, i); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = <span class="hljs-number"><span class="hljs-number">0</span></span>, attrptr = ippFirstAttribute(collection); (j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) &amp;&amp; (attrptr != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); attrptr = ippNextAttribute(collection)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(<span class="hljs-string"><span class="hljs-string">"...."</span></span>, ippGetName(attrptr)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ....TopMargin = ippGetInteger(attrptr, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(<span class="hljs-string"><span class="hljs-string">"...."</span></span>, ippGetName(attrptr)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ....BottomMargin = ippGetInteger(attrptr, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(<span class="hljs-string"><span class="hljs-string">"...."</span></span>, ippGetName(attrptr)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ....LeftMargin = ippGetInteger(attrptr, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(<span class="hljs-string"><span class="hljs-string">"...."</span></span>, ippGetName(attrptr)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ....RightMargin = ippGetInteger(attrptr, <span class="hljs-number"><span class="hljs-number">0</span></span>); } } .... }</code> </pre> <br>  PVS-Studio警告：V560 CWE-571条件表达式的一部分始终为true：（j &lt;4）。  ipphelper.c 926 <br><br> 请注意，变量<i>j的值</i>不会在任何地方递增。 这意味着子表达式<i>（j &lt;4）</i>始终为true。 <br><br> 涉及真/假条件的PVS-Studio分析仪最大数量的有用操作，是指使用<i>new</i>运算符检查对象创建结果的代码。 换句话说，分析器检测以下代码模式： <br><br><pre> <code class="cpp hljs">T *p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR;</code> </pre> <br> 这样的检查是没有意义的。 如果无法为该对象分配内存，则会抛出<i>std :: bad_alloc</i>类型的<i>异常，</i>并且该<i>异常</i>将无法检查指针值。 <br><br> 注意事项  <i>new</i>运算符可以<i>通过</i>写入<i>new（std :: nothrow）T</i>来返回<i>nullptr</i> <i>。</i> 但是，这不适用于所讨论的错误。 如果以这种方式创建对象，PVS-Studio分析仪会考虑<i>（std :: nothrow）</i> ，并且不会给出警告。 <br><br> 此类错误似乎无害。 好吧，想想看，一项额外的检查永远都行不通。 无论如何，将引发异常，该异常将在某处进行处理。 不幸的是，一些开发人员将<i>if语句</i>操作释放为true，以释放资源等。 由于此代码未执行，因此可能导致内存泄漏和其他错误。 <br><br> 考虑一下我在Android代码中注意到的这些情况之一。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_apk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *target_package_name)</span></span></span><span class="hljs-function"> </span></span>{ .... FileMap *dataMap = zip-&gt;createEntryFileMap(entry); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataMap == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { ALOGW(<span class="hljs-string"><span class="hljs-string">"%s: failed to create FileMap\n"</span></span>, __FUNCTION__); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[uncompLen]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> == buf) { ALOGW(<span class="hljs-string"><span class="hljs-string">"%s: failed to allocate %"</span></span> PRIu32 <span class="hljs-string"><span class="hljs-string">" byte\n"</span></span>, __FUNCTION__, uncompLen); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> dataMap; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } .... }</code> </pre> <br>  PVS-Studio警告：V668 CWE-570测试“ buf”指针是否为空没有意义，因为使用“ new”运算符分配了内存。 如果内存分配错误，将生成异常。 第213章 <br><br> 请注意，如果不可能分配第二个内存块，程序员将尝试释放第一个内存块： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> dataMap;</code> </pre> <br> 此代码将永远无法控制。 这是无效代码。 如果发生异常，则会发生内存泄漏。 <br><br> 编写这样的代码从根本上是错误的。 在这种情况下发明了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">智能指针</a> 。 <br><br> 在使用<i>new</i>创建对象之后，PVS-Studio分析器总共在Android代码中检测到<b>176</b>个指针检查位置。 我不了解这些地方的危险性，当然，我不会在所有这些警告中弄乱文章。 有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">兴趣的人</a>可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Android_V668.txt</a>文件中看到其他警告。 <br><br><h2> 解引用空指针 </h2><br> 取消引用空指针会导致程序行为未定义，因此查找并修复此类位置非常有用。 根据情况，PVS-Studio分析仪可以根据常见弱点枚举对这些错误进行分类，如下所示： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CWE-119</a> ：对内存缓冲区范围内操作的不当限制 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CWE-476</a> ：空指针取消引用 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CWE-628</a> ：带有错误指定参数的函数调用 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CWE-690</a> ：未检查的返回值到NULL指针取消引用 </li></ul><br> 我经常在负责处理非标准或不正确情况的代码中发现此类错误。 没有人会测试这样的代码，并且该错误会持续很长时间。 现在将考虑这种情况。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseEffect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xmlProxyLib == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { ALOGE(<span class="hljs-string"><span class="hljs-string">"effectProxy must contain a &lt;%s&gt;: %s"</span></span>, tag, dump(*xmlProxyLib)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } .... }</code> </pre> <br>  PVS-Studio警告：V522 CWE-476可能会取消引用空指针“ xmlProxyLib”。  EffectsConfig.cpp 205 <br><br> 如果<i>xmlProxyLib</i>指针为<i>nullptr</i> ，则程序员将显示一条调试消息，为此必须取消引用该指针。 糟糕... <br><br> 现在考虑该错误的更有趣的版本。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">soinfo_unload_impl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(soinfo* root)</span></span></span><span class="hljs-function"> </span></span>{ .... soinfo* needed = find_library(si-&gt;get_primary_namespace(), library_name, RTLD_NOLOAD, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (needed != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= PRINT("warning: couldn't find %s needed by %s on unload.", library_name, si-&gt;get_realpath()); return; } else if (local_unload_list.contains(needed)) { return; } else if (needed-&gt;is_linked() &amp;&amp; // &lt;= needed-&gt;get_local_group_root() != root) { external_unload_list.push_back(needed); } else { unload_list.push_front(needed); } .... }</span></span></code> </pre> <br>  PVS-Studio警告：V522 CWE-476可能会取消引用“需要”空指针。 链接器.cpp 1847 <br><br> 如果<i>需要</i>指针<i>！= Nullptr</i> ，则会发出警告，这是程序的非常可疑的行为。 最终可以很清楚地看到，如果您看下面的代码，则该代码将包含一个错误，当<i>需要== nullptr时</i> ，将在表达式<i>needed-&gt; is_linked（）中</i>取消引用空指针。 <br><br> 这里很可能会混淆运算符！=和==。 如果更换，则功能代码有意义，错误消失。 <br><br> 关于空指针可能被取消引用的大量警告都涉及以下形式的情况： <br><br><pre> <code class="cpp hljs">T *p = (T *) <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span> (N); *p = x;</code> </pre> <br> 如果无法分配内存，则诸如<i>malloc</i> ， <i>strdup</i>等函数可以返回<i>NULL</i> 。 因此，如果不先检查指针，就不能取消引用返回这些功能的指针。 <br><br> 有许多类似的错误，因此我只给出两个简单的代码片段：第一个包含 <br>  <i>malloc</i>和第二个与<i>strdup</i> 。 <br><br><pre> <code class="cpp hljs">DownmixerBufferProvider::DownmixerBufferProvider(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">effect_param_t</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> param = (<span class="hljs-keyword"><span class="hljs-keyword">effect_param_t</span></span> *) <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(downmixParamSize); param-&gt;psize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">downmix_params_t</span></span>); .... }</code> </pre> <br>  PVS-Studio警告：V522 CWE-690可能会取消引用潜在的空指针“参数”。 检查行：245、244。BufferProviders.cpp 245 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">descriptorClassToDot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* str)</span></span></span><span class="hljs-function"> </span></span>{ .... newStr = strdup(lastSlash); newStr[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(lastSlash)<span class="hljs-number"><span class="hljs-number">-1</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; .... }</code> </pre> <br>  PVS-Studio警告：V522 CWE-690可能会取消引用潜在的空指针'newStr'。 检查行：203、202。DexDump.cpp 203 <br><br> 可能有人会说这些是小错误。 如果没有足够的内存，则在取消引用空指针时程序将简单崩溃，这是正常的。 由于没有内存，因此无需尝试以某种方式处理这种情况。 <br><br> 这样的人是错的。 指针必须检查！ 我在“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为什么检查malloc函数返回什么很重要</a> ”一文中详细研究了此主题。 我强烈建议您将其阅读给所有未读过的人。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/923/793/0c5/9237930c52039f4f7e0542bee775ce72.png" alt="分配"></div><br><br> 简而言之，危险是不一定要在零地址附近进行对存储器的写操作。 可能会将数据写到不受写保护的内存页中很远的某个地方，从而导致难以捉摸的错误，或者通常将此错误用作漏洞。 让我们看看<i>check_size</i>函数示例的<i>含义</i> 。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check_size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">radio_metadata_buffer_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **metadata_ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size_int)</span></span></span><span class="hljs-function"> </span></span>{ .... metadata = <span class="hljs-built_in"><span class="hljs-built_in">realloc</span></span>(metadata, new_size_int * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)); memmove( (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *)metadata + new_size_int - (metadata-&gt;count + <span class="hljs-number"><span class="hljs-number">1</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *)metadata + metadata-&gt;size_int - (metadata-&gt;count + <span class="hljs-number"><span class="hljs-number">1</span></span>), (metadata-&gt;count + <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)); .... }</code> </pre> <br>  PVS-Studio警告：V769 CWE-119“（uint32_t *）元数据+ new_size_int”表达式中的“（uint32_t *）元数据”指针可能为nullptr。 在这种情况下，结果值将毫无意义，因此不应使用。 检查行：91，89。radio_metadata.c 91 <br><br> 我不了解该功能的逻辑，但这不是必需的。 最主要的是创建了一个新的缓冲区，并将数据复制到那里。 如果<i>realloc</i>函数返回<i>NULL</i> ，则数据将被复制到地址（（uint32_t *）NULL +元数据-&gt; size_int-（元数据-&gt;计数+1））。 <br><br> 如果<i>metadata-&gt; size_int值</i>很大，那么后果将令人遗憾。 事实证明，数据被写入到随机存储器中。 <br><br> 顺便说一句，还有另一种空指针取消引用，PVS-Studio分析器将其归类为CWE-628（无效参数）不是CWE-690。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_tcp_ports</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *portstring, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ports)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buffer; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *cp; buffer = strdup(portstring); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((cp = <span class="hljs-built_in"><span class="hljs-built_in">strchr</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">':'</span></span>)) == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) .... }</code> </pre> <br>  PVS-Studio警告：V575 CWE-628潜在的空指针传递到'strchr'函数中。 检查第一个参数。 检查行：47，46。libxt_tcp.c 47 <br><br> 事实是， <i>调用strchr</i>函数时将发生指针取消引用。 因此，分析器将这种情况解释为将错误的值传递给函数。 <br><br> 我在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Android_V522_V575.txt</a>文件中列出了其余<b>194</b>条此类警告。 <br><br> 顺便说一下，前面讨论过的关于在调用<i>new</i>运算符之后检查指针的警告给出了所有这些错误的特殊提示。 事实证明，当不检查指针时，有195个对<i>malloc</i> / <i>realloc</i> / <i>strdup函数的调用，</i>依此类推。 但是在调用<i>new</i>之后有176个地方检查指针。 同意，这很奇怪！ <br><br> 最后，我们还要考虑警告V595和V1004，它们也与使用空指针相关联。 <br><br>  V595检测到指针被取消引用然后检查的情况。 综合示例： <br><br><pre> <code class="cpp hljs">p-&gt;foo(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!p) Error();</code> </pre> <br> 当首先检查指针，然后忘记这样做时，V1004会显示相反的情况。 综合示例： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p) p-&gt;foo(); p-&gt;doo();</code> </pre> <br> 让我们看看一些Android代码片段，其中有这种类型的错误。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 特别说明其功能不是必需的。 </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">PV_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RC_UpdateBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VideoEncData *video, Int currLayer, Int num_skip)</span></span></span><span class="hljs-function"> </span></span>{ rateControl *rc = video-&gt;rc[currLayer]; MultiPass *pMP = video-&gt;pMP[currLayer]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (video == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || rc == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || pMP == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PV_FAIL; .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V595 CWE-476在针对nullptr进行验证之前，已使用了“视频”指针。</font><font style="vertical-align: inherit;">检查行：385、388。rate_control.cpp 385</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resampler_reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct resampler_itfe *resampler)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resampler</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rsmp</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resampler</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resampler</span></span></span><span class="hljs-class">;</span></span> rsmp-&gt;frames_in = <span class="hljs-number"><span class="hljs-number">0</span></span>; rsmp-&gt;frames_rq = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rsmp != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> &amp;&amp; rsmp-&gt;speex_resampler != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { speex_resampler_reset_mem(rsmp-&gt;speex_resampler); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V595 CWE-476在针对nullptr进行验证之前，已使用了'rsmp'指针。</font><font style="vertical-align: inherit;">检查线：54，57. resampler.c 54</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bta_gattc_disc_cmpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tBTA_GATTC_CLCB* p_clcb, UNUSED_ATTR tBTA_GATTC_DATA* p_data)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p_clcb-&gt;status != GATT_SUCCESS) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p_clcb-&gt;p_srcb) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;tBTA_GATTC_SERVICE&gt;().swap( p_clcb-&gt;p_srcb-&gt;srvc_cache); } bta_gattc_cache_reset(p_clcb-&gt;p_srcb-&gt;server_bda); } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V1004 CWE-476在针对nullptr进行验证之后，不安全地使用了'p_clcb-&gt; p_srcb'指针。</font><font style="vertical-align: inherit;">检查行：695，701。bta_gattc_act.cc 701 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考虑这种类型的其他警告并不有趣。</font><font style="vertical-align: inherit;">其中包括由于不良或困难的代码编写而引起的错误和错误警告。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我写了许多有用的警告：</font></font><br><br><ul><li> V1004 CWE-476 The 'ain' pointer was used unsafely after it was verified against nullptr. Check lines: 101, 105. rsCpuIntrinsicBLAS.cpp 105 </li><li> V595 CWE-476 The 'outError' pointer was utilized before it was verified against nullptr. Check lines: 437, 450. Command.cpp 437 </li><li> V595 CWE-476 The 'out_last_reference' pointer was utilized before it was verified against nullptr. Check lines: 432, 436. AssetManager2.cpp 432 </li><li> V595 CWE-476 The 'set' pointer was utilized before it was verified against nullptr. Check lines: 4524, 4529. ResourceTypes.cpp 4524 </li><li> V595 CWE-476 The 'reply' pointer was utilized before it was verified against nullptr. Check lines: 126, 133. Binder.cpp 126 </li><li> V595 CWE-476 The 'video' pointer was utilized before it was verified against nullptr. Check lines: 532, 540. rate_control.cpp 532 </li><li> V595 CWE-476 The 'video' pointer was utilized before it was verified against nullptr. Check lines: 702, 711. rate_control.cpp 702 </li><li> V595 CWE-476 The 'pInfo' pointer was utilized before it was verified against nullptr. Check lines: 251, 254. ResolveInfo.cpp 251 </li><li> V595 CWE-476 The 'address' pointer was utilized before it was verified against nullptr. Check lines: 53, 55. DeviceHalHidl.cpp 53 </li><li> V595 CWE-476 The 'halAddress' pointer was utilized before it was verified against nullptr. Check lines: 55, 82. DeviceHalHidl.cpp 55 </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后我很无聊，并且过滤掉了此类警告。因此，我什至不知道分析仪检测到了多少实际错误。这些警告正在等待他们的英雄，他们将仔细研究它们并更改代码。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我只想提请新读者注意这种错误：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NJ_EXTERN NJ_INT16 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">njx_search_word</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NJ_CLASS *iwnn, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... NJ_PREVIOUS_SELECTION_INFO *prev_info = &amp;(iwnn-&gt;previous_selection); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iwnn == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NJ_SET_ERR_VAL(NJ_FUNC_NJ_SEARCH_WORD, NJ_ERR_PARAM_ENV_NULL); } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V595 CWE-476在针对nullptr进行验证之前，已使用了'iwnn'指针。</font><font style="vertical-align: inherit;">检查行：686，689。ndapi.c 686 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有些人认为这里没有错误，因为“没有真正的指针取消引用”。</font><font style="vertical-align: inherit;">不存在的变量的地址可以简单地计算出来。</font><font style="vertical-align: inherit;">此外，如果指针</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iwnn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为零，则函数将退出。</font><font style="vertical-align: inherit;">因此，没有发生什么不好的事情，我们先前错误地计算了类成员的地址。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不，你不能那样说话。</font><font style="vertical-align: inherit;">此代码导致未定义的行为，因此不能这样写。</font><font style="vertical-align: inherit;">未定义的行为可以表现出来，例如，如下所示：</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编译器看到指针已取消引用：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iwnn-&gt; previous_selection</font></font></i> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 您不能取消引用空指针，因为这是未定义的行为 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编译器得出的结论是，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iwnn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指针</font><font style="vertical-align: inherit;">始终为非零</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 编译器删除了多余的检查：if（iwnn == NULL） </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 就这样，现在在执行程序时，不执行对空指针的检查，并且工作从指向类成员的不正确指针开始 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我的文章“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取消引用空指针会导致未定义的行为</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”中</font><font style="vertical-align: inherit;">对此主题进行了详细描述</font><font style="vertical-align: inherit;">。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 私有数据不会在内存中删除 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考虑一种严重的潜在漏洞，该漏洞根据“常见漏洞枚举”分类为</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-14</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：清除缓冲区的编译器删除代码。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简而言之，这就是底线：</font><font style="vertical-align: inherit;">如果在此之后不再使用缓冲区，则</font><font style="vertical-align: inherit;">编译器有权删除</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数调用</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当我写这种类型的漏洞时，必然会出现这样的评论：这只是编译器中的一个小故障，需要修复。</font><font style="vertical-align: inherit;">不，这不是小故障。</font><font style="vertical-align: inherit;">在反对之前，请阅读以下材料：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">罗马·富米切夫（Roman Fomichev）。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安全清理私人数据</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常见弱点枚举。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-14</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li><li><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V597</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">诊断程序的说明</font><font style="vertical-align: inherit;">。</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总的来说，一切都是认真的。</font><font style="vertical-align: inherit;">Android中是否存在此类错误？</font></font>当然有<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它们通常有很多：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">证明</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :)。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们回到Android代码并考虑</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FwdLockGlue_InitializeRoundKeys</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数的开头和结尾</font><font style="vertical-align: inherit;">，因为中间的内容对我们而言并不有趣。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FwdLockGlue_InitializeRoundKeys</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> keyEncryptionKey[KEY_SIZE]; .... <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(keyEncryptionKey, <span class="hljs-number"><span class="hljs-number">0</span></span>, KEY_SIZE); <span class="hljs-comment"><span class="hljs-comment">// Zero out key data. }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V597 CWE-14编译器可以删除“内存集”函数调用，该函数调用用于刷新“ keyEncryptionKey”缓冲区。 memset_s（）函数应用于擦除私有数据。 FwdLockGlue.c 102 </font><i><font style="vertical-align: inherit;">keyEncryptionKey</font></i></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组</font><font style="vertical-align: inherit;">在堆栈上创建，并存储私有信息。在函数的最后，他们想用零填充该数组，以免它意外地到达不应到达的位置。文章“ </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">覆盖内存-为什么？</font></a><font style="vertical-align: inherit;"> ” </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">将</font></a><font style="vertical-align: inherit;">告诉您信息如何到达不应到达的位置</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">要使用零填充私有信息来填充数组，请使用</font><i><font style="vertical-align: inherit;">memset</font></i><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">。评论“归零关键数据”确认我们正确理解了所有内容。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题在于，编译器在构建发行版本时很有可能会删除</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数调用</font><font style="vertical-align: inherit;">。由于</font><font style="vertical-align: inherit;">未使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调用之后的缓冲区</font><font style="vertical-align: inherit;">，因此</font><font style="vertical-align: inherit;">从编译器的角度来看，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数本身的调用</font><font style="vertical-align: inherit;">是多余的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更多</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10个</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">警告我写了一个文件</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android_V597.txt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还有一个错误是内存没有被覆盖，尽管在这种情况下</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">与此无关。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SHA1Transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> buffer[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">64</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> a, b, c, d, e; .... <span class="hljs-comment"><span class="hljs-comment">/* Wipe variables */</span></span> a = b = c = d = e = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V1001 CWE-563分配了'a'变量，但直到功能结束后才使用。</font><font style="vertical-align: inherit;">sha1.c 213 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio检测到与以下事实有关的异常：在将值分配给变量后，不再使用它们。</font><font style="vertical-align: inherit;">分析仪将此缺陷分类为</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-563</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：不使用变量分配。</font><font style="vertical-align: inherit;">而且，从形式上来说，他是对的，尽管事实上，我们在这里再次处理CWE-14。</font><font style="vertical-align: inherit;">编译器将丢弃这些分配，因为从C和C ++的角度来看，它们是多余的。</font><font style="vertical-align: inherit;">结果，堆栈将保留</font><font style="vertical-align: inherit;">存储私有数据</font><font style="vertical-align: inherit;">的变量</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的旧值</font><font style="vertical-align: inherit;">。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 未指定/实施定义的行为 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 当您不累时，让我们看一个复杂的案例，这需要我本人进行详尽的描述。 </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> GGLfixed; <span class="hljs-function"><span class="hljs-function">GGLfixed </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gglFastDivx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GGLfixed n, GGLfixed d)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((d&gt;&gt;<span class="hljs-number"><span class="hljs-number">24</span></span>) &amp;&amp; ((d&gt;&gt;<span class="hljs-number"><span class="hljs-number">24</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span>)) { n &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; d &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gglMulx(n, gglRecip(d)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V793奇怪的是'（d &gt;&gt; 24）+ 1'语句的结果是条件的一部分。</font><font style="vertical-align: inherit;">也许，该陈述应该与其他陈述进行比较。</font><font style="vertical-align: inherit;">fixed.cpp 75 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">程序员想要检查变量</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的8个高阶位是否</font><font style="vertical-align: inherit;">包含单位，但不是一次包含所有位。</font><font style="vertical-align: inherit;">换句话说，程序员希望验证高字节中除了0x00和0xFF之外的任何值。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他不必要地创造性地解决了这个问题。首先，他通过编写表达式（d &gt;&gt; 24）验证了最高有效位为非零。有此表达式的声明，但更有趣的是解析表达式的右侧：（（d &gt;&gt; 24）+1）。程序员将高8位移位到低字节。同时，它计算出最高有效符号位在所有其他位中重复。</font></font>即<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果变量d为0b11111111'00000000'00000000'00000000，则在移位后，我们将得到值0b11111111'11111111'11111111'11111111。将</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型的值0xFFFFFFFF加1 </font><font style="vertical-align: inherit;">，程序员计划获得0。即：-1 + 1 = 0。因此，他使用表达式（（d &gt;&gt; 24）+1）检查并非所有的高8位都等于1。我知道这是相当困难的，因此请不要着急并尝试找出工作原理和方法：)。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，让我们看看这段代码有什么问题。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移位时，最高有效符号位不一定“被抹上”。这是标准所说的：“ E1 &gt;&gt; E2的值是E1右移E2位的位置。如果E1具有无符号类型，或者E1具有带符号类型且非负值，则结果的值是E1 / 2 / E2的商的整数部分。如果E1具有带符号的类型和负值，则结果值是实现定义的。” </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最新报价对我们很重要。因此，我们遇到了实现定义的行为。此代码将如何工作取决于微处理器体系结构和编译器的实现。移位后，最高位可能很好地出现零，然后表达式（（d &gt;&gt; 24）+1）始终不同于0，即永远是真实的价值。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此得出结论：无需明智。</font><font style="vertical-align: inherit;">例如，如果您编写如下代码，则代码将变得更加可靠和易于理解：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">GGLfixed </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gglFastDivx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GGLfixed n, GGLfixed d)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> hibits = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;(d) &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hibits != <span class="hljs-number"><span class="hljs-number">0x00</span></span> &amp;&amp; hibits != <span class="hljs-number"><span class="hljs-number">0xFF</span></span>) { n &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; d &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gglMulx(n, gglRecip(d)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能我建议的方法不是理想的选择，但是在此代码中，实现没有定义任何行为，并且使读者更容易理解所检查的内容。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您应得一杯咖啡或茶。</font><font style="vertical-align: inherit;">分心并继续：我们正在等待一个有趣的未指定行为案例。</font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f53/1a9/86b/f531a986b1bca57105eddf63d12bd50b.png" alt="注意"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在面试时，作为向申请人提出的第一个问题，我问以下问题：“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数将打印什么</font><font style="vertical-align: inherit;">，为什么</font><font style="vertical-align: inherit;">打印</font><font style="vertical-align: inherit;">？”</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d,%d"</span></span>, i++, i++)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正确答案：这是未指定的行为。</font><font style="vertical-align: inherit;">没有定义调用函数时计算实际参数的过程。</font><font style="vertical-align: inherit;">有时，我什至演示了在Visual C ++的帮助下编译的这段代码在屏幕上显示“ 6.5”，这使知识和精神薄弱的新手完全迷惑了：）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这似乎是一个牵强的问题。</font><font style="vertical-align: inherit;">但是不可以，这种代码可以在严肃的应用程序中找到，例如，在Android代码中。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ComposerClient::CommandReader::parseSetLayerCursorPosition( <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> length) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (length != CommandWriterBase::kSetLayerCursorPositionLength) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> err = mHal.setLayerCursorPosition(mDisplay, mLayer, readSigned(), readSigned()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err != Error::NONE) { mWriter.setError(getCommandLoc(), err); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V681 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-758</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语言标准未定义在评估参数时将调用“ readSigned”功能的顺序。</font><font style="vertical-align: inherit;">ComposerClient.cpp 836 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们对以下代码行感兴趣：</font></font><br><br><pre> <code class="cpp hljs">mHal.setLayerCursorPosition(...., readSigned(), readSigned());</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过调用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">readSigned</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数，</font><font style="vertical-align: inherit;">将读取两个值。</font><font style="vertical-align: inherit;">但是无法预测将以什么顺序读取值。</font><font style="vertical-align: inherit;">这是未指定行为的典型案例。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使用静态代码分析器的好处 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整篇文章通常都会普及静态代码分析，尤其是我们的PVS-Studio工具。</font><font style="vertical-align: inherit;">但是，有些错误恰好证明了静态分析的可能性。</font><font style="vertical-align: inherit;">它们很难通过代码审查来识别，并且只有不疲倦的程序才能轻易注意到它们。</font><font style="vertical-align: inherit;">考虑几个这样的情况。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span>&gt; kBootReasonMap = { .... {<span class="hljs-string"><span class="hljs-string">"watchdog_sdi_apps_reset"</span></span>, <span class="hljs-number"><span class="hljs-number">106</span></span>}, {<span class="hljs-string"><span class="hljs-string">"smpl"</span></span>, <span class="hljs-number"><span class="hljs-number">107</span></span>}, {<span class="hljs-string"><span class="hljs-string">"oem_modem_failed_to_powerup"</span></span>, <span class="hljs-number"><span class="hljs-number">108</span></span>}, {<span class="hljs-string"><span class="hljs-string">"reboot_normal"</span></span>, <span class="hljs-number"><span class="hljs-number">109</span></span>}, {<span class="hljs-string"><span class="hljs-string">"oem_lpass_cfg"</span></span>, <span class="hljs-number"><span class="hljs-number">110</span></span>}, <span class="hljs-comment"><span class="hljs-comment">// &lt;= {"oem_xpu_ns_error", 111}, // &lt;= {"power_key_press", 112}, {"hardware_reset", 113}, {"reboot_by_powerkey", 114}, {"reboot_verity", 115}, {"oem_rpm_undef_error", 116}, {"oem_crash_on_the_lk", 117}, {"oem_rpm_reset", 118}, {"oem_lpass_cfg", 119}, // &lt;= {"oem_xpu_ns_error", 120}, // &lt;= {"factory_cable", 121}, {"oem_ar6320_failed_to_powerup", 122}, {"watchdog_rpm_bite", 123}, {"power_on_cable", 124}, {"reboot_unknown", 125}, .... };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PVS-Studio警告： </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V766 CWE-462已添加具有相同键“ oem_lpass_cfg”的项目。</font><font style="vertical-align: inherit;">bootstat.cpp 264</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V766 CWE-462已经添加了具有相同键“ oem_xpu_ns_error”的项目。</font><font style="vertical-align: inherit;">bootstat.cpp 265</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有相同键的不同值将插入已</font><font style="vertical-align: inherit;">排序的关联容器（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: map</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。在常见弱点枚举方面，这是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-462</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：关联列表中的重复密钥。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缩短了程序文本的位置，并用注释标记了错误，因此错误似乎很明显，但是当您用眼睛阅读此代码时，很难找到此类错误。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考虑另一段很难阅读的代码，因为它是相同的类型并且没有兴趣。</font></font><br><br><pre> <code class="cpp hljs">MtpResponseCode MyMtpDatabase::getDevicePropertyValue(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_INT8: packet.putInt8(longValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_UINT8: packet.putUInt8(longValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_INT16: packet.putInt16(longValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_UINT16: packet.putUInt16(longValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_INT32: packet.putInt32(longValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_UINT32: packet.putUInt32(longValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_INT64: packet.putInt64(longValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_UINT64: packet.putUInt64(longValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_INT128: packet.putInt128(longValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MTP_TYPE_UINT128: packet.putInt128(longValue); <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V525 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-682</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该代码包含相似块的集合。</font><font style="vertical-align: inherit;">在第620、623、626、629行中检查项目'putInt8'，'putUInt8'，'putInt16'，'putUInt16'，'putInt32'，'putUInt32'，'putInt64'，'putUInt64'，'putInt128'，'putInt128' ，632，635，638，641，644，647 620 android_mtp_MtpDatabase.cpp </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MTP_TYPE_UINT128</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须由功能引起</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">putUInt128</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，不</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">putInt128</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本节的最后一个是复制粘贴失败的一个很好的例子。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">btif_rc_upstreams_evt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> AVRC_PDU_REQUEST_CONTINUATION_RSP: { BTIF_TRACE_EVENT( <span class="hljs-string"><span class="hljs-string">"%s() REQUEST CONTINUATION: target_pdu: 0x%02d"</span></span>, __func__, pavrc_cmd-&gt;continu.target_pdu); tAVRC_RESPONSE avrc_rsp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p_dev-&gt;rc_connected == TRUE) { <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;(avrc_rsp.continu), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(tAVRC_NEXT_RSP)); avrc_rsp.continu.opcode = opcode_from_pdu(AVRC_PDU_REQUEST_CONTINUATION_RSP); avrc_rsp.continu.pdu = AVRC_PDU_REQUEST_CONTINUATION_RSP; avrc_rsp.continu.status = AVRC_STS_NO_ERROR; avrc_rsp.continu.target_pdu = pavrc_cmd-&gt;continu.target_pdu; send_metamsg_rsp(p_dev, <span class="hljs-number"><span class="hljs-number">-1</span></span>, label, ctype, &amp;avrc_rsp); } } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> AVRC_PDU_ABORT_CONTINUATION_RSP: { BTIF_TRACE_EVENT( <span class="hljs-string"><span class="hljs-string">"%s() ABORT CONTINUATION: target_pdu: 0x%02d"</span></span>, __func__, pavrc_cmd-&gt;<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>.target_pdu); tAVRC_RESPONSE avrc_rsp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p_dev-&gt;rc_connected == TRUE) { <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;(avrc_rsp.<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(tAVRC_NEXT_RSP)); avrc_rsp.<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>.opcode = opcode_from_pdu(AVRC_PDU_ABORT_CONTINUATION_RSP); avrc_rsp.<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>.pdu = AVRC_PDU_ABORT_CONTINUATION_RSP; avrc_rsp.<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>.status = AVRC_STS_NO_ERROR; avrc_rsp.<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>.target_pdu = pavrc_cmd-&gt;continu.target_pdu; send_metamsg_rsp(p_dev, <span class="hljs-number"><span class="hljs-number">-1</span></span>, label, ctype, &amp;avrc_rsp); } } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 建议您在阅读分析仪警告和更多内容之前，先查找错误。 </font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/83b/679/4ad/83b6794adb823b1fa52e18c91eff1ed2.png" alt="分散注意力的图片，Java"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了确保您不会意外地立即阅读答案，请使用以下图片来转移您的注意力。</font><font style="vertical-align: inherit;">如果您对带有铭文Java的鸡蛋的含义感兴趣，那么您</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来了</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，我希望您喜欢打字错误。</font><font style="vertical-align: inherit;">现在是时候向分析器发出警告了：V778 CW​​E-682发现了两个类似的代码片段。</font><font style="vertical-align: inherit;">也许这是一个错字，应该使用“ abort”变量而不是“ continu”。</font><font style="vertical-align: inherit;">btif_rc.cc 1554 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显然，该代码是使用Copy-Paste方法编写的，并且像往常一样，一个人在编辑复制的代码片段的过程中不能专心。</font><font style="vertical-align: inherit;">结果，最终，他没有将“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continue</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ” </font><font style="vertical-align: inherit;">替换</font><font style="vertical-align: inherit;">为“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abort</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”。</font></font><br><br> 即<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在第二块中应写成： </font></font><br><br><pre> <code class="cpp hljs">avrc_rsp.<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>.target_pdu = pavrc_cmd-&gt;<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>.target_pdu;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这种情况完全属于“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后一行效果</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ” </font><font style="vertical-align: inherit;">的定义</font><font style="vertical-align: inherit;">，因为在结尾处错误地替换了名称。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Facepalm </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个非常有趣的错误与Little-endian和Big-endian数据格式之间的转换有关（请参阅</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byte order</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bswap32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (((pData &amp; <span class="hljs-number"><span class="hljs-number">0xFF000000</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>) | ((pData &amp; <span class="hljs-number"><span class="hljs-number">0x00FF0000</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | ((pData &amp; <span class="hljs-number"><span class="hljs-number">0x0000FF00</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | ((pData &amp; <span class="hljs-number"><span class="hljs-number">0x000000FF</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">24</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ELFAttribute::merge(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> subsection_length = *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*&gt;(subsection_data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (llvm::sys::IsLittleEndianHost != m_Config.targets().isLittleEndian()) bswap32(subsection_length); .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V530 CWE-252需要使用功能“ bswap32”的返回值。</font><font style="vertical-align: inherit;">ELFAttribute.cpp 84 </font><i><font style="vertical-align: inherit;">没有关于bswap32</font></i></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数的</font><font style="vertical-align: inherit;">投诉。</font><font style="vertical-align: inherit;">但是使用不正确：</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs">bswap32(subsection_length);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作者建议将变量通过引用传递给函数，然后在此处进行更改。</font><font style="vertical-align: inherit;">但是，必须使用该函数返回的值。</font><font style="vertical-align: inherit;">结果，不发生数据转换。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分析仪将此错误识别为</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-252</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：未检查的返回值。</font><font style="vertical-align: inherit;">但是，实际上，在这里调用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-198</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更合适</font><font style="vertical-align: inherit;">：使用不正确的字节顺序。</font><font style="vertical-align: inherit;">不幸的是，分析器无法从高层次的角度理解错误是什么。</font><font style="vertical-align: inherit;">但是，这不会阻止他识别代码中的这一严重缺陷。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正确的代码是：</font></font><br><br><pre> <code class="cpp hljs">subsection_length = bswap32(subsection_length);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Android代码中还有另外三个错误相同的地方： </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V530 CWE-252需要使用功能“ bswap32”的返回值。</font><font style="vertical-align: inherit;">ELFAttribute.cpp 218</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V530 CWE-252需要使用功能“ bswap32”的返回值。</font><font style="vertical-align: inherit;">ELFAttribute.cpp 346</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V530 CWE-252需要使用功能“ bswap32”的返回值。</font><font style="vertical-align: inherit;">ELFAttribute.cpp 352</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为避免此类错误，建议使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[[nodiscard]]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">此属性用于指示调用函数时必须使用函数的返回值。</font><font style="vertical-align: inherit;">因此，如果您这样写：</font></font><br><br><pre> <code class="cpp hljs">[[nodiscard]] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bswap32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">那么即使在编译文件的阶段，也会检测到错误。</font><font style="vertical-align: inherit;">您可以从我同事的文章“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 17</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”中</font><font style="vertical-align: inherit;">了解更多关于一些新的有用属性的信息</font><font style="vertical-align: inherit;">。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 无法访问的代码 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在编程和编译器理论中，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无法到达的代码</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是程序代码的一部分，在任何情况下都无法执行，因为它在控制流程图中无法到达。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从常见弱点枚举的角度来看，它是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-561</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：死代码。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> sp&lt;IEffect&gt; createEffect(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pDesc == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> effect; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { *status = BAD_VALUE; } } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V779 CWE-561检测不到代码。</font><font style="vertical-align: inherit;">可能存在错误。</font><font style="vertical-align: inherit;">IAudioFlinger.cpp 733 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运营商</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的回报</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显然必须位于下方。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此类型的其他错误：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V779 CWE-561检测不到代码。</font><font style="vertical-align: inherit;">可能存在错误。</font><font style="vertical-align: inherit;">bta_hf_client_main.cc 612</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V779 CWE-561检测不到代码。</font><font style="vertical-align: inherit;">可能存在错误。</font><font style="vertical-align: inherit;">android_media_ImageReader.cpp 468</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V779 CWE-561检测不到代码。</font><font style="vertical-align: inherit;">可能存在错误。</font><font style="vertical-align: inherit;">AMPEG4AudioAssembler.cpp 187</font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 打破 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">忘记</font><font style="vertical-align: inherit;">在</font><i><font style="vertical-align: inherit;">开关</font></i><font style="vertical-align: inherit;">内部</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中断</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是C和C ++程序员的经典错误。</font><font style="vertical-align: inherit;">为了解决这个问题，C ++ 17中出现了一个有用的注释</font><i><font style="vertical-align: inherit;">[[fallthrough]]</font></i><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">您可以在我的文章“ </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">Break and fallthrough</font></a><font style="vertical-align: inherit;"> ”中</font><font style="vertical-align: inherit;">阅读</font><font style="vertical-align: inherit;">有关此错误和</font><i><font style="vertical-align: inherit;">[[fallthrough]]的</font></i><font style="vertical-align: inherit;">更多信息</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是，尽管世界充满了</font><font style="vertical-align: inherit;">不使用</font><i><font style="vertical-align: inherit;">[[fallthrough]]</font></i><font style="vertical-align: inherit;">的旧代码</font><font style="vertical-align: inherit;">，但是PVS-Studio对您有用。</font><font style="vertical-align: inherit;">考虑一下Android中发现的一些错误。</font><font style="vertical-align: inherit;">根据常见弱点枚举，这些错误被分类为</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">CWE-484</font></a><font style="vertical-align: inherit;">：交换机中的省略中断语句。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> A2dpCodecConfigLdac::setCodecConfig(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BTAV_A2DP_CODEC_SAMPLE_RATE_192000: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sampleRate &amp; A2DP_LDAC_SAMPLING_FREQ_192000) { result_config_cie.sampleRate = A2DP_LDAC_SAMPLING_FREQ_192000; codec_capability_.sample_rate = codec_user_config_.sample_rate; codec_config_.sample_rate = codec_user_config_.sample_rate; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BTAV_A2DP_CODEC_SAMPLE_RATE_16000: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BTAV_A2DP_CODEC_SAMPLE_RATE_24000: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BTAV_A2DP_CODEC_SAMPLE_RATE_NONE: codec_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE; codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V796 CWE-484 switch语句中可能缺少'break'语句。</font><font style="vertical-align: inherit;">a2dp_vendor_ldac.cc 912 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我认为该错误无需解释。</font><font style="vertical-align: inherit;">我仅注意到，经常会以多种方式检测到代码中的异常。</font><font style="vertical-align: inherit;">例如，V519警告也检测到此错误：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V519 CWE-563'codec_capability_.sample_rate'变量已连续两次分配值。</font><font style="vertical-align: inherit;">也许这是一个错误。</font><font style="vertical-align: inherit;">检查行：910、916。a2dp_vendor_ldac.cc 916</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V519 CWE-563'codec_config_.sample_rate'变量已连续两次分配值。</font><font style="vertical-align: inherit;">也许这是一个错误。</font><font style="vertical-align: inherit;">检查线：911、917。a2dp_vendor_ldac.cc 917</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 还有更多错误： </font></font><br><br><pre> <code class="cpp hljs">Return&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; EffectsFactory::getAllDescriptors(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (status) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> -ENOSYS: { <span class="hljs-comment"><span class="hljs-comment">// Effect list has changed. goto restart; } case -ENOENT: { // No more effects available. result.resize(i); } default: { result.resize(0); retval = Result::NOT_INITIALIZED; } } .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V796 CWE-484 switch语句中可能缺少'break'语句。</font><font style="vertical-align: inherit;">EffectsFactory.cpp 118</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reverb_getParameter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> REVERB_PARAM_REFLECTIONS_LEVEL: *(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> *)pValue = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> REVERB_PARAM_REFLECTIONS_DELAY: *(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *)pValue = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> REVERB_PARAM_REVERB_DELAY: *(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *)pValue = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V796 CWE-484 switch语句中可能缺少'break'语句。</font><font style="vertical-align: inherit;">EffectReverb.cpp 1847</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> SLresult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IAndroidConfiguration_GetConfiguration</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (IObjectToObjectID((thiz)-&gt;mThis)) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SL_OBJECTID_AUDIORECORDER: result = android_audioRecorder_getConfig( (CAudioRecorder *) thiz-&gt;mThis, configKey, pValueSize, pConfigValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SL_OBJECTID_AUDIOPLAYER: result = android_audioPlayer_getConfig( (CAudioPlayer *) thiz-&gt;mThis, configKey, pValueSize, pConfigValue); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: result = SL_RESULT_FEATURE_UNSUPPORTED; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V796 CWE-484 switch语句中可能缺少'break'语句。</font><font style="vertical-align: inherit;">IAndroidConfiguration.cpp 90</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 错误的内存管理 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里，我编译了与不正确的内存管理有关的错误。</font><font style="vertical-align: inherit;">根据常见弱点枚举，此类警告分类为：</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-401</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：在删除最后一个引用之前内存释放不当（“内存泄漏”）</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-562</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：堆栈变量地址的返回</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-762</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：不匹配的内存管理例程</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 让我们从返回对已销毁变量的引用的函数开始。 </font></font><br><br><pre> <code class="cpp hljs">TransformIterator&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { <span class="hljs-function"><span class="hljs-function">TransformIterator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; ++*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; } TransformIterator&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>--(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { <span class="hljs-function"><span class="hljs-function">TransformIterator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; --*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PVS-Studio警告： </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V558 CWE-562函数将对临时本地对象tmp的引用返回。</font><font style="vertical-align: inherit;">transform_iterator.h 77</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V558 CWE-562函数将对临时本地对象tmp的引用返回。</font><font style="vertical-align: inherit;">transform_iterator.h 92</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当函数完成执行时，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tmp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量将被</font><font style="vertical-align: inherit;">销毁，因为它是在堆栈上创建的。</font><font style="vertical-align: inherit;">因此，函数返回对已销毁（不存在）对象的引用。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正确的解决方案是返回值：</font></font><br><br><pre> <code class="cpp hljs">TransformIterator <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { <span class="hljs-function"><span class="hljs-function">TransformIterator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; ++*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; } TransformIterator <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>--(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { <span class="hljs-function"><span class="hljs-function">TransformIterator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; --*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tmp; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 考虑更多值得密切关注的可悲代码。 </font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/619/b25/299/619b2529917e9570454e60bf9c27c3f8.png" alt="危险代码"></div><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">register_socket_transport</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* serial, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> port, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> local)</span></span></span><span class="hljs-function"> </span></span>{ atransport* t = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> atransport(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!serial) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf), <span class="hljs-string"><span class="hljs-string">"T-%p"</span></span>, t); serial = buf; } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V507 CWE-562指向本地数组'buf'的指针存储在该数组的范围之外。这样的指针将变为无效。 transport.cpp 1030 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是危险的代码。如果</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">串行</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数的实际值为</font><font style="vertical-align: inherit;">NULL，则应使用堆栈上的临时缓冲区。当</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if语句</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的主体</font><font style="vertical-align: inherit;">结束时，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buf</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组</font><font style="vertical-align: inherit;">将不复存在。创建缓冲区的位置可用于存储在堆栈上创建的其他变量。数据将开始出现混乱的混乱，并且这种错误的后果很难预测。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下错误与创建和销毁对象的不兼容方法有关。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SensorService::SensorEventConnection::reAllocateCacheLocked(....) { <span class="hljs-keyword"><span class="hljs-keyword">sensors_event_t</span></span> *eventCache_new; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> new_cache_size = computeMaxCacheSizeLocked(); eventCache_new = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sensors_event_t</span></span>[new_cache_size]; .... <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> mEventCache; mEventCache = eventCache_new; mCacheSize += count; mMaxCacheSize = new_cache_size; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V611 CWE-762使用“ new T []”运算符分配了内存，但使用“ delete”运算符释放了内存。考虑检查此代码。最好使用“ delete [] mEventCache;”。检查行：391，384。SensorEventConnection.cpp 391 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里的一切都很简单。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mEventCache</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类的成员指向的缓冲区</font><font style="vertical-align: inherit;">是使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new []</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运算符分配的</font><font style="vertical-align: inherit;">。并使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delete</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运算符释放此内存</font><font style="vertical-align: inherit;">。这是不正确的，并导致未定义的程序行为。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类似错误：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">aaudio_result_t</span></span> AAudioServiceEndpointCapture::open(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> mDistributionBuffer; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distributionBufferSizeBytes = getStreamInternal()-&gt;getFramesPerBurst() * getStreamInternal()-&gt;getBytesPerFrame(); mDistributionBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>[distributionBufferSizeBytes]; .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V611 CWE-762使用“ new T []”运算符分配了内存，但使用“ delete”运算符释放了内存。</font><font style="vertical-align: inherit;">考虑检查此代码。</font><font style="vertical-align: inherit;">最好使用“ delete [] mDistributionBuffer;”。</font><font style="vertical-align: inherit;">AAudioServiceEndpointCapture.cpp 50 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我认为该错误无需解释。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下情况更有趣，但错误的本质完全相同。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HeifFrameInfo</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... mIccData.reset(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>[iccSize]); .... } .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>&gt; mIccData; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V554 CWE-762错误使用unique_ptr。 </font></font>分配给'new []'的内存将使用'delete'清除。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HeifDecoderAPI.h 62 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">默认情况下，智能指针</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类std :: unique_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delete</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运算符销毁一个对象</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是，在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">set</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数中，</font><font style="vertical-align: inherit;">使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new []</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运算符分配内存</font><font style="vertical-align: inherit;">。</font></font><br><br> 正确的选项： <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>[]&gt; mIccData;</code> </pre> <br> 其他错误： <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V554 CWE-762错误使用unique_ptr。 </font></font>分配给'new []'的内存将使用'delete'清除。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第949章 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V554 CWE-762错误使用unique_ptr。 </font></font>分配给'new []'的内存将使用'delete'清除。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atrace.cpp 950 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V554 CWE-762错误使用unique_ptr。 </font></font>分配给'new []'的内存将使用'delete'清除。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HeifDecoderImpl.cpp 102 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V554 CWE-762错误使用unique_ptr。 </font></font>分配给'new []'的内存将使用'delete'清除。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Heif解码器Impl.cpp 166 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V554 CWE-762错误使用unique_ptr。 </font></font>分配给'new []'的内存将使用'delete'清除。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ColorSpace.cpp 360 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内存泄漏错误将完成本节。</font><font style="vertical-align: inherit;">令人不愉快的是，有20多个这样的错误，在我看来，这些错误可能是非常痛苦的缺陷，导致在长时间连续运行操作系统期间，可用内存逐渐减少。</font></font><br><br><pre> <code class="cpp hljs">Asset* Asset::createFromUncompressedMap(FileMap* dataMap, AccessMode mode) { _FileAsset* pAsset; <span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> result; pAsset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> _FileAsset; result = pAsset-&gt;openChunk(dataMap); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result != NO_ERROR) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; pAsset-&gt;mAccessMode = mode; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pAsset; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PVS-Studio警告：V773 CWE-401在不释放“ pAsset”指针的情况下退出了该功能。 </font></font>可能发生内存泄漏。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asset.cpp 296 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果无法打开某个块，则函数将退出而不破坏对象，指向该对象的指针存储在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pAsset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量中</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">结果，将发生内存泄漏。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他错误类似，因此我认为没有理由在文章中考虑它们。</font><font style="vertical-align: inherit;">有</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">兴趣的人</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以在文件</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">Android_V773.txt中</font></a><font style="vertical-align: inherit;">查看其他警告</font><font style="vertical-align: inherit;">。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 出国数组 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有很多错误的模式会导致数组溢出。</font><font style="vertical-align: inherit;">对于Android，我仅检测到以下类型的一种错误模式：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || i &gt; MAX) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; A[i] = x;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在C和C ++中，数组单元格从0开始编号，因此数组中元素的最大索引必须比数组本身的大小小1。</font><font style="vertical-align: inherit;">正确的检查应如下所示：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || i &gt;= MAX) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; A[i] = x;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据常见弱点枚举，</font><font style="vertical-align: inherit;">溢出</font><font style="vertical-align: inherit;">数组的类别为</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-119</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：内存缓冲区范围内的操作限制不当。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">看看这些错误在Android代码中的样子。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">btif_hf_cb_t</span></span> btif_hf_cb[BTA_AG_MAX_NUM_CLIENTS]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSlcConnected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RawAddress* bd_addr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!bd_addr) { LOG(WARNING) &lt;&lt; __func__ &lt;&lt; <span class="hljs-string"><span class="hljs-string">": bd_addr is null"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx = btif_hf_idx_by_bdaddr(bd_addr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idx &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || idx &gt; BTA_AG_MAX_NUM_CLIENTS) { LOG(WARNING) &lt;&lt; __func__ &lt;&lt; <span class="hljs-string"><span class="hljs-string">": invalid index "</span></span> &lt;&lt; idx &lt;&lt; <span class="hljs-string"><span class="hljs-string">" for "</span></span> &lt;&lt; *bd_addr; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> btif_hf_cb[idx].state == BTHF_CONNECTION_STATE_SLC_CONNECTED; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V557 CWE-119阵列可能超限。</font><font style="vertical-align: inherit;">“ idx”索引的值可能达到6。btif_hf.cc 277 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正确的检查选项：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idx &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || idx &gt;= BTA_AG_MAX_NUM_CLIENTS) {</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 完全相同的错误又发现了两件事： </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V557 CWE-119阵列可能超限。</font><font style="vertical-align: inherit;">“ idx”索引的值可能达到6。btif_hf.cc 869</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V557 CWE-119阵列可能超限。</font><font style="vertical-align: inherit;">“索引”索引的值可能达到6。btif_rc.cc 374</font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 循环中断 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有许多方法可以编写故障循环。</font><font style="vertical-align: inherit;">在Android代码中，根据常见弱点枚举，我遇到了一些错误，这些错误可以归类为：</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-20</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：输入验证不正确</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-670</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：总是不正确的控制流实现</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-691</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：控制流管理不足</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-834</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：过度迭代</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 当然，与此同时，在编写循环时，还有其他方法可以“拍自己的脚”，但是这次却没有遇到我。 </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **argv)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%s is already in *.base_fs format, just ..... "</span></span>, ....); rewind(blk_alloc_file); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((c = fgetc(blk_alloc_file)) != EOF) { fputc(c, base_fs_file); } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V739 CWE-20 EOF不应与“ char”类型的值进行比较。 '（c = fgetc（blk_alloc_file））'应该是'int'类型的。 blk_alloc_to_base_fs.c 61 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分析器检测到</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EOF</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常量</font><font style="vertical-align: inherit;">与</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">char</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型的变量进行比较</font><font style="vertical-align: inherit;">。让我们看看为什么此代码不正确。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i><font style="vertical-align: inherit;">fgetc</font></i></a></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">返回一个</font><i><font style="vertical-align: inherit;">int</font></i><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">，即：它可以返回一个从0到255或EOF（-1）的数字。读取的值放在</font><i><font style="vertical-align: inherit;">char</font></i><font style="vertical-align: inherit;">类型的变量中</font><font style="vertical-align: inherit;">。因此，值为0xFF（255）的字符变为-1，并以与文件末尾（EOF）相同的方式进行解释。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i><font style="vertical-align: inherit;"></font></i></a><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于这些错误，使用扩展ASCII码的用户有时会遇到程序错误地处理其字母表中的一个字符的情况。例如，编码为Windows-1251的俄语字母的最后一个字母仅具有代码0xFF，并且在某些程序中被视为文件的末尾。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">综上所述，可以说停止循环的条件写得不正确。为了解决这种情况，变量</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须为</font><font style="vertical-align: inherit;">int类型。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们继续考虑使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语句时的更熟悉的错误</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> AudioPolicyManager::registerPolicyMixes(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mixes.size(); i++) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mHwModules.size(); j++) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= if (strcmp(AUDIO_HARDWARE_MODULE_ID_REMOTE_SUBMIX, mHwModules[j]-&gt;mName) == 0 &amp;&amp; mHwModules[j]-&gt;mHandle != 0) { rSubmixModule = mHwModules[j]; break; } .... } .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V534 CWE-691可能在“ for”运算符内比较了错误的变量。考虑查看“ i”。 AudioPolicyManager.cpp 2489 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于嵌套循环中有错字，该条件使用变量</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，尽管您必须使用变量</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。结果，变量</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不受控制地增加，随着时间的流逝，将导致</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mHwModules</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组</font><i><font style="vertical-align: inherit;">超出范围</font></i><font style="vertical-align: inherit;">。接下来将要发生的事情无法预测，因为会有不确定的程序行为。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顺便说一句，这个带有错误的片段已完全复制到另一个函数。因此，分析器在此处发现了完全相同的错误：AudioPolicyManager.cpp 2586。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还有3个对我来说非常可疑的代码段。</font><font style="vertical-align: inherit;">但是，我不能假定此代码肯定是错误的，因为那里存在复杂的逻辑。</font><font style="vertical-align: inherit;">无论如何，我必须注意此代码，以便作者对其进行检查。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一个片段：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ce_t3t_handle_check_cmd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; p_cb-&gt;cur_cmd.num_blocks; i++) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; T3T_MSG_NDEF_ATTR_INFO_SIZE; i++) { checksum += p_temp[i]; } .... } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V535 CWE-691变量“ i”正用于此循环和外部循环。</font><font style="vertical-align: inherit;">检查行：398，452。ce_t3t.cc 452 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请注意，变量</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于外部和内部循环。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另外两个类似的分析器触发器：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V535 CWE-691变量“ xx”用于该循环和外部循环。</font><font style="vertical-align: inherit;">检查行：801、807。sdp_db.cc 807</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V535 CWE-691变量“ xx”用于该循环和外部循环。</font><font style="vertical-align: inherit;">检查行：424、438。nfa_hci_act.cc 438</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">你还不累吗 </font><font style="vertical-align: inherit;">我建议暂停并</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载PVS-Studio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以尝试检查您的项目。</font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30b/8e3/d36/30b8e3d36a2b05111cee2b76d981d89f.png" alt="尝试PVS-Studio"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在让我们继续。 </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NFA_HCI_LAST_PROP_GATE 0xFF tNFA_HCI_DYN_GATE* nfa_hciu_alloc_gate(uint8_t gate_id, tNFA_HANDLE app_handle) { .... for (gate_id = NFA_HCI_FIRST_HOST_SPECIFIC_GENERIC_GATE; gate_id </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;= NFA_HCI_LAST_PROP_GATE; gate_id++) { if (gate_id == NFA_HCI_CONNECTIVITY_GATE) gate_id++; if (nfa_hciu_find_gate_by_gid(gate_id) == NULL) break; } if (gate_id &gt; NFA_HCI_LAST_PROP_GATE) { LOG(ERROR) &lt;&lt; StringPrintf( "nfa_hci_alloc_gate - no free Gate ID: %u " "App Handle: 0x%04x", gate_id, app_handle); return (NULL); } .... }</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V654 CWE-834循环的条件“ gate_id &lt;= 0xFF”始终为真。</font><font style="vertical-align: inherit;">nfa_hci_utils.cc 248 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请注意以下几点：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常量</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NFA_HCI_LAST_PROP_GATE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等于0xFF。</font></font></li><li><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型的变量用作</font><i><font style="vertical-align: inherit;">循环计数器</font></i><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，此变量的值范围是[0..0xFF]。</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事实证明，条件</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gate_id &lt;= NFA_HCI_LAST_PROP_GATE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">始终为true，并且无法停止循环的执行。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分析器将此错误分类为CWE-834，但也可以将其解释为CWE-571：表达式始终为True。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">循环中的下一个错误与未定义的行为有关。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> SimpleDecodingSource::doRead(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> retries = <span class="hljs-number"><span class="hljs-number">0</span></span>; ++retries; ) { .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V654 CWE-834循环的条件“ ++重试”始终为true。</font><font style="vertical-align: inherit;">SimpleDecodingSource.cpp 226 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显然，程序员希望</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retry</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量</font><font style="vertical-align: inherit;">采用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量的所有可能值，</font><font style="vertical-align: inherit;">然后循环才结束。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当表达式</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">++ retries</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为0 </font><font style="vertical-align: inherit;">时，循环应停止</font><font style="vertical-align: inherit;">。这仅在变量溢出时才有可能。</font><font style="vertical-align: inherit;">由于变量是带符号的类型，因此其溢出会导致未定义的行为。</font><font style="vertical-align: inherit;">因此，此代码不正确，并可能导致不可预测的后果。</font><font style="vertical-align: inherit;">例如，编译器拥有删除支票的全部权利，仅保留递增计数器的指令。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这是本节中的最后一个错误。 </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> Check(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; source) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pass = <span class="hljs-number"><span class="hljs-number">1</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(rc) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: SLOGI(<span class="hljs-string"><span class="hljs-string">"Filesystem check completed OK"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: SLOGE(<span class="hljs-string"><span class="hljs-string">"Filesystem check failed (not a FAT filesystem)"</span></span>); errno = ENODATA; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pass++ &lt;= <span class="hljs-number"><span class="hljs-number">3</span></span>) { SLOGW(<span class="hljs-string"><span class="hljs-string">"Filesystem modified - rechecking (pass %d)"</span></span>, pass); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= } SLOGE("Failing check after too many rechecks"); errno = EIO; return -1; case 8: SLOGE("Filesystem check failed (no filesystem)"); errno = ENODATA; return -1; default: SLOGE("Filesystem check failed (unknown exit code %d)", rc); errno = EIO; return -1; } } while (0); // &lt;= return 0; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V696 CWE-670因为条件始终为假，所以“继续”操作符将终止“（{FALSE）”时执行“ do {...}”循环。</font><font style="vertical-align: inherit;">检查行：105，121。Vfat.cpp 105 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在我们</font><font style="vertical-align: inherit;">面前的</font><font style="vertical-align: inherit;">是以下形式的循环：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; .... } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了执行重复的迭代，程序员使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continue</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语句</font><font style="vertical-align: inherit;">。</font></font>错了<font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continue</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语句</font><font style="vertical-align: inherit;">不会立即恢复循环，而是继续检查条件。</font><font style="vertical-align: inherit;">由于条件始终为假，因此在任何情况下循环仅执行一次。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要解决该错误，可以重写代码，例如：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 可变重新分配 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个非常</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常见的错误</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是在使用前一个值之前重写变量。</font><font style="vertical-align: inherit;">大多数情况下，此类错误是由于输入错误或复制粘贴不成功而发生的。</font><font style="vertical-align: inherit;">根据常见弱点枚举，此类错误分类为</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-563</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：不使用变量的分配。</font><font style="vertical-align: inherit;">在Android中并非没有这样的错误。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> XMLNode::flatten_node(....) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;namespaceExt, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(namespaceExt)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mNamespacePrefix.size() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { namespaceExt.prefix.index = htodl(strings.offsetForString(mNamespacePrefix)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { namespaceExt.prefix.index = htodl((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span>); } namespaceExt.prefix.index = htodl(strings.offsetForString(mNamespacePrefix)); namespaceExt.uri.index = htodl(strings.offsetForString(mNamespaceUri)); .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V519 CWE-563'namespaceExt.prefix.index'变量已连续两次分配值。</font><font style="vertical-align: inherit;">也许这是一个错误。</font><font style="vertical-align: inherit;">检查行：1535、1539。XMLNode.cpp 1539 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了突出显示错误的实质，我将编写一个伪代码：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) X = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> X = <span class="hljs-number"><span class="hljs-number">2</span></span>; X = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无论条件如何，变量</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（在当前代码中为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">namespaceExt.prefix.index</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）始终将分配一个值。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AudioFlinger::RecordThread::threadLoop() { .... <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> framesToRead = mBufferSize / mFrameSize; framesToRead = min(mRsmpInFramesOA - rear, mRsmpInFramesP2 / <span class="hljs-number"><span class="hljs-number">2</span></span>); .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V519 CWE-563'framesToRead'变量已连续两次分配值。</font><font style="vertical-align: inherit;">也许这是一个错误。</font><font style="vertical-align: inherit;">检查行：6341，6342。Threads.cpp 6342 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不清楚为什么在声明时必须初始化变量，如果立即将另一个值写入变量。</font><font style="vertical-align: inherit;">这里出了点问题。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SchedulingLatencyVisitorARM::VisitArrayGet(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index-&gt;IsConstant()) { last_visited_latency_ = kArmMemoryLoadLatency; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (has_intermediate_address) { } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { last_visited_internal_latency_ += kArmIntegerOpLatency; } last_visited_internal_latency_ = kArmMemoryLoadLatency; } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V519 CWE-563'last_visited_internal_latency_'变量已连续两次分配值。</font><font style="vertical-align: inherit;">也许这是一个错误。</font><font style="vertical-align: inherit;">检查行：680，682。scheduler_arm.cc 682 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常奇怪，毫无意义的代码。</font><font style="vertical-align: inherit;">我冒险建议应该将其写成：</font></font><br><br><pre> <code class="cpp hljs">last_visited_internal_latency_ += kArmMemoryLoadLatency;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 最后一个错误，展示了分析器如何孜孜不倦地发现即使仔细检查代码也最有可能被跳过的错误。 </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">multiprecision_fast_mod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> U; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> V; .... c[<span class="hljs-number"><span class="hljs-number">0</span></span>] += U; V = c[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt; U; c[<span class="hljs-number"><span class="hljs-number">1</span></span>] += V; V = c[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; V; c[<span class="hljs-number"><span class="hljs-number">2</span></span>] += V; <span class="hljs-comment"><span class="hljs-comment">// V = c[2] &lt; V; // &lt;= c[2] += U; // V = c[2] &lt; U; // &lt;= c[3] += V; V = c[3] &lt; V; c[4] += V; V = c[4] &lt; V; c[5] += V; V = c[5] &lt; V; .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V519 CWE-563'V'变量已连续两次分配值。</font><font style="vertical-align: inherit;">也许这是一个错误。</font><font style="vertical-align: inherit;">检查行：307，309。p_256_multprecision.cc 309 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码太“ </font><font style="vertical-align: inherit;">让人眼花</font><font style="vertical-align: inherit;">”乱”，以至于我不想理解它。</font><font style="vertical-align: inherit;">这很明显：代码中有一个错字，我在注释中突出了该错字。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 其他错误 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存在零散的错误，因此没有必要单独撰写章节。</font><font style="vertical-align: inherit;">但是，它们与前面考虑的一样有趣和阴险。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">优先行动</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TagMonitor::parseTagsToMonitor(String8 tagNames) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock(mMonitorMutex); <span class="hljs-comment"><span class="hljs-comment">// Expand shorthands if (ssize_t idx = tagNames.find("3a") != -1) { ssize_t end = tagNames.find(",", idx); char* start = tagNames.lockBuffer(tagNames.size()); start[idx] = '\0'; .... } .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V593 CWE-783考虑考虑'A = B！= C'类型的表达。该表达式的计算公式如下：“ A =（B！= C）”。 TagMonitor.cpp 50 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常见弱点枚举：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-783</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：操作员优先逻辑错误。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">程序员构思了以下内容。搜索子字符串“ 3a”，并将</font><font style="vertical-align: inherit;">该子字符串</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">位置写入</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">idx</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量</font><font style="vertical-align: inherit;">。如果找到子字符串（idx！= -1），则代码开始运行，该代码使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">idx</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量的值</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不幸的是，程序员对操作的优先级感到困惑。实际上，检查工作如下：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> idx = (tagNames.find(<span class="hljs-string"><span class="hljs-string">"3a"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>))</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，它检查字符串中是否存在子字符串“ 3a”，并将结果false / true放在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">idx</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量中</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">结果，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">idx</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量</font><font style="vertical-align: inherit;">的值为0或1。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果条件为true（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">idx</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量</font><font style="vertical-align: inherit;">为1），则使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">idx</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量的逻辑开始执行</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">始终等于1的变量将导致错误的程序行为。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您根据条件对变量进行初始化，则可以修复错误：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> idx = tagNames.find(<span class="hljs-string"><span class="hljs-string">"3a"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idx != <span class="hljs-number"><span class="hljs-number">-1</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 新版本的C ++ 17还允许您编写： </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> idx = tagNames.find(<span class="hljs-string"><span class="hljs-string">"3a"</span></span>); idx != <span class="hljs-number"><span class="hljs-number">-1</span></span>)</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无效的构造函数</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HearingDevice</span></span></span><span class="hljs-class"> {</span></span> .... HearingDevice() { HearingDevice(RawAddress::kEmpty, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } .... };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V603 CWE-665已创建对象，但未使用该对象。如果要调用构造函数，则应使用“ this-&gt; HearingDevice :: HearingDevice（....）”。听力_aid.cc 176 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常见弱点枚举：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-665</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：不正确的初始化。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">试图显式调用构造函数初始化对象时，程序员常常会犯错误。该类中有两个构造函数。为了减小源代码的大小，程序员决定从另一个调用一个构造函数。但是这段代码根本不符合开发人员的期望。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发生以下情况。创建一个新的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HearingDevice</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型的未命名对象，</font><font style="vertical-align: inherit;">然后销毁它。结果，类字段保持未初始化。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要解决该错误，可以使用委托的构造函数（此功能出现在C ++ 11中）。</font><font style="vertical-align: inherit;">正确的代码是：</font></font><br><br><pre> <code class="cpp hljs">HearingDevice() : HearingDevice(RawAddress::kEmpty, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数不返回值</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NET_RecvFrom</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flags, struct sockaddr *from, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *fromlen)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">socklen_t</span></span> socklen = *fromlen; BLOCKING_IO_RETURN_INT( s, recvfrom(s, buf, len, flags, from, &amp;socklen) ); *fromlen = socklen; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V591 CWE-393非无效函数应返回一个值。</font><font style="vertical-align: inherit;">linux_close.cpp 139 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常见弱点枚举：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-393</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：返回错误的状态代码。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该函数将返回一个随机值。</font><font style="vertical-align: inherit;">另一个此类错误：V591 CWE-393非无效函数应返回一个值。</font><font style="vertical-align: inherit;">linux_close.cpp 158 </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构尺寸计算不正确</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MtpFfsHandle::handleControlRequest(....) { .... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mtp_device_status</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">st</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">reinterpret_cast</span></span></span><span class="hljs-class">&lt;struct mtp_device_status*&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">buf</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">());</span></span> st-&gt;wLength = htole16(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(st)); .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V568'sizeof（）'运算符会评估指向类的指针的大小，但不会评估'st'类对象的大小，这很奇怪。</font><font style="vertical-align: inherit;">MtpFfsHandle.cpp 251 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我确信</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他们</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">想将结构的大小而不是指针的大小</font><font style="vertical-align: inherit;">放到</font><i><font style="vertical-align: inherit;">wLength</font></i><font style="vertical-align: inherit;">成员变量中</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">然后正确的代码应如下所示：</font></font><br><br><pre> <code class="cpp hljs">st-&gt;wLength = htole16(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*st));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 类似的分析仪响应： </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V568很奇怪，'sizeof（）'运算符会评估指向类的指针的大小，而不是'cacheinfo'类对象的大小。</font><font style="vertical-align: inherit;">NetlinkEvent.cpp 220</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V568很奇怪，'sizeof（）'运算符会评估指向类的指针的大小，而不是'page-&gt; next'类对象的大小。</font><font style="vertical-align: inherit;">linker_block_allocator.cpp 146</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V568奇怪的是sizeof（）运算符的参数是'＆session_id'表达式。</font><font style="vertical-align: inherit;">参考文献ril.c 1775</font></font></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无意义的位操作</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EGL_CONTEXT_OPENGL_DEBUG_BIT_KHR 0x00000001 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE_BIT_KHR 0x00000002 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EGL_CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR 0x00000004 EGLContext eglCreateContext(....) { .... case EGL_CONTEXT_FLAGS_KHR: </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((attrib_val | EGL_CONTEXT_OPENGL_DEBUG_BIT_KHR) || (attrib_val | EGL_CONTEXT_OPENGL_FORWARD_C....) || (attrib_val | EGL_CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR)) { context_flags = attrib_val; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { RETURN_ERROR(EGL_NO_CONTEXT,EGL_BAD_ATTRIBUTE); } .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V617 CWE-480考虑检查状况。</font><font style="vertical-align: inherit;">“ |”的“ 0x00000001”参数 </font><font style="vertical-align: inherit;">按位运算包含一个非零值。</font><font style="vertical-align: inherit;">egl.cpp 1329 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常见弱点枚举：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-480</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：使用错误的运算符。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">形式（A | 1）||的表达式 </font><font style="vertical-align: inherit;">（A | 2）|| </font><font style="vertical-align: inherit;">（A | 4）没有意义，因为结果将始终为真。</font><font style="vertical-align: inherit;">实际上，您需要使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＆</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运算符</font><font style="vertical-align: inherit;">，然后代码才有意义：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((attrib_val &amp; EGL_CONTEXT_OPENGL_DEBUG_BIT_KHR) || (attrib_val &amp; EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE_BIT_KHR) || (attrib_val &amp; EGL_CONTEXT_OPENGL_ROBUST_ACCESS_BIT_KHR))</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类似错误：V617 CWE-480考虑检查状况。 “ |”的“ 0x00000001”参数按位运算包含一个非零值。 egl.cpp 1338 </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">错误的移位</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> AddressType&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegsInfo</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> saved_reg_map = <span class="hljs-number"><span class="hljs-number">0</span></span>; AddressType saved_regs[<span class="hljs-number"><span class="hljs-number">64</span></span>]; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> AddressType* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reg &gt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(saved_regs) / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(AddressType)) { <span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); } saved_reg_map |= <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; reg; saved_regs[reg] = (*regs)[reg]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;(*regs)[reg]; } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V629 CWE-190考虑检查'1 &lt;&lt; reg'表达式。</font><font style="vertical-align: inherit;">32位值的位移，随后扩展为64位类型。</font><font style="vertical-align: inherit;">RegsInfo.h 47 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常见弱点枚举：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-190</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：整数溢出或环绕。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移位</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 &lt;&lt; reg，</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reg </font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">的</font></i><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">在[0..63]范围内。</font><font style="vertical-align: inherit;">该表达式用于获得不同的2度，从2 ^ 0到2 ^ 63结束。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该代码不起作用。</font><font style="vertical-align: inherit;">事实是数字文字1​​具有32位</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，获得大于1 ^ 31的值将不起作用。</font><font style="vertical-align: inherit;">移至更大的值会导致变量溢出和出现不确定的行为。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 正确的代码是： </font></font><br><br><pre> <code class="cpp hljs">saved_reg_map |= <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; reg;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 或： </font></font><br><br><pre> <code class="cpp hljs">saved_reg_map |= <span class="hljs-number"><span class="hljs-number">1U</span></span>LL &lt;&lt; reg;</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字符串被复制到自己。</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> PCLmGenerator::writeJobTicket() { <span class="hljs-comment"><span class="hljs-comment">// Write JobTicket char inputBin[256]; char outputBin[256]; if (!m_pPCLmSSettings) { return; } getInputBinString(m_pPCLmSSettings-&gt;userInputBin, &amp;inputBin[0]); getOutputBin(m_pPCLmSSettings-&gt;userOutputBin, &amp;outputBin[0]); strcpy(inputBin, inputBin); strcpy(outputBin, outputBin); .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PVS-Studio警告： </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V549 CWE-688'strcpy'函数的第一个参数等于第二个参数。</font><font style="vertical-align: inherit;">genPCLm.cpp 1181</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V549 CWE-688'strcpy'函数的第一个参数等于第二个参数。</font><font style="vertical-align: inherit;">第1182章</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据常见弱点枚举的分类：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-688</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：带有错误变量或引用作为参数的函数调用。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出于某种原因，字符串会复制到自身。</font><font style="vertical-align: inherit;">最有可能的是这里有些错别字。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用未初始化的变量</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mca_set_cfg_by_tbl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ tMCA_DCB* p_dcb; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tL2CAP_FCR_OPTS* p_opt; tMCA_FCS_OPT fcs = MCA_FCS_NONE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p_tbl-&gt;tcid == MCA_CTRL_TCID) { p_opt = &amp;mca_l2c_fcr_opts_def; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { p_dcb = mca_dcb_by_hdl(p_tbl-&gt;cb_idx); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p_dcb) { p_opt = &amp;p_dcb-&gt;p_chnl_cfg-&gt;fcr_opt; fcs = p_dcb-&gt;p_chnl_cfg-&gt;fcs; } } <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(p_cfg, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(tL2CAP_CFG_INFO)); p_cfg-&gt;mtu_present = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; p_cfg-&gt;mtu = p_tbl-&gt;my_mtu; p_cfg-&gt;fcr_present = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;p_cfg-&gt;fcr, p_opt, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(tL2CAP_FCR_OPTS)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V614 CWE-824使用了潜在的未初始化指针'p_opt'。考虑检查“ memcpy”函数的第二个实际参数。 mca_main.cc 252 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常见弱点枚举：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-824</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：访问未初始化的指针。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p_tbl-&gt; tcid！= MCA_CTRL_TCID</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p_dcb == nullptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则指针</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p_opt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将保持未初始化状态。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">陌生使用未初始化的变量</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timespec</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">__time_t</span></span> tv_sec; <span class="hljs-comment"><span class="hljs-comment">/* Seconds. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tv_nsec; <span class="hljs-comment"><span class="hljs-comment">/* Nanoseconds. */</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> timespec </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NsToTimespec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ns)</span></span></span><span class="hljs-function"> </span></span>{ timespec t; <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> remainder; t.tv_sec = ns / kNanosPerSecond; remainder = ns % kNanosPerSecond; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (remainder &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { t.tv_nsec--; remainder += kNanosPerSecond; } t.tv_nsec = remainder; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V614 CWE-457使用了未初始化的变量't.tv_nsec'。</font><font style="vertical-align: inherit;">clock_ns.h 55 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常见弱点枚举：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-457</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：使用未初始化的变量。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在减小变量</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t.tv_nsec时，</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它</font><i><font style="vertical-align: inherit;">尚未</font></i><font style="vertical-align: inherit;">初始化。</font><font style="vertical-align: inherit;">该变量稍后进行初始化：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t.tv_nsec =余数；</font></font></i>  。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里有些东西显然很混乱。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">过度表达</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bta_dm_co_ble_io_req</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... *p_auth_req = bte_appl_cfg.ble_auth_req | (bte_appl_cfg.ble_auth_req &amp; <span class="hljs-number"><span class="hljs-number">0x04</span></span>) | ((*p_auth_req) &amp; <span class="hljs-number"><span class="hljs-number">0x04</span></span>); .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio警告：V578检测到奇怪的按位操作。</font><font style="vertical-align: inherit;">考虑进行验证。</font><font style="vertical-align: inherit;">bta_dm_co.cc 259 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此表达式是多余的。</font><font style="vertical-align: inherit;">如果删除子表达式</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（bte_appl_cfg.ble_auth_req＆0x04）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则表达式的结果将保持不变。</font><font style="vertical-align: inherit;">也许这里有些错字。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处理泄漏</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> RSReflectionCpp::genEncodedBitCode() { FILE *pfin = fopen(mBitCodeFilePath.c_str(), <span class="hljs-string"><span class="hljs-string">"rb"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pfin == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Error: could not read file %s\n"</span></span>, mBitCodeFilePath.c_str()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> read_length; mOut.indent() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"static const unsigned char __txt[] ="</span></span>; mOut.startBlock(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((read_length = fread(buf, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf), pfin)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { mOut.indent(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; read_length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf2[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(buf2, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf2), <span class="hljs-string"><span class="hljs-string">"0x%02x,"</span></span>, buf[i]); mOut &lt;&lt; buf2; } mOut &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } mOut.endBlock(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); mOut &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PVS-Studio警告：V773 CWE-401在不释放“ pfin”手柄的情况下退出了该功能。 </font></font>资源泄漏是可能的。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">slang_rs_reflection_cpp.cpp 448 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分析仪根据常见弱点枚举将该错误分类为：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-401</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：在删除上一个引用之前内存释放不当（“内存泄漏”）。</font><font style="vertical-align: inherit;">但是，在这里发布</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE-775</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：在有效生命周期后缺少文件描述符或句柄的发布会</font><font style="vertical-align: inherit;">更正确</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我将指示我的同事更正PVS-Studio中的此缺陷。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">描述</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PFIN</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从来没有公布过。</font><font style="vertical-align: inherit;">只是忘了最后调用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fclose</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">一个令人不愉快的错误，它可能很快耗尽整个可用描述符的供应，此后将无法打开新文件。</font></font><br><br><h2> 结论 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如您所见，即使在像Android这样的知名项目中，PVS-Studio分析仪也很容易发现许多错误和潜在的漏洞。</font><font style="vertical-align: inherit;">总结发现哪些弱点（潜在漏洞）：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-14：清除代码的编译器删除缓冲区 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-20：输入验证不正确 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-119：内存缓冲区范围内的操作限制不当 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-190：整数溢出或环绕 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-198：使用不正确的字节顺序 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-393：返回错误的状态码 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-401：删除最后一个引用之前内存释放不当（“内存泄漏”） </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-457：使用未初始化的变量 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-462：关联列表中的重复密钥 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-480：使用不正确的运算符 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-484：交换机中的省略中断语句 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-561：无效代码 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CWE-562：堆栈变量地址的返回 </font></font></li><li> CWE-563: Assignment to Variable without Use </li><li> CWE-570: Expression is Always False </li><li> CWE-571: Expression is Always True </li><li> CWE-476: NULL Pointer Dereference </li><li> CWE-628: Function Call with Incorrectly Specified Arguments </li><li> CWE-665: Improper Initialization </li><li> CWE-670: Always-Incorrect Control Flow Implementation </li><li> CWE-682: Incorrect Calculation </li><li> CWE-688: Function Call With Incorrect Variable or Reference as Argument </li><li> CWE-690: Unchecked Return Value to NULL Pointer Dereference </li><li> CWE-691: Insufficient Control Flow Management </li><li> CWE-758: Reliance on Undefined, Unspecified, or Implementation-Defined Behavior </li><li> CWE-762: Mismatched Memory Management Routines </li><li> CWE-775: Missing Release of File Descriptor or Handle after Effective Lifetime </li><li> CWE-783: Operator Precedence Logic Error </li><li> CWE-824: Access of Uninitialized Pointer </li><li> CWE-834: Excessive Iteration </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本文中，我总共描述了490个潜在漏洞。</font><font style="vertical-align: inherit;">实际上，分析器能够识别更多的报告，但是，正如我之前所写，我没有发现更仔细地研究报告的实力。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在C和C ++中，经过测试的代码库的大小约为2,168,000行代码。</font><font style="vertical-align: inherit;">在这些评论中，有14.4％是评论。</font><font style="vertical-align: inherit;">总共，我们获得了大约1,855,000行的干净代码。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，我们有490个CWE，可用于1,855,000行代码。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事实证明，对于Android项目中的每4000行代码，PVS-Studio分析仪能够检测到1个以上的弱点（潜在漏洞）。</font><font style="vertical-align: inherit;">我很高兴为代码分析器提供良好的结果。</font></font><br><br> 感谢您的关注！<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 祝大家没有代码，并建议执行以下操作： </font></font><br><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PVS-Studio并检查工作草案。</font></font></li><li>  :      : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">     </a> . </li><li> ,        : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">twitter</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RSS</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">vk.com</a> . </li></ol><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br> 如果您想与说英语的读者分享这篇文章，请使用以下链接：Andrey Karpov。 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">We Checked the Android Source Codes by PVS-Studio or Nothing is Perfect</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN418891/">https://habr.com/ru/post/zh-CN418891/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN418879/index.html">加密交易所和加密钱包的测试方法</a></li>
<li><a href="../zh-CN418883/index.html">NAS上的GitLab</a></li>
<li><a href="../zh-CN418885/index.html">Crispr可以加快自然过程并改变食物的种植方式</a></li>
<li><a href="../zh-CN418887/index.html">宇宙膨胀有多快？</a></li>
<li><a href="../zh-CN418889/index.html">手动应用程序测试指南：好处，步骤和方法</a></li>
<li><a href="../zh-CN418895/index.html">学习人工智能玩游戏</a></li>
<li><a href="../zh-CN418897/index.html">CRDT：无冲突的复制数据类型</a></li>
<li><a href="../zh-CN418899/index.html">将MySQL从5.7升级到8.0.11后的第一印象和操作</a></li>
<li><a href="../zh-CN418901/index.html">在2018年欧洲计算机科学奥林匹克eJOI上，俄罗斯人获得了大多数金牌</a></li>
<li><a href="../zh-CN418903/index.html">科学家：火星上没有足够的二氧化碳来温暖大气层。 杆爆炸无济于事</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>