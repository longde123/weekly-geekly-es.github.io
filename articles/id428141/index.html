<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ•ºğŸ» ğŸ—ï¸ ğŸ‘¨ğŸ½â€ğŸ’¼ Backend untuk frontend, atau How Yandex.Market membuat API tanpa kruk â›¹ï¸ ğŸ‘¿ ğŸ’–</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mengapa beberapa API lebih nyaman digunakan daripada yang lain? Apa yang bisa kita lakukan sebagai penyedia front-end di pihak kita untuk bekerja deng...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Backend untuk frontend, atau How Yandex.Market membuat API tanpa kruk</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/428141/"><p>  Mengapa beberapa API lebih nyaman digunakan daripada yang lain?  Apa yang bisa kita lakukan sebagai penyedia front-end di pihak kita untuk bekerja dengan API dengan kualitas yang dapat diterima?  Hari ini saya akan memberi tahu pembaca Habr tentang opsi teknis dan tentang langkah-langkah organisasi yang akan membantu penyedia front-end dan back-end menemukan bahasa yang sama dan membangun kerja yang efektif. </p><br><img src="https://habrastorage.org/webt/us/fq/lo/usfqlosft_umexv3_kh5zyd_wdy.png"><br><p>  Musim gugur ini, Yandex.Market berusia 18 tahun.  Selama ini, antarmuka afiliasi Market telah berkembang.  Singkatnya, ini adalah panel admin tempat toko dapat mengunggah katalog, bekerja dengan bermacam-macam, mengikuti statistik, menanggapi ulasan, dll.  Kekhasan proyek adalah Anda harus banyak berinteraksi dengan berbagai backend.  Namun, data tidak selalu dapat diperoleh di satu tempat, dari satu backend tertentu. </p><br><p><a name="habracut"></a></p><h3>  Gejala Masalah </h3><br>  Jadi, bayangkan, ada semacam masalah.  Manajer pergi dengan tugas kepada para desainer - mereka menggambar tata letak.  Lalu ia pergi ke back-end - mereka membuat beberapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pena</a> dan menulis daftar parameter dan format respons pada wiki internal. <br><p>  Kemudian manajer pergi ke front-end dengan kata-kata "Saya membawa API untuk Anda" dan menawarkan untuk dengan cepat skrip semuanya, karena, menurutnya, hampir semua pekerjaan telah dilakukan. </p><br><p>  Anda melihat dokumentasi dan melihat ini: </p><br><pre><code class="xml hljs">â„– |   ---------------------- 53 | feed_shoffed_id 54 | fesh 55 | filter-currency 56 | showVendors</code> </pre> <br><p>  Tidak melihat sesuatu yang aneh?  Kasing Unta, Ular, dan Kebab dalam satu pena.  Saya tidak berbicara tentang parameter fesh.  Apa itu fesh?  Kata seperti itu bahkan tidak ada.  Coba tebak sebelum Anda membuka spoiler. </p><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><p>  Fesh adalah filter menurut ID toko.  Anda dapat melewati beberapa pengidentifikasi yang dipisahkan oleh koma.  ID dapat didahului dengan tanda minus, yang berarti bahwa toko ini harus dikeluarkan dari hasil. </p></div></div><br><p>  Pada saat yang sama, dari JavaSctipt, tentu saja, saya tidak dapat mengakses properti dari objek seperti itu melalui notasi bertitik.  Belum lagi fakta bahwa jika Anda memiliki lebih dari 50 parameter di satu tempat, maka, jelas, dalam hidup Anda, Anda berpaling ke tempat lain. </p><br><p>  Ada banyak opsi untuk API yang tidak nyaman.  Contoh klasik - API mencari dan mengembalikan hasil: </p><br><pre> <code class="javascript hljs">result: [ {<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'IPhone 8'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'IPhone 8 Plus'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'IPhone X'</span></span>}, ] result: {<span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'IPhone 8'</span></span>} result: <span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre> <br><p>  Jika barang ditemukan, kami mendapatkan array.  Jika satu produk ditemukan, maka kita mendapatkan objek dengan produk ini.  Jika tidak ada yang ditemukan, maka yang terbaik adalah nol.  Dalam kasus terburuk, backend merespons dengan 404 atau bahkan 400 (Permintaan Buruk). </p><br><p>  Situasi lebih mudah.  Misalnya, Anda perlu mendapatkan daftar toko di satu backend, dan pengaturan toko di yang lain.  Di beberapa pena tidak ada data yang cukup, dalam beberapa data ada terlalu banyak.  Memfilter semua ini pada klien atau membuat beberapa permintaan ajax adalah ide yang buruk. </p><br><p>  Jadi apa yang bisa menjadi solusi untuk masalah ini?  Apa yang bisa kita lakukan sebagai penyedia front-end di pihak kita untuk bekerja dengan API dengan kualitas yang dapat diterima? </p><br><h3>  Frontend backend </h3><br><p>  Kami menggunakan klien React / Redux di antarmuka mitra.  Di bawah klien terdapat Node.js, yang melakukan banyak hal tambahan, misalnya, melemparkannya ke halaman InitialState untuk Editor.  Jika Anda memiliki rendering sisi server, tidak masalah dengan kerangka kerja klien yang mana, kemungkinan besar, itu dirender oleh sebuah node.  Tetapi bagaimana jika Anda melangkah lebih jauh dan tidak secara langsung menghubungi klien di backend, tetapi membuat API proksi Anda pada node, yang secara maksimal disesuaikan dengan kebutuhan klien? <br>  Teknik ini disebut BFF (Backend For Frontend).  Istilah ini pertama kali <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diperkenalkan oleh</a> SoundCloud pada tahun 2015, dan idenya dapat secara skematis digambarkan sebagai berikut: </p><br><img src="https://habrastorage.org/webt/du/jw/re/dujwreelvkjlvykh1ut-dphjhxe.png"><br><p>  Dengan demikian, Anda berhenti beralih dari kode klien langsung ke API.  Setiap pegangan, setiap metode API nyata yang Anda duplikasi pada node dan dari klien pergi secara eksklusif ke node.  Dan node sudah memproksi permintaan ke API nyata dan mengembalikan respons kepada Anda. </p><br><p>  Ini tidak hanya berlaku untuk permintaan-mendapatkan primitif, tetapi secara umum untuk semua permintaan, termasuk dengan data multi-bagian / formulir.  Misalnya, toko mengunggah file .xls dengan katalognya melalui formulir di situs.  Jadi, dalam implementasi ini, direktori tidak dimuat secara langsung ke API, tetapi ke pegangan Nod Anda, yang proksi streaming ke backend nyata. </p><br><p>  Ingat contoh itu dengan hasil ketika backend mengembalikan nol, array atau objek?  Sekarang kita bisa mengembalikannya ke normal - sesuatu seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getItems</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isNull(response)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isObject(response)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [response] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response }</code> </pre> <br><p>  Kode ini terlihat mengerikan.  Karena dia mengerikan.  Tetapi kita masih perlu melakukan ini.  Kami punya pilihan: melakukannya di server atau di klien.  Saya memilih server. </p><br><p>  Kami juga dapat memetakan semua kotak kebab dan ular ini dalam gaya yang nyaman bagi kami dan segera meletakkan nilai default jika perlu. </p><br><pre> <code class="javascript hljs">query: { <span class="hljs-string"><span class="hljs-string">'feed_shoffer_id'</span></span>: <span class="hljs-string"><span class="hljs-string">'feedShofferId'</span></span>, <span class="hljs-string"><span class="hljs-string">'pi-from'</span></span>: <span class="hljs-string"><span class="hljs-string">'piFrom'</span></span>, <span class="hljs-string"><span class="hljs-string">'show-urls'</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{showUrls = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'offercard'</span></span></span></span><span class="hljs-function"><span class="hljs-params">}</span></span></span><span class="hljs-function">) =&gt;</span></span> showUrls, }</code> </pre> <br><p>  Apa keuntungan lain yang kita dapatkan? </p><br><ol><li>  <strong>Penyaringan</strong> .  Klien hanya menerima apa yang ia butuhkan, tidak lebih, tidak kurang. </li><li>  <strong>Agregasi</strong>  Tidak perlu membuang jaringan klien dan baterai untuk membuat beberapa permintaan ajax.  Peningkatan kecepatan yang terlihat karena membuka koneksi merupakan operasi yang mahal. </li><li>  <strong>Caching</strong>  Panggilan agregat berulang Anda tidak akan menarik siapa pun lagi, tetapi hanya mengembalikan 304 Tidak Dimodifikasi. </li><li>  <strong>Menyembunyikan</strong> data.  Misalnya, Anda mungkin memiliki token yang diperlukan di antara backend dan tidak boleh pergi ke klien.  Klien mungkin tidak memiliki hak untuk tahu tentang keberadaan token ini, belum lagi isinya. </li><li>  <strong>Layanan microser</strong> .  Jika Anda memiliki monolit di bagian belakang, maka BFF adalah langkah pertama untuk layanan microser. </li></ol><br><p>  Sekarang tentang kontra. </p><br><ol><li>  Meningkatkan <strong>kesulitan</strong> .  Abstraksi apa pun adalah lapisan lain yang perlu dikodekan, disebarkan, didukung.  Bagian lain yang bergerak dari mekanisme yang mungkin gagal. </li><li>  <strong>Duplikasi</strong> pegangan.  Misalnya, beberapa titik akhir dapat melakukan jenis agregasi yang sama. </li><li>  BFF adalah <strong>lapisan batas</strong> yang harus mendukung perutean umum, pembatasan hak pengguna, pencatatan kueri, dll. </li></ol><br><p>  Untuk meratakan minus ini, cukup mematuhi aturan sederhana.  Yang pertama adalah memisahkan front-end dan logika bisnis.  BFF Anda tidak boleh mengubah logika bisnis API inti.  Kedua, layer Anda seharusnya hanya mengkonversi data jika benar-benar diperlukan.  Kami tidak berbicara tentang API komprehensif mandiri, tetapi hanya tentang proksi yang mengisi kesenjangan, memperbaiki kekurangan backend. </p><br><h3>  GraphQL </h3><br><p>  Masalah serupa diselesaikan oleh GraphQL.  Dengan GraphQL, alih-alih banyak titik akhir "bodoh", Anda memiliki satu pena pintar yang dapat bekerja dengan permintaan kompleks dan menghasilkan data dalam bentuk yang diminta klien. </p><br><p>  Pada saat yang sama, GraphQL dapat bekerja di atas REST, yaitu sumber data bukan basis data, tetapi API sisanya.  Karena sifat deklaratif GraphQL, karena semua ini berteman dengan React dan Editor, klien Anda menjadi lebih mudah. </p><br><p>  Bahkan, saya melihat GraphQL sebagai implementasi BFF dengan protokol dan bahasa query yang ketat. </p><br><p>  Ini adalah solusi yang sangat baik, tetapi memiliki beberapa kelemahan, khususnya, dengan tipifikasi, dengan diferensiasi hak, dan secara umum ini merupakan pendekatan yang relatif baru.  Oleh karena itu, kami belum beralih ke sana, tetapi di masa mendatang menurut saya cara yang paling optimal untuk membuat API. </p><br><h3>  Teman terbaik selamanya </h3><br><p>  Tidak ada solusi teknis yang akan bekerja dengan benar tanpa perubahan organisasi.  Anda masih memerlukan dokumentasi, jaminan bahwa format respons tidak akan berubah tiba-tiba, dll. </p><br><p>  Harus dipahami bahwa kita semua berada di kapal yang sama.  Untuk pelanggan yang abstrak, apakah itu manajer atau manajer Anda, pada umumnya, tidak ada bedanya - Anda memiliki GraphQL di sana atau BFF.  Lebih penting baginya bahwa masalah diselesaikan dan kesalahan tidak muncul pada prod.  Baginya, tidak ada banyak perbedaan karena kesalahan siapa kesalahan terjadi pada produk - melalui kesalahan bagian depan atau belakang.  Karena itu, Anda perlu bernegosiasi dengan para backders. </p><br><p>  Selain itu, kelemahan di bagian belakang yang saya bicarakan di awal laporan tidak selalu muncul karena tindakan jahat seseorang.  Mungkin saja parameter fesh juga memiliki beberapa arti. </p><br><img src="https://habrastorage.org/webt/zh/mh/ni/zhmhnidl5c9zkj_yh04ui_eimhe.png"><br><p>  Perhatikan tanggal komit.  Ternyata baru-baru ini fesh merayakan ulang tahun ketujuh belas. </p><br><p>  Lihat beberapa pengidentifikasi aneh di sebelah kiri?  Ini SVN, hanya karena tidak ada gita pada tahun 2001.  Bukan github sebagai layanan, tetapi gith sebagai sistem kontrol versi.  Dia muncul hanya pada tahun 2005. </p><br><h3>  Dokumentasi </h3><br><p>  Jadi, yang kita butuhkan bukanlah bertengkar dengan back-end, tetapi untuk menyetujui.  Ini hanya dapat dilakukan jika kita menemukan satu sumber kebenaran.  Sumber itu harus berupa dokumentasi. </p><br><p>  Yang paling penting di sini adalah menulis dokumentasi sebelum kita mulai mengerjakan fungsionalitas.  Seperti halnya perjanjian pranikah, lebih baik menyepakati semua yang ada di pantai. </p><br><p>  Bagaimana cara kerjanya?  Secara relatif, tiga akan: manajer, front-end dan back-end.  Fronteder fasih dalam bidang subjek, sehingga partisipasinya sangat penting.  Mereka berkumpul dan mulai berpikir tentang API: dengan cara apa, jawaban apa yang harus dikembalikan, hingga nama dan format bidang. </p><br><h3>  Kesombongan </h3><br><p>  Pilihan yang baik untuk dokumentasi API adalah format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Swagger</a> , sekarang disebut OpenAPI.  Lebih baik menggunakan Swagger dalam format YAML, karena, tidak seperti JSON, lebih baik dibaca oleh manusia, tetapi tidak ada perbedaan untuk mesin. </p><br><p>  Akibatnya, semua perjanjian diperbaiki dalam format Swagger dan diterbitkan dalam repositori bersama.  Dokumentasi untuk backend penjualan harus dalam panduan. </p><br><p>  Master dilindungi dari komit, kode masuk ke dalamnya hanya melalui kumpulan permintaan, Anda tidak dapat mendorongnya.  Perwakilan dari tim depan berkewajiban melakukan peninjauan terhadap kumpulan permintaan, tanpa peningkatannya, kode tidak akan diberikan kepada master.  Ini melindungi Anda dari perubahan API yang tidak terduga tanpa pemberitahuan sebelumnya. </p><br><p>  Jadi Anda berkumpul, tulis Swagger, jadi Anda benar-benar menandatangani kontrak.  Mulai saat ini, Anda sebagai front-end dapat memulai pekerjaan Anda tanpa menunggu pembuatan API nyata.  Lagi pula, apa gunanya pemisahan antara klien dan server, jika kita tidak bisa bekerja secara paralel dan pengembang klien harus menunggu pengembang server?  Jika kita memiliki "kontrak", maka kita dapat memparalelkan masalah ini dengan aman. </p><br><h3>  Faker.js </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Faker</a> hebat untuk tujuan ini.  Ini adalah pustaka untuk menghasilkan sejumlah besar data palsu.  Ini dapat menghasilkan berbagai jenis data: tanggal, nama, alamat, dll., Semua ini terlokalisasi dengan baik, ada dukungan untuk bahasa Rusia. </p><br><p>  Pada saat yang sama, si penipu berteman dengan kesombongan, dan Anda dapat dengan tenang meningkatkan server Mock, yang, berdasarkan skema Kesombongan, akan menghasilkan jawaban palsu kepada Anda dengan cara yang diperlukan. </p><br><h3>  Validasi </h3><br><p>  Swagger dapat dikonversi menjadi skema json, dan dengan bantuan alat-alat seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ajv</a> Anda dapat memvalidasi respons backend langsung di runtime, di BFF Anda, dan melaporkan penguji, pendukung sendiri, jika ada perbedaan, dll. </p><br><p>  Misalkan penguji menemukan beberapa jenis bug di situs, misalnya, ketika tombol diklik, tidak ada yang terjadi.  Apa yang dilakukan penguji?  Dia meletakkan tiket di front-end: "ini tombol Anda, tidak ditekan, perbaiki." </p><br><p>  Jika ada validator antara Anda dan belakang, tester akan tahu bahwa tombol tersebut benar-benar ditekan, hanya backend yang mengirim jawaban yang salah.  Salah - ini adalah respons yang tidak diharapkan front, yaitu tidak sesuai dengan "kontrak".  Dan di sini sudah perlu untuk memperbaiki bagian belakang atau mengubah kontrak. </p><br><h3>  Kesimpulan </h3><br><ol><li>  Kami secara aktif terlibat dalam desain API.  Kami merancang API agar nyaman digunakan setelah 17 tahun. </li><li>  Kami memerlukan dokumentasi Swagger.  Tidak ada dokumentasi - operasi back-end tidak selesai. </li><li>  Ada dokumentasi - kami menerbitkannya di git, dan setiap perubahan dalam API harus diperbarui oleh perwakilan tim depan. </li><li>  Kami meningkatkan server palsu dan mulai bekerja di depan tanpa menunggu API yang sebenarnya. </li><li>  Kami meletakkan simpul di bawah frontend dan memvalidasi semua jawaban.  Plus, kami mendapatkan kemampuan untuk mengumpulkan, menormalkan, dan menyimpan data. </li></ol><br><h4>  Lihat juga </h4><br><p>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana membangun API seperti REST di proyek besar</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Backend Di Frontend</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menggunakan GraphQL sebagai Implementasi Pola BFF</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428141/">https://habr.com/ru/post/id428141/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428129/index.html">Logika fuzzy sederhana saling menempel â€œdari apa duluâ€ untuk mesin turbin gas</a></li>
<li><a href="../id428131/index.html">Seluruh kebenaran tentang RTOS. Artikel # 17. Grup Bendera Acara: Pengantar dan Layanan Dasar</a></li>
<li><a href="../id428133/index.html">Hasura. GraphQL Kinerja Tinggi untuk Arsitektur SQL Server</a></li>
<li><a href="../id428135/index.html">Cara mengkonfigurasi atau menonaktifkan linting di editor kode bawaan</a></li>
<li><a href="../id428137/index.html">Olimpiade, kontes ide, ceramah tentang manajemen proyek TI dan pemutaran film: 10 acara mendatang di ITMO University</a></li>
<li><a href="../id428143/index.html">Pendekatan Implementasi ReactJS RBAC</a></li>
<li><a href="../id428147/index.html">Script untuk mengumpulkan kutipan dan mengenali teks dari video dengan Python</a></li>
<li><a href="../id428149/index.html">Sky Ally Enterprise Mavic 2 Baru Anda</a></li>
<li><a href="../id428151/index.html">Ulasan kinerja PostgreSQL 10.5 di layanan cloud Yandex.Cloud terbaru</a></li>
<li><a href="../id428155/index.html">Batas kecepatan untuk kendaraan listrik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>