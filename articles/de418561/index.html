<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßîüèΩ üçõ üë©üèª‚Äçüíª Zustandsautomaten im Dienst von MVP. Yandex Vortrag üë• üë©‚Äç‚öïÔ∏è üöô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Finite-State-Machine-Modell (FSM) wird zum Schreiben von Code f√ºr eine Vielzahl von Plattformen verwendet, einschlie√ülich Android. Sie k√∂nnen den ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zustandsautomaten im Dienst von MVP. Yandex Vortrag</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/418561/">  Das Finite-State-Machine-Modell (FSM) wird zum Schreiben von Code f√ºr eine Vielzahl von Plattformen verwendet, einschlie√ülich Android.  Sie k√∂nnen den Code weniger umst√§ndlich machen, passen gut in das MVP-Paradigma (Model-View-Presenter) und eignen sich f√ºr einfache Tests.  Entwickler Vladislav Kuznetsov erkl√§rte der Droid Party, wie dieses Modell bei der Entwicklung der Yandex.Disk-Anwendung hilft. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/U3StVUzqmzc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Lassen Sie uns zun√§chst √ºber die Theorie sprechen.  Ich denke, jeder von Ihnen hat von MVP und der Zustandsmaschine geh√∂rt, aber wir werden es wiederholen. <a name="habracut"></a><br><br><img src="https://habrastorage.org/webt/ok/59/iy/ok59iyqnwvzdxm3a6_ozothgyka.jpeg"><br><br>  Sprechen wir √ºber Motivation, warum all dies ben√∂tigt wird und wie es uns helfen kann.  Fahren wir mit dem fort, was wir getan haben. An einem realen Beispiel werde ich Codeteile zeigen.  Und am Ende werden wir √ºber das Testen sprechen, dar√ºber, wie dieser Ansatz dazu beigetragen hat, alles bequem zu testen. <br><br>  Die Zustandsmaschine und MVP oder √§hnliches - wahrscheinlich MVI - wurden von allen verwendet. <br><br>  Es gibt viele Zustandsautomaten.  Hier ist die einfachste Definition, die ihnen gegeben werden kann: Dies ist eine Art mathematische Abstraktion, die je nach Ereignis in Form einer endlichen Menge von Zust√§nden, Ereignissen und √úberg√§ngen vom aktuellen in einen neuen Zustand dargestellt wird. <br><br><img src="https://habrastorage.org/webt/x_/o0/be/x_o0befettgekq2bf9h8rz4np3u.jpeg"><br><br>  Hier ist ein einfaches Diagramm eines abstrakten Programmierers, der manchmal schl√§ft, manchmal isst, aber meistens Code schreibt.  Das reicht uns.  Es gibt eine gro√üe Anzahl von Varianten einer Finite-State-Maschine, aber das reicht uns. <br><br><img src="https://habrastorage.org/webt/5q/hw/iu/5qhwiuh6zfcmumsokpxa8xpethq.jpeg"><br><br>  Der Umfang der Zustandsmaschine ist ziemlich gro√ü.  F√ºr jeden Artikel werden sie verwendet und erfolgreich angewendet. <br><br><img src="https://habrastorage.org/webt/6k/z6/mx/6kz6mxlq_mdtra5x-duehczdoro.jpeg"><br><br>  Wie jeder Ansatz unterteilt MVP unsere Anwendung in mehrere Ebenen.  Ansicht - meistens eine Aktivit√§t oder ein Fragment, dessen Aufgabe es ist, eine Aktion an den Benutzer weiterzuleiten, um den Pr√§sentator zu identifizieren, den der Benutzer etwas getan hat.  Wir betrachten Model als Datenanbieter.  Es kann wie eine Datenbank sein, wenn wir √ºber saubere Architektur oder Interactor sprechen, kann alles sein.  Presenter ist ein Vermittler, der die Ansicht und das Modell verbindet und gleichzeitig die Ansicht aus dem Modell abrufen und aktualisieren kann.  Das reicht uns. <br><br>  Wer kann in einem Satz sagen, was ein Programm ist?  Ausf√ºhrbarer Code?  Zu allgemein, detaillierter.  Ein Algorithmus?  Ein Algorithmus ist eine Folge von Aktionen. <br><br>  Dies ist ein Datensatz und eine Art Kontrollfluss.  Es spielt keine Rolle, wer diese Daten manipuliert: der Benutzer oder nicht.  Es folgt der Gedanke, dass der Status einer Anwendung zu jedem Zeitpunkt durch die Gesamtheit aller ihrer Daten bestimmt wird.  Und je mehr Daten in der Anwendung enthalten sind, desto schwieriger ist es, sie zu verwalten, desto unvorhersehbarer kann eine Situation werden, wenn etwas schief geht. <br><br><img src="https://habrastorage.org/webt/nw/zj/ck/nwzjck2q097uwbqk89wzm98pe7e.jpeg"><br><br>  Stellen Sie sich eine einfache Klasse mit drei Booleschen Flags vor.  Um sicherzustellen, dass Sie alle Szenarien zum Kombinieren dieser Flags abdecken, ben√∂tigen Sie 2¬≥ Szenarien.  Es ist notwendig, acht Szenarien mit der Garantie abzudecken, dass ich mit Sicherheit alle Flaggenkombinationen verarbeite.  Wenn Sie ein weiteres Flag hinzuf√ºgen, erh√∂ht es sich proportional. <br><br>  Wir hatten ein √§hnliches Problem.  Es schien eine einfache Aufgabe zu sein, aber als wir uns entwickelten und daran arbeiteten, stellten wir fest, dass etwas schief lief.  Ich werde √ºber die Funktionen sprechen, die wir gestartet haben.  Es wird als L√∂schen lokaler Fotos bezeichnet.  Der Punkt ist, dass der Benutzer einige Daten im automatischen Modus in die Cloud hochl√§dt.  H√∂chstwahrscheinlich sind dies Fotos und Videos, die er auf seinem Handy aufgenommen hat.  Es stellt sich heraus, dass sich die Dateien in der Cloud zu befinden scheinen.  Warum sollten Sie wertvollen Speicherplatz auf Ihrem Telefon beanspruchen, wenn Sie diese Fotos l√∂schen k√∂nnen? <br><br><img src="https://habrastorage.org/webt/3n/3p/lh/3n3plhy4_4mu3v2m4p4gkygdkky.jpeg"><br><br>  Designer haben ein solches Konzept entworfen.  Es scheint nur ein Dialog zu sein, es hat eine √úberschrift, in der der freie Speicherplatz gezeichnet wird, den Nachrichtentext und ein H√§kchen, dass es zwei Reinigungsmodi gibt: L√∂schen Sie alle Fotos, die der Benutzer hochgeladen hat, oder nur diejenigen, die √§lter als ein Monat sind. <br><br><img src="https://habrastorage.org/webt/mx/rh/ww/mxrhwwwyscc58l0l_q0dddos4zk.jpeg"><br><br>  Wir haben nachgesehen - es scheint nichts Kompliziertes zu geben.  Dialogfeld, zwei Textansichten, Kontrollk√§stchen, Schaltfl√§chen.  Als wir jedoch anfingen, dieses Problem im Detail zu bearbeiten, wurde uns klar, dass es eine langfristige Aufgabe ist, Daten dar√ºber zu erhalten, wie viele Dateien wir l√∂schen k√∂nnen.  Daher m√ºssen wir dem Benutzer eine Art Stub zeigen.  Dies ist ein Pseudocode, im wirklichen Leben sieht er anders aus, aber die Bedeutung ist dieselbe. <br><br><img src="https://habrastorage.org/webt/70/if/kj/70ifkjrvmkxonvj7fybqkwuii_4.jpeg"><br><br>  Wir √ºberpr√ºfen einen Status, √ºberpr√ºfen, ob wir rechnen, und ziehen einen Wartestecker. <br><br><img src="https://habrastorage.org/webt/v5/zl/-r/v5zl-rzfbiupzf3xas9oatuev6c.jpeg"><br><br>  Wenn die Berechnungen beendet sind, haben wir verschiedene M√∂glichkeiten, was dem Benutzer angezeigt werden soll.  Zum Beispiel ist die Anzahl der Dateien, die wir l√∂schen k√∂nnen, Null.  In diesem Fall ziehen wir eine Nachricht an den Benutzer, dass nichts zu l√∂schen ist. Kommen Sie also beim n√§chsten Mal.  Dann kommen Designer zu uns und sagen, dass wir zwischen Situationen unterscheiden m√ºssen, in denen der Benutzer die Dateien bereits gel√∂scht hat oder nichts gel√∂scht hat, nichts geladen wurde.  Daher erscheint eine andere Bedingung, dass wir auf den Start warten und ihm eine weitere Nachricht zeichnen. <br><br><img src="https://habrastorage.org/webt/o_/_v/qy/o__vqyedqzkarkomv1xtyvpmqr4.jpeg"><br><br>  Dann gibt es Situationen, in denen dennoch etwas funktioniert hat und der Benutzer beispielsweise ein H√§kchen hat, um keine neuen Dateien zu l√∂schen.  In diesem Fall gibt es auch zwei M√∂glichkeiten.  Entweder k√∂nnen die Dateien bereinigt werden oder die Dateien k√∂nnen nicht bereinigt werden, dh es wurden bereits alle Dateien gel√∂scht. Wir warnen Sie daher, dass Sie bereits alle neuen Dateien gel√∂scht haben. <br><br><img src="https://habrastorage.org/webt/dl/oj/dj/dlojdj0k01zqxtfetujqmgjnwc4.jpeg"><br><img src="https://habrastorage.org/webt/xp/m2/k9/xpm2k931n5l9uj8kkmtl17qjuja.jpeg"><br><br>  Es gibt noch eine Bedingung, unter der wir wirklich etwas l√∂schen k√∂nnen.  Deaktiviert, und es gibt eine Option, mit der Sie etwas l√∂schen k√∂nnen.  Sie sehen sich diesen Code an und es scheint, dass etwas nicht stimmt.  Ich habe noch nicht alles aufgelistet. Wir haben eine Permishin-Pr√ºfung, da ohne sie nichts funktioniert. Wir k√∂nnen die Dateien auf der Karte nicht ber√ºhren. Au√üerdem m√ºssen wir √ºberpr√ºfen, ob der Benutzer das automatische Laden aktiviert hat, da die Funktionen ohne automatisches Laden unbrauchbar sind zu reinigen.  Und noch ein paar Bedingungen.  Und verdammt, es scheint so einfach zu sein, und so viele Probleme sind dadurch entstanden. <br><br>  Und offensichtlich treten sofort mehrere Probleme auf.  Erstens ist dieser Code nicht lesbar.  Hier ist ein bestimmter Pseudocode dargestellt, aber in einem realen Projekt ist er √ºber verschiedene Funktionen, Codeteile, verteilt und mit dem Auge nicht so leicht wahrzunehmen.  Die Unterst√ºtzung f√ºr solchen Code ist ebenfalls recht kompliziert.  Besonders wenn Sie zu einem neuen Projekt kommen, wird Ihnen gesagt, dass Sie eine solche Funktion erstellen m√ºssen, Sie f√ºgen eine Bedingung hinzu, √ºberpr√ºfen ein positives Szenario, alles funktioniert, aber dann kommen Tester und sagen, dass unter bestimmten Bedingungen alles kaputt ist.  Dies geschieht, weil Sie einfach keine Szenarien ber√ºcksichtigt haben. <br><br>  Au√üerdem ist es in dem Sinne √ºberfl√ºssig, dass wir, da wir einen gro√üen Zweig von Bedingungen haben, alle Bedingungen, die nicht zu uns passen, im Voraus pr√ºfen m√ºssen.  Sie sind im Voraus negativ, aber da sie mit solchen Zweigen geschrieben sind, m√ºssen wir sie √ºberpr√ºfen.  Tatsache ist, dass ich im Beispiel eine Art Boolesche Flags habe, aber in der Praxis k√∂nnen Sie Funktionen aufrufen, die irgendwo tiefer in die Datenbank gehen.  Alles kann sein, aufgrund von Redundanz wird es zus√§tzliche Bremsen geben. <br><br>  Und das Traurigste ist ein unerwartetes Verhalten, das w√§hrend der Testphase √ºbersehen wurde, dort passierte nichts, und irgendwo in der Produktion passierte der Benutzer bestenfalls nicht, eine Art UI-Kurve, und im schlimmsten Fall fiel es oder die Daten gingen verloren .  Nur die Anwendung hat sich nicht konsistent verhalten. <br><br>  Wie kann man dieses Problem l√∂sen?  Durch die Kraft der Zustandsmaschine. <br><br><img src="https://habrastorage.org/webt/_7/tj/-0/_7tj-0szm6wntxwaty3doc69isg.jpeg"><br><br>  Die Hauptaufgabe, die die Zustandsmaschine erledigt, besteht darin, eine gro√üe komplexe Aufgabe in kleine diskrete Zust√§nde zu zerlegen, mit denen einfacher zu interagieren und zu verwalten ist.  Nachdem wir gesessen haben und nachgedacht haben, wie wir unseren Staat an all das binden k√∂nnen, da wir versuchen, etwas MVP zu tun?  Wir sind zu einem solchen Schema gekommen.  Wer auch immer das GOF-Buch liest, ist ein klassisches Zustandsmuster, genau das, was es als Kontext bezeichnet, ich habe es als Staats-Oner bezeichnet, und tats√§chlich ist es ein Moderator.  Der Pr√§sentator hat diesen Status, wei√ü, wie er sie wechselt, und kann unseren Status dennoch einige Daten bereitstellen, wenn er etwas wissen m√∂chte, z. B. die Dateigr√∂√üe oder eine asynchrone Anforderung anfordern m√∂chte. <br><br><img src="https://habrastorage.org/webt/9r/kk/dz/9rkkdzixpvbrbgzcijhav5ap22k.jpeg"><br><br>  Hier gibt es nichts Super-Super, die n√§chste Folie ist wichtiger. <br><br><img src="https://habrastorage.org/webt/w0/ct/ae/w0ctaej1zhv5xticgrxlmaasybo.jpeg"><br><br>  Damit m√ºssen Sie mit der Entwicklung beginnen, wenn Sie mit der Erstellung einer Zustandsmaschine beginnen.  Sie sitzen an Ihrem Computer oder irgendwo am Tisch und zeichnen entweder auf einem Blatt Papier oder mit Spezialwerkzeugen ein Zustandsdiagramm.  Es gibt auch nichts Kompliziertes, aber diese Phase hat viele Vorteile.  Erstens k√∂nnen Sie fr√ºhzeitig einige Inkonsistenzen in der Gesch√§ftslogik erkennen.  Ihre Produkte m√∂gen kommen, ihren Wunsch ausdr√ºcken, alles ist in Ordnung, aber wenn Sie anfangen, Code zu schreiben, verstehen Sie, dass etwas nicht zusammenpasst.  Ich denke, jeder hatte eine solche Situation.  Wenn Sie jedoch ein Diagramm erstellen, k√∂nnen Sie fr√ºhzeitig erkennen, dass etwas nicht andockt.  Es wird ganz einfach gezeichnet, es gibt spezielle Tools wie PlantUML, in denen Sie nicht einmal zeichnen m√ºssen, Sie m√ºssen in der Lage sein, Pseudocode zu schreiben, und es selbst generiert Grafiken. <br><br>  Unser Diagramm sieht folgenderma√üen aus und beschreibt den Status dieses Dialogfelds.  Es gibt mehrere Zust√§nde und die Logik des √úbergangs zwischen ihnen. <br><br><img src="https://habrastorage.org/webt/ec/84/hl/ec84hlidyk6-olcmjrar9s2oiq0.jpeg"><br><br>  Fahren wir mit dem Code fort.  Geben Sie an, es gibt nichts Wichtiges. Hauptsache, es gibt drei Methoden: onEnter, das bei der Eingabe zuerst invalidateView aufruft.  Warum wird das gemacht?  Sobald wir in den Status gelangen, wird die Benutzeroberfl√§che aktualisiert.  Au√üerdem gibt es die invalidateView-Methode, die wir √ºberladen, wenn wir etwas mit der Benutzeroberfl√§che tun m√ºssen, und die onExit-Methode, mit der wir etwas tun k√∂nnen, wenn wir den Status verlassen. <br><br><img src="https://habrastorage.org/webt/zo/ld/5s/zold5sqpcjeu_1z3mq48c4jnos4.jpeg"><br><br>  Staatsbesitzer.  Eine Schnittstelle, die den Klickstatus bietet.  Wie wir herausgefunden haben, wird es ein zuk√ºnftiger Moderator sein.  Und dies sind Methoden, die zus√§tzlichen Zugriff auf Daten bieten.  Wenn Daten zwischen Status durchsucht werden, k√∂nnen wir sie im Presenter behalten und √ºber diese Schnittstelle weitergeben.  In diesem Fall k√∂nnen wir die Gr√∂√üe der Dateien angeben, die wir bereinigen k√∂nnen, und die M√∂glichkeit bieten, eine Anfrage zu stellen.  Wir sind in einem Zustand, wir m√∂chten etwas anfordern und √ºber StateOwner k√∂nnen wir eine Methode aufrufen. <br><br>  Ein weiterer solcher Nutzen ist, dass auch er einen Link zur Ansicht zur√ºckgeben kann.  Dies geschieht, damit Sie, wenn Sie einen Status haben und einige Daten eintreffen, nicht in einen neuen Status wechseln m√∂chten, sondern nur redundant sind. Sie k√∂nnen die Ansicht und den Text direkt aktualisieren.  Wir verwenden dies, um die Anzahl der Ziffern zu aktualisieren, die der Benutzer sieht, wenn er den Dialog betrachtet.  Wir sind in der Laufzeit beim Herunterladen von Dateien, er schaut sich den Dialog an und die Zahlen werden aktualisiert.  Wir bewegen uns nicht in einen neuen Zustand, wir aktualisieren nur die aktuelle Ansicht. <br><br><img src="https://habrastorage.org/webt/og/ug/pq/ogugpqbvlhyh5rfxwyofcz22my8.jpeg"><br><br>  Hier ist das Standard-MVP, alles sollte extrem einfach sein, keine Logik, einfache Methoden, die etwas zeichnen.  Ich halte mich an dieses Konzept.  Es sollte keine Logik geben, zumindest keine Aktion.  Wir nehmen sauber eine Textansicht, √§ndern sie, nicht mehr. <br><br><img src="https://habrastorage.org/webt/8h/-f/zf/8h-fzfwagetflmtss66is8shzly.jpeg"><br><br>  Moderator  Es gibt interessantere Dinge.  Zun√§chst k√∂nnen wir Daten f√ºr einige Zust√§nde durchsuchen. Wir haben zwei Variablen, die mit der Zustandsanmerkung markiert sind.  Wer Icepick benutzt hat, ist damit vertraut.  Wir schreiben keine Serialisierung mit unseren H√§nden in Partible, wir verwenden eine vorgefertigte Bibliothek. <br><br>  Das Folgende ist der Ausgangszustand.  Es ist immer n√ºtzlich, den Ausgangszustand festzulegen, auch wenn nichts unternommen wird.  Der Nutzen ist, dass Sie keine Nullpr√ºfungen durchf√ºhren m√ºssen, aber wenn wir sagen, dass es etwas tun kann.  Beispielsweise m√ºssen Sie f√ºr den Lebenszyklus Ihrer Anwendung einmal etwas tun. Wenn wir beginnen, m√ºssen Sie die Prozedur einmal ausf√ºhren und nie wieder ausf√ºhren.  Wenn wir den Ausgangszustand verlassen, k√∂nnen wir immer so etwas tun, und wir kehren nie in diesen Zustand zur√ºck.  Geben Sie so ein, dass das Zustandsdiagramm gezeichnet wird.  Obwohl wer wei√ü, wer zeichnen wird, k√∂nnen Sie vielleicht zur√ºckkommen. <br><br>  Ich bin daf√ºr, die √úberpr√ºfungen auf Null usw. zu minimieren, daher behalte ich hier einen Link zu einer einfachen Ansichtsimplementierung.  Wir m√ºssen nichts synchronisieren, nur irgendwann, wenn das Trennen passiert, ersetzen wir die Ansicht durch eine leere, und der Pr√§sentator kann irgendwo in den Status wechseln, denken, dass es eine Ansicht gibt, sie aktualisiert sie, aber tats√§chlich funktioniert sie mit leerer Implementierung. <br><br>  Es gibt mehrere weitere Methoden, um den Status zu speichern, aber wir m√∂chten den Umbruch der Aktivit√§t erleben. In diesem Fall erfolgt alles √ºber den Konstruktor.  Alles ist etwas komplizierter, hier ein √ºbertriebenes Beispiel. <br><br><img src="https://habrastorage.org/webt/rk/a2/1m/rka21mszygspy9cjuprcqgv9afi.jpeg"><br><br>  Es ist notwendig, saveState weiterzuleiten. Wenn jemand mit √§hnlichen Bibliotheken gearbeitet hat, ist alles ziemlich trivial.  Sie k√∂nnen mit Ihren H√§nden schreiben.  Und zwei Methoden sind sehr wichtig: Anh√§ngen, aufgerufen bei onStart, und Trennen, aufgerufen bei onStop. <br><br><img src="https://habrastorage.org/webt/p4/dq/n2/p4dqn2m5adpxmsfybd7fctrjc0a.jpeg"><br><br>  Welche Bedeutung haben sie?  Urspr√ºnglich wollten wir onCreateView, onDestroyView anh√§ngen und trennen, aber das war nicht genug.  Wenn Sie eine Ansicht haben, wird Ihr Text m√∂glicherweise aktualisiert oder ein Dialogfragment wird angezeigt.  Wenn Sie sich nicht in onStop verfangen und dann versuchen, das Fragment anzuzeigen, wird die bekannte Ausnahme angezeigt, dass Sie keine Transaktion festschreiben k√∂nnen, wenn der Status noch vorhanden ist.  Verwenden Sie entweder Commit State Loss oder nicht.  Daher werden wir in onStop detailliert beschrieben, w√§hrend der Pr√§sentator dort weiterarbeiten, den Status wechseln und Ereignisse abfangen wird.  In dem Moment, in dem der Start erfolgt, wird das Ereignis "Ansicht angeh√§ngt" ausgel√∂st, und der Pr√§sentator aktualisiert die Benutzeroberfl√§che so, dass sie dem aktuellen Status entspricht. <br><br><img src="https://habrastorage.org/webt/fk/r6/op/fkr6op8zellkewd81kh7omqaxto.jpeg"><br><img src="https://habrastorage.org/webt/my/sb/t8/mysbt8ecs5ap56d5o_jyndzgp_a.jpeg"><br><br>  Es gibt eine Freigabemethode, die normalerweise in onDestroy aufgerufen wird. Sie trennen Ressourcen und geben sie zus√§tzlich frei. <br><br><img src="https://habrastorage.org/webt/f9/lg/-d/f9lg-db1fwe27xwd09pg1yltu44.jpeg"><br><br>  Eine weitere wichtige setState-Methode.  Da wir planen, die Benutzeroberfl√§che in onEnter und onExit zu √§ndern, wird der Hauptthread √ºberpr√ºft.  Dies f√ºhrt zu einer Einschr√§nkung f√ºr uns, dass wir hier nichts Schweres tun. Alle Anforderungen m√ºssen entweder an die Benutzeroberfl√§che oder asynchron sein.  Der Vorteil dieses Ortes ist, dass wir hier den Ein- und Ausgang des Staates reservieren k√∂nnen. Dies ist sehr n√ºtzlich beim Debuggen. Wenn beispielsweise etwas schief geht, k√∂nnen Sie sehen, wie das System geklickt hat, und verstehen, was falsch war. <br><br><img src="https://habrastorage.org/webt/sh/bx/nx/shbxnx_e_4myifye8ucidtdpj7e.jpeg"><br><br>  Einige Beispiele f√ºr Bedingungen.  Es gibt einen Anfangszustand, der lediglich die Berechnung ausl√∂st, wie viel Speicherplatz Sie zum Zeitpunkt der Verf√ºgbarkeit der Ansicht freigeben m√ºssen.  Dies geschieht nach onStart.  Sobald onStart passiert, wechseln wir in einen neuen Zustand und das System beginnt, Daten anzufordern. <br><br><img src="https://habrastorage.org/webt/nt/cy/i3/ntcyi3chfp0yvgyiauig5gegy2c.jpeg"><br><br><img src="https://habrastorage.org/webt/f4/bq/j-/f4bqj-kaebdsnml-dpa-azvgrmm.jpeg"><br><br>  Ein Beispiel f√ºr den Status ist Berechnen. Wir geben die Gr√∂√üe der Dateien mit stateOwner an, sie kriechen irgendwie in die Datenbank und dann gibt es noch eine inValidateView. Wir aktualisieren die aktuelle Benutzeroberfl√§che.  Und viewAttached wird aufgerufen, wenn die Ansicht erneut angeh√§ngt wird.  Wenn wir im Hintergrund waren, war das Rechnen im Hintergrund, wir kehren wieder zu unserer Aktivit√§t zur√ºck, diese Methode wird aufgerufen und aktualisiert alle Daten. <br><br><img src="https://habrastorage.org/webt/eu/fg/5f/eufg5fb-rwg6keerfqik_skfo44.jpeg"><br><br>  Als Beispiel f√ºr ein Ereignis haben wir stateOwner gefragt, wie viele Dateien freigegeben werden k√∂nnen, und es wird die Methode filesSizeUpdated aufgerufen.  Hier war ich zu faul, es war m√∂glich drei separate Methoden zu schreiben, wie zum Beispiel aktualisiert, es gibt so viele alte Dateien wie man verschiedene Ereignisse trennt.  Aber Sie m√ºssen verstehen, wenn es f√ºr Sie schwierig wird, wenn es viel einfacher wird.  Es ist nicht notwendig, in √úberentwicklung zu verfallen, dass jedes Ereignis eine separate Methode ist.  Sie k√∂nnen mit einem einfachen Wenn auskommen, ich sehe nichts falsch daran. <br><br><img src="https://habrastorage.org/webt/r0/ge/tx/r0getxszg4i3mwlruqqybl-mffm.jpeg"><br><br>  Ich sehe mehrere m√∂gliche Verbesserungen.  Ich mag es nicht, dass wir gezwungen sind, unsere H√§nde um diese Methoden wie onStart, on Stop, onCreate, onSave und mehr zu werfen.  Sie k√∂nnen an Lifecycle angeh√§ngt werden, es ist jedoch unklar, was mit saveState geschehen soll.  Es gibt beispielsweise die Idee, ein Pr√§sentatorfragment zu erstellen.  Warum nicht?  Ein Fragment ohne Benutzeroberfl√§che, das den Lebenszyklus erfasst, und im Allgemeinen brauchen wir dann nichts, alles wird von selbst zu uns fliegen. <br><br>  Ein weiterer interessanter Punkt: Dieser Pr√§sentator wird jedes Mal neu erstellt. Wenn Sie gro√üe Datenmengen im Pr√§sentator gespeichert haben, zur Datenbank gegangen sind und einen gro√üen Cursor gedr√ºckt haben, ist es nicht akzeptabel, bei jedem Drehen des Bildschirms eine Anforderung anzufordern.  Daher k√∂nnen Sie den Pr√§sentator zwischenspeichern, z. B. ViewModule aus Architekturkomponenten, ein Fragment erstellen, das den Pr√§sentator-Cache enth√§lt, und diese f√ºr jede Ansicht zur√ºckgeben. <br><br>  Sie k√∂nnen die Tabellenmaschinen tabellarisch angeben, da das von uns verwendete Statusmuster einen wesentlichen Nachteil aufweist: Sobald Sie einem neuen Ereignis eine Methode hinzuf√ºgen m√ºssen, m√ºssen Sie allen Nachkommen eine Implementierung hinzuf√ºgen.  Zumindest leer.  Oder im Grundzustand.  Dies ist nicht sehr praktisch.  Daher wird in allen Bibliotheken die tabellarische Methode zur Angabe von Zustandsautomaten verwendet. Wenn Sie auf GitHub nach dem Wort FSM suchen, finden Sie eine gro√üe Anzahl von Bibliotheken, die Ihnen eine Art Builder zur Verf√ºgung stellen, in dem Sie den Anfangszustand, das Ereignis und den Endzustand festlegen.  Das Erweitern und Warten einer solchen Zustandsmaschine ist viel einfacher. <br><br>  Ein weiterer interessanter Punkt: Wenn Sie das Statusmuster verwenden und Ihre Statusmaschine zu wachsen beginnt, m√ºssen Sie h√∂chstwahrscheinlich einige Ereignisse auf die gleiche Weise behandeln, damit der Code nicht kopiert wird. Sie erstellen einen Basisstatus.  Je mehr Ereignisse auftreten, desto mehr Grundbedingungen treten auf, die Hierarchie w√§chst und etwas geht schief. <br><br>  Wie wir wissen, muss die Vererbung durch Delegierung ersetzt werden, und hierarchische Zustandsautomaten helfen, dieses Problem zu l√∂sen.  Sie haben Zust√§nde, die nicht von der Vererbungsstufe abh√§ngen. Erstellen Sie einfach einen Baum von Zust√§nden, die den obigen Handler √ºbergeben.  Sie k√∂nnen auch separat lesen, eine sehr n√ºtzliche Sache.  In Android werden beispielsweise hierarchische Zustandsautomaten in WatchDog Wi-Fi verwendet, das den Netzwerkstatus √ºberwacht. Sie befinden sich direkt in der Android-Quelle. <br><br><img src="https://habrastorage.org/webt/kd/qn/cn/kdqncnx-u10ovabuexg_h-kdxiu.jpeg"><br><br>  Zu guter Letzt.  Wie kann das getestet werden?  Zun√§chst k√∂nnen deterministische Zust√§nde getestet werden.  Es gibt einen separaten Status. Wir erstellen eine Instanz, ziehen die onEnter-Methode und sehen, dass die entsprechenden Werte in der Ansicht aufgerufen werden.  Daher √ºberpr√ºfen wir, ob unser Status die Ansicht korrekt aktualisiert.  Wenn Ihre Ansicht nichts Ernstes tut, werden Sie h√∂chstwahrscheinlich eine Vielzahl von Szenarien abdecken. <br><br><img src="https://habrastorage.org/webt/bc/mn/o_/bcmno_pvrehzh447tidyzn3nd5w.jpeg"><br><br>  Sie k√∂nnen einige Methoden mit einer Funktion sperren, die die Gr√∂√üe zur√ºckgibt, nach onEnter ein anderes Ereignis aufrufen und sehen, wie ein bestimmter Status auf bestimmte Ereignisse reagiert.  In diesem Fall m√ºssen wir in den neuen Status CleanAllFiles wechseln, wenn das Ereignis filesSizeUpdated auftritt und wenn AllFilesSize gr√∂√üer als Null ist.  Mit Hilfe des Layouts √ºberpr√ºfen wir dies alles. <br><br><img src="https://habrastorage.org/webt/1z/pu/lp/1zpulp09kyd3vcr2xhcevmum4rm.jpeg"><br><br>  Und das letzte - wir k√∂nnen das ganze System testen.  Wir konstruieren den Status, senden ein Ereignis an ihn und √ºberpr√ºfen, wie sich das System verh√§lt.  Wir haben drei Testphasen.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir testen separat, wie die Benutzeroberfl√§che aktualisiert wird, separat testen wir, wie die Logik des √úbergangs und des Wechsels zwischen Zust√§nden erfolgt, und separat testen wir das gesamte System als Ganzes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben den Videoplayer f√ºr ein solches Konzept umgeschrieben und eine Abdeckung von mehr als 70% erhalten. </font><font style="vertical-align: inherit;">Unter 80% der Anweisungen wurden durch solche Tests abgedeckt. </font><font style="vertical-align: inherit;">Ich denke, das ist ein sehr cooler Indikator. </font></font><br><br><img src="https://habrastorage.org/webt/tu/pz/qx/tupzqxbhu35qyqjpzhx0_xc6kxu.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was haben wir mit diesem Konzept? </font><font style="vertical-align: inherit;">Zun√§chst einmal testen. </font><font style="vertical-align: inherit;">Die Zustandsmaschine und unser Moderator k√∂nnen sich leicht mit dem Lebenszyklus anfreunden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erweiterbarkeit. </font><font style="vertical-align: inherit;">Mit diesem Ansatz k√∂nnen Sie sich auf ein bestimmtes Konzept beschr√§nken. </font><font style="vertical-align: inherit;">Sie k√∂nnen etwas h√§rten, aber h√∂chstwahrscheinlich wird jemand, der Ihren Code √ºberpr√ºft, sagen: Warum tun Sie das, wenn Sie einfach einen neuen Status hinzuf√ºgen k√∂nnen und alles funktioniert?</font></font><br><br>     -  ,  ,    ,    .    ,   ,     .    ,        ,     .    -    ,    ,   .    , ,   .     lock   .   - ,     . <br><br>   ‚Äî .   ,       ,           ,     ,   . ,   - , ,  -,    ,   .     ,      .   , . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418561/">https://habr.com/ru/post/de418561/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418549/index.html">Erstellen eines Bots zur Teilnahme am AI Mini Cup 2018 basierend auf einem wiederkehrenden neuronalen Netzwerk (Teil 3)</a></li>
<li><a href="../de418551/index.html">Wie viel sollte ein Programmierer in Mathe wissen?</a></li>
<li><a href="../de418553/index.html">Kotlin + Reagieren gegen Javasript + Reagieren</a></li>
<li><a href="../de418557/index.html">Berechnung von Wellenprozessen in einer Hydraulikleitung nach der Methode der Eigenschaften</a></li>
<li><a href="../de418559/index.html">NL2API: Erstellen von Schnittstellen in nat√ºrlicher Sprache f√ºr die Web-API</a></li>
<li><a href="../de418563/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 263 (23. Juli - 29. Juli)</a></li>
<li><a href="../de418565/index.html">Auf dem Weg zu einer 100% igen Codeabdeckung mit Tests in Go am Beispiel von SQL-Dumper</a></li>
<li><a href="../de418567/index.html">Dell wird aufh√∂ren, ein privates Unternehmen zu sein, und zum ersten Mal seit 5 Jahren Aktien an die B√∂rse bringen</a></li>
<li><a href="../de418569/index.html">Neue Satelliten - neue Fehler: Der Satelliten-Infrarotsensor GOES-17 k√ºhlt nicht gut ab</a></li>
<li><a href="../de418573/index.html">Waterius: √úbertragen Sie die Wasserwerte √ºber WLAN auf ein Telefon (4 Jahre im Akkubetrieb).</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>