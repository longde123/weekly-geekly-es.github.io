<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêº üèçÔ∏è üëÉüèø O que foi congelado no congelamento de recursos em 2019. Parte I. JSONPath ü§∏üèª ‚òπÔ∏è üíö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ap√≥s o comit√™ de 2019-03 , ocorreu o congelamento de recursos. Temos uma coluna quase tradicional aqui: j√° escrevemos sobre o congelamento do ano pass...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O que foi congelado no congelamento de recursos em 2019. Parte I. JSONPath</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/448612/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/yl/kw/ra/ylkwraooftas8s1ft0ik4pgn5tc.jpeg"></div><br>  Ap√≥s o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><b>comit√™ de 2019-03</b></a> , ocorreu o congelamento de recursos.  Temos uma coluna quase tradicional aqui: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">j√° escrevemos</a> sobre o congelamento do ano passado.  Agora, os resultados de 2019: qual dos novos ser√° inclu√≠do no PostgreSQL 12. Nesta parte da revis√£o dedicada ao JSONPath, s√£o usados ‚Äã‚Äãexemplos e fragmentos do relat√≥rio "Postgres 12 in Etudes", que Oleg Bartunov leu no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Saint Highload ++</a> em S√£o Petersburgo, no dia 9 de abril deste ano. <br><a name="habracut"></a><br><h2>  Jsonpath </h2><br>  Tudo relacionado ao JSON (B) √© relevante, na demanda mundial, na R√∫ssia, e esta √© uma das √°reas mais importantes de desenvolvimento do Postgres Professional.  O tipo jsonb, fun√ß√µes e operadores para trabalhar com JSON / JSONB apareceram no PostgreSQL vers√£o 9.4, eles foram criados por uma equipe liderada por Oleg Bartunov. <br><br>  O padr√£o SQL / 2016 prev√™ trabalhar com JSON: JSONPath √© mencionado l√° - um conjunto de ferramentas de endere√ßamento de dados dentro do JSON;  JSONTABLE - meio de converter JSON em tabelas regulares;  Uma grande fam√≠lia de fun√ß√µes e operadores.  Apesar de o JSON no Postgres ter sido suportado por um longo tempo, em 2017 Oleg Bartunov e seus colegas come√ßaram a trabalhar no suporte ao padr√£o.  Cumprir com o padr√£o √© sempre bom.  De tudo o que √© descrito no padr√£o, apenas um, mas o patch mais importante, √© o JSONPath na vers√£o 12, portanto, falaremos sobre isso em primeiro lugar. <br><br>  Nos tempos antigos, as pessoas usavam JSON, armazenando-o em campos de texto.  Na 9.3, um tipo de dados especial para JSON apareceu, mas a funcionalidade associada a ele n√£o era rica e as solicita√ß√µes com esse tipo funcionaram lentamente devido ao tempo gasto na an√°lise da representa√ß√£o de texto de JSON.  Isso interrompeu muitos usu√°rios em potencial do Postgres que preferiram os bancos de dados NoSQL.  A produtividade do Postgres aumentou em 9,4 quando, gra√ßas a O. Bartunov, A. Korotkov e F. Sigaev, o Postgres introduziu uma vers√£o bin√°ria do JSON - o tipo jsonb. <br>  O jsonb n√£o precisa ser analisado todas as vezes, portanto, trabalhar com ele √© muito mais r√°pido.  Das novas fun√ß√µes e operadores que surgiram ao mesmo tempo, alguns funcionam apenas com um novo tipo bin√°rio, como o importante operador de ocorr√™ncia <b>@&gt;</b> , que verifica se um elemento ou matriz est√° inclu√≠do em um determinado JSONB: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'[1, 2, 3]'</span></span>::jsonb @&gt; <span class="hljs-string"><span class="hljs-string">'[1, 3]'</span></span>::jsonb;</code> </pre> <br>  d√° TRUE, j√° que a matriz do lado direito entra na matriz da esquerda.  Mas <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'[1, 2, [1, 3]]'</span></span>::jsonb @&gt; <span class="hljs-string"><span class="hljs-string">'[1, 3]'</span></span>::jsonb;</code> </pre> <br>  dar√° FALSE, j√° que o n√≠vel de aninhamento √© diferente, ele deve ser definido explicitamente.  O operador de exist√™ncia √© introduzido para o tipo jsonb <b>?</b>  (um ponto de interroga√ß√£o) que verifica se uma sequ√™ncia √© uma chave de objeto ou um elemento de uma matriz no n√≠vel superior dos valores JSONB, al√©m de mais dois operadores semelhantes (detalhes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ).  Eles s√£o suportados por √≠ndices GIN com duas classes de operadores GIN.  O operador <b>-&gt;</b> (seta) permite "navegar" pelo JSONB, ele retorna um valor por chave ou, se for uma matriz, por √≠ndice.  Existem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">v√°rios outros</a> operadores para se mover.  Mas n√£o h√° como organizar filtros que funcionem de maneira semelhante a WHERE.  Foi uma inova√ß√£o: gra√ßas ao jsonb, o Postgres come√ßou a crescer em popularidade como um RDBMS com recursos NoSQL. <br><br>  Em 2014, A. Korotkov, O. Bartunov e F. Sigaev desenvolveram a extens√£o jsquery, que foi inclu√≠da como resultado no Postgres Pro Standard 9.5 (e em vers√µes posteriores do Standard e Enterprise).  Ele fornece recursos adicionais muito amplos para trabalhar com o json (b).  Essa extens√£o define a linguagem de consulta para extrair dados de json (b) e √≠ndices para acelerar essas consultas.  Essa funcionalidade era exigida pelos usu√°rios, eles n√£o estavam prontos para aguardar o padr√£o e a inclus√£o de novos recursos na vers√£o vanilla.  O valor pr√°tico tamb√©m √© evidenciado pelo fato de o desenvolvimento ter sido patrocinado pela Wargaming.net.  A extens√£o implementa um tipo especial - jsquery. <br><br>  Uma consulta nesse idioma √© compacta e se parece, por exemplo, com esta: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'{"apt":[{"no": 1, "rooms":2}, {"no": 2, "rooms":3}, {"no": 3, "rooms":2}]}'</span></span>::jsonb @@ <span class="hljs-string"><span class="hljs-string">'apt.#.rooms=3'</span></span>::jsquery;</code> </pre> <br>  Estamos perguntando aqui se existem "tr√™s rublos" no pr√©dio.  O tipo jsquery deve ser especificado porque o operador @@ agora tamb√©m est√° no tipo jsonb.  A descri√ß√£o est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> e a apresenta√ß√£o com muitos exemplos est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Total: o Postgres j√° tinha tudo para trabalhar com JSON e, em seguida, o padr√£o SQL: 2016 apareceu.  Aconteceu que sua sem√¢ntica n√£o √© t√£o diferente da nossa na extens√£o jsquery.  √â poss√≠vel que os autores do padr√£o tenham olhado para jsquery, inventando o JSONPath.  Nossa equipe teve que implementar um pouco diferente do que j√° t√≠nhamos e, √© claro, muitas coisas novas tamb√©m. <br><br>  Mais de um ano atr√°s, no commitfest de mar√ßo, os frutos de nossos esfor√ßos de programa√ß√£o foram oferecidos √† comunidade na forma de 3 grandes patches com suporte para o padr√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SQL: 2016</a> : <br><br>  SQL / JSON: JSONPath; <br>  SQL / JSON: fun√ß√µes; <br>  SQL / JSON: JSON_TABLE. <br><br>  Mas desenvolver um patch n√£o √© o neg√≥cio todo, promov√™-los tamb√©m n√£o √© f√°cil, especialmente se os patches forem grandes e afetarem muitos m√≥dulos.  Muitas itera√ß√µes de revis√£o de revis√£o s√£o necess√°rias, o patch deve ser promovido, como as empresas comerciais, investindo muitos recursos (horas-homem).  O arquiteto-chefe do Postgres Professional, Alexander Korotkov, assumiu a responsabilidade (j√° que agora tem o status de committer) e garantiu a ado√ß√£o do patch JSONPath - o principal nesta s√©rie de patches.  O segundo e o terceiro est√£o agora no status de Revis√£o de necessidades.  O JSONPath focado permite que voc√™ trabalhe com a estrutura JSON (B) e √© flex√≠vel o suficiente para destacar seus fragmentos.  Dos 15 pontos prescritos no padr√£o, 14 s√£o implementados, e isso √© mais do que no Oracle, MySQL e MS SQL. <br><br>  A nota√ß√£o JSONPath difere das instru√ß√µes do Postgres por trabalhar com a nota√ß√£o JSON e JSQuery.  A hierarquia √© indicada por pontos: <br><br>  $ .abc (na nota√ß√£o do postgres 11, eu precisaria escrever 'a' -&gt; 'b' -&gt; 'c'); <br>  $ - o contexto atual do elemento - de fato, a express√£o com $ define a regi√£o json (b) que deve ser processada, incluindo a regi√£o do filtro, o restante n√£o est√° dispon√≠vel para trabalho; <br>  @ - o contexto atual na express√£o de filtro - itera sobre os caminhos dispon√≠veis na express√£o com $; <br>  [*] - uma matriz; <br>  * - curinga, na express√£o com $ ou @ significa qualquer valor do segmento de caminho, mas levando em considera√ß√£o a hierarquia; <br>  ** - como parte da express√£o com $ ou @ pode significar qualquer valor do segmento de caminho sem levar em conta a hierarquia - √© conveniente us√°-lo se voc√™ n√£o souber o n√≠vel de aninhamento de elementos; <br>  operador "?"  permite organizar um filtro semelhante a WHERE: <br>  $ .abc?  (@ .x&gt; 10); <br>  $ .abcxtype (), bem como tamanho (), duplo (), teto (), piso (), abs (), datetime (), keyvalue () s√£o m√©todos. <br>  Uma consulta com a fun√ß√£o jsonb_path_query (sobre as fun√ß√µes abaixo) pode ter esta apar√™ncia: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query_array(<span class="hljs-string"><span class="hljs-string">'[1,2,3,4,5]'</span></span>, <span class="hljs-string"><span class="hljs-string">'$[*] ? (@ &gt; 3)'</span></span>); jsonb_path_query_array <span class="hljs-comment"><span class="hljs-comment">------------------------ [4, 5] (1 row)</span></span></code> </pre> <br>  Embora um patch especial com fun√ß√µes n√£o seja confirmado, o patch JSONPath j√° possui fun√ß√µes-chave para trabalhar com JSON (B): <br><br><br><pre> <code class="sql hljs">jsonb_path_exists('{"a": 1}', '$.a')  true (  "?") jsonb_path_exists('{"a": 1}', '$.b')  false jsonb_path_match('{"a": 1}', '$.a == 1')  true (  "@&gt;") jsonb_path_match('{"a": 1}', '$.a &gt;= 2')  false jsonb_path_query('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 2)')  3, 4, 5 jsonb_path_query('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 5)')  0  jsonb_path_query_array('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 2)')  [3, 4, 5] jsonb_path_query_array('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 5)')  [] jsonb_path_query_first('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 2)')  3 jsonb_path_query_first('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 5)')  NULL</code> </pre> <br>  Observe que a igualdade nas express√µes JSONPath √© um √∫nico "=", enquanto no jsquery √© o dobro: "==". <br><br>  Para ilustra√ß√µes mais elegantes, geraremos JSONB em uma placa de casa com uma coluna: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> house(js jsonb); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> house <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'{ "address": { "city":"Moscow", "street": "Ulyanova, 7A" }, "lift": false, "floor": [ { "level": 1, "apt": [ {"no": 1, "area": 40, "rooms": 1}, {"no": 2, "area": 80, "rooms": 3}, {"no": 3, "area": 50, "rooms": 2} ] }, { "level": 2, "apt": [ {"no": 4, "area": 100, "rooms": 3}, {"no": 5, "area": 60, "rooms": 2} ] } ] }'</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/u6/ob/nb/u6obnbokethtz5gatlcbdtvhjyi.png"><br>  <i>Fig. 1 √Årvore JSON de habita√ß√£o com apartamentos de folhas alocados.</i> <br><br>  Esse √© um JSON estranho: ele tem uma hierarquia confusa, mas √© tirada da vida e, na vida, muitas vezes √© necess√°rio trabalhar com o que √© e n√£o com o que deveria ser.  Munidos dos recursos da nova vers√£o, encontraremos apartamentos no 1¬∫ e 2¬∫ andares, mas n√£o o primeiro na lista de apartamentos (na √°rvore, eles s√£o destacados em verde): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query_array(js, <span class="hljs-string"><span class="hljs-string">'$.floor[0, 1].apt[1 to last]'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house; <span class="hljs-comment"><span class="hljs-comment">--------------------- [{"no": 2, "area": 80, "rooms": 3}, {"no": 3, "area": 50, "rooms": 2}, {"no": 5, "area": 60, "rooms": 2}]</span></span></code> </pre><br>  No PostgreSQL 11, voc√™ deve perguntar o seguinte: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_agg(apt) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> apt-&gt;generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, jsonb_array_length(apt) - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> js-&gt;<span class="hljs-string"><span class="hljs-string">'floor'</span></span>-&gt;<span class="hljs-keyword"><span class="hljs-keyword">unnest</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>])-&gt;<span class="hljs-string"><span class="hljs-string">'apt'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house ) apts(apt) ) apts(apt);</code> </pre> <br>  Agora, uma pergunta muito simples: existem linhas contendo (em qualquer lugar) o valor "Moscow"?  Realmente simples: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_exists(js, <span class="hljs-string"><span class="hljs-string">'$.** ? (@ == "Moscow")'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house;</code> </pre> <br>  Na vers√£o 11, voc√™ teria que escrever um script enorme: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RECURSIVE</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COALESCE</span></span>(kv.value, e.value) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> LATERAL jsonb_each ( <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> jsonb_typeof(t.value) = <span class="hljs-string"><span class="hljs-string">'object'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> t.value <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> ) kv <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> LATERAL jsonb_array_elements ( <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> jsonb_typeof(t.value) = <span class="hljs-string"><span class="hljs-string">'array'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> t.value <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> ) e <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> kv.value <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> e.value <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-string"><span class="hljs-string">'"Moscow"'</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/1k/uv/go/1kuvgo4f2bnjj_aylnvej76gltc.png"><br>  <i>Fig. 2 √Årvore da habita√ß√£o JSON, Moscou foi encontrada!</i> <br><br>  Estamos √† procura de qualquer apartamento em qualquer andar com uma √°rea de 40 a 90 m¬≤: <br><br><pre> <code class="plaintext hljs">select jsonb_path_query(js, '$.floor[*].apt[*] ? (@.area &gt; 40 &amp;&amp; @.area &lt; 90)') FROM house; jsonb_path_query ----------------------------------- {"no": 2, "area": 80, "rooms": 3} {"no": 3, "area": 50, "rooms": 2} {"no": 5, "area": 60, "rooms": 2} (3 rows)</code> </pre><br>  Estamos √† procura de apartamentos com quartos ap√≥s o dia 3, usando o nosso alojamento jason: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(js, <span class="hljs-string"><span class="hljs-string">'$.floor.apt.no ? (@&gt;3)'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house; jsonb_path_query <span class="hljs-comment"><span class="hljs-comment">------------------ 4 5 (2 rows)</span></span></code> </pre> <br>  E aqui est√° como o jsonb_path_query_first funciona: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query_first(js, <span class="hljs-string"><span class="hljs-string">'$.floor.apt.no ? (@&gt;3)'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house; jsonb_path_query_first <span class="hljs-comment"><span class="hljs-comment">------------------------ 4 (1 row)</span></span></code> </pre> <br>  Vemos que apenas o primeiro valor √© selecionado que satisfaz a condi√ß√£o do filtro. <br><br>  O operador booleano JSONPath para JSONB @@ √© chamado de operador correspondente.  Ele calcula o predicado JSONPath chamando a fun√ß√£o jsonb_path_match_opr. <br><br>  Outro operador booleano √© @?  - este √© um teste de exist√™ncia, responde √† pergunta se a express√£o JSONPath retornar√° objetos SQL / JSON, chama a fun√ß√£o jsonb_path_exists_opr: <br><br><pre> <code class="sql hljs"> '[1,2,3]' @@ '$[*] == 3'  true;  '[1,2,3]' @? '$[*] @? (@ == 3)' -  true</code> </pre> <br>  O mesmo resultado pode ser alcan√ßado usando operadores diferentes: <br><br><pre> <code class="sql hljs">js @? '$.a'  js @@ 'exists($.a)' js @@ '$.a == 1'  js @? '$ ? ($.a == 1)'</code> </pre> <br>  A beleza dos operadores booleanos JSONPath √© que eles s√£o suportados, acelerados pelos √≠ndices GIN.  jsonb_ops e jsonb_path_ops s√£o as classes de operadores correspondentes.  No exemplo, desabilitamos o SEQSCAN, j√° que temos uma microtable, em tabelas grandes o pr√≥prio otimizador selecionar√° o √çndice de bitmap: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ENABLE_SEQSCAN <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> house <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> gin (js); <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (COSTS <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> js @? <span class="hljs-string"><span class="hljs-string">'$.floor[*].apt[*] ? (@.rooms == 3)'</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------- Bitmap Heap Scan on house Recheck Cond: (js @? '$."floor"[*]."apt"[*]?(@."rooms" == 3)'::jsonpath) -&gt; Bitmap Index Scan on house_js_idx Index Cond: (js @? '$."floor"[*]."apt"[*]?(@."rooms" == 3)'::jsonpath) (4 rows)</span></span></code> </pre> <br>  Todas as fun√ß√µes do formato jsonb_path_xxx () t√™m a mesma assinatura: <br><br><pre> <code class="sql hljs">jsonb_path_xxx( js jsonb, jsp jsonpath, vars jsonb DEFAULT '{}', silent boolean DEFAULT false )</code> </pre> <br>  vars √© um objeto JSONB para transmitir vari√°veis ‚Äã‚ÄãJSONPath: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query_array(<span class="hljs-string"><span class="hljs-string">'[1,2,3,4,5]'</span></span>, <span class="hljs-string"><span class="hljs-string">'$[*] ? (@ &gt; $x)'</span></span>, vars =&gt; <span class="hljs-string"><span class="hljs-string">'{"x": 2}'</span></span>); jsonb_path_query_array <span class="hljs-comment"><span class="hljs-comment">------------------------ [3, 4, 5]</span></span></code> </pre> <br>  √â dif√≠cil ficar sem vars quando fazemos uma jun√ß√£o envolvendo um campo do tipo jsonb em uma das tabelas.  Digamos que fazemos um aplicativo que procure apartamentos adequados para os funcion√°rios daquela casa que anotaram seus requisitos para a √°rea m√≠nima do question√°rio: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> demands(<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">position</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">demand</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> demands <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">85</span></span>), (<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">45</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(js, <span class="hljs-string"><span class="hljs-string">'$.floor[*].apt[*] ? (@.area &gt;= $min)'</span></span>, vars =&gt; jsonb_build_object(<span class="hljs-string"><span class="hljs-string">'min'</span></span>, demands.demand)) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house, demands <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span>; -[ RECORD 1 ]<span class="hljs-comment"><span class="hljs-comment">----+----------------------------------- jsonb_path_query | {"no": 2, "area": 80, "rooms": 3} -[ RECORD 2 ]----+----------------------------------- jsonb_path_query | {"no": 3, "area": 50, "rooms": 2} -[ RECORD 3 ]----+----------------------------------- jsonb_path_query | {"no": 4, "area": 100, "rooms": 3} -[ RECORD 4 ]----+----------------------------------- jsonb_path_query | {"no": 5, "area": 60, "rooms": 2}</span></span></code> </pre> <br>  Lucky Pasha pode escolher entre 4 apartamentos.  Mas vale a pena alterar 1 letra na solicita√ß√£o - de "P" para "C", e n√£o haver√° escolha!  Apenas 1 apartamento servir√°. <br><br><br>  Mais uma palavra-chave permanece: silencioso √© um sinalizador que suprime o tratamento de erros; eles est√£o na consci√™ncia do programador. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(<span class="hljs-string"><span class="hljs-string">'[]'</span></span>, <span class="hljs-string"><span class="hljs-string">'strict $.a'</span></span>); ERROR: SQL/JSON member not found DETAIL: jsonpath member accessor can only be applied to an object</code> </pre> <br>  O erro  Mas isso n√£o ser√° um erro: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(<span class="hljs-string"><span class="hljs-string">'[]'</span></span>, <span class="hljs-string"><span class="hljs-string">'strict $.a'</span></span>, silent =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span>); jsonb_path_query <span class="hljs-comment"><span class="hljs-comment">------------------ (0 rows)</span></span></code> </pre> <br>  A prop√≥sito, sobre erros: de acordo com o padr√£o, erros aritm√©ticos nas express√µes n√£o emitem mensagens de erro, eles est√£o na consci√™ncia do programador: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(<span class="hljs-string"><span class="hljs-string">'[1,0,2]'</span></span>, <span class="hljs-string"><span class="hljs-string">'$[*] ? (1/ @ &gt;= 1)'</span></span>); jsonb_path_query <span class="hljs-comment"><span class="hljs-comment">------------------ 1 (1 row)</span></span></code> </pre> <br>  Ao calcular a express√£o no filtro, os valores da matriz s√£o pesquisados, dentre os quais h√° 0, mas dividir por 0 n√£o gera um erro. <br><br>  As fun√ß√µes funcionar√£o de maneira diferente, dependendo do modo selecionado: Estrito ou Relaxado (na tradu√ß√£o ‚Äún√£o estrito‚Äù ou at√© ‚Äúsolto‚Äù, √© selecionado por padr√£o).  Suponha que estamos procurando uma chave no modo Lax no JSON, onde obviamente n√£o √©: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb <span class="hljs-string"><span class="hljs-string">'{"a":1}'</span></span> @? <span class="hljs-string"><span class="hljs-string">'lax $.b ? (@ &gt; 1)'</span></span>; ?column? <span class="hljs-comment"><span class="hljs-comment">---------- f (1 row)</span></span></code> </pre> <br>  Agora no modo estrito: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb <span class="hljs-string"><span class="hljs-string">'{"a":1}'</span></span> @? <span class="hljs-string"><span class="hljs-string">'strict $.b ? (@ &gt; 1)'</span></span>; ?column? <span class="hljs-comment"><span class="hljs-comment">---------- (null) (1 row)</span></span></code> </pre> <br>  Ou seja, onde, no modo liberal, recebemos FALSE, com rigor obtemos NULL. <br><br>  No modo relaxado, uma matriz com uma hierarquia complexa [1,2, [3,4,5]] sempre se expande para [1,2,3,4,5]: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb <span class="hljs-string"><span class="hljs-string">'[1,2,[3,4,5]]'</span></span> @? <span class="hljs-string"><span class="hljs-string">'lax $[*] ? (@ == 5)'</span></span>; ?column? <span class="hljs-comment"><span class="hljs-comment">---------- t (1 row)</span></span></code> </pre> <br>  No modo Rigoroso, o n√∫mero ‚Äú5‚Äù n√£o ser√° encontrado, pois n√£o est√° na parte inferior da hierarquia.  Para encontr√°-lo, voc√™ precisa modificar a consulta, substituindo "@" por "@ [*]": <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb <span class="hljs-string"><span class="hljs-string">'[1,2,[3,4,5]]'</span></span> @? <span class="hljs-string"><span class="hljs-string">'strict $[*] ? (@[*] == 5)'</span></span>; ?column? <span class="hljs-comment"><span class="hljs-comment">---------- t (1 row)</span></span></code> </pre> <br>  No PostgreSQL 12, JSONPath √© um tipo de dados.  O padr√£o n√£o diz nada sobre a necessidade de um novo tipo, √© uma propriedade de implementa√ß√£o.  Com o novo tipo, obtemos um trabalho completo com jsonpath com a ajuda de operadores e √≠ndices que aceleram seu trabalho, que j√° existe para o JSONB.  Caso contr√°rio, o JSONPath teria que ser integrado no n√≠vel do c√≥digo do executor e do otimizador. <br><br>  Voc√™ pode ler sobre a sintaxe SQL / JSON, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  A postagem do blog de Oleg Bartunov √© sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">conformidade com o padr√£o SQL / JSON-2016</a> para PostgreSQL, Oracle, SQL Server e MySQL. <br><br>  Aqui est√° uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">apresenta√ß√£o</a> sobre SQL / JSON. <br><br>  E aqui est√° uma <a href="">introdu√ß√£o</a> ao SQL / JSON. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt448612/">https://habr.com/ru/post/pt448612/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt448602/index.html">O monitoramento est√° morto? - Monitoramento ao vivo</a></li>
<li><a href="../pt448604/index.html">Gameboy em C #</a></li>
<li><a href="../pt448606/index.html">Sidorin: KnowledgeConf √© sobre como manter o conhecimento com uma dura√ß√£o m√©dia de trabalho em um local em 2 a 3 anos</a></li>
<li><a href="../pt448608/index.html">Como dar os primeiros passos na rob√≥tica?</a></li>
<li><a href="../pt448610/index.html">DIY: Como fizemos uma programa√ß√£o ao vivo para o Codefest X</a></li>
<li><a href="../pt448618/index.html">Algoritmo de Douglas-Pecker</a></li>
<li><a href="../pt448622/index.html">PHP GR8: JIT melhorar√° o desempenho do PHP 8</a></li>
<li><a href="../pt448624/index.html">Veja os dados? N√£o. Ent√£o, eu n√£o vejo, mas eles s√£o. Destru√≠mos dados em unidades SSD e at√© restauramos a velocidade</a></li>
<li><a href="../pt448626/index.html">DDoS para ajudar: como realizamos testes de estresse e estresse</a></li>
<li><a href="../pt448628/index.html">Est√©tica e tecnologia t√©cnicas sovi√©ticas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>