<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🔧 🔔 👨🏿‍🍳 Datenübertragung per animiertem QR an Gomobile und GopherJS 🌦️ 👩🏿‍🤝‍👨🏾 🚵🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel möchte ich über ein kleines und lustiges Wochenendprojekt zum Übertragen von Dateien über animierte QR-Codes sprechen. Das Projekt w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Datenübertragung per animiertem QR an Gomobile und GopherJS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430688/"><p> In diesem Artikel möchte ich über ein kleines und lustiges Wochenendprojekt zum Übertragen von Dateien über animierte QR-Codes sprechen.  Das Projekt wurde in Go mit Gomobile und Gopherjs geschrieben - der neuesten Version einer Webanwendung zur automatischen Messung der Datenübertragungsraten.  Wenn Sie an der Idee interessiert sind, Daten über visuelle Codes zu übertragen, Webanwendungen zu entwickeln, die nicht auf JS oder dem echten plattformübergreifenden Go - to Wellcome to Cat basieren. </p><br><p><img src="https://habrastorage.org/webt/2p/zg/t_/2pzgt_2anc92t0udxgl3cnt3xy0.gif" alt="txqr Demo"></p><a name="habracut"></a><br><p>  Die Idee des Projekts entstand aus einer bestimmten Aufgabe für eine mobile Anwendung - wie ein kleiner Teil der Daten (~ 15 KB) unter Bedingungen der Netzwerkblockierung am einfachsten und schnellsten auf ein anderes Gerät übertragen werden kann.  Der erste Gedanke war, Bluetooth zu verwenden, aber es ist nicht so praktisch, wie es scheint - der relativ lange und nicht immer funktionierende Prozess zum Erkennen und Koppeln von Geräten ist für die Aufgabe zu schwierig.  Eine gute Idee wäre die Verwendung von NFC (Near Field Communication), aber es gibt immer noch zu viele Geräte, bei denen die NFC-Unterstützung eingeschränkt oder nicht vorhanden ist.  Wir brauchten etwas Einfacheres und Erschwinglicheres. </p><br><p>  Was ist mit QR-Codes? </p><br><h1 id="qr-kody">  QR-Codes </h1><br><p>  QR-Code (Quick Response) ist die weltweit beliebteste Art von visuellem Code.  Es ermöglicht Ihnen, bis zu 3 KB beliebige Daten zu codieren, und verfügt über verschiedene Fehlerkorrekturstufen, mit denen Sie selbst ein Drittel eines geschlossenen oder verschmutzten Codes sicher lesen können. </p><br><p>  Bei QR-Codes gibt es jedoch zwei Probleme: </p><br><ul><li>  3KB reichen nicht aus </li><li>  Je mehr Daten codiert sind, desto höher sind die Qualitätsanforderungen für das zu scannende Bild </li></ul><br><p>  Hier ist der QR-Code der 40. Version (die höchste Aufzeichnungsdichte) mit 1276 Bytes: </p><br><p><img src="https://habrastorage.org/webt/wp/r1/mp/wpr1mp7p-uz4vzzssaai5zp8v44.gif" alt="qrv40"></p><br><p>  Für meine Aufgabe musste ich lernen, wie man ~ 15 KB Daten auf Standardgeräten (Smartphones / Tablets) überträgt. Daher stellte sich die Frage von selbst: Warum nicht die Reihenfolge der QR-Codes animieren und die Daten in Teilen übertragen? </p><br><p>  Eine schnelle Suche nach vorgefertigten Implementierungen führte zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mehreren</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">solchen</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projekten</a> - hauptsächlich Projekten zu Hackathons (obwohl es auch eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">These gab</a> ) -, aber alle wurden in Java, Python oder JavaScript geschrieben, was den Code leider praktisch unportabel und unbenutzt machte.  Angesichts der großen Beliebtheit von QR-Codes und der geringen technischen Komplexität der Idee wurde beschlossen, in Go - einer plattformübergreifenden, lesbaren und schnellen Sprache - von Grund auf neu zu schreiben.  Normalerweise impliziert plattformübergreifend die Möglichkeit, Binärcode für Windows, Mac und Linux zu erstellen. In meinem Fall war es jedoch auch wichtig, ihn für das Web (gopherjs) und für mobile Systeme (iOS / Android) zu erstellen.  Go bietet alles sofort einsatzbereit mit minimalen Kosten. </p><br><p>  Ich habe auch alternative Optionen für visuelle Codes in Betracht gezogen - wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HCCB</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JAB-Code</a> , aber für sie müsste ich einen OpenCV-Scanner schreiben, einen Encoder / Decoder von Grund auf neu implementieren und dies war zu viel für ein Projekt für ein Wochenende.  Mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Round-Robin-</a> QR-Codes ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shotcodes</a> ) und ihren auf Facebook, Kik und Snapchat verwendeten Gegenstücken können Sie viel weniger Informationen codieren. Apples unglaublich cooler patentierter Ansatz zum Koppeln von Apple Watch und iPhone - einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">animierten Wolke aus bunten Partikeln</a> - ist ebenfalls für den Wow-Effekt optimiert nicht unter maximaler Bandbreite.  QR-Codes sind in die nativen SDK-Kameras des mobilen Betriebssystems integriert, was die Arbeit mit ihnen erheblich erleichtert. </p><br><h1 id="txqr">  TXQR </h1><br><p>  So entstand das <em>txqr-</em> Projekt (aus Tx - Transmission und QR), das eine Bibliothek zum Codieren / Decodieren von QR auf Pure Go und ein Protokoll zum Übertragen von Daten implementiert. </p><br><p>  Die Hauptidee lautet wie folgt: Ein Client wählt eine Datei oder Daten aus, die gesendet werden sollen, das Programm auf dem Gerät zerlegt die Datei in Teile, codiert sie jeweils in QR-Frames und zeigt sie in einer Endlosschleife mit einer bestimmten Framerate an, bis der Empfänger alle Daten empfängt.  Das Protokoll ist so erstellt, dass der Empfänger von jedem Frame aus starten und QR-Frames in beliebiger Reihenfolge empfangen kann - dies vermeidet die Notwendigkeit, die Animationsfrequenz und die Scanfrequenz zu synchronisieren.  Der Empfänger kann ein altes Gerät sein, mit dessen Leistung Sie 2 Bilder pro Sekunde dekodieren können, und der Absender mit einem neuen Smartphone, das 120-Hz-Animationen erzeugt, oder umgekehrt. Dies ist kein grundlegendes Problem für das Protokoll. </p><br><p> Dies wird wie folgt erreicht - wenn die Datei in Teile ( <em>Frames</em> weiter) unterteilt ist, ein Präfix mit Informationen über den Versatz relativ zu allen Daten und die Gesamtlänge - <code>OFFSET/TOTAL|</code>  (wobei OFFSET und TOTAL ganzzahlige Werte für Offset bzw. Länge sind).  Binärdaten werden in Base64 weiterhin codiert, dies ist jedoch nicht unbedingt erforderlich. Die QR-Spezifikation ermöglicht nicht nur die Codierung von Daten als Binärdaten, sondern auch die Optimierung verschiedener Teile der Daten für unterschiedliche Codierungen (z. B. kann ein Präfix mit geringfügigen Änderungen als <em>alphanumerisch</em> codiert werden, und der Rest des Inhalts - wie <em>binär</em> ), aber der Einfachheit halber hat Base64 seine Funktion perfekt ausgeführt. </p><br><p>  Darüber hinaus können die Bildgröße und -frequenz sogar dynamisch geändert werden, um sie an die Fähigkeiten des Empfängers anzupassen. </p><br><p><img src="https://habrastorage.org/webt/qm/7g/dg/qm7gdgycvmlhgjflhc_xudrfeu8.png" alt="Protokoll"></p><br><p>  Das Protokoll selbst ist sehr einfach, und sein Haupt-Minus ist, dass bei großen Dateien (obwohl dies den Rahmen der Aufgabe sprengt, aber immer noch) ein beim Scannen übersprungener Frame die Scanzeit verdoppelt - der Empfänger muss erneut auf den vollständigen Zyklus warten.  In der Codierungstheorie gibt es Lösungen für solche Fälle - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Brunnencodes</a> , aber ich werde dies für einige der folgenden freien Tage belassen. </p><br><p>  Der interessanteste Punkt war, eine mobile Anwendung zu schreiben, die dieses Protokoll verwenden kann. </p><br><h2 id="gomobile">  Gomobile </h2><br><p>  Wenn Sie noch nichts von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gomobile gehört haben</a> , ist dies ein Projekt, mit dem Sie Go-Bibliotheken in iOS- und Android-Projekten verwenden können und das dies zu einem obszönen einfachen Verfahren macht. </p><br><p>  Der Standardprozess ist wie folgt: </p><br><ul><li>  Sie schreiben regulären Go-Code </li><li>  laufen <code>gomobile bind ...</code> </li><li>  Kopieren Sie die resultierenden Artefakte ( <code>yourpackage.framework.</code> oder <code>yourpackage.aar</code> ) in Ihr mobiles Projekt </li><li>  Importieren Sie <code>yourpackage</code> und arbeiten Sie damit wie mit einer normalen Bibliothek </li></ul><br><p>  Sie können versuchen, wie einfach es ist. </p><br><p>  Daher habe ich schnell eine Anwendung auf Swift geschrieben, die QR-Codes (dank dieses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wunderbaren Artikels</a> ) scannt und dekodiert, zusammenklebt und beim Empfang der gesamten Datei im Vorschaufenster anzeigt. </p><br><p>  Als Neuling bei Swift (obwohl ich das Swift 4-Buch gelesen habe) gab es einige Momente, in denen ich mich auf etwas Einfaches festgelegt hatte, um herauszufinden, wie man es richtig macht, und am Ende bestand die beste Lösung darin, diese Funktionalität auf Go and Use zu implementieren über gomobile.  Verstehen Sie mich nicht falsch, Swift ist in vielerlei Hinsicht eine wunderbare Sprache, aber wie die meisten anderen Programmiersprachen bietet es zu viele Möglichkeiten, dasselbe zu tun, und es gibt bereits eine anständige Geschichte rückwärts inkompatibler Änderungen.  Zum Beispiel musste ich eine einfache Sache tun - um die Dauer eines Ereignisses mit Millisekundengenauigkeit zu messen.  Eine Suche bei Google und StackOverflow führte zu einer Vielzahl unterschiedlicher, widersprüchlicher und oft veralteter Lösungen, von denen am Ende keine für mich schön oder für den Compiler korrekt aussah.  Nach 40 Minuten habe ich gerade eine andere Methode im Go-Paket erstellt, die <code>time.Since(start) / time.Millisecond</code> und das Ergebnis von Swift direkt verwendet hat. </p><br><p>  Ich habe auch das Konsolendienstprogramm <code>txqr-ascii</code> für schnelle Anwendungstests geschrieben.  Es codiert die Datei und animiert die QR-Codes im Terminal.  Alles in allem funktionierte es überraschend gut - ich konnte in wenigen Sekunden ein kleines Bild senden, aber als ich anfing, verschiedene Werte der Bildrate, die Anzahl der Bytes in jedem QR-Rahmen und den Grad der Fehlerkorrektur im QR-Encoder zu testen, wurde klar, dass die Terminallösung dies nicht war kommt mit der hohen Frequenz (mehr als 10) der Animation zurecht, und das manuelle Testen und Messen der Ergebnisse ist eine katastrophale Sache. </p><br><h1 id="txqr-tester">  TXQR-Tester </h1><br><p><img src="https://habrastorage.org/webt/bc/tp/a6/bctpa6fnru8q-kxbezmo27dcc1w.jpeg"></p><br><p>  Um die optimale Kombination aus Bildrate, Datengröße in einem QR-Rahmen und dem Grad der Fehlerkorrektur unter den angemessenen Grenzen dieser Werte zu finden, musste ich mehr als 1000 Tests durchführen, die Parameter manuell ändern, mit dem Telefon in der Hand auf einen vollständigen Zyklus warten und die Ergebnisse auf eine Platte schreiben.  Dies muss natürlich automatisiert werden! </p><br><p>  Hier kam die Idee der nächsten Anwendung <code>txqr-tester</code> - <code>txqr-tester</code> .  Ursprünglich wollte ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">x / exp / shiny verwenden</a> - ein experimentelles UI-Framework für native Desktop-Anwendungen unter Go, aber es scheint aufgegeben zu werden.  Vor ungefähr einem Jahr habe ich es versucht, und der Eindruck war nicht schlecht - es passte perfekt für Dinge auf niedrigem Niveau.  Aber heute ist die Hauptniederlassung noch nicht einmal kompiliert worden.  Es scheint, dass es keinen Anreiz mehr gibt, in die Entwicklung von Desktop-Frameworks zu investieren - eine komplexe und umständliche Aufgabe, bei der heutzutage fast keine Nachfrage mehr besteht. Alle UI-Lösungen sind vor langer Zeit ins Web gewechselt. </p><br><p>  Wie Sie wissen, haben Programmiersprachen in der Webprogrammierung dank WebAssembly gerade erst begonnen, aber dies sind immer noch die ersten Schritte für Kinder.  Natürlich gibt es immer noch JavaScript und Add-Ons, aber Freunde erlauben Freunden nicht, Anwendungen in JavaScript zu schreiben. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Deshalb habe</a> ich mich für meine jüngste Entdeckung entschieden - das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vecty-</a> Framework, mit dem Sie Frontends auf reinem Go schreiben können, die automatisch mit einem sehr erwachsenen und überraschend gut funktionierenden JavaScript konvertiert werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GopherJS-</a> Projekt. </p><br><h1 id="vecty-i-gopherjs">  Vecty und GopherJS </h1><br><p><img src="https://habrastorage.org/webt/rf/xc/zz/rfxczzfu4b5efmhjtu_lmf7ema4.png" alt="vecty"></p><br><p>  In meinem Leben hat mich die Entwicklung von Front-End-Schnittstellen nicht so begeistert. </p><br><p>  Wenig später habe ich vor, ein paar weitere Artikel über meine Erfahrungen bei der Entwicklung von Frontends auf Vecty zu schreiben, einschließlich WebGL-Anwendungen. Unter dem Strich ist das Schreiben eines Frontends in einer durchdachten und einfachen Programmiersprache nach mehreren Projekten in React, Angulars und Ember ein Hauch von Frische Luft!  Ich kann in kurzer Zeit ziemlich schöne Frontends schreiben, ohne eine einzige Zeile in JavaScript zu schreiben! </p><br><p>  Für den Anfang starten Sie auf diese Weise ein neues Projekt auf Vecty (keine Codegeneratoren für "Erstprojekte", die Tonnen von Dateien und Ordnern erstellen) - nur main.go: </p><br><pre> <code class="go hljs">ackage main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/gopherjs/vecty"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { app := NewApp() vecty.SetTitle(<span class="hljs-string"><span class="hljs-string">"My App"</span></span>) vecty.AddStylesheet(<span class="hljs-comment"><span class="hljs-comment">/* ... add your css... */</span></span>) vecty.RenderBody(app) }</code> </pre> <br><p>  Eine Anwendung ist wie jede UI-Komponente nur ein Typ: eine Struktur, die den Typ <code>vecty.Core</code> und die Schnittstelle <code>vecty.Component</code> (bestehend aus einer <code>Render()</code> -Methode) implementieren muss.  Und das ist alles!  Dann arbeiten Sie mit Typen, Methoden, Funktionen, Bibliotheken für die Arbeit mit dem DOM usw. - keine versteckte Magie und neue Begriffe und Konzepte.  Hier ist der vereinfachte Code für die Hauptseite: </p><br><pre> <code class="go hljs">/ App is a top-level app component. <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> App <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { vecty.Core session *Session settings *Settings <span class="hljs-comment"><span class="hljs-comment">// any other stuff you need, // it's just a struct } // Render implements the vecty.Component interface. func (a *App) Render() vecty.ComponentOrHTML { return elem.Body( a.header(), elem.Div( vecty.Markup( vecty.Class("columns"), ), // Left half elem.Div( vecty.Markup( vecty.Class("column", "is-half"), ), elem.Div(a.QR()), // QR display zone ), // Right half elem.Div( vecty.Markup( vecty.Class("column", "is-half"), ), vecty.If(!a.session.Started(), elem.Div( a.settings, )), vecty.If(a.session.Started(), elem.Div( a.resultsTable, )), ), ), vecty.Markup( event.KeyDown(a.KeyListener), ), ) }</span></span></code> </pre> <br><p>  Sie schauen sich jetzt wahrscheinlich den Code an und denken - wie viel unbegründete Arbeit mit dem DOM ist!  Das habe ich auch zuerst gedacht, aber als ich anfing zu arbeiten, wurde mir klar, wie bequem es war: </p><br><ol><li>  Es gibt keine Magie - jeder Block (Markup oder HTML) ist nur eine Variable des gewünschten Typs, mit klaren Grenzen, an die Sie dank statischer Typisierung etwas setzen können. </li><li>  Es gibt keine öffnenden / schließenden Tags, die Sie entweder beim Refactoring ändern müssen, oder die IDE verwenden, die dies für Sie erledigt. </li><li>  Die Struktur wird plötzlich klar - zum Beispiel habe ich nie verstanden, warum es in React bis zur 16. Version unmöglich war, mehrere Tags von einer Komponente zurückzugeben - dies ist "nur eine Zeichenfolge".  Als man sah, wie dies in Vecty gemacht wird, wurde plötzlich klar, wo die Wurzeln dieser Einschränkung in React wuchsen.  Trotzdem ist nicht klar, warum es nach Reaktion 16 möglich, aber nicht notwendig wurde. </li></ol><br><p>  Sobald Sie diesen Ansatz für die Arbeit mit dem DOM ausprobieren, werden seine Vorteile im Allgemeinen sehr offensichtlich.  Natürlich gibt es auch Nachteile, aber nach den Nachteilen der üblichen Methoden sind sie unsichtbar. </p><br><p>  Vecty wird als reaktionsähnliches Framework bezeichnet, dies ist jedoch nicht ganz richtig.  Es gibt eine native GopherJS-Bibliothek für React - <a href="">myitcv.io/react</a> , aber ich halte es nicht für eine gute Idee, die Architekturlösungen von React für Go zu wiederholen.  Wenn Sie ein Frontend auf Vecty schreiben, wird plötzlich klar, wie viel einfacher es wirklich ist.  Plötzlich werden all diese verborgene Magie und die neuen Begriffe und Konzepte, die jedes JavaScript-Framework erfindet, überflüssig - sie sind nur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">noch komplexer</a> , nichts weiter.  Alles, was benötigt wird, ist, die Komponenten und ihr Verhalten klar und deutlich zu beschreiben und miteinander zu verbinden - Typen, Methoden und Funktionen, und das ist alles. </p><br><p>  Für CSS habe ich ein überraschend anständiges <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bulma-</a> Framework verwendet - es hat eine sehr klare Klassennamen und eine gute Struktur, und der deklarative UI-Code ist sehr gut lesbar. </p><br><p>  Die wahre Magie beginnt jedoch, wenn Sie Go-Code in JavaScript kompilieren.  Es klingt sehr einschüchternd, aber in der Tat rufen Sie einfach <code>gopherjs build</code> und in weniger als einer Sekunde haben Sie eine automatisch generierte JavaScript-Datei, die bereit ist, in Ihre grundlegende HTML-Seite aufgenommen zu werden (eine reguläre Anwendung besteht nur aus einem leeren Body-Tag und dessen Aufnahme JS-Skript).  Als ich diesen Befehl zum ersten Mal ausführte, erwartete ich viele Meldungen, Warnungen und Fehler, aber nein - er funktioniert fantastisch schnell und leise. Er druckt nur Einzeiler bei Kompilierungsfehlern, die vom Go-Compiler generiert werden. Das ist also sehr klar.  Es war jedoch noch cooler, Fehler in der Browserkonsole zu sehen, da Stapelspuren auf .go-Dateien und die richtige Zeile verweisen!  Das ist sehr cool. </p><br><h2 id="testirovanie-parametrov-qr-animacii">  Testen von QR-Animationsparametern </h2><br><p>  Mehrere Stunden lang hatte ich eine Webanwendung bereit, mit der ich die Parameter zum Testen schnell ändern konnte: </p><br><ul><li>  FPS - Bildrate </li><li>  QR-Frame-Größe - Wie viele Bytes sollten in jedem Frame sein? </li><li>  QR-Wiederherstellungsstufe - QR-Fehlerkorrekturstufe </li></ul><br><p>  und führen Sie den Test automatisch aus. </p><br><p><img src="https://habrastorage.org/webt/dl/51/my/dl51myjlg-kfbii5wxjx3ggu9tm.png" alt="Die App"></p><br><p>  Die mobile Anwendung musste natürlich auch automatisiert werden - sie musste verstehen, wann die nächste Runde mit neuen Parametern beginnt, wann der Empfang zu lange dauert und die Runde abbricht, die Ergebnisse an die Anwendung senden und so weiter. </p><br><p>  Der Haken war, dass die Webanwendung, während sie in der Browser-Sandbox ausgeführt wird, keine neuen Verbindungen erstellen kann. Wenn ich mich nicht irre, besteht die einzige Möglichkeit einer echten Peer-to-Peer-Verbindung zum Browser nur über WebRTC (ich muss NAT nicht durchschlagen ), aber es war zu umständlich.  Die Webanwendung kann nur ein Client sein. </p><br><p>  Die Lösung war einfach: Der Go-Webdienst, der die Webanwendung bereitstellte (und den Browser unter der gewünschten URL startete), startete auch den WebSocket-Proxy für zwei Clients.  Sobald zwei Clients beitreten, werden Nachrichten transparent von einer Verbindung an eine andere gesendet, sodass Clients (Webanwendung und mobiler Client) direkt kommunizieren können.  Sie müssen dafür natürlich in einem WIFI-Netzwerk sein. </p><br><p>  Es gab ein Problem, wie einem mobilen Gerät mitgeteilt werden konnte, wo tatsächlich eine Verbindung hergestellt werden soll, und es wurde mithilfe von ... QR-Code gelöst! </p><br><p>  Der Testprozess sieht folgendermaßen aus: </p><br><ul><li>  Eine mobile Anwendung sucht nach einem QR-Code mit einer Startmarkierung und einem Link zu einem WebSocket-Proxy </li><li>  Sobald das Token gelesen wurde, stellt die Anwendung eine Verbindung zu diesem WebSocket-Proxy her </li><li>  Die Webanwendung (die bereits mit dem Proxy verbunden ist) versteht, dass die mobile Anwendung bereit ist, und zeigt einen QR-Code mit der Markierung "Bereit für die nächste Runde?" an. </li><li>  Die mobile Anwendung erkennt das Signal, setzt den Decoder zurück und sendet über WebSocket die Nachricht „yep“. </li><li>  Nachdem die Webanwendung eine Bestätigung erhalten hat, generiert sie eine neue QR-Animation und dreht sie, bis sie die Ergebnisse oder das Zeitlimit erhält. </li><li>  Die Ergebnisse werden einer Platte hinzugefügt, neben der Sie sie sofort als CSV herunterladen können </li></ul><br><p><img src="https://habrastorage.org/webt/u_/gm/jx/u_gmjxdtzg16tus3pboxicibyuk.png" alt="Design"></p><br><p>  Infolgedessen blieb mir nur noch das Telefon auf ein Stativ zu stellen, die Anwendung zu starten, und dann erledigten die beiden Programme selbst die ganze Drecksarbeit und kommunizierten höflich über QR-Codes und WebSocket :) </p><br><p><img src="https://habrastorage.org/webt/b-/no/wn/b-nownnc3g_qjijctnqqwpjppri.gif" alt="Tester Demo"></p><br><p>  Am Ende habe ich die CSV-Datei mit den Ergebnissen heruntergeladen, sie an RStudio und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plotly Online Chart Maker gesendet</a> und die Ergebnisse analysiert. </p><br><h1 id="rezultaty">  Ergebnisse </h1><br><p>  Der vollständige Testzyklus dauert ungefähr 4 Stunden (leider musste der schwierigste Teil des Prozesses - das Generieren eines animierten GIF-Bildes mit QR-Frames - im Browser ausgeführt werden, und da sich der resultierende Code noch in JS befindet, wird nur ein Prozessor verwendet) Sie mussten darauf achten, dass der Bildschirm nicht plötzlich leer wurde oder eine Anwendung das Fenster mit der Webanwendung nicht schloss.  Folgende Parameter wurden getestet: </p><br><ul><li>  FPS - 3 bis 12 </li><li>  Die Größe des QR-Rahmens beträgt 100 bis 1000 Byte (in Schritten von 50). </li><li>  Alle 4 Stufen der QR-Fehlerkorrektur (niedrig, mittel, hoch, am höchsten) </li><li>  Übertragene Dateigröße - 13 KB zufällig generierte Bytes </li></ul><br><p>  Einige Stunden später lud ich CSV herunter und begann, die Ergebnisse zu analysieren. </p><br><p>  Ein Bild ist wichtiger als tausend Wörter, aber interaktive 3D-Visualisierungen sind wichtiger als tausend Bilder.  Hier ist eine Visualisierung der Ergebnisse (anklickbar): </p><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="qr_scan_results"><img src="https://habrastorage.org/getpro/habr/post_images/ba3/833/7f1/ba38337f18e68ef62245173481e497f7.png" alt="qr_scan_results" width="600"></a> <br><br><br><p>  Das beste Ergebnis war 1,4 Sekunden, was ungefähr 9 KB / s entspricht!  Dieses Ergebnis wurde mit einer Frequenz von 11 Bildern pro Sekunde, einer Bildgröße von 850 Bytes und einem durchschnittlichen Fehlerkorrekturniveau aufgezeichnet.  In den meisten Fällen übersprang der Kameradecoder jedoch bei dieser Geschwindigkeit einige Bilder und musste auf die nächste Wiederholung des fehlenden Bilds warten, was sich sehr negativ auf die Ergebnisse auswirkte - anstelle von zwei Sekunden konnte es leicht 15 oder eine Zeitüberschreitung von 30 Sekunden geben. </p><br><p>  Hier sind die Diagramme der Abhängigkeit der Ergebnisse von variablen Variablen: </p><br><h3 id="vremya--razmer-freyma">  Bildzeit / Größe </h3><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/pd/9c/rp/pd9crp3igj0djkv3uftlpxcgb2y.png" alt="Zeit gegen Größe"></a> </p><br><p>  Wie Sie sehen können, ist bei niedrigen Werten der Anzahl von Bytes in jedem Rahmen die überschüssige Codierung zu groß bzw. die Gesamtlesezeit zu groß.  Es gibt ein lokales Minimum von 500-600 Bytes pro Frame, aber die Werte daneben führen immer noch zu verlorenen Frames.  Das beste Ergebnis wurde bei 900 Bytes beobachtet, bei 1000 und mehr ist jedoch fast ein Frame-Verlust garantiert. </p><br><h3 id="vremya--fps">  Zeit / FPS </h3><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/-g/al/up/-galupwvvmk5k78p2bqgmsg1zme.png" alt="Zeit gegen FPS"></a> </p><br><p>  Der Wert der Anzahl der Bilder pro Sekunde hatte zu meiner Überraschung keinen sehr großen Effekt - kleine Werte erhöhten die Gesamtübertragungszeit zu stark und große die Wahrscheinlichkeit eines fehlenden Bilds.  Nach diesen Tests liegt der optimale Wert für die Geräte, auf denen ich getestet habe, im Bereich von 6 bis 7 Bildern pro Sekunde. </p><br><h3 id="vremya--uroven-korrekcii-oshibok">  Zeit- / Fehlerkorrekturstufe </h3><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/c4/2g/di/c42gdiq0sqjxynepawom9j6bpi4.png" alt="Zeit gegen Lvl"></a> </p><br><p>  Die Fehlerkorrekturstufe zeigte eine klare Beziehung zwischen der Dateiübertragungszeit und der Redundanzstufe, was nicht überraschend ist.  Der klare Gewinner ist hier die niedrige (L) Korrekturstufe - je weniger redundante Daten, desto besser lesbar ist der QR-Code für den Scanner mit derselben Datengröße.  Tatsächlich ist für dieses Experiment überhaupt keine Redundanz erforderlich, aber der Standard bietet keine solche Option. </p><br><p>  Für objektivere Daten sollte dieser Test natürlich hunderttausend Mal auf verschiedenen Geräten und Bildschirmen ausgeführt werden, aber für mein Wochenendexperiment war es mehr als genug Ergebnis. </p><br><h1 id="vyvody">  Schlussfolgerungen </h1><br><p>  Dieses amüsante Projekt hat bewiesen, dass eine einseitige Datenübertragung durch animierte Codes durchaus möglich ist. Für Situationen, in denen Sie eine kleine Menge ohne Netzwerke übertragen müssen, ist dies durchaus geeignet.  Obwohl mein maximales Ergebnis etwa 9 KB / s betrug, betrug die tatsächliche Geschwindigkeit in den meisten Fällen 1-2 KB / s. </p><br><p>  Ich habe es auch sehr genossen, Gomobile und GopherJS mit Vecty als routinemäßiges Werkzeug zur Problemlösung zu verwenden.  Dies sind sehr ausgereifte Projekte mit ausgezeichneter Arbeitsgeschwindigkeit und in den meisten Fällen Erfahrung "es funktioniert einfach". </p><br><p>  Schließlich bewundere ich immer noch, wie produktiv Sie mit Go sein können, wenn Sie genau wissen, was Sie implementieren möchten - der extrem kurze Zyklus „Ändern“ - „Zusammensetzen“ - „Prüfen“ ermöglicht es Ihnen, viel und häufig mit einfachem Code und dem Fehlen einer Klassenhierarchie in der Struktur zu experimentieren Programme ermöglichen es, sie unterwegs einfach und schmerzlos umzugestalten. Dank der fantastischen plattformübergreifenden Integration in die Sprache von Anfang an können Sie den Code einmal schreiben und auf dem Server, auf dem Webclient und in der nativen mobilen Anwendung verwenden.  Gleichzeitig gibt es trotz mehr als ausreichender Leistung immer noch viel Platz für Optimierung und Beschleunigung. </p><br><p>  Wenn Sie also noch nie Gomobile oder GopherJS ausprobiert haben, empfehle ich Ihnen, es bei der nächsten Gelegenheit zu versuchen.  Es wird eine Stunde Ihrer Zeit dauern, aber es kann eine ganz neue Ebene von Möglichkeiten in der Web- oder Mobilentwicklung eröffnen.  Fühlen Sie sich frei zu versuchen! </p><br><h1 id="ssylki">  Referenzen </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/divan/txqr</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/divan/txqr/tree/master/cmd/txqr-tester</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/divan/txqr-tester-ios</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/divan/txqr-reader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/gopherjs/vecty</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/golang/mobile</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430688/">https://habr.com/ru/post/de430688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430678/index.html">Test von zehn Dimmern mit LED-Lampen</a></li>
<li><a href="../de430680/index.html">Schreiben eines einfachen Prozessors und einer Umgebung dafür</a></li>
<li><a href="../de430682/index.html">Drei Jahre Mond-Mikrosatelliten-Projekt: Stadien des Erwachsenwerdens</a></li>
<li><a href="../de430684/index.html">Scannen von Live Ethereum-Verträgen auf nicht aktivierte Sendefehler. Teil 2</a></li>
<li><a href="../de430686/index.html">Überblick: WAZERs erste Wasserstrahlschneidemaschine</a></li>
<li><a href="../de430690/index.html">Deterministische Ausnahmen und Fehlerbehandlung in „C ++ der Zukunft“</a></li>
<li><a href="../de430692/index.html">Social Engineering mit APPX-Software (Universal Windows Platform)</a></li>
<li><a href="../de430694/index.html">Eine kurze Anleitung zum Erlernen von C ++: Was, wann und worauf soll erstellt werden?</a></li>
<li><a href="../de430700/index.html">Ein einheitliches System zur Aufzeichnung von Online-Filmansichten wird in Russland funktionieren</a></li>
<li><a href="../de430702/index.html">Sehr seltsames Training</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>