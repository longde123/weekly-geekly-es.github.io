<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤛🏽 🎽 😁 Chargement d'images paresseuses à l'aide d'IntersectionObserver 🕴🏾 ✌🏻 😲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De nos jours, la principale pierre d'achoppement sur le chemin vers des sites de chargement à grande vitesse est l'image. Cela est particulièrement vr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Chargement d'images paresseuses à l'aide d'IntersectionObserver</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/423485/">  De nos jours, la principale pierre d'achoppement sur le chemin vers des sites de chargement à grande vitesse est l'image.  Cela est particulièrement vrai pour les projets de commerce électronique.  Les images qui s'y trouvent, généralement assez «lourdes», constituent l'essentiel du contenu des pages.  Ceci, en règle générale, conduit au fait que pour afficher une page à l'utilisateur, son navigateur doit télécharger plusieurs mégaoctets de données graphiques.  Comment accélérer le chargement des pages dans cette situation?  La réponse à cette question est consacrée au matériel dont nous publions aujourd'hui la traduction. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/943/040/c54/943040c5465e609d529aaa40f4f81f67.jpg" alt="image"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Dispositions générales</font> </h2><br>  Considérez, par exemple, la page d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">accueil du</a> département <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Home</a> de Walmart. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e09/717/79a/e0971779a66d1ee7c507d8db410dbb2b.gif"></div><br>  <i><font color="#999999">Une page avec de nombreuses images</font></i> <br><br>  Voici des informations sur le nombre d'images chargées pour former cette page: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/584/5d9/139/5845d91397a03e5e6763a0b953d72f93.png"></div><br>  <i><font color="#999999">Images chargées lors de la formation de la page</font></i> <br><br>  Comme vous pouvez le voir, il y a 137 images!  Cela signifie que plus de 80% des données nécessaires à l'affichage de la page et transmises sur le réseau sont présentées sous forme de fichiers graphiques. <br><br>  Nous analysons maintenant les requêtes réseau qui sont exécutées au chargement de la page: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f42/618/dae/f42618daedd718f3766010a6a8a8cde3.png"></div><br>  <i><font color="#999999">Requêtes réseau exécutées lors de la formation de la page</font></i> <br><br>  Dans ce cas, les fichiers résultant de la séparation du code projet sont téléchargés plus tard qu'ils ne le pouvaient.  Cela est dû au fait que vous devez d'abord charger le bundle principal <code>cp_ny.bundle</code> .  Cet ensemble pourrait être téléchargé beaucoup plus rapidement s'il n'avait pas été perturbé par 18 images en concurrence les unes avec les autres pour la bande passante. <br><br>  Comment y remédier?  En fait, pour vraiment «réparer» cela ne fonctionnera pas, mais vous pouvez faire beaucoup de choses afin d'optimiser le chargement de l'image.  Il existe de nombreuses approches pour optimiser les images utilisées sur les pages Web.  Parmi eux, l'utilisation de divers formats de fichiers graphiques, la compression des données, l'utilisation de la technique d'animation floue, l'utilisation de CDN.  Je voudrais m'arrêter sur le soi-disant "chargement paresseux" des images (chargement paresseux).  En particulier, nous parlerons de la façon de mettre en œuvre cette technique sur les sites React, mais comme elle est basée sur des mécanismes JavaScript, elle peut être intégrée dans n'importe quel projet Web. <br><br><h2>  <font color="#3AC1EF">Projet pilote</font> </h2><br>  Commençons par un composant <code>Image</code> React extrêmement simple: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Image</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ render() {   const { src } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props;   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;img align=<span class="hljs-string"><span class="hljs-string">"center"</span></span> src={src} /&gt;; } }</code> </pre> <br>  Il prend comme propriété une URL et l'utilise pour rendre l'élément HTML <code>img</code> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici le</a> code JSFiddle pertinent.  L'image suivante montre la page contenant ce composant.  Veuillez noter que pour voir l'image affichée par lui, vous devez faire défiler le contenu de la page. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/754/978/b57/754978b574f4cc42960bda55487491a0.gif"></div><br>  <i><font color="#999999">La page avec le composant qui affiche l'image</font></i> <br><br>  Afin de mettre en œuvre la technique de chargement paresseux d'images dans ce composant, vous devez effectuer les trois étapes suivantes: <br><br><ol><li>  Ne restituez pas l'image immédiatement après le téléchargement. </li><li>  Configurez des outils pour détecter l'apparence d'une image dans la zone de visualisation du contenu de la page. </li><li>  Affichez l'image après avoir détecté qu'elle est tombée dans la zone de visualisation. </li></ol><br>  Jetons un coup d'œil à ces étapes. <br><br><h2>  <font color="#3AC1EF">Étape 1</font> </h2><br>  À cette étape, l'image immédiatement après le chargement n'est pas affichée. <br><br><pre> <code class="hljs kotlin">render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;img /&gt;; }</code> </pre> <br><h2>  <font color="#3AC1EF">Étape 2</font> </h2><br>  Ici, nous configurons les mécanismes qui nous permettent de détecter le moment où l'image entre dans la zone de visualisation. <br><br><pre> <code class="hljs coffeescript">componentDidMount() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.observer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntersectionObserver(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        }, {   root: <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">".container"</span></span>) }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.observer.observe(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element); } .... render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;img ref={el =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element = el} /&gt;; }</code> </pre> <br>  Analysons ce code.  Voici ce qui a été fait ici: <br><br><ul><li>  L'attribut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ref</a> a été ajouté à l'élément <code>img</code> .  Cela vous permet de mettre à jour ultérieurement le lien d'image dans <code>src</code> sans avoir à restituer le composant. </li><li>  Une nouvelle instance d' <code>IntersectionObserver</code> (nous en parlerons ci-dessous). </li><li>  L'objet <code>IntersectionObserver</code> est invité à observer l'image à l'aide de la construction <code>observe(this.element)</code> . </li></ul><br>  Qu'est-ce que <code>IntersectionObserver</code> ?  Considérant que le mot «intersection» est traduit par «intersection» et «observateur» est «observateur», on peut déjà deviner le rôle de cet objet.  Si vous recherchez des informations à ce sujet sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MDN</a> , vous pouvez découvrir que l'API Intersection Observer permet aux applications Web de surveiller de manière asynchrone les changements dans l'intersection d'un élément avec son parent ou la portée d'un document de fenêtre. <br><br>  À première vue, cette caractéristique de l'API peut ne pas sembler particulièrement compréhensible, mais, en fait, sa structure est très simple.  L'instance <code>IntersectionObserver</code> reçoit plusieurs paramètres.  En particulier, nous avons utilisé le paramètre <code>root</code> , qui nous permet de définir l'élément racine DOM, que nous considérons comme un conteneur, à propos de l'intersection de l'élément avec la frontière dont nous avons besoin de connaître.  Par défaut, c'est la zone dans laquelle se trouve le fragment visible de la page (fenêtre), mais je l'ai explicitement défini pour utiliser le conteneur situé dans l'élément <code>iframe</code> de JSFiddle.  Ceci est fait afin, plus tard, d'envisager une possibilité qui n'est pas conçue pour utiliser des éléments <code>iframe</code> . <br><br>  La raison pour laquelle utiliser <code>IntersectionObserver</code> pour déterminer le moment où un élément devient visible est plus populaire que les méthodes plus traditionnelles, telles que l'utilisation <code>onScroll</code> et <code>getBoundingClientRect()</code> , car les mécanismes <code>IntersectionObserver</code> s'exécutent en dehors du thread principal.  Cependant, le rappel appelé après que <code>IntersectionObserver</code> détecte que l'intersection de l'élément avec le conteneur est exécuté naturellement dans le thread principal, donc son code ne doit pas être trop lourd. <br><br><h2>  <font color="#3AC1EF">Étape 3</font> </h2><br>  Nous devons maintenant configurer le rappel qui est appelé lorsqu'il détecte l'intersection de l'élément <code>target</code> ( <code>this.element</code> dans notre cas) avec le conteneur <code>root</code> (dans notre cas, c'est un élément <code>div</code> <code>.container</code> ). <br><br><pre> <code class="hljs kotlin">.... <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.observer = new IntersectionObserver( entries =&gt; {   entries.forEach(entry =&gt; {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { isIntersecting } = entry;     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isIntersecting) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element.src = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.src;       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.observer = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.observer.disconnect();     }   }); }, {   root: document.querySelector(<span class="hljs-string"><span class="hljs-string">".container"</span></span>) } ); ....</code> </pre> <br>  Lorsque l'intersection est détectée, le tableau d' <code>entries</code> transféré vers le <code>entries</code> , qui ressemble à un ensemble d'instantanés de l'état de tous les éléments cibles pour lesquels l'intersection de la bordure spécifiée est détectée.  La propriété <code>isIntersecting</code> indique la direction de l'intersection.  Si l'élément surveillé ne fait pas partie de l'élément racine, c'est <code>true</code> .  Si un élément quitte l'élément racine, alors c'est <code>false</code> . <br><br>  Donc, quand il s'avère que l'élément a traversé la bordure inférieure du conteneur, je définis manuellement sa propriété <code>src</code> et désactive sa surveillance, ce qui n'est plus nécessaire. <br><br><h2>  <font color="#3AC1EF">Étape 4 (secrète)</font> </h2><br>  Maintenant, à la quatrième étape secrète de notre travail, vous pouvez admirer le résultat et profiter du succès.  Voici le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code</a> qui recueille ce dont nous venons de parler. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edf/b5c/4e3/edfb5c4e3ab3bd515f11e96fe0e8d8ac.gif"></div><br>  <i><font color="#999999">Le résultat de l'application de la technique de chargement d'image paresseuse</font></i> <br><br>  Cependant, si vous regardez de plus près ce que nous avons, il se trouve qu'ici vous pouvez trouver quelque chose de pas très bon.  Afin de voir cela, j'ai rapidement fait défiler la page, tout en ralentissant la vitesse de la connexion réseau. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/400/c00/2ce/400c002ce3f46f27875c40288bf39f4f.gif"></div><br>  <i><font color="#999999">Comportement de la page lorsqu'elle défile rapidement et ralentit la vitesse de connexion réseau</font></i> <br><br>  Comme nous ne chargeons l'image qu'après avoir atteint la zone dans laquelle elle devrait déjà être visible, l'utilisateur n'a pas la possibilité de faire défiler la page et de voir la zone occupée par l'image, et, bien sûr, l'image elle-même, avant de la charger.  Lorsque des sites consultent des ordinateurs ordinaires connectés à Internet rapide, cela ne pose aucun problème.  Mais de nombreux utilisateurs modernes visitent des sites depuis leur téléphone, parfois ils utilisent des réseaux 3G ou, pire encore, des connexions EDGE. <br><br>  Certes, traiter ce problème n'est pas si difficile.  Cela peut être dû au fait que l'API Intersection Observer offre au développeur la possibilité d'étendre ou de réduire les limites de l'élément racine (dans notre cas, c'est l'élément <code>.container</code> ).  Afin d'utiliser cette opportunité, ajoutez simplement une ligne de code à l'endroit où le conteneur racine est configuré: <br><br><pre> <code class="hljs objectivec">rootMargin: <span class="hljs-string"><span class="hljs-string">"0px 0px 200px 0px"</span></span></code> </pre> <br>  Dans la propriété <code>rootMargin</code> , écrivez une ligne dont la structure est conforme aux règles CSS utilisées pour configurer l'indentation des éléments.  Dans notre cas, nous informons le système que la bordure inférieure utilisée pour détecter l'intersection d'un élément avec un conteneur doit être augmentée de 200 pixels.  Cela signifie que le rappel correspondant sera appelé lorsque l'élément tombe dans une zone située à 200 pixels sous la bordure inférieure de l'élément racine (la valeur par défaut est 0). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici le</a> code qui implémente cette technique. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae8/e52/257/ae8e52257adaf3205addb04ac82dc10a.gif"></div><br>  <i><font color="#999999">Amélioration de la technique de chargement d'images paresseuses</font></i> <br><br>  En conséquence, il s'avère que lorsque nous faisons défiler la page uniquement vers le 4ème élément de la liste, l'image est chargée dans une zone qui est à 200 pixels en dessous de la zone visible de la page. <br>  Maintenant, il semblerait, tout ce qui est nécessaire est fait.  Mais ce n'est pas le cas. <br><br><h2>  <font color="#3AC1EF">Problème de hauteur d'image</font> </h2><br>  Si vous avez soigneusement étudié les illustrations GIF ci-dessus, vous remarquerez peut-être que la barre de défilement fait un "saut" après le chargement de l'image.  Heureusement, ce problème est facile à gérer.  Sa raison en est que l'élément qui affiche l'image a initialement une hauteur de 0 qui, après chargement de l'image, s'avère être de 300 pixels.  Par conséquent, pour résoudre le problème, il suffit de définir l'élément à une hauteur fixe en ajoutant l'attribut <code>height={300}</code> à l'image. <br><br><h2>  <font color="#3AC1EF">À propos des résultats d'optimisation</font> </h2><br>  Quels résultats avons-nous obtenus chez Walmart après avoir appliqué le chargement d'images paresseuses sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette</a> page?  En fait, les résultats spécifiques varient considérablement en fonction de nombreuses circonstances, parmi lesquelles on peut noter la vitesse de connexion réseau du client, la disponibilité du CDN, le nombre d'images sur la page et les règles de détection des intersections avec l'élément racine qui leur est appliqué.  En d'autres termes, pour vous, afin d'évaluer l'impact du chargement paresseux d'images sur votre propre projet, il est préférable de l'implémenter et de le vérifier vous-même.  Mais si vous êtes toujours intéressé à regarder ce que le chargement d'images paresseux nous a donné, voici quelques rapports Lighthouse.  Le premier est formé avant l'optimisation, le second après. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/547/4c8/698/5474c8698697e0489dd1ba213970b244.png"></div><br>  <i><font color="#999999">Rapport sur les phares généré avant l'optimisation</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/203/c82/7ec/203c827ec729a55597ac33568672365e.png"></div><br>  <i><font color="#999999">Rapport phare généré après optimisation</font></i> <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  Aujourd'hui, nous avons examiné une technique pour optimiser les pages Web à l'aide du chargement d'images paresseuses.  Si les pages de votre site sont remplies d'images, alors, très probablement, cette technique vous sera utile. <br><br>  <b>Chers lecteurs!</b>  Comment optimisez-vous les images et leur chargement? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr423485/">https://habr.com/ru/post/fr423485/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr423475/index.html">Pirater le code du vieillissement: une nouvelle science sur le vieillissement et ce que signifie rester jeune</a></li>
<li><a href="../fr423477/index.html">Soyez un ninja de la sécurité: commencez votre chemin vers les hauteurs de l'IB</a></li>
<li><a href="../fr423479/index.html">"First": s'il faut voler vers Mars</a></li>
<li><a href="../fr423481/index.html">Je dois augmenter le cluster Kubernetes, mais je ne suis qu'un programmeur de code. Il y a un moyen de sortir</a></li>
<li><a href="../fr423483/index.html">Trouver la bonne façon de séparer le contenu d'un site Web à l'aide de Webpack</a></li>
<li><a href="../fr423487/index.html">Node.js sans node_modules</a></li>
<li><a href="../fr423489/index.html">Je suis médecin urgentiste et je veux parler du nouvel électrocardiogramme Apple Watch</a></li>
<li><a href="../fr423491/index.html">PHP Digest n ° 139 (du 3 au 17 septembre 2018)</a></li>
<li><a href="../fr423493/index.html">Android Go est le futur milliard d'appareils et une limite de 50 Mo. Conférence Yandex</a></li>
<li><a href="../fr423495/index.html">Que contient XGBoost et qu'est-ce que Go a à voir avec cela?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>