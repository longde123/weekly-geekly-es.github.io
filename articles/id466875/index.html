<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤸🏻 😍 🎴 Nasib menyedihkan specifier format fungsi printf untuk karakter Unicode di Visual C ++ 🧖 🙌🏾 🖖🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dukungan Unicode pada Windows muncul lebih awal daripada kebanyakan sistem operasi lain. Karena itu, banyak masalah yang terkait dengan representasi k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nasib menyedihkan specifier format fungsi printf untuk karakter Unicode di Visual C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/466875/">  Dukungan Unicode pada Windows muncul lebih awal daripada kebanyakan sistem operasi lain.  Karena itu, banyak masalah yang terkait dengan representasi karakter di Windows tidak diselesaikan dengan cara yang sama seperti pada sistem lain yang pengembangnya menunda implementasi standar baru sampai waktu yang lebih baik [1].  Contoh paling jelas: pada Windows, pengkodean UCS-2 digunakan untuk mewakili karakter Unicode.  Direkomendasikan oleh Konsorsium Unicode karena versi 1.0 hanya mendukung 65.536 karakter [2].  Lima tahun kemudian, Konsorsium berubah pikiran, tetapi pada saat itu sudah terlambat untuk mengubah sesuatu di Windows, karena Win32s, Windows NT 3.1, Windows NT 3.5, Windows NT 3.51 dan Windows 95 telah dirilis ke pasar - mereka semua menggunakan pengkodean UCS -2 [3]. <br><br>  Tetapi hari ini kita akan berbicara tentang rangkaian format fungsi <i>printf</i> . <br><a name="habracut"></a><br>  Karena Unicode diadopsi pada Windows lebih awal daripada di C, ini berarti bahwa pengembang Microsoft harus mencari cara untuk menerapkan dukungan untuk standar ini dalam runtime C. Akibatnya, fitur seperti <i>wcscmp</i> , <i>wcschr,</i> dan <i>wprintf muncul</i> .  Adapun untuk memformat string di <i>printf</i> , kualifikasi berikut diperkenalkan untuk mereka: <br><br><ul><li>  <b><i>% s</i></b> mewakili string dengan lebar yang sama dengan string format; </li><li>  <b><i>% S</i></b> mewakili string dengan lebar terbalik dengan lebar string format; </li><li>  <b><i>% hs</i></b> mewakili string biasa terlepas dari lebar string format; </li><li>  <b><i>% ws</i></b> dan <b><i>% ls</i></b> mewakili string lebar terlepas dari lebar string format. </li></ul><br>  Idenya adalah menulis kode seperti ini: <br><br><pre><code class="cpp hljs">TCHAR buffer[<span class="hljs-number"><span class="hljs-number">256</span></span>]; GetSomeString(buffer, <span class="hljs-number"><span class="hljs-number">256</span></span>); _tprintf(TEXT(<span class="hljs-string"><span class="hljs-string">"The string is %s.\n"</span></span>), buffer);</code> </pre> <br>  Dan saat kompilasi dalam mode ANSI, dapatkan hasil ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buffer[<span class="hljs-number"><span class="hljs-number">256</span></span>]; GetSomeStringA(buffer, <span class="hljs-number"><span class="hljs-number">256</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"The string is %s.\n"</span></span>, buffer);</code> </pre> <br>  Dan ketika mengkompilasi dalam mode Unicode - ini [4]: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span> buffer[<span class="hljs-number"><span class="hljs-number">256</span></span>]; GetSomeStringW(buffer, <span class="hljs-number"><span class="hljs-number">256</span></span>); wprintf(<span class="hljs-string"><span class="hljs-string">L"The string is %s.\n"</span></span>, buffer);</code> </pre> <br>  Karena specifier <i>% s</i> menerima string dengan lebar yang sama dengan string format, kode ini akan berfungsi dengan baik dalam format ANSI dan Unicode.  Juga, solusi ini sangat menyederhanakan konversi kode yang sudah ditulis dari format ANSI ke format Unicode, karena string dari lebar yang diperlukan diganti untuk penspesifikasi <i>% s</i> . <br><br>  Ketika dukungan Unicode secara resmi ditambahkan ke C99, komite standardisasi bahasa C mengadopsi model string format yang berbeda untuk fungsi <i>printf</i> : <br><br><ul><li>  <b><i>% s</i></b> dan <b><i>% hs</i></b> mewakili string biasa; </li><li>  <b><i>% ls</i></b> mewakili string lebar. </li></ul><br>  Di situlah masalah dimulai.  Selama enam tahun terakhir pada saat itu, sejumlah besar program dengan volume miliaran baris ditulis untuk Windows, dan mereka menggunakan format lama.  Bagaimana cara menjadi kompiler Visual C dan C ++? <br><br>  Diputuskan untuk tetap menggunakan model lama yang tidak standar, agar tidak merusak semua program Windows yang ada di dunia. <br><br>  Jika Anda ingin kode Anda berfungsi di kedua lingkungan runtime yang mematuhi aturan klasik untuk <i>printf</i> dan yang mengikuti aturan standar C, Anda harus membatasi diri Anda pada <i>% hs</i> specifier untuk string reguler dan <i>% ls</i> untuk string lebar.  Dalam hal ini, kesegaran hasil dijamin, terlepas dari apakah string format dilewatkan ke fungsi <i>sprintf</i> atau <i>wsprintf</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> UNICODE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TSTRINGWIDTH TEXT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"l"</span></span></span><span class="hljs-meta">) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TSTRINGWIDTH TEXT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"h"</span></span></span><span class="hljs-meta">) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> TCHAR buffer[256]; GetSomeString(buffer, 256); _tprintf(TEXT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"The string is %"</span></span></span><span class="hljs-meta">) TSTRINGWIDTH TEXT(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"s\n"</span></span></span><span class="hljs-meta">), buffer); char buffer[256]; GetSomeStringA(buffer, 256); printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"The string is %hs\n"</span></span></span><span class="hljs-meta">, buffer); wchar_t buffer[256]; GetSomeStringW(buffer, 256); wprintf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"The string is %ls\n"</span></span></span><span class="hljs-meta">, buffer);</span></span></code> </pre> <br>  Definisi <b><i>TSTRINGWIDTH yang</i></b> terpisah memungkinkan <b><i>Anda</i></b> untuk menulis, misalnya, kode ini: <br><br><pre> <code class="cpp hljs">_tprintf(TEXT(<span class="hljs-string"><span class="hljs-string">"The string is %10"</span></span>) TSTRINGWIDTH TEXT(<span class="hljs-string"><span class="hljs-string">"s\n"</span></span>), buffer);</code> </pre> <br>  Karena orang-orang menyukai penyajian informasi tabular, inilah tabel untuk Anda. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/t1/jn/_w/t1jn_wpvdvdebnzak5mqdxu3mb8.png"></div><br>  Saya menyoroti garis dengan kualifikasi, yang didefinisikan dalam C dengan cara yang sama seperti dalam format klasik yang diadopsi di Windows [5].  Gunakan kualifikasi ini jika Anda ingin kode Anda menghasilkan hasil yang sama di kedua format. <br><br>  <b>Catatan</b> <br><br>  [1] Tampaknya pengenalan Unicode di Windows sebelum sistem lain seharusnya memberi Microsoft keuntungan dari langkah pertama, tetapi - setidaknya dalam kasus Unicode - itu berubah menjadi "kutukan pelopor" bagi mereka, karena sisanya memutuskan untuk hanya menunggu sampai waktu yang lebih baik, ketika akan ada solusi yang lebih menjanjikan (seperti pengkodean UTF-8), dan hanya setelah itu memperkenalkan Unicode dalam sistem mereka. <br><br>  [2] Rupanya, mereka percaya bahwa 65.536 karakter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seharusnya sudah cukup untuk semua orang</a> . <br><br>  [3] Itu kemudian digantikan oleh UTF-16.  Untungnya, UTF-16 kompatibel dengan UCS-2 untuk karakter kode yang dapat direpresentasikan dalam kedua pengkodean. <br><br>  [4] Secara resmi, versi Unicode akan terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> buffer[<span class="hljs-number"><span class="hljs-number">256</span></span>]; GetSomeStringW(buffer, <span class="hljs-number"><span class="hljs-number">256</span></span>); wprintf(<span class="hljs-string"><span class="hljs-string">L"The string is %s.\n"</span></span>, buffer);</code> </pre> <br>  Faktanya adalah bahwa <i>wchar_t</i> belum menjadi tipe independen, dan sampai ditambahkan ke standar, itu hanya sinonim untuk <i>short unsigned</i> .  Liku-liku nasib <i>wchar_t</i> dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel terpisah</a> . <br><br>  [5] Format klasik yang dikembangkan oleh Windows muncul pertama kali, jadi itu lebih mungkin bahwa standar C harus beradaptasi dengannya, dan bukan sebaliknya. <br><br>  <b>Catatan Penerjemah</b> <br><br>  Saya berterima kasih kepada penulis untuk publikasi ini.  Sekarang menjadi jelas bagaimana semua kebingungan ini dengan "% s" ternyata.  Faktanya adalah bahwa pengguna kami terus-menerus mengajukan pertanyaan mengapa PVS-Studio bereaksi berbeda terhadap kode mereka, seperti yang terlihat bagi mereka, "portabel", tergantung pada apakah mereka mengumpulkan proyek mereka di Linux atau Windows.  Itu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perlu untuk membuat</a> bagian terpisah khusus dalam deskripsi diagnostik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V576 yang</a> ditujukan untuk topik ini (lihat "Garis lebar").  Setelah artikel ini, semuanya menjadi lebih jelas dan jelas.  Saya pikir catatan ini harus dibaca untuk semua orang yang mengembangkan aplikasi lintas platform.  Baca dan beri tahu kolega. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466875/">https://habr.com/ru/post/id466875/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466859/index.html">Menggunakan Layanan Federasi AD untuk Memberi Otorisasi Pengguna AWS dengan Distribusi Hak</a></li>
<li><a href="../id466861/index.html">Cara melarikan diri dari kenyataan menggunakan hackathon</a></li>
<li><a href="../id466863/index.html">Menyiapkan Asymptote</a></li>
<li><a href="../id466865/index.html">Menunggu tanggal 1 November: larangan atau legalisasi cryptocurrency</a></li>
<li><a href="../id466873/index.html">5 hal yang paling baru untuk JavaScript tidak mengerti</a></li>
<li><a href="../id466877/index.html">Malicious Sustes telah diperbarui dan sekarang menyebar melalui kerentanan Exim (CVE-2019-10149)</a></li>
<li><a href="../id466879/index.html">Teknik Pengujian Terbaik dalam JavaScript dan Node.js</a></li>
<li><a href="../id466881/index.html">Ivan Shamatov: cara menulis uang</a></li>
<li><a href="../id466887/index.html">Hanya divisi, atau cara membuat teori matematika dan dapatkan $ 400K di atasnya</a></li>
<li><a href="../id466889/index.html">Status zona domain Baltik untuk Agustus 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>