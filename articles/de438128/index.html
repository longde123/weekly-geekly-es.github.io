<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔶 🧑🏾‍🤝‍🧑🏼 👩🏾‍🤝‍👩🏻 Viele Zeichen - viele neuronale Netze: Wie kann ein effektives Erkennungssystem für eine große Anzahl von Klassen aufgebaut werden? 🧕🏼 👨🏾‍💻 🚩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In früheren Artikeln haben sie bereits darüber geschrieben, wie unsere Texterkennungstechnologie funktioniert: 

 Seriennavigator 

- Texterkennung in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Viele Zeichen - viele neuronale Netze: Wie kann ein effektives Erkennungssystem für eine große Anzahl von Klassen aufgebaut werden?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/abbyy/blog/438128/">  In früheren Artikeln haben sie bereits darüber geschrieben, wie unsere Texterkennungstechnologie funktioniert: <br><br><div class="spoiler">  <b class="spoiler_title">Seriennavigator</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Texterkennung in ABBYY FineReader (1/2)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Texterkennung in ABBYY FineReader (2/2)</a> </li></ul><br></div></div><br>  Bis 2018 wurde die Erkennung japanischer und chinesischer Schriftzeichen auf die gleiche Weise angeordnet: hauptsächlich unter Verwendung von Raster- und Feature-Klassifikatoren.  Aber mit dem Erkennen von Hieroglyphen gibt es Schwierigkeiten: <br><br><ol><li>  Eine große Anzahl von Klassen, die unterschieden werden müssen. </li><li>  Komplexerer Gerätecharakter als Ganzes. </li></ol><br><img src="https://habrastorage.org/webt/fy/p7/yu/fyp7yudyxpraxbdsegon8y7w_xa.png" alt="Bild"><br><br>  Es ist ebenso schwierig, eindeutig zu sagen, wie viele Zeichen das chinesische Alphabet schriftlich hat, wie es genau ist, wie viele Wörter auf Russisch zu zählen.  In der chinesischen Schrift werden jedoch meistens ~ 10.000 Zeichen verwendet.  Mit ihnen haben wir die Anzahl der zur Anerkennung verwendeten Klassen begrenzt. <br><br>  Beide oben beschriebenen Probleme führen auch dazu, dass Sie eine große Anzahl von Zeichen verwenden müssen, um eine hohe Qualität zu erzielen, und diese Zeichen selbst werden auf den Bildern von Zeichen länger berechnet. <br><br>  Damit diese Probleme nicht zu einer starken Verlangsamung des gesamten Erkennungssystems führten, musste ich viele Heuristiken verwenden, die in erster Linie darauf abzielten, eine erhebliche Anzahl von Hieroglyphen schnell abzuschneiden, wie dieses Bild definitiv nicht aussieht.  Es hat bis zum Ende immer noch nicht geholfen, aber wir wollten unsere Technologie auf ein ganz neues Niveau bringen. <br><br>  Wir haben begonnen, die Anwendbarkeit von Faltungs-Neuronalen Netzen zu untersuchen, um sowohl die Qualität als auch die Erkennungsgeschwindigkeit von Hieroglyphen zu verbessern.  Ich wollte die gesamte Einheit für die Erkennung eines einzelnen Zeichens für diese Sprachen mithilfe neuronaler Netze ersetzen.  In diesem Artikel werden wir beschreiben, wie es uns letztendlich gelungen ist. <br><a name="habracut"></a><br><h2>  Ein einfacher Ansatz: Ein Faltungsnetzwerk, um alle Hieroglyphen zu erkennen </h2><br>  Im Allgemeinen ist die Verwendung von Faltungsnetzwerken zur Zeichenerkennung überhaupt keine neue Idee.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Historisch gesehen wurden sie</a> bereits 1998 genau für diese Aufgabe eingesetzt.  Das waren zwar keine gedruckten Zeichen, sondern handgeschriebene englische Buchstaben und Zahlen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yg/fi/se/ygfisegze1bli8r9nyakftguapu.png"></div><br><br>  In über 20 Jahren hat die Technologie im Bereich des tiefen Lernens natürlich Fortschritte gemacht.  Einschließlich fortschrittlicherer Architekturen und neuer Lernansätze. <br><br>  Die im obigen Diagramm (LeNet) dargestellte Architektur eignet sich heute sehr gut für einfache Aufgaben wie die Erkennung von gedrucktem Text.  "Einfach" nenne ich es im Vergleich zu anderen Aufgaben der Bildverarbeitung wie der Suche und Erkennung von Gesichtern. <br><br>  Es scheint, dass die Lösung nirgends einfacher ist.  Wir nehmen ein neuronales Netzwerk, eine Stichprobe markierter Hieroglyphen, und trainieren es für das Klassifizierungsproblem.  Leider stellte sich heraus, dass nicht alles so einfach ist.  Alle möglichen Änderungen von LeNet für die Klassifizierung von 10.000 Hieroglyphen lieferten keine ausreichende Qualität (zumindest vergleichbar mit dem bereits vorhandenen Erkennungssystem). <br><br>  Um die erforderliche Qualität zu erreichen, mussten wir tiefere und komplexere Architekturen berücksichtigen: WideResNet, SqueezeNet usw.  Mit ihrer Hilfe war es möglich, das erforderliche Qualitätsniveau zu erreichen, aber sie gaben einen starken Geschwindigkeitsabfall - 3-5 mal im Vergleich zum Basisalgorithmus auf der CPU. <br><br>  Jemand könnte fragen: "Was bringt es, die Geschwindigkeit des Netzwerks auf der CPU zu messen, wenn es auf dem Grafikprozessor (GPU) viel schneller arbeitet?"  An dieser Stelle sei darauf hingewiesen, dass die Geschwindigkeit des Algorithmus auf der CPU in erster Linie für uns wichtig ist.  Wir entwickeln Technologien für die große Produktpalette von ABBYY.  In den meisten Szenarien erfolgt die Erkennung auf der Clientseite, und wir können nicht wissen, dass eine GPU vorhanden ist. <br><br>  Am Ende kamen wir also zu folgendem Problem: Ein neuronales Netzwerk zum Erkennen aller Zeichen in Abhängigkeit von der Wahl der Architektur funktioniert entweder zu schlecht oder zu langsam. <br><br><h2>  Zwei-Ebenen-Hieroglyphenerkennungsmodell für neuronale Netze </h2><br>  Ich musste nach einem anderen Weg suchen.  Gleichzeitig wollte ich neuronale Netze nicht aufgeben.  Es schien, dass das größte Problem eine große Anzahl von Klassen war, weshalb es notwendig war, Netzwerke komplexer Architektur aufzubauen.  Aus diesem Grund haben wir beschlossen, kein Netzwerk für eine große Anzahl von Klassen, dh für das gesamte Alphabet, zu trainieren, sondern viele Netzwerke für eine kleine Anzahl von Klassen (Teilmengen des Alphabets) zu trainieren. <br><br>  Im Allgemeinen wurde das ideale System wie folgt dargestellt: Das Alphabet ist in Gruppen ähnlicher Zeichen unterteilt.  Das Netzwerk der ersten Ebene klassifiziert, zu welcher Zeichengruppe ein bestimmtes Bild gehört.  Für jede Gruppe wird wiederum ein Netzwerk der zweiten Ebene trainiert, das die endgültige Klassifizierung innerhalb jeder Gruppe erstellt. <br><br>  <i>Klickbares Bild</i> <br> <a href=""><img src="https://habrastorage.org/webt/lg/r9/a1/lgr9a1ibz_vktq5xvkzqquawd7k.png"></a> <br><br>  Daher nehmen wir die endgültige Klassifizierung vor, indem wir zwei Netzwerke starten: Das erste bestimmt, welches Netzwerk der zweiten Ebene gestartet werden soll, und das zweite führt bereits die endgültige Klassifizierung durch. <br><br>  Tatsächlich ist der grundlegende Punkt hier, wie die Zeichen in Gruppen unterteilt werden, damit das Netzwerk der ersten Ebene genau und schnell erstellt werden kann. <br><br><h2>  Erstellen eines Klassifikators der ersten Ebene </h2><br>  Um zu verstehen, welche Netzwerksymbole leichter zu unterscheiden und welche schwieriger sind, ist es am einfachsten zu untersuchen, welche Zeichen für bestimmte Symbole hervorstechen.  Zu diesem Zweck haben wir ein Klassifikator-Netzwerk verwendet, das darauf trainiert ist, alle Zeichen des Alphabets mit guter Qualität zu unterscheiden, und die Aktivierungsstatistik der vorletzten Schicht dieses Netzwerks untersucht. Wir haben begonnen, die endgültigen Feature-Darstellungen zu untersuchen, die das Netzwerk für alle Zeichen erhält. <br><br>  Gleichzeitig wussten wir, dass das Bild dort ungefähr so ​​aussehen sollte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sr/bw/el/srbwele_woukv5qioz-qr6vdq6g.png"></div><br><br>  Dies ist ein einfaches Beispiel für den Fall der Klassifizierung einer Auswahl handgeschriebener Ziffern (MNIST) in 10 Klassen.  Auf der vorletzten verborgenen Ebene, die vor der Klassifizierung liegt, befinden sich nur 2 Neuronen, wodurch die Aktivierungsstatistik einfach in der Ebene angezeigt werden kann.  Jeder Punkt in der Grafik entspricht einem Beispiel aus der Testprobe.  Die Farbe eines Punktes entspricht einer bestimmten Klasse. <br><br>  In unserem Fall war die Dimension des Merkmalsraums im Beispiel größer als 128. Wir haben eine Gruppe von Bildern aus einer Testprobe ausgeführt und für jedes Bild einen Merkmalsvektor erhalten.  Danach wurden sie normalisiert (geteilt durch die Länge).  Aus dem obigen Bild ist ersichtlich, warum sich dies lohnt.  Wir haben die normalisierten Vektoren nach der KMeans-Methode geclustert.  Wir haben eine Aufschlüsselung der Stichprobe in Gruppen ähnlicher (aus Sicht des Netzwerks) Bilder erhalten. <br><br>  Am Ende mussten wir jedoch eine Partition des Alphabets in Gruppen und nicht eine Partition des Testbeispiels erstellen.  Die erste der zweiten ist jedoch nicht schwer zu erhalten: Es reicht aus, jede Klassenbezeichnung dem Cluster zuzuweisen, der die meisten Bilder dieser Klasse enthält.  In den meisten Situationen landet die gesamte Klasse natürlich sogar in einem Cluster. <br><br>  Nun, das ist alles, wir haben eine Aufteilung des gesamten Alphabets in Gruppen ähnlicher Zeichen.  Dann bleibt es, eine einfache Architektur zu wählen und den Klassifikator zu trainieren, um zwischen diesen Gruppen zu unterscheiden. <br><br>  Hier ist ein Beispiel für zufällige 6 Gruppen, die durch Aufteilen des gesamten Quellalphabets in 500 Cluster erhalten werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/14/zi/ge14ziruqvxamfjvh-zx6fchb3s.png"></div><br><h2>  Konstruktion von Klassifikatoren der zweiten Ebene </h2><br>  Als nächstes müssen Sie entscheiden, welche Zielzeichensätze die Klassifikatoren der zweiten Ebene lernen sollen.  Die Antwort scheint offensichtlich zu sein - dies sollten Gruppen von Zeichen sein, die im vorherigen Schritt erhalten wurden.  Dies wird funktionieren, aber nicht immer mit guter Qualität. <br><br>  Tatsache ist, dass der Klassifikator der ersten Ebene in jedem Fall Fehler macht und diese teilweise durch die Konstruktion von Mengen der zweiten Ebene wie folgt ausgeglichen werden können: <br><br><ul><li>  Wir korrigieren eine bestimmte separate Stichprobe von Symbolbildern (die weder an Schulungen noch an Tests teilnehmen). </li><li>  Wir führen dieses Beispiel durch einen trainierten Klassifikator der ersten Ebene und markieren jedes Bild mit der Bezeichnung dieses Klassifikators (Gruppenbezeichnung). </li><li>  Für jedes Symbol betrachten wir alle möglichen Gruppen, zu denen der Klassifikator der ersten Ebene zu den Bildern dieses Symbols gehört. </li><li>  Fügen Sie dieses Symbol allen Gruppen hinzu, bis der erforderliche Abdeckungsgrad T_acc erreicht ist. </li><li>  Wir betrachten die letzten Gruppen von Symbolen als Zielmengen der zweiten Ebene, auf denen Klassifikatoren trainiert werden. </li></ul><br>  Zum Beispiel wurden die Bilder des Symbols "A" vom Klassifikator der ersten Ebene 980 Mal der 5. Gruppe, 19 Mal der 2. Gruppe und 1 Mal der 6. Gruppe zugewiesen.  Insgesamt haben wir 1000 Bilder dieses Symbols. <br><br>  Dann können wir das Symbol „A“ zur 5. Gruppe hinzufügen und eine 98% ige Abdeckung dieses Symbols erhalten.  Wir können es der 5. und 2. Gruppe zuordnen und erhalten eine Abdeckung von 99,9%.  Und wir können es sofort Gruppen (5, 2, 6) zuordnen und eine 100% ige Abdeckung erhalten. <br><br>  Im Wesentlichen stellt T_acc ein Gleichgewicht zwischen Geschwindigkeit und Qualität her.  Je höher es ist, desto höher ist die endgültige Qualität der Klassifizierung, aber desto größer sind die Zielmengen der zweiten Ebene und desto schwieriger ist die Klassifizierung auf der zweiten Ebene. <br><br>  Die Praxis zeigt, dass selbst bei T_acc = 1 die Zunahme der Größe von Sätzen infolge des oben beschriebenen Nachfüllvorgangs nicht so signifikant ist - im Durchschnitt etwa zweimal.  Dies hängt natürlich direkt von der Qualität des trainierten Klassifikators der ersten Stufe ab. <br><br>  Hier ist ein Beispiel dafür, wie diese Vervollständigung für einen der Sätze aus derselben Partition in 500 Gruppen funktioniert, was höher war: <br><br><img src="https://habrastorage.org/webt/b6/kd/nh/b6kdnh829fmav36s41h2ygqzen0.png" alt="Bild"><br><br><h2>  Ergebnisse der Modelleinbettung </h2><br>  Geschulte zweistufige Modelle haben endlich schneller und besser funktioniert als bisher verwendete Klassifikatoren.  Tatsächlich war es nicht so einfach, mit demselben linearen Teilungsgraphen (GLD) „Freunde zu finden“.  Dazu musste ich dem Modell separat beibringen, Zeichen von a priori Müll- und Zeilensegmentierungsfehlern zu unterscheiden (um in diesen Situationen ein geringes Vertrauen zurückzugeben). <br><br>  Das Endergebnis der Einbettung in den folgenden Algorithmus zur vollständigen Dokumentenerkennung (erhalten bei der Sammlung chinesischer und japanischer Dokumente) ist die Geschwindigkeit, die für den vollständigen Algorithmus angegeben wird: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7g/jq/oa/7gjqoavm4iu3xwanuakuhml4mhe.png"></div><br>  Wir haben die Qualität verbessert und sowohl im normalen als auch im schnellen Modus beschleunigt, während wir die gesamte Zeichenerkennung auf neuronale Netze übertragen haben. <br><br><h2>  Ein bisschen über End-to-End-Erkennung </h2><br>  Heutzutage verwenden die meisten öffentlich bekannten OCR-Systeme (der gleiche Tesseract von Google) die End-to-End-Architektur neuronaler Netze, um Zeichenfolgen oder deren Fragmente in ihrer Gesamtheit zu erkennen.  Aber hier haben wir neuronale Netze genau als Ersatz für ein einzelnes Zeichenerkennungsmodul verwendet.  Das ist kein Zufall. <br><br>  Tatsache ist, dass die Segmentierung einer Zeichenfolge in Zeichen in gedrucktem Chinesisch und Japanisch aufgrund des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">monospaced</a> Drucks kein großes Problem darstellt.  In dieser Hinsicht verbessert die Verwendung der End-to-End-Erkennung für diese Sprachen die Qualität nicht wesentlich, ist jedoch viel langsamer (zumindest auf der CPU).  Im Allgemeinen ist nicht klar, wie der vorgeschlagene zweistufige Ansatz im End-to-End-Kontext verwendet werden soll. <br><br>  Im Gegenteil, es gibt Sprachen, bei denen die lineare Unterteilung in Zeichen ein Schlüsselproblem darstellt.  Explizite Beispiele sind Arabisch, Hindi.  Für Arabisch zum Beispiel werden End-to-End-Lösungen bereits aktiv bei uns untersucht.  Aber das ist eine ganz andere Geschichte. <br><br>  <i>Alexey Zhuravlev, Leiter der OCR New Technologies Group</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438128/">https://habr.com/ru/post/de438128/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438118/index.html">Mit Dex-Net 4.0 können Ambidextro-Roboter das Beste heraussuchen</a></li>
<li><a href="../de438120/index.html">Die Zusammenfassung der Ereignisse für HR-Experten im Bereich IT für Februar 2019</a></li>
<li><a href="../de438122/index.html">Numerologie zu MS SQL - ein unterhaltsames Experiment</a></li>
<li><a href="../de438124/index.html">Piter GraphQL: Videos von Mitap in Wrike</a></li>
<li><a href="../de438126/index.html">Absolventen von IT-Praktika bei der Raiffeisenbank - wie es war</a></li>
<li><a href="../de438130/index.html">Neutralinojs - Eine Elektronenalternative, die weniger Speicher verbraucht</a></li>
<li><a href="../de438132/index.html">GOSINT - eine Open Source-Lösung zur Verwaltung von Kompromissindikatoren (IoC)</a></li>
<li><a href="../de438134/index.html">Installation von CCTV-Systemen: schöne und unglückliche Geschichten mit Kameras</a></li>
<li><a href="../de438136/index.html">Zustimmung zur Datenverarbeitung der DSGVO: detaillierte Analyse</a></li>
<li><a href="../de438138/index.html">Anatomie der Falken</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>