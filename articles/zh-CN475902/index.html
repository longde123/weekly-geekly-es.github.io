<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤷🏼 👩‍❤️‍👨 💸 Workflow Core-.Net Core的业务流程引擎 👲🏼 🚥 ✖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好！ 


 我们决定支持使用Windows Workflow Foundation到.Net Core的项目迁移主题，该主题是由DIRECTUM的同事发起的，因为几年前我们遇到了类似的问题，并且走了自己的路。 
 让我们从故事开始 


 我们的旗舰产品Avanpost IDM是帐户生命周期和...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Workflow Core-.Net Core的业务流程引擎</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/avanpost/blog/475902/"><p><img src="https://habrastorage.org/webt/hp/ll/of/hpllof4hjsvcpfxbkl_q-epwfew.jpeg" alt="图片"></p><br><p> 大家好！ </p><br><p> 我们决定支持<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用Windows Workflow Foundation到.Net Core的项目迁移主题，</a>该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">主题</a>是由DIRECTUM的同事发起的，因为几年前我们遇到了类似的问题，并且走了自己的路。 </p><a name="habracut"></a><br><h2> 让我们从故事开始 </h2><br><p> 我们的旗舰产品Avanpost IDM是帐户生命周期和员工访问管理系统。 他知道如何根据角色模型并根据请求自动管理访问。 在产品诞生之初，我们就拥有了一个相当简单的自助服务系统，该系统具有简单的分步工作流程，原则上不需要引擎。 </p><br><p><img src="https://habrastorage.org/webt/hl/uo/c1/hluoc1imf_ejbdyzynpumdefmaa.png" alt="图片"></p><br><p> 但是，当面对大客户时，我们意识到需要一个更加灵活的工具，因为他们对访问权限协调过程的要求寻求了良好，重要的工作流程的规则。 在分析了需求之后，我们决定开发适合自己需求的BPMN格式的流程编辑器。 稍后我们将讨论使用React.js + SVG进行编辑器的开发，今天我们将讨论后端主题- <strong>工作流引擎</strong>或业务流程引擎。 </p><br><h2> 要求条件 </h2><br><p> 在系统开发之初，我们对引擎有以下要求： </p><br><ul><li> 支持流程图，易于理解的格式，能够从我们的格式广播到引擎格式 </li><li> 流程状态存储 </li><li> 流程版本控制支持 </li><li> 支持流程的并行执行（分支） </li><li> 在复制的商业产品中使用该解决方案的合适许可证 </li><li> 支持水平缩放 </li></ul><br><p> 在分析市场（针对2014年）之后，我们确定了适用于.Net的几乎非替代解决方案：Windows Workflow Foundation。 </p><br><h2>  Windows Workflow Foundation（WWF） </h2><br><p>  WWF是Microsoft用于定义，执行和管理工作流的技术。 </p><br><p> 其逻辑的基础是一组用于操作（活动）的容器，以及从这些容器构建顺序流程的能力。 容器可以是普通的-执行活动的过程中的某个步骤。 它可以是经理-包含分支逻辑。 </p><br><p> 您可以直接在Visual Studio中绘制过程。 编译后的业务流程图存储在Haml中，这非常方便-描述了格式，可以使自己编写流程设计师。 这是一方面。 另一方面，Xaml并不是用于存储描述的最方便的格式-或多或少的实际过程的编译方案非常庞大，尤其是因为冗余。 这很难理解，但您必须理解它。 </p><br><p> 但是，如果早晚有人可以理解各种方案并学会阅读它们，那么引擎本身缺乏透明性便会增加用户在系统运行过程中的麻烦。 当错误来自Wf的肠子时，并非总是能够100％找出故障的确切原因。 封闭的来源和相对的怪异无助于此。 错误修复通常是由于症状引起的。 </p><br><p>公平地讲，这里值得澄清的是，由于Wf的强大定制功能，上述问题在很大程度上困扰着我们。 一位读者肯定会说我们自己创造了很多问题，然后英勇地解决了这些问题。 从一开始就必须制造出自制的发动机。 一般来说，他们是正确的。 </p><br><p> 最重要的是，该解决方案运行稳定并成功投入生产。 但是我们产品向.Net Core的过渡迫使我们放弃WWF并寻找另一个业务流程引擎，因为 截至2019年5月，Windows Workflow Foundation尚未迁移到.Net Core。 当我们在寻找一个新引擎时-在另一篇文章中作为主题，但是最后我们选择了Workflow Core。 </p><br><h2> 工作流程核心 </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Workflow Core</a>是一个免费的业务流程引擎。 它是根据MIT许可开发的，即可以安全地用于商业开发。 </p><br><p> 它是由一个人主动完成的，另外几个人会定期发出请求。 有用于其他语言（Java，Python等）的端口。 </p><br><p> 引擎定位为轻量化。 实际上，这只是按顺序执行按任何业务规则分组的操作的主机。 </p><br><p> 该项目具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wiki文档</a> 。 不幸的是，它没有描述引擎的所有功能。 但是，要求完整的文档是无礼的-开源项目得到一位发烧友的支持。 因此，维基足以入门。 </p><br><p> 开箱即用的支持将过程状态存储在外部存储（持久性存储）中。 提供者是以下方面的标准： </p><br><ul><li>  Mongodb </li><li>  SQL服务器 </li><li>  PostgreSQL的 </li><li>  Sqlite </li><li> 亚马逊DynamoDB </li></ul><br><p> 写您的提供程序不是问题。 我们以任何标准的来源为例。 </p><br><p> 支持水平缩放，也就是说，您可以一次在多个节点上运行引擎，同时具有一个存储过程状态的点（一个持久性存储）。 同时，引擎的内部任务队列应位于常规存储器中（可选，rabbitMQ）。 为了排除多个节点执行一项任务，同时提供了一个锁管理器。 与外部存储提供者类似，有一些标准实现： </p><br><ul><li>  Azure存储租约 </li><li> 雷迪斯 </li><li>  AWS DynamoDB </li><li>  SQLServer（在源代码中有，但是文档中没有任何内容） </li></ul><br><p> 从一个例子开始，最容易了解新事物。 因此，让我们开始吧。 我将从一开始就描述一个简单过程的构造，并进行解释。 一个例子似乎太简单了。 我同意-这很简单。 最开始的。 </p><br><p> 走吧 </p><br><h4> 步骤 </h4><br><p> 步骤是执行任何动作的过程中的步骤。 整个过程是由一系列步骤构成的。 一个步骤可以执行许多动作，例如对于外部某个事件可以重复执行。 有一系列步骤具有逻辑“开箱即用”： </p><br><ul><li> 等待 </li><li> 如果 </li><li> 当 </li><li> 佛瑞奇 </li><li> 延误 </li><li> 平行的 </li><li> 日程安排 </li><li> 重复发生 </li></ul><br><p> 当然，在某些内置基元上，您无法承受这个过程。 我们需要完成业务任务的步骤。 因此，暂时将它们放在一边，并按照我们自己的逻辑采取步骤。 为此，您需要继承<strong>StepBody</strong>抽象。 </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StepBody</span></span> : <span class="hljs-title"><span class="hljs-title">IStepBody</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> ExecutionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IStepExecutionContext context</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br><p> 当过程进入步骤时，将执行<strong>Run</strong>方法。 有必要在其中放置必要的逻辑。 </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StepBody</span></span> : <span class="hljs-title"><span class="hljs-title">IStepBody</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> ExecutionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IStepExecutionContext context</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br><p> 这些步骤支持依赖项注入。 为此，将它们作为必需的依赖项注册在同一容器中就足够了。 </p><br><p> 显然，该过程需要它自己的上下文-一个可以在其中添加中间执行结果的地方。  Wf核心具有自己的上下文，可以执行存储有关其当前状态的信息的进程。 您可以使用<strong>Run</strong> （）方法中的<strong>上下文</strong>变量来访问它。 除了内置的，我们还可以使用上下文。 </p><br><p> 我们将在下面更详细地分析描述和注册过程的方式，现在，我们仅定义一个特定的类—上下文。 </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ProcessContext</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Number1 {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Number2 {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> StepResult {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Number1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; Number2 = <span class="hljs-number"><span class="hljs-number">2</span></span>; } }</code> </pre> <br><p> 在变量<strong>Number中，</strong>我们写数字。 进入变量<strong>StepResult-</strong>步骤的结果。 </p><br><p> 我们决定了上下文。 您可以编写自己的步骤： </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomStep</span></span> : <span class="hljs-title"><span class="hljs-title">StepBody</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Ilogger _log; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Input1 { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Input2 { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Action { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Result { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomStep</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ilogger log</span></span></span><span class="hljs-function">)</span></span> { _log = log; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> ExecutionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IStepExecutionContext context</span></span></span><span class="hljs-function">)</span></span> { Result = ”none”; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Action ==”sum”) { Result = Number1 + Number2; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Action ==”dif”){ Result = Number1 - Number2; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExecutionResult.Next(); } }</code> </pre> <br><p> 逻辑非常简单：两个数字和操作名称出现在输入中。 将运算结果写入输出变量<strong>Result</strong> 。 如果未定义操作，则结果为<em>none</em> 。 </p><br><p> 我们根据上下文决定，我们需要的逻辑也迈出了一步。 现在我们需要在引擎中注册我们的过程。 </p><br><h4> 过程说明。 在引擎中注册。 </h4><br><p> 有两种描述过程的方法。 第一个是代码中的描述-硬代码。 </p><br><p> 通过<strong>流畅的界面</strong>描述了该过程。 有必要从广义的<strong>IWorkflow &lt;T&gt;</strong>接口继承，其中T是模型上下文类。 在我们的例子中，这是一个<strong>ProcessContext</strong> 。 </p><br><p> 看起来像这样： </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SimpleWorkflow</span></span> : <span class="hljs-title"><span class="hljs-title">IWorkflow</span></span>&lt;<span class="hljs-title"><span class="hljs-title">ProcessContext</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Build</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IWorkflowBuilder&lt;ProcessContext&gt; builder</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    } public string Id =&gt; "SomeWorkflow"; public int Version =&gt; 1; }</span></span></code> </pre> <br><p> 描述本身将在<strong>Build</strong>方法内部。  <strong>编号</strong>和<strong>版本</strong>字段也是必填字段。  Wf核心支持流程版本控制-您可以使用相同的标识符注册n个流程版本。 当您需要更新现有流程并同时“激活”现有任务时，这很方便。 </p><br><p> 我们描述一个简单的过程： </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SimpleWorkflow</span></span> : <span class="hljs-title"><span class="hljs-title">IWorkflow</span></span>&lt;<span class="hljs-title"><span class="hljs-title">ProcessContext</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Build</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IWorkflowBuilder&lt;ProcessContext&gt; builder</span></span></span><span class="hljs-function">)</span></span> { builder.StartWith&lt;CustomStep&gt;() .Input(step =&gt; step.Input1, data =&gt; data.Number1) .Input(step =&gt; step.Input2, data =&gt; data.Number2) .Input(step =&gt; step.Action, data =&gt; “sum”) .Output(data =&gt; data.StepResult, step =&gt; step.Result) .EndWorkflow(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Id =&gt; <span class="hljs-string"><span class="hljs-string">"SomeWorkflow"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Version =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p> 如果将其翻译成“人类”语言，结果将是这样：该过程从<strong>CustomStep</strong>步骤开始。 步骤字段<strong>Input1</strong>的值从上下文字段<strong>Number1中获取</strong> ，步骤字段<strong>Input2</strong>的值从上下文字段<strong>Number2中获取</strong> ， <strong>操作</strong>字段被硬编码为值<strong>“ sum”</strong> 。  <strong>Result</strong>字段的输出将写入<strong>StepResult</strong>上下文<strong>字段</strong> 。 完成该过程。 </p><br><p> 同意，即使没有C＃的专门知识，该代码也具有很高的可读性，很可能会弄清楚它。 </p><br><p> 在我们的过程中再增加一个步骤，该步骤会将上一步的结果输出到日志中： </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomStep</span></span> : <span class="hljs-title"><span class="hljs-title">StepBody</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Ilogger _log; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> TextToOutput { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomStep</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ilogger log</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    _log = log; } public override ExecutionResult Run(IStepExecutionContext context) { _log.Debug(TextToOutput); return ExecutionResult.Next(); } }</span></span></code> </pre> <br><p> 并更新过程： </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SimpleWorkflow</span></span> : <span class="hljs-title"><span class="hljs-title">IWorkflow</span></span>&lt;<span class="hljs-title"><span class="hljs-title">ProcessContext</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Build</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IWorkflowBuilder&lt;ProcessContext&gt; builder</span></span></span><span class="hljs-function">)</span></span> { builder.StartWith&lt;CustomStep&gt;() .Input(step =&gt; step.Input1, data =&gt; data.Number1) .Input(step =&gt; step.Input2, data =&gt; data.Number2) .Input(step =&gt; step.Action, data =&gt; “sum”) .Output(data =&gt; data.StepResult, step =&gt; step.Result) .Then&lt;OutputStep&gt;.Input(step =&gt; step.TextToOutput, data =&gt; data.StepResult) .EndWorkflow(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Id =&gt; <span class="hljs-string"><span class="hljs-string">"SomeWorkflow"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Version =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre> <br><p> 现在，在执行加法运算的步骤之后，接下来是将结果输出到日志的步骤。 对于输入，我们传递<strong>Result</strong>和context变量，在最后一步中将执行结果写入该变量。 我将自由地断言，在实际系统中通过代码（硬代码）进行这种描述几乎没有用处。 除非用于某些办公流程。 能够分别存储电路更加有趣。 至少，我们不必在每次需要在过程中进行更改或添加新项目时都重新组合项目。  Wf核心通过存储json模式来提供此功能。 我们继续扩大我们的榜样。 </p><br><h4>  Json流程说明 </h4><br><p>  <i>此外，我不会通过代码提供描述。</i>  <i>这并不是特别有趣，只会使文章膨胀。</i> </p><br><p>  Wf核心支持json中的架构描述。 在我看来，json比xaml更直观（在注释中，这是holivar的一个好话题：）。 文件结构非常简单： </p><br><pre> <code class="plaintext hljs">{ "Id": "SomeWorkflow", "Version": 1, "DataType": "App.ProcessContext, App", "Steps": [ { /*step1*/ }, { /*step2*/ } ] }</code> </pre> <br><p>  <strong>DataType</strong>字段指示上下文类的完全限定名称以及在其中描述它的程序集的名称。  <strong>步骤</strong>存储过程中所有步骤的集合。 填写<strong>步骤</strong>元素： </p><br><pre> <code class="plaintext hljs">{ "Id": "SomeWorkflow", "Version": 1, "DataType": "App.ProcessContext, App", "Steps": [ { "Id": "Eval", "StepType": "App.CustomStep, App", "NextStepId": "Output", "Inputs": { "Input1": "data.Number1", "Input2": "data.Number2" }, "Outputs": { "StepResult": "step.Result" } }, { "Id": "Output", "StepType": "App.OutputStep, App", "Inputs": { "TextToOutput": "data.StepResult" } } ] }</code> </pre> <br><p> 让我们仔细看看通过json进行的步骤描述的结构。 </p><br><p>  <strong>Id</strong>和<strong>NextStepId</strong>字段存储此步骤的标识符以及下一个步骤的指示符。 此外，集合元素的顺序并不重要。 </p><br><p>  <strong>StepType</strong>类似于<strong>DataType</strong>字段，它包含步骤类的全名（一种继承自<strong>StepBody</strong>并实现步骤逻辑的类型）和程序集的名称。 更有趣的是<strong>Inputs</strong>和<strong>Outputs</strong>对象。 它们以映射的形式设置。 </p><br><p> 对于<strong>Inputs，</strong> json元素名称是我们步骤的类字段的名称； 元素的值是类中字段的名称，即过程的上下文。 </p><br><p> 相反，对于<strong>Outputs，</strong> json元素名称是类中字段的名称，即进程的上下文； 元素值是我们步骤的类字段的名称。 </p><br><p> 为什么要通过<em>数据{Field_name}</em>指定上下文字段，而对于<strong>Output</strong> ， <em>则要</em>通过<em>{Field_name}</em> <em>步骤</em>指定上下文字段？ 由于wf core，元素值作为C＃表达式执行（使用了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Dynamic Expressions库</a> ）。 这是相当有用的事情，如果架构师当然认可这样的耻辱，那么借助它的帮助，您可以在方案内部直接放置一些业务逻辑：)。 </p><br><p> 我们通过标准图元使方案多样化。 添加条件<strong>If</strong>步骤并处理外部事件。 </p><br><h5> 如果 </h5><br><p> 原始<strong>如果</strong> 。 困难从这里开始。 如果您习惯使用该符号进行bpmn和绘制过程，则将发现一个简单的设置。 根据文档，该步骤描述如下： </p><br><pre> <code class="plaintext hljs">{ "Id": "IfStep", "StepType": "WorkflowCore.Primitives.If, WorkflowCore", "NextStepId": "nextStep", "Inputs": { "Condition": "&lt;&lt;expression to evaluate&gt;&gt;" }, "Do": [ [ { /*do1*/ }, { /*do2*/ } ] ] }</code> </pre> <br><p> 没有感觉到这里有什么问题吗？ 我有一个 步骤输入设置为“ <em>条件</em> -表达式”。 接下来，我们设置<strong>Do</strong>数组（操作）中的步骤列表。 那么， <strong>假</strong>分支在哪里？ 为什么没有Do数组为False？ 其实有。 可以理解， <strong>False</strong>分支只是沿过程的进一步传递，即紧跟<strong>NextStepId中</strong>的指针。 起初，我一直为此感到困惑。 好，整理一下。 虽然没有。 如果需要将在<em>True</em>情况下的流程动作放入<strong>Do内</strong> ，则这将是“美丽的” json。 而如果有这些， <strong>如果</strong>附上一打呢？ 一切都会横着走。 他们还说，关于xaml的方案很难阅读。 有一个小技巧。 只是将显示器扩大。 上面稍微提到过，集合中步骤的顺序无关紧要，过渡遵循的迹象。 可以使用。 再增加一个步骤： </p><br><pre> <code class="plaintext hljs">{ "Id": "Jump", "StepType": "App.JumpStep, App", "NextStepId": "" }</code> </pre> <br><p> 猜猜我要干什么？ 的确，我们引入了服务步骤，该服务步骤将流程转移到<strong>NextStepId中</strong>的步骤。 </p><br><p> 更新我们的方案： </p><br><pre> <code class="plaintext hljs">{ "Id": "SomeWorkflow", "Version": 1, "DataType": "App.ProcessContext, App", "Steps": [ { "Id": "Eval", "StepType": "App.CustomStep, App", "NextStepId": "MyIfStep", "Inputs": { "Input1": "data.Number1", "Input2": "data.Number2" }, "Outputs": { "StepResult": "step.Result" } }, { "Id": "MyIfStep", "StepType": "WorkflowCore.Primitives.If, WorkflowCore", "NextStepId": "OutputEmptyResult", "Inputs": { "Condition": "!String.IsNullOrEmpty(data.StepResult)" }, "Do": [ [ { "Id": "Jump", "StepType": "App.JumpStep, App", "NextStepId": "Output" } ] ] }, { "Id": "Output", "StepType": "App.OutputStep, App", "Inputs": { "TextToOutput": "data.StepResult" } }, { "Id": "OutputEmptyResult", "StepType": "App.OutputStep, App", "Inputs": { "TextToOutput": "\"Empty result\"" } } ] }</code> </pre> <br><p>  <strong>If</strong>步骤检查<strong>Eval</strong>步骤的结果是否为空。 如果不为空，则显示结果；如果为空，则显示消息“为<em>空</em> ”。  “ <strong>跳转”</strong>步骤将过程带到“ <strong>输出”</strong>步骤，该步骤位于<strong>Do</strong>集合之外。 因此，我们保持了该方案的“垂直性”。 同样，以这种方式，人们可以向后跳n步，即 组织一个周期。  wf核心中有用于循环的内置原语，但它们并不总是很方便。 例如，在bpmn中，通过<strong>If</strong>来组织循环。 </p><br><p> 使用这种方法或标准，由您决定。 对于我们来说，这样的组织是更方便的步骤。 </p><br><h5> 等待 </h5><br><p>  <strong>WaitFor</strong>原语允许外界在已经运行的过程中对其进行影响。 例如，如果在过程阶段需要任何用户批​​准进一步的课程。 该过程将一直处于<strong>WaitFor</strong>步骤中，直到收到订阅的事件为止。 </p><br><p> 基本结构： </p><br><pre> <code class="plaintext hljs">{ "Id": "Wait", "StepType": "WorkflowCore.Primitives.WaitFor, WorkflowCore", "NextStepId": "NextStep", "CancelCondition": "If(cancel==true)", "Inputs": { "EventName": "\"UserAction\"", "EventKey": "\"DoSum\"", "EffectiveDate": "DateTime.Now" } }</code> </pre> <br><p> 我会解释一些参数。 </p><br><p>  <strong>CancelCondition-</strong>中断等待的条件。 提供中断事件等待并继续进行的功能。 例如，如果一个进程同时等待n个不同的事件（wf内核支持并行执行步骤），则不必等待所有事件都<strong>到达</strong> ，在这种情况下， <strong>CancelCondition</strong>将为<strong>我们提供</strong>帮助。 我们向上下文变量添加逻辑标志，并在接收到事件后将标志设置为<strong>true-</strong>所有<strong>WaitFor</strong>步骤均已完成。 </p><br><p>  <strong>EventName</strong>和<strong>EventKey-</strong>事件的名称和键。 为了区分事件，即在具有大量同时工作过程的真实系统中，需要字段。 以便引擎了解哪个事件是针对哪个过程和哪个步骤的。 </p><br><p>  <strong>有效日期</strong> -一个可选的字段，用于添加事件时间戳。 如果您需要发布“未来”的事件，它可能会派上用场。 为了使其立即发布，可以将参数保留为空或设置当前时间。 </p><br><p> 并非在所有情况下都采取单独的步骤来从外部处理反应很方便；相反，即使通常情况下，这也是多余的。 通过将外部事件的期望及其处理逻辑添加到常规步骤中，可以避免额外的步骤。 我们<strong>通过</strong>订阅外部事件来<strong>补充CustomStep</strong>步骤： </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomStep</span></span> : <span class="hljs-title"><span class="hljs-title">StepBody</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Ilogger _log; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> TextToOutput { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomStep</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ilogger log</span></span></span><span class="hljs-function">)</span></span> { _log = log; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> ExecutionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IStepExecutionContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//-  return ExecutionResult.WaitForEvent("eventName", "eventKey", DateTime.Now); } }</span></span></code> </pre> <br><p> 我们使用了标准的<strong>WaitForEvent（）</strong>扩展方法。 它接受前面提到的参数<strong>EventName</strong> ， <strong>EventKey</strong>和<strong>EffectiveDate</strong> 。 完成此步骤的逻辑后，该过程将等待所描述的事件，并在该事件在引擎总线中发布时再次调用<strong>Run（）</strong>方法。 但是，以当前形式，我们无法区分最初进入步骤的时刻和事件之后的进入时刻。 但是我想以某种方式在步骤级别上前后分离逻辑。 而<strong>EventPublished</strong>标志将帮助我们实现这一点。 它位于流程的一般上下文中，您可以像这样获得它： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ifEvent=context.ExecutionPointer.EventPublished;</code> </pre> <br><p> 基于此标志，您可以将逻辑安全地划分为外部事件之前和之后。 </p><br><p> 重要说明-根据引擎创建者的想法，一个步骤只能在一个事件上签名，并对其进行一次反应。 对于某些任务，这是一个非常不愉快的限制。 为了摆脱这种细微差别，我们甚至不得不“完成”引擎。 我们将在本文中跳过它们的描述，否则该文章将永远不会结束:)。 后续文章中将介绍更复杂的使用方法和改进示例。 </p><br><h4> 引擎中的注册过程。 在公共汽车上发布事件。 </h4><br><p> 因此，随着步骤的逻辑执行和对过程的描述弄清楚了。 剩下的是最重要的事情，没有它，该过程将无法进行-说明需要注册。 </p><br><p> 我们将使用标准的<strong>AddWorkflow（）</strong>扩展方法，该方法会将其依赖项放在IoC容器中。 </p><br><p> 看起来像这样： </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IServiceCollection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWorkflow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IServiceCollection services, Action&lt;WorkflowOptions&gt; setupAction = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span></code> </pre> <br><p>  <strong>IServiceCollection-</strong>接口-服务描述集合的合同。 他住在Microsoft的DI内部（有关更多信息， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">请点击此处</a> ） </p><br><p>  <strong>WorkflowOptions-</strong>基本引擎设置。 不必自己设置它们；标准值对于初学者是完全可以接受的。 我们走得更远。 </p><br><p> 如果该过程是用代码描述的，则注册将如下所示： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> host = _serviceProvider.GetService&lt;IWorkflowHost&gt;(); host.RegisterWorkflow&lt;SomeWorkflow, ProcessContext&gt;();</code> </pre> <br><p> 如果该过程是通过json描述的，则必须按以下方式注册（当然，必须从存储位置预加载json描述）： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> host = _serviceProvider.GetService&lt;IWorkflowHost&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> definitionLoader = _serviceProvider.GetService&lt;IDefinitionLoader&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> definition = loader.LoadDefinition({*json  *});</code> </pre> <br><p> 此外，对于这两个选项，代码将相同： </p><br><pre> <code class="cs hljs">host.Start(); <span class="hljs-comment"><span class="hljs-comment">//      host.StartWorkflow(definitionId, version, context); //      /// host.Stop(); / /    </span></span></code> </pre> <br><p>  <strong>definitionId</strong>参数是进程标识符。 在流程ID字段中写入的内容。 在这种情况下，id = <strong>SomeWorkflow</strong> 。 </p><br><p>  <strong>version</strong>参数指定要运行的进程的版本。 该引擎提供了使用一个标识符立即注册n个流程版本的功能。 当您需要在不破坏已经运行的任务的情况下更改流程说明时，这很方便-新任务将根据新版本创建，旧任务将安静地存在于旧任务中。 </p><br><p>  <strong>上下文</strong>参数是流程上下文的一个实例。 </p><br><p>  <strong>host.Start（）</strong>和<strong>host.Stop（）</strong>方法启动和停止进程托管。 如果在应用程序中启动进程是一项已应用的任务，并且是定期执行的，则应停止托管。 如果应用程序主要集中在各种过程的实现上，则无法停止托管。 </p><br><p> 有一种方法可以将消息从外界发送到引擎总线，然后将消息分发给订户： </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PublishEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eventName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eventKey, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> eventData, DateTime effectiveDate = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p> 文章中对它的参数的描述更高（ <em>请参见WaitFor基本部分</em> ）。 </p><br><h2> 结论 </h2><br><p> 当我们决定采用Workflow Core-开源项目时，我们肯定会冒风险，该项目由一个人积极开发，即使文档非常差。 而且，您极有可能找不到在生产系统（我们公司除外）中使用wf core的实际做法。 当然，选择了单独的抽象层后，我们可以确保自己不会出现故障，也不需要为快速返回WWF（例如，一种自行编写的解决方案）而烦恼，但是一切进展顺利，并且故障并没有到来。 </p><br><p> 改用开源Workflow Core引擎解决了许多问题，这些问题使我们无法在WWF上安居乐业。 当然，其中最重要的是支持.Net Core，即使在WWF计划中也缺乏。 </p><br><p> 以下是开源。 与WWF一起工作并从肠中得到各种错误，至少能够阅读源代码的能力将非常有帮助。 更不用说改变他们的东西了。 这里有了Workflow Core的完全自由（包括许可-MIT）。 如果引擎的肠子突然出现错误，只需从github下载源代码，然后静静地寻找其发生原因。 是的，仅仅具有调试功能并具有断点的引擎功能已经极大地促进了该过程。 </p><br><p> 当然，为了解决一些问题，Workflow Core带来了自己的新问题。 我们必须对引擎核心进行大量更改。 但是 与从头开发自己的引擎相比，自行完成“完成”所花费的时间更少。 最终的解决方案在速度和稳定性方面是完全可以接受的，它使我们能够忘记引擎的问题，而专注于开发产品的商业价值。 </p><br><p>  <em>PS：如果主题变得有趣，那么将在wf core上发布更多文章，并对引擎和复杂业务问题的解决方案进行更深入的分析。</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN475902/">https://habr.com/ru/post/zh-CN475902/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN475888/index.html">云人脸识别的好处</a></li>
<li><a href="../zh-CN475892/index.html">我们如何改善办公室午餐的顺序（无法访问服务器）</a></li>
<li><a href="../zh-CN475894/index.html">三阶段协议</a></li>
<li><a href="../zh-CN475896/index.html">全I / O裸C反应器</a></li>
<li><a href="../zh-CN475900/index.html">6门最新的Azure课程</a></li>
<li><a href="../zh-CN475904/index.html">给新经理的5条笔记</a></li>
<li><a href="../zh-CN475908/index.html">十个最受欢迎的俄语俄语课程</a></li>
<li><a href="../zh-CN475912/index.html">如何评估和比较以太网的加密设备</a></li>
<li><a href="../zh-CN475916/index.html">向机器人注视</a></li>
<li><a href="../zh-CN475920/index.html">不是在运行时，而是在设计时</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>