<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëàüèø üë®üèæ‚Äçüíº üêï Nome da Implementa√ß√£o e Nome do Resultado ü§± üö∑ üë©üèø‚Äçüíª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eu queria escrever este post em julho, mas n√£o podia, oh ironia , decidir como cham√°-lo. Bons termos me vieram √† mente somente ap√≥s a palestra de Kate...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nome da Implementa√ß√£o e Nome do Resultado</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484860/"><p><img src="https://habrastorage.org/webt/sw/9a/fb/sw9afbxo38dofpspvffb0c_jrq4.jpeg"></p><br><p>  Eu queria escrever este post em julho, mas n√£o podia, <em>oh ironia</em> , decidir como cham√°-lo.  Bons termos me vieram √† mente somente ap√≥s <a href="https://www.youtube.com/watch%3Fv%3DMBRoCdtZOYg">a palestra de Kate Gregory na CppCon</a> , e agora posso finalmente dizer como chamar fun√ß√µes. </p><br><p> Obviamente, existem nomes que n√£o carregam informa√ß√µes, como <code>int f(int x)</code> .  Eles tamb√©m n√£o precisam ser usados, mas n√£o √© sobre eles.  √Äs vezes acontece que parece que as informa√ß√µes no t√≠tulo est√£o completas, mas n√£o h√° absolutamente nenhum benef√≠cio delas. </p><a name="habracut"></a><br><h2 id="primer-1-stdlog2p1">  Exemplo 1: std :: log2p1 () </h2><br><p>  No C ++ 20, v√°rias novas fun√ß√µes para opera√ß√µes de bit foram adicionadas ao cabe√ßalho, entre outras <code>std::log2p1</code> .  √â assim: <br><br><br></p><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log2p1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::log2(x)); }</code> </pre><br><p>  Ou seja, para qualquer n√∫mero natural, a fun√ß√£o retorna seu logaritmo bin√°rio mais 1 e para 0 retorna 0. E essa n√£o √© uma tarefa da escola para o operador if / else, isso √© realmente uma coisa √∫til - o n√∫mero m√≠nimo de bits nos quais esse valor se ajustar√°.  Apenas adivinhar pelo nome da fun√ß√£o √© quase imposs√≠vel. </p><br><h2 id="primer-2-stdbless">  Exemplo 2: std :: bless () </h2><br><p>  <em>Agora n√£o ser√° sobre o nome</em> </p><br><p>  Uma pequena digress√£o: em C ++, a aritm√©tica de ponteiro funciona apenas com ponteiros para criar elementos de matriz.  O que, em princ√≠pio, √© l√≥gico: no caso geral, o conjunto de objetos vizinhos √© desconhecido e "qualquer coisa pode acontecer em dez bytes √† direita da vari√°vel <code>i</code> ".  Esse √© um comportamento inequivocamente vago. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> obj = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = &amp;obj; ++ptr; <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre> <br><p>  Mas essa restri√ß√£o declara uma quantidade enorme de comportamento indefinido do c√≥digo existente.  Por exemplo, aqui est√° uma implementa√ß√£o simplificada de <code>std::vector&lt;T&gt;::reserve()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      auto new_memory = (T*) ::operator new(n * sizeof(T)); //    ‚Ä¶ //   auto size = this-&gt;size(); begin_ = new_memory; //   end_ = new_memory + size; //     end_capacity_ = new_memory + n; //    }</span></span></code> </pre> <br><p>  Alocamos mem√≥ria, movemos todos os objetos e agora tentamos garantir que os ponteiros indiquem para onde ir.  Aqui est√£o apenas as √∫ltimas tr√™s linhas indefinidas, porque cont√™m opera√ß√µes aritm√©ticas em ponteiros fora da matriz! </p><br><p>  Obviamente, n√£o √© o programador quem deve culpar.  O problema est√° no pr√≥prio padr√£o C ++, que declara que esse peda√ßo de c√≥digo obviamente razo√°vel √© um comportamento indefinido.  Portanto, <a href="https://wg21.link/p0593">P0593</a> sugere corrigir o padr√£o adicionando algumas fun√ß√µes (como <code>::operator new</code> e <code>std::malloc</code> ) a capacidade de criar matrizes conforme necess√°rio.  Todos os ponteiros criados por eles se tornar√£o magicamente ponteiros para matrizes e opera√ß√µes aritm√©ticas podem ser executadas com eles. </p><br><p>  <em>Ainda n√£o √© sobre os nomes, espere um segundo.</em> </p><br><p>  Mas, √†s vezes, opera√ß√µes em ponteiros s√£o necess√°rias ao trabalhar com mem√≥ria que uma dessas fun√ß√µes n√£o alocou.  Por exemplo, a fun√ß√£o <code>deallocate()</code> trabalha essencialmente com mem√≥ria morta, na qual n√£o h√° objetos, mas ainda assim deve adicionar o ponteiro e o tamanho da √°rea.  Nesse caso, o P0593 ofereceu a fun√ß√£o <code>std::bless(void* ptr, std::size_t n)</code> (havia outra fun√ß√£o l√°, tamb√©m chamada de <code>bless</code> , mas n√£o √© isso).  N√£o tem efeito em um computador f√≠sico da vida real, mas cria objetos para uma m√°quina abstrata que permitiria o uso da aritm√©tica de ponteiros. </p><br><p>  O nome <code>std::bless</code> era tempor√°rio. </p><br><p>  <em>Ent√£o, o nome.</em> </p><br><p>  Em Col√¥nia, o LEWG recebeu a tarefa de criar um nome para esta fun√ß√£o.  As op√ß√µes <code>implicitly_create_objects()</code> e <code>implicitly_create_objects_as_needed()</code> foram propostas, porque √© isso que a fun√ß√£o faz. </p><br><p>  Eu n√£o gostei dessas op√ß√µes. </p><br><h2 id="primer-3-stdpartial_sort_copy">  Exemplo 3: std :: parcial_sort_copy () </h2><br><p>  <em>Exemplo retirado <a href="https://www.youtube.com/watch%3Fv%3DMBRoCdtZOYg">da apresenta√ß√£o</a> de <a href="https://www.youtube.com/watch%3Fv%3DMBRoCdtZOYg">Kate</a></em> </p><br><p>  Existe uma fun√ß√£o <code>std::sort</code> , que classifica os elementos do cont√™iner: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vec = {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(vec.begin(), vec.end()); <span class="hljs-comment"><span class="hljs-comment">// vec == {1, 2, 3, 4, 5}</span></span></code> </pre> <br><p>  H√° tamb√©m <code>std::partial_sort</code> , que classifica apenas parte dos elementos: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vec = {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::partial_sort(vec.begin(), vec.begin() + <span class="hljs-number"><span class="hljs-number">3</span></span>, vec.end()); <span class="hljs-comment"><span class="hljs-comment">// vec == {1, 2, 3, ?, ?} ( ...4,5,  ...5,4)</span></span></code> </pre> <br><p>  E ainda existe <code>std::partial_sort_copy</code> , que tamb√©m classifica parte dos elementos, mas ao mesmo tempo o cont√™iner antigo n√£o muda, mas transfere os valores para o novo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vec = {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; out; out.resize(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::partial_sort_copy(vec.begin(), vec.end(), out.begin(), out.end()); <span class="hljs-comment"><span class="hljs-comment">// out == {1, 2, 3}</span></span></code> </pre> <br><p>  Kate alega que <code>std::partial_sort_copy</code> √© um nome mais ou menos, e eu concordo com ela. </p><br><h2 id="nazvanie-implementacii-i-nazvanie-rezultata">  Nome da Implementa√ß√£o e Nome do Resultado </h2><br><p>  Nenhum dos nomes listados √©, estritamente falando, <em>incorreto</em> : todos descrevem perfeitamente o que a fun√ß√£o faz.  <code>std::log2p1()</code> realmente conta o logaritmo bin√°rio e adiciona um a ele;  <code>implicitly_create_objects()</code> cria objetos implicitamente e <code>std::partial_sort_copy()</code> classifica parcialmente o cont√™iner e copia o resultado.  No entanto, n√£o gosto de todos esses nomes, porque s√£o <em>in√∫teis</em> . </p><br><p>  Nenhum programador se senta e pensa: ‚ÄúGostaria de poder pegar o logaritmo bin√°rio e adicionar um a ele‚Äù.  Ele precisa saber quantos bits o valor fornecido caber√° e, sem √™xito, procura nas docas algo como <code>bit_width</code> .  Quando ele chega ao usu√°rio da biblioteca, o que o logaritmo bin√°rio tem a ver com ele, ele j√° escreveu sua implementa√ß√£o (e provavelmente perdeu a verifica√ß√£o de zero).  Mesmo que <code>std::log2p1</code> tenha sido um milagre no c√≥digo, o pr√≥ximo a ver esse c√≥digo deve entender novamente o que √© e por que √© necess√°rio.  <code>bit_width(max_value)</code> n√£o teria esse problema. </p><br><p>  Da mesma forma, ningu√©m precisa ‚Äúcriar objetos implicitamente‚Äù ou ‚Äúclassificar parcialmente uma c√≥pia de um vetor‚Äù - eles precisam reutilizar a mem√≥ria ou obter os 5 maiores valores em ordem decrescente.  Algo como <code>recycle_storage()</code> (que tamb√©m foi sugerido como o nome <code>std::bless</code> ) e <code>top_n_sorted()</code> seria muito mais claro. </p><br><p>  O Kate usa o termo <em>nome de implementa√ß√£o</em> para <code>std::partial_sort_copy()</code> , mas tamb√©m se encaixa em outras duas fun√ß√µes.  A implementa√ß√£o de seu nome √© realmente descrita perfeitamente.  Isso √© apenas o usu√°rio precisa do nome do resultado - o que ele obt√©m chamando a fun√ß√£o.  Para a estrutura interna dela, ele n√£o se importa, ele s√≥ quer descobrir o tamanho em bits ou reutilizar a mem√≥ria. </p><br><p>  <strong>Nomear uma fun√ß√£o com base em suas especifica√ß√µes significa criar do nada um mal-entendido entre o desenvolvedor da biblioteca e seu usu√°rio.</strong>  <strong>Voc√™ deve sempre lembrar quando e como a fun√ß√£o ser√° usada.</strong> </p><br><p>  Isso parece brega, sim.  Mas, julgando por <code>std::log2p1()</code> , isso est√° longe de ser √≥bvio para todos.  Al√©m disso, √†s vezes n√£o √© t√£o simples. </p><br><h2 id="primer-4-stdpopcount">  Exemplo 4: std :: popcount () </h2><br><p>  <code>std::popcount()</code> , como <code>std::log2p1()</code> , em C ++ 20 prop√µe-se adicionar ao <code>&lt;bit&gt;</code> .  E esse, √© claro, √© um nome monstruosamente ruim.  Se voc√™ n√£o sabe o que essa fun√ß√£o faz, √© imposs√≠vel adivinhar.  A abrevia√ß√£o n√£o √© apenas confusa (existe pop no nome, mas pop / push n√£o tem nada a ver com isso) - decifrar a contagem da popula√ß√£o (contar a popula√ß√£o? O n√∫mero de popula√ß√µes?) Tamb√©m n√£o ajuda. </p><br><p>  Por outro lado, <code>std::popcount()</code> ideal para esta fun√ß√£o porque chama a instru√ß√£o popcount de instru√ß√µes de montagem.  Este n√£o √© apenas o <em>nome da</em> implementa√ß√£o - √© sua descri√ß√£o completa. </p><br><p>  No entanto, neste caso, a diferen√ßa entre desenvolvedores de linguagem e programadores n√£o √© t√£o grande.  Uma instru√ß√£o que conta o n√∫mero de unidades em uma palavra bin√°ria √© chamada de popcount a partir dos anos sessenta.  Para uma pessoa que sabe alguma coisa sobre opera√ß√µes de bits, esse nome √© absolutamente √≥bvio. </p><br><p>  <em>A prop√≥sito, uma boa pergunta: voc√™ pensa em nomes que s√£o convenientes para iniciantes ou os deixa familiares para os velhos?</em> </p><br><h2 id="heppi-end">  Final feliz? </h2><br><p>  <a href="https://wg21.link/P1956">P1956</a> sugere renomear <code>std::log2p1()</code> para <code>std::bit_width()</code> .  √â prov√°vel que esta proposta seja aceita em C ++ 20.  <code>std::ceil2</code> e <code>std::floor2</code> tamb√©m ser√£o renomeados para std :: bit_ceil () e std :: bit_floor () respectivamente.  Os nomes antigos tamb√©m n√£o eram muito, mas por outros motivos. </p><br><p>  O LEWG em Col√¥nia n√£o selecionou <code>implicitly_create_objects[_as_needed]</code> nem <code>recycle_storage</code> como o nome para <code>std::bless</code> .  Eles decidiram n√£o incluir essa fun√ß√£o no padr√£o.  O mesmo efeito pode ser alcan√ßado criando explicitamente uma matriz de bytes; portanto, eles dizem que a fun√ß√£o n√£o √© necess√°ria.  N√£o gosto disso porque chamar <code>std::recycle_storage()</code> seria mais leg√≠vel.  Outro <code>std::bless()</code> ainda existe, mas agora √© chamado <code>start_lifetime_as</code> .  Eu gosto disso.  Deve entrar no C ++ 23. </p><br><p>  √â claro que <code>std::partial_sort_copy()</code> n√£o <code>std::partial_sort_copy()</code> mais renomeado - com esse nome, ele entrou no padr√£o em 1998. Mas pelo menos <code>std::log2p1</code> corrigido, e isso n√£o √© ruim. </p><br><p>  Ao apresentar os nomes das fun√ß√µes, voc√™ precisa pensar sobre quem as usar√° e o que ele deseja delas.  Como Kate disse, <strong>nomear exige empatia</strong> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt484860/">https://habr.com/ru/post/pt484860/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt484836/index.html">C√°lculo da rentabilidade da Tarifa Verde em 2020, Ucr√¢nia</a></li>
<li><a href="../pt484838/index.html">13 exemplos de configura√ß√£o de regras no Google Ads [instru√ß√£o]</a></li>
<li><a href="../pt484840/index.html">GOTO Return</a></li>
<li><a href="../pt484846/index.html">Meu relacionamento com c√≥digo aberto</a></li>
<li><a href="../pt484854/index.html">Execute o jogo em c # no MS-DOS</a></li>
<li><a href="../pt484862/index.html">Migrando do AngularJS para o Angular7 por meio de um aplicativo h√≠brido</a></li>
<li><a href="../pt484866/index.html">Usando o Astra Linux em um computador embarcado ARM</a></li>
<li><a href="../pt484868/index.html">Como medir a melhoria da equipe? Parte 2</a></li>
<li><a href="../pt484870/index.html">Como o ingl√™s mudou a Ilona Mask por 20 anos</a></li>
<li><a href="../pt484874/index.html">"O seu especialista em TI est√° quebrado, traga um novo": como construir uma carreira em TI e n√£o enlouquecer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>