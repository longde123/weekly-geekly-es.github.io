<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõÄ üí™üèΩ üë®üèº‚Äçüé® DMA: mitos y realidad üñêüèæ üë®üèæ‚Äçü§ù‚Äçüë®üèΩ üöò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 En un art√≠culo anterior ( "Parte 2: Uso de bloques Cypress PSoC UDB para reducir el n√∫mero de interrupciones en una impresora 3D" ), no...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DMA: mitos y realidad</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437112/"><img src="https://habrastorage.org/webt/m4/12/q3/m412q3b8zbug620xzvv0the7ix0.jpeg"><br><br><h2>  Introduccion </h2><br>  En un art√≠culo anterior ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Parte 2: Uso de bloques Cypress PSoC UDB para reducir el n√∫mero de interrupciones en una impresora 3D"</a> ), not√© un hecho muy interesante: si una m√°quina en UDB elimin√≥ datos de FIFO demasiado r√°pido, logr√≥ notar el estado de que hay nuevos no hay datos en FIFO, despu√©s de lo cual pasa a un estado falso <b>Inactivo</b> .  Por supuesto, estaba interesado en este hecho.  Mostr√© los resultados abiertos a un grupo de conocidos.  Una persona respondi√≥ que todo esto era bastante obvio, e incluso mencion√≥ las razones.  El resto no estaba menos sorprendido que yo al comienzo de la investigaci√≥n.  Por lo tanto, algunos expertos no encontrar√°n nada nuevo aqu√≠, pero ser√≠a bueno llevar esta informaci√≥n al p√∫blico en general para que todos los programadores de microcontroladores la tengan en cuenta. <br><a name="habracut"></a><br>  No es que fuera un colapso de alg√∫n tipo de cobertura.  Result√≥ que todo esto est√° bien documentado, pero el problema es que no est√° en lo principal, sino en documentos adicionales.  Y personalmente, estaba felizmente ignorante, creyendo que DMA es un subsistema muy √°gil que puede aumentar dram√°ticamente la eficiencia de los programas, ya que hay una transferencia sistem√°tica de datos sin distraer el incremento del registro y organizar el ciclo con los mismos comandos.  En cuanto a mejorar la eficiencia, todo es cierto, pero debido a cosas ligeramente diferentes. <br><br>  Pero lo primero es lo primero. <br><br><h2>  Experimentos con Cypress PSoC </h2><br>  Hagamos una m√°quina simple.  Condicionalmente tendr√° dos estados: el estado inactivo y el estado en el que caer√° cuando haya al menos un byte de datos en FIFO.  Al ingresar a tal estado, simplemente toma estos datos y luego nuevamente cae en un estado de reposo.  La palabra "condicional" no la cit√© accidentalmente.  Tenemos dos FIFO, por lo que har√© dos de esos estados, uno para cada FIFO, para asegurarme de que son completamente id√©nticos en comportamiento.  El gr√°fico de transici√≥n para la m√°quina result√≥ as√≠: <br><br><img src="https://habrastorage.org/webt/pv/cu/1q/pvcu1qmbxk9zkbgxk8u51unthpe.png"><br><br>  Los indicadores para salir del estado inactivo se definen de la siguiente manera: <br><br><img src="https://habrastorage.org/webt/h8/re/rp/h8rerphupbsfvawmjiwgwqr_thw.png"><br><br>  No olvide enviar los bits del n√∫mero de estado a las entradas de Datapath: <br><br><img src="https://habrastorage.org/webt/ze/dz/ab/zedzab8iuaoxnu0esg32xwwga3g.png"><br><br>  En el exterior, emitimos dos grupos de se√±ales: un par de se√±ales de que FIFO tiene espacio libre (para que DMA pueda comenzar a cargar datos) y un par de se√±ales de que FIFO est√°n vac√≠as (para mostrar este hecho en un osciloscopio). <br><br><img src="https://habrastorage.org/webt/ts/bm/dn/tsbmdn-puyugsmixnsipf81pboa.png"><br><br>  ALU simplemente tomar√° datos ficticios de FIFO: <br><br><img src="https://habrastorage.org/webt/px/5s/_w/px5s_wj1zqwjedrk0h7ty7tbu_4.png"><br><br>  D√©jame mostrarte los detalles del estado "0001": <br><br><img src="https://habrastorage.org/webt/mb/-s/j0/mb-sj05-chkdijmqn3mue8hmjnk.png"><br><br>  Tambi√©n configur√© el ancho del bus, que estaba en el proyecto en el que not√© este efecto, 16 bits: <br><br><img src="https://habrastorage.org/webt/sa/hc/br/sahcbrgearj6wnw5-4lykaew1qy.png"><br><br>  Pasamos al esquema del proyecto en s√≠.  Exteriormente, doy no solo se√±ales de que el FIFO est√° vac√≠o, sino tambi√©n pulsos de reloj.  Esto me permitir√° prescindir de las mediciones del cursor en un osciloscopio.  Solo puedo tomar medidas con el dedo. <br><br><img src="https://habrastorage.org/webt/b-/8v/iq/b-8viqzbm1isamdkiljvmwevwme.png"><br><br>  Aparentemente, hice 24 megahercios de velocidad de reloj.  La frecuencia central del procesador es exactamente la misma.  Cuanto m√°s baja es la frecuencia, menos interferencia hay en un osciloscopio chino (oficialmente tiene una banda de 250 MHz, pero luego megahercios chinos), y todas las mediciones se realizar√°n con respecto a los pulsos de reloj.  Cualquiera sea la frecuencia, el sistema seguir√° funcionando con respecto a ellos.  Hubiera establecido un megahercio, pero el entorno de desarrollo me prohibi√≥ ingresar un valor de frecuencia central del procesador de menos de 24 MHz. <br><br>  Ahora las cosas de prueba.  Para escribir a FIFO0, hice esta funci√≥n: <br><br><pre><code class="plaintext hljs">void WriteTo0FromROM() { static const uint16 steps[] = { 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001, 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001 }; //  DMA  ,      uint8 channel = DMA_0_DmaInitialize (sizeof(steps[0]),1,HI16(steps),HI16(JustReadFromFIFO_1_Datapath_1_F0_PTR)); CyDmaChRoundRobin (channel,1); //       ,       uint8 td = CyDmaTdAllocate(); //       .  ,    . CyDmaTdSetConfiguration(td, sizeof(steps), CY_DMA_DISABLE_TD, TD_INC_SRC_ADR / TD_AUTO_EXEC_NEXT); //       CyDmaTdSetAddress(td, LO16((uint32)steps), LO16((uint32)JustReadFromFIFO_1_Datapath_1_F0_PTR)); //      CyDmaChSetInitialTd(channel, td); //         CyDmaChEnable(channel, 1); }</code> </pre> <br>  La palabra ROM en el nombre de la funci√≥n se debe al hecho de que la matriz que se enviar√° se almacena en el √°rea ROM, y el Cortex M3 tiene una arquitectura de Harvard.  La velocidad de acceso al bus RAM y al bus ROM puede variar, quer√≠a comprobarlo, por lo que tengo una funci√≥n similar para enviar una matriz desde RAM (la matriz de <b>pasos</b> no tiene un modificador de <b>constante est√°tico</b> en su cuerpo).  Bueno, hay el mismo par de funciones para enviar a FIFO1, el registro del receptor es diferente all√≠: no F0, sino F1.  De lo contrario, todas las funciones son id√©nticas.  Como no not√© mucha diferencia en los resultados, considerar√© los resultados de invocar exactamente la funci√≥n anterior.  Un rayo amarillo - pulsos de reloj, salida azul <b>FIFO0 vac√≠o</b> . <br><br><img src="https://habrastorage.org/webt/ko/65/0j/ko650jp1nj58h1nm5dzal4bzdhw.png"><br><br>  Primero, verifique la plausibilidad de por qu√© el FIFO se completa en dos ciclos de reloj.  Veamos este sitio con m√°s detalle: <br><br><img src="https://habrastorage.org/webt/ox/fi/x_/oxfix_l8jpspyxgbiumrlagm9ma.png"><br><br>  En el borde 1, los datos caen en FIFO, el indicador de <b>FIFO0enmpty</b> cae.  En el borde 2, el aut√≥mata ingresa al estado <b>GetDataFromFifo1</b> .  En el borde 3, en este estado, los datos de FIFO se copian en el registro ALU, se vac√≠a FIFO, se vuelve a <b>levantar el</b> indicador de <b>vac√≠o FIFO0</b> .  Es decir, la forma de onda se comporta de manera plausible, puede contar con ella durante el ciclo del reloj.  Obtenemos 9 piezas. <br><br><img src="https://habrastorage.org/webt/fc/mq/bj/fcmqbjhfee7mf7u7_xnkgyspq18.png"><br><br>  <b>En total, en el √°rea inspeccionada, se necesitan 9 ciclos de reloj para copiar una palabra de datos de RAM a UDB usando DMA.</b> <br><br>  Y ahora lo mismo, pero con la ayuda del n√∫cleo del procesador.  Primero, un c√≥digo ideal que dif√≠cilmente se puede lograr en la vida real: <br><br><pre> <code class="plaintext hljs"> volatile uint16_t* ptr = (uint16_t*)JustReadFromFIFO_1_Datapath_1_F0_PTR; ptr[0] = 0; ptr[0] = 0;</code> </pre><br>  lo que se convertir√° en c√≥digo de ensamblaje: <br><br><pre> <code class="plaintext hljs"> ldr r3, [pc, #8] ; (90 &lt;main+0xc&gt;) movs r2, #0 strh r2, [r3, #0] strh r2, [r3, #0] bn 8e &lt;main+0xa&gt; .word 0x40006898</code> </pre><br>  Sin descansos, sin ciclos adicionales.  Dos pares de medidas seguidas ... <br><br><img src="https://habrastorage.org/webt/ms/po/gq/mspogqifm21mt0o34s0ltbh1fyu.png"><br><br>  Hagamos que el c√≥digo sea un poco m√°s real (con la sobrecarga de organizar el ciclo, obtener datos e incrementar los punteros): <br><br><pre> <code class="plaintext hljs">void SoftWriteTo0FromROM() { //         . //         static const uint16 steps[] = { 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001, 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001 }; uint16_t* src = steps; volatile uint16_t* dest = (uint16_t*)JustReadFromFIFO_1_Datapath_1_F0_PTR; for (int i=sizeof(steps)/sizeof(steps[0]);i&gt;0;i--) { *dest = *src++; } }</code> </pre><br>  c√≥digo de ensamblador recibido: <br><br><pre> <code class="plaintext hljs"> ldr r3, [pc, #14] ; (9c &lt;CYDEV_CACHE_SIZE&gt;) ldr r0, [pc, #14] ; (a0 &lt;CYDEV_CACHE_SIZE+0x4&gt;) add.w r1, r3, #28 ; 0x28 ldrh.w r2, [r3], #2 cmp r3, r1 strh r2, [r0, #0] bne.n 8e &lt;main+0xa&gt;</code> </pre><br>  En el oscilograma vemos solo 7 ciclos por ciclo versus nueve en el caso de DMA: <br><br><img src="https://habrastorage.org/webt/h5/5k/y0/h55ky0f4pfsfaco90dvfgahwwki.png"><br><br><h2>  Un poco sobre el mito </h2><br>  Para ser sincero, para m√≠ fue originalmente un shock.  De alguna manera, estoy acostumbrado a creer que el mecanismo DMA le permite transferir datos de manera r√°pida y eficiente.  1/9 de la frecuencia del bus no es tan r√°pida.  Pero result√≥ que nadie lo estaba ocultando.  El documento TRM para PSoC 5LP incluso contiene una serie de consideraciones te√≥ricas, y el documento "AN84810 - Temas avanzados de DMA de PSoC 3 y PSoC 5LP" describe en detalle el proceso de acceso a DMA.  La latencia es la culpable.  El ciclo de intercambio con el autob√∫s requiere un cierto n√∫mero de ticks.  En realidad, son estas medidas las que juegan un papel decisivo en la aparici√≥n de un retraso.  En general, nadie esconde nada, pero debes saberlo. <br><br>  <b>Si el famoso GPIF utilizado en FX2LP (otra arquitectura fabricada por Cypress) no limita nada, entonces el l√≠mite de velocidad se debe a las latencias que se producen al acceder al bus.</b> <br><br><h2>  Verificaci√≥n DMA en STM32 </h2><br>  Estaba tan impresionado que decid√≠ realizar un experimento en STM32.  Un STM32F103 que tiene el mismo n√∫cleo de procesador Cortex M3 se tom√≥ como un conejo experimental.  No tiene UDB de donde se puedan derivar las se√±ales de servicio, pero es muy posible verificar DMA.  ¬øQu√© es un GPIO?  Este es un conjunto de registros en un espacio de direcciones com√∫n.  Eso es genial  Configuramos DMA en el modo de copia ‚Äúmemoria-memoria‚Äù, especificando la memoria real (ROM o RAM) como la fuente, y el registro de datos GPIO sin el incremento de direcci√≥n como receptor.  Enviaremos all√≠ alternativamente 0 o 1, y arreglaremos el resultado con un osciloscopio.  Para comenzar, eleg√≠ el puerto B, fue m√°s f√°cil conectarme a √©l en el tablero. <br><br><img src="https://habrastorage.org/webt/od/u2/es/odu2esatrpusmpi8od4ecfaftk8.png"><br><br>  Realmente disfrut√© contar medidas con un dedo, no con cursores.  ¬øEs posible hacer lo mismo en este controlador?  Bastante!  Tome la frecuencia de reloj de referencia para el osciloscopio del tramo MCO, que est√° conectado al puerto PA8 en el STM32F10C8T6.  La elecci√≥n de las fuentes para este cristal barato no es excelente (el mismo STM32F103, pero m√°s impresionante, ofrece muchas m√°s opciones), enviaremos la se√±al SYSCLK a esta salida.  Dado que la frecuencia en la MCO no puede ser superior a 50 MHz, reduciremos la velocidad general del reloj del sistema a 48 MHz.  Multiplicaremos la frecuencia de cuarzo 8 MHz no por 9, sino por 6 (ya que 6 * 8 = 48): <br><br><img src="https://habrastorage.org/webt/0x/de/1a/0xde1acpu3rpgslyseaw2kcysc4.png"><br><br><div class="spoiler">  <b class="spoiler_title">Mismo texto:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void SystemClock_Config(void) { RCC_OscInitTypeDef RCC_OscInitStruct; RCC_ClkInitTypeDef RCC_ClkInitStruct; RCC_PeriphCLKInitTypeDef PeriphClkInit; /**Initializes the CPU, AHB and APB busses clocks */ RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; // RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6; if (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK) { _Error_Handler(__FILE__, __LINE__); }</code> </pre><br></div></div><br>  Programaremos la MCO utilizando la biblioteca <b>mcucpp</b> de Konstantin Chizhov (de ahora en adelante, conducir√© todas las llamadas al equipo a trav√©s de esta maravillosa biblioteca): <br><br><pre> <code class="plaintext hljs"> //  MCO Mcucpp::Clock::McoBitField::Set (0x4); //   MCO    Mcucpp::IO::Pa8::SetConfiguration (Mcucpp::IO::Pa8::Port::AltFunc); //     Mcucpp::IO::Pa8::SetSpeed (Mcucpp::IO::Pa8::Port::Fastest);</code> </pre><br>  Bueno, ahora configuramos la salida de la matriz de datos en el GPIOB: <br><br><pre> <code class="plaintext hljs">typedef Mcucpp::IO::Pb0 dmaTest0; typedef Mcucpp::IO::Pb1 dmaTest1; ... //  GPIOB      dmaTest0::ConfigPort::Enable(); dmaTest0::SetDirWrite(); dmaTest1::ConfigPort::Enable(); dmaTest1::SetDirWrite(); uint16_t dataForDma[]={0x0000,0x8001,0x0000,0x8001,0x0000, 0x8001,0x0000,0x8001,0x0000,0x8001,0x0000,0x8001,0x0000,0x8001}; typedef Mcucpp::Dma1Channel1 channel; //    dmaTest1::Set(); dmaTest1::Clear(); dmaTest1::Set(); // ,    DMA channel::Init (channel::Mem2Mem|channel::MSize16Bits|channel::PSize16Bits|channel::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); while (1) { } }</code> </pre><br>  La forma de onda resultante es muy similar a la del PSoC. <br><br><img src="https://habrastorage.org/webt/ee/nl/2i/eenl2ix0_9zgzgaaxxeffbjzwjk.png"><br><br>  En el medio hay una gran joroba azul.  Este es el proceso de inicializaci√≥n de DMA.  Los pulsos azules de la izquierda fueron recibidos √∫nicamente por software en PB1.  Est√≠ralos m√°s: <br><br><img src="https://habrastorage.org/webt/9l/y8/tp/9ly8tp_8hj1vohrh6jcnyktfa_a.png"><br><br>  2 medidas por pulso.  El funcionamiento del sistema es el esperado.  Pero ahora veamos el √°rea m√°s grande marcada en la forma de onda principal con un fondo azul oscuro.  En este punto, el bloque DMA ya se est√° ejecutando. <br><br><img src="https://habrastorage.org/webt/jw/fu/ds/jwfudsdqtgwfunc3htoczgrw5eg.png"><br><br>  10 ciclos por cambio de l√≠nea GPIO.  En realidad, el trabajo va con RAM, y el programa se repite en un ciclo constante.  No hay llamadas a RAM desde el n√∫cleo del procesador.  El bus est√° completamente a disposici√≥n de la unidad DMA, pero 10 ciclos.  Pero, de hecho, los resultados no son muy diferentes de los que se ven en el PSoC, as√≠ que simplemente comience a buscar Notas de aplicaci√≥n relacionadas con DMA en STM32.  Hab√≠a varios de ellos.  Hay AN2548 en F0 / F1, hay AN3117 en L0 / L1 / L3, hay AN4031 en F2 / F4 / F77.  Quiz√°s hay algunos m√°s ... <br><br>  Pero, sin embargo, de ellos vemos que tambi√©n aqu√≠, la latencia es la culpable.  Adem√°s, el acceso por lotes F103 al bus con DMA es imposible.  Son posibles para F4, pero no m√°s de cuatro palabras.  Entonces nuevamente surgir√° el problema de latencia. <br><br>  Intentemos realizar las mismas acciones, pero con la ayuda de un registro de programa.  Arriba, vimos que la grabaci√≥n directa en los puertos se realiza instant√°neamente.  Pero hab√≠a m√°s bien un registro perfecto.  Filas: <br><br><pre> <code class="plaintext hljs">//    dmaTest1::Set(); dmaTest1::Clear(); dmaTest1::Set();</code> </pre><br>  sujeto a dicha configuraci√≥n de optimizaci√≥n (debe especificar la optimizaci√≥n por tiempo): <br><br><img src="https://habrastorage.org/webt/zz/cs/vt/zzcsvtte2m06u7tzhkfefvfa8wg.png"><br><br>  convertido en el siguiente c√≥digo de ensamblador: <br><br><pre> <code class="plaintext hljs"> STR r6,[r2,#0x00] MOV r0,#0x20000 STR r0,[r2,#0x00] STR r6,[r2,#0x00]</code> </pre><br>  En la copia real, habr√° una llamada a la fuente, al receptor, un cambio en la variable del bucle, ramificaci√≥n ... En general, mucha sobrecarga (que, como se cree, simplemente elimina el DMA).  ¬øCu√°l ser√° la velocidad de los cambios en el puerto?  Entonces, escribimos: <br><br><pre> <code class="plaintext hljs">uint16_t* src = dataForDma; uint16_t* dest = (uint16_t*)&amp;GPIOB-&gt;ODR; for (int i=sizeof(dataForDma)/sizeof(dataForDma[0]);i&gt;0;i--) { *dest = *src++; }</code> </pre><br>  Este c√≥digo C ++ se convierte en dicho c√≥digo de ensamblaje: <br><br><pre> <code class="plaintext hljs"> MOVS r1,#0x0E LDRH r3,[r0],#0x02 STRH r3,[r2,#0x00] LDRH r3,[r0],#0x02 SUBS r1,r1,#2 STRH r3,[r2,#0x00] CMP r1,#0x00 BGT 0x080032A8</code> </pre><br>  Y obtenemos: <br><br><img src="https://habrastorage.org/webt/oj/m5/1d/ojm51d2qjhkz_rii2zfb4zvzdos.png"><br><br>  8 medidas en el medio ciclo superior y 6 en la mitad inferior (lo comprob√©, el resultado se repite para todos los medios per√≠odos).  La diferencia surgi√≥ porque el optimizador hizo 2 copias por iteraci√≥n.  Por lo tanto, se agregan 2 medidas en uno de los medios per√≠odos a la operaci√≥n de sucursal. <br><br>  <b>En t√©rminos generales, con la copia de software, se gastan 14 medidas en copiar dos palabras contra 20 medidas en la misma, pero por DMA.</b>  <b>El resultado est√° bastante documentado, pero es muy inesperado para aquellos que a√∫n no han le√≠do la literatura extendida.</b> <br><br>  Bueno  Pero, ¬øqu√© sucede si comienza a escribir datos en dos flujos DMA a la vez?  ¬øCu√°nta velocidad caer√°?  Conecte el rayo azul a PA0 y vuelva a escribir el programa de la siguiente manera: <br><br><pre> <code class="plaintext hljs">typedef Mcucpp::Dma1Channel1 channel1; typedef Mcucpp::Dma1Channel2 channel2; // ,    DMA channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2);</code> </pre><br>  Primero, examinemos la naturaleza de los pulsos: <br><br><img src="https://habrastorage.org/webt/vu/ki/pg/vukipghxkaqqtxdnvz4a2qjp1wu.png"><br><br>  Mientras se sintoniza el segundo canal, la velocidad de copia para el primero es mayor.  Luego, al copiar en pares, la velocidad disminuye.  Cuando finaliza el primer canal, el segundo comienza a funcionar m√°s r√°pido.  Todo es l√≥gico, solo queda descubrir exactamente cu√°nto cae la velocidad. <br><br>  Si bien solo hay un canal, la grabaci√≥n toma de 10 a 12 compases (los d√≠gitos est√°n flotando). <br><br><img src="https://habrastorage.org/webt/iw/1l/lk/iw1llkwh0nki1yczmva7gzxgrgk.png"><br><br>  Durante la colaboraci√≥n, obtenemos 16 ciclos por registro en cada puerto: <br><br><img src="https://habrastorage.org/webt/f6/vf/o3/f6vfo3mgv4mpos2kdrrwmo9dzsm.png"><br><br>  Es decir, la velocidad no se reduce a la mitad.  Pero, ¬øqu√© pasa si comienzas a escribir en tres hilos a la vez?  Agregamos trabajo con PC15, ya que PC0 no se emite (es por eso que no se emiten 0, 1, 0, 1 ..., sino 0x0000,0x8001, 0x0000, 0x8001 ... en la matriz). <br><br><pre> <code class="plaintext hljs">typedef Mcucpp::Dma1Channel1 channel1; typedef Mcucpp::Dma1Channel2 channel2; typedef Mcucpp::Dma1Channel3 channel3; // ,    DMA channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel3::Init (channel3::Mem2Mem|channel3::MSize16Bits|channel3::PSize16Bits|channel3::PeriphIncriment,(void*)&amp;GPIOC-&gt;ODR,dataForDma,sizeof(dataForDma)/2);</code> </pre><br>  Aqu√≠ el resultado es tan inesperado que apago el haz que muestra la frecuencia del reloj.  No tenemos tiempo para mediciones.  Nos fijamos en la l√≥gica del trabajo. <br><br><img src="https://habrastorage.org/webt/zo/u3/5s/zou35sqtetrlryln8lxe04tdkwy.png"><br><br>  Hasta que el primer canal termin√≥ el trabajo, el tercero no comenz√≥ a funcionar.  ¬°Tres canales al mismo tiempo no funcionan!  Algo sobre este tema se puede deducir de AppNote a DMA, dice que F103 tiene solo dos motores en un bloque (y copiamos usando un bloque de DMA, el segundo est√° inactivo ahora, y el volumen del art√≠culo ya es tal que puedo usarlo No lo har√©)  Reescribimos el programa de muestra para que el tercer canal comience antes que todos los dem√°s: <br><br><img src="https://habrastorage.org/webt/bs/ld/kc/bsldkce9ztqrbk15x7e1omcharg.png"><br><br><div class="spoiler">  <b class="spoiler_title">Mismo texto:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">// ,    DMA channel3::Init (channel3::Mem2Mem|channel3::MSize16Bits|channel3::PSize16Bits|channel3::PeriphIncriment,(void*)&amp;GPIOC-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2);</code> </pre><br></div></div><br>  La imagen cambiar√° de la siguiente manera: <br><br><img src="https://habrastorage.org/webt/jg/wr/_2/jgwr_2kidbaoxg_-17muiyvo3n4.png"><br><br>  Se lanz√≥ el tercer canal, incluso funcion√≥ junto con el primero, pero cuando el segundo ingres√≥ al negocio, el tercero fue suplantado hasta que se complet√≥ el primer canal. <br><br><h2>  Un poco sobre prioridades </h2><br>  En realidad, la imagen anterior est√° relacionada con las prioridades de DMA, hay algunas.  Si todos los canales en funcionamiento tienen la misma prioridad, sus n√∫meros entran en juego.  Dentro de una prioridad dada, quien tiene un n√∫mero menor es el que tiene prioridad.  Probemos con el tercer canal para indicar una prioridad global diferente, elev√°ndola por encima de todas las dem√°s (en el camino, tambi√©n aumentaremos la prioridad del segundo canal): <br><br><img src="https://habrastorage.org/webt/40/qo/c5/40qoc5ngwnq2tenzpmcc2ornd4w.png"><br><br><div class="spoiler">  <b class="spoiler_title">Mismo texto:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">channel3::Init (channel3::PriorityVeryHigh|channel3::Mem2Mem|channel3::MSize16Bits|channel3::PSize16Bits|channel3::PeriphIncriment,(void*)&amp;GPIOC-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel1::PriorityVeryHigh|channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2);</code> </pre><br></div></div><br>  Ahora el primero que sol√≠a ser el m√°s cool estar√° en desventaja. <br><br><img src="https://habrastorage.org/webt/te/mq/_7/temq_7wguw109a0t-oi_rsi3jju.png"><br><br>  En total, vemos que incluso jugando en prioridades, STM32F103 no puede lanzar m√°s de dos hilos en un bloque DMA.  En principio, el tercer hilo se puede ejecutar en el n√∫cleo del procesador.  Esto nos permitir√° comparar el rendimiento. <br><br><pre> <code class="plaintext hljs">// ,    DMA channel3::Init (channel3::Mem2Mem|channel3::MSize16Bits|channel3::PSize16Bits|channel3::PeriphIncriment,(void*)&amp;GPIOC-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2); uint16_t* src = dataForDma; uint16_t* dest = (uint16_t*)&amp;GPIOB-&gt;ODR; for (int i=sizeof(dataForDma)/sizeof(dataForDma[0]);i&gt;0;i--) { *dest = *src++; }</code> </pre><br>  Primero, la imagen general, que muestra que todo funciona en paralelo y que el n√∫cleo del procesador tiene la velocidad de copia m√°s alta: <br><br><img src="https://habrastorage.org/webt/yq/bc/ah/yqbcahagnawdxrr70dh7zvbetmo.png"><br><br>  Y ahora les dar√© a todos la oportunidad de contar las medidas en un momento en que todas las secuencias de copia est√©n activas: <br><br> <a href=""><img src="https://habrastorage.org/webt/_m/m9/2b/_mm92b5yfgjltz6cizilmdtg4d4.png"></a> <br><br><h2>  El n√∫cleo del procesador prioriza todos </h2><br>  Ahora volvamos al hecho de que durante la operaci√≥n de dos subprocesos, mientras el segundo canal estaba sintonizado, el primero proporcion√≥ datos para un n√∫mero diferente de ciclos de reloj.  Este hecho tambi√©n est√° bien documentado en AppNote en DMA.  El hecho es que durante la configuraci√≥n del segundo canal, las solicitudes a RAM se enviaban peri√≥dicamente, y el n√∫cleo del procesador tiene mayor prioridad al acceder a la RAM que el n√∫cleo DMA.  Cuando el procesador solicit√≥ algunos datos, DMA elimin√≥ los ciclos de reloj, recibi√≥ datos con un retraso, por lo tanto, se copi√≥ m√°s lentamente.  Hagamos el √∫ltimo experimento de hoy.  Llevemos el trabajo a uno m√°s real.  Despu√©s de iniciar DMA, no entraremos en un ciclo vac√≠o (cuando definitivamente no hay acceso a RAM), sino que realizaremos una operaci√≥n de copia de RAM a RAM, pero esta operaci√≥n no estar√° relacionada con la operaci√≥n de los n√∫cleos de DMA: <br><br><pre> <code class="plaintext hljs">channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2); uint32_t src1[0x200]; uint32_t dest1 [0x200]; while (1) { uint32_t* src = src1; uint32_t* dest = dest1; for (int i=sizeof(src1)/sizeof(src1[0]);i&gt;0;i--) { *dest++ = *src++; } }</code> </pre><br> <a href=""><img src="https://habrastorage.org/webt/ks/k-/c6/ksk-c6feobygy2krzseq0nlka78.png"></a> <br><br>  En algunos lugares, el ciclo se extendi√≥ de 16 a 17 medidas.  Ten√≠a miedo de que fuera peor. <br><br><h2>  Comienza a sacar conclusiones </h2><br>  En realidad, pasamos a lo que quer√≠a decir. <br><br>  Comenzar√© desde lejos.  Hace unos a√±os, comenzando a estudiar STM32, estudi√© las versiones de MiddleWare para USB que exist√≠an en ese momento y me pregunt√© por qu√© los desarrolladores eliminaron la transferencia de datos a trav√©s de DMA.  Era evidente que inicialmente tal opci√≥n estaba a la vista, luego fue llevada a los patios traseros, y al final solo quedaban rudimentos.  Ahora estoy empezando a sospechar que entiendo a los desarrolladores. <br><br>  En el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primer art√≠culo sobre UDB,</a> dije que aunque UDB puede trabajar con datos paralelos, es poco probable que pueda reemplazar GPIF consigo mismo, ya que el bus USB PSoC funciona a velocidad m√°xima versus alta velocidad para FX2LP.  Resulta que hay un factor limitante m√°s serio.  DMA simplemente no tiene tiempo para entregar datos a la misma velocidad que GPIF, incluso dentro del controlador, sin tener en cuenta el bus USB. <br><br>  Como puede ver, no hay una sola entidad DMA.  En primer lugar, cada fabricante lo hace a su manera.  No solo eso, incluso un fabricante para diferentes familias puede variar el enfoque para construir DMA.  Si planea cargar seriamente esta unidad, debe considerar cuidadosamente si se satisfar√°n las necesidades. <br><br>  Probablemente, es necesario diluir el flujo pesimista con un comentario optimista.  Incluso la destacar√©. <br><br>  <b>Los controladores DMA de Cortex M le permiten aumentar el rendimiento del sistema seg√∫n el principio de las famosas jabalinas: "Lanzar y olvidar".</b>  <b>S√≠, el software que copia datos es un poco m√°s r√°pido.</b>  <b>Pero si necesita copiar varios subprocesos, ning√∫n optimizador puede hacer que el procesador los controle a todos sin la sobrecarga de la recarga del registro y los bucles giratorios.</b>  <b>Adem√°s, para puertos lentos, el procesador a√∫n debe esperar la disponibilidad, y DMA lo hace a nivel de hardware.</b> <br><br>  Pero incluso aqu√≠ son posibles varios matices.  Si el puerto es relativamente lento ... Bueno, digamos, un SPI que funciona a la frecuencia m√°s alta posible, entonces hay situaciones te√≥ricamente posibles cuando el DMA no tiene tiempo para recopilar datos del b√∫fer y se produce un desbordamiento.  O viceversa: coloque los datos en el registro del b√∫fer.  Cuando el flujo de datos es √∫nico, es poco probable que esto suceda, pero cuando hay muchos de ellos, vimos qu√© superposiciones sorprendentes pueden ocurrir.  Para lidiar con esto, debe desarrollar tareas no por separado, sino en combinaci√≥n.  Y los probadores intentan provocar tales problemas (un trabajo tan destructivo para los probadores). <br><br>  Una vez m√°s, nadie oculta estos datos.  Pero por alguna raz√≥n, todo esto generalmente no est√° contenido en el documento principal, sino en las Notas de aplicaci√≥n.  Entonces, mi tarea era llamar la atenci√≥n de los programadores sobre el hecho de que DMA no es una panacea, sino solo una herramienta conveniente. <br><br>  Pero, por supuesto, no solo los programadores, sino tambi√©n los desarrolladores de hardware.  Digamos que, en nuestra organizaci√≥n, se est√° desarrollando un gran complejo de software y hardware para la depuraci√≥n remota de sistemas integrados.  La idea es que alguien est√° desarrollando un dispositivo, pero quiere pedir el "firmware" en el lateral.  Y por alguna raz√≥n, no puede proporcionar equipos a un lado.  Puede ser voluminoso, puede ser costoso, puede ser √∫nico y "necesitarlo usted mismo", diferentes grupos pueden trabajar con √©l en diferentes zonas horarias, proporcionando una especie de trabajo de varios turnos, siempre se lo puede recordar ... En general, puede encontrar razones mucho, nuestro grupo simplemente defraud√≥ esta tarea. <br><br>  En consecuencia, el complejo de depuraci√≥n debe poder simular tantos dispositivos externos como sea posible, desde la simulaci√≥n trivial de presionar botones hasta varios protocolos SPI, I2C, CAN, 4-20 mA y otras cosas m√°s, de modo que a trav√©s de ellos los emuladores puedan recrear diferentes comportamientos externos bloques conectados al equipo que se est√° desarrollando (personalmente, en un momento realic√© muchos simuladores para la depuraci√≥n en tierra de accesorios para helic√≥pteros, en nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sitio web se buscan los casos correspondientes con la palabra Cassel Aero</a> ). <br><br>  Y as√≠, en los requisitos t√©cnicos para el desarrollo de ciertos requisitos.  Tanto SPI, tanto I2C, tanto GPIO.  Deben operar a frecuencias tan extremas.  Todo parece estar claro.  Ponemos STM32F4 y ULPI para trabajar con USB en modo HS.  La tecnolog√≠a est√° probada.  Pero aqu√≠ llega un largo fin de semana con las vacaciones de noviembre, que descubr√≠ con UDB.  Al ver que algo estaba mal, por las noches obtuve los resultados pr√°cticos que se dan al comienzo de este art√≠culo.  Y me di cuenta de que todo, por supuesto, es genial, pero no para este proyecto.  Como ya se√±al√©, cuando el posible rendimiento m√°ximo del sistema se acerca al l√≠mite superior, todo debe dise√±arse no por separado, sino en un complejo. <br><br>  Pero aqu√≠ el dise√±o integrado de tareas no puede ser en principio.       ,  ‚Äî   .           .    ,         FTDI.    --      ,       USB .  Por desgracia        DMA. , , ,    ,      ‚Äì  ,   . <br><br>   .        DMA   (,    10:    1    , ,    1 ,  10  )     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437112/">https://habr.com/ru/post/437112/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437102/index.html">Nuevo campe√≥n de Lego: Lego Boost</a></li>
<li><a href="../437104/index.html">Introscopio: bueno, pruebas unitarias muy flojas</a></li>
<li><a href="../437106/index.html">IT en la zona .it</a></li>
<li><a href="../437108/index.html">La mayor√≠a de los textos en Internet est√°n escritos por locos.</a></li>
<li><a href="../437110/index.html">Los nanomateriales est√°n cambiando nuestro mundo y todav√≠a no tenemos procedimientos para verificar su seguridad.</a></li>
<li><a href="../437114/index.html">Seminario web abierto: "SSH / NC / Socat: consejos y trucos"</a></li>
<li><a href="../437116/index.html">AWS, MongoDB y las realidades econ√≥micas del c√≥digo abierto</a></li>
<li><a href="../437118/index.html">AI y 2048. Parte 1: M√©todo Monte Carlo</a></li>
<li><a href="../437120/index.html">Silla de oficina coreana: sensaciones de milagro Harachair</a></li>
<li><a href="../437122/index.html">Nombrando cosas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>