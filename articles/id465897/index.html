<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😸 😎 🐿️ 10 Kesalahan Kerangka Musim Semi Paling Umum 👩🏿‍🚒 🥟 🚴🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya mempersembahkan kepada Anda terjemahan dari artikel “10 Kerangka Kerangka Kerja Pegas Paling Umum” oleh Toni Kukurin. 

 Musim semi m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>10 Kesalahan Kerangka Musim Semi Paling Umum</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465897/"> Halo, Habr!  Saya mempersembahkan kepada Anda terjemahan dari artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“10 Kerangka Kerangka Kerja Pegas Paling Umum”</a> oleh Toni Kukurin. <br><br>  Musim semi mungkin merupakan salah satu kerangka kerja Java yang paling populer, juga binatang yang kuat untuk dijinakkan.  Meskipun konsep dasarnya cukup mudah dimengerti, perlu waktu dan upaya untuk menjadi pengembang Spring yang kuat. <br><br>  Pada artikel ini, kita akan melihat beberapa kesalahan paling umum di Spring, terutama yang berhubungan dengan aplikasi web dan Spring Boot.  Seperti yang dinyatakan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web Spring Boot</a> , itu memaksakan ide tentang bagaimana aplikasi industri harus dibangun, jadi dalam artikel ini kami akan mencoba untuk menunjukkan ide ini dan memberikan ikhtisar dari beberapa tips yang cocok dengan proses pengembangan aplikasi web Spring Boot standar. <br>  Jika Anda tidak terlalu mengenal Spring Boot, tetapi masih ingin mencoba beberapa hal yang disebutkan, saya membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori GitHub yang menyertai artikel ini</a> .  Jika Anda merasa bahwa Anda kehilangan bagian mana pun dalam artikel ini, saya sarankan kloning repositori ke komputer lokal Anda dan bermain dengan kodenya. <br><a name="habracut"></a><br><h2>  Kesalahan Umum # 1: Turun Terlalu Rendah </h2><br>  Kami menemukan kesalahan umum ini karena sindrom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"tidak ditemukan di sini"</a> cukup umum di dunia pengembangan perangkat lunak. Gejalanya meliputi penulisan ulang fragmen kode yang sering digunakan secara teratur, dan banyak pengembang tampaknya menderita karenanya. <br><br>  Meskipun memahami bagian dalam perpustakaan tertentu dan implementasinya untuk sebagian besar adalah baik dan perlu (dan bisa menjadi proses pembelajaran yang sangat baik), terus-menerus menyelesaikan detail implementasi tingkat rendah yang sama berbahaya bagi pengembangan Anda sebagai insinyur perangkat lunak.  Ada alasan mengapa abstraksi dan kerangka kerja seperti Spring ada yang benar-benar memisahkan Anda dari kerajinan berulang dan memungkinkan Anda untuk fokus pada detail tingkat yang lebih tinggi - objek domain dan logika bisnis Anda. <br><br>  Oleh karena itu, gunakan abstraksi - lain kali Anda menemukan masalah tertentu, pertama-tama lakukan pencarian cepat dan tentukan apakah perpustakaan yang memecahkan masalah ini terintegrasi ke dalam Spring.  Saat ini, Anda kemungkinan besar akan menemukan solusi yang sesuai yang ada.  Sebagai contoh perpustakaan yang bermanfaat, dalam contoh-contoh sisa artikel ini, saya akan menggunakan anotasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek Lombok</a> .  Lombok digunakan sebagai generator kode templat dan pengembang malas di dalam Anda, semoga tidak memiliki masalah dengan gagasan perpustakaan ini.  Sebagai contoh, lihat seperti apa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“kacang Jawa standar”</a> dengan Lombok: <br><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Getter</span></span> <span class="hljs-meta"><span class="hljs-meta">@Setter</span></span> <span class="hljs-meta"><span class="hljs-meta">@NoArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bean</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> firstBeanProperty; String secondBeanProperty; }</code> </pre> <br>  Seperti yang dapat Anda bayangkan, kode di atas mengkompilasi menjadi: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bean</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> firstBeanProperty; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String secondBeanProperty; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFirstBeanProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.firstBeanProperty; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSecondBeanProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.secondBeanProperty; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setFirstBeanProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> firstBeanProperty)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.firstBeanProperty = firstBeanProperty; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setSecondBeanProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String secondBeanProperty)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.secondBeanProperty = secondBeanProperty; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bean</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } }</code> </pre> <br>  Namun, perhatikan bahwa Anda kemungkinan besar harus menginstal plugin jika Anda bermaksud menggunakan Lombok dengan IDE Anda.  Versi plugin untuk IntelliJ IDEA dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h2>  Kesalahan Umum # 2: Membocorkan Konten Internal </h2><br>  Mengungkap struktur internal Anda selalu merupakan ide yang buruk, karena itu menciptakan fleksibilitas dalam desain layanan dan, oleh karena itu, berkontribusi terhadap praktik pengkodean yang buruk.  "Kebocoran" konten internal terwujud dalam kenyataan bahwa struktur database dapat diakses dari titik akhir API tertentu.  Sebagai contoh, anggap POJO berikut ("Plain Java Object") mewakili tabel dalam database Anda: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@NoArgsConstructor</span></span> <span class="hljs-meta"><span class="hljs-meta">@Getter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopTalentEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer id; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TopTalentEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } }</code> </pre> <br>  Misalkan ada titik akhir yang perlu mengakses data TopTalentEntity.  Tidak peduli seberapa menggoda untuk mengembalikan instance TopTalentEntity, solusi yang lebih fleksibel adalah membuat kelas baru untuk menampilkan data TopTalentEntity pada titik akhir API: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@AllArgsConstructor</span></span> <span class="hljs-meta"><span class="hljs-meta">@NoArgsConstructor</span></span> <span class="hljs-meta"><span class="hljs-meta">@Getter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopTalentData</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; }</code> </pre> <br>  Dengan demikian, membuat perubahan pada backend database tidak akan memerlukan perubahan tambahan pada lapisan layanan.  Pikirkan tentang apa yang terjadi jika Anda menambahkan bidang kata sandi ke TopTalentEntity untuk menyimpan hash kata sandi pengguna dalam basis data - tanpa konektor seperti TopTalentData, jika Anda lupa mengubah layanan, frontend tidak sengaja akan menampilkan beberapa informasi rahasia yang sangat tidak diinginkan! <br><br><h2>  Kesalahan Umum # 3: Kurangnya Pemisahan Tugas </h2><br>  Ketika aplikasi Anda tumbuh, mengatur kode Anda menjadi masalah yang semakin penting.  Ironisnya, sebagian besar prinsip pengembangan perangkat lunak mulai dilanggar di mana-mana - terutama dalam kasus-kasus di mana sedikit perhatian diberikan untuk merancang arsitektur aplikasi.  Salah satu kesalahan paling umum yang dihadapi pengembang adalah mencampur tanggung jawab kode, dan itu sangat mudah dilakukan! <br><br>  Apa yang biasanya melanggar prinsip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemisahan tugas</a> hanyalah "menambahkan" fungsi baru ke kelas yang ada.  Ini, tentu saja, adalah solusi jangka pendek yang sangat baik (untuk permulaan, ini membutuhkan lebih sedikit pengetikan), tetapi pasti akan menjadi masalah di masa depan, apakah selama pengujian, pemeliharaan, atau di suatu tempat di antaranya.  Pertimbangkan pengontrol berikut, yang mengembalikan TopTalentData dari repositori-nya: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopTalentController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TopTalentRepository topTalentRepository; <span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/toptal/get"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;TopTalentData&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTopTalent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> topTalentRepository.findAll() .stream() .map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::entityToData) .collect(Collectors.toList()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TopTalentData </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">entityToData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TopTalentEntity topTalentEntity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TopTalentData(topTalentEntity.getName()); } }</code> </pre> <br>  Pada awalnya, tidak terlihat ada sesuatu yang salah dengan potongan kode ini.  Ini memberikan daftar TopTalentData yang diambil dari instance TopTalentEntity.  Namun, jika Anda melihat lebih dekat, kita akan melihat bahwa sebenarnya TopTalentController melakukan beberapa hal di sini.  Yaitu: memetakan permintaan untuk titik akhir tertentu, mengambil data dari repositori dan mengubah entitas yang diperoleh dari TopTalentRepository ke dalam format lain.  Solusi "bersih" adalah dengan membagi tanggung jawab ini ke dalam kelas mereka sendiri.  Mungkin terlihat seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/toptal"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@AllArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopTalentController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TopTalentService topTalentService; <span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/get"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;TopTalentData&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTopTalent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> topTalentService.getTopTalent(); } } <span class="hljs-meta"><span class="hljs-meta">@AllArgsConstructor</span></span> <span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopTalentService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TopTalentRepository topTalentRepository; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TopTalentEntityConverter topTalentEntityConverter; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;TopTalentData&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTopTalent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> topTalentRepository.findAll() .stream() .map(topTalentEntityConverter::toResponse) .collect(Collectors.toList()); } } <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopTalentEntityConverter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TopTalentData </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TopTalentEntity topTalentEntity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TopTalentData(topTalentEntity.getName()); } }</code> </pre> <br>  Manfaat tambahan dari hierarki ini adalah memungkinkan kita untuk menentukan di mana fungsionalitas berada dengan hanya memeriksa nama kelas.  Selain itu, selama pengujian, kami dapat dengan mudah mengganti kelas dengan implementasi tiruan, jika perlu. <br><br><h2>  Kesalahan Umum # 4: Inkonsistensi dan Penanganan Kesalahan yang Buruk </h2><br>  Topik konsistensi belum tentu eksklusif untuk Spring (atau Jawa, dalam hal ini), tetapi masih merupakan aspek penting untuk dipertimbangkan ketika bekerja pada proyek Spring.  Sementara gaya penulisan kode dapat menjadi subjek diskusi (dan biasanya itu adalah masalah kesepakatan pada tim atau seluruh perusahaan), keberadaan standar bersama sangat membantu dalam kinerja.  Ini terutama berlaku untuk tim yang terdiri dari beberapa orang.  Konsistensi memungkinkan kode untuk ditransmisikan tanpa biaya sumber daya untuk pemeliharaan atau penyediaan penjelasan terperinci mengenai tanggung jawab berbagai kelas. <br><br>  Pertimbangkan proyek Pegas dengan berbagai file konfigurasi, layanan, dan pengontrol.  Menjadi semantik konsisten dalam penamaan mereka, struktur yang mudah dicari dibuat di mana setiap pengembang baru dapat mengontrol cara bekerja dengan kode: misalnya, akhiran Config ditambahkan ke kelas konfigurasi, akhiran Layanan untuk layanan dan akhiran pengontrol untuk pengontrol. <br><br>  Terkait erat dengan topik konsistensi, penanganan kesalahan sisi server patut mendapat perhatian khusus.  Jika Anda pernah harus menangani jawaban pengecualian dari API yang ditulis dengan buruk, Anda mungkin tahu mengapa bisa menyakitkan untuk menguraikan pengecualian, dan bahkan lebih sulit untuk menentukan alasan mengapa pengecualian ini awalnya terjadi. <br><br>  Sebagai pengembang API, idealnya Anda ingin mencakup semua titik akhir pengguna dan menerjemahkannya ke dalam format kesalahan umum.  Ini biasanya berarti bahwa Anda memiliki kode kesalahan umum dan deskripsi, dan bukan hanya alasan dalam bentuk: a) mengembalikan pesan "500 Internal Server Error" atau b) hanya menyetel ulang jejak tumpukan ke pengguna (yang harus dihindari dengan cara apa pun, karena itu menunjukkan bagian dalam Anda selain kompleksitas pemrosesan di sisi klien). <br>  Contoh format respons kesalahan umum mungkin: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ErrorResponse</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer errorCode; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String errorMessage; }</code> </pre> <br>  Sesuatu yang serupa biasanya ditemukan di sebagian besar API populer dan biasanya berfungsi dengan baik, karena dapat dengan mudah dan sistematis didokumentasikan.  Anda dapat menerjemahkan pengecualian ke dalam format ini dengan memberikan metode dengan anotasi @ExceptionHandler (contoh anotasi diberikan dalam Kesalahan Umum # 6). <br><br><h2>  Kesalahan Umum # 5: Multithreading yang salah </h2><br>  Terlepas dari apakah itu ditemukan di aplikasi desktop atau web, di Spring atau tidak di Spring, multithreading dapat menjadi tugas yang menakutkan.  Masalah yang disebabkan oleh menjalankan program paralel sulit dipahami dan seringkali sangat sulit untuk di-debug - pada kenyataannya, karena sifat masalahnya, setelah Anda memahami bahwa Anda berurusan dengan masalah eksekusi paralel, Anda mungkin harus sepenuhnya meninggalkan debugger dan mulai periksa kode Anda secara manual sampai Anda menemukan penyebab kesalahan.  Sayangnya, untuk mengatasi masalah seperti itu tidak ada solusi template.  Bergantung pada kasus tertentu, Anda harus menilai situasi dan kemudian menyerang masalah dari sudut yang Anda anggap terbaik. <br><br>  Idealnya, tentu saja, Anda ingin sepenuhnya menghindari bug multithreading.  Sekali lagi, tidak ada pendekatan tunggal untuk ini, tetapi berikut adalah beberapa pertimbangan praktis untuk debugging dan mencegah kesalahan multithreading: <br><br><h3>  Hindari Status Global </h3><br>  Pertama, selalu ingat masalah "negara global".  Jika Anda membuat aplikasi multi-utas, segala hal yang dapat diubah secara global harus dipantau dengan cermat dan, jika mungkin, dihapus sepenuhnya.  Jika ada alasan variabel global harus tetap bisa berubah, gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sinkronisasi</a> dengan hati-hati dan pantau kinerja aplikasi Anda untuk mengonfirmasi bahwa itu tidak melambat karena masa tunggu yang baru. <br><br><h3>  Hindari Mutabilitas </h3><br>  Ini mengikuti langsung dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemrograman fungsional</a> dan, menurut OOP, menyatakan bahwa volatilitas kelas dan perubahan status harus dihindari.  Singkatnya, hal tersebut di atas berarti keberadaan setter dan bidang akhir pribadi di semua kelas model.  Nilai-nilai mereka hanya berubah selama konstruksi.  Dengan demikian, Anda dapat yakin bahwa tidak akan ada masalah dalam perlombaan untuk sumber daya dan bahwa mengakses properti dari objek akan selalu memberikan nilai yang benar. <br><br><h3>  Catat data penting </h3><br>  Evaluasi di mana aplikasi Anda dapat menyebabkan masalah, dan pra-log semua data penting.  Jika terjadi kesalahan, Anda akan berterima kasih atas informasi tentang permintaan apa yang diterima dan Anda dapat lebih memahami mengapa aplikasi Anda berperilaku buruk.  Sekali lagi, perlu dicatat bahwa logging meningkatkan file I / O, jadi Anda tidak boleh menyalahgunakannya, karena ini dapat secara serius mempengaruhi kinerja aplikasi Anda. <br><br><h3>  Gunakan kembali implementasi yang ada </h3><br>  Kapan pun Anda perlu membuat utas sendiri (misalnya, untuk melakukan permintaan asinkron ke berbagai layanan), gunakan kembali implementasi aman yang ada, daripada buat solusi Anda sendiri.  Sebagian besar, ini berarti menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ExecutorServices</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CompletableFutures</a> dengan gaya fungsional Java 8 yang rapi untuk membuat utas.  Spring juga memungkinkan pemrosesan permintaan tidak sinkron melalui kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DeferredResult</a> . <br><br><h2>  Kesalahan umum # 6: tidak menggunakan validasi berbasis anotasi </h2><br>  Mari kita bayangkan bahwa layanan TopTalent kami, yang disebutkan di atas, membutuhkan titik akhir untuk menambahkan Super Talents baru.  Selain itu, anggap bahwa untuk alasan yang sangat bagus, setiap nama baru harus memiliki panjang 10 karakter.  Salah satu cara untuk melakukan ini adalah sebagai berikut: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/put"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addTopTalent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@RequestBody TopTalentData topTalentData)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> nameNonExistentOrHasInvalidLength = Optional.ofNullable(topTalentData) .map(TopTalentData::getName) .map(name -&gt; name.length() == <span class="hljs-number"><span class="hljs-number">10</span></span>) .orElse(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nameNonExistentOrInvalidLength) { <span class="hljs-comment"><span class="hljs-comment">// throw some exception } topTalentService.addTopTalent(topTalentData); }</span></span></code> </pre> <br>  Namun, hal di atas (selain dirancang dengan buruk) sebenarnya bukan solusi "bersih".  Kami memeriksa lebih dari satu jenis validitas (yaitu, bahwa TopTalentData bukan nol, dan TopTalentData.name tidak nol, dan TopTalentData.name panjangnya 10 karakter), dan juga memberikan pengecualian jika data tidak valid. <br><br>  Ini dapat dilakukan dengan lebih bersih menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">validator Hibernate</a> dengan Spring.  Pertama, kami menulis ulang metode addTopTalent untuk mendukung validasi: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/put"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addTopTalent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Valid @NotNull @RequestBody TopTalentData topTalentData)</span></span></span><span class="hljs-function"> </span></span>{ topTalentService.addTopTalent(topTalentData); } <span class="hljs-meta"><span class="hljs-meta">@ExceptionHandler</span></span> <span class="hljs-meta"><span class="hljs-meta">@ResponseStatus</span></span>(HttpStatus.BAD_REQUEST) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ErrorResponse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleInvalidTopTalentDataException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodArgumentNotValidException methodArgumentNotValidException)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// handle validation exception }</span></span></code> </pre> <br>  Selain itu, kita harus menunjukkan properti mana yang ingin kita periksa di kelas TopTalentData: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopTalentData</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Length</span></span>(min = <span class="hljs-number"><span class="hljs-number">10</span></span>, max = <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; }</code> </pre> <br>  Spring sekarang akan memotong permintaan dan memverifikasinya sebelum memanggil metode - tidak perlu menggunakan tes manual tambahan. <br><br>  Cara lain kita dapat mencapai hal yang sama adalah dengan membuat anotasi kita sendiri.  Meskipun anotasi khusus biasanya digunakan hanya ketika kebutuhan Anda melebihi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konstanta bawaan Hibernate</a> , untuk contoh ini, mari kita bayangkan bahwa anotasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Panjang</a> tidak ada.  Anda harus membuat validator yang memeriksa panjang string dengan membuat dua kelas tambahan, satu untuk memeriksa dan satu untuk properti anotasi: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Target</span></span>({ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER}) <span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-meta"><span class="hljs-meta">@Documented</span></span> <span class="hljs-meta"><span class="hljs-meta">@Constraint</span></span>(validatedBy = { MyAnnotationValidator.class }) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> MyAnnotation { <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> "String length does not match expected"</span></span>; Class&lt;?&gt;[] groups() <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> {}; Class&lt;? extends Payload&gt;[] payload() <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> {}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyAnnotationValidator</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConstraintValidator</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyAnnotation</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> expectedLength; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MyAnnotation myAnnotation)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.expectedLength = myAnnotation.value(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s, ConstraintValidatorContext constraintValidatorContext)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || s.length() == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.expectedLength; } }</code> </pre> <br>  Perhatikan bahwa dalam kasus ini, praktik terbaik untuk pemisahan tugas mengharuskan Anda menandai properti sebagai valid jika itu nol (s == null dalam metode isValid), dan kemudian menggunakan anotasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">NotNull</a> jika ini merupakan persyaratan tambahan untuk properti: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopTalentData</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@MyAnnotation</span></span>(value = <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; }</code> </pre> <br><h2>  Kesalahan Umum # 7: Menggunakan Konfigurasi XML (Diam) </h2><br>  Meskipun XML diperlukan untuk versi Spring sebelumnya, saat ini sebagian besar konfigurasi dapat dilakukan secara eksklusif dengan kode Java / anotasi.  Konfigurasi XML hanya mewakili boilerplate tambahan dan tidak perlu. <br>  Artikel ini (dan repositori GitHub yang menyertainya) menggunakan anotasi untuk mengonfigurasi Spring dan Spring tahu kacang mana yang harus disambungkan karena paket root dianotasi menggunakan anotasi senyawa @SpringBootApplication, misalnya: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ SpringApplication.run(Application.class, args); } }</code> </pre> <br>  Anotasi komposit ini (Anda dapat mempelajari lebih lanjut tentang hal itu dalam dokumentasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spring</a> ) hanya memberi Spring petunjuk tentang paket mana yang harus dipindai untuk mengekstrak kacang.  Dalam kasus khusus kami, ini berarti bahwa kelas-kelas berikut akan digunakan untuk menghubungkan kacang, dimulai dengan paket tingkat atas (co.kukurin): <br><br><ul><li> <code>@Component (TopTalentConverter, MyAnnotationValidator) @RestController (TopTalentController) @Repository (TopTalentRepository) @Service (TopTalentService)</code> </li> <li> <code>@Component (TopTalentConverter, MyAnnotationValidator) @RestController (TopTalentController) @Repository (TopTalentRepository) @Service (TopTalentService)</code> </li> <li> <code>@Component (TopTalentConverter, MyAnnotationValidator) @RestController (TopTalentController) @Repository (TopTalentRepository) @Service (TopTalentService)</code> </li> <li> <code>@Component (TopTalentConverter, MyAnnotationValidator) @RestController (TopTalentController) @Repository (TopTalentRepository) @Service (TopTalentService)</code> </li> </ul><br>  Jika kita memiliki kelas tambahan yang dijelaskan dengan @Configuration, mereka juga akan diperiksa untuk konfigurasi Java. <br><br><h2>  Kesalahan umum nomor 8: lupakan profil </h2><br>  Masalah yang sering dihadapi ketika mengembangkan server adalah perbedaan antara berbagai jenis konfigurasi, biasanya konfigurasi industri dan pengembangan.  Alih-alih mengubah berbagai parameter konfigurasi secara manual setiap kali Anda beralih dari pengujian ke penerapan aplikasi, cara yang lebih efisien adalah dengan menggunakan profil. <br><br>  Pertimbangkan kasus ini saat Anda menggunakan basis data dalam memori untuk pengembangan lokal dan basis data MySQL di PROM.  Intinya, ini berarti Anda akan menggunakan URL yang berbeda dan (semoga) kredensial yang berbeda untuk mengaksesnya masing-masing.  Mari kita lihat bagaimana hal ini dapat dilakukan dengan dua file konfigurasi yang berbeda: <br><br><h4>  APLIKASI FILE.YAML </h4><br><pre> <code class="plaintext hljs"># set default profile to 'dev' spring.profiles.active: dev # production database details spring.datasource.url: 'jdbc:mysql://localhost:3306/toptal' spring.datasource.username: root spring.datasource.password:</code> </pre> <br><h4>  APLIKASI FILE-DEV.YAML </h4><br><pre> <code class="plaintext hljs">spring.datasource.url: 'jdbc:h2:mem:' spring.datasource.platform: h2</code> </pre> <br>  Tampaknya, Anda tidak ingin secara tidak sengaja melakukan tindakan apa pun pada basis data industri Anda saat Anda mengacaukan kode, jadi masuk akal untuk mengatur profil default di dev.  Kemudian di server, Anda dapat secara manual mengganti profil konfigurasi dengan menentukan parameter -Dspring.profiles.active = prod untuk JVM.  Selain itu, Anda juga dapat mengatur variabel lingkungan OS ke profil default yang diinginkan. <br><br><h2>  Kesalahan Umum # 9: Ketidakmampuan untuk Menerima Injeksi Ketergantungan </h2><br>  Penggunaan injeksi dependensi yang tepat di Spring berarti memungkinkan Anda untuk mengikat semua objek Anda bersama dengan memindai semua kelas konfigurasi yang diperlukan;  ini berguna untuk memisahkan hubungan, dan juga membuat pengujian lebih mudah.  Alih-alih kelas yang menghubungkan keras, dengan melakukan sesuatu seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopTalentController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TopTalentService topTalentService; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TopTalentController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.topTalentService = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TopTalentService(); } }</code> </pre> <br><br>  Kami membiarkan Spring melakukan pengikatan untuk kami: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopTalentController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TopTalentService topTalentService; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TopTalentController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TopTalentService topTalentService)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.topTalentService = topTalentService; } }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Misko Hevery dari Google talk menjelaskan secara</a> rinci "alasan" untuk injeksi ketergantungan, jadi mari kita lihat bagaimana ini digunakan dalam praktik.  Dalam pembagian tanggung jawab (Kesalahan Umum # 3), kami menciptakan kelas layanan dan pengontrol.  Misalkan kita ingin menguji controller dengan asumsi bahwa TopTalentService berperilaku dengan benar.  Kami dapat menyisipkan objek tiruan alih-alih implementasi layanan yang sebenarnya, memberikan kelas konfigurasi terpisah: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SampleUnitTestConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TopTalentService </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topTalentService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TopTalentService topTalentService = Mockito.mock(TopTalentService.class); Mockito.when(topTalentService.getTopTalent()).thenReturn( Stream.of(<span class="hljs-string"><span class="hljs-string">"Mary"</span></span>, <span class="hljs-string"><span class="hljs-string">"Joel"</span></span>) .map(TopTalentData::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>).collect(Collectors.toList())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> topTalentService; } }</code> </pre> <br>  Kemudian kita bisa menyematkan objek tiruan dengan memberi tahu Spring untuk menggunakan SampleUnitTestConfig sebagai penyedia konfigurasi: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ContextConfiguration</span></span>(classes = { SampleUnitTestConfig.class })</code> </pre> <br>  Maka ini akan memungkinkan kita untuk menggunakan konfigurasi konteks untuk menanamkan kacang kustom dalam pengujian unit. <br><br><h2>  Kesalahan umum # 10: kurangnya pengujian atau pengujian yang salah </h2><br>  Terlepas dari kenyataan bahwa ide pengujian unit telah bersama kami untuk waktu yang lama, banyak pengembang tampaknya "lupa" untuk melakukan ini (terutama jika ini tidak perlu), atau cukup tinggalkan untuk nanti.  Jelas, ini tidak diinginkan, karena tes tidak hanya memverifikasi kebenaran kode Anda, tetapi juga berfungsi sebagai dokumentasi tentang bagaimana aplikasi harus berperilaku dalam situasi yang berbeda. <br><br>  Saat menguji layanan web, Anda jarang melakukan tes unit "bersih" yang luar biasa, karena interaksi melalui HTTP biasanya memerlukan panggilan DispatcherServlet Spring dan melihat apa yang terjadi ketika HttpServletRequest yang sebenarnya diterima (yang menjadikannya uji integrasi, dengan menggunakan validasi, serialisasi, dll.).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">REST Assured</a> - Java DSL untuk dengan mudah menguji layanan REST di atas MockMVC telah terbukti menjadi solusi yang sangat elegan.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pertimbangkan fragmen kode berikut dengan injeksi dependensi: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(SpringJUnit4ClassRunner.class) <span class="hljs-meta"><span class="hljs-meta">@ContextConfiguration</span></span>(classes = { Application.class, SampleUnitTestConfig.class }) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RestAssuredTestDemonstration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TopTalentController topTalentController; <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldGetMaryAndJoel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// given MockMvcRequestSpecification givenRestAssuredSpecification = RestAssuredMockMvc.given() .standaloneSetup(topTalentController); // when MockMvcResponse response = givenRestAssuredSpecification.when().get("/toptal/get"); // then response.then().statusCode(200); response.then().body("name", hasItems("Mary", "Joel")); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SampleUnitTestConfig memungkinkan implementasi tiruan TopTalentService di TopTalentController, sementara semua kelas lainnya terhubung menggunakan konfigurasi standar yang diperoleh dengan memindai paket yang berakar pada paket kelas aplikasi. </font><font style="vertical-align: inherit;">RestAssuredMockMvc hanya digunakan untuk menciptakan lingkungan yang ringan dan mengirim permintaan GET ke / toptal / get endpoint.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menjadi Master Musim Semi </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Musim semi adalah kerangka kerja yang kuat yang mudah untuk memulai, tetapi membutuhkan dedikasi dan waktu untuk mencapai penguasaan penuh. Jika Anda menghabiskan waktu untuk mengenal kerangka kerja, itu pasti akan meningkatkan produktivitas Anda dalam jangka panjang dan pada akhirnya membantu Anda menulis kode yang lebih bersih dan menjadi pengembang yang lebih baik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda mencari sumber daya tambahan, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring In Action</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah buku praktik bagus yang mencakup banyak topik inti Spring. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TAGS</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Java SpringFramework</font></font><br><br><h2>  Komentar </h2><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Timothy Schimandle</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pada # 2, saya berpikir bahwa mengembalikan objek domain lebih disukai dalam banyak kasus. Contoh objek kustom Anda adalah salah satu dari beberapa kelas yang memiliki bidang yang ingin kami sembunyikan. Tetapi sebagian besar objek yang saya kerjakan tidak memiliki batasan seperti itu, dan menambahkan kelas dto hanya kode yang tidak perlu. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua dalam semua artikel yang bagus. Kerja bagus </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPIRITED ke Timothy Schimandle,</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> saya sepenuhnya setuju. Sepertinya lapisan kode tambahan yang tidak perlu telah ditambahkan, saya pikir @JsonIgnore akan membantu untuk mengabaikan bidang (walaupun dengan kelemahan dalam strategi deteksi repositori default), tetapi secara keseluruhan ini adalah posting blog yang bagus. Bangga tersandung ... </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arokiadoss Asirvatham</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bung, kesalahan pemula yang umum lainnya adalah: 1) Ketergantungan Siklik, dan 2) ketidakpatuhan terhadap doktrin deklarasi Kelas Singleton dasar, seperti menggunakan variabel instan dalam kacang dengan cakupan singleton. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hlodowig</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mengenai nomor 8, saya percaya bahwa pendekatan ke profil sangat tidak memuaskan. </font><font style="vertical-align: inherit;">Mari kita lihat:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keamanan: beberapa orang mengatakan: jika repositori Anda bersifat publik, apakah akan ada kunci / kata sandi rahasia? </font><font style="vertical-align: inherit;">Kemungkinan besar, akan begitu, mengikuti pendekatan ini. </font><font style="vertical-align: inherit;">Kecuali, tentu saja, Anda menambahkan file config ke .gitignore, tetapi ini bukan opsi yang serius.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Duplikasi: setiap kali saya memiliki pengaturan yang berbeda, saya harus membuat file properti baru, yang sangat mengganggu. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portabilitas: Saya tahu ini hanya satu argumen JVM, tetapi nol lebih baik dari satu. </font><font style="vertical-align: inherit;">Kesalahan cenderung jauh lebih kecil.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya mencoba menemukan cara untuk menggunakan variabel lingkungan dalam file konfigurasi saya daripada "hard coding" nilai-nilai, tetapi sejauh ini saya belum berhasil, saya pikir saya perlu melakukan penelitian lebih lanjut. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel bagus Tony, terus bekerja dengan baik! </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terjemahan selesai: tele.gg/middle_java</font></font></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id465897/">https://habr.com/ru/post/id465897/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id465885/index.html">Bagaimana cara menjadi Master Scrum Terkemuka dan menggerakkan Tim?</a></li>
<li><a href="../id465889/index.html">Bagaimana kami melakukan efisiensi energi</a></li>
<li><a href="../id465891/index.html">Cara membuat produk atau nama perusahaan menggunakan Vepp sebagai contoh</a></li>
<li><a href="../id465893/index.html">Summ3r h4ck 2019. Departemen Analisis Keamanan</a></li>
<li><a href="../id465895/index.html">C ++ Russia 2019 Ikhtisar program Piter: asinkron, modul, perpustakaan ... dan taksi</a></li>
<li><a href="../id465899/index.html">Buku "Linux Command Prompt. Panduan lengkap. Int 2. ed. "</a></li>
<li><a href="../id465901/index.html">Apa yang seharusnya dimiliki aplikasi kebugaran?</a></li>
<li><a href="../id465903/index.html">Selamat datang di Tur Dunia Fujitsu 2019</a></li>
<li><a href="../id465905/index.html">Konferensi ZeroNights 2019</a></li>
<li><a href="../id465911/index.html">Pertemuan akselerasi 17/09 video dan presentasi UPD</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>