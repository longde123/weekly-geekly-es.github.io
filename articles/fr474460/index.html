<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∞üèΩ üö£ üçâ Description des architectures de processeur dans LLVM utilisant TableGen üê§ üë®üèº‚Äçüíº üõÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="√Ä l'heure actuelle, LLVM est d√©j√† devenu un syst√®me tr√®s populaire, que de nombreuses personnes utilisent activement pour cr√©er divers compilateurs, a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Description des architectures de processeur dans LLVM utilisant TableGen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474460/"> √Ä l'heure actuelle, LLVM est d√©j√† devenu un syst√®me tr√®s populaire, que de nombreuses personnes utilisent activement pour cr√©er divers compilateurs, analyseurs, etc.  Un grand nombre de documents utiles sur ce sujet ont d√©j√† √©t√© r√©dig√©s, y compris en russe, ce qui est une bonne nouvelle.  Cependant, dans la plupart des cas, le principal biais dans les articles concerne le LLVM frontal et interm√©diaire.  Bien s√ªr, lors de la description du sch√©ma complet du fonctionnement de LLVM, la g√©n√©ration de code machine n'est pas contourn√©e, mais fondamentalement, ce sujet est abord√© avec d√©sinvolture, en particulier dans les publications en russe.  Dans le m√™me temps, LLVM dispose d'un m√©canisme plut√¥t flexible et int√©ressant pour d√©crire les architectures de processeur.  Par cons√©quent, ce mat√©riel sera consacr√© √† l'utilitaire quelque peu n√©glig√© TableGen, qui fait partie de LLVM. <br><br>  La raison pour laquelle le compilateur a besoin d'informations sur l'architecture de chacune des plates-formes cibles est assez √©vidente.  Naturellement, chaque mod√®le de processeur poss√®de son propre ensemble de registres, ses propres instructions machine, etc.  Et le compilateur doit avoir toutes les informations n√©cessaires √† leur sujet afin de pouvoir g√©n√©rer un code machine valide et efficace.  Le compilateur r√©sout diverses t√¢ches sp√©cifiques √† la plate-forme: distribue les registres, etc.  De plus, les backends LLVM effectuent √©galement des optimisations d√©j√† sur la machine IR, qui est plus proche des instructions r√©elles, ou sur les instructions d'assembleur elles-m√™mes.  Dans de telles optimisations, les instructions doivent √™tre remplac√©es et transform√©es; en cons√©quence, toutes les informations les concernant doivent √™tre disponibles. <br><a name="habracut"></a><br>  Pour r√©soudre le probl√®me de description de l'architecture du processeur, LLVM a adopt√© un format unique pour d√©terminer les propri√©t√©s du processeur n√©cessaires au compilateur.  Pour chaque architecture prise en charge, un <code>.td</code> contient une description dans un langage formel sp√©cial.  Il est converti en fichiers <code>.inc</code> lors de la construction du compilateur √† l'aide de l'utilitaire TableGen inclus avec LLVM.  En fait, les fichiers r√©sultants sont de source C, mais ont probablement une extension distincte, juste pour que ces fichiers g√©n√©r√©s automatiquement puissent √™tre facilement distingu√©s et filtr√©s.  La documentation officielle de TableGen est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> et donne toutes les informations n√©cessaires, il y a aussi une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">description formelle de la langue</a> et une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">introduction g√©n√©rale</a> . <br><br>  Bien s√ªr, il s'agit d'un sujet tr√®s complet, o√π il existe de nombreux d√©tails sur lesquels vous pouvez √©crire des articles individuels.  Dans cet article, nous consid√©rons simplement les points de base de la description des processeurs m√™me sans un aper√ßu de toutes les fonctionnalit√©s. <br><br><h2>  Description de l'architecture dans le fichier .td </h2><br>  Ainsi, le langage de description formel utilis√© dans TableGen a des caract√©ristiques similaires aux langages de programmation ordinaires et vous permet de d√©crire les caract√©ristiques de l'architecture dans un style d√©claratif.  Et si je comprends bien, ce langage est aussi commun√©ment appel√© TableGen.  C'est-√†-dire  Dans cet article, TableGen utilise √† la fois le nom du langage formel lui-m√™me et l'utilitaire qui en g√©n√®re les artefacts. <br><br>  Les processeurs modernes sont des syst√®mes tr√®s complexes, il n'est donc pas surprenant que leur description soit assez volumineuse.  En cons√©quence, pour cr√©er la structure et simplifier la maintenance des fichiers <code>.td</code> , vous pouvez vous inclure en utilisant la directive <code>#include</code> habituelle pour les programmeurs C.  Avec l'aide de cette directive, le fichier <code>Target.td</code> est toujours inclus en premier, contenant des interfaces ind√©pendantes de la plate-forme qui doivent √™tre impl√©ment√©es pour fournir toutes les informations TableGen n√©cessaires.  Ce fichier comprend d√©j√† un fichier <code>.td</code> avec des descriptions intrins√®ques LLVM, mais en lui-m√™me il contient principalement des classes de base, telles que <code>Register</code> , <code>Instruction</code> , <code>Processor</code> , etc., dont vous devez h√©riter pour cr√©er votre propre architecture pour un compilateur bas√© sur LLVM.  D'apr√®s la phrase pr√©c√©dente, il est clair que TableGen a la notion de classes bien connue de tous les programmeurs. <br><br>  En g√©n√©ral, TableGen n'a que deux entit√©s de base: les <b>classes</b> et les <b>d√©finitions</b> . <br><br><h3>  Cours </h3><br>  Les classes TableGen sont √©galement des abstractions, comme dans tous les langages de programmation orient√©s objet, mais ce sont des entit√©s plus simples. <br><br>  Les classes peuvent avoir des param√®tres et des champs, et elles peuvent √©galement h√©riter d'autres classes. <br>  Par exemple, l'une des classes de base est pr√©sent√©e ci-dessous. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// A class representing the register size, spill size and spill alignment // in bits of a register. class RegInfo&lt;int RS, int SS, int SA&gt; { int RegSize = RS; // Register size in bits. int SpillSize = SS; // Spill slot size in bits. int SpillAlignment = SA; // Spill slot alignment in bits. }</span></span></code> </pre> <br>  Les crochets angulaires indiquent les param√®tres d'entr√©e affect√©s aux propri√©t√©s de la classe.  Dans cet exemple, vous pouvez √©galement remarquer que le langage TableGen est typ√© statiquement.  Les types qui existent dans TableGen: <code>bit</code> (un analogue du type bool√©en avec les valeurs 0 et 1), <code>int</code> , <code>string</code> , <code>code</code> (un morceau de code, c'est un type, simplement parce qu'il n'y a pas de m√©thodes et de fonctions dans TableGen au sens habituel, les lignes de code sont √©crites en <code>[{ ... }]</code> ), bits &lt;n&gt;, liste &lt;type&gt; (les valeurs sont d√©finies √† l'aide de crochets [...] comme en Python et dans d'autres langages de programmation), <code>class type</code> , <code>dag</code> . <br><br>  La plupart des types doivent √™tre compris, mais s'ils ont des questions, ils sont tous d√©crits en d√©tail dans la sp√©cification de la langue, disponible sur le lien donn√© au d√©but de l'article. <br><br>  L'h√©ritage est √©galement d√©crit par une syntaxe assez famili√®re avec:. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X86MemOperand</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">printMethod</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsmOperandClass</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parserMatchClass</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X86MemAsmOperand</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Operand</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iPTR</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">PrintMethod</span></span> = printMethod; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">MIOperandInfo</span></span> = (ops ptr_rc, i8imm, ptr_rc_nosp, i32imm, <span class="hljs-type"><span class="hljs-type">SEGMENT_REG</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">ParserMatchClass</span></span> = parserMatchClass; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">OperandType</span></span> = <span class="hljs-string"><span class="hljs-string">"OPERAND_MEMORY"</span></span>; }</code> </pre> <br>  Dans ce cas, la classe cr√©√©e, bien s√ªr, peut remplacer les valeurs des champs sp√©cifi√©s dans la classe de base √† l'aide du mot cl√© <code>let</code> .  Et il peut ajouter ses propres champs similaires √† la description fournie dans l'exemple pr√©c√©dent, en indiquant le type de champ. <br><br><h3>  D√©finitions </h3><br>  Les d√©finitions sont d√©j√† des entit√©s concr√®tes, vous pouvez les comparer avec le familier √† tous les objets.  Les d√©finitions sont d√©finies √† l'aide du mot cl√© <code>def</code> et peuvent impl√©menter une classe, red√©finir les champs des classes de base exactement de la m√™me mani√®re que d√©crit ci-dessus, et √©galement avoir leurs propres champs. <br><br><pre> <code class="swift hljs">def i8mem : <span class="hljs-type"><span class="hljs-type">X86MemOperand</span></span>&lt;<span class="hljs-string"><span class="hljs-string">"printbytemem"</span></span>, <span class="hljs-type"><span class="hljs-type">X86Mem8AsmOperand</span></span>&gt;; def <span class="hljs-type"><span class="hljs-type">X86AbsMemAsmOperand</span></span> : <span class="hljs-type"><span class="hljs-type">AsmOperandClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">Name</span></span> = <span class="hljs-string"><span class="hljs-string">"AbsMem"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">SuperClasses</span></span> = [<span class="hljs-type"><span class="hljs-type">X86MemAsmOperand</span></span>]; }</code> </pre><br><h3>  Multiclasses </h3><br>  Naturellement, un grand nombre d'instructions dans les processeurs ont une s√©mantique similaire.  Par exemple, il peut y avoir un ensemble d'instructions √† trois adresses qui prennent les deux formes <code>‚Äúreg = reg op reg‚Äù</code> et <code>‚Äúreg = reg op imm‚Äù</code> .  Dans un cas, les valeurs sont extraites des registres et le r√©sultat est √©galement enregistr√© dans le registre, et dans l'autre cas, le deuxi√®me op√©rande est une valeur constante (imm - op√©rande imm√©diat). <br><br>  Lister toutes les combinaisons manuellement est assez fastidieux; le risque de faire une erreur augmente.  Bien s√ªr, ils peuvent √™tre g√©n√©r√©s automatiquement en √©crivant un script simple, mais ce n'est pas n√©cessaire, car un concept tel que les multiclasses existe dans le langage TableGen. <br><br><pre> <code class="cpp hljs">multiclass ri_inst&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> opc, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> asmstr&gt; { def _rr : inst&lt;opc, !strconcat(asmstr, <span class="hljs-string"><span class="hljs-string">" $dst, $src1, $src2"</span></span>), (ops GPR:$dst, GPR:$src1, GPR:$src2)&gt;; def _ri : inst&lt;opc, !strconcat(asmstr, <span class="hljs-string"><span class="hljs-string">" $dst, $src1, $src2"</span></span>), (ops GPR:$dst, GPR:$src1, Imm:$src2)&gt;; }</code> </pre> <br>  Dans les multiclasses, vous devez d√©crire toutes les formes d'instructions possibles √† l'aide du mot cl√© <code>def</code> .  Mais ce n'est pas une forme compl√®te d'instructions √† g√©n√©rer.  Dans le m√™me temps, vous pouvez red√©finir les champs qu'ils contiennent et faire tout ce qui est possible dans les d√©finitions habituelles.  Pour cr√©er de v√©ritables d√©finitions bas√©es sur une multiclasse, vous devez utiliser le mot cl√© <code>defm</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Instantiations of the ri_inst multiclass. defm ADD : ri_inst&lt;0b111, "add"&gt;; defm SUB : ri_inst&lt;0b101, "sub"&gt;; defm MUL : ri_inst&lt;0b100, "mul"&gt;;</span></span></code> </pre> <br>  Et en cons√©quence, pour chacune de ces d√©finitions donn√©es via <code>defm</code> en fait, plusieurs d√©finitions seront construites qui sont une combinaison de l'instruction principale et de toutes les formes possibles d√©crites dans la multiclasse.  Par cons√©quent, les instructions suivantes seront g√©n√©r√©es dans cet exemple: <code>ADD_rr</code> , <code>ADD_ri</code> , <code>SUB_rr</code> , <code>SUB_ri</code> , <code>MUL_rr</code> , <code>MUL_ri</code> . <br><br>  Les multiclasses peuvent contenir non seulement des d√©finitions avec <code>def</code> , mais √©galement des <code>defm</code> imbriqu√©es, permettant ainsi la g√©n√©ration de formes complexes d'instructions.  Un exemple illustrant la cr√©ation de telles cha√Ænes se trouve dans la documentation officielle. <br><br><h3>  Sous-cibles </h3><br>  Une autre chose fondamentale et utile pour les processeurs qui ont diff√©rentes variations du jeu d'instructions est le support de subtarget dans LLVM.  Un exemple d'utilisation est l'impl√©mentation LLVM SPARC, qui couvre trois versions principales de l'architecture de microprocesseur SPARC √† la fois: version 8 (architecture V8, 32 bits), version 9 (architecture V9, 64 bits) et architecture UltraSPARC.  La diff√©rence entre les architectures est assez grande, un nombre diff√©rent de registres de diff√©rents types, l'ordre des octets pris en charge, etc.  Dans de tels cas, s'il existe plusieurs configurations, il vaut la peine d'impl√©menter la classe <code>XXXSubtarget</code> pour l'architecture.  L'utilisation de cette classe dans la description entra√Ænera de nouvelles options de ligne de commande <code>-mcpu=</code> et <code>-mattr=</code> . <br><br>  En plus de la classe <code>Subtarget</code> elle-m√™me, la classe <code>Subtarget</code> importante. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SubtargetFeature</span></span></span><span class="hljs-class">&lt;string n, string a, string v, string d, list&lt;SubtargetFeature&gt; i = []&gt; {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Name = n; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Attribute = a; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Value = v; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Desc = d; <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;SubtargetFeature&gt; Implies = i; }</code> </pre> <br>  Dans le fichier <code>Sparc.td</code> , vous pouvez trouver des exemples d'impl√©mentation de <code>SubtargetFeature</code> , qui vous permettent de d√©crire la disponibilit√© d'un ensemble d'instructions pour chaque sous-type individuel de l'architecture. <br><br><pre> <code class="cpp hljs">def FeatureV9 : SubtargetFeature&lt;<span class="hljs-string"><span class="hljs-string">"v9"</span></span>, <span class="hljs-string"><span class="hljs-string">"IsV9"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-string"><span class="hljs-string">"Enable SPARC-V9 instructions"</span></span>&gt;; def FeatureV8Deprecated : SubtargetFeature&lt;<span class="hljs-string"><span class="hljs-string">"deprecated-v8"</span></span>, <span class="hljs-string"><span class="hljs-string">"V8DeprecatedInsts"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-string"><span class="hljs-string">"Enable deprecated V8 instructions in V9 mode"</span></span>&gt;; def FeatureVIS : SubtargetFeature&lt;<span class="hljs-string"><span class="hljs-string">"vis"</span></span>, <span class="hljs-string"><span class="hljs-string">"IsVIS"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-string"><span class="hljs-string">"Enable UltraSPARC Visual Instruction Set extensions"</span></span>&gt;;</code> </pre><br>  Dans ce cas, de toute fa√ßon, <code>Sparc.td</code> d√©finit toujours la classe <code>Proc</code> , qui est utilis√©e pour d√©crire des sous-types sp√©cifiques de processeurs SPARC, qui peuvent simplement avoir les propri√©t√©s d√©crites ci-dessus, y compris diff√©rents ensembles d'instructions. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Proc</span></span></span><span class="hljs-class">&lt;string Name, list&lt;SubtargetFeature&gt; Features&gt; :</span></span> Processor&lt;Name, NoItineraries, Features&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"generic"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"v8"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"supersparc"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"sparclite"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"f934"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"hypersparc"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"sparclite86x"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"sparclet"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"tsc701"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"v9"</span></span>, [FeatureV9]&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"ultrasparc"</span></span>, [FeatureV9, FeatureV8Deprecated]&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"ultrasparc3"</span></span>, [FeatureV9, FeatureV8Deprecated]&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"ultrasparc3-vis"</span></span>, [FeatureV9, FeatureV8Deprecated, FeatureVIS]&gt;;</code> </pre> <br><h2>  Relation entre les propri√©t√©s des instructions dans TableGen et le code backend LLVM </h2><br>  Les propri√©t√©s des classes et des d√©finitions vous permettent de g√©n√©rer et de d√©finir correctement les fonctionnalit√©s architecturales, mais il n'y a pas d'acc√®s direct √† celles-ci depuis le code source du backend LLVM.  Cependant, vous souhaitez parfois pouvoir obtenir certaines propri√©t√©s d'instructions sp√©cifiques √† la plate-forme directement dans le code du compilateur. <br><br><h3>  TSFlags </h3><br>  Pour ce faire, la classe de base <code>Instruction</code> poss√®de un champ sp√©cial, TSFlags 64 bits, qui est converti par TableGen en un champ d'objets C ++ de la classe <code>MCInstrDesc</code> , g√©n√©r√© sur la base des donn√©es re√ßues de la description TableGen.  Vous pouvez sp√©cifier n'importe quel nombre de bits dont vous avez besoin pour stocker des informations.  Il peut s'agir d'une valeur bool√©enne, par exemple, pour indiquer que nous utilisons une ALU scalaire. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">TSFlags</span></span>{<span class="hljs-number"><span class="hljs-number">0</span></span>} = <span class="hljs-type"><span class="hljs-type">SALU</span></span>;</code> </pre> <br>  Ou nous pouvons stocker le type d'instruction.  Ensuite, nous avons bien s√ªr besoin de plus d'un bit. <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// Instruction type according to the ISA. IType Type = type; let TSFlags{7-1} = Type.Value;</span></span></code> </pre> <br>  Par cons√©quent, il devient possible d'obtenir ces propri√©t√©s √† partir de l'instruction dans le code principal. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isSALU = MI.getDesc().TSFlags &amp; SIInstrFlags::SALU;</code> </pre> <br>  Si la propri√©t√© est plus complexe, vous pouvez la comparer √† la valeur d√©crite dans TableGen, qui sera ajout√©e √† l'√©num√©ration g√©n√©r√©e automatiquement. <br><br><pre> <code class="cpp hljs">(Desc.TSFlags &amp; X86II::FormMask) == X86II::MRMSrcMem</code> </pre> <br><br><h3>  Pr√©dicats de fonction </h3><br>  De plus, les pr√©dicats de fonction peuvent √™tre utilis√©s pour obtenir les informations n√©cessaires sur les instructions.  Avec leur aide, vous pouvez montrer √† TableGen que vous devez g√©n√©rer une fonction qui sera donc disponible dans le code backend.  La classe de base avec laquelle vous pouvez cr√©er une telle d√©finition de fonction est pr√©sent√©e ci-dessous. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Base class for function predicates. class FunctionPredicateBase&lt;string name, MCStatement body&gt; { string FunctionName = name; MCStatement Body = body; }</span></span></code> </pre> <br>  Vous pouvez facilement trouver des exemples d'utilisation dans le backend pour X86.  Il y a donc sa propre classe interm√©diaire, √† l'aide de laquelle les d√©finitions n√©cessaires des fonctions sont d√©j√† cr√©√©es. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Check that a call to method `Name` in class "XXXInstrInfo" (where XXX is // the name of a target) returns true. // // TIIPredicate definitions are used to model calls to the target-specific // InstrInfo. A TIIPredicate is treated specially by the InstrInfoEmitter // tablegen backend, which will use it to automatically generate a definition in // the target specific `InstrInfo` class. // // There cannot be multiple TIIPredicate definitions with the same name for the // same target class TIIPredicate&lt;string Name, MCStatement body&gt; : FunctionPredicateBase&lt;Name, body&gt;, MCInstPredicate; // This predicate evaluates to true only if the input machine instruction is a // 3-operands LEA. Tablegen automatically generates a new method for it in // X86GenInstrInfo. def IsThreeOperandsLEAFn : TIIPredicate&lt;"isThreeOperandsLEA", IsThreeOperandsLEABody&gt;; //   -    ,  -  ,       // Used to generate the body of a TII member function. def IsThreeOperandsLEABody : MCOpcodeSwitchStatement&lt;[LEACases], MCReturnStatement&lt;FalsePred&gt;&gt;;</span></span></code> </pre> <br>  Par cons√©quent, vous pouvez utiliser la m√©thode <code>isThreeOperandsLEA</code> dans le code C ++. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(TII-&gt;isThreeOperandsLEA(MI) || hasInefficientLEABaseReg(Base, Index)) || !TII-&gt;isSafeToClobberEFLAGS(MBB, MI) || Segment.getReg() != X86::NoRegister) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br>  Ici, TII est l'information d'instruction cible, qui peut √™tre obtenue en utilisant la m√©thode <code>getInstrInfo()</code> du <code>MCSubtargetInfo</code> pour l'architecture souhait√©e. <br><br><h2>  Transformation des instructions lors des optimisations.  Mappage d'instructions </h2><br>  Lors d'un grand nombre d'optimisations effectu√©es dans les derni√®res √©tapes de la compilation, la t√¢che se pose souvent de convertir tout ou partie des instructions d'un formulaire en instructions d'un autre formulaire.  Compte tenu de l'application des multiclasses d√©crites au d√©but, nous pouvons avoir un grand nombre d'instructions avec une s√©mantique et des propri√©t√©s similaires.  Dans le code, ces transformations, bien s√ªr, pourraient √™tre √©crites sous la forme de grandes constructions de <code>switch-case</code> , qui pour chaque instruction √©crasaient la transformation correspondante.  En partie, ces √©normes constructions peuvent √™tre r√©duites √† l'aide de macros, qui formeraient le nom n√©cessaire de l'instruction selon des r√®gles bien connues.  Mais encore, cette approche est tr√®s g√™nante, elle est difficile √† maintenir en raison du fait que tous les noms d'instructions sont explicitement r√©pertori√©s.  L'ajout d'une nouvelle instruction peut tr√®s facilement entra√Æner une erreur, car  vous devez vous rappeler de l'ajouter √† toutes les conversions pertinentes.  Ayant √©t√© tourment√© par cette approche, LLVM a cr√©√© un m√©canisme sp√©cial pour convertir efficacement une forme d'instruction en une autre <code>Instruction Mapping</code> . <br><br>  L'id√©e est tr√®s simple, il faut d√©crire des mod√®les possibles pour transformer des instructions directement dans TableGen.  Par cons√©quent, dans LLVM TableGen, il existe une classe de base pour d√©crire ces mod√®les. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InstrMapping</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// Used to reduce search space only to the instructions using this // relation model. string FilterClass; // List of fields/attributes that should be same for all the instructions in // a row of the relation table. Think of this as a set of properties shared // by all the instructions related by this relationship. list&lt;string&gt; RowFields = []; // List of fields/attributes that are same for all the instructions // in a column of the relation table. list&lt;string&gt; ColFields = []; // Values for the fields/attributes listed in 'ColFields' corresponding to // the key instruction. This is the instruction that will be transformed // using this relation model. list&lt;string&gt; KeyCol = []; // List of values for the fields/attributes listed in 'ColFields', one for // each column in the relation table. These are the instructions a key // instruction will be transformed into. list&lt;list&lt;string&gt; &gt; ValueCols = []; }</span></span></code> </pre> <br>  Regardons un exemple donn√© dans la documentation.  Les exemples qui peuvent √™tre trouv√©s dans le code source sont maintenant encore plus simples, car seules deux colonnes sont obtenues dans le tableau final.  Dans le code principal, vous pouvez trouver la conversion d'anciens formulaires en de nouvelles formes d'instructions, des instructions dsp en mmdsp, etc., d√©crites √† l'aide du mappage d'instructions.  En fait, ce m√©canisme n'est pas si largement utilis√© jusqu'√† pr√©sent, simplement parce que la plupart des backends ont commenc√© √† √™tre cr√©√©s avant son apparition, et pour qu'il fonctionne, vous devez toujours d√©finir les propri√©t√©s correctes pour les instructions, donc passer √† celui-ci n'est pas toujours facile, vous pouvez en avoir besoin refactoring. <br><br>  Ainsi, par exemple.  Supposons que nous ayons des formes d'instructions sans pr√©dicats et des instructions o√π le pr√©dicat est respectivement vrai et faux.  Nous les d√©crivons √† l'aide d'une multiclasse et d'une classe sp√©ciale, que nous allons simplement utiliser comme filtre.  Une description simplifi√©e sans param√®tres et de nombreuses propri√©t√©s peut ressembler √† ceci. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PredRel</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">multiclass</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInstruction</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">BaseOpcode</span></span> = name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> { def : <span class="hljs-type"><span class="hljs-type">PredRel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">PredSense</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span>; } def _pt: <span class="hljs-type"><span class="hljs-type">PredRel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">PredSense</span></span> = <span class="hljs-string"><span class="hljs-string">"true"</span></span>; } def _pf: <span class="hljs-type"><span class="hljs-type">PredRel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">PredSense</span></span> = <span class="hljs-string"><span class="hljs-string">"false"</span></span>; } } } defm <span class="hljs-type"><span class="hljs-type">ADD</span></span>: <span class="hljs-type"><span class="hljs-type">MyInstruction</span></span>&lt;‚Äù<span class="hljs-type"><span class="hljs-type">ADD</span></span>‚Äù&gt;; defm <span class="hljs-type"><span class="hljs-type">SUB</span></span>: <span class="hljs-type"><span class="hljs-type">MyIntruction</span></span>&lt;‚Äù<span class="hljs-type"><span class="hljs-type">SUB</span></span>‚Äù&gt;; defm <span class="hljs-type"><span class="hljs-type">MUL</span></span>: <span class="hljs-type"><span class="hljs-type">MyInstruction</span></span>&lt;‚Äù<span class="hljs-type"><span class="hljs-type">MUL</span></span>‚Äù&gt;; ‚Ä¶</code> </pre> <br>  Dans cet exemple, en passant, il est √©galement montr√© comment remplacer une propri√©t√© pour plusieurs d√©finitions √† la fois en utilisant la construction <code>let ‚Ä¶ in</code> .  Par cons√©quent, nous avons de nombreuses instructions qui stockent leur nom de base et leur propri√©t√© qui d√©crivent de mani√®re unique leur formulaire.  Ensuite, vous pouvez cr√©er un mod√®le de transformation. <br><br><pre> <code class="swift hljs">def getPredOpcode : <span class="hljs-type"><span class="hljs-type">InstrMapping</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,       - PredRel  let FilterClass = "PredRel"; //         ,      let RowFields = ["BaseOpcode"]; //          PredSense. let ColFields = ["PredSense"]; //  ,  ,       ,     PredSense=‚Äù‚Äù let KeyCol = [""]; //   PredSense      let ValueCols = [["true"], ["false"]]; }</span></span></code> </pre> <br>  Par cons√©quent, le tableau suivant sera g√©n√©r√© √† partir de cette description. <br><br><div class="scrollable-table"><table><tbody><tr><th>  PredSense = "" </th><th>  PredSense = "vrai" </th><th>  PredSense = "faux" </th></tr><tr><td>  AJOUTER </td><td>  ADD_pt </td><td>  ADD_pf </td></tr><tr><td>  SUB </td><td>  SUB_pt </td><td>  SUB_pf </td></tr><tr><td>  Mul </td><td>  MUL_pt </td><td>  MUL_pf </td></tr></tbody></table></div><br>  Une fonction sera g√©n√©r√©e dans le fichier <code>.inc</code> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPredOpcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Opcode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> PredSense inPredSense)</span></span></span></span></code> </pre> <br>  Qui, en cons√©quence, accepte un code d'instruction pour la conversion et la valeur de l'√©num√©ration g√©n√©r√©e automatiquement PredSense, qui contient toutes les valeurs possibles dans les colonnes.  La mise en ≈ìuvre de cette fonction est tr√®s simple, car  il renvoie l'√©l√©ment de tableau souhait√© pour l'instruction qui nous int√©resse. <br><br>  Et dans le code backend, au lieu d'√©crire un <code>switch-case</code> suffit d'appeler simplement la fonction g√©n√©r√©e, qui renverra le code de l'instruction convertie.  Une solution simple, o√π l'ajout de nouvelles instructions, n'entra√Ænera pas la n√©cessit√© d'une action suppl√©mentaire. <br><br><h2>  Artefacts g√©n√©r√©s automatiquement (fichiers <code>.inc</code> ) </h2><br>  Toute l'interaction entre la description TableGen et le code backend LLVM est assur√©e par les fichiers <code>.inc</code> g√©n√©r√©s qui contiennent le code C.  Pour obtenir une image compl√®te, voyons un peu ce qu'ils sont exactement. <br><br>  Apr√®s chaque build, pour chaque architecture, il y aura plusieurs fichiers <code>.inc</code> dans le r√©pertoire de build, chacun d'entre eux stockant des informations distinctes sur l'architecture.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Donc , </font><font style="vertical-align: inherit;">il y a un fichier </font></font><code>&lt;TargetName&gt;GenInstrInfo.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contenant des </font><font style="vertical-align: inherit;">informations sur les instructions </font></font><code>&lt;TargetName&gt;GenRegisterInfo.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, respectivement, qui contient des </font><font style="vertical-align: inherit;">informations sur les registres, il y a des </font><font style="vertical-align: inherit;">fichiers de travail directement avec l'assembleur et sa sortie </font></font><code>&lt;TargetName&gt;GenAsmMatcher.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>&lt;TargetName&gt;GenAsmWriter.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En quoi consistent ces fichiers? En g√©n√©ral, ils contiennent des √©num√©rations, des tableaux, des structures et des fonctions simples. Par exemple, vous pouvez consulter les informations converties sur les instructions dans </font></font><code>&lt;TargetName&gt;GenInstrInfo.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la premi√®re partie, dans l'espace de noms avec le nom de la cible se trouve une √©num√©ration contenant toutes les instructions qui ont √©t√© d√©crites.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> X86 { <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { PHI = <span class="hljs-number"><span class="hljs-number">0</span></span>, ‚Ä¶ ADD16i16 = <span class="hljs-number"><span class="hljs-number">287</span></span>, ADD16mi = <span class="hljs-number"><span class="hljs-number">288</span></span>, ADD16mi8 = <span class="hljs-number"><span class="hljs-number">289</span></span>, ADD16mr = <span class="hljs-number"><span class="hljs-number">290</span></span>, ADD16ri = <span class="hljs-number"><span class="hljs-number">291</span></span>, ADD16ri8 = <span class="hljs-number"><span class="hljs-number">292</span></span>, ADD16rm = <span class="hljs-number"><span class="hljs-number">293</span></span>, ADD16rr = <span class="hljs-number"><span class="hljs-number">294</span></span>, ADD16rr_REV = <span class="hljs-number"><span class="hljs-number">295</span></span>, ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vient ensuite un tableau d√©crivant les propri√©t√©s des instructions </font></font><code>const MCInstrDesc X86Insts[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Les tableaux suivants contiennent des informations sur les noms d'instructions, etc. </font><font style="vertical-align: inherit;">Fondamentalement, toutes les informations sont stock√©es dans des transferts et des tableaux. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe √©galement des fonctions qui ont √©t√© d√©crites √† l'aide de pr√©dicats. </font><font style="vertical-align: inherit;">Sur la base de la d√©finition de pr√©dicat de fonction discut√©e dans la section pr√©c√©dente, la fonction suivante sera g√©n√©r√©e.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> X86InstrInfo::isThreeOperandsLEA(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MachineInstr &amp;MI) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(MI.getOpcode()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> X86::LEA32r: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> X86::LEA64r: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> X86::LEA64_32r: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> X86::LEA16r: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( MI.getOperand(<span class="hljs-number"><span class="hljs-number">1</span></span>).isReg() &amp;&amp; MI.getOperand(<span class="hljs-number"><span class="hljs-number">1</span></span>).getReg() != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; MI.getOperand(<span class="hljs-number"><span class="hljs-number">3</span></span>).isReg() &amp;&amp; MI.getOperand(<span class="hljs-number"><span class="hljs-number">3</span></span>).getReg() != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; ( ( MI.getOperand(<span class="hljs-number"><span class="hljs-number">4</span></span>).isImm() &amp;&amp; MI.getOperand(<span class="hljs-number"><span class="hljs-number">4</span></span>).getImm() != <span class="hljs-number"><span class="hljs-number">0</span></span> ) || (MI.getOperand(<span class="hljs-number"><span class="hljs-number">4</span></span>).isGlobal()) ) ); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// end of switch-stmt }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais il y a des donn√©es dans les fichiers et les structures g√©n√©r√©s. </font><font style="vertical-align: inherit;">Dans </font></font><code>X86GenSubtargetInfo.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vous pouvez trouver un exemple de la structure qui devrait √™tre utilis√©e dans le code principal pour obtenir des informations sur l'architecture, √† travers elle dans la section pr√©c√©dente, nous avons obtenu TTI.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X86GenMCSubtargetInfo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MCSubtargetInfo { X86GenMCSubtargetInfo(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Triple &amp;TT, StringRef CPU, StringRef FS, ArrayRef&lt;SubtargetFeatureKV&gt; PF, ArrayRef&lt;SubtargetSubTypeKV&gt; PD, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MCWriteProcResEntry *WPR, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MCWriteLatencyEntry *WL, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MCReadAdvanceEntry *RA, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InstrStage *IS, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> *OC, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> *FP) : MCSubtargetInfo(TT, CPU, FS, PF, PD, WPR, WL, RA, IS, OC, FP) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolveVariantSchedClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SchedClass, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MCInst *MI, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CPUID)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> X86_MC::resolveVariantSchedClassImpl(SchedClass, MI, CPUID); } };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S'il est utilis√© </font></font><code>Subtarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour d√©crire diverses configurations </font></font><code>XXXGenSubtarget.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, une √©num√©ration sera cr√©√©e avec les propri√©t√©s d√©crites √† l'aide de </font></font><code>SubtargetFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tableaux avec des valeurs constantes pour indiquer les caract√©ristiques et les sous-types du CPU, et une fonction sera g√©n√©r√©e </font></font><code>ParseSubtargetFeatures</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui </font><font style="vertical-align: inherit;">traitera </font><font style="vertical-align: inherit;">la cha√Æne avec le jeu d'options </font></font><code>Subtarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. De plus, l'impl√©mentation de la m√©thode </font></font><code>XXXSubtarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans le code backend doit correspondre au pseudo-code suivant, dans lequel il est n√©cessaire d'utiliser cette fonction:</font></font><br><br><pre> <code class="cpp hljs">XXXSubtarget::XXXSubtarget(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Module &amp;M, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;FS) { <span class="hljs-comment"><span class="hljs-comment">// Set the default features // Determine default and user specified characteristics of the CPU // Call ParseSubtargetFeatures(FS, CPU) to parse the features string // Perform any additional operations }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malgr√© le fait que les </font></font><code>.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fichiers sont tr√®s volumineux et contiennent d'√©normes tableaux, cela nous permet d'optimiser le temps d'acc√®s aux informations, car l'acc√®s √† un √©l√©ment du tableau a un temps constant. </font><font style="vertical-align: inherit;">Les fonctions de recherche g√©n√©r√©es par des instructions sont impl√©ment√©es √† l'aide d'un algorithme de recherche binaire pour minimiser le temps de fonctionnement. </font><font style="vertical-align: inherit;">Le stockage sous cette forme est donc tout √† fait justifi√©.</font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En cons√©quence, gr√¢ce √† TableGen dans LLVM, nous avons des descriptions d'architecture lisibles et facilement prises en charge dans un format unique avec divers m√©canismes pour interagir et acc√©der aux informations √† partir du code source backend LLVM pour les optimisations et la g√©n√©ration de code. </font><font style="vertical-align: inherit;">Dans le m√™me temps, une telle description n'affecte pas les performances du compilateur en raison du code g√©n√©r√© automatiquement qui utilise des solutions et des structures de donn√©es efficaces.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr474460/">https://habr.com/ru/post/fr474460/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr474444/index.html">5 projets de formation plus audacieux pour le d√©veloppeur (Layer, Squoosh, Calculator, Website Crawler, Music Player)</a></li>
<li><a href="../fr474448/index.html">Ce que le cerveau d'un √©tudiant dans le monde informatique est capable de faire</a></li>
<li><a href="../fr474450/index.html">Arr√™tez d'utiliser un TTL ridiculement petit pour DNS</a></li>
<li><a href="../fr474452/index.html">Rapport de situation automne Haxe</a></li>
<li><a href="../fr474458/index.html">Total cumul√© en SQL</a></li>
<li><a href="../fr474462/index.html">√ânorme ensemble de donn√©es ouvertes de la version russe du discours 1.0</a></li>
<li><a href="../fr474466/index.html">Histoire du premier Diablo</a></li>
<li><a href="../fr474470/index.html">Attaque DDoS sur les services RDP: reconna√Ætre et surmonter. Exp√©rience r√©ussie de Tucha</a></li>
<li><a href="../fr474472/index.html">Liste de contr√¥le UX en 30 points pour les applications mobiles</a></li>
<li><a href="../fr474474/index.html">Rep√®res ouverts pour le test de charge des serveurs et des applications Web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>