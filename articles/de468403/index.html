<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçüî¨ üöÖ üë©üèª‚Äçüé® Integrierte Laufzeitsteuerung f√ºr Softwareanwendungen ‚ìÇÔ∏è üéÉ üë®‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Ver√∂ffentlichung enth√§lt eine Softwareimplementierung integrierter Tools zum Sammeln und Sammeln von Metrikinformationen zur Laufzeit von Anwendun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Integrierte Laufzeitsteuerung f√ºr Softwareanwendungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468403/"><img src="https://habrastorage.org/webt/k1/xf/-b/k1xf-b3txxrnnl3dlfn6htckrmm.jpeg" align="right" width="40%">  Die Ver√∂ffentlichung enth√§lt eine Softwareimplementierung integrierter Tools zum Sammeln und Sammeln von Metrikinformationen zur Laufzeit von Anwendungen, die in C / C ++ / C # geschrieben wurden. <br><br>  Der Kern des beschriebenen Ansatzes basiert auf der Aufnahme von ‚ÄûKontrollpunkten‚Äú in den Programmcode der Anwendung zum Extrahieren von Daten zur Ausf√ºhrungszeit von Strukturkomponenten: Methoden, Funktionen und {} Bl√∂cke.  Die extrahierten Metrikinformationen werden in einer internen Datenbank gesammelt, deren Inhalt am Ende der Anwendung in ein in einer Datei gespeichertes Textberichtsformular konvertiert wird.  Die Angemessenheit der Verwendung der Mittel zur integrierten Steuerung der Ausf√ºhrungszeit beruht auf der Notwendigkeit, Problembereiche des Codes zu identifizieren, die Ursachen f√ºr die vor√ºbergehende Verschlechterung der Anwendung zu analysieren: vollst√§ndig oder teilweise oder auf bestimmten S√§tzen von Quelldaten zu manifestieren. <br><br>  Die angegebenen C ++ / C # -Quellcodebeispiele zeigen m√∂gliche Implementierungen des beschriebenen Ansatzes. <br><a name="habracut"></a><br><h3>  Einf√ºhrung </h3><br>  Die Entwicklung einer Softwareanwendung bei jeder Iteration (z. B. der Ver√∂ffentlichung der n√§chsten Version) ihrer evolution√§ren Entwicklung umfasst die folgenden grundlegenden Schritte: <br><br><ul><li>  Entwicklung und Erprobung von Funktionen; </li><li>  Optimierung der verbrauchten RAM-Ressourcen; </li><li>  Stabilisierung von Laufzeitmetriken. </li></ul><br>  Diese Schritte erfordern eine erhebliche Anzahl von Entwicklern, die nicht nur kreativ sind (wie die Entwicklung und Implementierung effektiver Algorithmen, die Erstellung einer flexiblen Softwarearchitektur usw.), sondern auch Routinearbeiten.  Die letztere Kategorie umfasst Aktivit√§ten zur Stabilisierung von Zeitmetriken f√ºr die Anwendungsausf√ºhrung.  In vielen F√§llen ist dies ein ziemlich schmerzhafter Vorgang, wenn Entwickler mit einer Verschlechterung konfrontiert sind. Dies ist eine Folge der Erweiterung der Funktionalit√§t des Softwareprodukts, der Neuerstellung der Softwarearchitektur und des Auftretens neuer Threads in der Anwendung.  Gleichzeitig erfordern die Ursachen der Verschlechterung bestimmte Anstrengungen, um sie zu erkennen, was nicht nur durch die hohe Flei√üigkeit und Verantwortung der Entwickler (notwendige Bedingung), sondern auch durch die Zusammensetzung der f√ºr diese Zwecke verwendeten Werkzeuge (ausreichende Bedingung) erreicht wird. <br><br>  Einer der effektiven Ans√§tze zur L√∂sung des Problems der Analyse von Anwendungszeitmetriken ist die Verwendung spezialisierter Softwareprodukte, beispielsweise GNU <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i><b>gprof</b></i></a> .  Durch die Analyse von Berichten, die mit solchen Tools erstellt wurden, k√∂nnen Sie ‚ÄûEngp√§sse‚Äú (Klassenmethoden und -funktionen) identifizieren, die einen erheblichen Zeitaufwand f√ºr die Ausf√ºhrung der gesamten Anwendung ausmachen.  Gleichzeitig wird die G√ºltigkeit der Zeit, die f√ºr die Ausf√ºhrung von Methoden und Verfahren aufgewendet wird, sicherlich von den Entwicklern qualifiziert. <br><br>  Es ist auch zu beachten, dass die Softwareprodukte dieser Klasse in der Regel eine metrische Analyse der Ausf√ºhrungszeit des Programmcodes auf den Ebenen der Methoden von Klassen und Funktionen durchf√ºhren, wobei die niedrigeren (vom Standpunkt der Problemanalyse jedoch signifikanten) Ebenen ignoriert werden: <i>{...}, z. w√§hrend, bis, wenn - sonst, Try-Catch-</i> Bl√∂cke, innerhalb derer keine weniger bedeutenden Ausgaben f√ºr die Ausf√ºhrungszeit anfallen. <br><br>  Als n√§chstes wird der Hauptinhalt einer der m√∂glichen L√∂sungen f√ºr die Implementierung integrierter Laufzeitsteuerungswerkzeuge betrachtet, die darauf abzielen, detaillierte Informationen √ºber Zeitmetriken von gesteuerten Softwarebl√∂cken mit anschlie√üender Erstellung von Berichten f√ºr Entwickler zu extrahieren und zu sammeln. <br><br><h3>  Methoden zum Abrufen von Laufzeitdaten </h3><br>  Die Funktionalit√§t jeder Softwareanwendung kann als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">abstrakte Maschine</a> mit einer endlichen Menge eindeutiger <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zust√§nde</a> <b><i>{St}</i></b> und √úberg√§ngen <b><i>{Tr}</i></b> zwischen ihnen interpretiert werden. <br><br>  Im Rahmen dieses Ansatzes sollte jeder Ausf√ºhrungsfluss in der Anwendung als eine geordnete Folge ihrer Zust√§nde und √úberg√§nge zwischen ihnen interpretiert werden.  In diesem Fall wird die Sch√§tzung der Ausf√ºhrungszeitkosten durchgef√ºhrt, indem die Zeitmetriken √ºber den gesamten Satz √ºbergebener Zust√§nde summiert werden, wobei die Kosten f√ºr √úberg√§nge von einem Zustand in einen anderen ignoriert werden - als vernachl√§ssigbare Werte. <br><br>  Das Extrahieren und Sammeln von Daten zur Anwendungsausf√ºhrungszeit an den angegebenen Kontrollpunkten ist die Hauptaufgabe, die von den nachstehend beschriebenen integrierten Steuerungswerkzeugen gel√∂st wird. <br><br>  F√ºr jeden im Quellcode durch Platzieren deklarierten Haltepunkt <br>  <b>PROFILE_ENTRY</b> C ++ - Makro, die Anzahl seiner Durchl√§ufe w√§hrend der Anwendungsausf√ºhrung sowie die Zeitmetrik - die Gesamtzeit, in der sich die Anwendung im Zustand befand, ab dem Zeitpunkt, an dem der Pr√ºfpunkt an die n√§chste Ebene der Programmhierarchie √ºbergeben wurde (einschlie√ülich Block, Klassenmethode, Funktion usw.). wie in der folgenden Abbildung dargestellt. <br><br>  Die Steuerung der Kontrollpunkte (Erstregistrierung und Berechnung ihrer <b><i>Zeitmetriken</i></b> ) erfolgt durch das Objekt <b><i>'timeManager'</i></b> , das in einer einzelnen Instanz erstellt wird.  Jedes Ereignis beim √úbergeben des Pr√ºfpunkts wird durch das Objekt <b><i>'timeManager' festgelegt</i></b> und w√§hrend des ersten Durchlaufs von ihm als Observables als <b><i>'registerEntry' registriert</i></b> . <br><br>  Bei jedem Durchlaufen des Kontrollpunkts wird ein <b><i>timerObject-</i></b> Objekt <b><i>erstellt</i></b> , das den Zeitpunkt seiner Erstellung <b><i>festlegt</i></b> .  Die Ausf√ºhrungszeit wird am Pr√ºfpunkt festgelegt, wenn die Anwendung die aktuelle Ebene der Softwarehierarchie verl√§sst.  In diesem Moment wird das timerObject des Objekts automatisch zerst√∂rt, was mit der Berechnung seiner "Lebensdauer" T <b><i>einhergeht. Infolgedessen</i></b> erh√∂ht der <b><i>timeManager</i></b> die <b><i>H√§ufigkeit</i></b> , mit der der Pr√ºfpunkt passiert, und die Zeit, die <b><i>T.</i></b> in ihm verbringt <b><i>.</i></b>  F√ºr alle festgelegten Kontrollpunkte sammelt <b><i>timeManager</i></b> Daten mit der anschlie√üenden Ver√∂ffentlichung eines Berichts, wenn die Anwendung beendet wird. <br><br><img src="https://habrastorage.org/webt/eq/ze/7e/eqze7eww_flgezgdi08ncstlz7m.jpeg"><br><br>  Unten finden Sie den C ++ - Quellcode, der die integrierten Tools zur Steuerung der Ausf√ºhrungszeit der Anwendung implementiert. <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     #include &lt;vector&gt; #include &lt;map&gt; #include &lt;algorithm&gt; #include &lt;stdio.h&gt; #include &lt;time.h&gt; typedef unsigned long LONGEST_INT; // ,    //     //     //  ( )   // ()   //    #define PROFILER_ENABLED // CREATE_PROFILER  timeManager , //     // 'main()' #ifdef PROFILER_ENABLED #define CREATE_PROFILER timeManager tManager; #else #define CREATE_PROFILER //   CREATE_PROFILER. #endif //INITIALIZE_PROFILER    timeManager  //       //   'main()' #ifdef PROFILER_ENABLED #define INITIALIZE_PROFILER bool timeManager::object = false;\ std::vector&lt;registerEntry&gt; timeManager::entries; #else #define INITIALIZE_PROFILER //   INITIALIZE_PROFILER. #endif //DELAY(_SECONDS)   '_SECONDS' . //    ,  //     //  #ifdef PROFILER_ENABLED #define DELAY(_SECONDS) {clock_t clk_wait=clock()+((double)_ARG)*CLOCKS_PER_SEC;\ while(clock()&lt;clk_wait) {}} #else #define DELAY(_SECONDS) //    DELAY. #endif //     , //     UNIX  WINDOWS //      #ifdef PROFILER_ENABLED #define MERGE2(x,y) x##y #define MERGE1(_X,_Y) MERGE2(_X,_Y) #if WIN32 #define UNIQUENAME prefix,postfix) MERGE1(prefix,postfix) #else #define UNIQUENAME(prefix,postfix) MERGE2(prefix,postfix) #endif #define GEN_SRC(_ARG1,_ARG2) static int UNIQUENAME(ind,_ARG2)=-1;\ if(UNIQUENAME(ind,_ARG2)&lt;0)\ UNIQUENAME(ind,_ARG2)=timeManager::add_entry(_ARG1);\ timeManager::incr_counter(UNIQUENAME(ind,_ARG2));\ timerObject UNIQUENAME(tm,_ARG2)(UNIQUENAME(ind,_ARG2)); //PROFILE_ENTRY      #ifdef PROFILER_ENABLED #if WIN32 #define PROFILE_ENTRY(_TITLE) GEN_SRC(_TITLE,__COUNTER__) #else #define PROFILE_ENTRY(_TITLE) GEN_SRC(_TITLE,__LINE__) #endif #else #define PROFILE_ENTRY(_TITLE) //    PROFILE_ENTRY. #endif //        //    //    ,   timeManager struct registerEntry { //     (  ) std::string entry_name; //     //     LONGEST_INT covers_counter; //      //     (ticks) LONGEST_INT elapsed_time; // registerEntry(const char * title):entry_name(title), covers_counter(0), elapsed_time(0) {} }; //     class timerObject { //   ,     int index; //    clock_t start_time; public: //       timerObject(int ind):index(ind),start_time(clock()) {} //    ‚Äú ‚Äù  //       //   ~timerObject(void) { timeManager::incr_timer(index,(LONGEST_INT)(clock()-start_time)); } }; //     class timeManager { private: //     static std::vector&lt;registerEntry&gt; entries; // ,     //    static bool object; public: //     //  ,    //     static int add_entry(const char * title) { entries.push_back(registerEntry(title)); return (((int)entries.size())-1); } //       //      static void incr_counter(int profile_entry_id) { entries[profile_entry_id].covers_counter++; } //  'value'     //      static void incr_timer(int profile_entry_id, LONGEST_INT value) { entries[profile_entry_id].elapsed_time += val; } //       //   static void report(void); //  timeManager(void) { if(!object) object = true; else { printf("\n&lt;&lt;&gt;&gt;:    'timeManager' .\n"); throw; } } //        //   virtual ~timeManager(void) {report();} }; //      bool cmp_entries(registerEntry &amp; first, registerEntry &amp; second) { if(first.entry_name.compare(second.entry_name)&gt;0) return false; return true; } //      //    void timeManager::report(void) { const std::string bar(72,'*'); //        const char * REPORT_FILE = "C:\\tmProfile.txt"; FILE * fp = fopen(REPORT_FILE,"w"); if(!fp) { printf("\n&lt;&lt;&gt;&gt;:       (%s)",REPORT_FILE); return; } fprintf(fp,"\n#%s",bar.c_str()); fprintf(fp,"\n#\n#      "); fprintf(fp,"\n#\n#%s",bar.c_str()); fprintf(fp,"\n#\n# %-35s %-15s %-20s", " ",""," ()"); fprintf(fp,"\n# %-35s %-15s %-20s", "------------------","-------------","---------------\n#"); //         std::sort(entries.begin(),entries.end(),cmp_entries); for(unsigned jj = 0; jj&lt; entries.size(); jj++) { fprintf(fp,"\n# %-35s %-16d", entries[jj].entry_name.c_str(), entries[jj].covers_counter); if(entries[jj].covers_counter == 0) fprintf(fp,"%-20d",0); else fprintf(fp,"%-20.0f", static_cast&lt;double&gt;(entries[jj].elapsed_time)/ static_cast&lt;double&gt;(CLOCKS_PER_SEC)); } if(entries.size() == 0) fprintf(fp,"\n# No covered profile entries found\n"); fprintf(fp,"\n#\n#%s\n",bar.c_str()); fclose(fp); }</span></span></code> </pre> <br>  Die Struktur der Demoanwendung ist unten dargestellt und zeigt die Verwendung der integrierten Laufzeitsteuerungstools als Beispiel sowie eine Tabelle der erzielten Ergebnisse (Einzelheiten siehe <b><i>Anhang 1. Quellcode der Demoanwendung</i></b> ). <br><br><img src="https://habrastorage.org/webt/bg/ds/cg/bgdscgwtg66sw9cdwo1kacjeryy.jpeg"><br><br><img src="https://habrastorage.org/webt/oi/sw/kk/oiswkkxofhegr5uokrld8ttpdmg.jpeg"><br><br>  Abschnitt <b><i>Nachtrag 2. Der Quellcode der Mittel der eingebauten Steuerung der Ausf√ºhrungszeit der C # -Anwendung</i></b> zeigt eine √§hnliche Implementierung der Mittel der eingebauten Steuerung in C #. <br><br>  Der Autor verwendet Paare von <b>TimeWatcher.StartWatch ()</b> und <b>TimeWatcher.StopWatch ()</b> , um die Ausf√ºhrungszeit m√ºhsamer (aus rechnerischer Sicht) Methoden und Verfahren im Rahmen des von <b>EREMEX</b> entwickelten Software-Produkts <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Delta Design</b></a> - einem computergest√ºtzten Konstruktionssystem f√ºr elektronische Ger√§te - zu <b>analysieren</b> . <br><br>  Unten finden Sie ein Beispiel f√ºr einen kurzen Bericht √ºber Zeitmetriken einer der Funktionen des genannten Produkts. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5_/ka/r-/5_kar-gqi4xmd2p9bfrtlqae3vc.jpeg"></div><br><h3>  Kurze Schlussfolgerungen </h3><br>  Die beschriebenen Tools k√∂nnen verwendet werden, um Daten zur Ausf√ºhrungszeit von Anwendungen in verschiedenen Teilen des Programmcodes zu erfassen. Insbesondere erm√∂glichen sie Folgendes: <br><br><ul><li>  Sammeln und Sammeln von Daten zu Zeitmetriken von Ausf√ºhrungsthreads in der Anwendung; </li><li>  Sch√§tzungen der Ausf√ºhrungszeit von Programmcode durchf√ºhren, die auf elementare Sprachkonstrukte genau sind; </li><li>  Verwalten Sie das Volumen der extrahierten Daten, indem Sie die integrierten Steuerungswerkzeuge in den entsprechenden Abschnitten der Anwendungsausf√ºhrungsabl√§ufe ein- und ausschalten </li><li>  Entwicklung und Anwendung von Regressionstests, die die Stabilit√§t (und die Verschlechterung) von Anwendungszeitmetriken √ºberwachen. </li></ul><br>  Zusammenfassend ist anzumerken, dass au√üerhalb des Umfangs dieser Ver√∂ffentlichung Fragen zur Verwendung der beschriebenen integrierten Steuerungswerkzeuge im Zusammenhang mit <i>Multithreading-</i> Anwendungen <i>auftraten</i> und keine Analyse der Genauigkeit der erhaltenen Daten anhand von Zeitmetriken in irgendeiner Form vorgelegt wurde.  Letzteres ist darauf zur√ºckzuf√ºhren, dass in der Praxis bei der Ermittlung der Ursachen f√ºr die vor√ºbergehende Verschlechterung einer <font color="blue"><font color="black">Anwendung in</font></font> erster Linie die Daten zur <font color="blue"><b><i>relativen Verteilung</i></b> <font color="black">der Ausf√ºhrungszeitkosten zwischen den Softwarekomponenten der Anwendung</font></font> relevant sind <font color="blue"><font color="black">.</font></font>  <font color="blue"><font color="black">In diesem Zusammenhang treten Fragen nach der Genauigkeit der erhaltenen Daten in den Hintergrund.</font></font> <font color="blue"><font color="black"><br><br></font></font> <h3>  <font color="blue"><font color="black">Anhang 1. Quellcode f√ºr die Demo-Anwendung</font></font> </h3> <font color="blue"><font color="black"><br></font></font> <pre> <font color="blue"><font color="black"><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">INITIALIZE_PROFILER </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//create profile manager CREATE_PROFILER PROFILE_ENTRY("1 Main context") f11(); for(unsigned jj = 0;jj&lt;4;jj++) f12(); f13 (); f14 (); f15 (); f16 (); f17(); return 0; } void f11(void)///////////////////////////////////////// { PROFILE_ENTRY ("2 f11()........................") for (unsigned jj = 0; jj&lt;5; jj++) { PROFILE_ENTRY ("2 f11()::for(...){...} iterat-ing") DELAY(1) } //profile entry for repeating int nn(3); while(nn &gt; 0) { PROFILE_ENTRY("2 f11()::while(...){...} iterat-ing") DELAY(1) nn--; } } void f12(void)///////////////////////////////////////// { PROFILE_ENTRY("3 f12()........................") goto ending; { PROFILE_ENTRY("3 f12()::ignored code part") DELAY(1) } ending: PROFILE_ENTRY("3 f12()::ending code part") DELAY(2) } void f13(void) ///////////////////////////////////////// { PROFILE_ENTRY("4 f13()........................") srand((unsigned) time(NULL)/2); for(unsigned jj = 0; jj &lt; 200; jj++) { if(rand()%2 == 0) { PROFILE_ENTRY("4 f13()::even branch") DELAY(0.01) } else { PROFILE_ENTRY("4 f13()::od branch") DELAY(0.02) } } } void f14(void)///////////////////////////////////////// { static int depth = 10; { PROFILE_ENTRY("5 f14() recursion") depth--; DELAY(0.5) if(depth == 0) return; } f14(); } void f15(void)///////////////////////////////////////// { PROFILE_ENTRY("7 f15()........................") for(unsigned jj = 0; jj &lt; 10; jj++) { demo_class obj; obj.method1(); obj.method2(); obj.method3(); } } void f16(void)///////////////////////////////////////// { PROFILE_ENTRY("8 f16()........................") try { for(int jj = 10; jj &gt;= 0; jj--) { PROFILE_ENTRY("81 f16() try clause") DELAY(1) int rr = 200/jj; } } catch(...) { PROFILE_ENTRY("81 f16() catch clause") DELAY(2) return; } } void f17(void)///////////////////////////////////////// { PROFILE_ENTRY("9 f17()........................") f21(); f22(); f23(); f24(); f25(); } void f22(void)///////////////////////////////////////// { PROFILE_ENTRY("91 f22()........................") DELAY(1) f221(); f222(); f223(); } void f23(void) {PROFILE_ENTRY("91 f23()") DELAY(1) } void f24(void) {PROFILE_ENTRY("91 f24()") DELAY(1) } void f25(void) {PROFILE_ENTRY("91 f25()") DELAY(1) } void f221(void) {PROFILE_ENTRY("91 f221()") DELAY(3) } void f222(void) {PROFILE_ENTRY("91 f222()") DELAY(4) } void f223(void) {PROFILE_ENTRY("91 f223()") DELAY(5) }</span></span></code></font></font> </pre> <font color="blue"><font color="black"><br></font></font> <h3>  <font color="blue"><font color="black">Erg√§nzung 2. Quellcode der integrierten C # -Anwendungen zur Laufzeitsteuerung</font></font> </h3> <font color="blue"><font color="black"><br></font></font> <pre> <font color="blue"><font color="black"><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// &lt;summary&gt; ///             /// &lt;/summary&gt; public class TimeWatcher { /// &lt;summary&gt; ///            /// &lt;/summary&gt; internal class TimeEntry { //     public Stopwatch timeWatch; //       public long elapsedTime; //  public TimeEntry() { timeWatch = new Stopwatch(); elapsedTime = 0; } } //       //    private static bool enableTimeWatcher = false; //            private static Dictionary&lt;string, TimeEntry&gt; entryDictionary = new Dictionary&lt;string, TimeEntry&gt;(); //         public static void StartWatch(string postfix = "") { if (!enableTimeWatcher) return; string entryName = GetCurrentMethod(); if (postfix != "") { entryName += postfix; } //    ,      //         if (!entryDictionary.ContainsKey(entryName)) { entryDictionary.Add(entryName, new TimeEntry()); entryDictionary[entryName].timeWatch.Start(); } else { if (entryDictionary[entryName].timeWatch.IsRunning) { throw new System.InvalidOperationException(":    '" + entryName + "'  ."); } else entryDictionary[entryName].timeWatch.Restart(); } } //        public static void StopWatch(string postfix = "") { if (!enableTimeWatcher) return; string entryName = GetCurrentMethod(); if (postfix != "") { entryName += postfix; } //    ,      if (!entryDictionary.ContainsKey(entryName)) { throw new System.InvalidOperationException(":     -    '" + entryName + "'."); } if (!entryDictionary[entryName].timeWatch.IsRunning) { throw new System.InvalidOperationException ":        '" + entryName + "'."); } entryDictionary[entryName].timeWatch.Stop(); entryDictionary[entryName].elapsedTime += entryDictionary[entryName].timeWatch.ElapsedMilliseconds; } //        //     public static void TimeWatchReport() { const string bar = "============================================="; if (!enableTimeWatcher) return; Console.WriteLine(""); Console.WriteLine(bar); Console.WriteLine("     (): "); Console.WriteLine(""); int maxLen = 0; foreach (var timeEntry in entryDictionary) { if(timeEntry.Key.Length &gt; maxLen) maxLen = timeEntry.Key.Length; } maxLen++; string strFormat = "{0," + maxLen + "} ... {1,-10}"; foreach (var timeEntry in entryDictionary) { Console.WriteLine(strFormat, timeEntry.Key, timeEntry.Value.elapsedTime); } Console.WriteLine(bar); Console.WriteLine(""); entryDictionary.Clear(); enableTimeWatcher = false; } //          //      /tmw    //   public static void InitTimeWatch() { if (Environment.GetCommandLineArgs().Any(v =&gt; v == "/tmw")) { if (entryDictionary.Count &gt; 0) { TimeWatchReport(); } entryDictionary.Clear(); enableTimeWatcher = true; } } //        private static string GetCurrentMethod() { StackTrace st = new StackTrace(); StackFrame sf = st.GetFrame(2); return sf.GetMethod().Name; } }</span></span></code></font></font> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468403/">https://habr.com/ru/post/de468403/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468393/index.html">Mit einem guten Mikrocontroller vergeht die Zeit schnell oder mit einem Wochenendoszilloskop</a></li>
<li><a href="../de468395/index.html">Cloud-Sicherheits√ºberwachung. Teil 2</a></li>
<li><a href="../de468397/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 477 (09/03/2019 - 09.09.2019)</a></li>
<li><a href="../de468399/index.html">C / C ++. Verwendung eingebetteter Anwendungsressourcen bei der Arbeit in GCC unter Linux</a></li>
<li><a href="../de468401/index.html">Sichere M√∂glichkeit zum Austausch von JWT in ASP.NET Core + SPA</a></li>
<li><a href="../de468405/index.html">Zwei Browser betreten irgendwie die Bildlaufleiste ...</a></li>
<li><a href="../de468407/index.html">5G - eine Technologie, die das Web wahrscheinlich verlangsamen wird</a></li>
<li><a href="../de468409/index.html">Servicemitarbeiter im Slack Client: On Download-Beschleunigung und Offline-Modus</a></li>
<li><a href="../de468411/index.html">Eine Geschichte √ºber das L√∂sen des Leistungsproblems von Moment.j.</a></li>
<li><a href="../de468413/index.html">Beschleunigung instagram.com. Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>