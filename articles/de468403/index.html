<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🔬 🚅 👩🏻‍🎨 Integrierte Laufzeitsteuerung für Softwareanwendungen Ⓜ️ 🎃 👨‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Veröffentlichung enthält eine Softwareimplementierung integrierter Tools zum Sammeln und Sammeln von Metrikinformationen zur Laufzeit von Anwendun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Integrierte Laufzeitsteuerung für Softwareanwendungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468403/"><img src="https://habrastorage.org/webt/k1/xf/-b/k1xf-b3txxrnnl3dlfn6htckrmm.jpeg" align="right" width="40%">  Die Veröffentlichung enthält eine Softwareimplementierung integrierter Tools zum Sammeln und Sammeln von Metrikinformationen zur Laufzeit von Anwendungen, die in C / C ++ / C # geschrieben wurden. <br><br>  Der Kern des beschriebenen Ansatzes basiert auf der Aufnahme von „Kontrollpunkten“ in den Programmcode der Anwendung zum Extrahieren von Daten zur Ausführungszeit von Strukturkomponenten: Methoden, Funktionen und {} Blöcke.  Die extrahierten Metrikinformationen werden in einer internen Datenbank gesammelt, deren Inhalt am Ende der Anwendung in ein in einer Datei gespeichertes Textberichtsformular konvertiert wird.  Die Angemessenheit der Verwendung der Mittel zur integrierten Steuerung der Ausführungszeit beruht auf der Notwendigkeit, Problembereiche des Codes zu identifizieren, die Ursachen für die vorübergehende Verschlechterung der Anwendung zu analysieren: vollständig oder teilweise oder auf bestimmten Sätzen von Quelldaten zu manifestieren. <br><br>  Die angegebenen C ++ / C # -Quellcodebeispiele zeigen mögliche Implementierungen des beschriebenen Ansatzes. <br><a name="habracut"></a><br><h3>  Einführung </h3><br>  Die Entwicklung einer Softwareanwendung bei jeder Iteration (z. B. der Veröffentlichung der nächsten Version) ihrer evolutionären Entwicklung umfasst die folgenden grundlegenden Schritte: <br><br><ul><li>  Entwicklung und Erprobung von Funktionen; </li><li>  Optimierung der verbrauchten RAM-Ressourcen; </li><li>  Stabilisierung von Laufzeitmetriken. </li></ul><br>  Diese Schritte erfordern eine erhebliche Anzahl von Entwicklern, die nicht nur kreativ sind (wie die Entwicklung und Implementierung effektiver Algorithmen, die Erstellung einer flexiblen Softwarearchitektur usw.), sondern auch Routinearbeiten.  Die letztere Kategorie umfasst Aktivitäten zur Stabilisierung von Zeitmetriken für die Anwendungsausführung.  In vielen Fällen ist dies ein ziemlich schmerzhafter Vorgang, wenn Entwickler mit einer Verschlechterung konfrontiert sind. Dies ist eine Folge der Erweiterung der Funktionalität des Softwareprodukts, der Neuerstellung der Softwarearchitektur und des Auftretens neuer Threads in der Anwendung.  Gleichzeitig erfordern die Ursachen der Verschlechterung bestimmte Anstrengungen, um sie zu erkennen, was nicht nur durch die hohe Fleißigkeit und Verantwortung der Entwickler (notwendige Bedingung), sondern auch durch die Zusammensetzung der für diese Zwecke verwendeten Werkzeuge (ausreichende Bedingung) erreicht wird. <br><br>  Einer der effektiven Ansätze zur Lösung des Problems der Analyse von Anwendungszeitmetriken ist die Verwendung spezialisierter Softwareprodukte, beispielsweise GNU <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i><b>gprof</b></i></a> .  Durch die Analyse von Berichten, die mit solchen Tools erstellt wurden, können Sie „Engpässe“ (Klassenmethoden und -funktionen) identifizieren, die einen erheblichen Zeitaufwand für die Ausführung der gesamten Anwendung ausmachen.  Gleichzeitig wird die Gültigkeit der Zeit, die für die Ausführung von Methoden und Verfahren aufgewendet wird, sicherlich von den Entwicklern qualifiziert. <br><br>  Es ist auch zu beachten, dass die Softwareprodukte dieser Klasse in der Regel eine metrische Analyse der Ausführungszeit des Programmcodes auf den Ebenen der Methoden von Klassen und Funktionen durchführen, wobei die niedrigeren (vom Standpunkt der Problemanalyse jedoch signifikanten) Ebenen ignoriert werden: <i>{...}, z. während, bis, wenn - sonst, Try-Catch-</i> Blöcke, innerhalb derer keine weniger bedeutenden Ausgaben für die Ausführungszeit anfallen. <br><br>  Als nächstes wird der Hauptinhalt einer der möglichen Lösungen für die Implementierung integrierter Laufzeitsteuerungswerkzeuge betrachtet, die darauf abzielen, detaillierte Informationen über Zeitmetriken von gesteuerten Softwareblöcken mit anschließender Erstellung von Berichten für Entwickler zu extrahieren und zu sammeln. <br><br><h3>  Methoden zum Abrufen von Laufzeitdaten </h3><br>  Die Funktionalität jeder Softwareanwendung kann als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">abstrakte Maschine</a> mit einer endlichen Menge eindeutiger <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zustände</a> <b><i>{St}</i></b> und Übergängen <b><i>{Tr}</i></b> zwischen ihnen interpretiert werden. <br><br>  Im Rahmen dieses Ansatzes sollte jeder Ausführungsfluss in der Anwendung als eine geordnete Folge ihrer Zustände und Übergänge zwischen ihnen interpretiert werden.  In diesem Fall wird die Schätzung der Ausführungszeitkosten durchgeführt, indem die Zeitmetriken über den gesamten Satz übergebener Zustände summiert werden, wobei die Kosten für Übergänge von einem Zustand in einen anderen ignoriert werden - als vernachlässigbare Werte. <br><br>  Das Extrahieren und Sammeln von Daten zur Anwendungsausführungszeit an den angegebenen Kontrollpunkten ist die Hauptaufgabe, die von den nachstehend beschriebenen integrierten Steuerungswerkzeugen gelöst wird. <br><br>  Für jeden im Quellcode durch Platzieren deklarierten Haltepunkt <br>  <b>PROFILE_ENTRY</b> C ++ - Makro, die Anzahl seiner Durchläufe während der Anwendungsausführung sowie die Zeitmetrik - die Gesamtzeit, in der sich die Anwendung im Zustand befand, ab dem Zeitpunkt, an dem der Prüfpunkt an die nächste Ebene der Programmhierarchie übergeben wurde (einschließlich Block, Klassenmethode, Funktion usw.). wie in der folgenden Abbildung dargestellt. <br><br>  Die Steuerung der Kontrollpunkte (Erstregistrierung und Berechnung ihrer <b><i>Zeitmetriken</i></b> ) erfolgt durch das Objekt <b><i>'timeManager'</i></b> , das in einer einzelnen Instanz erstellt wird.  Jedes Ereignis beim Übergeben des Prüfpunkts wird durch das Objekt <b><i>'timeManager' festgelegt</i></b> und während des ersten Durchlaufs von ihm als Observables als <b><i>'registerEntry' registriert</i></b> . <br><br>  Bei jedem Durchlaufen des Kontrollpunkts wird ein <b><i>timerObject-</i></b> Objekt <b><i>erstellt</i></b> , das den Zeitpunkt seiner Erstellung <b><i>festlegt</i></b> .  Die Ausführungszeit wird am Prüfpunkt festgelegt, wenn die Anwendung die aktuelle Ebene der Softwarehierarchie verlässt.  In diesem Moment wird das timerObject des Objekts automatisch zerstört, was mit der Berechnung seiner "Lebensdauer" T <b><i>einhergeht. Infolgedessen</i></b> erhöht der <b><i>timeManager</i></b> die <b><i>Häufigkeit</i></b> , mit der der Prüfpunkt passiert, und die Zeit, die <b><i>T.</i></b> in ihm verbringt <b><i>.</i></b>  Für alle festgelegten Kontrollpunkte sammelt <b><i>timeManager</i></b> Daten mit der anschließenden Veröffentlichung eines Berichts, wenn die Anwendung beendet wird. <br><br><img src="https://habrastorage.org/webt/eq/ze/7e/eqze7eww_flgezgdi08ncstlz7m.jpeg"><br><br>  Unten finden Sie den C ++ - Quellcode, der die integrierten Tools zur Steuerung der Ausführungszeit der Anwendung implementiert. <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     #include &lt;vector&gt; #include &lt;map&gt; #include &lt;algorithm&gt; #include &lt;stdio.h&gt; #include &lt;time.h&gt; typedef unsigned long LONGEST_INT; // ,    //     //     //  ( )   // ()   //    #define PROFILER_ENABLED // CREATE_PROFILER  timeManager , //     // 'main()' #ifdef PROFILER_ENABLED #define CREATE_PROFILER timeManager tManager; #else #define CREATE_PROFILER //   CREATE_PROFILER. #endif //INITIALIZE_PROFILER    timeManager  //       //   'main()' #ifdef PROFILER_ENABLED #define INITIALIZE_PROFILER bool timeManager::object = false;\ std::vector&lt;registerEntry&gt; timeManager::entries; #else #define INITIALIZE_PROFILER //   INITIALIZE_PROFILER. #endif //DELAY(_SECONDS)   '_SECONDS' . //    ,  //     //  #ifdef PROFILER_ENABLED #define DELAY(_SECONDS) {clock_t clk_wait=clock()+((double)_ARG)*CLOCKS_PER_SEC;\ while(clock()&lt;clk_wait) {}} #else #define DELAY(_SECONDS) //    DELAY. #endif //     , //     UNIX  WINDOWS //      #ifdef PROFILER_ENABLED #define MERGE2(x,y) x##y #define MERGE1(_X,_Y) MERGE2(_X,_Y) #if WIN32 #define UNIQUENAME prefix,postfix) MERGE1(prefix,postfix) #else #define UNIQUENAME(prefix,postfix) MERGE2(prefix,postfix) #endif #define GEN_SRC(_ARG1,_ARG2) static int UNIQUENAME(ind,_ARG2)=-1;\ if(UNIQUENAME(ind,_ARG2)&lt;0)\ UNIQUENAME(ind,_ARG2)=timeManager::add_entry(_ARG1);\ timeManager::incr_counter(UNIQUENAME(ind,_ARG2));\ timerObject UNIQUENAME(tm,_ARG2)(UNIQUENAME(ind,_ARG2)); //PROFILE_ENTRY      #ifdef PROFILER_ENABLED #if WIN32 #define PROFILE_ENTRY(_TITLE) GEN_SRC(_TITLE,__COUNTER__) #else #define PROFILE_ENTRY(_TITLE) GEN_SRC(_TITLE,__LINE__) #endif #else #define PROFILE_ENTRY(_TITLE) //    PROFILE_ENTRY. #endif //        //    //    ,   timeManager struct registerEntry { //     (  ) std::string entry_name; //     //     LONGEST_INT covers_counter; //      //     (ticks) LONGEST_INT elapsed_time; // registerEntry(const char * title):entry_name(title), covers_counter(0), elapsed_time(0) {} }; //     class timerObject { //   ,     int index; //    clock_t start_time; public: //       timerObject(int ind):index(ind),start_time(clock()) {} //    “ ”  //       //   ~timerObject(void) { timeManager::incr_timer(index,(LONGEST_INT)(clock()-start_time)); } }; //     class timeManager { private: //     static std::vector&lt;registerEntry&gt; entries; // ,     //    static bool object; public: //     //  ,    //     static int add_entry(const char * title) { entries.push_back(registerEntry(title)); return (((int)entries.size())-1); } //       //      static void incr_counter(int profile_entry_id) { entries[profile_entry_id].covers_counter++; } //  'value'     //      static void incr_timer(int profile_entry_id, LONGEST_INT value) { entries[profile_entry_id].elapsed_time += val; } //       //   static void report(void); //  timeManager(void) { if(!object) object = true; else { printf("\n&lt;&lt;&gt;&gt;:    'timeManager' .\n"); throw; } } //        //   virtual ~timeManager(void) {report();} }; //      bool cmp_entries(registerEntry &amp; first, registerEntry &amp; second) { if(first.entry_name.compare(second.entry_name)&gt;0) return false; return true; } //      //    void timeManager::report(void) { const std::string bar(72,'*'); //        const char * REPORT_FILE = "C:\\tmProfile.txt"; FILE * fp = fopen(REPORT_FILE,"w"); if(!fp) { printf("\n&lt;&lt;&gt;&gt;:       (%s)",REPORT_FILE); return; } fprintf(fp,"\n#%s",bar.c_str()); fprintf(fp,"\n#\n#      "); fprintf(fp,"\n#\n#%s",bar.c_str()); fprintf(fp,"\n#\n# %-35s %-15s %-20s", " ",""," ()"); fprintf(fp,"\n# %-35s %-15s %-20s", "------------------","-------------","---------------\n#"); //         std::sort(entries.begin(),entries.end(),cmp_entries); for(unsigned jj = 0; jj&lt; entries.size(); jj++) { fprintf(fp,"\n# %-35s %-16d", entries[jj].entry_name.c_str(), entries[jj].covers_counter); if(entries[jj].covers_counter == 0) fprintf(fp,"%-20d",0); else fprintf(fp,"%-20.0f", static_cast&lt;double&gt;(entries[jj].elapsed_time)/ static_cast&lt;double&gt;(CLOCKS_PER_SEC)); } if(entries.size() == 0) fprintf(fp,"\n# No covered profile entries found\n"); fprintf(fp,"\n#\n#%s\n",bar.c_str()); fclose(fp); }</span></span></code> </pre> <br>  Die Struktur der Demoanwendung ist unten dargestellt und zeigt die Verwendung der integrierten Laufzeitsteuerungstools als Beispiel sowie eine Tabelle der erzielten Ergebnisse (Einzelheiten siehe <b><i>Anhang 1. Quellcode der Demoanwendung</i></b> ). <br><br><img src="https://habrastorage.org/webt/bg/ds/cg/bgdscgwtg66sw9cdwo1kacjeryy.jpeg"><br><br><img src="https://habrastorage.org/webt/oi/sw/kk/oiswkkxofhegr5uokrld8ttpdmg.jpeg"><br><br>  Abschnitt <b><i>Nachtrag 2. Der Quellcode der Mittel der eingebauten Steuerung der Ausführungszeit der C # -Anwendung</i></b> zeigt eine ähnliche Implementierung der Mittel der eingebauten Steuerung in C #. <br><br>  Der Autor verwendet Paare von <b>TimeWatcher.StartWatch ()</b> und <b>TimeWatcher.StopWatch ()</b> , um die Ausführungszeit mühsamer (aus rechnerischer Sicht) Methoden und Verfahren im Rahmen des von <b>EREMEX</b> entwickelten Software-Produkts <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Delta Design</b></a> - einem computergestützten Konstruktionssystem für elektronische Geräte - zu <b>analysieren</b> . <br><br>  Unten finden Sie ein Beispiel für einen kurzen Bericht über Zeitmetriken einer der Funktionen des genannten Produkts. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5_/ka/r-/5_kar-gqi4xmd2p9bfrtlqae3vc.jpeg"></div><br><h3>  Kurze Schlussfolgerungen </h3><br>  Die beschriebenen Tools können verwendet werden, um Daten zur Ausführungszeit von Anwendungen in verschiedenen Teilen des Programmcodes zu erfassen. Insbesondere ermöglichen sie Folgendes: <br><br><ul><li>  Sammeln und Sammeln von Daten zu Zeitmetriken von Ausführungsthreads in der Anwendung; </li><li>  Schätzungen der Ausführungszeit von Programmcode durchführen, die auf elementare Sprachkonstrukte genau sind; </li><li>  Verwalten Sie das Volumen der extrahierten Daten, indem Sie die integrierten Steuerungswerkzeuge in den entsprechenden Abschnitten der Anwendungsausführungsabläufe ein- und ausschalten </li><li>  Entwicklung und Anwendung von Regressionstests, die die Stabilität (und die Verschlechterung) von Anwendungszeitmetriken überwachen. </li></ul><br>  Zusammenfassend ist anzumerken, dass außerhalb des Umfangs dieser Veröffentlichung Fragen zur Verwendung der beschriebenen integrierten Steuerungswerkzeuge im Zusammenhang mit <i>Multithreading-</i> Anwendungen <i>auftraten</i> und keine Analyse der Genauigkeit der erhaltenen Daten anhand von Zeitmetriken in irgendeiner Form vorgelegt wurde.  Letzteres ist darauf zurückzuführen, dass in der Praxis bei der Ermittlung der Ursachen für die vorübergehende Verschlechterung einer <font color="blue"><font color="black">Anwendung in</font></font> erster Linie die Daten zur <font color="blue"><b><i>relativen Verteilung</i></b> <font color="black">der Ausführungszeitkosten zwischen den Softwarekomponenten der Anwendung</font></font> relevant sind <font color="blue"><font color="black">.</font></font>  <font color="blue"><font color="black">In diesem Zusammenhang treten Fragen nach der Genauigkeit der erhaltenen Daten in den Hintergrund.</font></font> <font color="blue"><font color="black"><br><br></font></font> <h3>  <font color="blue"><font color="black">Anhang 1. Quellcode für die Demo-Anwendung</font></font> </h3> <font color="blue"><font color="black"><br></font></font> <pre> <font color="blue"><font color="black"><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">INITIALIZE_PROFILER </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//create profile manager CREATE_PROFILER PROFILE_ENTRY("1 Main context") f11(); for(unsigned jj = 0;jj&lt;4;jj++) f12(); f13 (); f14 (); f15 (); f16 (); f17(); return 0; } void f11(void)///////////////////////////////////////// { PROFILE_ENTRY ("2 f11()........................") for (unsigned jj = 0; jj&lt;5; jj++) { PROFILE_ENTRY ("2 f11()::for(...){...} iterat-ing") DELAY(1) } //profile entry for repeating int nn(3); while(nn &gt; 0) { PROFILE_ENTRY("2 f11()::while(...){...} iterat-ing") DELAY(1) nn--; } } void f12(void)///////////////////////////////////////// { PROFILE_ENTRY("3 f12()........................") goto ending; { PROFILE_ENTRY("3 f12()::ignored code part") DELAY(1) } ending: PROFILE_ENTRY("3 f12()::ending code part") DELAY(2) } void f13(void) ///////////////////////////////////////// { PROFILE_ENTRY("4 f13()........................") srand((unsigned) time(NULL)/2); for(unsigned jj = 0; jj &lt; 200; jj++) { if(rand()%2 == 0) { PROFILE_ENTRY("4 f13()::even branch") DELAY(0.01) } else { PROFILE_ENTRY("4 f13()::od branch") DELAY(0.02) } } } void f14(void)///////////////////////////////////////// { static int depth = 10; { PROFILE_ENTRY("5 f14() recursion") depth--; DELAY(0.5) if(depth == 0) return; } f14(); } void f15(void)///////////////////////////////////////// { PROFILE_ENTRY("7 f15()........................") for(unsigned jj = 0; jj &lt; 10; jj++) { demo_class obj; obj.method1(); obj.method2(); obj.method3(); } } void f16(void)///////////////////////////////////////// { PROFILE_ENTRY("8 f16()........................") try { for(int jj = 10; jj &gt;= 0; jj--) { PROFILE_ENTRY("81 f16() try clause") DELAY(1) int rr = 200/jj; } } catch(...) { PROFILE_ENTRY("81 f16() catch clause") DELAY(2) return; } } void f17(void)///////////////////////////////////////// { PROFILE_ENTRY("9 f17()........................") f21(); f22(); f23(); f24(); f25(); } void f22(void)///////////////////////////////////////// { PROFILE_ENTRY("91 f22()........................") DELAY(1) f221(); f222(); f223(); } void f23(void) {PROFILE_ENTRY("91 f23()") DELAY(1) } void f24(void) {PROFILE_ENTRY("91 f24()") DELAY(1) } void f25(void) {PROFILE_ENTRY("91 f25()") DELAY(1) } void f221(void) {PROFILE_ENTRY("91 f221()") DELAY(3) } void f222(void) {PROFILE_ENTRY("91 f222()") DELAY(4) } void f223(void) {PROFILE_ENTRY("91 f223()") DELAY(5) }</span></span></code></font></font> </pre> <font color="blue"><font color="black"><br></font></font> <h3>  <font color="blue"><font color="black">Ergänzung 2. Quellcode der integrierten C # -Anwendungen zur Laufzeitsteuerung</font></font> </h3> <font color="blue"><font color="black"><br></font></font> <pre> <font color="blue"><font color="black"><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// &lt;summary&gt; ///             /// &lt;/summary&gt; public class TimeWatcher { /// &lt;summary&gt; ///            /// &lt;/summary&gt; internal class TimeEntry { //     public Stopwatch timeWatch; //       public long elapsedTime; //  public TimeEntry() { timeWatch = new Stopwatch(); elapsedTime = 0; } } //       //    private static bool enableTimeWatcher = false; //            private static Dictionary&lt;string, TimeEntry&gt; entryDictionary = new Dictionary&lt;string, TimeEntry&gt;(); //         public static void StartWatch(string postfix = "") { if (!enableTimeWatcher) return; string entryName = GetCurrentMethod(); if (postfix != "") { entryName += postfix; } //    ,      //         if (!entryDictionary.ContainsKey(entryName)) { entryDictionary.Add(entryName, new TimeEntry()); entryDictionary[entryName].timeWatch.Start(); } else { if (entryDictionary[entryName].timeWatch.IsRunning) { throw new System.InvalidOperationException(":    '" + entryName + "'  ."); } else entryDictionary[entryName].timeWatch.Restart(); } } //        public static void StopWatch(string postfix = "") { if (!enableTimeWatcher) return; string entryName = GetCurrentMethod(); if (postfix != "") { entryName += postfix; } //    ,      if (!entryDictionary.ContainsKey(entryName)) { throw new System.InvalidOperationException(":     -    '" + entryName + "'."); } if (!entryDictionary[entryName].timeWatch.IsRunning) { throw new System.InvalidOperationException ":        '" + entryName + "'."); } entryDictionary[entryName].timeWatch.Stop(); entryDictionary[entryName].elapsedTime += entryDictionary[entryName].timeWatch.ElapsedMilliseconds; } //        //     public static void TimeWatchReport() { const string bar = "============================================="; if (!enableTimeWatcher) return; Console.WriteLine(""); Console.WriteLine(bar); Console.WriteLine("     (): "); Console.WriteLine(""); int maxLen = 0; foreach (var timeEntry in entryDictionary) { if(timeEntry.Key.Length &gt; maxLen) maxLen = timeEntry.Key.Length; } maxLen++; string strFormat = "{0," + maxLen + "} ... {1,-10}"; foreach (var timeEntry in entryDictionary) { Console.WriteLine(strFormat, timeEntry.Key, timeEntry.Value.elapsedTime); } Console.WriteLine(bar); Console.WriteLine(""); entryDictionary.Clear(); enableTimeWatcher = false; } //          //      /tmw    //   public static void InitTimeWatch() { if (Environment.GetCommandLineArgs().Any(v =&gt; v == "/tmw")) { if (entryDictionary.Count &gt; 0) { TimeWatchReport(); } entryDictionary.Clear(); enableTimeWatcher = true; } } //        private static string GetCurrentMethod() { StackTrace st = new StackTrace(); StackFrame sf = st.GetFrame(2); return sf.GetMethod().Name; } }</span></span></code></font></font> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468403/">https://habr.com/ru/post/de468403/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468393/index.html">Mit einem guten Mikrocontroller vergeht die Zeit schnell oder mit einem Wochenendoszilloskop</a></li>
<li><a href="../de468395/index.html">Cloud-Sicherheitsüberwachung. Teil 2</a></li>
<li><a href="../de468397/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 477 (09/03/2019 - 09.09.2019)</a></li>
<li><a href="../de468399/index.html">C / C ++. Verwendung eingebetteter Anwendungsressourcen bei der Arbeit in GCC unter Linux</a></li>
<li><a href="../de468401/index.html">Sichere Möglichkeit zum Austausch von JWT in ASP.NET Core + SPA</a></li>
<li><a href="../de468405/index.html">Zwei Browser betreten irgendwie die Bildlaufleiste ...</a></li>
<li><a href="../de468407/index.html">5G - eine Technologie, die das Web wahrscheinlich verlangsamen wird</a></li>
<li><a href="../de468409/index.html">Servicemitarbeiter im Slack Client: On Download-Beschleunigung und Offline-Modus</a></li>
<li><a href="../de468411/index.html">Eine Geschichte über das Lösen des Leistungsproblems von Moment.j.</a></li>
<li><a href="../de468413/index.html">Beschleunigung instagram.com. Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>