<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîí ‚úãüèø üòÄ Prise en charge des instructions sp√©cifiques au mat√©riel dans .NET Core (d√©sormais non seulement SIMD) üßóüèø üë∏üèø üåè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 


 Il y a quelques ann√©es, nous avons d√©cid√© qu'il √©tait temps de prendre en charge le code SIMD dans .NET . Nous avons introduit l'espa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prise en charge des instructions sp√©cifiques au mat√©riel dans .NET Core (d√©sormais non seulement SIMD)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/467663/"><h2 id="vvedenie">  Pr√©sentation </h2><br><p> Il y a quelques ann√©es, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nous avons d√©cid√© qu'il √©tait temps de prendre en charge le code SIMD dans .NET</a> .  Nous avons introduit l'espace de noms <code>System.Numerics</code> avec les types <code>Vector2</code> , <code>Vector3</code> , <code>Vector4</code> et <code>Vector&lt;T&gt;</code> .  Ces types repr√©sentent une API √† usage g√©n√©ral pour cr√©er, acc√©der et manipuler des instructions vectorielles dans la mesure du possible.  Ils offrent √©galement une compatibilit√© logicielle dans les cas o√π le mat√©riel ne prend pas en charge les instructions appropri√©es.  Cela a permis, avec un refactoring minimal, de vectoriser un certain nombre d'algorithmes.  Quoi qu'il en soit, la g√©n√©ralit√© de cette approche rend son application difficile afin de tirer pleinement parti de toutes les instructions vectorielles disponibles, sur du mat√©riel moderne.  De plus, le mat√©riel moderne fournit un certain nombre d'instructions sp√©cialis√©es, non vectorielles, qui peuvent am√©liorer consid√©rablement les performances.  Dans cet article, je vais vous expliquer comment nous avons contourn√© ces limitations dans .NET Core 3.0. </p><br><p><img src="https://habrastorage.org/webt/4d/mx/lt/4dmxlt8xgnpgncvellsujvoe_rk.jpeg"><br>  <strong>Remarque: Il</strong> <em>n'y a pas encore de terme √©tabli pour la traduction <strong>Intrisics</strong> .</em>  <em>√Ä la fin de l'article, il y a un vote pour l'option de traduction.</em>  <em>Si nous choisissons une bonne option, nous changerons l'article</em> </p><a name="habracut"></a><br><h2 id="chto-takoe-vstroennye-funkcii">  Quelles sont les fonctions int√©gr√©es </h2><br><p>  Dans .NET Core 3.0, nous avons ajout√© de nouvelles fonctionnalit√©s appel√©es fonctions <em>int√©gr√©es sp√©cifiques au mat√©riel</em> (loin WF).  Cette <em>fonctionnalit√©</em> donne acc√®s √† de nombreuses instructions mat√©rielles sp√©cifiques qui ne peuvent pas √™tre simplement repr√©sent√©es par des m√©canismes plus g√©n√©raux.  Ils diff√®rent des instructions SIMD existantes en ce qu'ils n'ont pas un usage g√©n√©ral (les nouveaux <em>WF</em> ne sont pas multiplateformes et leur architecture ne fournit pas de compatibilit√© logicielle).  Au lieu de cela, ils fournissent directement des fonctionnalit√©s sp√©cifiques √† la plateforme et au mat√©riel pour les d√©veloppeurs .NET.  Les fonctions SIMD existantes, par exemple multiplateforme, offrent une compatibilit√© logicielle et sont l√©g√®rement abstraites du mat√©riel sous-jacent.  Cette abstraction peut √™tre co√ªteuse, en plus, elle peut emp√™cher la divulgation de certaines fonctionnalit√©s (lorsque, par exemple, la fonctionnalit√© n'existe pas ou est difficile √† √©muler sur toutes les plates-formes cibles). </p><br><p>  Les nouvelles <em>fonctions int√©gr√©es</em> et les types pris en charge se trouvent sous l' <code>System.Runtime.Intrinsics</code> .  Pour .NET Core 3.0, il existe actuellement un <code>System.Runtime.Intrinsics.X86</code> .  Nous travaillons sur la prise en charge <em>des fonctions int√©gr√©es</em> pour d'autres plates-formes telles que <code>System.Runtime.Intrinsics.Arm</code> . </p><br><p>  Dans les espaces de noms sp√©cifiques √† la plate-forme, les <em>WF</em> sont regroup√©s en classes qui repr√©sentent des groupes d'instructions mat√©rielles int√©gr√©es logiquement (souvent appel√©es architecture de jeu d'instructions (ISA)).  Chaque classe fournit une propri√©t√© <code>IsSupported</code> indique si le mat√©riel sur lequel le code s'ex√©cute prend en charge cet ensemble d'instructions.  En outre, chacune de ces classes contient un ensemble de m√©thodes mapp√©es √† un ensemble d'instructions correspondant.  Parfois, il existe une sous-classe suppl√©mentaire qui correspond √† une partie du m√™me jeu d'instructions, qui peut √™tre limit√©e (prise en charge) par du mat√©riel sp√©cifique.  Par exemple, la classe <code>Lzcnt</code> donne acc√®s aux <em>instructions pour compter les z√©ros non</em> <code>Lzcnt</code> .  Il poss√®de une sous-classe appel√©e <code>X64</code> , qui contient la forme de ces instructions utilis√©es uniquement sur les machines √† architecture 64 bits. </p><br><p>  Certaines de ces classes sont naturellement de nature hi√©rarchique.  Par exemple, si <code>Lzcnt.X64.IsSupported</code> renvoie true, alors <code>Lzcnt.IsSupported</code> doit √©galement renvoyer true, car il s'agit d'une sous-classe explicite.  Ou, par exemple, si <code>Sse2.IsSupported</code> renvoie true, alors <code>Sse.IsSupported</code> doit retourner true, car <code>Sse2</code> h√©rite explicitement de <code>Sse</code> .  Cependant, il convient de noter que la similitude des noms de classe n'est pas un indicateur de leur appartenance √† la m√™me hi√©rarchie d'h√©ritage.  Par exemple, <code>Bmi2</code> pas h√©rit√© de <code>Bmi1</code> , donc les valeurs renvoy√©es par <code>IsSupported</code> pour ces deux ensembles d'instructions seront diff√©rentes.  Le principe fondamental du d√©veloppement de ces classes √©tait la pr√©sentation explicite des sp√©cifications ISA.  SSE2 n√©cessite la prise en charge de SSE1, de sorte que les classes qui les repr√©sentent sont li√©es par h√©ritage.  Dans le m√™me temps, BMI2 ne n√©cessite pas de prise en charge pour BMI1, nous n'avons donc pas utilis√© d'h√©ritage.  Ce qui suit est un exemple de l'API ci-dessus. </p><br><pre> <code class="plaintext hljs">namespace System.Runtime.Intrinsics.X86 { public abstract class Sse { public static bool IsSupported { get; } public static Vector128&lt;float&gt; Add(Vector128&lt;float&gt; left, Vector128&lt;float&gt; right); // Additional APIs public abstract class X64 { public static bool IsSupported { get; } public static long ConvertToInt64(Vector128&lt;float&gt; value); // Additional APIs } } public abstract class Sse2 : Sse { public static new bool IsSupported { get; } public static Vector128&lt;byte&gt; Add(Vector128&lt;byte&gt; left, Vector128&lt;byte&gt; right); // Additional APIs public new abstract class X64 : Sse.X64 { public static bool IsSupported { get; } public static long ConvertToInt64(Vector128&lt;double&gt; value); // Additional APIs } } }</code> </pre> <br><p>  Vous pouvez en voir plus dans le code source sur les liens suivants <a href="">source.dot.net ou dotnet / coreclr sur GitHub</a> </p><br><p>  <code>IsSupported</code> v√©rifications <code>IsSupported</code> trait√©es par le compilateur JIT en tant que constantes d'ex√©cution (lorsque l'optimisation est activ√©e), vous n'avez donc pas besoin de compilation crois√©e pour prendre en charge plusieurs ISA, plates-formes ou architectures.  Au lieu de cela, il vous suffit d'√©crire le code √† l'aide d'expressions <code>if</code> , √† la suite de quoi les branches de code inutilis√©es (c'est-√†-dire les branches qui ne sont pas accessibles en raison de la valeur de la variable dans l'instruction conditionnelle) seront ignor√©es lors de la g√©n√©ration du code natif. </p><br><p>  Il est important que la v√©rification du <code>IsSupported</code> correspondant pr√©c√®de l'utilisation des commandes mat√©rielles int√©gr√©es.  S'il n'y a pas une telle v√©rification, le code qui utilise des commandes sp√©cifiques √† la plate-forme s'ex√©cutant sur des plates-formes / architectures o√π ces commandes ne sont pas prises en charge l√®vera une exception d'ex√©cution <code>PlatformNotSupportedException</code> . </p><br><h2 id="kakie-preimuschestva-oni-dayut">  Quels avantages offrent-ils? </h2><br><p>  Bien s√ªr, les <em>fonctions int√©gr√©es sp√©cifiques au mat√©riel</em> ne <em>sont</em> pas pour tout le monde, mais elles peuvent √™tre utilis√©es pour am√©liorer les performances des op√©rations charg√©es de calculs.  <code>CoreFX</code> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>ML.NET</code></a> utilisent ces m√©thodes pour acc√©l√©rer des op√©rations telles que la copie en m√©moire, la recherche de l'index d'un √©l√©ment dans un tableau ou une cha√Æne, le redimensionnement d'une image ou le travail avec des vecteurs / matrices / tenseurs.  La vectorisation manuelle d'un code qui s'est av√©r√© √™tre un goulot d'√©tranglement peut √©galement √™tre plus simple qu'il n'y para√Æt.  La vectorisation du code, en effet, consiste √† effectuer plusieurs op√©rations √† la fois, en g√©n√©ral, √† l'aide d'instructions SIMD (un flux d'instructions, plusieurs flux de donn√©es). </p><br><p>  Avant de d√©cider de vectoriser du code, vous devez effectuer un profilage pour vous assurer que ce code fait vraiment partie du ¬´point chaud¬ª (et, par cons√©quent, votre optimisation augmentera consid√©rablement les performances).  Il est √©galement important d'effectuer un profilage √† chaque √©tape de la vectorisation, car la vectorisation de tout le code n'entra√Æne pas une productivit√© accrue. </p><br><h2 id="vektorizaciya-prostogo-algoritma">  Vectorisation d'un algorithme simple </h2><br><p>  Pour illustrer l'utilisation des <em>fonctions int√©gr√©es,</em> nous prenons l'algorithme pour additionner tous les √©l√©ments d'un tableau ou d'une plage.  Ce type de code est un candidat id√©al pour la vectorisation, car  √† chaque it√©ration, la m√™me op√©ration triviale est effectu√©e. </p><br><p>  Un exemple d'impl√©mentation d'un tel algorithme peut ressembler √† ceci: </p><br><pre> <code class="plaintext hljs">public int Sum(ReadOnlySpan&lt;int&gt; source) { int result = 0; for (int i = 0; i &lt; source.Length; i++) { result += source[i]; } return result; }</code> </pre> <br><p>  Ce code est assez simple et direct, mais en m√™me temps assez lent pour les donn√©es d'entr√©e volumineuses, comme  ne fait qu'une seule op√©ration triviale par it√©ration. </p><br><pre> <code class="plaintext hljs">BenchmarkDotNet=v0.11.5, OS=Windows 10.0.18362 AMD Ryzen 7 1800X, 1 CPU, 16 logical and 8 physical cores .NET Core SDK=3.0.100-preview9-013775 [Host] : .NET Core 3.0.0-preview9-19410-10 (CoreCLR 4.700.19.40902, CoreFX 4.700.19.40917), 64bit RyuJIT [AttachedDebugger] DefaultJob : .NET Core 3.0.0-preview9-19410-10 (CoreCLR 4.700.19.40902, CoreFX 4.700.19.40917), 64bit RyuJIT</code> </pre> <br><div class="scrollable-table"><table><thead><tr><th>  La m√©thode </th><th>  Compter </th><th>  Moyenne </th><th>  Erreur </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Somme </td><td>  1 </td><td>  2,477 ns </td><td>  0,0192 ns </td><td>  0,0179 ns </td></tr><tr><td>  Somme </td><td>  2 </td><td>  2,164 ns </td><td>  0,0265 ns </td><td>  0,0235 ns </td></tr><tr><td>  Somme </td><td>  4 </td><td>  3,224 ns </td><td>  0,0302 ns </td><td>  0,0267 ns </td></tr><tr><td>  Somme </td><td>  8 </td><td>  4.347 ns </td><td>  0,0665 ns </td><td>  0,0622 ns </td></tr><tr><td>  Somme </td><td>  16 </td><td>  8.444 ns </td><td>  0,2042 ns </td><td>  0,3734 ns </td></tr><tr><td>  Somme </td><td>  32 </td><td>  13,963 ns </td><td>  0,2182 ns </td><td>  0,2041 ns </td></tr><tr><td>  Somme </td><td>  64 </td><td>  50,374 ns </td><td>  0,2995 ns </td><td>  0,2620 ns </td></tr><tr><td>  Somme </td><td>  128 </td><td>  60.139 ns </td><td>  0,3890 ns </td><td>  0,3639 ns </td></tr><tr><td>  Somme </td><td>  256 </td><td>  106,416 ns </td><td>  0,6404 ns </td><td>  0,5990 ns </td></tr><tr><td>  Somme </td><td>  512 </td><td>  291.450 ns </td><td>  3,5148 ns </td><td>  3,2878 ns </td></tr><tr><td>  Somme </td><td>  1024 </td><td>  574.243 ns </td><td>  9.5851 ns </td><td>  8.4970 ns </td></tr><tr><td>  Somme </td><td>  2048 </td><td>  1 137,819 ns </td><td>  5,9363 ns </td><td>  5,5529 ns </td></tr><tr><td>  Somme </td><td>  4096 </td><td>  2 228,341 ns </td><td>  22.8882 ns </td><td>  21.4097 ns </td></tr><tr><td>  Somme </td><td>  8192 </td><td>  2 973,040 ns </td><td>  14.2863 ns </td><td>  12,6644 ns </td></tr><tr><td>  Somme </td><td>  16384 </td><td>  5 883,504 ns </td><td>  15,9619 ns </td><td>  14.9308 ns </td></tr><tr><td>  Somme </td><td>  32768 </td><td>  11 699,237 ns </td><td>  104,0970 ns </td><td>  97,3724 ns </td></tr></tbody></table></div><br><h2 id="povyshenie-proizvoditelnosti-za-schet-razvertyvaniya-ciklov">  Augmentez la productivit√© gr√¢ce aux cycles de d√©ploiement </h2><br><p>  Les processeurs modernes ont diverses options pour am√©liorer les performances du code.  Pour les applications monothread, une de ces options consiste √† effectuer plusieurs op√©rations primitives en un seul cycle de processeur. </p><br><p>  La plupart des processeurs modernes peuvent effectuer quatre op√©rations d'addition en un seul cycle d'horloge (dans des conditions optimales), ce qui permet, avec la ¬´mise en page¬ª correcte du code, d'am√©liorer parfois les performances, m√™me dans une impl√©mentation √† un seul thread. </p><br><p>  Bien que JIT puisse effectuer le d√©roulement de boucle seul, JIT est prudent dans ce type de d√©cision, en raison de la taille du code g√©n√©r√©.  Par cons√©quent, il peut √™tre avantageux de d√©ployer une boucle, en code, manuellement. </p><br><p>  Vous pouvez d√©velopper la boucle dans le code ci-dessus comme suit: </p><br><pre> <code class="plaintext hljs">public unsafe int SumUnrolled(ReadOnlySpan&lt;int&gt; source) { int result = 0; int i = 0; int lastBlockIndex = source.Length - (source.Length % 4); // Pin source so we can elide the bounds checks fixed (int* pSource = source) { while (i &lt; lastBlockIndex) { result += pSource[i + 0]; result += pSource[i + 1]; result += pSource[i + 2]; result += pSource[i + 3]; i += 4; } while (i &lt; source.Length) { result += pSource[i]; i += 1; } } return result; }</code> </pre> <br><p>  Ce code est un peu plus compliqu√©, mais il fait un meilleur usage des fonctionnalit√©s mat√©rielles. </p><br><p>  Pour les tr√®s petites boucles, ce code s'ex√©cute un peu plus lentement.  Mais cette tendance est d√©j√† en train de changer pour les donn√©es d'entr√©e de huit √©l√©ments, apr√®s quoi la vitesse d'ex√©cution commence √† augmenter (le temps d'ex√©cution du code optimis√©, pour 32 mille √©l√©ments, est 26% inf√©rieur √† celui de la version originale).  Il convient de noter qu'une telle optimisation n'augmente pas toujours la productivit√©.  Par exemple, lorsque vous travaillez avec des collections avec des √©l√©ments de type <code>float</code> version "d√©ploy√©e" de l'algorithme a presque la m√™me vitesse que celle d'origine.  Par cons√©quent, il est tr√®s important d'effectuer un profilage. </p><br><div class="scrollable-table"><table><thead><tr><th>  La m√©thode </th><th>  Compter </th><th>  Moyenne </th><th>  Erreur </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Sumunrolled </td><td>  1 </td><td>  2.922 ns </td><td>  0,0651 ns </td><td>  0,0609 ns </td></tr><tr><td>  Sumunrolled </td><td>  2 </td><td>  3,576 ns </td><td>  0,0116 ns </td><td>  0,0109 ns </td></tr><tr><td>  Sumunrolled </td><td>  4 </td><td>  3,708 ns </td><td>  0,0157 ns </td><td>  0,0139 ns </td></tr><tr><td>  Sumunrolled </td><td>  8 </td><td>  4.832 ns </td><td>  0,0486 ns </td><td>  0,0454 ns </td></tr><tr><td>  Sumunrolled </td><td>  16 </td><td>  7.490 ns </td><td>  0,1131 ns </td><td>  0,1058 ns </td></tr><tr><td>  Sumunrolled </td><td>  32 </td><td>  11,277 ns </td><td>  0,0910 ns </td><td>  0,0851 ns </td></tr><tr><td>  Sumunrolled </td><td>  64 </td><td>  19,761 ns </td><td>  0.2016 ns </td><td>  0,1888 ns </td></tr><tr><td>  Sumunrolled </td><td>  128 </td><td>  36,639 ns </td><td>  0,3043 ns </td><td>  0,2847 ns </td></tr><tr><td>  Sumunrolled </td><td>  256 </td><td>  77,969 ns </td><td>  0,8409 ns </td><td>  0,7866 ns </td></tr><tr><td>  Sumunrolled </td><td>  512 </td><td>  146,357 ns </td><td>  1,3209 ns </td><td>  1,2356 ns </td></tr><tr><td>  Sumunrolled </td><td>  1024 </td><td>  287,354 ns </td><td>  0,9223 ns </td><td>  0,8627 ns </td></tr><tr><td>  Sumunrolled </td><td>  2048 </td><td>  566,405 ns </td><td>  4,0155 ns </td><td>  3,5596 ns </td></tr><tr><td>  Sumunrolled </td><td>  4096 </td><td>  1 131,016 ns </td><td>  7.3601 ns </td><td>  6,5246 ns </td></tr><tr><td>  Sumunrolled </td><td>  8192 </td><td>  2 259,836 ns </td><td>  8.6539 ns </td><td>  8.0949 ns </td></tr><tr><td>  Sumunrolled </td><td>  16384 </td><td>  4 501,295 ns </td><td>  6,4186 ns </td><td>  6.0040 ns </td></tr><tr><td>  Sumunrolled </td><td>  32768 </td><td>  8 979,690 ns </td><td>  19,5265 ns </td><td>  18.2651 ns </td></tr></tbody></table></div><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4b7/180/775/4b71807758bdae4be2fba1eb6af8360b.png"></p><br><h2 id="povyshenie-proizvoditelnosti-za-schet-vektorizacii-ciklov">  Augmentez la productivit√© gr√¢ce √† la vectorisation de boucle </h2><br><p>  Quoi qu'il en soit, mais nous pouvons encore optimiser l√©g√®rement ce code.  Les instructions SIMD sont une autre option fournie par les processeurs modernes pour am√©liorer les performances.  √Ä l'aide d'une seule instruction, ils vous permettent d'effectuer plusieurs op√©rations en un seul cycle d'horloge.  Cela peut √™tre mieux que le d√©pliage de boucle directe, car, en fait, la m√™me chose se fait, mais avec une plus petite quantit√© de code g√©n√©r√©. </p><br><p>  Pour clarifier, chaque op√©ration d'ajout, dans un cycle d√©ploy√©, prend 4 octets.  Ainsi, nous avons besoin de 16 octets pour 4 op√©rations d'addition sous forme d√©velopp√©e.  Dans le m√™me temps, l'instruction d'addition SIMD effectue √©galement 4 op√©rations d'addition, mais ne prend que 4 octets.  Cela signifie que nous avons moins d'instructions pour le CPU.  De plus, dans le cas d'une instruction SIMD, le CPU peut faire des <em>hypoth√®ses</em> et effectuer des optimisations, mais cela d√©passe le cadre de cet article.  Ce qui est encore mieux, c'est que les processeurs modernes peuvent ex√©cuter plus d'une instruction SIMD √† la fois, c'est-√†-dire que, dans certains cas, vous pouvez appliquer une strat√©gie mixte, en m√™me temps effectuer un balayage de cycle partiel et une vectorisation. </p><br><p>  En g√©n√©ral, vous devez commencer par regarder la classe polyvalente <code>Vector&lt;T&gt;</code> pour vos t√¢ches.  Comme les nouveaux <em>WF</em> , il int√©grera des instructions SIMD, mais en m√™me temps, √©tant donn√© la polyvalence de cette classe, il peut r√©duire le nombre de codage ¬´manuel¬ª. </p><br><p>  Le code pourrait ressembler √† ceci: </p><br><pre> <code class="plaintext hljs">public int SumVectorT(ReadOnlySpan&lt;int&gt; source) { int result = 0; Vector&lt;int&gt; vresult = Vector&lt;int&gt;.Zero; int i = 0; int lastBlockIndex = source.Length - (source.Length % Vector&lt;int&gt;.Count); while (i &lt; lastBlockIndex) { vresult += new Vector&lt;int&gt;(source.Slice(i)); i += Vector&lt;int&gt;.Count; } for (int n = 0; n &lt; Vector&lt;int&gt;.Count; n++) { result += vresult[n]; } while (i &lt; source.Length) { result += source[i]; i += 1; } return result; }</code> </pre> <br><p>  Ce code fonctionne plus rapidement, mais nous sommes oblig√©s de faire r√©f√©rence √† chaque √©l√©ment s√©par√©ment lors du calcul du montant final.  En outre, le <code>Vector&lt;T&gt;</code> n'a pas de taille d√©finie avec pr√©cision et peut varier en fonction de l'√©quipement sur lequel le code s'ex√©cute.  <em>Les fonctions int√©gr√©es sp√©cifiques au mat√©riel</em> fournissent des fonctionnalit√©s suppl√©mentaires qui peuvent l√©g√®rement am√©liorer ce code et le rendre un peu plus rapide (au prix d'une complexit√© de code suppl√©mentaire et d'exigences de maintenance). </p><br><div class="scrollable-table"><table><thead><tr><th>  La m√©thode </th><th>  Compter </th><th>  Moyenne </th><th>  Erreur </th><th>  Stddev </th></tr></thead><tbody><tr><td>  SumVectorT </td><td>  1 </td><td>  4,517 ns </td><td>  0,0752 ns </td><td>  0,0703 ns </td></tr><tr><td>  SumVectorT </td><td>  2 </td><td>  4.853 ns </td><td>  0,0609 ns </td><td>  0,0570 ns </td></tr><tr><td>  SumVectorT </td><td>  4 </td><td>  5,047 ns </td><td>  0,0909 ns </td><td>  0,0850 ns </td></tr><tr><td>  SumVectorT </td><td>  8 </td><td>  5.671 ns </td><td>  0,0251 ns </td><td>  0,0223 ns </td></tr><tr><td>  SumVectorT </td><td>  16 </td><td>  6,579 ns </td><td>  0,0330 ns </td><td>  0,0276 ns </td></tr><tr><td>  SumVectorT </td><td>  32 </td><td>  10,460 ns </td><td>  0,0241 ns </td><td>  0,0226 ns </td></tr><tr><td>  SumVectorT </td><td>  64 </td><td>  17.148 ns </td><td>  0,0407 ns </td><td>  0,0381 ns </td></tr><tr><td>  SumVectorT </td><td>  128 </td><td>  23,239 ns </td><td>  0,0853 ns </td><td>  0,0756 ns </td></tr><tr><td>  SumVectorT </td><td>  256 </td><td>  62,146 ns </td><td>  0,8319 ns </td><td>  0,7778 ns </td></tr><tr><td>  SumVectorT </td><td>  512 </td><td>  114,863 ns </td><td>  0,4175 ns </td><td>  0,3906 ns </td></tr><tr><td>  SumVectorT </td><td>  1024 </td><td>  172,129 ns </td><td>  1,8673 ns </td><td>  1,7467 ns </td></tr><tr><td>  SumVectorT </td><td>  2048 </td><td>  429,722 ns </td><td>  1,0461 ns </td><td>  0,9786 ns </td></tr><tr><td>  SumVectorT </td><td>  4096 </td><td>  654,209 ns </td><td>  3,6215 ns </td><td>  3.0241 ns </td></tr><tr><td>  SumVectorT </td><td>  8192 </td><td>  1 675,046 ns </td><td>  14,5231 ns </td><td>  13,5849 ns </td></tr><tr><td>  SumVectorT </td><td>  16384 </td><td>  2 514,778 ns </td><td>  5.3369 ns </td><td>  4,9921 ns </td></tr><tr><td>  SumVectorT </td><td>  32768 </td><td>  6 689,829 ns </td><td>  13.9947 ns </td><td>  13.0906 ns </td></tr></tbody></table></div><br><p><img src="https://habrastorage.org/getpro/habr/post_images/00e/0be/5d4/00e0be5d469067af095f34beccf8c45c.png"></p><br><p>  <em>REMARQUE</em> Pour cet article, j'ai forc√© la taille <code>Vector&lt;T&gt;</code> √©gale √† 16 octets en utilisant le param√®tre de configuration interne ( <code>COMPlus_SIMD16ByteOnly=1</code> ).  Ce r√©glage a normalis√© les r√©sultats lors de la comparaison de <code>SumVectorT</code> avec <code>SumVectorizedSse</code> , et nous a permis de garder le code simple.  En particulier, il a √©vit√© d'√©crire un saut conditionnel <code>if (Avx2.IsSupported) { }</code> .  Ce code est presque identique au code pour <code>Sse2</code> , mais traite avec <code>Vector256&lt;T&gt;</code> (32 octets) et traite encore plus d'√©l√©ments en une seule it√©ration de la boucle. </p><br><p>  Ainsi, en utilisant les nouvelles <em>fonctions int√©gr√©es</em> , le code peut √™tre r√©√©crit comme suit: </p><br><pre> <code class="plaintext hljs">public int SumVectorized(ReadOnlySpan&lt;int&gt; source) { if (Sse2.IsSupported) { return SumVectorizedSse2(source); } else { return SumVectorT(source); } } public unsafe int SumVectorizedSse2(ReadOnlySpan&lt;int&gt; source) { int result; fixed (int* pSource = source) { Vector128&lt;int&gt; vresult = Vector128&lt;int&gt;.Zero; int i = 0; int lastBlockIndex = source.Length - (source.Length % 4); while (i &lt; lastBlockIndex) { vresult = Sse2.Add(vresult, Sse2.LoadVector128(pSource + i)); i += 4; } if (Ssse3.IsSupported) { vresult = Ssse3.HorizontalAdd(vresult, vresult); vresult = Ssse3.HorizontalAdd(vresult, vresult); } else { vresult = Sse2.Add(vresult, Sse2.Shuffle(vresult, 0x4E)); vresult = Sse2.Add(vresult, Sse2.Shuffle(vresult, 0xB1)); } result = vresult.ToScalar(); while (i &lt; source.Length) { result += pSource[i]; i += 1; } } return result; }</code> </pre> <br><p>  Ce code, encore une fois, est un peu plus compliqu√©, mais il est beaucoup plus rapide pour tout le monde, sauf les plus petits ensembles d'entr√©e.  Pour 32 000 √©l√©ments, ce code s'ex√©cute 75% plus rapidement que le cycle √©tendu et 81% plus rapidement que le code source de l'exemple. </p><br><p>  Vous avez remarqu√© que nous avons r√©dig√© des ch√®ques <code>IsSupported</code> .  Le premier v√©rifie si le mat√©riel actuel prend en charge l'ensemble requis de <em>fonctions int√©gr√©es</em> , sinon, l'optimisation est effectu√©e par une combinaison de balayage et de <code>Vector&lt;T&gt;</code> .  Cette derni√®re option sera s√©lectionn√©e pour les plates-formes comme ARM / ARM64 qui ne prennent pas en charge le jeu d'instructions requis, ou si le jeu a √©t√© d√©sactiv√© pour la plate-forme.  Le deuxi√®me test <code>IsSupported</code> , dans la m√©thode <code>SumVectorizedSse2</code> , est utilis√© pour une optimisation suppl√©mentaire si le mat√©riel prend en charge le <code>Ssse3</code> instructions <code>Ssse3</code> . </p><br><p>  Sinon, la majeure partie de la logique est essentiellement la m√™me que pour la boucle √©tendue.  <code>Vector128&lt;T&gt;</code> est un type de 128 bits contenant des √©l√©ments <code>Vector128&lt;T&gt;.Count</code> .  Dans ce cas, <code>uint</code> , qui est lui-m√™me 32 bits, peut avoir 4 √©l√©ments (128/32), c'est ainsi que nous avons lanc√© la boucle. </p><br><div class="scrollable-table"><table><thead><tr><th>  La m√©thode </th><th>  Compter </th><th>  Moyenne </th><th>  Erreur </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Sumvectoris√© </td><td>  1 </td><td>  4,555 ns </td><td>  0,0192 ns </td><td>  0,0179 ns </td></tr><tr><td>  Sumvectoris√© </td><td>  2 </td><td>  4,848 ns </td><td>  0,0147 ns </td><td>  0,0137 ns </td></tr><tr><td>  Sumvectoris√© </td><td>  4 </td><td>  5.381 ns </td><td>  0,0210 ns </td><td>  0,0186 ns </td></tr><tr><td>  Sumvectoris√© </td><td>  8 </td><td>  4,838 ns </td><td>  0,0209 ns </td><td>  0,0186 ns </td></tr><tr><td>  Sumvectoris√© </td><td>  16 </td><td>  5.107 ns </td><td>  0,0175 ns </td><td>  0,0146 ns </td></tr><tr><td>  Sumvectoris√© </td><td>  32 </td><td>  5.646 ns </td><td>  0,0230 ns </td><td>  0,0204 ns </td></tr><tr><td>  Sumvectoris√© </td><td>  64 </td><td>  6,763 ns </td><td>  0,0338 ns </td><td>  0,0316 ns </td></tr><tr><td>  Sumvectoris√© </td><td>  128 </td><td>  9.308 ns </td><td>  0,1041 ns </td><td>  0,0870 ns </td></tr><tr><td>  Sumvectoris√© </td><td>  256 </td><td>  15,634 ns </td><td>  0,0927 ns </td><td>  0,0821 ns </td></tr><tr><td>  Sumvectoris√© </td><td>  512 </td><td>  34.706 ns </td><td>  0,2851 ns </td><td>  0,2381 ns </td></tr><tr><td>  Sumvectoris√© </td><td>  1024 </td><td>  68.110 ns </td><td>  0,4016 ns </td><td>  0,3756 ns </td></tr><tr><td>  Sumvectoris√© </td><td>  2048 </td><td>  136,533 ns </td><td>  1,3104 ns </td><td>  1,2257 ns </td></tr><tr><td>  Sumvectoris√© </td><td>  4096 </td><td>  277,930 ns </td><td>  0,5913 ns </td><td>  0,5531 ns </td></tr><tr><td>  Sumvectoris√© </td><td>  8192 </td><td>  554,720 ns </td><td>  3,5133 ns </td><td>  3,2864 ns </td></tr><tr><td>  Sumvectoris√© </td><td>  16384 </td><td>  1 110,730 ns </td><td>  3,3043 ns </td><td>  3.0909 ns </td></tr><tr><td>  Sumvectoris√© </td><td>  32768 </td><td>  2 200,996 ns </td><td>  21.0538 ns </td><td>  19,6938 ns </td></tr></tbody></table></div><br><p><img src="https://habrastorage.org/getpro/habr/post_images/311/e70/320/311e7032050337fe946103244e749076.png"></p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Les nouvelles <em>fonctions int√©gr√©es</em> vous permettent de tirer parti des fonctionnalit√©s sp√©cifiques au mat√©riel de la machine sur laquelle vous ex√©cutez le code.  Il existe environ 1 500 API pour X86 et X64 r√©parties sur 15 ensembles, il y en a trop pour les d√©crire dans un seul article.  En profilant le code pour identifier les goulots d'√©tranglement, vous pouvez d√©terminer la partie du code qui b√©n√©ficie de la vectorisation et observer une tr√®s bonne augmentation des performances.  Il existe de nombreux sc√©narios o√π la vectorisation peut √™tre appliqu√©e et le d√©roulement de la boucle n'est que le d√©but. </p><br><p>  Quiconque veut voir plus d'exemples peut rechercher l'utilisation de <em>fonctions int√©gr√©es</em> dans le cadre (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dotnet</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">aspnet</a> ), ou dans d'autres articles de la communaut√©.  Et bien que les <em>WF</em> actuels soient vastes, il reste encore beaucoup de fonctionnalit√©s √† introduire.  Si vous avez la fonctionnalit√© que vous souhaitez introduire, n'h√©sitez pas √† enregistrer votre demande d'API via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dotnet / corefx sur GitHub</a> .  Le processus de r√©vision de l'API est d√©crit <a href="">ici</a> et il existe un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bon exemple</a> de mod√®le de demande d'API sp√©cifi√© √† l'√©tape 1. </p><br><h2 id="osobye-blagodarnosti">  Remerciements sp√©ciaux </h2><br><p>  Je tiens √† exprimer une gratitude particuli√®re aux membres de notre communaut√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fei Peng (@fiigii)</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jacek Blaszczynski (@ 4creators)</a> pour leur aide dans la mise en ≈ìuvre du <em>WF</em> , ainsi qu'√† tous les membres de la communaut√© pour leurs pr√©cieux commentaires concernant le d√©veloppement, la mise en ≈ìuvre et la facilit√© d'utilisation de cette fonctionnalit√©. </p><br><hr><br><h3 id="posleslovie-k-perevodu">  Postface √† la traduction </h3><br><p>  J'aime observer le d√©veloppement de la plateforme .NET, et en particulier le langage C #.  Venant du monde du C ++ et ayant peu d'exp√©rience en d√©veloppement en Delphi et Java, j'√©tais tr√®s √† l'aise pour √©crire des programmes en C #.  En 2006, ce langage de programmation (le langage lui-m√™me) m'a paru plus concis et pratique que Java dans le monde de la gestion des ordures et du cross-platform.  Par cons√©quent, mon choix s'est port√© sur C #, et je ne l'ai pas regrett√©.  La premi√®re √©tape de l'√©volution d'une langue a √©t√© simplement son apparition.  En 2006, C # a absorb√© tout le meilleur qui √©tait √† l'√©poque dans les meilleurs langages et plateformes: C ++ / Java / Delphi.  En 2010, F # est devenue publique.  C'√©tait une plate-forme exp√©rimentale pour √©tudier le paradigme fonctionnel dans le but de l'introduire dans le monde de .NET.  Le r√©sultat des exp√©riences a √©t√© la prochaine √©tape de l'√©volution de C # - l'expansion de ses capacit√©s vers le FP, gr√¢ce √† l'introduction de fonctions anonymes, d'expressions lambda et, finalement, de LINQ.  Cette extension du langage a fait de C # le langage le plus avanc√©, de mon point de vue, √† usage g√©n√©ral.  L'√©tape √©volutive suivante √©tait li√©e √† la prise en charge de la concurrence et de l'asynchronie.  T√¢che / T√¢che &lt;T&gt;, tout le concept de TPL, le d√©veloppement de LINQ - PLINQ, et, enfin, async / wait.  ,   - ,       .NET   C# ‚Äî      .    Span&lt;T&gt;  Memory&lt;T&gt;, ValueTask/ValueTask&lt;T&gt;, IAsyncDispose, ref readonly struct   in,  foreach, IO.Streams.         GC    .   ,       ‚Äî       .  ,     .NET   C#,  ,          .   (       )         . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467663/">https://habr.com/ru/post/fr467663/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467653/index.html">Habrastatistique: analyse des commentaires des lecteurs</a></li>
<li><a href="../fr467655/index.html">Comment j'ai pass√© l'√©t√© avec C # 8</a></li>
<li><a href="../fr467657/index.html">Inventaire de I √† Z. Nous comptons les licences logicielles</a></li>
<li><a href="../fr467659/index.html">Acc√©l√®re consid√©rablement l'ex√©cution des t√¢ches gr√¢ce √† l'exemple de configuration suppl√©mentaire de la m√©moire HyperX FURY DDR4 mise √† jour</a></li>
<li><a href="../fr467661/index.html">Dosim√®tre pour Seryozha. Partie I. Polimaster - Chasseurs de nucl√©ides</a></li>
<li><a href="../fr467665/index.html">Chariot de camion ROS. Partie 5. Travailler dans rviz et gazebo: xacro, nouveaux capteurs</a></li>
<li><a href="../fr467667/index.html">Planification de projet d'organisation (partie 4)</a></li>
<li><a href="../fr467669/index.html">Regardez-moi en entier: tirez le meilleur parti de la vid√©o en direct sur les plateformes mobiles</a></li>
<li><a href="../fr467671/index.html">NLX Retro Computer</a></li>
<li><a href="../fr467673/index.html">Fonctionnalit√©s Go int√©gr√©es</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>