<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏆 🖇️ 👨🏼‍🤝‍👨🏻 InterSystems IRIS Global Transactions 💪🏿 🤼 🛌🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="InterSystems IRIS DBMS prend en charge les curieuses structures de stockage de données - globales. En fait, ce sont des clés à plusieurs niveaux avec ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>InterSystems IRIS Global Transactions</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461753/"><img src="https://habrastorage.org/webt/fh/h6/kb/fhh6kbibffqggpvpjk1bpabnj1w.png" alt="InterSystems IRIS et transaction" align="left">  InterSystems IRIS DBMS prend en charge les curieuses structures de stockage de données - globales.  En fait, ce sont des clés à plusieurs niveaux avec divers avantages supplémentaires sous la forme de transactions, des fonctions rapides pour parcourir les arbres de données, des verrous et leur propre langage ObjectScript. <br><br>  Plus d'informations sur les globaux dans la série d'articles «Globals - Swords-Masons for Data Storage»: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les arbres.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les arbres.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2e partie</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tableaux clairsemés.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3e partie</a> <br><br>  Il est devenu intéressant pour moi de savoir comment les transactions sont mises en œuvre dans le monde, quelles sont les fonctionnalités.  Après tout, il s'agit d'une structure de stockage des données complètement différente de celle des tables habituelles.  Niveau beaucoup plus bas. <br><a name="habracut"></a><br>  Comme vous le savez d'après la théorie des bases de données relationnelles, une bonne implémentation de transaction doit satisfaire aux exigences <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ACID</a> : <br><br>  <b>A - Atomique (atomicité).</b>  Toutes les modifications apportées à la transaction ou aucune du tout sont enregistrées. <br><br>  <b>C - Cohérence.</b>  Une fois la transaction terminée, l'état logique de la base de données doit être cohérent en interne.  À bien des égards, cette exigence s'applique au programmeur, mais dans le cas des bases de données SQL, elle s'applique également aux clés étrangères. <br><br>  <b>I - Isoler (isolement).</b>  Les transactions parallèles ne devraient pas s’affecter. <br><br>  <b>D - Durable.</b>  Une fois la transaction terminée avec succès, les problèmes aux niveaux inférieurs (panne de courant, par exemple) ne devraient pas affecter les données modifiées par la transaction. <br><br>  Les globaux sont des structures de données non relationnelles.  Ils ont été créés pour un travail ultrarapide sur un matériel très limité.  Voyons comment les transactions globales sont implémentées à l'aide de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">image Docker IRIS officielle</a> . <br><br>  Pour prendre en charge les transactions dans IRIS, les commandes suivantes sont utilisées: <a href="">TSTART</a> , <a href="">TCOMMIT</a> , <a href="">TROLLBACK</a> . <br><br><h2>  1. Atomicité </h2><br>  Le moyen le plus simple de vérifier l'atomicité.  Vérification à partir de la console de base de données. <br><br><pre><code class="bash hljs">Kill ^a TSTART Set ^a(1) = 1 Set ^a(2) = 2 Set ^a(3) = 3 TCOMMIT</code> </pre> <br>  Nous concluons ensuite: <br><br><pre> <code class="bash hljs">Write ^a(1), “ ”, ^a(2), “ ”, ^a(3)</code> </pre> <br>  Nous obtenons: <br><br><pre> <code class="bash hljs">1 2 3</code> </pre> <br>  Tout va bien.  Atomicité observée: tous les changements sont enregistrés. <br><br>  Nous compliquons la tâche, introduisons une erreur et voyons comment la transaction est enregistrée, partiellement ou pas du tout. <br><br>  Vérifions à nouveau l'atomicité: <br><br><pre> <code class="bash hljs">Kill ^A TSTART Set ^a(1) = 1 Set ^a(2) = 2 Set ^a(3) = 3</code> </pre> <br>  Ensuite, arrêtez de force le conteneur, démarrez et voyez. <br><br><pre> <code class="bash hljs">docker <span class="hljs-built_in"><span class="hljs-built_in">kill</span></span> my-iris</code> </pre> <br>  Cette commande est presque équivalente à une mise hors tension forcée, car elle envoie un signal pour arrêter immédiatement le processus SIGKILL. <br><br>  Peut-être que la transaction a été partiellement enregistrée? <br><br><pre> <code class="bash hljs">WRITE ^a(1), ^a(2), ^a(3) ^ &lt;UNDEFINED&gt; ^a(1)</code> </pre> <br>  - Non, pas conservé. <br><br>  Testez la commande de restauration: <br><br><pre> <code class="bash hljs">Kill ^A TSTART Set ^a(1) = 1 Set ^a(2) = 2 Set ^a(3) = 3 TROLLBACK WRITE ^a(1), ^a(2), ^a(3) ^ &lt;UNDEFINED&gt; ^a(1)</code> </pre> <br>  Rien n'a été conservé non plus. <br><br><h2>  2. Cohérence </h2><br>  Étant donné que dans les bases de données sur les globaux, les clés sont également créées sur les globaux (je rappelle qu'un global est une structure de niveau inférieur pour stocker des données qu'une table relationnelle), pour répondre à l'exigence de cohérence, vous devez inclure le changement de clé dans la même transaction que le changement global. <br><br>  Par exemple, nous avons une personne globale ^ dans laquelle nous stockons des personnalités et nous utilisons le NIF comme clé. <br><br><pre> <code class="bash hljs">^person(1234567, <span class="hljs-string"><span class="hljs-string">'firstname'</span></span>) = <span class="hljs-string"><span class="hljs-string">'Sergey'</span></span> ^person(1234567, <span class="hljs-string"><span class="hljs-string">'lastname'</span></span>) = <span class="hljs-string"><span class="hljs-string">'Kamenev'</span></span> ^person(1234567, <span class="hljs-string"><span class="hljs-string">'phone'</span></span>) = <span class="hljs-string"><span class="hljs-string">'+74995555555 ...</span></span></code> </pre> <br>  Afin d'avoir une recherche rapide par nom et prénom, nous avons fait la clé ^ index. <br><br><pre> <code class="bash hljs">^index(<span class="hljs-string"><span class="hljs-string">'Kamenev'</span></span>, <span class="hljs-string"><span class="hljs-string">'Sergey'</span></span>, 1234567) = 1</code> </pre> <br>  Pour que la base soit convenue, nous devons ajouter des personnalités comme celle-ci: <br><br><pre> <code class="bash hljs">TSTART ^person(1234567, <span class="hljs-string"><span class="hljs-string">'firstname'</span></span>) = <span class="hljs-string"><span class="hljs-string">'Sergey'</span></span> ^person(1234567, <span class="hljs-string"><span class="hljs-string">'lastname'</span></span>) = <span class="hljs-string"><span class="hljs-string">'Kamenev'</span></span> ^person(1234567, <span class="hljs-string"><span class="hljs-string">'phone'</span></span>) = <span class="hljs-string"><span class="hljs-string">'+74995555555 ^index('</span></span>Kamenev<span class="hljs-string"><span class="hljs-string">', '</span></span>Sergey<span class="hljs-string"><span class="hljs-string">', 1234567) = 1 TCOMMIT</span></span></code> </pre> <br>  Par conséquent, lors de la suppression, nous devons également utiliser la transaction: <br><br><pre> <code class="bash hljs">TSTART Kill ^person(1234567) ZKill ^index(<span class="hljs-string"><span class="hljs-string">'Kamenev'</span></span>, <span class="hljs-string"><span class="hljs-string">'Sergey'</span></span>, 1234567) TCOMMIT</code> </pre> <br>  En d'autres termes, la satisfaction de l'exigence de cohérence incombe entièrement au programmeur.  Mais en ce qui concerne les globaux, c'est normal, en raison de leur nature de bas niveau. <br><br><h2>  3. Isolement </h2><br>  C'est là que les déserts commencent.  De nombreux utilisateurs travaillent simultanément sur la même base de données, modifient les mêmes données. <br><br>  La situation est comparable à la situation où de nombreux utilisateurs travaillent simultanément avec le même référentiel avec le code et tentent de valider des modifications sur plusieurs fichiers à la fois. <br><br>  La base de données devrait résoudre ce problème en temps réel.  Étant donné que dans les entreprises sérieuses, il y a même une personne spéciale qui est responsable du contrôle de version (pour la fusion des succursales, la résolution des conflits, etc.), et la base de données devrait faire tout cela en temps réel, la complexité de la tâche et la conception correcte de la base de données et le code qui le sert. <br><br>  La base de données ne peut pas comprendre la signification des actions effectuées par les utilisateurs afin de prévenir les conflits s'ils travaillent sur les mêmes données.  Il ne peut annuler qu'une transaction contrairement à une autre ou les exécuter séquentiellement. <br><br>  Un autre problème est que pendant l'exécution de la transaction (avant la validation), l'état de la base de données peut être incohérent, il est donc souhaitable que d'autres transactions n'aient pas accès à l'état incohérent de la base de données, qui est obtenu dans les bases de données relationnelles de plusieurs manières: création d'instantanés, lignes multiversionnelles et etc. <br><br>  Dans l'exécution parallèle de transactions, il est important pour nous qu'elles n'interfèrent pas entre elles.  C'est la propriété de l'isolement. <br><br>  SQL définit 4 niveaux d'isolement: <br><br><ul><li>  LIRE NON ENGAGÉ </li><li>  LIRE ENGAGÉ </li><li>  LECTURE RÉPÉTABLE </li><li>  SÉRIALISABLE </li></ul><br>  Examinons chaque niveau séparément.  Les coûts de mise en œuvre de chaque niveau augmentent presque exponentiellement. <br><br>  <b>LIRE NON ENGAGÉ</b> est le niveau d'isolement le plus bas, mais le plus rapide.  Les transactions peuvent lire les modifications apportées par l'autre. <br><br>  <b>READ COMMITTED</b> est le prochain niveau d'isolement, qui est un compromis.  Les transactions ne peuvent pas lire les modifications apportées par l'autre avant un commit, mais peuvent lire toutes les modifications apportées après un commit. <br><br>  Si nous avons une longue transaction T1, au cours de laquelle il y a eu des validations dans les transactions T2, T3 ... Tn qui fonctionnaient avec les mêmes données que T1, alors lorsque nous demandons des données dans T1, nous obtiendrons des résultats différents à chaque fois.  Ce phénomène est appelé lecture non répétable. <br><br>  <b>REPEATABLE READ</b> - dans ce niveau d'isolement, nous n'avons pas le phénomène de lecture non répétable, car pour chaque demande de lecture de données, un instantané des données de résultat est créé et lorsqu'elles sont réutilisées dans la même transaction, les données de l'instantané sont utilisées.  Cependant, à ce niveau d'isolement, les données fantômes peuvent être lues.  Cela fait référence à la lecture de nouvelles lignes ajoutées par des transactions validées simultanées. <br><br>  <b>SERIALIZABLE</b> est le plus haut niveau d'isolement.  Il se caractérise par le fait que les données utilisées de quelque manière que ce soit dans la transaction (lecture ou modification) ne deviennent disponibles pour d'autres transactions qu'après la fin de la première transaction. <br><br>  Commençons par déterminer s'il existe une isolation des opérations dans une transaction par rapport au thread principal.  Ouvrons 2 fenêtres de terminal. <br><div class="scrollable-table"><table><tbody><tr><td><pre> <code class="bash hljs">Kill ^t Write ^t(1) 2</code> </pre> </td><td><pre> <code class="bash hljs">TSTART Set ^t(1)=2</code> </pre> </td></tr></tbody></table></div><br>  Il n'y a pas d'isolement.  Un thread voit ce que fait le second qui a ouvert la transaction. <br><br>  Voyons si les transactions de différents flux voient ce qui se passe à l'intérieur. <br><br>  Nous ouvrons 2 fenêtres de terminal et ouvrons 2 transactions en parallèle. <br><div class="scrollable-table"><table><tbody><tr><td><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">kill</span></span> ^t TSTART Write ^t(1) 3</code> </pre> </td><td><pre> <code class="bash hljs">TSTART Set ^t(1)=3</code> </pre></td></tr></tbody></table></div><br>  Les transactions simultanées voient les données des autres.  Nous avons donc obtenu le niveau d'isolement le plus simple, mais aussi le plus rapide LIRE NON COMMITÉ. <br><br>  En principe, cela pourrait être prévu pour les mondiaux, pour qui la vitesse a toujours été primordiale. <br><br>  Mais que faire si nous avons besoin d'un niveau d'isolement plus élevé dans les opérations mondiales? <br><br>  Ici, vous devez vous demander pourquoi les niveaux d'isolation sont nécessaires et comment ils fonctionnent. <br><br>  Le niveau d'isolement le plus élevé de SERIALIZE signifie que le résultat des transactions exécutées simultanément est équivalent à leur exécution séquentielle, ce qui garantit l'absence de collisions. <br><br>  Nous pouvons le faire à l'aide de verrous compétents en ObjectScript, qui ont beaucoup de façons différentes d'appliquer: vous pouvez faire des verrous multiples réguliers et incrémentiels avec la commande <a href="">LOCK</a> . <br><br>  Des niveaux d'isolement plus faibles sont des compromis conçus pour augmenter la vitesse de la base de données. <br><br>  Voyons comment nous pouvons atteindre différents niveaux d'isolement à l'aide de verrous. <br><br>  Cet opérateur vous permet de prendre non seulement les verrous exclusifs nécessaires pour modifier les données, mais aussi les verrous dits partagés, qui peuvent prendre plusieurs threads à la fois, lorsqu'ils ont besoin de lire des données qui ne devraient pas être modifiées par d'autres processus pendant la lecture. <br><br>  Plus d'informations sur la méthode de verrouillage à deux phases en russe et en anglais: <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Verrouillage biphasé</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Verrouillage biphasé</a> <br><br>  La difficulté est que pendant la transaction, l'état de la base de données peut être incohérent, cependant, ces données incohérentes sont visibles par d'autres processus.  Comment éviter cela? <br><br>  En utilisant des verrous, nous ferons de telles fenêtres de visibilité dans lesquelles l'état de la base de données sera convenu.  Et tous les appels à de telles fenêtres de visibilité de l'état convenu seront contrôlés par des verrous. <br><br>  Les verrous partagés des mêmes données sont réutilisables - plusieurs processus peuvent les prendre.  Ces verrous empêchent d'autres processus de modifier les données, c'est-à-dire  ils sont utilisés pour former les fenêtres de l'état coordonné de la base de données. <br><br>  Des verrous exclusifs sont utilisés pour modifier les données - un seul processus peut prendre un tel verrou.  Le blocage exclusif peut prendre: <br><br><ol><li>  Tout processus si les données sont libres </li><li>  Seul le processus qui a un verrou partagé sur ces données et le premier a demandé un verrou exclusif. </li></ol><br><img src="https://habrastorage.org/webt/ba/pu/mx/bapumxoivygurvclagw-mkw9p8w.png"><br><br>  Plus la fenêtre de visibilité est étroite, plus il faut de temps aux autres processus pour attendre, mais plus l'état de la base de données peut être cohérent. <br><br>  <b>READ_COMMITED</b> - l'essence de ce niveau est que nous ne voyons que les données d'autres flux qui sont verrouillés.  Si les données d'une autre transaction ne sont pas encore validées, alors nous voyons leur ancienne version. <br><br>  Cela nous permet de paralléliser le travail au lieu d'attendre que le verrou soit libéré. <br><br>  Sans astuces spéciales, nous ne pourrons pas voir l'ancienne version des données dans IRIS, nous devons donc faire avec les verrous. <br><br>  Par conséquent, nous devrons utiliser des verrous partagés pour permettre la lecture des données uniquement à des moments de cohérence. <br><br>  Supposons que nous ayons une base d'utilisateurs ^ personne qui se transfère de l'argent. <br><br>  Moment du transfert de la personne 123 à la personne 242: <br><br><pre> <code class="bash hljs">LOCK +^person(123), +^person(242) Set ^person(123, amount) = ^person(123, amount) - amount Set ^person(242, amount) = ^person(242, amount) + amount LOCK -^person(123), -^person(242)</code> </pre> <br>  Le moment de demander le montant d'argent à la personne 123 avant le débit doit être accompagné d'un verrou exclusif (par défaut): <br><br><pre> <code class="bash hljs">LOCK +^person(123) Write ^person(123)</code> </pre> <br>  Et si vous devez afficher l'état du compte dans votre compte, vous pouvez utiliser le verrouillage partagé ou ne pas l'utiliser du tout: <br><br><pre> <code class="bash hljs">LOCK +^person(123)<span class="hljs-comment"><span class="hljs-comment">#”S” Write ^person(123)</span></span></code> </pre> <br>  Cependant, si nous supposons que les opérations de base de données sont effectuées presque instantanément (je me souviens que les globaux sont une structure de niveau beaucoup plus faible qu'une table relationnelle), alors le besoin de ce niveau diminue. <br><br>  <b>REPEATABLE READ</b> - Dans ce niveau d'isolement, il est <b>supposé</b> qu'il peut y avoir plusieurs lectures de données qui peuvent être modifiées par des transactions simultanées. <br><br>  En conséquence, nous devrons mettre un verrou partagé sur la lecture des données que nous modifions et des verrous exclusifs sur les données que nous modifions. <br><br>  Heureusement, l'opérateur LOCK permet à un opérateur de répertorier en détail tous les verrous nécessaires, qui peuvent être très nombreux. <br><br><pre> <code class="bash hljs">LOCK +^person(123, amount)<span class="hljs-comment"><span class="hljs-comment">#”S”  ^person(123, amount)</span></span></code> </pre> <br>  autres opérations (pour le moment, les threads parallèles tentent de changer ^ personne (123, montant), mais ne peuvent pas) <br><br><pre> <code class="bash hljs">LOCK +^person(123, amount)  ^person(123, amount) LOCK -^person(123, amount)  ^person(123, amount) LOCK -^person(123, amount)<span class="hljs-comment"><span class="hljs-comment">#”S”</span></span></code> </pre> <br>  Lorsque vous répertoriez des verrous séparés par des virgules, ils sont pris de manière séquentielle, et si vous le faites: <br><br><pre> <code class="bash hljs">LOCK +(^person(123),^person(242))</code> </pre> <br>  puis ils sont pris atomiquement en une seule fois. <br><br>  <b>SÉRIALISER</b> - nous devrons définir les verrous de sorte que finalement toutes les transactions qui ont des données communes soient exécutées séquentiellement.  Pour cette approche, la plupart des serrures doivent être exclusives et prises dans les plus petites zones du monde pour des performances. <br><br>  Si nous parlons de radiations dans la personne globale, alors seul le niveau d'isolement SERIALIZE lui est acceptable, car l'argent doit être dépensé strictement séquentiellement, sinon il est possible de dépenser le même montant plusieurs fois. <br><br><h2>  4. Durabilité </h2><br>  J'ai effectué des tests avec une découpe difficile du conteneur à travers <br><br><pre> <code class="bash hljs">docker <span class="hljs-built_in"><span class="hljs-built_in">kill</span></span> my-iris</code> </pre> <br>  La base les a bien tolérés.  Aucun problème n'a été identifié. <br><br><h2>  Conclusion </h2><br>  Pour les pays du monde entier, InterSystems IRIS prend en charge les transactions.  Ils sont vraiment atomiques, fiables.  Pour garantir la cohérence de la base de données sur les globaux, les efforts du programmeur et l'utilisation des transactions sont nécessaires, car il n'y a pas de constructions intégrées complexes telles que des clés étrangères. <br><br>  Le niveau d'isolement des globaux sans utilisation de verrous est LIRE NON COMMIS, et lors de l'utilisation de verrous, il peut être assuré jusqu'au niveau SERIALIZE. <br><br>  L'exactitude et la rapidité des transactions sur les globaux dépendent beaucoup de la compétence du programmeur: plus les verrous partagés sont largement utilisés lors de la lecture, plus le niveau d'isolement est élevé et plus les verrous exclusifs sont pris, plus la vitesse est élevée. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr461753/">https://habr.com/ru/post/fr461753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr461743/index.html">Security Week 31: vulnérabilité VLC et téléphone cassé</a></li>
<li><a href="../fr461745/index.html">DeviceLock DLP: Prix du marché noir russe pour percer les données personnelles (plus une réponse à la réponse de Tinkoff Bank)</a></li>
<li><a href="../fr461747/index.html">Comment nous avons implémenté ML dans une application avec près de 50 millions d'utilisateurs. Expérience Sberbank</a></li>
<li><a href="../fr461749/index.html">La beauté dans l'œil du spectateur</a></li>
<li><a href="../fr461751/index.html">Contribution du concepteur au développement d'applications mobiles</a></li>
<li><a href="../fr461755/index.html">La psychologie de la vision sonore. Svetlana Lebedeva a expliqué comment les gens apprennent une nouvelle façon de percevoir</a></li>
<li><a href="../fr461759/index.html">Écoute des communications VoIP cryptées</a></li>
<li><a href="../fr461761/index.html">DPKI: remédier aux inconvénients de l'ICP centralisée avec la blockchain</a></li>
<li><a href="../fr461763/index.html">Les agences de publicité peuvent-elles tuer des entreprises au début du voyage</a></li>
<li><a href="../fr461765/index.html">Nous traversons des k8 avec Kafka, économisons des conteneurs, échappons aux déchets dans Ansible: les 10 meilleurs rapports de DevOops 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>