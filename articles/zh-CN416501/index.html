<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏩ 👨🏿‍🍳 📏 用C＃给我写一个GraphQL服务器 🔁 👎🏻 😺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="不知何故，我休息了几天，然后将GraphQL服务器绘制到了我们的Docsvision平台上。 下面我将告诉你它是如何进行的。 



 什么是Docsvision平台 


 Docsvision平台包括许多用于构建工作流系统的工具，但其关键组件类似于ORM。 有一个元数据编辑器，您可以在其中描述卡...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>用C＃给我写一个GraphQL服务器</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/docsvision/blog/416501/"><p> 不知何故，我休息了几天，然后将GraphQL服务器绘制到了我们的Docsvision平台上。 下面我将告诉你它是如何进行的。 </p><br><p><img src="https://habrastorage.org/webt/ol/gu/2p/olgu2pfxvycejlhj4z_o5o0q9ru.jpeg" alt="海报-按要求"></p><a name="habracut"></a><br><h4 id="chto-za-platforma-docsvision"> 什么是Docsvision平台 </h4><br><p> Docsvision平台包括许多用于构建工作流系统的工具，但其关键组件类似于ORM。 有一个元数据编辑器，您可以在其中描述卡字段的结构。 可能会有结构部分，集合部分和树部分，此外，它们可以嵌套， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通常，一切都很复杂</a> 。 数据库是由元数据生成的，然后您可以通过某些C＃API使用它。 一言以蔽之-构建GraphQL服务器的理想选择。 </p><br><h4 id="kakie-est-varianty"> 有哪些选择 </h4><br><p> 老实说，没有太多选择，而且都是这样。 我设法只找到两个库： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">图网</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">图网</a> </li></ul><br><p>  UPD：他们在评论中建议仍然存在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Hotchocolate</a> 。 </p><br><p> 在README上，起初我喜欢第二个，甚至开始使用它。 但是他很快发现她的API太差了，她无法应付生成元数据方案的任务。 但是，它似乎已经被放弃（一年前的最后一次提交）。 </p><br><p> <code>graphql-dotnet</code> API相当灵活，但同时<code>graphql-dotnet</code>文档记录，混乱<code>graphql-dotnet</code>直观。 要了解如何使用它，我必须看一下源代码...的确，我使用<code>0.16</code>版，而现在的最后一个是<code>0.17.3</code> ，并且已经发布了7个beta版本<code>2.0</code> 。 因此，如果材料过时，我感到抱歉。 </p><br><p> 我还必须提到，库带有未签名的程序集。 为了在带有签名程序集的ASP.NET应用程序中使用它们，我必须从源代码手动重建它们。 </p><br><h4 id="struktura-graphql-servera">  GraphQL服务器结构 </h4><br><p> 如果您不熟悉GraphQL，则可以尝试<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github Explorer</a> 。 一个小秘密-您可以按Ctrl +空格键来自动完成。 客户端部分无非就是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GraphiQL</a> ，可以轻松地将其固定到服务器上。 只需获取<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">index.html</a> ，从npm包中添加脚本，然后将graphQLFetcher函数中的url更改为服务器的地址-就可以了。 </p><br><p> 考虑一个简单的查询： </p><br><pre> <code class="hljs pgsql">query { viewer { <span class="hljs-keyword"><span class="hljs-keyword">login</span></span>, company } }</code> </pre> <br><p> 在这里，我们看到一组字段-查看器，登录名，公司。 像GraphQL后端一样，我们的任务是在服务器上构建一些“方案”，在其中将处理所有这些字段。 实际上，我们只需要使用字段描述创建适当的服务对象结构，并定义用于计算值的回调函数。 </p><br><p> 该方案可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">基于C＃类</a>自动生成，但是我们将经历核心问题-我们将全力以赴。 但这不是因为我是一个时髦的人，仅生成基于元数据的架构是graphql-dotnet中的非标准脚本，官方文档不支持该脚本。 因此，我们在她的肠道内的无证部位挖了一点。 </p><br><p> 创建了方案之后，我们仍然可以通过任何方便的方式（无论GET，POST，SignalR，TCP ...如何都无关紧要）将请求字符串（和参数）从客户端传递到服务器，并随方案一起提供其引擎。 引擎将吐出一个对象，结果是我们将其转换为JSON并将其返回给客户端。 对我来说看起来像这样： </p><br><pre> <code class="hljs pgsql"> //  ,        var schema = GraphQlService.GetCardsSchema(sessionContext); //    (  ) var executer = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> DocumentExecuter(); //   ,  var dict = await executer.ExecuteAsync(<span class="hljs-keyword"><span class="hljs-keyword">schema</span></span>, sessionContext, request.Query, request.MethodName).ConfigureAwait(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); // -   :) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dict.Errors != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; dict.Errors.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> InvalidOperationException(dict.Errors.First().Message); } //    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">Json</span></span>(dict.Data);</code> </pre> <br><p> 您可以注意<code>sessionContext</code> 。 这是特定于Docsvision的对象，可通过该对象访问平台。 在创建方案时，我们总是在特定的环境下工作，但以后会更多。 </p><br><h4 id="generaciya-shemy"> 电路生成 </h4><br><p> 一切都以感人的方式开始： </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Schema</span></span> schema = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Schema</span></span>();</code> </pre> <br><p> 不幸的是，这就是简单代码的结尾。 为了向方案添加字段，我们需要： </p><br><ol><li> 描述其类型-创建一个ObjectGraphType，StringGraphType，BooleanGraphType，IdGraphType，IntGraphType，DateGraphType或FloatGraphType对象。 </li><li> 描述字段本身（名称，处理程序）-创建一个GraphQL.Types.FieldType对象 </li></ol><br><p> 让我们尝试描述我上面引用的简单请求。 在请求中，我们有一个字段-查看者。 要将其添加到查询中，必须首先描述其类型。 它的类型很简单-一个具有两个字符串字段的对象-登录名和公司。 我们描述登录字段： </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loginField = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphQL.Types.FieldType(); loginField.Name = <span class="hljs-string"><span class="hljs-string">"login"</span></span>; loginField.ResolvedType = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringGraphType(); loginField.Type = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>); loginField.Resolver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyViewerLoginResolver(); <span class="hljs-comment"><span class="hljs-comment">// ... class MyViewerLoginResolver : GraphQL.Resolvers.IFieldResolver { public object Resolve(ResolveFieldContext context) { // ,       -   UserInfo //      viewer return (context.Source as UserInfo).AccountName; } }</span></span></code> </pre> <br><p> 我们以相同的方式创建companyField对象-非常好，我们准备描述查看器字段的类型。 </p><br><pre> <code class="hljs pgsql">ObjectGraphType&lt;UserInfo&gt; viewerType = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ObjectGraphType&lt;UserInfo&gt;(); viewerType.Name = "Viewer"; viewerType.AddField(loginField); viewerType.AddField(companyField);</code> </pre> <br><p> 有一个类型，现在我们可以描述查看器字段本身： </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> viewerField = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphQL.Types.FieldType(); viewerField.Name = <span class="hljs-string"><span class="hljs-string">"viewer"</span></span>; viewerField.ResolvedType = viewerType; viewerField.Type = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(UserInfo); viewerField.Resolver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyViewerResolver(); <span class="hljs-comment"><span class="hljs-comment">// ... class MyViewerResolver : GraphQL.Resolvers.IFieldResolver { public object Resolve(ResolveFieldContext context) { //     sessionContext   ? // ,         (login  company) return (context.Source as SessionContext).UserInfo; } }</span></span></code> </pre> <br><p> 好了，最后一点，将我们的字段添加到查询类型： </p><br><pre> <code class="hljs erlang">var <span class="hljs-keyword"><span class="hljs-keyword">query</span></span>Type = new ObjectGraphType(); <span class="hljs-keyword"><span class="hljs-keyword">query</span></span>Type.AddField(viewerField); schema.Query = <span class="hljs-keyword"><span class="hljs-keyword">query</span></span>Type;</code> </pre> <br><p> 就是这样，我们的计划已经准备就绪。 </p><br><h4 id="kollekcii-peydzhinaciya-obrabotka-parametrov"> 收集，分页，参数处理 </h4><br><p> 如果该字段返回的不是一个对象，而是一个集合，则需要显式指定此对象。 为此，只需将属性类型包装在ListGraphType类的实例中。 假设查看者返回了一个集合，我们可以简单地写成这样： </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//  ( ) viewerField.ResolvedType = viewerType; //  () viewerField.ResolvedType = new ListGraphType(viewerType);</span></span></code> </pre> <br><p> 因此，在MyViewerResolver解析器中，有必要返回列表。 </p><br><p> 当出现收集字段时，立即进行分页很重要。 这里没有现成的机制，所有操作都<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通过参数</a>完成。 您可能会注意到在上面的示例中使用参数的示例（cardDocument具有id参数）。 让我们向查看器添加这样的参数： </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idArgument = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QueryArgument(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IdGraphType)); idArgument.Name = <span class="hljs-string"><span class="hljs-string">"id"</span></span>; idArgument.ResolvedType = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IdGraphType(); idArgument.DefaultValue = Guid.Empty; viewerField.Arguments = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QueryArguments(idArgument);</code> </pre> <br><p> 然后，您可以像这样在解析器中获取参数值： </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Resolve</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ResolveFieldContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idArgStr = context.Arguments?[<span class="hljs-string"><span class="hljs-string">"id"</span></span>].ToString() ?? Guid.Empty.ToString(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idArg = Guid.Parse(idArgStr);</code> </pre> <br><p>  GraphQL的类型如此之大，以至于Guid当然无法解析。 好吧，对我们来说并不难。 </p><br><h4 id="zapros-kartochek-docsvision">  Docsvision卡申请 </h4><br><p> 因此，在针对Docsvision平台的GrapqhQL的实现中，我只需遍历元数据代码（ <code>sessionContext.Session.CardManager.CardTypes</code> ），对于所有卡及其部分，我都会使用相应的解析器自动创建此类对象。 结果是这样的： </p><br><pre> <code class="hljs objectivec">query { cardDocument(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>: <span class="hljs-string"><span class="hljs-string">"{AF652E55-7BCF-E711-8308-54A05079B7BF}"</span></span>) { mainInfo { name instanceID } } }</code> </pre> <br><p> 这里cardDocument是卡的类型，mainInfo是其中的部分的名称，name和instanceID是该部分中的字段。 卡，部分和字段的相应解析器按以下方式使用CardManager API： </p><br><pre> <code class="hljs kotlin"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CardDataResolver</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQL.Resolvers.IFieldResolver { public object Resolve</span></span></span></span>(ResolveFieldContext context) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sessionContext = (context.Source <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> SessionContext); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idArg = Guid.Parse(context.Arguments?[<span class="hljs-string"><span class="hljs-string">"id"</span></span>].ToString() ?? Guid.Empty.ToString()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sessionContext.Session.CardManager.GetCardData(idArg); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SectionResolver</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQL.Resolvers.IFieldResolver { CardSection section; public SectionFieldResolver</span></span></span></span>(CardSection section) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.section = section; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Resolve(ResolveFieldContext context) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idArg = Guid.Parse(context.Arguments?[<span class="hljs-string"><span class="hljs-string">"id"</span></span>].ToString() ?? Guid.Empty.ToString()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> skipArg = (int?)context.Arguments?[<span class="hljs-string"><span class="hljs-string">"skip"</span></span>] ?? <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> takeArg = (int?)context.Arguments?[<span class="hljs-string"><span class="hljs-string">"take"</span></span>] ?? <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sectionData = (context.Source <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> CardData).Sections[section.Id]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> idArg == Guid.Empty ? sectionData.GetAllRows().Skip(skipArg).Take(takeArg) : new List&lt;RowData&gt; { sectionData.GetRow(idArg) }; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RowFieldResolver</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQL.Resolvers.IFieldResolver { Field field; public RowFieldResolver</span></span></span></span>(Field field) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.field = field; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Resolve(ResolveFieldContext context) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (context.Source <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> RowData)[field.Alias]; } }</code> </pre> <br><p> 当然，在这里您只能通过ID申请卡，但是以相同的方式生成方案以访问高级报告，服务和其他任何内容都很容易。 使用此API，您只需编写适当的JavaScript即可从Docsvision数据库获取任何数据-编写自己的脚本和扩展名非常方便。 </p><br><h4 id="zaklyuchenie"> 结论 </h4><br><p> 使用.NET中的GrapqhQL，事情并不容易。 有一个稍微活跃的库，没有可靠的供应商，前途未卜，API不稳定且奇怪，未知在负载下的行为方式和稳定性。 但是，我们拥有的东西似乎可以正常运行，但是文档中的缺陷和其余缺陷已被源代码的开放性所抵消。 </p><br><p> 我在本文中描述的是一个越来越不公开的API，我通过键入和研究源代码对其进行了探索。 只是库的作者并不认为有人需要自动生成电路-恩，您能做什么，这是开源的。 </p><br><p> 到目前为止，所有这些都是单独编写的，到目前为止，只不过是一个原型。 在标准Docsvision软件包中，这可能会出现，但是何时-仍然很难说。 但是，如果您希望直接从JavaScrpit访问Docsvision数据库而不编写服务器扩展的想法，请编写。 合作伙伴的兴趣越高，我们将对此进行更多的关注。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN416501/">https://habr.com/ru/post/zh-CN416501/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN416489/index.html">地球外生命：关于纠正德雷克方程和大滤波器</a></li>
<li><a href="../zh-CN416491/index.html">Activiti-业务流程引擎</a></li>
<li><a href="../zh-CN416493/index.html">启动SIIG MiniSys S286</a></li>
<li><a href="../zh-CN416495/index.html">SamsPcbGuide第6部分：跟踪信号线。 损耗和串扰模型</a></li>
<li><a href="../zh-CN416497/index.html">在MATLAB中使用傅立叶变换计算信号反应的示例</a></li>
<li><a href="../zh-CN416505/index.html">我们在Rust'e上写一个堆栈虚拟机</a></li>
<li><a href="../zh-CN416507/index.html">如何检查数据中心的可靠性：您需要注意的三个要点</a></li>
<li><a href="../zh-CN416511/index.html">您（可能）在React代码中最常见的错误</a></li>
<li><a href="../zh-CN416513/index.html">260号移动开发人员的有趣材料摘要（7月2日至7月8日）</a></li>
<li><a href="../zh-CN416515/index.html">评分文章以添加到收藏夹</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>