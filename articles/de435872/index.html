<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶Å ‚öôÔ∏è üö† Zick-Programmiersprache üëì üçù üçÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der erste Kommentar zu dem wunderbaren Artikel Subjektive Vision einer idealen Programmiersprache stellte sich als Hinweis auf die Zig-Programmierspra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zick-Programmiersprache</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435872/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pq/fm/db/pqfmdbfclpie1tmlpudotsmvlbw.jpeg"></div><br>  Der erste Kommentar zu dem wunderbaren Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Subjektive Vision einer idealen Programmiersprache</a> stellte sich als Hinweis auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Zig-Programmiersprache heraus</a> .  Nat√ºrlich wurde es interessant, um welche Art von Sprache es sich handelt, die behauptet, eine Nische von C ++, D und Rust zu sein.  Ich sah aus - die Sprache schien h√ºbsch und etwas interessant.  Sch√∂ne si-√§hnliche Syntax, origineller Ansatz zur Fehlerbehandlung, integrierte Coroutinen.  Dieser Artikel gibt einen kurzen √úberblick √ºber die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offizielle Dokumentation,</a> die mit ihren eigenen Gedanken und Eindr√ºcken aus laufenden Codebeispielen durchsetzt ist. <br><a name="habracut"></a><br><h2>  Erste Schritte </h2><br>  Die Installation des Compilers ist f√ºr Windows recht einfach. Entpacken Sie das Distributionspaket einfach in einen Ordner.  Wir erstellen eine hello.zig-Textdatei im selben Ordner, f√ºgen den Code aus der Dokumentation dort ein und speichern ihn.  Die Montage erfolgt √ºber den Befehl <br><br><pre><code class="plaintext hljs">zig build-exe hello.zig</code> </pre> <br>  Danach erscheint hello.exe im selben Verzeichnis. <br><br>  Zus√§tzlich zur Montage steht der Unit-Test-Modus zur Verf√ºgung. Hierzu werden im Code Testbl√∂cke verwendet und die Montage und der Start der Tests werden mit dem Befehl ausgef√ºhrt <br><br><pre> <code class="plaintext hljs">zig test hello.zig</code> </pre> <br><h3>  Erste Kuriosit√§ten </h3><br>  Der Compiler unterst√ºtzt keine Windows-Zeilenumbr√ºche (\ r \ n).  Die Tatsache, dass Zeilenumbr√ºche in jedem System (Win, Nix, Mac) einige ihrer eigenen sind, ist nat√ºrlich Wildheit und ein Relikt der Vergangenheit.  Es ist jedoch nichts zu tun. W√§hlen Sie beispielsweise in Notepad ++ das gew√ºnschte Format f√ºr den Compiler aus. <br><br>  Die zweite Kuriosit√§t, auf die ich zuf√§llig gesto√üen bin - Tabs werden im Code nicht unterst√ºtzt!  Nur Leerzeichen.  Aber es passiert :) <br><br>  Dies ist jedoch ehrlich in der Dokumentation geschrieben - die Wahrheit ist bereits ganz am Ende. <br><br><h3>  Kommentare </h3><br>  Eine weitere Kuriosit√§t ist, dass Zig keine mehrzeiligen Kommentare unterst√ºtzt.  Ich erinnere mich, dass im alten Turbo Pascal alles richtig gemacht wurde - verschachtelte mehrzeilige Kommentare wurden unterst√ºtzt.  Anscheinend hat seitdem kein Sprachentwickler so eine einfache Sache gemeistert :) <br><br>  Aber es gibt dokumentarische Kommentare.  Beginnen Sie mit ///.  Muss an bestimmten Stellen sein - vor den entsprechenden Objekten (Variablen, Funktionen, Klassen ...).  Wenn sie woanders sind - ein Kompilierungsfehler.  Nicht schlecht. <br><br><h3>  Variablendeklaration </h3><br>  Geschehen im modischen Jetzt (und ideologisch korrekten) Stil, wenn zuerst das Schl√ºsselwort (const oder var) geschrieben wird, dann der Name, dann optional der Typ und dann der Anfangswert.  Das hei√üt,  Eine automatische Typinferenz ist verf√ºgbar.  Variablen m√ºssen initialisiert werden. Wenn Sie keinen Anfangswert angeben, tritt ein Kompilierungsfehler auf.  Es wird jedoch ein spezieller undefinierter Wert bereitgestellt, mit dem explizit nicht initialisierte Variablen angegeben werden k√∂nnen. <br><br><pre> <code class="plaintext hljs">var i:i32 = undefined;</code> </pre> <br><h3>  Konsolenausgabe </h3><br>  F√ºr Experimente ben√∂tigen wir eine Ausgabe an die Konsole - in allen Beispielen ist dies die verwendete Methode.  Im Bereich der Plug-Ins <br><br><pre> <code class="plaintext hljs">const warn = std.debug.warn;</code> </pre> <br>  und der Code ist wie folgt geschrieben: <br><br><pre> <code class="plaintext hljs">warn("{}\n{}\n", false, "hi");</code> </pre> <br>  Der Compiler hat einige Fehler, die er ehrlich meldet, wenn er versucht, eine Ganzzahl oder eine Gleitkommazahl auf folgende Weise auszugeben: <br><blockquote>  Fehler: Compiler-Fehler: Integer- und Float-Literale in der Funktion var args m√ºssen umgewandelt werden.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/ziglang/zig/issues/557</a> </blockquote><h2>  Datentypen </h2><br><h3>  Primitive Typen </h3><br>  Typnamen stammen anscheinend von Rust (i8, u8, ... i128, u128), es gibt auch spezielle Typen f√ºr die bin√§re C-Kompatibilit√§t, 4 Arten von Gleitkommatypen (f16, f32, f64, f128).  Es gibt einen Typ Bool.  Es gibt eine Art Nulll√ºcke und eine spezielle Noreturn, auf die ich sp√§ter noch eingehen werde. <br><br>  Sie k√∂nnen auch ganzzahlige Typen beliebiger L√§nge in Bits von 1 bis 65535 erstellen. Der Typname beginnt mit dem Buchstaben i oder u, und dann wird die L√§nge in Bits geschrieben. <br><br><pre> <code class="plaintext hljs">//  ! var j:i65535 = 0x0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF;</code> </pre> <br>  Dieser Wert konnte jedoch nicht an die Konsole √ºbertragen werden. W√§hrend des Kompilierungsvorgangs ist im LLVM ein Fehler aufgetreten. <br><br>  Im Allgemeinen ist dies eine interessante L√∂sung, obwohl sie nicht eindeutig ist (IMHO: Die Unterst√ºtzung genau langer numerischer Literale auf Compilerebene ist korrekt, aber die Benennung von Typen auf diese Weise ist nicht sehr gut, es ist besser, dies ehrlich √ºber einen Vorlagentyp zu tun).  Und warum ist das Limit 65535?  Bibliotheken wie GMP scheinen solche Einschr√§nkungen nicht aufzuerlegen? <br><br><h3>  String-Literale </h3><br>  Dies sind Zeichenarrays (ohne Null am Ende).  F√ºr Literale mit einer abschlie√üenden Null wird das Pr√§fix 'c' verwendet. <br><br><pre> <code class="plaintext hljs">const normal_bytes = "hello"; const null_terminated_bytes = c"hello";</code> </pre> <br>  Wie die meisten Sprachen unterst√ºtzt Zig Standard-Escape-Sequenzen und das Einf√ºgen von Unicode-Zeichen durch ihre Codes (\ uNNNN, \ UNNNNNN, wobei N eine hexadezimale Ziffer ist). <br>  Mehrzeilige Literale werden mit zwei umgekehrten Schr√§gstrichen am Anfang jeder Zeile gebildet.  Es sind keine Anf√ºhrungszeichen erforderlich.  Das hei√üt, einige versuchen, rohe Zeichenfolgen zu erstellen, aber IMHO ist nicht erfolgreich - der Vorteil von rohen Zeichenfolgen besteht darin, dass Sie jeden Text von einer beliebigen Stelle im Code einf√ºgen k√∂nnen - und im Idealfall nichts √§ndern, aber hier m√ºssen Sie \\ am Anfang jeder Zeile hinzuf√ºgen. <br><br><pre> <code class="plaintext hljs">const multiline = \\#include &lt;stdio.h&gt; \\ \\int main(int argc, char **argv) { \\ printf("hello world\n"); \\ return 0; \\} ;</code> </pre> <br><h3>  Ganzzahlige Literale </h3><br>  Alles ist in si-√§hnlichen Sprachen.  Ich war sehr erfreut, dass f√ºr Oktalliterale das Pr√§fix 0o verwendet wird und nicht nur Null, wie in C.  Bin√§rliterale mit dem Pr√§fix 0b werden ebenfalls unterst√ºtzt.  Gleitkomma-Literale k√∂nnen hexadezimal sein (wie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der GCC-Erweiterung</a> ). <br><br><h3>  Operationen </h3><br>  Nat√ºrlich gibt es standardm√§√üige arithmetische, logische und bitweise C-Operationen.  Kurzoperationen werden unterst√ºtzt (+ = usw.).  Anstelle von &amp;&amp; und ||  die Schl√ºsselw√∂rter und und oder werden verwendet.  Ein interessanter Punkt ist, dass Operationen mit garantierter Wraparound-Semantik zus√§tzlich unterst√ºtzt werden.  Sie sehen so aus: <br><br><pre> <code class="plaintext hljs">a +% b a +%= b</code> </pre> <br>  In diesem Fall garantieren gew√∂hnliche arithmetische Operationen keinen √úberlauf und ihre Ergebnisse w√§hrend des √úberlaufs werden als undefiniert betrachtet (und Kompilierungsfehler werden f√ºr Konstanten generiert).  IMHO ist dies ein wenig seltsam, aber anscheinend wird es aus einigen tiefen √úberlegungen zur Kompatibilit√§t mit der Semantik der C-Sprache gemacht. <br><br><h3>  Arrays </h3><br>  Array-Literale sehen folgenderma√üen aus: <br><br><pre> <code class="plaintext hljs">const msg = []u8{ 'h', 'e', 'l', 'l', 'o' }; const arr = []i32{ 1, 2, 3, 4 };</code> </pre> <br>  Zeichenfolgen sind Anordnungen von Zeichen, wie in C.  Klassische Indexierung mit eckigen Klammern.  Die Operationen der Addition (Verkettung) und Multiplikation von Arrays werden bereitgestellt.  Es ist eine sehr interessante Sache, und wenn bei der Verkettung alles klar ist, dann die Multiplikation - ich habe gewartet, bis jemand dies implementiert, und jetzt warte ich :) In Assembler (!) Gibt es eine solche Dup-Operation, mit der Sie doppelte Daten generieren k√∂nnen.  Jetzt in Zig: <br><br><pre> <code class="plaintext hljs">const one = []i32{ 1, 2, 3, 4 }; const two = []i32{ 5, 6, 7, 8 }; const c = one ++ two; // { 1,2,3,4,5,6,7,8 } const pattern = "ab" ** 3; // "ababab"</code> </pre> <br><h3>  Zeiger </h3><br>  Die Syntax √§hnelt C. <br><br><pre> <code class="plaintext hljs">var x: i32 = 1234; //  const x_ptr = &amp;x; //  </code> </pre> <br>  F√ºr die Dereferenzierung (Werte per Zeiger nehmen) wird eine ungew√∂hnliche Postfix-Operation verwendet: <br><br><pre> <code class="plaintext hljs">x_ptr.* == 5678; x_ptr.* += 1;</code> </pre> <br>  Der Zeigertyp wird explizit festgelegt, indem ein Sternchen vor dem Typnamen gesetzt wird <br><br><pre> <code class="plaintext hljs">const x_ptr : *i32 = &amp;x;</code> </pre> <br><h3>  Scheiben (Scheiben) </h3><br>  Eine in die Sprache integrierte Datenstruktur, mit der Sie auf ein Array oder einen Teil davon verweisen k√∂nnen.  Enth√§lt einen Zeiger auf das erste Element und die Anzahl der Elemente.  Es sieht so aus: <br><br><pre> <code class="plaintext hljs">var array = []i32{ 1, 2, 3, 4 }; const slice = array[0..array.len];</code> </pre> <br>  Es scheint von Go genommen zu sein, nicht sicher.  Und ich bin mir auch nicht sicher, ob es sich gelohnt hat, in eine Sprache einzubetten, w√§hrend die Implementierung einer solchen Sache in eine OOP-Sprache sehr elementar ist. <br><br><h3>  Strukturen </h3><br>  Eine interessante M√∂glichkeit, eine Struktur zu deklarieren: Es wird eine Konstante deklariert, deren Typ automatisch als "Typ" (Typ) angezeigt wird und die als Name der Struktur verwendet wird.  Und die Struktur selbst (struct) ist "namenlos". <br><br><pre> <code class="plaintext hljs">const Point = struct { x: f32, y: f32, };</code> </pre> <br>  Es ist unm√∂glich, einen Namen in C-√§hnlichen Sprachen auf die √ºbliche Weise anzugeben. Der Compiler zeigt den Typnamen jedoch nach bestimmten Regeln an. Insbesondere in dem oben betrachteten Fall stimmt er mit dem Namen der Konstante ‚Äûtype‚Äú √ºberein. <br><br>  Im Allgemeinen garantiert die Sprache nicht die Reihenfolge der Felder und ihre Ausrichtung im Speicher.  Wenn Garantien ben√∂tigt werden, sollten ‚Äûverpackte‚Äú Strukturen verwendet werden. <br><br><pre> <code class="plaintext hljs">const Point2 = packed struct { x: f32, y: f32, };</code> </pre> <br>  Initialisierung - im Stil der Sishny-Bezeichner: <br><br><pre> <code class="plaintext hljs">const p = Point { .x = 0.12, .y = 0.34, };</code> </pre> <br>  Strukturen k√∂nnen Methoden haben.  Beim Platzieren einer Methode in einer Struktur wird die Struktur jedoch einfach als Namespace verwendet.  Im Gegensatz zu C ++ werden diese Parameter nicht implizit √ºbergeben. <br><br><h3>  Transfers </h3><br>  Im Allgemeinen dasselbe wie in C / C ++.  Es gibt einige praktische integrierte Methoden f√ºr den Zugriff auf Metainformationen, z. B. die Anzahl der Felder und deren Namen, die durch in die Sprache integrierte Syntaxmakros implementiert werden (die in der Dokumentation als integrierte Funktionen bezeichnet werden). <br><br>  Aus Gr√ºnden der "Bin√§rkompatibilit√§t mit C" werden einige externe Aufz√§hlungen bereitgestellt. <br><br>  Um den Typ anzugeben, der der Aufz√§hlung zugrunde liegen soll, eine Konstruktion des Formulars <br><br><pre> <code class="plaintext hljs">packed enum(u8)</code> </pre> <br>  Dabei ist u8 der Basistyp. <br>  Aufz√§hlungen k√∂nnen struktur√§hnliche Methoden haben (d. H. Einen Aufz√§hlungsnamen als Namespace verwenden). <br><br><h3>  Gewerkschaften </h3><br>  Nach meinem Verst√§ndnis ist die Vereinigung in Zig eine algebraische Typensumme, d.h.  enth√§lt ein verstecktes Tag-Feld, das bestimmt, welches der Vereinigungsfelder "aktiv" ist.  Die "Aktivierung" eines anderen Feldes erfolgt durch eine vollst√§ndige Neuzuordnung des gesamten Vereins.  Dokumentationsbeispiel <br><br><pre> <code class="plaintext hljs">const assert = @import("std").debug.assert; const mem = @import("std").mem; const Payload = union { Int: i64, Float: f64, Bool: bool, }; test "simple union" { var payload = Payload {.Int = 1234}; // payload.Float = 12.34; // !    assert(payload.Int == 1234); //       payload = Payload {.Float = 12.34}; assert(payload.Float == 12.34); }</code> </pre> <br>  Gewerkschaften k√∂nnen auch explizit Aufz√§hlungen f√ºr das Tag verwenden. <br><br><pre> <code class="plaintext hljs">// Unions can be given an enum tag type: const ComplexTypeTag = enum { Ok, NotOk }; const ComplexType = union(ComplexTypeTag) { Ok: u8, NotOk: void, };</code> </pre> <br>  Gewerkschaften k√∂nnen wie Aufz√§hlungen und Strukturen auch einen eigenen Namespace f√ºr Methoden bereitstellen. <br><br><h3>  Optionale Typen </h3><br>  Zig verf√ºgt √ºber eine integrierte optionale Unterst√ºtzung.  Vor dem Typnamen wird ein Fragezeichen eingef√ºgt: <br><br><pre> <code class="plaintext hljs">const normal_int: i32 = 1234; // normal integer const optional_int: ?i32 = 5678; // optional integer</code> </pre> <br>  Interessanterweise setzt Zig eine Sache um, deren M√∂glichkeit ich vermutet habe, war mir aber nicht sicher, ob sie richtig war oder nicht.  Zeiger werden mit Optionen kompatibel gemacht, ohne dass ein zus√§tzliches verstecktes Feld (‚ÄûTag‚Äú) hinzugef√ºgt wird, in dem ein Zeichen f√ºr die G√ºltigkeit des Werts gespeichert ist.  und null wird als ung√ºltiger Wert verwendet.  Daher ben√∂tigen die in Zig durch Zeiger dargestellten Referenztypen nicht einmal zus√§tzlichen Speicher f√ºr "Optionalit√§t".  Gleichzeitig ist das Zuweisen von Nullwerten zu regul√§ren Zeigern verboten. <br><br><h3>  Fehlertypen </h3><br>  Sie √§hneln optionalen Typen, aber anstelle des Booleschen Tags ("wirklich ung√ºltig") wird ein Aufz√§hlungselement verwendet, das dem Fehlercode entspricht.  Die Syntax √§hnelt Optionen, anstelle eines Fragezeichens wird ein Ausrufezeichen hinzugef√ºgt.  So k√∂nnen diese Typen beispielsweise zur R√ºckgabe von Funktionen verwendet werden: Entweder wird das Objektergebnis der erfolgreichen Operation der Funktion zur√ºckgegeben, oder es wird ein Fehler mit dem entsprechenden Code zur√ºckgegeben.  Fehlertypen sind ein wichtiger Bestandteil des Zig-Sprachfehlerbehandlungssystems. Weitere Informationen finden Sie im Abschnitt Fehlerbehandlung. <br><br><h3>  Geben Sie void ein </h3><br>  Variablen wie void und Operationen mit ihnen sind in Zig m√∂glich <br><br><pre> <code class="plaintext hljs">var x: void = {}; var y: void = {}; x = y;</code> </pre> <br>  F√ºr solche Operationen wird kein Code generiert.  Dieser Typ ist haupts√§chlich f√ºr die Metaprogrammierung n√ºtzlich. <br><br>  Es gibt auch einen c_void-Typ f√ºr C-Kompatibilit√§t. <br><br><h2>  Bediener und Funktionen steuern </h2><br>  Dazu geh√∂ren: Bl√∂cke, Schalter, w√§hrend, wenn, sonst, brechen, fortfahren.  Um den Code zu gruppieren, werden standardm√§√üige geschweifte Klammern verwendet.  Nur Bl√∂cke wie in C / C ++ werden verwendet, um den Umfang von Variablen zu begrenzen.  Bl√∂cke k√∂nnen als Ausdr√ºcke betrachtet werden.  Es gibt kein goto in der Sprache, aber es gibt Beschriftungen, die mit den Anweisungen break und continue verwendet werden k√∂nnen.  Standardm√§√üig arbeiten diese Operatoren mit Schleifen. Wenn ein Block jedoch eine Beschriftung hat, k√∂nnen Sie diese verwenden. <br><br><pre> <code class="plaintext hljs">var y: i32 = 123; const x = blk: { y += 1; break :blk y; //   blk   y };</code> </pre> <br>  Die switch-Anweisung unterscheidet sich vom Operator darin, dass sie kein "Fallthrough" hat, d. H.  Es wird nur eine Bedingung (Fall) ausgef√ºhrt und der Schalter wird beendet.  Die Syntax ist kompakter: Anstelle von Gro√ü- und Kleinschreibung wird der Pfeil "=&gt;" verwendet.  Switch kann auch als Ausdruck betrachtet werden. <br><br>  Die while- und if-Anweisungen sind im Allgemeinen dieselben wie in allen C-√§hnlichen Sprachen.  Die for-Anweisung √§hnelt eher foreach.  Alle von ihnen k√∂nnen als Ausdr√ºcke betrachtet werden.  Von den neuen Funktionen kann while und for sowie if einen else-Block haben, der ausgef√ºhrt wird, wenn keine Schleifeniteration vorhanden ist. <br><br>  Und hier ist es an der Zeit, √ºber eine gemeinsame Funktion f√ºr den Switch zu sprechen, die in gewisser Weise aus dem Konzept der foreach-Schleifen entlehnt ist - das ‚ÄûErfassen‚Äú von Variablen.  Es sieht so aus: <br><br><pre> <code class="plaintext hljs">while (eventuallyNullSequence()) |value| { sum1 += value; } if (opt_arg) |value| { assert(value == 0); } for (items[0..1]) |value| { sum += value; }</code> </pre><br>  Hier ist das while-Argument eine bestimmte ‚ÄûDatenquelle‚Äú, die f√ºr ein Array oder ein Slice optional sein kann, und eine Variable zwischen zwei vertikalen Linien enth√§lt einen ‚Äûerweiterten‚Äú Wert, d. H.  das aktuelle Element des Arrays oder Slice (oder ein Zeiger darauf), der interne Wert des optionalen Typs (oder ein Zeiger darauf). <br><br><h3>  Anweisungen verschieben und verschieben </h3><br>  Die von Go geliehene aufgeschobene Ausf√ºhrungserkl√§rung.  Es funktioniert genauso - das Argument dieses Operators wird ausgef√ºhrt, wenn der Bereich verlassen wird, in dem der Operator verwendet wird.  Zus√§tzlich wird der Errdefer-Operator bereitgestellt, der ausgel√∂st wird, wenn ein Fehlertyp mit einem aktiven Fehlercode von der Funktion zur√ºckgegeben wird.  Dies ist Teil des urspr√ºnglichen Zig-Fehlerbehandlungssystems. <br><br><h3>  Nicht erreichbarer Bediener </h3><br>  Das Element der Vertragsprogrammierung.  Ein spezielles Schl√ºsselwort, das dort platziert wird, wo das Management unter keinen Umst√§nden kommen sollte.  Wenn es dort ankommt, wird in den Modi Debug und ReleaseSafe eine Panik erzeugt, und in ReleaseFast wirft das Optimierungsprogramm diese Zweige vollst√§ndig aus. <br><br><h3>  noreturn </h3><br>  Technisch gesehen ist es ein Typ, der in Ausdr√ºcken mit jedem anderen Typ kompatibel ist.  Dies ist m√∂glich, weil ein Objekt dieses Typs niemals zur√ºckkehren wird.  Da Operatoren Ausdr√ºcke in Zig sind, wird ein spezieller Typ f√ºr Ausdr√ºcke ben√∂tigt, die niemals ausgewertet werden.  Dies geschieht, wenn die rechte Seite des Ausdrucks die Kontrolle unwiderruflich an einen Ort au√üerhalb √ºbertr√§gt.  Zu solchen Anweisungen brechen, fortfahren, zur√ºckgeben, nicht erreichbare Endlosschleifen und Funktionen, die niemals die Kontrolle zur√ºckgeben.  Zum Vergleich: Ein Aufruf einer regul√§ren Funktion (R√ºckgabe der Steuerung) ist kein Noreturn-Operator, da die Steuerung zwar nach au√üen √ºbertragen wird, aber fr√ºher oder sp√§ter an den Anrufpunkt zur√ºckgegeben wird. <br><br>  Somit werden folgende Ausdr√ºcke m√∂glich: <br><br><pre> <code class="plaintext hljs">fn foo(condition: bool, b: u32) void { const a = if (condition) b else return; @panic("do something with a"); }</code> </pre> <br>  Die Variable a erh√§lt den von der if / else-Anweisung zur√ºckgegebenen Wert.  Dazu m√ºssen die Teile (sowohl if als auch else) einen Ausdruck des gleichen Typs zur√ºckgeben.  Der if-Teil gibt bool zur√ºck, der else-Teil ist der noreturn-Typ, der technisch mit jedem Typ kompatibel ist. Daher wird der Code fehlerfrei kompiliert. <br><br><h3>  Funktionen </h3><br>  Die Syntax ist klassisch f√ºr Sprachen dieses Typs: <br><br><pre> <code class="plaintext hljs">fn add(a: i8, b: i8) i8 { return a + b; }</code> </pre> <br>  Im Allgemeinen sehen die Funktionen ziemlich normal aus.  Bisher habe ich keine Anzeichen f√ºr erstklassige Funktionen bemerkt, aber meine Kenntnis der Sprache ist sehr oberfl√§chlich, ich k√∂nnte mich irren.  Obwohl dies vielleicht noch nicht geschehen ist. <br><br>  Ein weiteres interessantes Feature ist, dass in Zig das Ignorieren zur√ºckgegebener Werte nur explizit mit dem Unterstrich _ erfolgen kann <br><br><pre> <code class="plaintext hljs"> _ = foo();</code> </pre> <br>  Es gibt eine Reflexion, mit der Sie verschiedene Informationen √ºber die Funktion erhalten k√∂nnen <br><br><pre> <code class="plaintext hljs">const assert = @import("std").debug.assert; test "fn reflection" { assert(@typeOf(assert).ReturnType == void); //    assert(@typeOf(assert).is_var_args == false); //    }</code> </pre> <br><h2>  Codeausf√ºhrung zur Kompilierungszeit </h2><br>  Zig bietet eine leistungsstarke Funktion: Ausf√ºhren von Code, der zur Kompilierungszeit in Zick geschrieben wird.  Damit der Code zur Kompilierungszeit ausgef√ºhrt werden kann, schlie√üen Sie ihn einfach in einen Block mit dem Schl√ºsselwort comptime ein.  Dieselbe Funktion kann sowohl zur Kompilierungszeit als auch zur Laufzeit aufgerufen werden, sodass Sie universellen Code schreiben k√∂nnen.  Nat√ºrlich gibt es einige Einschr√§nkungen, die mit verschiedenen Kontexten des Codes verbunden sind.  In der Dokumentation in vielen Beispielen wird beispielsweise comptime verwendet, um die Kompilierungszeit zu √ºberpr√ºfen: <br><br><pre> <code class="plaintext hljs">// array literal const message = []u8{ 'h', 'e', 'l', 'l', 'o' }; // get the size of an array comptime { assert(message.len == 5); }</code> </pre> <br>  Aber nat√ºrlich ist die Leistung dieses Betreibers hier bei weitem nicht vollst√§ndig offenbart.  In der Beschreibung der Sprache wird daher ein klassisches Beispiel f√ºr die effektive Verwendung syntaktischer Makros gegeben - die Implementierung einer Funktion √§hnlich wie printf, die jedoch die Formatzeichenfolge analysiert und alle erforderlichen Typpr√ºfungen von Argumenten in der Kompilierungsphase durchf√ºhrt. <br><br>  Das Wort comptime wird auch verwendet, um die Parameter von Funktionen zur Kompilierungszeit anzugeben, die den C ++ - Vorlagenfunktionen √§hnlich sind. <br><br><pre> <code class="plaintext hljs">   fn max(comptime T: type, a: T, b: T) T { return if (a &gt; b) a else b; }</code> </pre> <br><h2>  Fehlerbehandlung </h2><br>  Zig erfand ein urspr√ºngliches Fehlerbehandlungssystem, das anderen Sprachen nicht glich.  Dies kann als "explizite Ausnahmen" bezeichnet werden (in dieser Sprache ist explizite Aussage im Allgemeinen eine der Redewendungen).  Es sieht auch aus wie Go-R√ºckkehrcodes, funktioniert aber anders. <br><br>  Das Zig-Fehlerverarbeitungssystem basiert auf speziellen Aufz√§hlungen zur Implementierung eigener Fehlercodes (Fehler) und basiert auf deren Basis ‚ÄûFehlertypen‚Äú (algebraische Typensumme, die den zur√ºckgegebenen Funktionstyp und den Fehlercode kombiniert). <br><br>  Fehleraufz√§hlungen werden wie regul√§re Aufz√§hlungen deklariert: <br><br><pre> <code class="plaintext hljs">const FileOpenError = error { AccessDenied, OutOfMemory, FileNotFound, }; const AllocationError = error { OutOfMemory, };</code> </pre> <br>  Alle Fehlercodes erhalten jedoch Werte gr√∂√üer als Null.  Wenn Sie einen Code mit demselben Namen in zwei Aufz√§hlungen deklarieren, erh√§lt er denselben Wert.  Implizite Konvertierungen zwischen verschiedenen Aufz√§hlungen von Fehlern sind jedoch verboten. <br><br>  Das Schl√ºsselwort anyerror bedeutet eine Aufz√§hlung, die alle Fehlercodes enth√§lt. <br><br>  Wie optionale Typen unterst√ºtzt die Sprache die Generierung von Fehlertypen mithilfe einer speziellen Syntax.  Typ! U64 ist eine abgek√ºrzte Form von anyerror! U64, was wiederum eine Vereinigung (Option) bedeutet, die Typ u64 und type anyerror enth√§lt (nach meinem Verst√§ndnis ist Code 0 reserviert, um das Fehlen eines Fehlers und die G√ºltigkeit des Datenfelds anzuzeigen, der Rest der Codes tats√§chlich Fehlercodes). <br><br>  Mit dem Schl√ºsselwort catch k√∂nnen Sie den Fehler abfangen und in einen Standardwert umwandeln: <br><br><pre> <code class="plaintext hljs">const number = parseU64(str, 10) catch 13;</code> </pre> <br>  Wenn also ein Fehler in der Funktion parseU64 auftritt, der den Typ! U64 zur√ºckgibt, wird catch ihn abfangen und den Standardwert 13 zur√ºckgeben. <br><br>  Mit dem Schl√ºsselwort try k√∂nnen Sie den Fehler an die obere Ebene (dh an die Ebene der aufrufenden Funktion) weiterleiten.  Code anzeigen <br><br><pre> <code class="plaintext hljs">fn doAThing(str: []u8) !void { const number = try parseU64(str, 10); // ... }</code> </pre> <br>  √§quivalent dazu: <br><br><pre> <code class="plaintext hljs">fn doAThing(str: []u8) !void { const number = parseU64(str, 10) catch |err| return err; // ... }</code> </pre> <br>  Hier passiert Folgendes: parseU64 wird aufgerufen, wenn ein Fehler von ihm zur√ºckgegeben wird - es wird von der catch-Anweisung abgefangen, in der der Fehlercode mithilfe der in der err-Variablen platzierten Syntax "capture" extrahiert wird, die √ºber! Void an die aufrufende Funktion zur√ºckgegeben wird. <br><br>  Der zuvor beschriebene Errdefer-Operator bezieht sich auch auf die Fehlerbehandlung.  Der Errdefer-Argumentcode wird nur ausgef√ºhrt, wenn die Funktion einen Fehler zur√ºckgibt. <br><br>  Einige weitere M√∂glichkeiten.  Mit dem ||  Sie k√∂nnen Fehlers√§tze zusammenf√ºhren <br><br><pre> <code class="plaintext hljs">const A = error{ NotDir, PathNotFound, }; const B = error{ OutOfMemory, PathNotFound, }; const C = A || B;</code> </pre> <br>  Zig bietet auch Funktionen wie die Fehlerverfolgung.  Dies √§hnelt einer Stapelverfolgung, enth√§lt jedoch detaillierte Informationen dar√ºber, welcher Fehler aufgetreten ist und wie er sich entlang der Versuchskette vom Ort des Auftretens zur Hauptfunktion des Programms ausbreitet. <br><br>  ,     Zig     ,       C++,      Go.  ,        ‚Äî  4 ,        ;   ‚Äî    .    ++,        -    .     ‚Äî      . <br><br><h2>  </h2><br>  Zig   .  ,      async,         (  ,   ). <br><br><pre> <code class="plaintext hljs">test "create a coroutine and cancel it" { const p = try async&lt;std.debug.global_allocator&gt; simpleAsyncFn(); comptime assert(@typeOf(p) == promise-&gt;void); cancel p; assert(x == 2); } async&lt;*std.mem.Allocator&gt; fn simpleAsyncFn() void { x += 1; }</code> </pre> <br> async     promise-&gt;T ( T ‚Äî   ).       . <br><br>       suspend, resume  cancel.   suspend        .    suspend,         . <br><br> resume    promise-&gt;T       ,     . <br><br> cancel   . <br><br>          (  )  .   : <br><br><img src="https://habrastorage.org/webt/yi/em/dv/yiemdv3ujvm-rodjnohawjtld68.png" alt="Bild"><br><br>  ( )  ‚Äî  await.   ,   ,  ,   (,    ).          ,      : <br><br><img src="https://habrastorage.org/webt/yo/gu/uq/yoguuqayvhwyxtrhcni-rjn-w7g.png" alt="Bild"><br><br><h2>   </h2><br> builtin functions ‚Äî    ,          . ,      ¬´  ¬ª,         . builtin'      (sizeOf, tagName, TagType, typeInfo, typeName, typeOf),      (import).      builtin' C/C++ ‚Äî     ,     sqrt, popCount, slhExact  ..  ,          . <br><br><h3>  Abschlie√üend </h3><br>        .      ,     ,              . ++ ,   ,       ,         -        . Rust ,      ,    . D ‚Äî  ,     ,          Java,      -     .   Zig ‚Äî    .  ,         . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435872/">https://habr.com/ru/post/de435872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435862/index.html">Unterhaltungselektronik Hall of Fame: Die Geschichten der besten Ger√§te der letzten 50 Jahre, Teil 4</a></li>
<li><a href="../de435864/index.html">Mapping-Anfragen f√ºr Netty</a></li>
<li><a href="../de435866/index.html">Release IT: Eine neue Plattform f√ºr die Einf√ºhrung von Produkten und Dienstleistungen im Rahmen des SXSW 2019-Festivals</a></li>
<li><a href="../de435868/index.html">Slush 2018. Preview Day</a></li>
<li><a href="../de435870/index.html">Kybernetisches Orchester. Docker Container Orchestration mit .NET Core-Anwendungen in der Cloud</a></li>
<li><a href="../de435876/index.html">Detaillierte Firefox-Browsereinstellungen</a></li>
<li><a href="../de435878/index.html">Amateur in OpenSource - Lektionen in 3 Jahren gelernt</a></li>
<li><a href="../de435880/index.html">√Ñndern des Schemas von PostgreSQL-Tabellen ohne lange Sperren. Yandex Vortrag</a></li>
<li><a href="../de435882/index.html">Xiaomi Mi Box S Bewertung und ein kleiner Vergleich mit Mi Box 3</a></li>
<li><a href="../de435884/index.html">Metallsuche und ... neuronales Netzwerk</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>