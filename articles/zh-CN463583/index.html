<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔝 ⛹🏿 🤵🏼 神奇的插件，卷。 1.理论 🛷 ⚪️ 👨🏿‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="多模块项目的生活并非如此简单。 为了避免创建新模块的例行程序，我们为Android Studio创建了自己的插件。 在实施过程中，我们遇到了缺乏实际文档的情况，尝试了几种方法并挖掘了许多陷阱。 结果是两篇文章：“理论”和“实践” 。 认识我！ 



 我要说什么 


- 为什么要使用插件？ 为什...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>神奇的插件，卷。 1.理论</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/463583/"><p> 多模块项目的生活并非如此简单。 为了避免创建新模块的例行程序，我们为Android Studio创建了自己的插件。 在实施过程中，我们遇到了缺乏实际文档的情况，尝试了几种方法并挖掘了许多陷阱。 结果是两篇文章：“理论”和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“实践”</a> 。 认识我！ </p><br><p><img src="https://habrastorage.org/webt/an/fg/dp/anfgdpffwxapeeei7coineoxdvk.png" alt="图片"></p><a name="habracut"></a><br><h1 id="o-chem-budu-govorit"> 我要说什么 </h1><br><ul><li> 为什么要使用插件？ 为什么要使用插件？ <br><ul><li> 拟定清单 </li><li> 清单自动化选项 </li></ul></li><li> 插件开发基础 <br><ul><li> 动作 </li><li> 插件中的UI开发 </li><li> 结论 </li></ul></li><li>  IDEA内部：组件，PSI <br><ul><li>  IDEA内部单元 </li><li>  PSI </li><li> 结论 </li></ul></li></ul><br><h1 id="zachem-plagin-pochemu-plagin"> 为什么要使用插件？ 为什么要使用插件？ </h1><br><p> 如果您正在开发一个多模块Android项目，那么您就会知道每次创建一个新模块是什么样的例程。 您需要创建一个模块，在其中配置Gradle，添加依赖项，等待同步，不要忘记在应用程序模块中修复某些东西-这都需要很多时间。 我们希望使例程自动化，因此我们首先编写了每次创建新模块时要做的事情的清单。 </p><br><p>  1.首先，我们通过菜单File-&gt; New-&gt; New module-&gt; Android library创建模块本身。 </p><br><p><img src="https://habrastorage.org/webt/eo/nt/tk/eonttksy33ofpojuctkl8aoghuo.png" alt="图片"></p><br><p>  2.我们在settings.gradle文件中写入模块的路径，因为我们有几种类型的模块-核心模块和功能模块，它们位于不同的文件夹中。 </p><br><div class="spoiler">  <b class="spoiler_title">我们编写模块的路径</b> <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// settings.gradle include ':analytics project(':analytics').projectDir = new File(settingsDir, 'core/framework-metrics/analytics) ... include ':feature-worknear' project(':feature-worknear').projectDir = new File(settingsDir, 'feature/feature-worknear')</span></span></code> </pre> </div></div><br><p>  3.在生成的<em>build.gradle中</em>更改常量<em>compileSdk</em> ， <em>minSdk</em>和<em>targetSdk</em> ：将其替换为在root <em>build.gradle</em>中定义的<em>常量</em> 。 </p><br><div class="spoiler">  <b class="spoiler_title">在新模块的build.gradle中更改常量</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Feature module build.gradle … android { compileSdkVersion rootProject.ext.targetSdkVersion defaultConfig { minSdkVersion rootProject.ext.minSdkVersion targetSdkVersion rootProject.ext.targetSdkVersion ... } }</span></span></code> </pre> </div></div><br><p> 注意：我们最近将工作的这一部分移到了Gradle插件中，该插件可帮助多行配置<em>build.gradle</em>文件的所有必需参数。 </p><br><p>  4.由于我们正在用Kotlin编写所有新代码，因此作为标准，我们连接了两个插件： <em>kotlin-android</em>和<em>kotlin-kapt</em> 。 如果该模块以某种方式与UI连接，我们还可以连接<em>kotlin-android-extensions</em>模块。 </p><br><div class="spoiler">  <b class="spoiler_title">连接Kotlin插件</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Feature module build.gradle apply plugin: 'com.android.library' apply plugin: 'kotlin-android' apply plugin: 'kotlin-android-extensions' apply plugin: 'kotlin-kapt'</span></span></code> </pre></div></div><br><p>  5.我们连接通用库和核心模块。 核心模块是例如记录器，分析程序，一些常规实用程序和库-RxJava，Moxy等。 </p><br><div class="spoiler">  <b class="spoiler_title">我们连接共享库和模块</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Feature module build.gradle dependencies { def libraries = rootProject.ext.deps compileOnly project(':logger') compileOnly project(':analytics') … // Kotlin compileOnly libraries.kotlin // DI compileOnly libraries.toothpick kapt libraries.toothpickCompiler }</span></span></code> </pre></div></div><br><p>  6.为牙签设置kapt。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">牙签</a>是我们的核心DI框架。 您很可能知道：为了在发行版本中使用代码生成而不是反射，您需要配置注释处理器，以便其了解从何处获取所创建对象的工厂： </p><br><div class="spoiler">  <b class="spoiler_title">为牙签配置注释处理器</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Feature module build.gradle defaultConfig { ... javaCompileOptions { annotationProcessorOptions { arguments = [ toothpick_registry_package_name: "ru.hh.feature_worknear" ] } } ...</span></span></code> </pre> </div></div><br><p> 注意：在hh.ru中，我们使用第一个版本的Toothpick，在第二个版本中，我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">删除了使用代码生成的功能</a> 。 </p><br><p>  7.我们在创建的模块内为Moxy配置kapt。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Moxy</a>是用于在应用程序中创建MVP的主要框架， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">您需要对其</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">稍加改动</a> ，使其可以在多模块项目中工作。 特别是，在kapt参数中注册创建的模块的软件包： </p><br><div class="spoiler">  <b class="spoiler_title">为Moxy配置Kapt</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Feature module build.gradle android { ... kapt { arguments { arg("moxyReflectorPackage", "ru.hh.feature_worknear") } } ...</span></span></code> </pre></div></div><br><p> 注意：我们已经切换到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">新版本的Moxy</a> ，并且代码生成的这一部分已经失去了意义。 </p><br><p>  8.我们生成了一堆新文件。 我的意思不是不是那些自动创建的文件（AndroidManifest.xml，build.gradle，.gitignore），而是新模块的常规框架：交互器，存储库，DI模块，演示者，片段。 这些文件很多，开始时它们具有相同的结构，创建它们是一个例程。 </p><br><p><img src="https://habrastorage.org/webt/j2/f5/sz/j2f5szalxm1nmgg4yj9kivxpdfs.png" alt="图片"></p><br><p>  9.我们将创建的模块连接到应用程序模块。 在此步骤中，您必须记住在应用程序模块的build.gradle文件中配置Toothpick。 为此，我们将创建的模块的程序包添加到特殊的参数注释处理器<em>-toothpick_registry_children_package_names中</em> 。 </p><br><div class="spoiler">  <b class="spoiler_title">调整牙签</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// App module build.gradle defaultConfig { … javaCompileOptions { annotationProcessorOptions { arguments = [ toothpick_registry_package_name: "ru.hh.android", toothpick_registry_children_package_names: [ "ru.hh.analytics", "ru.hh.feature_worknear", ... ].join(",") ] } } …</span></span></code> </pre></div></div><br><p> 之后，我们在应用程序模块中配置Moxy。 我们有一个标有<strong>@RegisterMoxyReflectorPackages</strong>批注的类-我们在其中添加已创建模块的包名称： </p><br><div class="spoiler">  <b class="spoiler_title">配置MoxyReflectorStub</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// App module file @RegisterMoxyReflectorPackages( "ru.hh.feature_force_update", "ru.hh.feature_profile", "ru.hh.feature_worknear" ... ) class MoxyReflectorStub</span></span></code> </pre> </div></div><br><p> 最后，不要忘记将创建的模块连接到应用程序模块的<em>依赖关系</em>块： </p><br><div class="spoiler">  <b class="spoiler_title">添加依赖</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Application module build.gradle dependencies { def libraries = rootProject.ext.deps implementation project(':logger') implementation project(':dependency-handler') implementation project(':common') implementation project(':analytics') implementation project(':feature_worknear') ...</span></span></code> </pre> </div></div><br><p> 我们得到了九点清单。 </p><br><p> 由于有很多要点，很可能会忘记一些东西。 然后花数小时来思考发生了什么以及为什么项目不进行。 </p><br><p> 我们认为您不能过这种生活，您需要做出一些改变。 </p><br><h2 id="varianty-avtomatizacii-chek-lista"> 清单自动化选项 </h2><br><p> 编制完清单后，我们开始寻找自动执行其项目的选项。 </p><br><p> 第一种选择是尝试执行<strong>“ Ctrl + C，Ctrl + V”</strong> 。 我们试图找到一种用于创建Android库模块的实现，该模块可“直接使用”。 在带有Android Studio的文件夹中（对于MacOs： <em>/ Applications / Android \ Studio.app/Contents/plugins/android/lib/templates/gradle-projects/</em> ），您可以找到一个特殊的文件夹，其中包含当您选择文件时看到的那些项目的模板- &gt;新建-&gt;新建模块。 我们试图通过更改<em>template.xml.ftl</em>文件中的id来复制NewAndroidModule模板。 然后他们启动了IDE，开始创建一个新模块，然后... Android Studio崩溃了，因为您在菜单中看到的用于创建新模块的模块列表是硬编码的，因此无法使用原始的复制粘贴进行更改。 当您尝试添加，删除或更改元素时，Android Studio会崩溃。 </p><br><p><img src="https://habrastorage.org/webt/ym/ww/sw/ymwwsw1rzibvaxwrhkqkwd5fqyk.png" alt="图片"></p><br><p> 自动执行清单的第二个选项是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FreeMarker模板引擎</a> 。 在尝试不成功的复制粘贴之后，我们决定仔细查看模块模板，并在幕后找到FreeMarker模板。 </p><br><p> 我不会告诉您FreeMarker的详细信息<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-RedMadRobot</a>有一篇<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不错的文章，</a>以及<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Lesha Bykov的</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MosDroid</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">视频</a> 。 但简而言之-这是一个使用模板和特殊的Map-ki Java对象生成文件的引擎。 您提供模板，对象，然后FreeMarker在输出中生成代码。 </p><br><p> 但是，请再次查看清单： </p><br><p><img src="https://habrastorage.org/webt/nf/hl/81/nfhl811qacot1f4j_pt2fhsmm8k.png" alt="图片"></p><br><p> 如果仔细观察，您会发现它分为两大组任务： </p><br><ul><li> 生成新代码（1、3、4、5、6、7、8）的任务，以及 </li><li> 修改现有代码的任务（2、7、8、9） </li></ul><br><p> 而且，如果FreeMarker能够应付第一组的任务，那么它根本就无法应付第二组的任务。 举一个小例子：在Android Studio中FreeMarker集成的当前实现中，当您尝试在settings.gradle文件中插入以'include'开头的行时， <a href="">Studio将会崩溃</a> 。 在这里，我们感到悲伤，并决定放弃使用FreeMarker。 </p><br><p>  FreeMarker失败后，想到了编写我自己的控制台实用程序来执行清单的想法。 在Intellij IDEA内部可以使用终端，为什么不呢？ 让我们在bash上写一个脚本，总的业务： </p><br><p><img src="https://habrastorage.org/webt/t0/2h/ki/t02hki4jlkvs_7eaqisfbuqnyb0.png" alt="图片"></p><br><p> 但是，由于我们希望能够灵活地配置所创建的模块，因此我们将不得不输入许多不同的标志，这在控制台中打印将不太方便。 </p><br><p> 之后，我们退后一步，并想起我们正在Intellij IDEA内部工作。 以及如何安排？ 有一定的类核心，引擎上附有许多插件，这些插件增加了我们所需的功能。 </p><br><p> 在屏幕快照中，有多少人看到了两个以上已连接的插件？ </p><br><p><img src="https://habrastorage.org/webt/rf/fr/dm/rffrdmuui00uxtruelogjpor_le.png" alt="图片"></p><br><div class="spoiler">  <b class="spoiler_title">在哪里看？</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/0m/uw/ua/0muwuamgty0p8kri2ywhq3dsbaw.png" alt="图片"></p></div></div><br><p> 在这里，它们至少连接三个。 如果您使用Kotlin，则您已启用Kotlin插件。 如果您正在使用Gradle处理项目，则还包括Gradle插件。 如果您在使用版本控制系统（Git，SVN或其他版本）的项目中工作，则将包含用于集成此VCS的适当插件。 </p><br><p> 我们调查了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">官方的</a> JetBrains <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">插件存储库</a> ，结果发现已经有4000多个正式注册的插件！ 几乎全世界都在写插件，这些插件可以做任何事情：从将编程语言集成到IDEA中开始，再到可以在IDEA中运行的特定工具结束。 </p><br><p> 简而言之，我们决定编写自己的插件。 </p><br><h1 id="osnovy-razrabotki-plaginov"> 插件开发基础 </h1><br><p> 我们继续介绍插件开发的基础知识。 首先，您只需要三件事： </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IntelliJ IDEA</a> ，最低社区版本（您可以使用Ultimate版本，但是在开发插件时不会带来特殊优势）； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">与之</a>相连的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">插件DevKit</a>是一个特殊的插件，它增加了编写其他插件的能力。 </li><li> 以及您要用来编写插件的任何JVM语言。 可能是Kotlin，Java，Groovy等等。 </li></ol><br><p> 我们首先创建一个插件项目。 我们选择<strong>New project</strong> ，指向<strong>Gradle</strong> ，勾选<strong>IntelliJ Platform Plugin</strong>并创建项目。 </p><br><p><img src="https://habrastorage.org/webt/je/rf/wd/jerfwdeqfmpzdef-_cypw4wahw8.png" alt="图片"></p><br><p> 注意：如果没有看到IntelliJ Platform Plugin复选框，则意味着您没有安装Plugin DevKit。 </p><br><p> 填写必填字段后，我们将看到一个空的插件结构。 </p><br><p><img src="https://habrastorage.org/webt/i2/sy/59/i2sy59dpr0pi8nlmhfyhson20h8.png" alt="图片"></p><br><p> 让我们仔细看看。 它包括： </p><br><ul><li> 您将在其中编写未来项目代码的文件夹；  （ <em>main / java</em> ， <em>main / kotlin</em>等）； </li><li>  <em>build.gradle</em>文件，您将在其中声明某些库上插件的依赖项，还将配置<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>gradle-intellij-plugin</em></a>这样的东西。 </li></ul><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>gradle-intellij-plugin</em></a> -Gradle插件，可让您将Gradle用作插件构建系统。 之所以方便，是因为几乎每个Android开发人员都熟悉Gradle并且知道如何使用它。 另外，gradle-intellij-plugin向您的项目添加了有用的gradle任务，尤其是： </p><br><ul><li>  runIde-此任务将使用您正在开发的插件启动一个单独的IDEA实例，以便您可以对其进行调试； </li><li>  buildPlugin-收集插件的zip存档，以便您可以在本地或通过官方IDEA存储库分发它； </li><li>  verifyPlugin-此任务检查您的插件是否存在严重错误，这些错误可能不允许其集成到Android Studio或某些其他IDEA中。 </li></ul><br><p>  <em>gradle-intellij-plugin还提供</em>什么？ 有了它的帮助，添加对其他插件的依赖关系变得更加容易，但是我们稍后再讨论，但是现在我可以说<em>gradle-intellij-plugin</em>是您的兄弟，请使用它。 </p><br><p> 回到插件结构。 任何插件中最重要的文件是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>plugin.xml</em></a> 。 </p><br><div class="spoiler">  <b class="spoiler_title">plugin.xml</b> <div class="spoiler_text"><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">idea-plugin</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">id</span></span></span><span class="hljs-tag">&gt;</span></span>com.experiment.simple.plugin<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">id</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span>Hello, world<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">vendor</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">email</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"myemail@yourcompany.com"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">url</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.mycompany.com"</span></span></span><span class="hljs-tag">&gt;</span></span> My company <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">vendor</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span>&lt;![CDATA[ My first ever plugin - try to open Hello world dialog&lt;br&gt; ]]&gt;<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">description</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">depends</span></span></span><span class="hljs-tag">&gt;</span></span>com.intellij.modules.lang<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">depends</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">depends</span></span></span><span class="hljs-tag">&gt;</span></span>org.jetbrains.kotlin<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">depends</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">depends</span></span></span><span class="hljs-tag">&gt;</span></span>org.intellij.groovy<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">depends</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">idea-version</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">since-build</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"163"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">actions</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">group</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">description</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"My actions"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"MyActionGroup"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">text</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"My actions"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">separator</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">action</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.experiment.actions.OpenHelloWorldAction"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.experiment.actions.OpenHelloWorldAction"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">text</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Show Hello world"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">description</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Open dialog"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">add-to-group</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">group-id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"NewGroup"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">anchor</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"last"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">action</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">group</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">actions</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">idea-plugin</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> </div></div><br><p> 该文件包含： </p><br><ul><li> 您的插件元数据：标识符，名称，描述，供应商信息，更改日志 </li><li> 对其他插件的依赖关系的描述； </li><li> 在这里，您还可以指定插件可以正常使用的IDEA版本 </li><li>  <em>动作</em>也在这里描述。 </li></ul><br><h3 id="actions"> 动作 </h3><br><p> 什么是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">动作</a> ？ 假设您打开一个菜单来创建一个新文件。 实际上，此菜单的每个元素都是通过某种插件添加的： </p><br><p><img src="https://habrastorage.org/webt/al/8y/kg/al8ykgojltbksqkuqu5l8cww4fw.png" alt="图片"></p><br><p> 操作是用户插件的入口点。 每次用户单击菜单项时，都可以在插件内部进行控制，您可以响应此单击并执行必要的操作。 <br> 如何创建动作？ 让我们编写一个简单的动作，该动作将显示一个带有消息“ Hello，World”的对话框。 </p><br><div class="spoiler">  <b class="spoiler_title">OpenHelloWorldAction</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpenHelloWorldAction</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AnAction</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actionPerformed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(actionEvent: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AnActionEvent</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> project = actionEvent.project Messages.showMessageDialog( project, <span class="hljs-string"><span class="hljs-string">"Hello world!"</span></span>, <span class="hljs-string"><span class="hljs-string">"Greeting"</span></span>, Messages.getInformationIcon() ) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AnActionEvent</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.update(e) <span class="hljs-comment"><span class="hljs-comment">// TODO - Here we can update our action (for example, disable it) } override fun beforeActionPerformedUpdate(e: AnActionEvent) { super.beforeActionPerformedUpdate(e) // TODO - This method calls right before 'actionPerformed' } }</span></span></code> </pre> </div></div><br><p> 为了创建一个动作，我们首先创建一个从<em>AnAction</em>类继承的类。 其次，我们必须重新定义actionPerformed方法，其中<em>AnActionEvent</em>类的特殊参数<em>来自</em> 。 此参数包含有关您的操作的执行上下文的信息。 上下文是指您在其中工作的项目，现在在用户代码编辑器中打开的文件，在项目树中选择的元素以及其他有助于处理任务的数据。 </p><br><p> 为了显示“ Hello，world”对话框，我们首先获取项目（仅从<em>AnActionEvent</em>参数中获取），然后使用实用程序类<em>Messages</em>来显示对话框。 </p><br><p> 我们在Action中拥有哪些<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">其他功能</a> ？ 我们可以重写两个方法： <em>update</em>和<em>beforeActionPerformedUpdate</em> 。 </p><br><p> 每当您的Action的执行上下文更改时，都会调用<em>update</em>方法。 为什么对您有用：例如，更新插件添加的菜单项。 假设您编写了只能使用Kotlin文件的Action，并且用户现在已经打开了Groovy文件。 然后，在更新方法中，您可以使操作不可访问。 </p><br><p>  <em>beforeActionPerformedUpdate</em>方法类似于update方法，但是在<em>actionPerformed</em>之前被调用。 这是影响您行动的最后机会。 文档建议您不要在此方法中执行任何“繁重的操作”，以使其尽快运行。 </p><br><p> 您还可以将Actions绑定到IDEA界面的某些元素，并为它们设置默认的按键组合以进行调用-我建议<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>阅读更多内容。 </p><br><h3 id="razrabotka-ui-v-plaginah"> 插件中的UI开发 </h3><br><p> 如果您需要自己的对话框设计，则必须努力工作。 我们开发UI是因为我们希望拥有一个方便的图形界面，在其中可以标记一些刻度线，并为枚举值提供选择器，等等。 </p><br><p> 用于开发UI的插件DevKit添加了一些操作，例如<em>GUI form</em>和<em>Dialog</em> 。 第一个为我们创建一个空表单，第二个为带有两个按钮的表单： <em>Ok</em>和<em>Cancel</em> 。 </p><br><p><img src="https://habrastorage.org/webt/wd/bx/3r/wdbx3rhggovpfv-fey53fucs2aw.png" alt="图片"></p><br><p> 好的， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有一位表单设计师</a> ，但他是…一般。 相比之下，即使是Android Studio中的布局设计器，看起来也很舒适。 整个UI是在Java Swing之类的库上开发的。 该表单设计器生成人类可读的XML文件。 如果您无法在表单设计器中执行任何操作（例如：在同一个网格单元中插入多个控件并隐藏其中的一个控件，则全部隐藏），则需要转到此文件并进行更改-IDEA会选择这些更改。 </p><br><p> 几乎每种形式都由两个文件组成：第一个文件具有扩展名<em>.form</em> ，这只是XML文件，第二个是所谓的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>Bound类</em></a> ，可以用Java，Kotlin或任何您想要的语言编写。 它充当表单控制器。 出乎意料，但是用Java编写比使用其他语言容易得多。 例如，因为对Kotlin的调音还不是很完美。 在使用Java类添加新组件时，这些组件会自动添加到类中，并且在设计器中更改组件名称时，会自动将其拉出。 但是对于Kotlin，不添加任何组件-不会发生集成，您可能会忘记一些东西，但不了解为什么什么都不起作用。 </p><br><h3 id="rezyumiruem-osnovy"> 我们总结基础知识 </h3><br><ul><li> 要创建插件，您将需要：IDEA社区版，插件DevKit和与其连接的Java。 </li><li>  gradle-intellij-plugin是您的兄弟，它将大大简化您的生活，我建议您使用它。 </li><li> 除非必要，否则不要编写自己的UI。  IDEA中有许多实用程序类，它们使您可以立即创建自己的UI。 如果您需要复杂的东西，请准备好努力工作。 </li><li> 该插件可以具有任意数量的动作。 相同的插件可以为您的IDEA添加很多功能。 </li></ul><br><h1 id="vnutrennosti-idea-komponenty-psi">  IDEA内部：组件，PSI </h1><br><p> 让我们讨论一下IDEA的肠道，以及它在内部的排列方式。 我告诉您，当我讲解实际部分时，您的脑海不会崩溃，以便您了解其来源。 </p><br><p>  IDEA如何安排？ 在层次结构的第一层是一个类，例如<a href=""><em>Application</em></a> 。 这是一个单独的IDEA实例。 对于每个IDEA实例，将创建一个Application类对象。 例如，如果您同时运行AppCode，Intellij IDEA，Android Studio，则将获得Application类的三个单独的实例。 此类旨在处理输入/输出流。 </p><br><div class="spoiler">  <b class="spoiler_title">将应用程序放置在层次结构中</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/rw/_y/vm/rw_yvmpfn1hyekftipxwuq-qxn8.png" alt="图片"></p></div></div><br><p> 下一个级别是<a href=""><em>Project</em></a>类。 这是与在IDEA中打开新项目时看到的最接近的概念。 通常需要Project才能在IDEA中获得其他组件：实用程序类，管理器等等。 </p><br><div class="spoiler">  <b class="spoiler_title">项目在层次结构中的位置</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xv/ku/z6/xvkuz6ezzzd5w5_c9suloyafcza.png" alt="图片"></p></div></div><br><p> 下一个详细级别是<a href=""><em>Module</em></a>类。 通常，模块是分组到一个文件夹中的类的层次结构。 但是这里的模块是指Maven模块，Gradle模块。 首先，需要使用此类来确定模块之间的依赖性，其次，要在这些模块内搜索类。 </p><br><div class="spoiler">  <b class="spoiler_title">将模块放置在层次结构中</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/zr/vs/ah/zrvsahicec7gak2sfqhox2ldts0.png" alt="图片"></p></div></div><br><p> 下一级别的细节是<a href=""><em>VirtualFile</em></a>类。 这是磁盘上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">真实文件</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">抽象</a> 。 多个<em>VirtualFile</em>实例可以对应于每个真实文件，但是它们都相等。 同时，如果删除了真实文件，则<em>VirtualFile</em>将不会自行删除，而只会变得无效。 </p><br><div class="spoiler">  <b class="spoiler_title">VirtualFile层次结构位置</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/z8/4y/hq/z84yhqyl6tzv-1uwc_ersyhmqv0.png" alt="图片"></p></div></div><br><p> 诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>Document之类</em></a> <em>的</em>实体与每个<em>VirtualFile</em>相关联。 它是文件文本的抽象。 需要<em>文档</em> ，以便您可以跟踪与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文件文本更改</a>相关的事件：用户插入行，删除行等，等等。 </p><br><div class="spoiler">  <b class="spoiler_title">将文档放入层次结构</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/fr/nc/qg/frncqgrdpc3xgtnn_txrhlvdcv0.png" alt="图片"></p></div></div><br><p> 这个层次结构的另一端是<a href=""><em>Editor</em></a>类-它是一个代码编辑器。 每个项目可以有一个<em>编辑器</em> 。 需要它以便跟踪与代码编辑器有关的事件：用户突出显示了插入符号所在的行，依此类推。 </p><br><div class="spoiler">  <b class="spoiler_title">编辑者在层次结构中的位置</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/fk/kj/l-/fkkjl-c-t5nyehcwt6j-ywdhwf0.png" alt="图片"></p></div></div><br><p> 我想谈的最后一件事是<a href=""><em>PsiFile</em></a> 。 这也是对真实文件的抽象，但是从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">表示代码元素</a>的角度来看。  PSI代表程序结构接口。 </p><br><div class="spoiler">  <b class="spoiler_title">PsiFile在层次结构中的位置</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ho/kn/l0/hoknl08rk2giwbxure86b3pqcva.png" alt="图片"></p></div></div><br><p> 每个程序由什么组成？ 考虑一个普通的Java类。 </p><br><div class="spoiler">  <b class="spoiler_title">普通的Java类</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.experiment; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.inject.Inject; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> String injectedString; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(injectedString); } }</code> </pre> </div></div><br><p> 它由指定包，导入，类，字段，方法，注释，关键字，数据类型，修饰符，标识符，方法引用，表达式和标记组成。 并且对于每个元素都有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>PsiElement</em></a>的抽象。 也就是说，每个程序都由<em>PsiElements</em>组成。 </p><br><p><img src="https://habrastorage.org/webt/ps/oa/2t/psoa2timve59g__naf1rrskzfdm.png" alt="图片"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">而PsiFile</a>是一种树结构，其中每个元素可以有一个父代和许多后代。 </p><br><p><img src="https://habrastorage.org/webt/mi/4j/f2/mi4jf2mdcqjc1huurmu2ca0hsfi.png" alt="图片"></p><br><p> 我想提一下，PSI不等于<strong>抽象语法树</strong> 。 抽象语法树是解析器通过您的程序后程序的表示树，并且它与任何编程语言都<strong>分离</strong> 。 相反，PSI与特定的编程语言相关。 当您使用Java类时，您正在处理Java PsiElement。 使用Groovy类时-使用Groovy PsiElements等等。   ,         PSI-  -  ,      ,   , –    . </p><br><p>      PSI –   PSI-   IDEA.            ,    ,        ,   .         . </p><br><h3 id="rezyumiruem-chast-pro-vnutrennosti-idea">     IDEA </h3><br><ul><li> PSI      IDEA; </li><li> PSI-   IDEA,            ; </li><li>         PsiElement-. </li></ul><br><p>      ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> .            . </p><br><h2 id="dopolnitelnye-materialy-po-plaginostroeniyu">     </h2><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">     </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">   ,    </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  Tool window</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">    </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">    </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">      IntelliJ IDEA</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">       IDEA</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">      IntelliJ IDEA</a> </li><li>   , , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a>     .    ,     . </li><li>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  Droidcon Italy 2017</a> ,  ,   , ,        FreeMarker- .        ,      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">   KotlinConf</a> ,     Square       SQLDelight,        Java,   Kotlin. </li></ul></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN463583/">https://habr.com/ru/post/zh-CN463583/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN463573/index.html">首款基于Zen 2架构的数据中心芯片</a></li>
<li><a href="../zh-CN463575/index.html">培训Cisco 200-125 CCNA v3.0。 第22天，第三个CCNA：继续学习RIP</a></li>
<li><a href="../zh-CN463577/index.html">可塑性和强度：金属间化合物的硬化而不强调位错</a></li>
<li><a href="../zh-CN463579/index.html">Windows：找出谁登录</a></li>
<li><a href="../zh-CN463581/index.html">培训Cisco 200-125 CCNA v3.0。 第23天。先进的路由技术</a></li>
<li><a href="../zh-CN463585/index.html">培训Cisco 200-125 CCNA v3.0。 第24天。IPv6</a></li>
<li><a href="../zh-CN463587/index.html">ConfigureAwait，应该归咎于谁和怎么办？</a></li>
<li><a href="../zh-CN463591/index.html">BlueKeep-2-Windows的所有新版本现在都容易受到攻击</a></li>
<li><a href="../zh-CN463595/index.html">我们控制网络摄像头的焦点或少量C＃和STM32</a></li>
<li><a href="../zh-CN463597/index.html">在React中使用Context API创建响应式应用程序设计</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>