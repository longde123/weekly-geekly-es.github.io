<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåä üë©‚Äçüëß‚Äçüëß ‚ôæ Analyse du code de ROOT, cadre d'analyse des donn√©es scientifiques üë©üèΩ‚Äç‚úàÔ∏è üçè ü§µ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alors que Stockholm organisait la 118e semaine Nobel, j'√©tais assis dans notre bureau, o√π nous d√©veloppons l'analyseur statique PVS-Studio, travaillan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyse du code de ROOT, cadre d'analyse des donn√©es scientifiques</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/472492/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df2/7f4/bcd/df27f4bcd139790b322570ee2f48e1ab.png" alt="Image 3"></div>  Alors que Stockholm organisait la 118e semaine Nobel, j'√©tais assis dans notre bureau, o√π nous d√©veloppons l'analyseur statique PVS-Studio, travaillant sur une revue d'analyse du projet ROOT, un cadre de traitement des m√©gadonn√©es utilis√© dans la recherche scientifique.  Ce code ne gagnerait pas de prix, bien s√ªr, mais les auteurs peuvent certainement compter sur un examen d√©taill√© des d√©fauts les plus int√©ressants et une licence gratuite pour v√©rifier eux-m√™mes le projet. <br><br><h2>  Pr√©sentation </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a89/187/f04/a89187f045bbcb2b5b8d5ab7c9dc7da1.png" alt="Image 1"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ROOT</a> est une bo√Æte √† outils logicielle scientifique modulaire.  Il fournit toutes les fonctionnalit√©s n√©cessaires au traitement du big data, √† l'analyse statistique, √† la visualisation et au stockage.  Il est principalement √©crit en C ++.  ROOT est n√© au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CERN</a> , au c≈ìur de la recherche en physique des hautes √©nergies.  Chaque jour, des milliers de physiciens utilisent des applications ROOT pour analyser leurs donn√©es ou effectuer des simulations. <br><a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PVS-Studio</a> est un outil pour d√©tecter les bogues logiciels et les vuln√©rabilit√©s potentielles dans le code source des programmes √©crits en C, C ++, C # et Java.  Il fonctionne sur Windows 64 bits, Linux et macOS et peut analyser le code source √©crit pour les plates-formes ARM 32 bits, 64 bits et int√©gr√©es. <br><br><h2>  Les d√©buts d'un nouveau diagnostic </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V1046</a> Utilisation non <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">s√ªre</a> des types bool 'et' int 'ensemble dans l'op√©ration' &amp; = '.  GSLMultiRootFinder.h 175 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ROOT::Math::IMultiGenFunction &amp; func)</span></span></span><span class="hljs-function"> </span></span>{ ROOT::Math::IMultiGenFunction * f = func.Clone(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!f) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; fFunctions.push_back(f); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fFunctions.size(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FuncIterator</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SetFunctionList</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FuncIterator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">begin</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FuncIterator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ret = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (FuncIterator itr = begin; itr != end; ++itr) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ROOT::Math::IMultiGenFunction * f = *itr; ret &amp;= AddFunction(*f); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre> <br>  Tout d'abord, voici un merveilleux bug trouv√© par la version b√™ta de PVS-Studio, que j'utilisais pour cet examen. <br><br>  <b>Les attentes</b>  La fonction <i>SetFunctionList</i> traverse une liste d'it√©rateurs.  Si au moins un it√©rateur n'est pas valide, la fonction renvoie <i>false</i> , ou <i>true</i> sinon. <br><br>  <b>La r√©alit√©</b>  La fonction <i>SetFunctionList</i> peut retourner <i>false</i> m√™me pour les it√©rateurs valides.  Voyons pourquoi.  La fonction <i>AddFunction</i> renvoie le nombre d'it√©rateurs valides dans la liste <i>fFunctions</i> .  Autrement dit, l'ajout d'it√©rateurs non nuls entra√Ænera une augmentation incr√©mentielle de la liste: 1, 2, 3, 4, etc.  C'est l√† que le bug entre en jeu: <br><br><pre> <code class="cpp hljs">ret &amp;= AddFunction(*f);</code> </pre> <br>  √âtant donn√© que la fonction renvoie une valeur de type <i>int</i> plut√¥t que <i>bool</i> , l'op√©ration '&amp; =' renvoie <i>false</i> pour les valeurs paires car le bit le moins significatif d'un nombre pair est toujours d√©fini sur z√©ro.  C'est ainsi qu'un bug subtil peut casser la valeur de retour de <i>SetFunctionsList</i> m√™me lorsque ses arguments sont valides. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa4/c23/64f/aa4c2364f5205b526db1625aeebd32ff.png" alt="Image 2"></div><br><h2>  Erreurs dans les expressions conditionnelles </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V501</a> Il existe des sous-expressions identiques √† gauche et √† droite de l'op√©rateur '&amp;&amp;': module &amp;&amp; module rootcling_impl.cxx 3650 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleDiagnostic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> override </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isROOTSystemModuleDiag = <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> &amp;&amp; ....; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isSystemModuleDiag = <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>-&gt;IsSystem; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isROOTSystemModuleDiag &amp;&amp; !isSystemModuleDiag) fChild-&gt;HandleDiagnostic(DiagLevel, Info); .... }</code> </pre> <br>  Commen√ßons par le bug le moins nuisible.  Le pointeur du <i>module</i> est v√©rifi√© deux fois.  L'un des contr√¥les est probablement redondant, mais il serait toujours judicieux de le corriger pour √©viter toute confusion √† l'avenir. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V501</a> Il existe des sous-expressions identiques 'strchr (fHostAuth-&gt; GetHost (),' * ')' √† gauche et √† droite de '||'  op√©rateur.  TAuthenticate.cxx 300 <br><br><pre> <code class="cpp hljs">TAuthenticate::TAuthenticate(TSocket *sock, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *remote, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *proto, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *user) { .... <span class="hljs-comment"><span class="hljs-comment">// If generic THostAuth (ie with wild card or user == any) // make a personalized memory copy of this THostAuth if (strchr(fHostAuth-&gt;GetHost(),'*') || strchr(fHostAuth-&gt;GetHost(),'*') || fHostAuth-&gt;GetServer() == -1 ) { fHostAuth = new THostAuth(*fHostAuth); fHostAuth-&gt;SetHost(fqdn); fHostAuth-&gt;SetUser(checkUser); fHostAuth-&gt;SetServer(servtype); } .... }</span></span></code> </pre> <br>  La <i>cha√Æne fHostAuth-&gt; GetHost ()</i> est analys√©e deux fois pour le caract√®re '*'.  L'une de ces v√©rifications √©tait probablement destin√©e √† rechercher le ¬´?¬ª  car ces deux caract√®res sont g√©n√©ralement ceux utilis√©s pour sp√©cifier divers masques g√©n√©riques. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V517</a> L'utilisation du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mod√®le</a> 'if (A) {...} else if (A) {...}' a √©t√© d√©tect√©e.  Il y a une probabilit√© de pr√©sence d'erreur logique.  V√©rifiez les lignes: 163, 165. TProofMonSenderML.cxx 163 <br><br><pre> <code class="cpp hljs">Int_t TProofMonSenderML::SendSummary(TList *recs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *id) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fSummaryVrs == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((dsn = recs-&gt;FindObject(<span class="hljs-string"><span class="hljs-string">"dataset"</span></span>))) recs-&gt;Remove(dsn); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fSummaryVrs == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Only the first records xrecs = new TList; xrecs-&gt;SetOwner(kFALSE); TIter nxr(recs); TObject *o = 0; while ((o = nxr())) { if (!strcmp(o-&gt;GetName(), "vmemmxw")) break; xrecs-&gt;Add(o); } } .... }</span></span></code> </pre> <br>  La variable <i>fSummaryVrs</i> est compar√©e √† z√©ro deux fois, donc l'ex√©cution n'atteint jamais le code dans la branche <i>else-if</i> .  Et il y a pas mal de code l√†-dedans ... <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V523</a> L' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instruction</a> 'then' est √©quivalente √† l'instruction 'else'.  TKDTree.cxx 805 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Index, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Value&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TKDTree&lt;Index, Value&gt;::UpdateRange(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (point[fAxis[inode]]&lt;=fValue[inode]){ <span class="hljs-comment"><span class="hljs-comment">//first examine the node that contains the point UpdateRange(GetLeft(inode),point, range, res); UpdateRange(GetRight(inode),point, range, res); } else { UpdateRange(GetLeft(inode),point, range, res); UpdateRange(GetRight(inode),point, range, res); } .... }</span></span></code> </pre> <br>  Le m√™me bloc de code, qui est un clone copier-coller, est ex√©cut√© quelle que soit la condition.  Je suppose qu'il y a une confusion entre les mots <i>gauche</i> et <i>droite</i> . <br><br>  Le projet est plein de points suspects comme √ßa: <br><br><ul><li>  V523 L'instruction 'then' est √©quivalente √† l'instruction 'else'.  TContainerConverters.cxx 51 </li><li>  V523 L'instruction 'then' est √©quivalente √† l'instruction 'else'.  TWebFile.cxx 1310 </li><li>  V523 L'instruction 'then' est √©quivalente √† l'instruction 'else'.  MethodMLP.cxx 423 </li><li>  V523 L'instruction 'then' est √©quivalente √† l'instruction 'else'.  RooAbsCategory.cxx 394 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V547 L'</a> expression '! File_name_value.empty ()' est toujours fausse.  SelectionRules.cxx 1423 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> SelectionRules::AreAllSelectionRulesUsed() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; rule : fClassSelectionRules){ .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file_name_value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rule.GetAttributeValue(<span class="hljs-string"><span class="hljs-string">"file_name"</span></span>, file_name_value)) file_name_value.clear(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!file_name_value.empty()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= // don't complain about defined_in rules continue; } const char* attrName = nullptr; const char* attrVal = nullptr; if (!file_name_value.empty()) { // &lt;= attrName = "file name"; attrVal = file_name_value.c_str(); } else { attrName = "class"; if (!name.empty()) attrVal = name.c_str(); } ROOT::TMetaUtils::Warning(0,"Unused %s rule: %s\n", attrName, attrVal); } .... }</span></span></code> </pre> <br>  Ce n'est probablement pas un bug;  l'analyseur vient de trouver du code qui peut √™tre simplifi√©.  √âtant donn√© que la valeur de retour de <i>file_name_value.empty ()</i> est d√©j√† v√©rifi√©e au d√©but de la boucle, la deuxi√®me v√©rification en double peut √™tre supprim√©e, jetant ainsi une bonne quantit√© de code inutile. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V590</a> Envisagez d'inspecter le '! File1 ||  c &lt;= 0 ||  c == '*' ||  c! = '(' 'expression. L'expression est excessive ou contient une erreur d'impression. TTabCom.cxx 840 <br><br><pre> <code class="cpp hljs">TString TTabCom::DetermineClass(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> varName[]) { .... c = file1.get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!file1 || c &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || c == <span class="hljs-string"><span class="hljs-string">'*'</span></span> || c != <span class="hljs-string"><span class="hljs-string">'('</span></span>) { Error(<span class="hljs-string"><span class="hljs-string">"TTabCom::DetermineClass"</span></span>, <span class="hljs-string"><span class="hljs-string">"variable \"%s\" not defined?"</span></span>, varName); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> cleanup; } .... }</code> </pre> <br>  Voici la partie probl√©matique de l'expression conditionnelle signal√©e par l'analyseur: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (.... || c == <span class="hljs-string"><span class="hljs-string">'*'</span></span> || c != <span class="hljs-string"><span class="hljs-string">'('</span></span>) { .... }</code> </pre> <br>  La v√©rification du caract√®re ast√©risque n'affectera pas le r√©sultat de la condition.  Cette partie sera toujours vraie pour tout personnage autre que '('. Vous pouvez facilement le v√©rifier par vous-m√™me en dessinant une table de v√©rit√©. <br><br>  Deux autres avertissements sur les conditions avec une logique √©trange: <br><br><ul><li>  V590 Envisagez d'inspecter cette expression.  L'expression est excessive ou contient une erreur d'impression.  TFile.cxx 3963 </li><li>  V590 Envisagez d'inspecter cette expression.  L'expression est excessive ou contient une erreur d'impression.  TStreamerInfoActions.cxx 3084 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V593</a> Envisagez de revoir l'expression du type ¬´A = B &lt;C¬ª.  L'expression est calcul√©e comme suit: ¬´A = (B &lt;C)¬ª.  TProofServ.cxx 1903 <br><br><pre> <code class="cpp hljs">Int_t TProofServ::HandleSocketInput(TMessage *mess, Bool_t all) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Int_t ret = fProof-&gt;AddWorkers(workerList) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Error(<span class="hljs-string"><span class="hljs-string">"HandleSocketInput:kPROOF_GETSLAVEINFO"</span></span>, <span class="hljs-string"><span class="hljs-string">"adding a list of worker nodes returned: %d"</span></span>, ret); } .... }</code> </pre> <br>  Ce bogue ne se r√©v√®le que dans le cas d'un comportement d√©fectueux du programme.  La variable <i>ret</i> est cens√©e stocker le code retour de la fonction <i>AddWorkers</i> et √©crire cette valeur dans le journal en cas de condition d'erreur.  Mais cela ne fonctionne pas comme pr√©vu.  La condition manque de parenth√®ses suppl√©mentaires for√ßant l'ordre d'√©valuation souhait√©.  Ce que la variable <i>ret</i> stocke r√©ellement n'est pas le code retour mais le r√©sultat de la comparaison logique, c'est-√†-dire 0 ou 1. <br><br>  Un autre probl√®me similaire: <br><br><ul><li>  V593 Envisagez de revoir l'expression du type ¬´A = B &lt;C¬ª.  L'expression est calcul√©e comme suit: ¬´A = (B &lt;C)¬ª.  TProofServ.cxx 3897 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V768</a> La constante d'√©num√©ration 'kCostComplexityPruning' est utilis√©e comme variable de type bool√©en.  MethodDT.cxx 283 <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EPruneMethod {kExpectedErrorPruning=<span class="hljs-number"><span class="hljs-number">0</span></span>, kCostComplexityPruning, kNoPruning}; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TMVA::MethodDT::ProcessOptions() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fPruneStrength &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) fAutomatic = kTRUE; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> fAutomatic = kFALSE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fAutomatic &amp;&amp; fPruneMethod==!DecisionTree::kCostComplexityPruning){ Log() &lt;&lt; kFATAL &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Sorry automatic pruning strength determination is ...."</span></span> &lt;&lt; Endl; } .... }</code> </pre> <br>  Hm ... Pourquoi annuler la valeur constante <i>kCostComplexityPruning</i> ?  Je soup√ßonne que le caract√®re de n√©gation est une faute de frappe, ce qui fausse maintenant la logique d'ex√©cution. <br><br><h2>  Erreurs de gestion du pointeur </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V522 Le</a> d√©r√©f√©rencement du pointeur nul ¬´pre¬ª peut avoir lieu.  TSynapse.cxx 61 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TSynapse::SetPre(TNeuron * pre) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pre) { Error(<span class="hljs-string"><span class="hljs-string">"SetPre"</span></span>,<span class="hljs-string"><span class="hljs-string">"this synapse is already assigned to a pre-neuron."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } fpre = pre; pre-&gt;AddPost(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  J'ai fait de mon mieux pour comprendre cet √©trange code, et il semble que l'id√©e √©tait d'√©viter d'attribuer une nouvelle valeur au champ <i>fpre</i> .  Si c'est le cas, le programmeur v√©rifie accidentellement le mauvais pointeur.  L'impl√©mentation actuelle conduit √† d√©r√©f√©rencer un pointeur null si vous transmettez la valeur <i>nullptr</i> √† la fonction <i>SetPre</i> . <br><br>  Je pense que cet extrait devrait √™tre corrig√© comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TSynapse::SetPre(TNeuron * pre) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fpre) { Error(<span class="hljs-string"><span class="hljs-string">"SetPre"</span></span>,<span class="hljs-string"><span class="hljs-string">"this synapse is already assigned to a pre-neuron."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } fpre = pre; pre-&gt;AddPost(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Cependant, cela n'emp√™cherait pas le passage d'un pointeur nul √† la fonction, mais au moins cette version est plus coh√©rente logiquement que la version d'origine. <br><br>  Un clone l√©g√®rement modifi√© de ce code peut √™tre trouv√© √† un autre endroit: <br><br><ul><li>  V522 Le d√©r√©f√©rencement du pointeur nul ¬´post¬ª peut avoir lieu.  TSynapse.cxx 74 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V595</a> Le pointeur 'N' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† nullptr.  V√©rifiez les lignes: 484, 488. Scanner.cxx 484 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> RScanner::shouldVisitDecl(clang::NamedDecl *D) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> M = D-&gt;getOwningModule()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= 2 return fInterpreter.getSema().isModuleVisible(M); } return true; } bool RScanner::VisitNamespaceDecl(clang::NamespaceDecl* N) { if (fScanType == EScanType::kOnePCM) return true; if (!shouldVisitDecl(N)) // &lt;= 1 return true; if((N &amp;&amp; N-&gt;isImplicit()) || !N){ // &lt;= 3 return true; } .... }</span></span></code> </pre> <br>  C'est un morceau de code extr√™mement dangereux!  Le pointeur <i>N</i> n'est pas v√©rifi√© pour null avant qu'il ne soit d√©r√©f√©renc√© la premi√®re fois.  De plus, vous ne pouvez pas voir cela se produire ici car la d√©r√©f√©rence a lieu √† l'int√©rieur de la fonction <i>shouldVisitDecl</i> . <br><br>  Ce diagnostic g√©n√®re traditionnellement un ensemble d'avertissements pertinents.  Voici quelques exemples: <br><br><ul><li>  V595 Le pointeur ¬´fichier¬ª a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† nullptr.  V√©rifiez les lignes: 141, 153. TFileCacheRead.cxx 141 </li><li>  V595 Le pointeur 'fFree' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† nullptr.  V√©rifiez les lignes: 2029, 2038. TFile.cxx 2029 </li><li>  V595 Le pointeur 'tbuf' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† nullptr.  V√©rifier les lignes: 586, 591. TGText.cxx 586 </li><li>  V595 Le pointeur 'fPlayer' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† nullptr.  V√©rifiez les lignes: 3425, 3430. TProof.cxx 3425 </li><li>  V595 Le pointeur 'gProofServ' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† nullptr.  V√©rifiez les lignes: 1192, 1194. TProofPlayer.cxx 1192 </li><li>  V595 Le pointeur 'projDataTmp' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† nullptr.  V√©rifiez les lignes: 791, 804. RooSimultaneous.cxx 791 </li></ul><br>  Le suivant n'est pas un bogue, mais c'est encore un autre exemple de la fa√ßon dont les macros <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">encouragent l'</a> √©criture de code d√©fectueux ou redondant. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V571 Contr√¥le</a> r√©current.  La condition ¬´if (fCanvasImp)¬ª a d√©j√† √©t√© v√©rifi√©e √† la ligne 799. TCanvas.cxx 800 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SafeDelete(p) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (p) { delete p; p = 0; } } void TCanvas::Close(Option_t *option) { .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (fCanvasImp) SafeDelete(fCanvasImp); .... }</span></span></code> </pre> <br>  Le pointeur <i>fCanvasImp</i> est v√©rifi√© deux fois, l'une des v√©rifications √©tant d√©j√† impl√©ment√©e dans la macro <i>SafeDelete</i> .  L'un des probl√®mes avec les macros est qu'elles sont difficiles √† naviguer √† partir du code, c'est pourquoi de nombreux programmeurs n'examinent pas leur contenu avant utilisation. <br><br><h2>  Erreurs de gestion des baies </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V519</a> La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">variable</a> 'Line [Cursor]' re√ßoit des valeurs successives deux fois.  C'est peut-√™tre une erreur.  V√©rifiez les lignes: 352, 353. Editor.cpp 353 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> find_last_non_alnum(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;str, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::size_type index = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos) { .... <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> tmp = Line.GetText()[Cursor]; Line[Cursor] = Line[Cursor - <span class="hljs-number"><span class="hljs-number">1</span></span>]; Line[Cursor] = tmp; .... }</code> </pre> <br>  L'√©l√©ment <i>Line [Cursor]</i> se voit attribuer une nouvelle valeur, qui est alors imm√©diatement √©cras√©e.  Cela ne semble pas correct ... <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V557 Le</a> d√©passement de matrice est possible.  L'index ¬´ivar¬ª pointe au-del√† de la limite du tableau.  BasicMinimizer.cxx 130 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> BasicMinimizer::SetVariableValue(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ivar, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> val) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ivar &gt; fValues.size() ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; fValues[ivar] = val; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Faire cette erreur lors de la v√©rification des index de tableau est une tendance r√©cente;  nous le voyons dans presque tous les trois projets.  Bien que l'indexation dans un tableau √† l'int√©rieur d'une boucle soit facile - vous utilisez g√©n√©ralement l'op√©rateur '&lt;' pour comparer l'index √† la taille du tableau - les v√©rifications comme celle illustr√©e ci-dessus n√©cessitent l'op√©rateur '&gt; =', pas '&gt;'.  Sinon, vous risquez d'indexer un √©l√©ment au-del√† de la limite du tableau. <br><br>  Ce bug a √©t√© clon√© plusieurs fois dans le code: <br><br><ul><li>  V557 Le d√©passement de matrice est possible.  L'index ¬´ivar¬ª pointe au-del√† de la limite du tableau.  BasicMinimizer.cxx 186 </li><li>  V557 Le d√©passement de matrice est possible.  L'index ¬´ivar¬ª pointe au-del√† de la limite du tableau.  BasicMinimizer.cxx 194 </li><li>  V557 Le d√©passement de matrice est possible.  L'index ¬´ivar¬ª pointe au-del√† de la limite du tableau.  BasicMinimizer.cxx 209 </li><li>  V557 Le d√©passement de matrice est possible.  L'index ¬´ivar¬ª pointe au-del√† de la limite du tableau.  BasicMinimizer.cxx 215 </li><li>  V557 Le d√©passement de matrice est possible.  L'index ¬´ivar¬ª pointe au-del√† de la limite du tableau.  BasicMinimizer.cxx 230 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V621</a> Envisagez d'inspecter l'op√©rateur ¬´pour¬ª.  Il est possible que la boucle soit mal ex√©cut√©e ou ne soit pas ex√©cut√©e du tout.  TDataMember.cxx 554 <br><br><pre> <code class="cpp hljs">Int_t TDataMember::GetArrayDim() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fArrayDim&lt;<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; fInfo) { R__LOCKGUARD(gInterpreterMutex); TDataMember *dm = <span class="hljs-keyword"><span class="hljs-keyword">const_cast</span></span>&lt;TDataMember*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); dm-&gt;fArrayDim = gCling-&gt;DataMemberInfo_ArrayDim(fInfo); <span class="hljs-comment"><span class="hljs-comment">// fArrayMaxIndex should be zero if (dm-&gt;fArrayDim) { dm-&gt;fArrayMaxIndex = new Int_t[fArrayDim]; for(Int_t dim = 0; dim &lt; fArrayDim; ++dim) { dm-&gt;fArrayMaxIndex[dim] = gCling-&gt;DataMemberInfo_MaxIndex(fInfo,dim); } } } return fArrayDim; }</span></span></code> </pre> <br>  Dans la boucle <i>for</i> , les d√©veloppeurs ont apparemment voulu comparer la variable <i>dim</i> avec <i>dm-&gt; fArrayDim</i> plut√¥t que <i>fArrayDim</i> .  La valeur de <i>fArrayDim</i> est n√©gative, ce qui est garanti par la condition au d√©but de la fonction.  Par cons√©quent, cette boucle ne s'ex√©cutera jamais. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V767</a> Acc√®s suspect √† l'√©l√©ment du tableau 'courant' par un index constant √† l'int√©rieur d'une boucle.  TClingUtils.cxx 3082 <br><br><pre> <code class="cpp hljs">llvm::StringRef ROOT::TMetaUtils::DataMemberInfo__ValidArrayIndex(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current!=<span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Check the token if (isdigit(current[0])) { for(i=0;i&lt;strlen(current);i++) { if (!isdigit(current[0])) { if (errstr) *errstr = current; if (errnum) *errnum = NOT_INT; return llvm::StringRef(); } } } else { // current token is not a digit .... } .... } .... }</span></span></code> </pre> <br>  Ce code analyse et v√©rifie une cha√Æne.  Si le premier caract√®re de la cha√Æne <i>actuelle</i> (c'est-√†-dire √† l'index 0) a √©t√© reconnu comme un nombre, la boucle traversera tous les caract√®res restants pour s'assurer que tous sont des nombres.  Eh bien, c'est du moins l'id√©e.  Le probl√®me est que le compteur <i>i</i> n'est pas utilis√© dans la boucle.  La condition doit √™tre r√©√©crite afin qu'elle v√©rifie le <i>courant [i]</i> plut√¥t que le <i>courant [0]</i> . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16e/c09/97a/16ec0997a4c29ce4a257d4124cf63ce2.png" alt="Image 4"></div><br><h2>  Fuite de m√©moire </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V773</a> La fonction a √©t√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ferm√©e</a> sans rel√¢cher le pointeur ¬´liste d'options¬ª.  Une fuite de m√©moire est possible.  TDataMember.cxx 355 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TDataMember::Init(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> afterReading) { .... TList *optionlist = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TList(); <span class="hljs-comment"><span class="hljs-comment">//storage for options strings for (i=0;i&lt;token_cnt;i++) { if (strstr(tokens[i],"Items")) { ptr1 = R__STRTOK_R(tokens[i], "()", &amp;rest); if (ptr1 == 0) { Fatal("TDataMember","Internal error, found \"Items....",GetTitle()); return; } ptr1 = R__STRTOK_R(nullptr, "()", &amp;rest); if (ptr1 == 0) { Fatal("TDataMember","Internal error, found \"Items....",GetTitle()); return; } .... } .... } .... // dispose of temporary option list... delete optionlist; .... }</span></span></code> </pre> <br>  Le pointeur <i>optionList</i> n'est pas lib√©r√© avant de revenir de la fonction.  Je ne sais pas si une telle lib√©ration est n√©cessaire dans ce cas particulier, mais lorsque nous signalons de telles erreurs, les d√©veloppeurs les corrigent g√©n√©ralement.  Tout d√©pend si vous souhaitez ou non que votre programme continue de fonctionner en cas d'erreur.  ROOT a un tas de d√©fauts comme √ßa, donc je conseillerais aux auteurs de rev√©rifier le projet eux-m√™mes. <br><br><h2>  memset √† nouveau </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V597</a> Le compilateur pourrait supprimer l'appel de fonction 'memset', qui est utilis√© pour vider le tampon 'x'.  La fonction memset_s () doit √™tre utilis√©e pour effacer les donn√©es priv√©es.  TMD5.cxx 366 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TMD5::Transform(UInt_t buf[<span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UChar_t in[<span class="hljs-number"><span class="hljs-number">64</span></span>]) { UInt_t a, b, c, d, x[<span class="hljs-number"><span class="hljs-number">16</span></span>]; .... <span class="hljs-comment"><span class="hljs-comment">// Zero out sensitive information memset(x, 0, sizeof(x)); }</span></span></code> </pre> <br>  Beaucoup pensent que le commentaire ne parviendra pas au fichier binaire apr√®s la compilation, et ils sont absolument corrects: D.  Ce que certains ne savent peut-√™tre pas, c'est que le compilateur supprimera √©galement la fonction <i>memset</i> .  Et cela arrivera √† coup s√ªr.  Si le tampon en question n'est plus utilis√© dans le code, le compilateur optimisera l'appel de fonction.  Techniquement, c'est une d√©cision raisonnable, mais si le tampon stockait des donn√©es priv√©es, ces donn√©es resteront l√†.  Il s'agit d'une faiblesse de s√©curit√© classique <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CWE-14</a> . <br><br><h2>  Divers </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V591</a> La fonction non vide doit renvoyer une valeur.  LogLikelihoodFCN.h 108 <br><br><pre> <code class="cpp hljs">LogLikelihoodFCN &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LogLikelihoodFCN &amp; rhs) { SetData(rhs.DataPtr() ); SetModelFunction(rhs.ModelFunctionPtr() ); fNEffPoints = rhs.fNEffPoints; fGrad = rhs.fGrad; fIsExtended = rhs.fIsExtended; fWeight = rhs.fWeight; fExecutionPolicy = rhs.fExecutionPolicy; }</code> </pre> <br>  L'op√©rateur surcharg√© n'a pas de valeur de retour.  Il s'agit d'une autre tendance r√©cente. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V596</a> L'objet a √©t√© cr√©√© mais il n'est pas utilis√©.  Le mot cl√© ¬´throw¬ª peut √™tre manquant: throw runtime_error (FOO);  RTensor.hxx 363 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Value_t, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Container_t&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> RTensor&lt;Value_t, Container_t&gt; RTensor&lt;Value_t, Container_t&gt;::Transpose() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fLayout == MemoryLayout::RowMajor) { fLayout = MemoryLayout::ColumnMajor; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fLayout == MemoryLayout::ColumnMajor) { fLayout = MemoryLayout::RowMajor; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"Memory layout is not known."</span></span>); } .... }</code> </pre> <br>  Le probl√®me est que le programmeur a accidentellement omis le mot cl√© <i>throw</i> , emp√™chant ainsi le lancement d'une exception en cas de condition d'erreur. <br><br>  Il n'y avait que deux avertissements de ce type.  Voici la seconde: <br><br><ul><li>  V596 L'objet a √©t√© cr√©√© mais il n'est pas utilis√©.  Le mot cl√© ¬´throw¬ª peut √™tre manquant: throw runtime_error (FOO);  Forest.hxx 137 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V609</a> Divisez par z√©ro.  Plage du d√©nominateur [0..100].  TGHtmlImage.cxx 340 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *TGHtml::GetPctWidth(TGHtmlElement *p, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *opt, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ret) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, m, val; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || n &gt; <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (opt[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'h'</span></span>) { val = fCanvas-&gt;GetHeight() * <span class="hljs-number"><span class="hljs-number">100</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { val = fCanvas-&gt;GetWidth() * <span class="hljs-number"><span class="hljs-number">100</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!fInTd) { <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(ret, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-string"><span class="hljs-string">"%d"</span></span>, val / n); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } else { .... } .... }</span></span></code> </pre> <br>  Celui-ci est similaire aux exemples de gestion de tableau discut√©s pr√©c√©demment.  La variable <i>n</i> est limit√©e √† la plage de 0 √† 100. Mais il y a ensuite une branche qui effectue la division par la variable <i>n</i> qui peut avoir la valeur 0. Je pense que les limites de la plage de <i>n</i> devraient √™tre fix√©es comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || n &gt; <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z;</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V646</a> Envisagez d'inspecter la logique de l'application.  Il est possible que le mot cl√© "else" soit manquant.  TProofServ.cxx 729 <br><br><pre> <code class="cpp hljs">TProofServ::TProofServ(Int_t *argc, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **argv, FILE *flog) : TApplication(<span class="hljs-string"><span class="hljs-string">"proofserv"</span></span>, argc, argv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!logmx.IsDigit()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (logmx.EndsWith(<span class="hljs-string"><span class="hljs-string">"K"</span></span>)) { xf = <span class="hljs-number"><span class="hljs-number">1024</span></span>; logmx.Remove(TString::kTrailing, <span class="hljs-string"><span class="hljs-string">'K'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (logmx.EndsWith(<span class="hljs-string"><span class="hljs-string">"M"</span></span>)) { xf = <span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>; logmx.Remove(TString::kTrailing, <span class="hljs-string"><span class="hljs-string">'M'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (logmx.EndsWith(<span class="hljs-string"><span class="hljs-string">"G"</span></span>)) { xf = <span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>; logmx.Remove(TString::kTrailing, <span class="hljs-string"><span class="hljs-string">'G'</span></span>); } } .... }</code> </pre> <br>  L'analyseur signale une instruction <i>if</i> √©trangement format√©e avec le mot-cl√© <i>else</i> manquant.  L'aspect de ce code sugg√®re qu'il doit √™tre corrig√©. <br><br>  Quelques avertissements suppl√©mentaires de ce type: <br><br><ul><li>  V646 Envisagez d'inspecter la logique de l'application.  Il est possible que le mot cl√© "else" soit manquant.  TFormula_v5.cxx 3702 </li><li>  V646 Envisagez d'inspecter la logique de l'application.  Il est possible que le mot cl√© "else" soit manquant.  RooAbsCategory.cxx 604 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La</a> boucle infinie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V663</a> est possible.  La condition ¬´cin.eof ()¬ª est insuffisante pour rompre la boucle.  Pensez √† ajouter l'appel de fonction 'cin.fail ()' √† l'expression conditionnelle.  MethodKNN.cxx 602 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TMVA::MethodKNN::ReadWeightsFromStream(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream&amp; is) { .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!is.eof()) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> line; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::getline(is, line); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (line.empty() || line.find(<span class="hljs-string"><span class="hljs-string">"#"</span></span>) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } .... } .... }</code> </pre> <br>  Lorsque vous travaillez avec la classe <i>std :: istream</i> , appeler la fonction <i>eof ()</i> ne suffit pas pour terminer la boucle.  La fonction <i>eof ()</i> retournera toujours <i>false</i> si les donn√©es ne peuvent pas √™tre lues, et il n'y a pas d'autres points de terminaison dans ce code.  Pour garantir la fin de la boucle, une v√©rification suppl√©mentaire de la valeur retourn√©e par la fonction <i>fail ()</i> est requise: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!is.eof() &amp;&amp; !is.fail()) { .... }</code> </pre> <br>  Comme alternative, il peut √™tre r√©√©crit comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (is) { .... }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V678</a> Un objet est utilis√© comme argument de sa propre m√©thode.  Pensez √† v√©rifier le premier argument r√©el de la fonction ¬´Copier¬ª.  TFormLeafInfo.cxx 2414 <br><br><pre> <code class="cpp hljs">TFormLeafInfoMultiVarDim::TFormLeafInfoMultiVarDim( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TFormLeafInfoMultiVarDim&amp; orig) : TFormLeafInfo(orig) { fNsize = orig.fNsize; fSizes.Copy(fSizes); <span class="hljs-comment"><span class="hljs-comment">// &lt;= fCounter2 = orig.fCounter2?orig.fCounter2-&gt;DeepCopy():0; fSumOfSizes = orig.fSumOfSizes; fDim = orig.fDim; fVirtDim = orig.fVirtDim; fPrimaryIndex = orig.fPrimaryIndex; fSecondaryIndex = orig.fSecondaryIndex; }</span></span></code> </pre> <br>  Terminons l'article avec cette jolie petite faute de frappe.  La fonction de <i>copie</i> doit √™tre appel√©e avec <i>orig.fSizes</i> , pas <i>fSizes</i> . <br><br><h2>  Conclusion </h2><br>  Il y a environ un an, nous avons v√©rifi√© le projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NCBI Genome Workbench</a> , un autre programme utilis√© dans la recherche scientifique qui traite de l'analyse du g√©nome.  Je le mentionne parce que la qualit√© des logiciels scientifiques est extr√™mement cruciale, mais les d√©veloppeurs ont tendance √† les sous-estimer. <br><br>  Soit dit en passant, macOS 10.15 Catalina a √©t√© publi√© l'autre jour, o√π ils ont cess√© de prendre en charge les applications 32 bits.  Heureusement, PVS-Studio propose un large √©ventail de diagnostics sp√©cialement con√ßus pour d√©tecter les bogues qui accompagnent le portage de programmes vers des syst√®mes 64 bits.  En savoir plus dans ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">post</a> par l'√©quipe PVS-Studio. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472492/">https://habr.com/ru/post/fr472492/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472482/index.html">Accident radioactif: d√©couverte d'une phase solide solide de plutonium</a></li>
<li><a href="../fr472484/index.html">Fermeture de trous dans un cluster Kubernetes. Rapport et transcription avec DevOpsConf</a></li>
<li><a href="../fr472486/index.html">Stockage de donn√©es √† long terme. (Article - discussion)</a></li>
<li><a href="../fr472488/index.html">Trente reportages de DevOops 2019: Tim Lister, Hadi Hariri, Roman Shaposhnik et autres stars du DevOps international</a></li>
<li><a href="../fr472490/index.html">Comment j'ai recherch√© une norme de beaut√© √† l'aide du traitement du langage naturel (et je ne l'ai pas trouv√©e)</a></li>
<li><a href="../fr472494/index.html">Analyse de code ROOT - cadre d'analyse des donn√©es de recherche</a></li>
<li><a href="../fr472496/index.html">Cr√©ation d'une mise en page Scrapbook sur une grille CSS</a></li>
<li><a href="../fr472502/index.html">SOC is people: la dure vie quotidienne du responsable de service du centre de surveillance et de r√©ponse aux cyberattaques</a></li>
<li><a href="../fr472504/index.html">PHP Microservice Framework Swoft: Use Database Part 1</a></li>
<li><a href="../fr472508/index.html">Fiabilit√© du flash: attendue et inattendue. Partie 3. XIV conf√©rence de l'association USENIX. Technologies de stockage de fichiers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>