<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👦 👃 🤜🏽 ChaiScript - linguagem de script para C ++ ✊ 👨‍👧‍👧 🧜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quando é necessário incorporar uma linguagem de script em um projeto C ++, a primeira coisa que a maioria das pessoas lembra é Lua. Neste artigo não s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ChaiScript - linguagem de script para C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483540/">  Quando é necessário incorporar uma linguagem de script em um projeto C ++, a primeira coisa que a maioria das pessoas lembra é Lua.  Neste artigo não será, vou falar sobre outro, não menos conveniente e fácil de aprender linguagem chamada ChaiScript. <br><br><img src="https://habrastorage.org/webt/zh/vl/py/zhvlpyg_87wuf7gg0alk-s7qeyo.png" alt="imagem"><br><a name="habracut"></a><br><h4>  Breve introdução </h4><br>  Eu mesmo me deparei com o ChaiScript por acaso, quando assisti a <a href="https://youtu.be/uzF4u9KgUWI">uma das palestras de</a> Jason Turner, um dos criadores da linguagem.  Isso me interessou e, naquele momento em que era necessário escolher uma linguagem de script no projeto, eu decidi - por que não experimentar o ChaiScript?  O resultado me surpreendeu agradavelmente (minha experiência pessoal será escrita mais perto do final do artigo), no entanto, por mais estranho que pareça, não havia um único artigo no hub que sequer mencionasse esse idioma de alguma forma e decidi que seria bom escrever sobre ele.  Obviamente, o idioma possui <a href="">documentação</a> e um <a href="http://chaiscript.com/">site oficial</a> , mas nem todos lerão as observações, e o formato do artigo está mais próximo de muitos (inclusive eu). <br><br>  Primeiro, falaremos sobre a sintaxe da linguagem e todos os seus recursos, depois sobre como implementá-la em seu projeto C ++ e, no final, falarei um pouco sobre minha experiência.  Se alguma parte de você não estiver interessada ou desejar ler o artigo em uma ordem diferente, poderá usar o índice: <br><br><ul><li>  <a href="https://habr.com/ru/post/483540/">Sintaxe do ChaiScript</a> </li><li>  <a href="https://habr.com/ru/post/483540/">Implementação em C ++</a> </li><li>  <a href="https://habr.com/ru/post/483540/">Experiência pessoal</a> </li></ul><br><a name="syntax"></a><br><h2>  Sintaxe de idioma </h2><br>  O ChaiScript é muito semelhante ao C ++ e JS em sua sintaxe.  Primeiro, ele, como a grande maioria das linguagens de script, é digitado dinamicamente, no entanto, ao contrário do JavaScript, possui digitação estrita (não <code>1 + "2"</code> ).  Há também um coletor de lixo embutido, a linguagem é totalmente interpretável, permitindo a execução de código linha por linha, sem compilação no bytecode.  Ele suporta exceções (além disso, joint, permitindo capturá-las tanto dentro do script quanto em C ++), funções lambda, sobrecarga do operador.  Não é sensível a espaços, permitindo que você escreva como uma única linha através de um ponto-e-vírgula ou no estilo python, separando expressões com uma nova linha. <br><br><h4>  Tipos primitivos </h4><br>  O ChaiScript, por padrão, armazena variáveis ​​inteiras como int, real como double e strings com std :: string.  Isso é feito principalmente para garantir a compatibilidade com o código de chamada.  A linguagem ainda possui sufixos para números, para que possamos indicar explicitamente que tipo de variável é nossa: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*   chaiscript    js    ,  var / auto `;`      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myInt = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">// int var myLongLong = 1ll // long long int var myFloating = 3.3 // double var myBoolean = false // bool var myString = "hello world!\n" // std::string</span></span></code> </pre><br>  Alterar o tipo de variáveis ​​simplesmente não funciona, provavelmente você precisará definir seu próprio operador `=` para esses tipos; caso contrário, você corre o risco de lançar uma exceção (falaremos sobre isso mais adiante) ou tornar-se vítima de arredondamentos, assim: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> integer = <span class="hljs-number"><span class="hljs-number">3</span></span> integer = <span class="hljs-number"><span class="hljs-number">5.433</span></span> print(integer) <span class="hljs-comment"><span class="hljs-comment">//  5    double    int! integer = true //   -   `=`  (int, bool)</span></span></code> </pre><br>  No entanto, você pode declarar uma variável sem atribuir um valor a ela; nesse caso, ela conterá um tipo de indefinido até que seja atribuído um valor. <br><br><h4>  Recipientes em linha </h4><br>  O idioma possui dois contêineres - Vetor e Mapa.  Eles funcionam de maneira muito semelhante aos seus equivalentes em C ++ (std :: vector e std :: map, respectivamente), mas não precisam de um tipo, porque podem armazenar qualquer um.  A indexação pode ser feita como de costume com ints, mas o Map exige uma chave com uma string.  Aparentemente inspirados em python, os autores também adicionaram a capacidade de declarar rapidamente contêineres no código usando a seguinte sintaxe: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = [ <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>u, <span class="hljs-number"><span class="hljs-number">4</span></span>ll, <span class="hljs-string"><span class="hljs-string">"16"</span></span>, <span class="hljs-string"><span class="hljs-string">`+`</span></span> ] <span class="hljs-comment"><span class="hljs-comment">//      var m = [ "key1" : 1, "key2": "Bob" ]; //    - var M = Map() //    var V = Vector() //    //        C++ : v.push_back(123) //    ,     v.push_back_ref(m); // m -   //      m["key"] = 3 //       (reference assignment): m["key"] := m //      </span></span></code> </pre><br>  Ambas as classes repetem quase completamente suas contrapartes em C ++, com exceção dos iteradores, porque em vez delas existem classes especiais Range e Const_Range.  A propósito, todos os contêineres são passados ​​por referência, mesmo se você usar a atribuição por =, o que é muito estranho para mim, porque para todos os outros tipos ocorre a cópia por valor. <br><br><h4>  Construções Condicionais </h4><br>  Quase todas as construções de condições e ciclos podem ser descritas literalmente em um exemplo de código: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-comment"><span class="hljs-comment">//  if-else if (a &gt; b) { print("a &gt; b") } else if (a == b){ print("a == b") } else { print("a &lt; b") } // switch -    if- //      //  break    ,    C++ var str = "hello" switch(str) { case("hi") { print("hi!"); break; } case("hello") { print("hello!" break; } case("bye") { print("bye-bye!") break; } default { print("what have you said?") } } var x = true //     ,       while (x) { print("x was true") x = false; } //    C.        ,    ,    ,    for (var i = 0; i &lt; 10; ++i) //   -,    { print(i); //  0 ... 9  10  } // ranged-for loop for(element : [1, 2, 3, 4, 5]) { puts(element) //   12345 } //  :   C++17 if-init statements: if(var x = get_value(); x &lt; 10) { print(x) // x     if }</span></span></code> </pre><br>  Acho que as pessoas familiarizadas com C ++ não encontraram nada de novo.  Isso não é surpreendente, porque o ChaiScript está posicionado como uma linguagem fácil para os "alunos" aprenderem e, portanto, empresta todos os projetos clássicos conhecidos.  Os autores decidiram destacar até duas palavras-chave para declarar variáveis ​​- <code>var</code> e <code>auto</code> , caso você realmente goste das vantagens com auto. <br><br><h4>  Contexto de execução </h4><br>  O ChaiScript possui um contexto local e global.  O código é executado de cima para baixo, linha por linha, no entanto, pode ser retirado em funções e chamado mais tarde (mas não antes!).  Variáveis ​​declaradas dentro de funções ou condições / loops não são visíveis por fora, por padrão, mas você pode alterar esse comportamento usando o identificador <code>global</code> vez de <code>var</code> .  As variáveis ​​globais diferem das comuns, pois, primeiro, são visíveis fora do contexto local e, segundo, podem ser declaradas novamente (se o valor não for definido durante a declaração repetida, ele permanecerá o mesmo) <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     chaiscript def foo(x) { global G = 2 print(x) } foo(0) //  foo(x), G = 2 print(G) //  2 global G = 3 //  G = 3,   global -  !</span></span></code> </pre><br>  A propósito, se você possui uma variável e precisa verificar se está atribuído um valor, use a função <code>is_var_undef</code> , que retorna true se a variável não estiver definida. <br><br><h4>  Interpolação de string </h4><br>  Objetos base ou objetos de usuário que possuem um método <code>to_string()</code> podem ser colocados em uma string usando a sintaxe <code>${object}</code> .  Isso evita concatenações desnecessárias de strings e geralmente parece muito mais organizado: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-comment"><span class="hljs-comment">//  sum of 3 + 4 = 7 print("sum of ${x} + ${y} = ${x + y}")</span></span></code> </pre><br>  Vector, Map, MapPair e todas as primitivas também suportam esse recurso.  O vetor é exibido no formato <code>[o1, o2, ...]</code> , Mapa como <code>[&lt;key1, val1&gt;, &lt;key2, val2&gt;, ...]</code> e MapPair: <code>&lt;key, val&gt;</code> . <br><br><h4>  Funções e suas nuances </h4><br>  As funções ChaiScript são objetos como todo o resto.  Eles podem ser capturados, atribuídos a variáveis, aninhados em outras funções e transmitidos como argumento.  Também para eles, você pode especificar o tipo de valores de entrada (que é o que faltavam nos idiomas digitados dinamicamente!). Para isso, é necessário especificar o tipo antes de declarar o parâmetro da função.  Se, quando chamado, o parâmetro puder ser convertido para o especificado, a conversão ocorrerá de acordo com as regras do C ++, caso contrário, uma exceção será lançada: <br><br><pre> <code class="javascript hljs">def adder(int x, int y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y } def adder(bool x, bool y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x || y } adder(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ,  3 adder(1.22, -3.7) // ,  1 + (-3) = 2 adder(true, true) // ,  true adder(true, 3) // ,    adder(bool, int)</span></span></code> </pre><br>  As funções no idioma também podem ser definidas como condições de chamada (proteção de chamada).  Se não for respeitado, uma exceção será lançada; caso contrário, será feita uma chamada.  Também observo que, se a função não tiver uma declaração de retorno no final, a última expressão será retornada.  Muito conveniente para pequenas rotinas: <br><br><pre> <code class="javascript hljs">def div(x, y) : y != <span class="hljs-number"><span class="hljs-number">0</span></span> { x / y } <span class="hljs-comment"><span class="hljs-comment">//  `y`    -    `x`  `y` print(div(2, 0.5)) //  4.0 print(div(2, 0)) // , `y`  0!</span></span></code> </pre><br><h4>  Classes e Dynamic_Object </h4><br>  O ChaiScript possui os rudimentos do OOP, que é uma vantagem definitiva se você precisar manipular objetos complexos.  O idioma tem um tipo especial - Dynamic_Object.  De fato, todas as instâncias de classes e espaços para nome são exatamente Dynamic_Object com propriedades predefinidas.  Um objeto dinâmico permite adicionar campos a ele durante a execução do script e acessá-los: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = Dynamic_Object(); obj.x = <span class="hljs-number"><span class="hljs-number">3</span></span>; obj.f = fun(arg) { print(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x + arg); } <span class="hljs-comment"><span class="hljs-comment">//  obj   f (     `x` obj.f(-3); //  0</span></span></code> </pre><br>  As classes são definidas de maneira bastante simples.  Eles podem ser configurados para campos, métodos, construtores.  Do <code>set_explicit(object, value)</code> interessante <code>set_explicit(object, value)</code> através da função especial <code>set_explicit(object, value)</code> você pode "consertar" os campos do objeto proibindo a adição de novos métodos ou atributos após a declaração da classe (isso geralmente é feito no construtor): <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id; <span class="hljs-comment"><span class="hljs-comment">//  id def Widget() { this.id= 0 } //    def Widget(id) { this.id = id } //   1  def get_id() { id } //   } var w = Widget(10) print(w.get_id()) //  10 (w.id) print(w.get_id) //   10,        set_explicit(w, true) //    wx = 3 //      Widget   x</span></span></code> </pre><br>  Um ponto importante - de fato, os métodos de classe são apenas funções cujo primeiro argumento é um objeto de uma classe com um tipo especificado explicitamente.  Portanto, o código a seguir é equivalente a adicionar um método a uma classe existente: <br><br><pre> <code class="javascript hljs">def set_id(Widget w, id) { w.id = id } w.set_id(<span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-comment"><span class="hljs-comment">// w.id = 9 set_id(w, 9) //  , w.id = 9</span></span></code> </pre><br>  Qualquer pessoa familiarizada com o C # pode substituir o que parece dolorosamente um método de extensão e estará próxima da verdade.  Portanto, no idioma, você pode adicionar novas funcionalidades, mesmo para classes internas, por exemplo, para uma string ou int.  Os autores também oferecem uma maneira complicada de sobrecarregar os operadores: para fazer isso, você precisa colocar o símbolo do operador com um til (`) como no exemplo abaixo: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   +     Widget def `+`(Widget w1, Widget w2) { print("merging two widgets!") } var widget1 = Widget() var widget2 = Widget() widget1 + widget2 //      //        : var plus = `+` print(plus(1, 7)) //  8</span></span></code> </pre><br><h4>  Namespaces </h4><br>  Falando sobre o espaço para nome no ChaiScript, deve-se ter em mente que essas são essencialmente classes que sempre estão em um contexto global.  Você pode criá-los usando a função de <code>namespace(name)</code> e, em seguida, adicionar as funções e classes necessárias.  Por padrão, não há bibliotecas no idioma, no entanto, você pode instalá-las usando extensões, sobre as quais falaremos um pouco mais tarde.  Em geral, a inicialização do espaço para nome pode ser assim: <br><br><pre> <code class="javascript hljs">namespace(<span class="hljs-string"><span class="hljs-string">"math"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//    math //   math.square = fun(x) { x * x } math.hypot_squared= fun(x, y) { math.square(x) + math.square(y) } print(math.square(4)) //  16 print(math.hypot_squared(3, 4)) //  25</span></span></code> </pre><br><h4>  Expressões Lambda e outros recursos </h4><br>  As expressões lambda no ChaiScript são semelhantes ao que sabemos em C ++.  A palavra-chave <b>divertida</b> é usada para eles, e eles também exigem a especificação explícita das variáveis ​​capturadas, mas sempre fazem isso por referência.  O idioma também possui uma função de ligação que permite vincular valores a parâmetros de função: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> func_object = fun(x) { x * x } func_object(<span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  81 var name = "John" var greet = fun[name]() { "Hello, " + name } print(greet()) //  Hello, John name = "Bob" print(greet()) //  Hello, Bob var message = bind(fun(msg, name) { msg + " from " + name }, _, "ChaiScript"); print(message("Hello")) //  Hello from ChaiScript</span></span></code> </pre><br><h4>  Exceções </h4><br>  Exceções podem ocorrer durante a execução do script.  Eles podem ser interceptados tanto no próprio ChaiScript (que discutiremos aqui) quanto no C ++.  A sintaxe é absolutamente idêntica às vantagens, você pode até jogar fora um número ou uma string: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(x + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// x   } catch (e) { print("Error during evaluation")) } //   C++   ChaiScript //   Vector -   std::vector,    std::exception      try { var vec = [1, 2] var val = vec[3] //     } catch (e) { print("index out of range: " + e.what()); // e.what    ChaiScript } //  atch   guard     ,    `:` try { throw(5.2) } catch(e) : is_type(e, "int") { print("Int: ${e}"); //   `e`  int } catch(e) : is_type(e, "double") { print("Double: ${e}"); //  `e`  double }</span></span></code> </pre><br>  De uma maneira boa, você deve definir sua classe de exceções e lançá-la.  Falaremos sobre como interceptá-lo em C ++ na segunda seção.  Para exceções de intérpretes, o ChaiScript lança suas exceções, como eval_error, bad_boxed_cast, etc. <br><br><h4>  Constantes intérpretes </h4><br>  Para minha surpresa, a linguagem acabou sendo algum tipo de macro de compilador - existem apenas quatro e todas servem para identificar o contexto e são usadas principalmente para tratamento de erros: <br><div class="scrollable-table"><table><tbody><tr><td>  __LINE__ </td><td>  linha atual, se o código não for executado a partir de um arquivo, então '1' </td></tr><tr><td>  __FILE__ </td><td>  arquivo atual, se o código não for chamado de um arquivo, "__EVAL__" </td></tr><tr><td>  __CLASS__ </td><td>  classe atual ou "NOT_IN_CLASS" </td></tr><tr><td>  __FUNC__ </td><td>  função atual ou "NOT_IN_FUNCTION" </td></tr></tbody></table></div><br><h4>  Interceptação de erro </h4><br>  Se a função que você está chamando não tiver sido declarada, uma exceção será lançada.  Se isso é inaceitável para você, você pode definir uma função especial - <code>method_missing(object, func_name, params)</code> , que será chamada com os argumentos correspondentes em caso de erro: <br><br><pre> <code class="javascript hljs">def method_missing(Widget w, string name, Vector v) { print(<span class="hljs-string"><span class="hljs-string">"widget method ${name} with params {v} was not found"</span></span>) } w = Widget() w.invoke_error(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  widget method invoke_error with params [1, 2, 3] was not found</span></span></code> </pre><br><h4>  Funções incorporadas </h4><br>  O ChaiScript define muitas funções internas e, no artigo, gostaria de falar sobre funções especialmente úteis.  Entre eles: <code>eval(str)</code> , <code>eval_file(filename)</code> , <code>to_json(object)</code> , <code>from_json(str)</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">"x * y"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// res = 15,  eval     //     : //  eval_file eval_file("source.chai") //   use,  ,         use("source.chai") // to_json    Map    var w = Widget(0) var j = to_json(w) // j = "{ "id" : 0 }" // from_json    Map ( ,   ) var m = from_json(" { "x": 0, "y": 3, "z": 2 }") print(m) //  Map  [&lt;x, 0&gt;, &lt;y, 3&gt;, &lt;z, 2&gt;]</span></span></code> </pre><br><a name="cppchai"></a><br><h2>  Implementação em C ++ </h2><br><h4>  Instalação </h4><br>  O ChaiScript é uma biblioteca somente de cabeçalho baseada em modelo C ++.  Portanto, para a instalação, você só precisa criar um <a href="https://github.com/ChaiScript/ChaiScript">repositório</a> clone ou apenas colocar todos os arquivos <a href="https://github.com/ChaiScript/ChaiScript/tree/develop/include/chaiscript">desta pasta</a> em seu projeto.  Como, dependendo do IDE, tudo isso é feito de maneira diferente e foi descrito em detalhes nos fóruns por um longo tempo, assumiremos que você conseguiu conectar a biblioteca e o código com include: <code>#include &lt;chaiscript/chaiscript.hpp&gt;</code> compilado. <br><br><h4>  Chamada de código C ++ e carregamento de script </h4><br>  O menor código de amostra usando o ChaiScript é mostrado abaixo.  Definimos uma função simples em C ++ que pega std :: string e retorna a string alterada e, em seguida, adicionamos um link a ela no objeto ChaiScript para chamá-la.  A compilação pode levar um tempo considerável, mas isso se deve principalmente ao fato de não ser fácil instanciar um grande número de modelos para o compilador: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;chaiscript/chaiscript.hpp&gt; std::string greet_name(const std::string&amp; name) { return "hello, " + name; } int main() { chaiscript::ChaiScript chai; //  chaiscript chai.add(chaiscript::fun(&amp;greet_name), "greet"); //    greet //  eval      chai.eval(R"( print(greet("John")); )"); }</span></span></span></span></code> </pre> <br>  Espero que você tenha tido sucesso e tenha visto o resultado da função.  Quero anotar uma nuance imediatamente - se você declarar um objeto ChaiScript como estático, receberá um erro de execução desagradável.  Isso ocorre porque o idioma suporta multithreading por padrão e armazena variáveis ​​de fluxo local que são acessadas em seu destruidor.  No entanto, eles são destruídos antes que o destruidor da instância estática seja chamado e, como resultado, temos uma violação de acesso ou erro de falha de segmentação.  Com base no <a href="https://github.com/ChaiScript/ChaiScript/issues/338">problema do github</a> , a solução mais simples seria simplesmente colocar <b><code>#define CHAISCRIPT_NO_THREADS</code></b> nas configurações do compilador ou antes de incluir o arquivo da biblioteca, desativando o multithreading.  Pelo que entendi, não foi possível corrigir esse erro. <br><br>  Agora vamos analisar em detalhes como ocorre a interação entre C ++ e ChaiScript.  A biblioteca define uma função de modelo especial <code>fun</code> , que pode levar um ponteiro para uma função, functor ou ponteiro para uma variável de classe e, em seguida, retornar um objeto especial que armazena estado.  Como exemplo, vamos definir a classe Widget no código C ++ e tentar associá-la ao ChaiScript de diferentes maneiras: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Widget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id) : Id(id) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Id; } }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Widget&amp; w)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"widget #"</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(w.GetId()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">w</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget  C++  chai.add(chaiscript::fun([&amp;w] { return w; }), "get_widget"); //         chai.add(chaiscript::fun(ToString), "to_string"); //   chai.add(chaiscript::fun(&amp;Widget::GetId), "get_id"); //   //    ,   Widget    GetId,    to_string,    chai.eval(R"( var w = get_widget() print(w.get_id) //  2 print(w) //  widget #2 )"); }</span></span></code> </pre><br>  Como você pode ver, o ChaiScript funciona de maneira absolutamente calma com classes C ++ desconhecidas e pode chamar seus métodos.  Se você cometer algum erro em algum lugar do código, provavelmente o script lançará uma exceção do tipo de <code>error in function dispatch</code> , o que não é crítico.  No entanto, não apenas as funções podem ser importadas, vamos ver como adicionar uma variável a um script usando a biblioteca.  Para fazer isso, selecione um pouco mais a tarefa - importe std :: vector &lt;Widget&gt;.  A função <code>chaiscript::var</code> e o método <code>add_global</code> nos ajudarão com isso.  Também adicionaremos o campo público <code>Data</code> ao nosso Widget para ver como importar o campo da classe: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Data = <span class="hljs-number"><span class="hljs-number">0</span></span>; Widget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : Id(id) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Id; } }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Widget&amp; w)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"widget #"</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(w.GetId()) + <span class="hljs-string"><span class="hljs-string">" with data: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(w.Data); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Widget&gt; W; <span class="hljs-comment"><span class="hljs-comment">//    Widget W.emplace_back(1); W.emplace_back(2); W.emplace_back(3); chai.add(chaiscript::fund(ToString), "to_string"); chai.add(chaiscript::fun(&amp;Widget::Data), "data"); //     //     ChaiScript chai.add_global(chaiscript::var(std::ref(W)), "widgets"); //     std::ref chai.add(chaiscript::fun(&amp;std::vector&lt;Widget&gt;::size), "size"); //   // .        using IndexFuncType = Widget&amp; (std::vector&lt;Widget&gt;::*)(const size_t); chai.add(chaiscript::fun(IndexFuncType(&amp;std::vector&lt;Widget&gt;::operator[])), "[]"); chai.eval(R"( for(var i = 0; i &lt; vec.size; ++i) { vec[i].data = i * 2; print(vec[i]) } )"); }</span></span></code> </pre><br>  O código acima exibe: <b><code>widget #1 with data: 0</code> , <code>widget #2 with data: 2</code> , <code>widget #3 with data: 4</code></b> .  Adicionamos um ponteiro ao campo de classe no ChaiScript e, como o campo acabou sendo um tipo primitivo, alteramos seu valor.  Além disso, vários métodos foram adicionados para trabalhar com <code>std::vector</code> , incluindo o <code>operator[]</code> .  Quem conhece o STL sabe que o <code>std::vector</code> dois métodos de indexação - um retorna um link constante e o outro, um link simples.  É por isso que, para funções sobrecarregadas, você deve indicar explicitamente o tipo delas - caso contrário, a ambiguidade surge e o compilador gerará um erro. <br><br>  A biblioteca fornece vários outros métodos para adicionar objetos, mas todos são quase idênticos; portanto, não vejo o ponto de considerá-los em detalhes.  Como uma pequena dica, aqui está o código abaixo: <br><br><pre> <code class="cpp hljs">chai.add(chaiscript::var(x), <span class="hljs-string"><span class="hljs-string">"x"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// x   ChaiScript chai.add(chaiscript::var(std::ref(x), "x"); //  ,    C++  ChaiScript auto shared_x = std::make_shared&lt;int&gt;(5); chai.add(chaiscript::var(shared_x), "x"); // shared_ptr      C++  ChaiScript chai.add(chaiscript::const_var(x), "x"); //   ChaiScript    chai.add_global_const(chaiscript::const_var(x), "x"); // global const . ,  x   chai.add_global(chaiscript::var(x), "x"); // global , .  x   chai.set_global(chaiscript::var(x), "x"); //   global ,    const</span></span></code> </pre><br><h4>  Usando contêineres STL </h4><br>  Se desejar passar contêineres STL contendo tipos <b>primitivos</b> para o ChaiScript, você poderá adicionar uma instanciação de contêiner de modelo ao seu script para não importar métodos para cada tipo. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyVector = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;&gt;; MyVector V; V.emplace_back(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"John"</span></span>); V.emplace_back(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    - vector  pair chai.add(chaiscript::bootstrap::standard_library::vector_type&lt;MyVector&gt;("MyVec")); chai.add(chaiscript::bootstrap::standard_library::pair_type&lt;MyVector::value_type&gt;("MyVecData")); chai.add(chaiscript::var(std::ref(V)), "vec"); chai.eval(R"( for(var i = 0; i &lt; vec.size; ++i) { print(to_string(vec[i].first) + " " + vec[i].second) } )");</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sob o capô, várias funções do ChaiScript são chamadas, as quais adicionam os métodos necessários. </font><font style="vertical-align: inherit;">Em geral, se sua classe suportar operações semelhantes com contêineres STL, você também poderá adicioná-lo dessa maneira. </font></font><code>std::vector&lt;Widget&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infelizmente, </font><font style="vertical-align: inherit;">no caso de c, </font><font style="vertical-align: inherit;">isso é impossível, pois o ChaiScript requer um construtor sem parâmetros para o elemento </font></font><code>vector_type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que nosso Widget não possuía.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Classes C ++ dentro do ChaiScript </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Talvez como parte de sua tarefa, você precise não apenas modificar objetos no ChaiScript, mas também criá-los em um script. </font><font style="vertical-align: inherit;">Bem, isso é inteiramente possível. </font><font style="vertical-align: inherit;">Vamos pegar a classe Widget novamente, por exemplo, e herdar a classe WindowWidget, e adicionar ao script a capacidade de criar as duas e também converter a classe herdada na base:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Widget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id) : Id(id) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Id; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WindowWidget</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Widget { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; Size; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: WindowWidget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height) : Widget(id), Size(width, height) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWidth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Size.first; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Size.second; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-comment"><span class="hljs-comment">//   Widget    chai.add(chaiscript::user_type&lt;Widget&gt;(), "Widget"); chai.add(chaiscript::constructor&lt;Widget(int)&gt;(), "Widget"); //   WindowWidget    chai.add(chaiscript::user_type&lt;WindowWidget&gt;(), "WindowWidget"); chai.add(chaiscript::constructor&lt;WindowWidget(int, int, int)&gt;(), "WindowWidget"); // ,  Widget -    WindowWidget chai.add(chaiscript::base_class&lt;Widget, WindowWidget&gt;()); //   Widget  WindowWidget chai.add(chaiscript::fun(&amp;Widget::GetId), "get_id"); chai.add(chaiscript::fun(&amp;WindowWidget::GetWidth), "width"); chai.add(chaiscript::fun(&amp;WindowWidget::GetHeight), "height"); //  WindowWidget     chai.eval(R"( var window = WindowWidget(1, 800, 600) print("${window.width} * ${window.height}") print("widget.id is ${window.get_id}") )"); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O polimorfismo funciona no ChaiScript exatamente da mesma maneira que no C ++ para os tipos sobre os quais você fornece informações. </font><font style="vertical-align: inherit;">Se, por algum motivo, houver ambiguidade ao adicionar um ponteiro a um método herdado (talvez a classe seja herdada de vários métodos básicos de uma só vez), leve-a explicitamente à classe desejada, como foi feito no exemplo acima com o operador de indexação </font></font><code>std::vector&lt;Widget&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vinculando uma instância a um método e convertendo um tipo </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para objetos singleton, é conveniente usar a captura de links para eles junto com um método ou campo. </font><font style="vertical-align: inherit;">Nesse caso, no ChaiScript, obtemos uma função ou uma variável global que pode ser acessada sem mencionar este objeto:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">w</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; w.Data = <span class="hljs-number"><span class="hljs-number">4444</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget w chai.add(chaiscript::fun(&amp;Widget::GetId, &amp;w), "widget_id"); chai.add(chaiscript::fun(&amp;Widget::Data, &amp;w), "widget_data"); chai.eval(R"( print(widget_id) print(widget_data) )");</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Além disso, ao exportar mais classes de "biblioteca" de C ++ para ChaiScript (por exemplo, vec3, complexo, matriz), a possibilidade de conversão implícita de um tipo para outro geralmente é necessária. No ChaiScript, esse problema é resolvido adicionando </font></font><code>type_conversion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um script ao objeto. Por exemplo, considere a classe Complex e a implementação da conversão de int e double para ela durante a adição:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Complex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Re, Im; Complex(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> re, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> im = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) : Re(re), Im(im) { } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-comment"><span class="hljs-comment">//  Complex,   re, im,    `=` chai.add(chaiscript::user_type&lt;Complex&gt;(), "Complex"); chai.add(chaiscript::bootstrap::standard_library::assignable_type&lt;Complex&gt;("Complex")); chai.add(chaiscript::constructor&lt;Complex(float, float)&gt;(), "Complex"); chai.add(chaiscript::fun(&amp;Complex::Re), "re"); chai.add(chaiscript::fun(&amp;Complex::Im), "im"); //     double  int  Complex chai.add(chaiscript::type_conversion&lt;int, Complex&gt;()); chai.add(chaiscript::type_conversion&lt;double, Complex&gt;()); //     `+`    chai.eval(R"( def `+`(Complex c, x) { var res = Complex(0, 0) res.re = c.re + x.re res.im = c.im + x.im return res } var c = Complex(1, 2) c = c + 3 print("${c.re} + ${c.im}i") )"); // : `4 + 2i` }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, não é necessário escrever uma função de conversão no próprio C ++ e somente exportá-la para o ChaiScript. </font><font style="vertical-align: inherit;">Você pode adicionar transformações e já descrever a nova funcionalidade no próprio código de script. </font><font style="vertical-align: inherit;">Se a conversão para os dois tipos não for trivial, você pode passar o lambda como argumento para uma função </font></font><code>type_conversion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Será chamado quando estiver lançando. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um princípio semelhante é usado para converter Vector ou Map ChaiScript em seu tipo personalizado. </font><font style="vertical-align: inherit;">Para isso, </font></font><code>vector_conversion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e são </font><font style="vertical-align: inherit;">definidos na biblioteca </font></font><code>map_conversion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Descompactando valores de retorno ChaiScript </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Métodos </font></font><code>eval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>eval_file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retorne o valor da última expressão executada como um objeto </font></font><code>Boxed_Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para descompactá-lo e usar o resultado no código C ++, você pode especificar explicitamente o tipo do valor de retorno ou usar uma função </font></font><code>boxed_cast&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Se a conversão entre tipos existir, ela será executada; caso contrário, será gerada uma exceção </font></font><code>bad_boxed_cast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       double d = chai.eval&lt;double&gt;("5.3 + 2.1"); //     Boxed_Value,     auto v = chai.eval("5.3 + 2.1"); double d = chai.boxed_cast&lt;double&gt;(v);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como todos os objetos dentro do ChaiScript são armazenados usando shared_ptr, você pode obter o objeto como um ponteiro para continuar trabalhando com ele. </font><font style="vertical-align: inherit;">Para fazer isso, especifique explicitamente o tipo shared_ptr ao converter o valor de retorno:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = chai.eval&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;&gt;(<span class="hljs-string"><span class="hljs-string">"var x = 3.2"</span></span>);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O principal é não manter uma referência ao valor do shared_ptr desreferenciado, caso contrário, você corre o risco de obter uma violação de acesso depois que a variável é excluída durante a coleta de lixo automática no script. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como variáveis, você pode obter funções do ChaiScript na forma de functores compactados que capturam o estado de um objeto ChaiScript. </font><font style="vertical-align: inherit;">Por exemplo, usaremos a funcionalidade já implementada da classe Complex e tentaremos usá-la para chamar uma função no estágio de execução do programa:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> printComplex = chai.eval&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(Complex)&gt;&gt;(<span class="hljs-string"><span class="hljs-string">R"( fun(Complex c) { print("${c.re} + ${c.im}i"); } )"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  ,   ,      C++ printComplex(Complex(2, 3)); //  chaiscript,  `2 + 3i`</span></span></code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Captura de exceção do ChaiScript </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os autores recomendam a captura de três tipos de exceções além daquelas que você mesmo gera. </font><font style="vertical-align: inherit;">Isso ocorre </font></font><code>eval_error</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para erros de tempo de execução, </font></font><code>bad_boxed_cast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chamados quando os valores de retorno são descompactados incorretamente e </font></font><code>std::exception</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para todo o resto. </font><font style="vertical-align: inherit;">Se você planeja lançar suas próprias exceções, pode configurar a conversão automática para tipos C ++:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyException</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Data; MyException(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data) : <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception(<span class="hljs-string"><span class="hljs-string">"MyException"</span></span>), Data(data) { } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-comment"><span class="hljs-comment">//      chaiscript chai.add(chaiscript::user_type&lt;MyException&gt;(), "MyException"); chai.add(chaiscript::constructor&lt;MyException(int)&gt;(), "MyException"); try { //          chai.eval("throw(MyException(11111))", chaiscript::exception_specification&lt;MyException, std::exception&gt;()); } catch (MyException&amp; e) { std::cerr &lt;&lt; e.Data; //   `11111` } catch (chaiscript::exception::eval_error&amp; e) { std::cerr &lt;&lt; e.pretty_print(); } catch(std::exception&amp; e) { std::cerr &lt;&lt; e.what(); } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O exemplo acima mostra como capturar a maioria das exceções em C ++. </font><font style="vertical-align: inherit;">Além do método </font></font><code>pretty_print</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>eval_error</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ainda existem muitos dados úteis, como a pilha de chamadas, o nome do arquivo, os detalhes do erro, mas não entraremos tanto nessa classe neste artigo.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bibliotecas ChaiScript </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infelizmente, por padrão, o ChaiScript não fornece funcionalidade adicional em termos de bibliotecas. </font><font style="vertical-align: inherit;">Por exemplo, falta funções matemáticas, tabelas de hash e a maioria dos algoritmos. </font><font style="vertical-align: inherit;">Você pode fazer o download de alguns deles na forma de bibliotecas de módulos do repositório oficial do </font></font><a href="https://github.com/ChaiScript/ChaiScript_Extras"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChaiScript Extras</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e depois importar para o seu script. </font><font style="vertical-align: inherit;">Por exemplo, considere a biblioteca de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">matemática</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e a função acos (x):</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chaiscript/chaiscript.hpp&gt; #include &lt;chaiscript/extras/math.hpp&gt; int main() { chaiscript::ChaiScript chai; //   auto mathlib = chaiscript::extras::math::bootstrap(); chai.add(mathlib); std::cout &lt;&lt; chai.eval&lt;double&gt;("acos(0.5)"); // ~1.047 }</span></span></span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você também pode escrever sua biblioteca para o idioma e depois importar. </font><font style="vertical-align: inherit;">Isso é feito de maneira simples, por isso aconselho que você se familiarize com a matemática de código aberto ou qualquer outra fonte no repositório. </font><font style="vertical-align: inherit;">Em princípio, como parte da integração com o C ++, examinamos quase tudo, então acho que a seção pode ser concluída sobre isso.</font></font><br><a name="myexp"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Experiência pessoal </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No momento, estou escrevendo um mecanismo 3D no OpenGL como um projeto pessoal e tive uma ideia completamente lógica de implementar um console de depuração para controlar o estado do aplicativo em tempo real por meio de comandos. Seria possível fazer </font></font><a href="https://github.com/MomoDeve/MSL"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ciclismo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , é </font><font style="vertical-align: inherit;">claro </font><font style="vertical-align: inherit;">, mas como se costuma dizer, “o jogo não valeria a pena”, então decidi levar a biblioteca pronta.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como mencionei no início do artigo, eu já sabia sobre o ChaiScript, então tive uma escolha entre ele e Lua. </font><font style="vertical-align: inherit;">Até aquele momento, eu não estava familiarizado com nenhum desses idiomas, portanto, fatores como: sintaxe clara, facilidade de incorporação no código existente e suporte ao C ++ em vez de C influenciaram mais para não fazer diferença entre os invólucros de OOP sobre C- funções de estilo. </font><font style="vertical-align: inherit;">Penso que, ao ler este artigo, você já adivinhou em que minha escolha recaiu.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No momento, o idioma é mais do que adequado para mim, e escrever sobre as aulas não é grande coisa. </font><font style="vertical-align: inherit;">No código do mecanismo, uma instância do console no ImGui é anexada ao aplicativo iniciado, no qual o objeto chaiscript é inicializado. </font><font style="vertical-align: inherit;">Com algumas macros, a tarefa de introduzir uma nova classe em um script se resume a uma descrição simples de todos os métodos que precisam ser exportados:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      3D-: // rotation CHAI_IMPORT(&amp;GLInstance::RotateX, rotate_x); CHAI_IMPORT(&amp;GLInstance::RotateY, rotate_y); CHAI_IMPORT(&amp;GLInstance::RotateZ, rotate_z); // scale CHAI_IMPORT((GLInstance&amp;(GLInstance::*)(float))&amp;GLInstance::Scale, scale); CHAI_IMPORT((GLInstance&amp;(GLInstance::*)(float, float, float))&amp;GLInstance::Scale, scale); // translation CHAI_IMPORT(&amp;GLInstance::Translate, translate); CHAI_IMPORT(&amp;GLInstance::TranslateX, translate_x); CHAI_IMPORT(&amp;GLInstance::TranslateY, translate_y); CHAI_IMPORT(&amp;GLInstance::TranslateZ, translate_z); // hide / show CHAI_IMPORT(&amp;GLInstance::Hide, hide); CHAI_IMPORT(&amp;GLInstance::Show, show); // getters CHAI_IMPORT(&amp;GLInstance::GetTranslation, translation); CHAI_IMPORT(&amp;GLInstance::GetRotation, rotation); CHAI_IMPORT(&amp;GLInstance::GetScale, scale);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da mesma maneira, várias outras classes são exportadas e, em seguida, tudo é conectado por funções lambda declaradas diretamente no código de inicialização. Você pode ver o resultado do script na captura de tela: o </font></font><br><br><img src="https://habrastorage.org/webt/rl/bo/td/rlbotdpcfl4pdpbplwxfrvsk73i.png" alt="imagem"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">console do chaiscript para o ImGui: baixando e instalando o objeto por meio de comandos</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dada a flexibilidade geral da biblioteca, a mudança na abordagem de exportação de classes para o script será quase direta. É claro que Lua possui uma documentação mais extensa e uma comunidade, e essa linguagem seria preferível se você precisar obter mais desempenho do código de script (o JIT ainda faz seu trabalho), mas você ainda não deve cancelar o ChaiScript. Se você tem um projeto pequeno que precisa de script, pode experimentar com segurança as alternativas disponíveis.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta nota, eu gostaria de concluir este artigo. </font><font style="vertical-align: inherit;">Se você já teve experiência em trabalhar com linguagens de script dentro do C ++ (seja Lua ou outra linguagem), nos comentários, ficarei feliz em ouvir sua opinião sobre o ChaiScript e os scripts em geral. </font><font style="vertical-align: inherit;">Também saúdo quaisquer perguntas ou comentários sobre a publicação. </font><font style="vertical-align: inherit;">Obrigado a todos pela leitura.</font></font><br><br><h4>  Links úteis </h4><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Site oficial </font><a href="http://chaiscript.com/"><font style="vertical-align: inherit;">ChaiScript</font></a><font style="vertical-align: inherit;"> : </font></font><a href="http://chaiscript.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chaiscript.com</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referência rápida de sintaxe e biblioteca: </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cheatsheet ChaiScript</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentação oficial: </font></font><a href="https://codedocs.xyz/ChaiScript/ChaiScript/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codedocs.xyz/ChaiScript/ChaiScript</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meu projeto usando o ChaiScript: </font></font><a href="https://github.com/MomoDeve/MomoEngine"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/MomoDeve/MomoEngine</font></font></a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt483540/">https://habr.com/ru/post/pt483540/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt483528/index.html">API REST deve ser baseada em hipertexto</a></li>
<li><a href="../pt483530/index.html">Como fizemos um jogo de tabuleiro. Porque e porque?</a></li>
<li><a href="../pt483532/index.html">Conferência DefCon 27: Nos bastidores da criação de crachás eletrônicos Parte 1</a></li>
<li><a href="../pt483536/index.html">A história do microprocessador e computador pessoal: 1974 - 1980</a></li>
<li><a href="../pt483538/index.html">Conexão de um monitor ER-TFT101-1 de 10 "ao STM32F429 via FMC</a></li>
<li><a href="../pt483542/index.html">Resumo de telecomunicações - materiais sobre o trabalho dos fornecedores</a></li>
<li><a href="../pt483544/index.html">Novos dados refutam suposição chave de energia escura</a></li>
<li><a href="../pt483550/index.html">Desenvolvimento de serviços e IaaS: uma compilação de nuvem, armazenamento de dados e evolução da 1cloud</a></li>
<li><a href="../pt483552/index.html">MVVM e seleção de elementos no adaptador</a></li>
<li><a href="../pt483554/index.html">Nova plataforma tecnológica dos anos 20. Por que eu não concordo com Zuckerberg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>