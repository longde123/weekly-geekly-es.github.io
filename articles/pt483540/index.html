<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë¶ üëÉ ü§úüèΩ ChaiScript - linguagem de script para C ++ ‚úä üë®‚Äçüëß‚Äçüëß üßú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quando √© necess√°rio incorporar uma linguagem de script em um projeto C ++, a primeira coisa que a maioria das pessoas lembra √© Lua. Neste artigo n√£o s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ChaiScript - linguagem de script para C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483540/">  Quando √© necess√°rio incorporar uma linguagem de script em um projeto C ++, a primeira coisa que a maioria das pessoas lembra √© Lua.  Neste artigo n√£o ser√°, vou falar sobre outro, n√£o menos conveniente e f√°cil de aprender linguagem chamada ChaiScript. <br><br><img src="https://habrastorage.org/webt/zh/vl/py/zhvlpyg_87wuf7gg0alk-s7qeyo.png" alt="imagem"><br><a name="habracut"></a><br><h4>  Breve introdu√ß√£o </h4><br>  Eu mesmo me deparei com o ChaiScript por acaso, quando assisti a <a href="https://youtu.be/uzF4u9KgUWI">uma das palestras de</a> Jason Turner, um dos criadores da linguagem.  Isso me interessou e, naquele momento em que era necess√°rio escolher uma linguagem de script no projeto, eu decidi - por que n√£o experimentar o ChaiScript?  O resultado me surpreendeu agradavelmente (minha experi√™ncia pessoal ser√° escrita mais perto do final do artigo), no entanto, por mais estranho que pare√ßa, n√£o havia um √∫nico artigo no hub que sequer mencionasse esse idioma de alguma forma e decidi que seria bom escrever sobre ele.  Obviamente, o idioma possui <a href="">documenta√ß√£o</a> e um <a href="http://chaiscript.com/">site oficial</a> , mas nem todos ler√£o as observa√ß√µes, e o formato do artigo est√° mais pr√≥ximo de muitos (inclusive eu). <br><br>  Primeiro, falaremos sobre a sintaxe da linguagem e todos os seus recursos, depois sobre como implement√°-la em seu projeto C ++ e, no final, falarei um pouco sobre minha experi√™ncia.  Se alguma parte de voc√™ n√£o estiver interessada ou desejar ler o artigo em uma ordem diferente, poder√° usar o √≠ndice: <br><br><ul><li>  <a href="https://habr.com/ru/post/483540/">Sintaxe do ChaiScript</a> </li><li>  <a href="https://habr.com/ru/post/483540/">Implementa√ß√£o em C ++</a> </li><li>  <a href="https://habr.com/ru/post/483540/">Experi√™ncia pessoal</a> </li></ul><br><a name="syntax"></a><br><h2>  Sintaxe de idioma </h2><br>  O ChaiScript √© muito semelhante ao C ++ e JS em sua sintaxe.  Primeiro, ele, como a grande maioria das linguagens de script, √© digitado dinamicamente, no entanto, ao contr√°rio do JavaScript, possui digita√ß√£o estrita (n√£o <code>1 + "2"</code> ).  H√° tamb√©m um coletor de lixo embutido, a linguagem √© totalmente interpret√°vel, permitindo a execu√ß√£o de c√≥digo linha por linha, sem compila√ß√£o no bytecode.  Ele suporta exce√ß√µes (al√©m disso, joint, permitindo captur√°-las tanto dentro do script quanto em C ++), fun√ß√µes lambda, sobrecarga do operador.  N√£o √© sens√≠vel a espa√ßos, permitindo que voc√™ escreva como uma √∫nica linha atrav√©s de um ponto-e-v√≠rgula ou no estilo python, separando express√µes com uma nova linha. <br><br><h4>  Tipos primitivos </h4><br>  O ChaiScript, por padr√£o, armazena vari√°veis ‚Äã‚Äãinteiras como int, real como double e strings com std :: string.  Isso √© feito principalmente para garantir a compatibilidade com o c√≥digo de chamada.  A linguagem ainda possui sufixos para n√∫meros, para que possamos indicar explicitamente que tipo de vari√°vel √© nossa: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*   chaiscript    js    ,  var / auto `;`      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myInt = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">// int var myLongLong = 1ll // long long int var myFloating = 3.3 // double var myBoolean = false // bool var myString = "hello world!\n" // std::string</span></span></code> </pre><br>  Alterar o tipo de vari√°veis ‚Äã‚Äãsimplesmente n√£o funciona, provavelmente voc√™ precisar√° definir seu pr√≥prio operador `=` para esses tipos; caso contr√°rio, voc√™ corre o risco de lan√ßar uma exce√ß√£o (falaremos sobre isso mais adiante) ou tornar-se v√≠tima de arredondamentos, assim: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> integer = <span class="hljs-number"><span class="hljs-number">3</span></span> integer = <span class="hljs-number"><span class="hljs-number">5.433</span></span> print(integer) <span class="hljs-comment"><span class="hljs-comment">//  5    double    int! integer = true //   -   `=`  (int, bool)</span></span></code> </pre><br>  No entanto, voc√™ pode declarar uma vari√°vel sem atribuir um valor a ela; nesse caso, ela conter√° um tipo de indefinido at√© que seja atribu√≠do um valor. <br><br><h4>  Recipientes em linha </h4><br>  O idioma possui dois cont√™ineres - Vetor e Mapa.  Eles funcionam de maneira muito semelhante aos seus equivalentes em C ++ (std :: vector e std :: map, respectivamente), mas n√£o precisam de um tipo, porque podem armazenar qualquer um.  A indexa√ß√£o pode ser feita como de costume com ints, mas o Map exige uma chave com uma string.  Aparentemente inspirados em python, os autores tamb√©m adicionaram a capacidade de declarar rapidamente cont√™ineres no c√≥digo usando a seguinte sintaxe: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = [ <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>u, <span class="hljs-number"><span class="hljs-number">4</span></span>ll, <span class="hljs-string"><span class="hljs-string">"16"</span></span>, <span class="hljs-string"><span class="hljs-string">`+`</span></span> ] <span class="hljs-comment"><span class="hljs-comment">//      var m = [ "key1" : 1, "key2": "Bob" ]; //    - var M = Map() //    var V = Vector() //    //        C++ : v.push_back(123) //    ,     v.push_back_ref(m); // m -   //      m["key"] = 3 //       (reference assignment): m["key"] := m //      </span></span></code> </pre><br>  Ambas as classes repetem quase completamente suas contrapartes em C ++, com exce√ß√£o dos iteradores, porque em vez delas existem classes especiais Range e Const_Range.  A prop√≥sito, todos os cont√™ineres s√£o passados ‚Äã‚Äãpor refer√™ncia, mesmo se voc√™ usar a atribui√ß√£o por =, o que √© muito estranho para mim, porque para todos os outros tipos ocorre a c√≥pia por valor. <br><br><h4>  Constru√ß√µes Condicionais </h4><br>  Quase todas as constru√ß√µes de condi√ß√µes e ciclos podem ser descritas literalmente em um exemplo de c√≥digo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-comment"><span class="hljs-comment">//  if-else if (a &gt; b) { print("a &gt; b") } else if (a == b){ print("a == b") } else { print("a &lt; b") } // switch -    if- //      //  break    ,    C++ var str = "hello" switch(str) { case("hi") { print("hi!"); break; } case("hello") { print("hello!" break; } case("bye") { print("bye-bye!") break; } default { print("what have you said?") } } var x = true //     ,       while (x) { print("x was true") x = false; } //    C.        ,    ,    ,    for (var i = 0; i &lt; 10; ++i) //   -,    { print(i); //  0 ... 9  10  } // ranged-for loop for(element : [1, 2, 3, 4, 5]) { puts(element) //   12345 } //  :   C++17 if-init statements: if(var x = get_value(); x &lt; 10) { print(x) // x     if }</span></span></code> </pre><br>  Acho que as pessoas familiarizadas com C ++ n√£o encontraram nada de novo.  Isso n√£o √© surpreendente, porque o ChaiScript est√° posicionado como uma linguagem f√°cil para os "alunos" aprenderem e, portanto, empresta todos os projetos cl√°ssicos conhecidos.  Os autores decidiram destacar at√© duas palavras-chave para declarar vari√°veis ‚Äã‚Äã- <code>var</code> e <code>auto</code> , caso voc√™ realmente goste das vantagens com auto. <br><br><h4>  Contexto de execu√ß√£o </h4><br>  O ChaiScript possui um contexto local e global.  O c√≥digo √© executado de cima para baixo, linha por linha, no entanto, pode ser retirado em fun√ß√µes e chamado mais tarde (mas n√£o antes!).  Vari√°veis ‚Äã‚Äãdeclaradas dentro de fun√ß√µes ou condi√ß√µes / loops n√£o s√£o vis√≠veis por fora, por padr√£o, mas voc√™ pode alterar esse comportamento usando o identificador <code>global</code> vez de <code>var</code> .  As vari√°veis ‚Äã‚Äãglobais diferem das comuns, pois, primeiro, s√£o vis√≠veis fora do contexto local e, segundo, podem ser declaradas novamente (se o valor n√£o for definido durante a declara√ß√£o repetida, ele permanecer√° o mesmo) <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     chaiscript def foo(x) { global G = 2 print(x) } foo(0) //  foo(x), G = 2 print(G) //  2 global G = 3 //  G = 3,   global -  !</span></span></code> </pre><br>  A prop√≥sito, se voc√™ possui uma vari√°vel e precisa verificar se est√° atribu√≠do um valor, use a fun√ß√£o <code>is_var_undef</code> , que retorna true se a vari√°vel n√£o estiver definida. <br><br><h4>  Interpola√ß√£o de string </h4><br>  Objetos base ou objetos de usu√°rio que possuem um m√©todo <code>to_string()</code> podem ser colocados em uma string usando a sintaxe <code>${object}</code> .  Isso evita concatena√ß√µes desnecess√°rias de strings e geralmente parece muito mais organizado: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-comment"><span class="hljs-comment">//  sum of 3 + 4 = 7 print("sum of ${x} + ${y} = ${x + y}")</span></span></code> </pre><br>  Vector, Map, MapPair e todas as primitivas tamb√©m suportam esse recurso.  O vetor √© exibido no formato <code>[o1, o2, ...]</code> , Mapa como <code>[&lt;key1, val1&gt;, &lt;key2, val2&gt;, ...]</code> e MapPair: <code>&lt;key, val&gt;</code> . <br><br><h4>  Fun√ß√µes e suas nuances </h4><br>  As fun√ß√µes ChaiScript s√£o objetos como todo o resto.  Eles podem ser capturados, atribu√≠dos a vari√°veis, aninhados em outras fun√ß√µes e transmitidos como argumento.  Tamb√©m para eles, voc√™ pode especificar o tipo de valores de entrada (que √© o que faltavam nos idiomas digitados dinamicamente!). Para isso, √© necess√°rio especificar o tipo antes de declarar o par√¢metro da fun√ß√£o.  Se, quando chamado, o par√¢metro puder ser convertido para o especificado, a convers√£o ocorrer√° de acordo com as regras do C ++, caso contr√°rio, uma exce√ß√£o ser√° lan√ßada: <br><br><pre> <code class="javascript hljs">def adder(int x, int y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y } def adder(bool x, bool y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x || y } adder(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ,  3 adder(1.22, -3.7) // ,  1 + (-3) = 2 adder(true, true) // ,  true adder(true, 3) // ,    adder(bool, int)</span></span></code> </pre><br>  As fun√ß√µes no idioma tamb√©m podem ser definidas como condi√ß√µes de chamada (prote√ß√£o de chamada).  Se n√£o for respeitado, uma exce√ß√£o ser√° lan√ßada; caso contr√°rio, ser√° feita uma chamada.  Tamb√©m observo que, se a fun√ß√£o n√£o tiver uma declara√ß√£o de retorno no final, a √∫ltima express√£o ser√° retornada.  Muito conveniente para pequenas rotinas: <br><br><pre> <code class="javascript hljs">def div(x, y) : y != <span class="hljs-number"><span class="hljs-number">0</span></span> { x / y } <span class="hljs-comment"><span class="hljs-comment">//  `y`    -    `x`  `y` print(div(2, 0.5)) //  4.0 print(div(2, 0)) // , `y`  0!</span></span></code> </pre><br><h4>  Classes e Dynamic_Object </h4><br>  O ChaiScript possui os rudimentos do OOP, que √© uma vantagem definitiva se voc√™ precisar manipular objetos complexos.  O idioma tem um tipo especial - Dynamic_Object.  De fato, todas as inst√¢ncias de classes e espa√ßos para nome s√£o exatamente Dynamic_Object com propriedades predefinidas.  Um objeto din√¢mico permite adicionar campos a ele durante a execu√ß√£o do script e acess√°-los: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = Dynamic_Object(); obj.x = <span class="hljs-number"><span class="hljs-number">3</span></span>; obj.f = fun(arg) { print(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x + arg); } <span class="hljs-comment"><span class="hljs-comment">//  obj   f (     `x` obj.f(-3); //  0</span></span></code> </pre><br>  As classes s√£o definidas de maneira bastante simples.  Eles podem ser configurados para campos, m√©todos, construtores.  Do <code>set_explicit(object, value)</code> interessante <code>set_explicit(object, value)</code> atrav√©s da fun√ß√£o especial <code>set_explicit(object, value)</code> voc√™ pode "consertar" os campos do objeto proibindo a adi√ß√£o de novos m√©todos ou atributos ap√≥s a declara√ß√£o da classe (isso geralmente √© feito no construtor): <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id; <span class="hljs-comment"><span class="hljs-comment">//  id def Widget() { this.id= 0 } //    def Widget(id) { this.id = id } //   1  def get_id() { id } //   } var w = Widget(10) print(w.get_id()) //  10 (w.id) print(w.get_id) //   10,        set_explicit(w, true) //    wx = 3 //      Widget   x</span></span></code> </pre><br>  Um ponto importante - de fato, os m√©todos de classe s√£o apenas fun√ß√µes cujo primeiro argumento √© um objeto de uma classe com um tipo especificado explicitamente.  Portanto, o c√≥digo a seguir √© equivalente a adicionar um m√©todo a uma classe existente: <br><br><pre> <code class="javascript hljs">def set_id(Widget w, id) { w.id = id } w.set_id(<span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-comment"><span class="hljs-comment">// w.id = 9 set_id(w, 9) //  , w.id = 9</span></span></code> </pre><br>  Qualquer pessoa familiarizada com o C # pode substituir o que parece dolorosamente um m√©todo de extens√£o e estar√° pr√≥xima da verdade.  Portanto, no idioma, voc√™ pode adicionar novas funcionalidades, mesmo para classes internas, por exemplo, para uma string ou int.  Os autores tamb√©m oferecem uma maneira complicada de sobrecarregar os operadores: para fazer isso, voc√™ precisa colocar o s√≠mbolo do operador com um til (`) como no exemplo abaixo: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   +     Widget def `+`(Widget w1, Widget w2) { print("merging two widgets!") } var widget1 = Widget() var widget2 = Widget() widget1 + widget2 //      //        : var plus = `+` print(plus(1, 7)) //  8</span></span></code> </pre><br><h4>  Namespaces </h4><br>  Falando sobre o espa√ßo para nome no ChaiScript, deve-se ter em mente que essas s√£o essencialmente classes que sempre est√£o em um contexto global.  Voc√™ pode cri√°-los usando a fun√ß√£o de <code>namespace(name)</code> e, em seguida, adicionar as fun√ß√µes e classes necess√°rias.  Por padr√£o, n√£o h√° bibliotecas no idioma, no entanto, voc√™ pode instal√°-las usando extens√µes, sobre as quais falaremos um pouco mais tarde.  Em geral, a inicializa√ß√£o do espa√ßo para nome pode ser assim: <br><br><pre> <code class="javascript hljs">namespace(<span class="hljs-string"><span class="hljs-string">"math"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//    math //   math.square = fun(x) { x * x } math.hypot_squared= fun(x, y) { math.square(x) + math.square(y) } print(math.square(4)) //  16 print(math.hypot_squared(3, 4)) //  25</span></span></code> </pre><br><h4>  Express√µes Lambda e outros recursos </h4><br>  As express√µes lambda no ChaiScript s√£o semelhantes ao que sabemos em C ++.  A palavra-chave <b>divertida</b> √© usada para eles, e eles tamb√©m exigem a especifica√ß√£o expl√≠cita das vari√°veis ‚Äã‚Äãcapturadas, mas sempre fazem isso por refer√™ncia.  O idioma tamb√©m possui uma fun√ß√£o de liga√ß√£o que permite vincular valores a par√¢metros de fun√ß√£o: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> func_object = fun(x) { x * x } func_object(<span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  81 var name = "John" var greet = fun[name]() { "Hello, " + name } print(greet()) //  Hello, John name = "Bob" print(greet()) //  Hello, Bob var message = bind(fun(msg, name) { msg + " from " + name }, _, "ChaiScript"); print(message("Hello")) //  Hello from ChaiScript</span></span></code> </pre><br><h4>  Exce√ß√µes </h4><br>  Exce√ß√µes podem ocorrer durante a execu√ß√£o do script.  Eles podem ser interceptados tanto no pr√≥prio ChaiScript (que discutiremos aqui) quanto no C ++.  A sintaxe √© absolutamente id√™ntica √†s vantagens, voc√™ pode at√© jogar fora um n√∫mero ou uma string: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(x + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// x   } catch (e) { print("Error during evaluation")) } //   C++   ChaiScript //   Vector -   std::vector,    std::exception      try { var vec = [1, 2] var val = vec[3] //     } catch (e) { print("index out of range: " + e.what()); // e.what    ChaiScript } //  atch   guard     ,    `:` try { throw(5.2) } catch(e) : is_type(e, "int") { print("Int: ${e}"); //   `e`  int } catch(e) : is_type(e, "double") { print("Double: ${e}"); //  `e`  double }</span></span></code> </pre><br>  De uma maneira boa, voc√™ deve definir sua classe de exce√ß√µes e lan√ß√°-la.  Falaremos sobre como intercept√°-lo em C ++ na segunda se√ß√£o.  Para exce√ß√µes de int√©rpretes, o ChaiScript lan√ßa suas exce√ß√µes, como eval_error, bad_boxed_cast, etc. <br><br><h4>  Constantes int√©rpretes </h4><br>  Para minha surpresa, a linguagem acabou sendo algum tipo de macro de compilador - existem apenas quatro e todas servem para identificar o contexto e s√£o usadas principalmente para tratamento de erros: <br><div class="scrollable-table"><table><tbody><tr><td>  __LINE__ </td><td>  linha atual, se o c√≥digo n√£o for executado a partir de um arquivo, ent√£o '1' </td></tr><tr><td>  __FILE__ </td><td>  arquivo atual, se o c√≥digo n√£o for chamado de um arquivo, "__EVAL__" </td></tr><tr><td>  __CLASS__ </td><td>  classe atual ou "NOT_IN_CLASS" </td></tr><tr><td>  __FUNC__ </td><td>  fun√ß√£o atual ou "NOT_IN_FUNCTION" </td></tr></tbody></table></div><br><h4>  Intercepta√ß√£o de erro </h4><br>  Se a fun√ß√£o que voc√™ est√° chamando n√£o tiver sido declarada, uma exce√ß√£o ser√° lan√ßada.  Se isso √© inaceit√°vel para voc√™, voc√™ pode definir uma fun√ß√£o especial - <code>method_missing(object, func_name, params)</code> , que ser√° chamada com os argumentos correspondentes em caso de erro: <br><br><pre> <code class="javascript hljs">def method_missing(Widget w, string name, Vector v) { print(<span class="hljs-string"><span class="hljs-string">"widget method ${name} with params {v} was not found"</span></span>) } w = Widget() w.invoke_error(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  widget method invoke_error with params [1, 2, 3] was not found</span></span></code> </pre><br><h4>  Fun√ß√µes incorporadas </h4><br>  O ChaiScript define muitas fun√ß√µes internas e, no artigo, gostaria de falar sobre fun√ß√µes especialmente √∫teis.  Entre eles: <code>eval(str)</code> , <code>eval_file(filename)</code> , <code>to_json(object)</code> , <code>from_json(str)</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">"x * y"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// res = 15,  eval     //     : //  eval_file eval_file("source.chai") //   use,  ,         use("source.chai") // to_json    Map    var w = Widget(0) var j = to_json(w) // j = "{ "id" : 0 }" // from_json    Map ( ,   ) var m = from_json(" { "x": 0, "y": 3, "z": 2 }") print(m) //  Map  [&lt;x, 0&gt;, &lt;y, 3&gt;, &lt;z, 2&gt;]</span></span></code> </pre><br><a name="cppchai"></a><br><h2>  Implementa√ß√£o em C ++ </h2><br><h4>  Instala√ß√£o </h4><br>  O ChaiScript √© uma biblioteca somente de cabe√ßalho baseada em modelo C ++.  Portanto, para a instala√ß√£o, voc√™ s√≥ precisa criar um <a href="https://github.com/ChaiScript/ChaiScript">reposit√≥rio</a> clone ou apenas colocar todos os arquivos <a href="https://github.com/ChaiScript/ChaiScript/tree/develop/include/chaiscript">desta pasta</a> em seu projeto.  Como, dependendo do IDE, tudo isso √© feito de maneira diferente e foi descrito em detalhes nos f√≥runs por um longo tempo, assumiremos que voc√™ conseguiu conectar a biblioteca e o c√≥digo com include: <code>#include &lt;chaiscript/chaiscript.hpp&gt;</code> compilado. <br><br><h4>  Chamada de c√≥digo C ++ e carregamento de script </h4><br>  O menor c√≥digo de amostra usando o ChaiScript √© mostrado abaixo.  Definimos uma fun√ß√£o simples em C ++ que pega std :: string e retorna a string alterada e, em seguida, adicionamos um link a ela no objeto ChaiScript para cham√°-la.  A compila√ß√£o pode levar um tempo consider√°vel, mas isso se deve principalmente ao fato de n√£o ser f√°cil instanciar um grande n√∫mero de modelos para o compilador: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;chaiscript/chaiscript.hpp&gt; std::string greet_name(const std::string&amp; name) { return "hello, " + name; } int main() { chaiscript::ChaiScript chai; //  chaiscript chai.add(chaiscript::fun(&amp;greet_name), "greet"); //    greet //  eval      chai.eval(R"( print(greet("John")); )"); }</span></span></span></span></code> </pre> <br>  Espero que voc√™ tenha tido sucesso e tenha visto o resultado da fun√ß√£o.  Quero anotar uma nuance imediatamente - se voc√™ declarar um objeto ChaiScript como est√°tico, receber√° um erro de execu√ß√£o desagrad√°vel.  Isso ocorre porque o idioma suporta multithreading por padr√£o e armazena vari√°veis ‚Äã‚Äãde fluxo local que s√£o acessadas em seu destruidor.  No entanto, eles s√£o destru√≠dos antes que o destruidor da inst√¢ncia est√°tica seja chamado e, como resultado, temos uma viola√ß√£o de acesso ou erro de falha de segmenta√ß√£o.  Com base no <a href="https://github.com/ChaiScript/ChaiScript/issues/338">problema do github</a> , a solu√ß√£o mais simples seria simplesmente colocar <b><code>#define CHAISCRIPT_NO_THREADS</code></b> nas configura√ß√µes do compilador ou antes de incluir o arquivo da biblioteca, desativando o multithreading.  Pelo que entendi, n√£o foi poss√≠vel corrigir esse erro. <br><br>  Agora vamos analisar em detalhes como ocorre a intera√ß√£o entre C ++ e ChaiScript.  A biblioteca define uma fun√ß√£o de modelo especial <code>fun</code> , que pode levar um ponteiro para uma fun√ß√£o, functor ou ponteiro para uma vari√°vel de classe e, em seguida, retornar um objeto especial que armazena estado.  Como exemplo, vamos definir a classe Widget no c√≥digo C ++ e tentar associ√°-la ao ChaiScript de diferentes maneiras: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Widget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id) : Id(id) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Id; } }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Widget&amp; w)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"widget #"</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(w.GetId()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">w</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget  C++  chai.add(chaiscript::fun([&amp;w] { return w; }), "get_widget"); //         chai.add(chaiscript::fun(ToString), "to_string"); //   chai.add(chaiscript::fun(&amp;Widget::GetId), "get_id"); //   //    ,   Widget    GetId,    to_string,    chai.eval(R"( var w = get_widget() print(w.get_id) //  2 print(w) //  widget #2 )"); }</span></span></code> </pre><br>  Como voc√™ pode ver, o ChaiScript funciona de maneira absolutamente calma com classes C ++ desconhecidas e pode chamar seus m√©todos.  Se voc√™ cometer algum erro em algum lugar do c√≥digo, provavelmente o script lan√ßar√° uma exce√ß√£o do tipo de <code>error in function dispatch</code> , o que n√£o √© cr√≠tico.  No entanto, n√£o apenas as fun√ß√µes podem ser importadas, vamos ver como adicionar uma vari√°vel a um script usando a biblioteca.  Para fazer isso, selecione um pouco mais a tarefa - importe std :: vector &lt;Widget&gt;.  A fun√ß√£o <code>chaiscript::var</code> e o m√©todo <code>add_global</code> nos ajudar√£o com isso.  Tamb√©m adicionaremos o campo p√∫blico <code>Data</code> ao nosso Widget para ver como importar o campo da classe: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Data = <span class="hljs-number"><span class="hljs-number">0</span></span>; Widget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : Id(id) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Id; } }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Widget&amp; w)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"widget #"</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(w.GetId()) + <span class="hljs-string"><span class="hljs-string">" with data: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(w.Data); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Widget&gt; W; <span class="hljs-comment"><span class="hljs-comment">//    Widget W.emplace_back(1); W.emplace_back(2); W.emplace_back(3); chai.add(chaiscript::fund(ToString), "to_string"); chai.add(chaiscript::fun(&amp;Widget::Data), "data"); //     //     ChaiScript chai.add_global(chaiscript::var(std::ref(W)), "widgets"); //     std::ref chai.add(chaiscript::fun(&amp;std::vector&lt;Widget&gt;::size), "size"); //   // .        using IndexFuncType = Widget&amp; (std::vector&lt;Widget&gt;::*)(const size_t); chai.add(chaiscript::fun(IndexFuncType(&amp;std::vector&lt;Widget&gt;::operator[])), "[]"); chai.eval(R"( for(var i = 0; i &lt; vec.size; ++i) { vec[i].data = i * 2; print(vec[i]) } )"); }</span></span></code> </pre><br>  O c√≥digo acima exibe: <b><code>widget #1 with data: 0</code> , <code>widget #2 with data: 2</code> , <code>widget #3 with data: 4</code></b> .  Adicionamos um ponteiro ao campo de classe no ChaiScript e, como o campo acabou sendo um tipo primitivo, alteramos seu valor.  Al√©m disso, v√°rios m√©todos foram adicionados para trabalhar com <code>std::vector</code> , incluindo o <code>operator[]</code> .  Quem conhece o STL sabe que o <code>std::vector</code> dois m√©todos de indexa√ß√£o - um retorna um link constante e o outro, um link simples.  √â por isso que, para fun√ß√µes sobrecarregadas, voc√™ deve indicar explicitamente o tipo delas - caso contr√°rio, a ambiguidade surge e o compilador gerar√° um erro. <br><br>  A biblioteca fornece v√°rios outros m√©todos para adicionar objetos, mas todos s√£o quase id√™nticos; portanto, n√£o vejo o ponto de consider√°-los em detalhes.  Como uma pequena dica, aqui est√° o c√≥digo abaixo: <br><br><pre> <code class="cpp hljs">chai.add(chaiscript::var(x), <span class="hljs-string"><span class="hljs-string">"x"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// x   ChaiScript chai.add(chaiscript::var(std::ref(x), "x"); //  ,    C++  ChaiScript auto shared_x = std::make_shared&lt;int&gt;(5); chai.add(chaiscript::var(shared_x), "x"); // shared_ptr      C++  ChaiScript chai.add(chaiscript::const_var(x), "x"); //   ChaiScript    chai.add_global_const(chaiscript::const_var(x), "x"); // global const . ,  x   chai.add_global(chaiscript::var(x), "x"); // global , .  x   chai.set_global(chaiscript::var(x), "x"); //   global ,    const</span></span></code> </pre><br><h4>  Usando cont√™ineres STL </h4><br>  Se desejar passar cont√™ineres STL contendo tipos <b>primitivos</b> para o ChaiScript, voc√™ poder√° adicionar uma instancia√ß√£o de cont√™iner de modelo ao seu script para n√£o importar m√©todos para cada tipo. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyVector = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;&gt;; MyVector V; V.emplace_back(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"John"</span></span>); V.emplace_back(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    - vector  pair chai.add(chaiscript::bootstrap::standard_library::vector_type&lt;MyVector&gt;("MyVec")); chai.add(chaiscript::bootstrap::standard_library::pair_type&lt;MyVector::value_type&gt;("MyVecData")); chai.add(chaiscript::var(std::ref(V)), "vec"); chai.eval(R"( for(var i = 0; i &lt; vec.size; ++i) { print(to_string(vec[i].first) + " " + vec[i].second) } )");</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sob o cap√¥, v√°rias fun√ß√µes do ChaiScript s√£o chamadas, as quais adicionam os m√©todos necess√°rios. </font><font style="vertical-align: inherit;">Em geral, se sua classe suportar opera√ß√µes semelhantes com cont√™ineres STL, voc√™ tamb√©m poder√° adicion√°-lo dessa maneira. </font></font><code>std::vector&lt;Widget&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infelizmente, </font><font style="vertical-align: inherit;">no caso de c, </font><font style="vertical-align: inherit;">isso √© imposs√≠vel, pois o ChaiScript requer um construtor sem par√¢metros para o elemento </font></font><code>vector_type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que nosso Widget n√£o possu√≠a.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Classes C ++ dentro do ChaiScript </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Talvez como parte de sua tarefa, voc√™ precise n√£o apenas modificar objetos no ChaiScript, mas tamb√©m cri√°-los em um script. </font><font style="vertical-align: inherit;">Bem, isso √© inteiramente poss√≠vel. </font><font style="vertical-align: inherit;">Vamos pegar a classe Widget novamente, por exemplo, e herdar a classe WindowWidget, e adicionar ao script a capacidade de criar as duas e tamb√©m converter a classe herdada na base:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Widget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id) : Id(id) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Id; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WindowWidget</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Widget { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; Size; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: WindowWidget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height) : Widget(id), Size(width, height) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWidth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Size.first; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Size.second; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-comment"><span class="hljs-comment">//   Widget    chai.add(chaiscript::user_type&lt;Widget&gt;(), "Widget"); chai.add(chaiscript::constructor&lt;Widget(int)&gt;(), "Widget"); //   WindowWidget    chai.add(chaiscript::user_type&lt;WindowWidget&gt;(), "WindowWidget"); chai.add(chaiscript::constructor&lt;WindowWidget(int, int, int)&gt;(), "WindowWidget"); // ,  Widget -    WindowWidget chai.add(chaiscript::base_class&lt;Widget, WindowWidget&gt;()); //   Widget  WindowWidget chai.add(chaiscript::fun(&amp;Widget::GetId), "get_id"); chai.add(chaiscript::fun(&amp;WindowWidget::GetWidth), "width"); chai.add(chaiscript::fun(&amp;WindowWidget::GetHeight), "height"); //  WindowWidget     chai.eval(R"( var window = WindowWidget(1, 800, 600) print("${window.width} * ${window.height}") print("widget.id is ${window.get_id}") )"); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O polimorfismo funciona no ChaiScript exatamente da mesma maneira que no C ++ para os tipos sobre os quais voc√™ fornece informa√ß√µes. </font><font style="vertical-align: inherit;">Se, por algum motivo, houver ambiguidade ao adicionar um ponteiro a um m√©todo herdado (talvez a classe seja herdada de v√°rios m√©todos b√°sicos de uma s√≥ vez), leve-a explicitamente √† classe desejada, como foi feito no exemplo acima com o operador de indexa√ß√£o </font></font><code>std::vector&lt;Widget&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vinculando uma inst√¢ncia a um m√©todo e convertendo um tipo </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para objetos singleton, √© conveniente usar a captura de links para eles junto com um m√©todo ou campo. </font><font style="vertical-align: inherit;">Nesse caso, no ChaiScript, obtemos uma fun√ß√£o ou uma vari√°vel global que pode ser acessada sem mencionar este objeto:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">w</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; w.Data = <span class="hljs-number"><span class="hljs-number">4444</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget w chai.add(chaiscript::fun(&amp;Widget::GetId, &amp;w), "widget_id"); chai.add(chaiscript::fun(&amp;Widget::Data, &amp;w), "widget_data"); chai.eval(R"( print(widget_id) print(widget_data) )");</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, ao exportar mais classes de "biblioteca" de C ++ para ChaiScript (por exemplo, vec3, complexo, matriz), a possibilidade de convers√£o impl√≠cita de um tipo para outro geralmente √© necess√°ria. No ChaiScript, esse problema √© resolvido adicionando </font></font><code>type_conversion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um script ao objeto. Por exemplo, considere a classe Complex e a implementa√ß√£o da convers√£o de int e double para ela durante a adi√ß√£o:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Complex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Re, Im; Complex(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> re, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> im = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) : Re(re), Im(im) { } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-comment"><span class="hljs-comment">//  Complex,   re, im,    `=` chai.add(chaiscript::user_type&lt;Complex&gt;(), "Complex"); chai.add(chaiscript::bootstrap::standard_library::assignable_type&lt;Complex&gt;("Complex")); chai.add(chaiscript::constructor&lt;Complex(float, float)&gt;(), "Complex"); chai.add(chaiscript::fun(&amp;Complex::Re), "re"); chai.add(chaiscript::fun(&amp;Complex::Im), "im"); //     double  int  Complex chai.add(chaiscript::type_conversion&lt;int, Complex&gt;()); chai.add(chaiscript::type_conversion&lt;double, Complex&gt;()); //     `+`    chai.eval(R"( def `+`(Complex c, x) { var res = Complex(0, 0) res.re = c.re + x.re res.im = c.im + x.im return res } var c = Complex(1, 2) c = c + 3 print("${c.re} + ${c.im}i") )"); // : `4 + 2i` }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, n√£o √© necess√°rio escrever uma fun√ß√£o de convers√£o no pr√≥prio C ++ e somente export√°-la para o ChaiScript. </font><font style="vertical-align: inherit;">Voc√™ pode adicionar transforma√ß√µes e j√° descrever a nova funcionalidade no pr√≥prio c√≥digo de script. </font><font style="vertical-align: inherit;">Se a convers√£o para os dois tipos n√£o for trivial, voc√™ pode passar o lambda como argumento para uma fun√ß√£o </font></font><code>type_conversion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ser√° chamado quando estiver lan√ßando. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um princ√≠pio semelhante √© usado para converter Vector ou Map ChaiScript em seu tipo personalizado. </font><font style="vertical-align: inherit;">Para isso, </font></font><code>vector_conversion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e s√£o </font><font style="vertical-align: inherit;">definidos na biblioteca </font></font><code>map_conversion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Descompactando valores de retorno ChaiScript </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©todos </font></font><code>eval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>eval_file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retorne o valor da √∫ltima express√£o executada como um objeto </font></font><code>Boxed_Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para descompact√°-lo e usar o resultado no c√≥digo C ++, voc√™ pode especificar explicitamente o tipo do valor de retorno ou usar uma fun√ß√£o </font></font><code>boxed_cast&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Se a convers√£o entre tipos existir, ela ser√° executada; caso contr√°rio, ser√° gerada uma exce√ß√£o </font></font><code>bad_boxed_cast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       double d = chai.eval&lt;double&gt;("5.3 + 2.1"); //     Boxed_Value,     auto v = chai.eval("5.3 + 2.1"); double d = chai.boxed_cast&lt;double&gt;(v);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como todos os objetos dentro do ChaiScript s√£o armazenados usando shared_ptr, voc√™ pode obter o objeto como um ponteiro para continuar trabalhando com ele. </font><font style="vertical-align: inherit;">Para fazer isso, especifique explicitamente o tipo shared_ptr ao converter o valor de retorno:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = chai.eval&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;&gt;(<span class="hljs-string"><span class="hljs-string">"var x = 3.2"</span></span>);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O principal √© n√£o manter uma refer√™ncia ao valor do shared_ptr desreferenciado, caso contr√°rio, voc√™ corre o risco de obter uma viola√ß√£o de acesso depois que a vari√°vel √© exclu√≠da durante a coleta de lixo autom√°tica no script. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como vari√°veis, voc√™ pode obter fun√ß√µes do ChaiScript na forma de functores compactados que capturam o estado de um objeto ChaiScript. </font><font style="vertical-align: inherit;">Por exemplo, usaremos a funcionalidade j√° implementada da classe Complex e tentaremos us√°-la para chamar uma fun√ß√£o no est√°gio de execu√ß√£o do programa:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> printComplex = chai.eval&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(Complex)&gt;&gt;(<span class="hljs-string"><span class="hljs-string">R"( fun(Complex c) { print("${c.re} + ${c.im}i"); } )"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  ,   ,      C++ printComplex(Complex(2, 3)); //  chaiscript,  `2 + 3i`</span></span></code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Captura de exce√ß√£o do ChaiScript </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os autores recomendam a captura de tr√™s tipos de exce√ß√µes al√©m daquelas que voc√™ mesmo gera. </font><font style="vertical-align: inherit;">Isso ocorre </font></font><code>eval_error</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para erros de tempo de execu√ß√£o, </font></font><code>bad_boxed_cast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chamados quando os valores de retorno s√£o descompactados incorretamente e </font></font><code>std::exception</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para todo o resto. </font><font style="vertical-align: inherit;">Se voc√™ planeja lan√ßar suas pr√≥prias exce√ß√µes, pode configurar a convers√£o autom√°tica para tipos C ++:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyException</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Data; MyException(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data) : <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception(<span class="hljs-string"><span class="hljs-string">"MyException"</span></span>), Data(data) { } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-comment"><span class="hljs-comment">//      chaiscript chai.add(chaiscript::user_type&lt;MyException&gt;(), "MyException"); chai.add(chaiscript::constructor&lt;MyException(int)&gt;(), "MyException"); try { //          chai.eval("throw(MyException(11111))", chaiscript::exception_specification&lt;MyException, std::exception&gt;()); } catch (MyException&amp; e) { std::cerr &lt;&lt; e.Data; //   `11111` } catch (chaiscript::exception::eval_error&amp; e) { std::cerr &lt;&lt; e.pretty_print(); } catch(std::exception&amp; e) { std::cerr &lt;&lt; e.what(); } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O exemplo acima mostra como capturar a maioria das exce√ß√µes em C ++. </font><font style="vertical-align: inherit;">Al√©m do m√©todo </font></font><code>pretty_print</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>eval_error</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ainda existem muitos dados √∫teis, como a pilha de chamadas, o nome do arquivo, os detalhes do erro, mas n√£o entraremos tanto nessa classe neste artigo.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bibliotecas ChaiScript </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infelizmente, por padr√£o, o ChaiScript n√£o fornece funcionalidade adicional em termos de bibliotecas. </font><font style="vertical-align: inherit;">Por exemplo, falta fun√ß√µes matem√°ticas, tabelas de hash e a maioria dos algoritmos. </font><font style="vertical-align: inherit;">Voc√™ pode fazer o download de alguns deles na forma de bibliotecas de m√≥dulos do reposit√≥rio oficial do </font></font><a href="https://github.com/ChaiScript/ChaiScript_Extras"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChaiScript Extras</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e depois importar para o seu script. </font><font style="vertical-align: inherit;">Por exemplo, considere a biblioteca de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">matem√°tica</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e a fun√ß√£o acos (x):</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chaiscript/chaiscript.hpp&gt; #include &lt;chaiscript/extras/math.hpp&gt; int main() { chaiscript::ChaiScript chai; //   auto mathlib = chaiscript::extras::math::bootstrap(); chai.add(mathlib); std::cout &lt;&lt; chai.eval&lt;double&gt;("acos(0.5)"); // ~1.047 }</span></span></span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ tamb√©m pode escrever sua biblioteca para o idioma e depois importar. </font><font style="vertical-align: inherit;">Isso √© feito de maneira simples, por isso aconselho que voc√™ se familiarize com a matem√°tica de c√≥digo aberto ou qualquer outra fonte no reposit√≥rio. </font><font style="vertical-align: inherit;">Em princ√≠pio, como parte da integra√ß√£o com o C ++, examinamos quase tudo, ent√£o acho que a se√ß√£o pode ser conclu√≠da sobre isso.</font></font><br><a name="myexp"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Experi√™ncia pessoal </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No momento, estou escrevendo um mecanismo 3D no OpenGL como um projeto pessoal e tive uma ideia completamente l√≥gica de implementar um console de depura√ß√£o para controlar o estado do aplicativo em tempo real por meio de comandos. Seria poss√≠vel fazer </font></font><a href="https://github.com/MomoDeve/MSL"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ciclismo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , √© </font><font style="vertical-align: inherit;">claro </font><font style="vertical-align: inherit;">, mas como se costuma dizer, ‚Äúo jogo n√£o valeria a pena‚Äù, ent√£o decidi levar a biblioteca pronta.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como mencionei no in√≠cio do artigo, eu j√° sabia sobre o ChaiScript, ent√£o tive uma escolha entre ele e Lua. </font><font style="vertical-align: inherit;">At√© aquele momento, eu n√£o estava familiarizado com nenhum desses idiomas, portanto, fatores como: sintaxe clara, facilidade de incorpora√ß√£o no c√≥digo existente e suporte ao C ++ em vez de C influenciaram mais para n√£o fazer diferen√ßa entre os inv√≥lucros de OOP sobre C- fun√ß√µes de estilo. </font><font style="vertical-align: inherit;">Penso que, ao ler este artigo, voc√™ j√° adivinhou em que minha escolha recaiu.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No momento, o idioma √© mais do que adequado para mim, e escrever sobre as aulas n√£o √© grande coisa. </font><font style="vertical-align: inherit;">No c√≥digo do mecanismo, uma inst√¢ncia do console no ImGui √© anexada ao aplicativo iniciado, no qual o objeto chaiscript √© inicializado. </font><font style="vertical-align: inherit;">Com algumas macros, a tarefa de introduzir uma nova classe em um script se resume a uma descri√ß√£o simples de todos os m√©todos que precisam ser exportados:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      3D-: // rotation CHAI_IMPORT(&amp;GLInstance::RotateX, rotate_x); CHAI_IMPORT(&amp;GLInstance::RotateY, rotate_y); CHAI_IMPORT(&amp;GLInstance::RotateZ, rotate_z); // scale CHAI_IMPORT((GLInstance&amp;(GLInstance::*)(float))&amp;GLInstance::Scale, scale); CHAI_IMPORT((GLInstance&amp;(GLInstance::*)(float, float, float))&amp;GLInstance::Scale, scale); // translation CHAI_IMPORT(&amp;GLInstance::Translate, translate); CHAI_IMPORT(&amp;GLInstance::TranslateX, translate_x); CHAI_IMPORT(&amp;GLInstance::TranslateY, translate_y); CHAI_IMPORT(&amp;GLInstance::TranslateZ, translate_z); // hide / show CHAI_IMPORT(&amp;GLInstance::Hide, hide); CHAI_IMPORT(&amp;GLInstance::Show, show); // getters CHAI_IMPORT(&amp;GLInstance::GetTranslation, translation); CHAI_IMPORT(&amp;GLInstance::GetRotation, rotation); CHAI_IMPORT(&amp;GLInstance::GetScale, scale);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da mesma maneira, v√°rias outras classes s√£o exportadas e, em seguida, tudo √© conectado por fun√ß√µes lambda declaradas diretamente no c√≥digo de inicializa√ß√£o. Voc√™ pode ver o resultado do script na captura de tela: o </font></font><br><br><img src="https://habrastorage.org/webt/rl/bo/td/rlbotdpcfl4pdpbplwxfrvsk73i.png" alt="imagem"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">console do chaiscript para o ImGui: baixando e instalando o objeto por meio de comandos</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dada a flexibilidade geral da biblioteca, a mudan√ßa na abordagem de exporta√ß√£o de classes para o script ser√° quase direta. √â claro que Lua possui uma documenta√ß√£o mais extensa e uma comunidade, e essa linguagem seria prefer√≠vel se voc√™ precisar obter mais desempenho do c√≥digo de script (o JIT ainda faz seu trabalho), mas voc√™ ainda n√£o deve cancelar o ChaiScript. Se voc√™ tem um projeto pequeno que precisa de script, pode experimentar com seguran√ßa as alternativas dispon√≠veis.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta nota, eu gostaria de concluir este artigo. </font><font style="vertical-align: inherit;">Se voc√™ j√° teve experi√™ncia em trabalhar com linguagens de script dentro do C ++ (seja Lua ou outra linguagem), nos coment√°rios, ficarei feliz em ouvir sua opini√£o sobre o ChaiScript e os scripts em geral. </font><font style="vertical-align: inherit;">Tamb√©m sa√∫do quaisquer perguntas ou coment√°rios sobre a publica√ß√£o. </font><font style="vertical-align: inherit;">Obrigado a todos pela leitura.</font></font><br><br><h4>  Links √∫teis </h4><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Site oficial </font><a href="http://chaiscript.com/"><font style="vertical-align: inherit;">ChaiScript</font></a><font style="vertical-align: inherit;"> : </font></font><a href="http://chaiscript.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chaiscript.com</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Refer√™ncia r√°pida de sintaxe e biblioteca: </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cheatsheet ChaiScript</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documenta√ß√£o oficial: </font></font><a href="https://codedocs.xyz/ChaiScript/ChaiScript/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codedocs.xyz/ChaiScript/ChaiScript</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meu projeto usando o ChaiScript: </font></font><a href="https://github.com/MomoDeve/MomoEngine"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/MomoDeve/MomoEngine</font></font></a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt483540/">https://habr.com/ru/post/pt483540/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt483528/index.html">API REST deve ser baseada em hipertexto</a></li>
<li><a href="../pt483530/index.html">Como fizemos um jogo de tabuleiro. Porque e porque?</a></li>
<li><a href="../pt483532/index.html">Confer√™ncia DefCon 27: Nos bastidores da cria√ß√£o de crach√°s eletr√¥nicos Parte 1</a></li>
<li><a href="../pt483536/index.html">A hist√≥ria do microprocessador e computador pessoal: 1974 - 1980</a></li>
<li><a href="../pt483538/index.html">Conex√£o de um monitor ER-TFT101-1 de 10 "ao STM32F429 via FMC</a></li>
<li><a href="../pt483542/index.html">Resumo de telecomunica√ß√µes - materiais sobre o trabalho dos fornecedores</a></li>
<li><a href="../pt483544/index.html">Novos dados refutam suposi√ß√£o chave de energia escura</a></li>
<li><a href="../pt483550/index.html">Desenvolvimento de servi√ßos e IaaS: uma compila√ß√£o de nuvem, armazenamento de dados e evolu√ß√£o da 1cloud</a></li>
<li><a href="../pt483552/index.html">MVVM e sele√ß√£o de elementos no adaptador</a></li>
<li><a href="../pt483554/index.html">Nova plataforma tecnol√≥gica dos anos 20. Por que eu n√£o concordo com Zuckerberg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>