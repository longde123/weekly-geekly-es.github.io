<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öíÔ∏è üòÑ üë©üèæ‚ÄçüöÄ Einfacher Zombie-Shooter auf Unity üê∏ üîÖ üëàüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! In K√ºrze beginnt der Unterricht in der ersten Gruppe des Unity Games Developer- Kurses. Im Vorfeld des Kursbeginns wurde eine offene...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einfacher Zombie-Shooter auf Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/485210/">  <i>Hallo allerseits!</i>  <i>In K√ºrze beginnt der Unterricht in der ersten Gruppe des <a href="https://otus.pw/sW0V/">Unity Games Developer-</a> Kurses.</i>  <i>Im Vorfeld des Kursbeginns wurde <a href="https://www.youtube.com/watch%3Fv%3D6OTvr4e9PRY">eine offene Lektion</a> zum Erstellen eines Zombie-Shooters auf Unity abgehalten.</i>  <i>Das Webinar wurde von <a href="https://otus.pw/xfXx/">Nikolai Zapolnov</a> , Senior Game Developer von Rovio Entertainment Corporation, <a href="https://otus.pw/xfXx/">moderiert</a> .</i>  <i>Er hat auch einen ausf√ºhrlichen Artikel geschrieben, auf den wir Sie aufmerksam machen.</i> <br><br><img src="https://habrastorage.org/webt/z6/pk/iv/z6pkiv4cismrguzozecv51foouk.jpeg"><br><br>  In diesem Artikel m√∂chte ich zeigen, wie einfach es ist, Spiele in Unity zu erstellen.  Wenn Sie √ºber grundlegende Programmierkenntnisse verf√ºgen, k√∂nnen Sie schnell mit dieser Engine arbeiten und Ihr erstes Spiel erstellen. <br><br><hr><br>  <i>Disclaimer # 1: Dieser Artikel ist f√ºr Anf√§nger.</i>  <i>Wenn Sie in Unity einen Hund gefressen haben, kommt es Ihnen vielleicht langweilig vor.</i> <br><br>  <i>Haftungsausschluss Nr. 2: Um diesen Artikel lesen zu k√∂nnen, ben√∂tigen Sie mindestens grundlegende Programmierkenntnisse.</i>  <i>Zumindest die W√∂rter "Klasse" und "Methode" sollten Sie nicht erschrecken.</i> <br><br>  <b>Achtung, Verkehr unter dem Schnitt!</b> <br><a name="habracut"></a><br><h2>  Einf√ºhrung in die Einheit </h2><br>  <i>Wenn Sie mit dem Unity-Editor bereits vertraut sind, k√∂nnen Sie die Einf√ºhrung √ºberspringen und direkt zum Abschnitt ‚ÄûErstellen einer Spielwelt‚Äú wechseln.</i> <br><br>  Die grundlegende Struktureinheit in Unity ist die "Szene".  Eine Szene ist normalerweise eine Ebene des Spiels, obwohl es in einigen F√§llen mehrere Ebenen auf einmal in einer Szene geben kann, oder umgekehrt, eine gro√üe Ebene kann in mehrere dynamisch geladene Szenen unterteilt werden.  Szenen sind mit Spielobjekten gef√ºllt und sie sind wiederum mit Komponenten gef√ºllt.  Es sind die Komponenten, die verschiedene Spielfunktionen implementieren: Zeichnen von Objekten, Animation, Physik usw.  Mit diesem Modell k√∂nnen Sie Funktionen aus einfachen Bl√∂cken zusammensetzen, wie mit einem Spielzeug aus dem Lego-Konstruktor. <br><br>  Sie k√∂nnen Komponenten mit der Programmiersprache C # selbst schreiben.  So wird die Spiellogik geschrieben.  Nachfolgend werden wir sehen, wie das gemacht wird, aber schauen wir uns jetzt den Motor selbst an. <br><br>  Wenn Sie die Engine starten und ein neues Projekt erstellen, wird vor Ihnen ein Fenster angezeigt, in dem Sie vier Hauptelemente ausw√§hlen k√∂nnen: <br><br><img src="https://habrastorage.org/webt/5m/0o/9j/5m0o9jxwps3qwz3pbmvlchxveau.png"><br><br>  In der oberen linken Ecke des Screenshots befindet sich das Fenster "Hierarchie".  Hier sehen wir die Hierarchie der Spielobjekte in der aktuell ge√∂ffneten Szene.  Unity hat zwei Spielobjekte f√ºr uns erstellt: eine Kamera (‚ÄûHauptkamera‚Äú), durch die der Spieler unsere Spielwelt sehen kann, und ein ‚ÄûRichtungslicht‚Äú, das unsere Szene beleuchtet.  Ohne sie w√ºrden wir nur ein schwarzes Quadrat sehen. <br><br>  In der Mitte befindet sich das Szenenbearbeitungsfenster (‚ÄûSzene‚Äú).  Hier sehen wir unsere Ebene und k√∂nnen sie visuell bearbeiten - bewegen und drehen Sie Objekte mit der Maus und sehen Sie, was passiert.  In der N√§he sehen Sie die Registerkarte "Spiel", die derzeit inaktiv ist.  Wenn Sie dorthin wechseln, k√∂nnen Sie von der Kamera aus sehen, wie das Spiel aussieht.  Und wenn Sie das Spiel starten (√ºber die Schaltfl√§che mit dem Wiedergabesymbol in der Symbolleiste), wechselt Unity zu dieser Registerkarte, auf der wir das gestartete Spiel spielen. <br><br>  Im oberen rechten Teil befindet sich das Fenster ‚ÄûInspector‚Äú.  In diesem Fenster zeigt Unity die Parameter des ausgew√§hlten Objekts an und wir k√∂nnen sie bearbeiten.  Insbesondere k√∂nnen wir sehen, dass die ausgew√§hlte Kamera zwei Komponenten aufweist: "Transformieren", mit der die Position der Kamera in der Spielwelt festgelegt wird, und "Kamera", mit der die Funktionalit√§t der Kamera implementiert wird. <br><br>  √úbrigens ist die Transform-Komponente in allen Spielobjekten in Unity in der einen oder anderen Form. <br><br>  Und schlie√ülich befindet sich unten auf der Registerkarte ‚ÄûProjekt‚Äú alle so genannten Assets, die sich in unserem Projekt befinden.  Assets sind Datendateien wie Texturen, Sprites, 3D-Modelle, Animationen, Sounds und Musik sowie Konfigurationsdateien.  Das sind alle Daten, mit denen wir Ebenen oder die Benutzeroberfl√§che erstellen k√∂nnen.  Unity versteht eine Vielzahl von Standardformaten (z. B. PNG und JPG f√ºr Bilder oder FBX f√ºr 3D-Modelle), sodass das Laden von Daten in ein Projekt problemlos m√∂glich ist.  Und wenn Sie wie ich nicht wissen, wie man zeichnet, k√∂nnen Sie Assets aus dem Unity Asset Store herunterladen, der eine riesige Sammlung von Ressourcen aller Art enth√§lt: sowohl kostenlos als auch f√ºr Geld. <br><br>  Rechts neben der Registerkarte "Projekt" wird die inaktive Registerkarte "Konsole" angezeigt.  Unity schreibt Warnungen und Fehlermeldungen an die Konsole. √úberpr√ºfen Sie sie daher regelm√§√üig.  Vor allem, wenn etwas nicht funktioniert - h√∂chstwahrscheinlich weist die Konsole auf die Ursache des Problems hin.  Au√üerdem kann die Konsole Meldungen aus dem Spielcode zum Debuggen anzeigen. <br><br><h2>  Erstelle eine Spielwelt </h2><br>  Da ich Programmierer bin und schlechter zeichne als H√ºhnchenpfote, habe ich f√ºr die Grafiken ein paar kostenlose Assets aus dem Unity Asset Store genommen.  Links dazu finden Sie am Ende dieses Artikels. <br><br>  Aus diesen Assets habe ich ein einfaches Level zusammengestellt, mit dem wir arbeiten werden: <br><br><img src="https://habrastorage.org/webt/07/y-/cr/07y-crxk0zc6zywqh8vga90qg-s.jpeg"><br><br>  Keine Zauberei, ich habe einfach die gew√ºnschten Objekte aus dem Projektfenster gezogen und sie mit der Maus nach Belieben angeordnet: <br><br><img src="https://habrastorage.org/webt/ll/xb/ca/llxbca3cdunouswhcy2b4jgpgha.gif"><br><br>  √úbrigens: Mit Unity k√∂nnen Sie der Szene mit einem Klick Standardobjekte hinzuf√ºgen, z. B. einen W√ºrfel, eine Kugel oder eine Ebene.  Klicken Sie dazu einfach mit der rechten Maustaste in das Hierarchiefenster und w√§hlen Sie beispielsweise 3D-Objekt - Ebene.  Also wird der Asphalt in meinem Level nur aus einer Reihe von Ebenen zusammengesetzt, auf die ich eine Textur aus einer Reihe von Assets "gezogen" habe. <br><br>  NB Wenn Sie sich fragen, warum ich viele Ebenen und keine mit gro√üen Skalenwerten verwendet habe, ist die Antwort ganz einfach: Eine Ebene mit gro√üem Ma√üstab hat eine stark vergr√∂√üerte Textur, die in Bezug auf andere Objekte in der Szene unnat√ºrlich aussieht (dies kann mit den Parametern behoben werden) Material, aber wir versuchen alles so einfach wie m√∂glich zu machen, oder?) <br><br><h2>  Zombies auf der Suche nach einem Weg </h2><br>  Wir haben also ein Spiellevel, aber es passiert noch nichts.  In unserem Spiel jagen Zombies den Spieler und greifen ihn an. Dazu m√ºssen sie sich auf den Spieler zubewegen und Hindernisse umgehen k√∂nnen. <br><br>  Um dies zu implementieren, verwenden wir das Werkzeug ‚ÄûNavigationsnetz‚Äú.  Basierend auf den Szenendaten berechnet dieses Tool die Bereiche, in denen Sie sich bewegen k√∂nnen, und generiert einen Datensatz, mit dem Sie w√§hrend des Spiels nach der optimalen Route von einem beliebigen Punkt im Level zu einem anderen suchen k√∂nnen.  Diese Daten werden im Asset gespeichert und k√∂nnen in Zukunft nicht mehr ge√§ndert werden - dieser Vorgang wird als "Backen" bezeichnet.  Wenn Sie sich dynamisch √§ndernde Hindernisse ben√∂tigen, k√∂nnen Sie die NavMeshObstacle-Komponente verwenden, dies ist jedoch f√ºr unser Spiel nicht erforderlich. <br><br>  Ein wichtiger Punkt: Damit Unity wei√ü, welche Objekte in die Berechnung einbezogen werden sollen, klicken Sie im Inspektor f√ºr jedes Objekt (Sie k√∂nnen alles auf einmal im Hierarchiefenster ausw√§hlen) auf den Abw√§rtspfeil neben der Option ‚ÄûStatisch‚Äú und aktivieren Sie ‚ÄûNavigationsstatisch‚Äú: <br><br><img src="https://habrastorage.org/webt/d9/us/wk/d9uswkd5hafxmqqxlr3ujr0ed_u.jpeg"><br><br>  Im Allgemeinen sind die verbleibenden Punkte auch n√ºtzlich und helfen Unity, das Rendern von Szenen zu optimieren.  Wir werden uns heute nicht mit ihnen befassen, aber wenn Sie mit dem Erlernen der Grundlagen des Motors fertig sind, empfehle ich dringend, dass Sie sich auch mit anderen Parametern befassen.  Manchmal kann ein einzelnes H√§kchen die Bildrate erheblich erh√∂hen. <br><br>  Nun verwenden wir den Men√ºpunkt Window‚á®AI‚á®Navigation und w√§hlen im sich √∂ffnenden Fenster die Registerkarte ‚ÄûBake‚Äú.  Hier bietet Unity an, Parameter wie die H√∂he und den Radius des Zeichens, den maximalen Neigungswinkel der Erde, auf dem Sie noch gehen k√∂nnen, die maximale H√∂he der Stufen usw. festzulegen.  Wir werden noch nichts √§ndern und dr√ºcken Sie einfach die Taste "Backen". <br><br><img src="https://habrastorage.org/webt/zs/my/uo/zsmyuoqaopw11zon8bua6arf9aa.gif"><br><br>  Unity f√ºhrt die notwendigen Berechnungen durch und zeigt uns das Ergebnis: <br><br><img src="https://habrastorage.org/webt/3q/lg/t6/3qlgt6ze2hkj5sv8npdlr6ohkk8.jpeg"><br><br>  Hier kennzeichnet Blau den Bereich, in dem Sie gehen k√∂nnen.  Wie Sie sehen, hat Unity eine kleine Seite um Hindernisse herum gelassen - die Breite dieser Seite h√§ngt vom Radius des Charakters ab.  Befindet sich die Mitte des Charakters in der blauen Zone, wird er nicht durch die Hindernisse "fallen". <br><br>  Mit einem berechneten Navigationsraster k√∂nnen wir die NavMeshAgent-Komponente verwenden, um nach der Bewegungsroute zu suchen und die Bewegung von Spielobjekten auf unserer Ebene zu steuern. <br><br>  Lassen Sie uns ein "Zombie" -Spielobjekt erstellen, ein 3D-Modell von Zombies aus Assets hinzuf√ºgen und auch die NavMeshAgent-Komponente: <br><br><img src="https://habrastorage.org/webt/ij/jy/cb/ijjycbpwk8kjyyhkhter8jrbu7g.gif"><br><br>  Wenn Sie das Spiel jetzt starten, passiert nichts.  Wir m√ºssen der NavMeshAgent-Komponente mitteilen, wohin sie gehen soll.  Dazu erstellen wir unsere erste Komponente in C #. <br><br>  W√§hlen Sie im Projektfenster das Stammverzeichnis (es hei√üt "Assets") und klicken Sie in der Liste der Dateien mit der rechten Maustaste, um das Verzeichnis "Scripts" zu erstellen.  Wir werden alle unsere Skripte darin speichern, damit das Projekt Ordnung hat.  Jetzt erstellen wir in den "Skripten" ein "Zombie" -Skript und f√ºgen es dem Zombie-Spielobjekt hinzu: <br><br><img src="https://habrastorage.org/webt/dz/_d/a1/dz_da1d0ybbvslw1g3tvkq8vgau.gif"><br><br>  Ein Doppelklick auf das Skript √∂ffnet es im Editor.  Mal sehen, was die Einheit f√ºr uns geschaffen hat. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Zombie</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { } }</span></span></code> </pre> <br>  Dies ist eine leere Standardkomponente.  Wie wir sehen k√∂nnen, hat Unity die System.Collections- und System.Collections.Generic-Bibliotheken mit uns verbunden (jetzt werden sie nicht ben√∂tigt, aber sie werden h√§ufig im Unity-Spielecode ben√∂tigt, sodass sie in der Standardvorlage enthalten sind) sowie die UnityEngine-Bibliothek, die alle enth√§lt Core Engine API. <br><br>  Au√üerdem hat Unity die Zombie-Klasse f√ºr uns erstellt (der Name stimmt mit dem Dateinamen √ºberein; dies ist wichtig: Wenn sie nicht √ºbereinstimmen, kann Unity das Skript nicht mit der Komponente in der Szene abgleichen).  Die Klasse wird von MonoBehaviour geerbt - dies ist die Basisklasse f√ºr vom Benutzer erstellte Komponenten. <br><br>  Innerhalb der Klasse hat Unity zwei Methoden f√ºr uns erstellt: Start und Update.  Die Engine ruft diese Methoden selbst auf: Startet - unmittelbar nachdem die Szene geladen wurde, und Update - jeden Frame.  In der Tat gibt es viele solcher Funktionen, die von der Engine aufgerufen werden, aber die meisten davon werden wir heute nicht mehr ben√∂tigen.  Die vollst√§ndige Liste sowie die Reihenfolge der Aufrufe finden Sie immer in der Dokumentation: <a href="https://docs.unity3d.com/Manual/ExecutionOrder.html">https://docs.unity3d.com/Manual/ExecutionOrder.html</a> <br><br>  Lassen Sie uns die Zombies auf der Karte bewegen! <br><br>  Zuerst m√ºssen wir die UnityEngine.AI-Bibliothek verbinden.  Es enth√§lt die NavMeshAgent-Klasse und andere Klassen, die sich auf das Navigationsraster beziehen.  F√ºgen Sie dazu die using UnityEngine.AI-Direktive am Anfang der Datei hinzu. <br><br>  Als n√§chstes m√ºssen wir auf die NavMeshAgent-Komponente zugreifen.  Dazu k√∂nnen wir die Standardmethode GetComponent verwenden.  Hiermit k√∂nnen Sie eine Verkn√ºpfung zu jeder Komponente im selben Spielobjekt herstellen, in der sich die Komponente befindet, von der aus wir diese Methode aufrufen (in unserem Fall das Spielobjekt ‚ÄûZombie‚Äú).  Lassen Sie uns das Feld NavMeshAgent navMeshAgent in der Klasse abrufen. In der Start-Methode erhalten wir einen Link zu NavMeshAgent und fordern Sie auf, zum Punkt (0, 0, 0) zu wechseln.  Wir sollten dieses Skript bekommen: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Zombie</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { NavMeshAgent navMeshAgent; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { navMeshAgent = GetComponent&lt;NavMeshAgent&gt;(); navMeshAgent.SetDestination(Vector3.zero); } // Update is called once per frame void Update() { } }</span></span></code> </pre> <br>  Wenn Sie das Spiel starten, werden Sie sehen, wie sich der Zombie in die Mitte der Karte bewegt: <br><br><img src="https://habrastorage.org/webt/dx/uz/u1/dxuzu157nhtqaj85o0afxbm_s7k.gif"><br><br><h2>  Zombies jagen ein Opfer </h2><br>  Gro√üartig  Aber unsere Zombies sind gelangweilt und einsam. Lassen Sie uns f√ºr ihn das <s>Opfer eines</s> Spielers in das Spiel aufnehmen. <br><br>  In Analogie zu Zombies erstellen wir ein "Spieler" -Spielobjekt (dieses Mal w√§hlen wir ein 3D-Modell eines Polizeibeamten aus). Au√üerdem f√ºgen wir die NavMeshAgent-Komponente und das neu erstellte Spielerskript hinzu.  Wir werden den Inhalt des Player-Skripts noch nicht ber√ºhren, m√ºssen jedoch √Ñnderungen am Zombie-Skript vornehmen.  Au√üerdem empfehle ich, den Priority-Eigenschaftswert des Players in der NavMeshAgent-Komponente auf 10 zu setzen (oder einen anderen Wert, der unter dem Standardwert von 50 liegt, dh dem Player eine h√∂here Priorit√§t zuzuweisen).  In diesem Fall k√∂nnen die Zombies den Spieler nicht bewegen, wenn sich der Spieler und die Zombies auf der Karte treffen, w√§hrend der Spieler die Zombies hinausschieben kann. <br><br>  Um einen Spieler zu jagen, muss ein Zombie seine Position kennen.  Dazu m√ºssen wir in unserer Zombie-Klasse einen Link mit der Standardmethode FindObjectOfType erstellen.  Nachdem wir uns an den Link erinnert haben, k√∂nnen wir uns der Transformationskomponente des Spielers zuwenden und ihn nach dem Positionswert fragen.  Damit der Zombie den Spieler immer und nicht erst zu Beginn des Spiels verfolgt, legen wir in der Update-Methode ein Ziel f√ºr NavMeshAgent fest.  Sie erhalten folgendes Skript: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Zombie</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { NavMeshAgent navMeshAgent; Player player; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { navMeshAgent = GetComponent&lt;NavMeshAgent&gt;(); player = FindObjectOfType&lt;Player&gt;(); } // Update is called once per frame void Update() { navMeshAgent.SetDestination(player.transform.position); } }</span></span></code> </pre> <br>  Starte das Spiel und stelle sicher, dass der Zombie sein Opfer gefunden hat: <br><br><img src="https://habrastorage.org/webt/j3/lv/vc/j3lvvcaltksjiu44tzh-rijewi4.gif"><br><br><h2>  Flucht Flucht </h2><br>  Unser Spieler steht wie ein Idol.  Dies wird ihm eindeutig nicht helfen, in einer so aggressiven Welt zu √ºberleben. Sie m√ºssen ihm also beibringen, sich auf der Karte zu bewegen. <br><br>  Dazu ben√∂tigen wir Informationen zu den von Unity gedr√ºckten Tasten.  Die GetKey-Methode der Standard-Input-Klasse liefert nur solche Informationen! <br><br>  NB Im Allgemeinen ist diese Art der Eingabe nicht ganz kanonisch.  Es ist besser, Input.GetAxis zu verwenden und √ºber Project Settings (Projekteinstellungen) Input Manager zu binden.  Besser noch, <a href="https://blogs.unity3d.com/ru/2019/10/14/introducing-the-new-input-system/">neues Eingabesystem</a> .  Dieser Artikel erwies sich jedoch als zu lang. Machen wir es uns also so einfach wie m√∂glich. <br><br>  √ñffnen Sie das Player-Skript und √§ndern Sie es wie folgt: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Player</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { NavMeshAgent navMeshAgent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moveSpeed; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { navMeshAgent = GetComponent&lt;NavMeshAgent&gt;(); } // Update is called once per frame void Update() { Vector3 dir = Vector3.zero; if (Input.GetKey(KeyCode.LeftArrow)) dir.z = -1.0f; if (Input.GetKey(KeyCode.RightArrow)) dir.z = 1.0f; if (Input.GetKey(KeyCode.UpArrow)) dir.x = -1.0f; if (Input.GetKey(KeyCode.DownArrow)) dir.x = 1.0f; navMeshAgent.velocity = dir.normalized * moveSpeed; } }</span></span></code> </pre> <br>  Wie bei Zombies erhalten wir bei der Start-Methode einen Link zur NavMeshAgent-Komponente des Players und speichern sie im Klassenfeld.  Jetzt haben wir aber auch das moveSpeed-Feld hinzugef√ºgt. <br>  Da dieses Feld √∂ffentlich ist, kann sein Wert direkt im Inspector in Unity bearbeitet werden!  Wenn Sie einen Spieledesigner in Ihrem Team haben, wird er sich sehr freuen, dass er nicht in den Code gehen muss, um die Parameter des Spielers zu bearbeiten. <br><br>  Setze 10 als Geschwindigkeit: <br><br><img src="https://habrastorage.org/webt/o9/ro/cx/o9rocx0w0v3djxjgdt35ca59aug.gif"><br><br>  Bei der Update-Methode √ºberpr√ºfen wir mit Input.GetKey, ob einer der Pfeile auf der Tastatur gedr√ºckt ist, und bilden einen Richtungsvektor f√ºr den Player.  Beachten Sie, dass wir die X- und Z-Koordinaten verwenden, da in Unity die Y-Achse in den Himmel schaut und sich die Erde in der XZ-Ebene befindet. <br><br>  Nachdem wir einen Richtungsvektor f√ºr die Bewegungsrichtung gebildet haben, normalisieren wir ihn (andernfalls ist der Vektor etwas l√§nger als ein einzelner, wenn der Spieler sich diagonal bewegen m√∂chte, und diese Bewegung ist schneller als eine direkte Bewegung) und multiplizieren sie mit der angegebenen Bewegungsgeschwindigkeit.  Das Ergebnis wird an navMeshAgent.velocity √ºbergeben und der Agent erledigt den Rest. <br><br>  Durch das Starten des Spiels k√∂nnen wir endlich versuchen, den Zombies an einen sicheren Ort zu entkommen: <br><br><img src="https://habrastorage.org/webt/mn/gv/7w/mngv7wimzjqsdlfja2ghro-ovn8.gif"><br><br>  Um die Kamera mit dem Player zu bewegen, schreiben wir ein weiteres einfaches Skript.  Nennen wir es "PlayerCamera": <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PlayerCamera</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { Player player; Vector3 offset; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { player = FindObjectOfType&lt;Player&gt;(); offset = transform.position - player.transform.position; } // Update is called once per frame void LateUpdate() { transform.position = player.transform.position + offset; } }</span></span></code> </pre> <br>  Die Bedeutung dieses Skripts sollte weitgehend verstanden werden.  Von Funktionen - hier anstelle von Update verwenden wir LateUpdate.  Diese Methode √§hnelt Update, wird jedoch immer strikt nach Abschluss von Update f√ºr alle Skripte in der Szene aufgerufen.  In diesem Fall verwenden wir LateUpdate, da es f√ºr uns wichtig ist, dass NavMeshAgent die neue Position des Players berechnet, bevor wir die Kamera bewegen.  Andernfalls kann ein unangenehmer "Ruck" -Effekt auftreten. <br><br>  Wenn Sie diese Komponente jetzt an das Spielobjekt "Hauptkamera" anh√§ngen und das Spiel starten, steht der Charakter des Spielers immer im Rampenlicht! <br><br><h2>  Moment der Animation </h2><br>  F√ºr einen Moment schweifen wir von den Problemen des √úberlebens unter den Bedingungen einer Zombie-Apokalypse ab und denken √ºber das Ewige nach - √ºber Kunst.  Unsere Figuren sehen jetzt aus wie animierte Statuen, die von einer unbekannten Kraft in Bewegung gesetzt werden (m√∂glicherweise Magnete unter dem Asphalt).  Und ich m√∂chte, dass sie wie echte, lebende (und nicht sehr lebende) Menschen aussehen - sie bewegten ihre Arme und Beine.  Die Animator-Komponente und ein Tool namens Animator Controller helfen uns dabei. <br><br>  Animator Controller ist eine Zustandsmaschine, in der wir bestimmte Zust√§nde festlegen (der Charakter steht, der Charakter ist an, der Charakter stirbt usw.), ihnen Animationen hinzuf√ºgen und die Regeln f√ºr den √úbergang von einem Zustand in einen anderen festlegen.  Unity wechselt automatisch von einer Animation zur n√§chsten, sobald die entsprechende Regel funktioniert. <br><br>  Erstellen wir einen Animator-Controller f√ºr Zombies.  Erstellen Sie dazu das Animationsverzeichnis im Projekt (merken Sie sich die Reihenfolge im Projekt) und dort - mit der rechten Maustaste - Animator Controller.  Und nennen wir ihn "Zombie".  Doppelklick - und der Editor erscheint vor uns: <br><br><img src="https://habrastorage.org/webt/t1/54/ak/t154aknnrk7f0lwdlcmvj69uxqo.png"><br><br>  Bisher gibt es hier keine Bundesstaaten, aber es gibt zwei Einstiegspunkte (‚ÄûEntry‚Äú und ‚ÄûAny State‚Äú) und einen Ausstiegspunkt (‚ÄûExit‚Äú).  Ziehen Sie einige Animationen aus den Assets: <br><br><img src="https://habrastorage.org/webt/xg/cx/gw/xgcxgwkbtqsbqux7cj9y5qnwnk0.gif"><br><br>  Wie Sie sehen, hat Unity die erste Animation beim Ziehen automatisch an den Entry-Einstiegspunkt gebunden.  Dies ist die sogenannte Standardanimation.  Es wird sofort nach dem Start des Levels gespielt. <br><br>  Um in einen anderen Status zu wechseln (und eine andere Animation abzuspielen), m√ºssen √úbergangsregeln erstellt werden.  Dazu m√ºssen wir zun√§chst einen Parameter hinzuf√ºgen, den wir aus dem Code zum Verwalten von Animationen festlegen. <br><br>  In der oberen linken Ecke des Editorfensters befinden sich zwei Schaltfl√§chen: ‚ÄûEbenen‚Äú und ‚ÄûParameter‚Äú.  Standardm√§√üig ist die Registerkarte ‚ÄûEbenen‚Äú ausgew√§hlt, wir m√ºssen jedoch zu ‚ÄûParameter‚Äú wechseln.  Jetzt k√∂nnen wir mit der Schaltfl√§che ‚Äû+‚Äú einen neuen Parameter vom Typ float hinzuf√ºgen.  Nennen wir es "Geschwindigkeit": <br><br><img src="https://habrastorage.org/webt/po/is/nj/poisnjmj39qel2ofz_meiyginsw.gif"><br><br>  Jetzt m√ºssen wir Unity mitteilen, dass die Animation "Z_run" abgespielt werden soll, wenn die Geschwindigkeit gr√∂√üer als 0 ist, und "Z_idle_A", wenn die Geschwindigkeit Null ist.  Dazu m√ºssen wir zwei √úberg√§nge erstellen: einen von "Z_idle_A" nach "Z_run" und den anderen in die entgegengesetzte Richtung. <br><br>  Beginnen wir mit dem √úbergang vom Leerlauf zum Betrieb.  Klicken Sie mit der rechten Maustaste auf das Rechteck "Z_idle_A" und w√§hlen Sie "Make Transition".  Es erscheint ein Pfeil, auf den Sie die Parameter konfigurieren k√∂nnen.  Zuerst m√ºssen Sie das H√§kchen bei "Hat Austrittszeit" entfernen.  Ist dies nicht der Fall, wird die Animation nicht gem√§√ü unserer Bedingung umgeschaltet, sondern erst, wenn die vorherige Wiedergabe beendet ist.  Wir brauchen das √ºberhaupt nicht, also deaktivieren wir es.  Zweitens m√ºssen Sie unten in der Liste der Bedingungen (‚ÄûConditions‚Äú) auf ‚Äû+‚Äú klicken, und Unity f√ºgt uns eine Bedingung hinzu.  Die Standardwerte in diesem Fall sind genau das, was wir brauchen: Der Parameter "Geschwindigkeit" muss gr√∂√üer als Null sein, um vom Leerlauf in den Betrieb zu wechseln. <br><br><img src="https://habrastorage.org/webt/vt/rw/qy/vtrwqy-jyfhgrai9ruymphu_mwi.gif"><br><br>  In Analogie erzeugen wir einen √úbergang in die entgegengesetzte Richtung, aber als Bedingung geben wir jetzt "Geschwindigkeit" kleiner als 0,0001 an.  Es gibt keine Gleichheitspr√ºfungen f√ºr Parameter vom Typ float, sie k√∂nnen nur f√ºr mehr / weniger verglichen werden: <br><br><img src="https://habrastorage.org/webt/vz/ki/bu/vzkibunzaoxqfdfysekucvcqepa.png"><br><br>  Nun m√ºssen Sie den Controller an das Spielobjekt binden.  Wir w√§hlen das 3D-Modell des Zombies in der Szene aus (dies ist ein Kind des "Zombie" -Objekts) und ziehen den Controller mit der Maus in das entsprechende Feld in der Animator-Komponente: <br><br><img src="https://habrastorage.org/webt/lr/pv/pq/lrpvpqbl__neecouj3uyxdepqka.gif"><br><br>  Es muss nur noch ein Skript geschrieben werden, das den Geschwindigkeitsparameter steuert! <br><br>  Erstellen Sie das MovementAnimator-Skript mit den folgenden Inhalten: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MovementAnimator</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { NavMeshAgent navMeshAgent; Animator animator; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { navMeshAgent = GetComponent&lt;NavMeshAgent&gt;(); animator = GetComponentInChildren&lt;Animator&gt;(); } // Update is called once per frame void Update() { animator.SetFloat("speed", navMeshAgent.velocity.magnitude); } }</span></span></code> </pre> <br>  Hier erhalten wir wie in anderen Skripten in der Start-Methode Zugriff auf NavMeshAgent.  Wir erhalten auch Zugriff auf die Animator-Komponente. Da wir jedoch die MovementAnimator-Komponente an das Zombie-Spielobjekt anh√§ngen und der Animator sich im untergeordneten Objekt befindet, m√ºssen wir anstelle von GetComponent die Standardmethode GetComponentInChildren verwenden. <br><br>  Bei der Update-Methode fragen wir NavMeshAgent nach seinem Geschwindigkeitsvektor, berechnen seine L√§nge und √ºbergeben ihn als Geschwindigkeitsparameter an den Animator.  Keine Magie, alles in der Wissenschaft! <br><br>  F√ºgen Sie nun die MovementAnimator-Komponente zum Zombie-Spielobjekt hinzu und wenn das Spiel startet, sehen wir, dass die Zombies jetzt animiert sind: <br><br><img src="https://habrastorage.org/webt/uz/da/yt/uzdaytgsxzstqj8rnzx11rfa8ti.gif"><br><br>  Da wir den Animator-Steuercode in einer separaten MovementAnimation-Komponente platziert haben, kann er problemlos f√ºr den Player hinzugef√ºgt werden.  Es muss nicht einmal ein Controller von Grund auf neu erstellt werden. Sie k√∂nnen einen Zombie-Controller kopieren (indem Sie die Datei "Zombie" ausw√§hlen und Strg + D dr√ºcken) und die Animationen in den Statusrechtecken durch "m_idle_" und "m_run" ersetzen.  Alles andere ist wie ein Zombie.  Ich √ºberlasse Ihnen dies als √úbung (oder laden Sie den Code am Ende des Artikels herunter). <br><br>  Eine kleine Erg√§nzung, die n√ºtzlich ist, ist das Hinzuf√ºgen der folgenden Zeilen zur Zombie-Klasse: <br><br>  In der Start-Methode: <br><br><pre> <code class="cs hljs">navMeshAgent.updateRotation = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  In der Update-Methode: <br><br><pre> <code class="cs hljs">transform.rotation = Quaternion.LookRotation(navMeshAgent.velocity.normalized);</code> </pre> <br>  In der ersten Zeile wird NavMeshAgent mitgeteilt, dass er die Drehung des Zeichens nicht steuern soll, wir werden es selbst tun.  In der zweiten Zeile wird der Zug des Charakters in dieselbe Richtung gesetzt, in die seine Bewegung gerichtet ist.  NavMeshAgent interpoliert standardm√§√üig den Drehwinkel des Zeichens und dies sieht nicht besonders gut aus (der Zombie dreht sich langsamer als die Bewegungsrichtung √§ndert).  Durch Hinzuf√ºgen dieser Zeilen wird dieser Effekt entfernt. <br><br>  NB Wir verwenden das Quaternion, um die Rotation zu spezifizieren.  In dreidimensionalen Grafiken sind die Hauptmethoden zum Angeben der Drehung eines Objekts Euler-Winkel, Drehmatrizen und Quaternionen.  Die ersten beiden sind nicht immer bequem zu bedienen und unterliegen auch so einem unangenehmen Effekt wie ‚ÄûGimbal Lock‚Äú.  Quaternionen haben diesen Nachteil nicht mehr und werden heute fast universell eingesetzt.  Unity bietet praktische Werkzeuge f√ºr die Arbeit mit Quaternionen (sowie mit Matrizen und Euler-Winkeln), mit denen Sie nicht auf Details des Ger√§ts dieses mathematischen Ger√§ts eingehen k√∂nnen. <br><br><h2>  Ich sehe das Ziel </h2><br>  Gro√üartig, jetzt k√∂nnen wir den Zombies entkommen.  Aber das ist nicht genug, fr√ºher oder sp√§ter wird ein zweiter Zombie auftauchen, dann ein dritter, f√ºnfter, zehnter ... aber du kannst nicht einfach vor der Menge davonlaufen.  Um zu √ºberleben, musst du t√∂ten.  Au√üerdem hat der Spieler bereits eine Waffe in der Hand. <br><br>  Damit der Spieler schie√üen kann, m√ºssen Sie ihm die M√∂glichkeit geben, ein Ziel auszuw√§hlen.  Dazu platzieren Sie den mausgesteuerten Cursor auf dem Boden. <br><br>  Auf dem Bildschirm bewegt sich der Mauszeiger im zweidimensionalen Raum - der Oberfl√§che des Monitors.  Gleichzeitig ist unsere Spielszene dreidimensional.  Der Betrachter sieht die Szene durch sein Auge, wo alle Lichtstrahlen an einem Punkt zusammenlaufen.  Wenn wir all diese Strahlen kombinieren, erhalten wir eine Pyramide der Sichtbarkeit: <br><br><img src="https://habrastorage.org/webt/hl/bg/p5/hlbgp55snbpv2cxacycfmxbd_hw.png"><br><br>  Das Auge des Betrachters sieht nur, was in diese Pyramide f√§llt.  Dar√ºber hinaus schneidet der Motor diese Pyramide gezielt von zwei Seiten ab: Erstens befindet sich auf der Seite des Betrachters ein Monitorbildschirm, die sogenannte ‚ÄûNahe Ebene‚Äú (in der Abbildung ist sie gelb gestrichen).  Der Monitor kann keine Objekte anzeigen, die n√§her als der Bildschirm sind, sodass der Motor sie abschneidet.  Zweitens kann die Engine, da der Computer √ºber eine begrenzte Anzahl von Ressourcen verf√ºgt, die Strahlen nicht bis ins Unendliche ausdehnen (zum Beispiel muss f√ºr den Tiefenpuffer ein bestimmter Bereich m√∂glicher Werte festgelegt werden; je breiter er ist, desto geringer ist die Genauigkeit), sodass die Pyramide hinter der sogenannten abgeschnitten wird "Weites Flugzeug". <br><br>  Da sich der Mauszeiger entlang der nahen Ebene bewegt, k√∂nnen wir den Strahl an der Stelle ausl√∂sen, an der er sich tief in der Szene befindet.  Das erste Objekt, mit dem es sich schneidet, ist das Objekt, auf das der Mauszeiger aus Sicht des Betrachters zeigt. <br><br><img src="https://habrastorage.org/webt/rd/xf/kn/rdxfkn9vevlzr8qz5qtronl05vi.png"><br><br>  Um einen solchen Strahl zu erstellen und seine Schnittmenge mit Objekten in der Szene zu finden, k√∂nnen Sie die Raycast-Standardmethode aus der Physikklasse verwenden.  Wenn wir diese Methode verwenden, wird der Schnittpunkt mit allen Objekten in der Szene gefunden - Erde, Mauern, Zombies ... Wir m√∂chten jedoch, dass sich der Cursor nur auf dem Boden bewegt. Daher m√ºssen wir Unity irgendwie erkl√§ren, dass die Suche nach Schnittpunkten nur begrenzt sein soll eine gegebene Menge von Objekten (in unserem Fall nur die Ebenen der Erde). <br><br>  Wenn Sie ein Spielobjekt in der Szene ausw√§hlen, wird im oberen Bereich des Inspektors die Dropdown-Liste ‚ÄûEbene‚Äú angezeigt.  Standardm√§√üig gibt es den Wert "Standard".  Wenn Sie die Dropdown-Liste √∂ffnen, finden Sie darin das Element "Ebene hinzuf√ºgen ...", wodurch das Ebeneneditorfenster ge√∂ffnet wird.  Im Editor m√ºssen Sie eine neue Ebene hinzuf√ºgen (nennen wir es "Ground"): <br><br><img src="https://habrastorage.org/webt/3w/5g/pc/3w5gpczarjjyhhtombqxbxq68wk.gif"><br><br>  Jetzt k√∂nnen Sie alle Grundebenen in der Szene ausw√§hlen und diese Dropdown-Liste verwenden, um ihnen die Grundebene zuzuweisen.  Auf diese Weise k√∂nnen wir der Physics.Raycast-Methode im Skript mitteilen, dass nur mit diesen Objekten der Schnittpunkt des Strahls √ºberpr√ºft werden muss. <br><br>  Ziehen wir nun das Cursor-Sprite aus den Assets in die Szene (ich verwende Spags Assets‚á®Textures‚á®Demo‚á®white_hip‚á®white_hip_14): <br><br><img src="https://habrastorage.org/webt/ha/mw/aa/hamwaarhcaodn7q-y-e5qkps5kc.gif"><br><br>  Ich habe dem Cursor eine 90-Grad-Drehung um die X-Achse hinzugef√ºgt, damit er horizontal auf dem Boden liegt. Stellen Sie die Skala auf 0,25 ein, damit sie nicht so gro√ü ist, und legen Sie die Y-Koordinate auf 0,01 fest.  Letzteres ist wichtig, damit es keinen Effekt gibt, der als "Z-Fighting" bezeichnet wird.  Die Grafikkarte ermittelt anhand von Gleitkommaberechnungen, welche Objekte n√§her an der Kamera liegen.  Wenn Sie den Cursor auf 0 setzen (d. H. Den gleichen Wert wie die Grundebene), entscheidet die Grafikkarte aufgrund von Fehlern bei diesen Berechnungen f√ºr einige Pixel, dass der Cursor n√§her und f√ºr andere die Erde ist.  Dar√ºber hinaus sind die Pixelmengen in verschiedenen Frames unterschiedlich, was zu einem unangenehmen Effekt f√ºhrt, bei dem Teile des Cursors durch den Boden leuchten und flackern, wenn er sich bewegt.  Der Wert 0,01 ist gro√ü genug, um die Fehler bei der Berechnung der Grafikkarte auszugleichen, aber nicht so gro√ü, dass das Auge bemerkt, dass der Cursor in der Luft h√§ngt. <br><br>  Benenne nun das Spielobjekt in Cursor um und erstelle ein gleichnamiges Skript mit folgendem Inhalt: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Cursor</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { SpriteRenderer spriteRenderer; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> layerMask; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { spriteRenderer = GetComponent&lt;SpriteRenderer&gt;(); layerMask = LayerMask.GetMask("Ground"); } // Update is called once per frame void Update() { Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; if (!Physics.Raycast(ray, out hit, 1000, layerMask)) spriteRenderer.enabled = false; else { transform.position = new Vector3(hit.point.x, transform.position.y, hit.point.z); spriteRenderer.enabled = true; } } }</span></span></code> </pre> <br>  Da der Cursor ein Sprite ist (zweidimensionale Zeichnung), verwendet Unity die SpriteRenderer-Komponente zum Rendern.  Wir erhalten eine Verkn√ºpfung zu dieser Komponente in der Start-Methode, um sie bei Bedarf ein- und ausschalten zu k√∂nnen. <br><br>  Auch bei der Start-Methode konvertieren wir den Namen der zuvor erstellten "Ground" -Ebene in eine Bitmaske.  Unity verwendet bitweise Operationen zum Filtern von Objekten, wenn nach Schnittpunkten gesucht wird, und die LayerMask.GetMask-Methode gibt die der angegebenen Ebene entsprechende Bitmaske zur√ºck. <br><br>  Bei der Update-Methode greifen wir mit Camera.main auf die Hauptkamera der Szene zu und fordern sie auf, die zweidimensionalen Koordinaten der Maus (erhalten mit Input.mousePosition) in einen dreidimensionalen Strahl umzurechnen.  Als N√§chstes √ºbergeben wir diesen Strahl an die Physics.Raycast-Methode und pr√ºfen, ob er sich mit einem Objekt in der Szene schneidet.  Ein Wert von 1000 ist die maximale Entfernung.  In der Mathematik sind die Strahlen endlos, die Rechenressourcen und der Speicher eines Computers jedoch nicht.  Aus diesem Grund bittet uns Unity, eine angemessene maximale Entfernung zu bestimmen. <br><br>  Wenn es keine Kreuzung gab, schalten wir den SpriteRenderer aus und das Cursorbild verschwindet vom Bildschirm.  Wenn der Schnittpunkt gefunden wurde, bewegen wir den Cursor zum Schnittpunkt.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitte beachten Sie, dass wir die Y-Koordinate nicht √§ndern, da der Schnittpunkt des Strahls mit dem Boden Y gleich Null hat. Wenn wir ihn unserem Cursor zuweisen, erhalten wir erneut den Z-Kampf-Effekt, den wir oben loswerden wollten. </font><font style="vertical-align: inherit;">Daher nehmen wir nur die X- und Z-Koordinaten vom Schnittpunkt und Y bleibt gleich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie die Cursor-Komponente zum Cursor-Spielobjekt hinzu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns nun das Player-Skript fertigstellen: F√ºgen Sie zuerst das Cursor-Cursor-Feld hinzu. </font><font style="vertical-align: inherit;">F√ºgen Sie dann in der Start-Methode die folgenden Zeilen hinzu:</font></font><br><br><pre> <code class="cs hljs">cursor = FindObjectOfType&lt;Cursor&gt;(); navMeshAgent.updateRotation = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und schlie√ülich, damit sich der Player immer zum Cursor dreht, f√ºgen Sie in der Update-Methode Folgendes hinzu: </font></font><br><br><pre> <code class="cs hljs">Vector3 forward = cursor.transform.position - transform.position; transform.rotation = Quaternion.LookRotation(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(forward.x, <span class="hljs-number"><span class="hljs-number">0</span></span>, forward.z));</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Auch hier ber√ºcksichtigen wir die Y-Koordinate nicht. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schie√üen Sie, um zu √ºberleben </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die blo√üe Drehung in Richtung des Cursors sch√ºtzt uns nicht vor Zombies, sondern entlastet nur den Charakter des Spielers von √úberraschungseffekten - jetzt k√∂nnen Sie sich nicht hinter ihn heranschleichen. Damit er in den harten Realit√§ten unseres Spiels wirklich √ºberleben kann, musst du ihm das Schie√üen beibringen. Und was ist das f√ºr eine Einstellung, wenn sie nicht sichtbar ist? Jeder wei√ü, dass jeder seri√∂se Sch√ºtze immer Markierungskugeln abschie√üt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie ein Shot-Spielobjekt und f√ºgen Sie die Standard-LineRenderer-Komponente hinzu. Geben Sie im Editor im Feld ‚ÄûBreite‚Äú eine kleine Breite ein, z. B. 0,04. Wie wir sehen k√∂nnen, malt Unity es mit einer hellvioletten Farbe - auf diese Weise werden Objekte ohne Material hervorgehoben.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Materialien sind ein wichtiges Element jeder dreidimensionalen Maschine. Die Verwendung von Materialien beschreibt das Erscheinungsbild des Objekts. Alle Lichtparameter, Texturen, Shader - all dies wird durch das Material beschrieben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns das Materialverzeichnis im Projekt erstellen und darin das Material als Gelb bezeichnen. W√§hlen Sie als Shader Unlit / Color. Dieser Standard-Shader enth√§lt keine Beleuchtung, sodass unsere Kugel auch im Dunkeln sichtbar ist. W√§hlen Sie die gelbe Farbe: </font></font><br><br><img src="https://habrastorage.org/webt/en/pt/im/enptimmi5wn6-9f5ssbqzh2fxko.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem das Material erstellt wurde, k√∂nnen Sie es LineRenderer zuweisen: </font></font><br><br><img src="https://habrastorage.org/webt/ow/qr/31/owqr314ai0hyyfx-hswunci5lzs.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie ein Shot-Skript:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Shot</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { LineRenderer lineRenderer; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> visible; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { lineRenderer = GetComponent&lt;LineRenderer&gt;(); } // Update is called once per frame void FixedUpdate() { if (visible) visible = false; else gameObject.SetActive(false); } public void Show(Vector3 from, Vector3 to) { lineRenderer.SetPositions(new Vector3[]{ from, to }); visible = true; gameObject.SetActive(true); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Skript muss, wie Sie wahrscheinlich bereits erraten haben, zum Shot-Spielobjekt hinzugef√ºgt werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier habe ich einen kleinen Trick benutzt, um eine Aufnahme f√ºr genau ein Bild mit einem Minimum an Code auf dem Bildschirm anzuzeigen. Zuerst benutze ich FixedUpdate anstelle von Update. Die FixedUpdate-Methode wird mit der angegebenen H√§ufigkeit aufgerufen (standardm√§√üig 60 Bilder pro Sekunde), auch wenn die tats√§chliche Bildrate instabil ist. Zweitens setze ich die Variable sichtbar, die ich auf wahr gesetzt habe, wenn ich die Aufnahme auf dem Bildschirm anzeige. Beim n√§chsten FixedUpdate setze ich es auf false zur√ºck und schalte erst im n√§chsten Frame das Spielobjekt des Schusses aus. Im Wesentlichen verwende ich eine boolesche Variable als Z√§hler von 1 bis 0.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Methode gameObject.SetActive aktiviert oder deaktiviert das gesamte Spielobjekt, auf dem sich unsere Komponente befindet. Deaktivierte Spielobjekte werden nicht auf dem Bildschirm angezeigt und ihre Komponenten rufen keine Update-, FixedUpdate-Methoden usw. auf. Mit dieser Methode k√∂nnen Sie den Schuss unsichtbar machen, wenn der Player nicht schie√üt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt auch eine √∂ffentliche Show-Methode im Skript, die wir im Player-Skript verwenden, um das Aufz√§hlungszeichen beim Abfeuern tats√§chlich anzuzeigen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber zuerst m√ºssen Sie in der Lage sein, die Koordinaten des Waffenrohrs zu ermitteln, damit der Schuss aus dem richtigen Loch kommt. </font><font style="vertical-align: inherit;">Suchen Sie dazu im 3D-Modell des Spielers das Objekt Bip001‚á®Bip001 Bip001 Pelvis‚á®Bip001 Spine‚á®Bip001 R Clavicle‚á®Bip001 R UpperArm‚á®Bip001 R Forearm‚á®Bip001 R Hand‚á®R_hand_container‚á®w_handgun und f√ºgen Sie das untergeordnete GunBarrel-Objekt hinzu. </font><font style="vertical-align: inherit;">Platzieren Sie es so, dass es direkt neben dem Gewehrlauf liegt: </font></font><br><br><img src="https://habrastorage.org/webt/kc/qc/ix/kcqcixwjeh_nf2qxqa6c7iriekk.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie nun im Player-Skript die Felder hinzu:</font></font><br><br><pre> <code class="cs hljs">Shot shot; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform gunBarrel;</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√ºgen Sie der Start-Methode des Player-Skripts Folgendes hinzu: </font></font><br><br><pre> <code class="cs hljs">shot = FindObjectOfType&lt;Shot&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und in der Update-Methode: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> = gunBarrel.position; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> target = cursor.transform.position; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> to = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(target.x, <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.y, target.z); shot.Show(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, to); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie sich vorstellen k√∂nnen, ist das hinzugef√ºgte √∂ffentliche Feld gunBarrel wie moveSpeed ‚Äã‚Äãfr√ºher im Inspector verf√ºgbar. </font></font><br><br><img src="https://habrastorage.org/webt/r2/3p/6g/r23p6g9wgzes9qh_fg8l41txjqs.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weisen wir </font><font style="vertical-align: inherit;">ihm das eigentliche Spielobjekt zu, das wir erstellt haben: </font><font style="vertical-align: inherit;">Wenn wir jetzt das Spiel starten, k√∂nnen wir endlich die Zombies erschie√üen! </font></font><br><br><img src="https://habrastorage.org/webt/gj/ek/sx/gjeksxqnsbieryc_qrv07cyqm44.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier stimmt etwas nicht! Es scheint, dass die Sch√ºsse keine Zombies t√∂ten, sondern einfach durchfliegen! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie sich unseren Schusscode ansehen, k√∂nnen wir nat√ºrlich nicht nachvollziehen, ob unser Schuss den Feind getroffen hat oder nicht. Zeichnen Sie einfach eine Linie zum Cursor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist ziemlich einfach zu beheben. F√ºgen Sie im Code f√ºr die Verarbeitung von Mausklicks in der Player-Klasse nach der Zeile var to = ... und vor der Zeile shot.Show (...) die folgenden Zeilen hinzu:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> direction = (to - <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>).normalized; RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, to - <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit, <span class="hljs-number"><span class="hljs-number">100</span></span>)) to = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(hit.point.x, <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.y, hit.point.z); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> to = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> + direction * <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier verwenden wir den bekannten Physics.Raycast, um den Strahl aus dem Lauf einer Waffe herauszulassen und festzustellen, ob er sich mit einem Spielobjekt schneidet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier gibt es jedoch eine Einschr√§nkung: Die Kugel wird immer noch durch die Zombies fliegen. Tatsache ist, dass der Autor des Assets den Objekten des Levels (Geb√§uden, Kisten usw.) einen Collider hinzugef√ºgt hat. Und der Autor des Assets mit den Charakteren nicht. Beheben wir dieses √§rgerliche Missverst√§ndnis.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Collider ist eine Komponente, mit der die Physik-Engine Kollisionen zwischen Objekten ermittelt. </font><font style="vertical-align: inherit;">Gew√∂hnlich werden einfache geometrische Formen als Kollider verwendet - W√ºrfel, Kugeln usw. </font><font style="vertical-align: inherit;">Obwohl dieser Ansatz weniger genaue Kollisionen liefert, sind die Schnittformeln zwischen solchen Objekten recht einfach und erfordern keine gro√üen Rechenressourcen. </font><font style="vertical-align: inherit;">Wenn Sie maximale Genauigkeit ben√∂tigen, k√∂nnen Sie nat√ºrlich immer die Leistung opfern und den MeshCollider verwenden. </font><font style="vertical-align: inherit;">Da wir jedoch keine hohe Genauigkeit ben√∂tigen, verwenden wir die CapsuleCollider-Komponente: </font></font><br><br><img src="https://habrastorage.org/webt/wp/t3/qo/wpt3qo9lebty_w7hlawpe11le9u.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt fliegt die Kugel nicht mehr durch die Zombies. </font><font style="vertical-align: inherit;">Die Zombies sind jedoch immer noch unsterblich.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zombies - Zombietod! </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen wir dem Zombie Animation Controller zun√§chst eine Todesanimation hinzu. </font><font style="vertical-align: inherit;">Ziehen Sie dazu die Animation AssetPacks‚á®ToonyTinyPeople‚á®TT_demo‚á®animation‚á®zombie‚á®Z_death_A hinein. </font><font style="vertical-align: inherit;">Um es zu aktivieren, legen Sie einen neuen Parameter an, der mit dem Triggertyp abgestorben ist. </font><font style="vertical-align: inherit;">Im Gegensatz zu anderen Parametern (bool, float usw.) erinnern sich Trigger nicht an ihren Status und √§hneln eher einem Funktionsaufruf: Sie haben einen Trigger aktiviert - der √úbergang funktionierte und der Trigger wurde zur√ºckgesetzt. </font><font style="vertical-align: inherit;">Und da ein Zombie in jedem Zustand sterben kann - und wenn er stillsteht und l√§uft, f√ºgen wir den √úbergang vom Zustand "Jeder Zustand" hinzu: </font></font><br><br><img src="https://habrastorage.org/webt/-a/je/6j/-aje6jc9oteg-glqdrtckbjhv1o.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie dem Zombie-Skript die folgenden Felder hinzu:</font></font><br><br><pre> <code class="cs hljs">CapsuleCollider capsuleCollider; Animator animator; MovementAnimator movementAnimator; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> dead;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√ºgen Sie in die Start-Methode der Zombie-Klasse Folgendes ein: </font></font><br><br><pre> <code class="cs hljs">capsuleCollider = GetComponent&lt;CapsuleCollider&gt;(); animator = GetComponentInChildren&lt;Animator&gt;(); movementAnimator = GetComponent&lt;MovementAnimator&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ganz am Anfang der Update-Methode m√ºssen Sie eine Pr√ºfung hinzuf√ºgen: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dead) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und schlie√ülich f√ºgen Sie der Zombie-Klasse die √∂ffentliche Methode Kill hinzu: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Kill</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dead) { dead = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; Destroy(capsuleCollider); Destroy(movementAnimator); Destroy(navMeshAgent); animator.SetTrigger(<span class="hljs-string"><span class="hljs-string">"died"</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Zuordnung neuer Felder ist meiner Meinung nach ganz offensichtlich. Bei der Kill-Methode setzen wir (wenn wir nicht tot sind) das Zombietod-Flag und entfernen die CapsuleCollider-, MovementAnimator- und NavMeshAgent-Komponenten von unserem Spielobjekt. Danach aktivieren wir die Wiedergabe der Todesanimation vom Animations-Controller.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum Komponenten entfernen? Sobald ein Zombie stirbt, h√∂rt er auf, sich auf der Karte zu bewegen, und ist kein Hindernis mehr f√ºr Kugeln. Im Endeffekt m√ºssen Sie den K√∂rper nach dem Abspielen der Todesanimation noch irgendwie auf sch√∂ne Weise loswerden. Andernfalls fressen tote Zombies weiterhin Ressourcen, und wenn zu viele Leichen vorhanden sind, verlangsamt sich das Spiel merklich. Am einfachsten f√ºgen Sie hier den Destroy-Aufruf (gameObject, 3) hinzu. Dies bewirkt, dass Unity dieses Spielobjekt 3 Sekunden nach diesem Aufruf l√∂scht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit dies alles endlich funktionierte, blieb die letzte Ber√ºhrung. In der Player-Klasse f√ºgen wir in der Update-Methode, in der wir Physics.Raycast aufrufen, in der Verzweigung f√ºr den Fall, dass eine Kreuzung gefunden wurde, eine √úberpr√ºfung hinzu:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hit.transform != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> zombie = hit.transform.GetComponent&lt;Zombie&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zombie != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) zombie.Kill(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Physics.Raycast ruft die Schnittpunktinformationen in der Treffervariable auf. Insbesondere im Transformationsfeld gibt es eine Verkn√ºpfung zur Transformationskomponente des Spielobjekts, mit der sich der Strahl geschnitten hat. Wenn dieses Spielobjekt eine Zombie-Komponente hat, dann ist es ein Zombie und wir t√∂ten es. Grundlegend! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit der Tod des Feindes spektakul√§r aussieht, f√ºgen wir den Zombies ein einfaches Partikelsystem hinzu.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit Partikelsystemen k√∂nnen Sie eine gro√üe Anzahl kleiner Objekte (normalerweise Sprites) nach einem physikalischen Gesetz oder einer mathematischen Formel steuern. </font><font style="vertical-align: inherit;">Zum Beispiel k√∂nnen Sie sie auseinander fliegen lassen oder mit einer bestimmten Geschwindigkeit direkt nach unten fliegen. </font><font style="vertical-align: inherit;">Mit Hilfe von Partikelsystemen in Spielen werden alle m√∂glichen Effekte erzielt: Feuer, Rauch, Funken, Regen, Schnee, Schmutz unter den R√§dern usw. </font><font style="vertical-align: inherit;">Wir werden ein Partikelsystem verwenden, damit zum Zeitpunkt des Todes Blut von einem Zombie spritzt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie dem Zombie-Spielobjekt ein Partikelsystem hinzu (klicken Sie mit der rechten Maustaste darauf und w√§hlen Sie Effekte - Partikelsystem): </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich schlage folgende Optionen vor: </font></font><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transformieren:</font></font></u> <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Position: Y 0,5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Drehung: X -90 </font></font></li></ul><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partikelsystem</font></font></u> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dauer: 0.2 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schleifen: falsch </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Startlebensdauer: 0.8 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Startgr√∂√üe: 0,5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Startfarbe: gr√ºn </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schwerkraftmodifikator: 1 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wach spielen: falsch </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Emission: </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rate √ºber Zeit: 100 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Form: </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Radius: 0,25 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es sollte ungef√§hr so ‚Äã‚Äãaussehen: Es muss </font></font><br><br><img src="https://habrastorage.org/webt/nk/rz/mj/nkrzmjt9wu6gyqt6twhgfkldivo.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">noch in der Kill-Methode der Zombie-Klasse aktiviert werden:</font></font><br><br><pre> <code class="cs hljs">GetComponentInChildren&lt;ParticleSystem&gt;().Play();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und jetzt eine ganz andere Sache! </font></font><br><br><img src="https://habrastorage.org/webt/av/sl/mf/avslmfkniyguq6m4hxma0j4sqek.gif"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zombies greifen in der Menge an </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Tat ist es langweilig, gegen einen einzelnen Zombie zu k√§mpfen. </font><font style="vertical-align: inherit;">Du hast ihn get√∂tet und das wars. </font><font style="vertical-align: inherit;">Wo ist das Drama? </font><font style="vertical-align: inherit;">Wo ist die Angst, jung zu sterben? </font><font style="vertical-align: inherit;">Um eine wahre Atmosph√§re der Apokalypse und Hoffnungslosigkeit zu schaffen, sollte es viele Zombies geben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Gl√ºck ist das ziemlich einfach. </font><font style="vertical-align: inherit;">Wie Sie vielleicht erraten haben, ben√∂tigen wir ein anderes Skript. </font><font style="vertical-align: inherit;">Nennen Sie es EnemySpawner und f√ºllen Sie es mit folgendem Inhalt:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemySpawner</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Period; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject Enemy; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> TimeUntilNextSpawn; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { TimeUntilNextSpawn = Random.Range(0, Period); } // Update is called once per frame void Update() { TimeUntilNextSpawn -= Time.deltaTime; if (TimeUntilNextSpawn &lt;= 0.0f) { TimeUntilNextSpawn = Period; Instantiate(Enemy, transform.position, transform.rotation); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úber das √∂ffentliche Feld ‚ÄûPeriode‚Äú kann der Spieledesigner im Inspektor festlegen, wie oft ein neuer Feind erstellt werden muss. Im Feld "Feind" geben wir an, welcher Feind erstellt werden soll (bisher haben wir nur einen Feind, aber in Zukunft k√∂nnen wir weitere hinzuf√ºgen). Nun, dann ist alles ganz einfach - mit TimeUntilNextSpawn z√§hlen wir, wie viel Zeit bis zum n√§chsten Auftauchen des Feindes verbleibt, und f√ºgen der Szene nach der Standardmethode Instantiate einen neuen Zombie hinzu. Oh ja, bei der Start-Methode weisen wir dem TimeUntilNextSpawn-Feld einen zuf√§lligen Wert zu, sodass, wenn sich mehrere Spawner mit den gleichen Verz√∂gerungen in der Ebene befinden, sie nicht gleichzeitig Zombies hinzuf√ºgen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Frage bleibt - wie man den Feind im feindlichen Feld fragt? Dazu verwenden wir ein Unity-Tool wie "Prefabs". Tats√§chlich ist ein Fertighaus ein Teil der Szene, der in einer separaten Datei gespeichert ist. Dann k√∂nnen wir diese Datei in andere Szenen (oder in dieselbe) einf√ºgen und m√ºssen sie nicht jedes Mal wieder von St√ºcken sammeln. Zum Beispiel haben wir aus den Gegenst√§nden von W√§nden, Boden, Decke, Fenstern und T√ºren ein sch√∂nes Haus gesammelt und es als Fertighaus gespeichert. Jetzt k√∂nnen Sie dieses Haus mit einem Handgriff in andere Karten stecken. Wenn Sie die vorgefertigte Datei bearbeiten (z. B. eine Hintert√ºr zum Haus hinzuf√ºgen), √§ndert sich das Objekt gleichzeitig in allen Szenen. Manchmal ist es sehr bequem. Wir k√∂nnen auch Prefabs als Vorlagen f√ºr Instantiate verwenden - und wir werden diese Gelegenheit jetzt nutzen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um ein Fertighaus zu erstellen, ziehen Sie das Spielobjekt einfach aus dem Hierarchiefenster in das Projektfenster. Den Rest erledigt Unity. Erstellen wir ein Fertighaus aus Zombies und f√ºgen der Szene dann einen feindlichen Spawner </font></font><br><br><img src="https://habrastorage.org/webt/4i/ka/kx/4ikakx3ollmpndbgcqco8341e8y.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hinzu </font><font style="vertical-align: inherit;">: </font><font style="vertical-align: inherit;">Ich habe dem Projekt zur Abwechslung drei weitere </font><font style="vertical-align: inherit;">Spawner </font><font style="vertical-align: inherit;">hinzugef√ºgt (also habe ich am Ende vier davon). Und so, was ist passiert: </font></font><br><br><img src="https://habrastorage.org/webt/6h/0p/_f/6h0p_fo52j6zqydyml6z9aqlcu0.gif"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier! Es sieht schon aus wie eine Zombie-Apokalypse!</font></font></b> <br><br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist nat√ºrlich alles andere als ein vollst√§ndiges Spiel. </font><font style="vertical-align: inherit;">Wir haben nicht viele Probleme ber√ºcksichtigt, wie das Erstellen einer Benutzeroberfl√§che, Ger√§usche, Leben und Tod eines Spielers - all dies wird in diesem Artikel nicht behandelt. </font><font style="vertical-align: inherit;">Mir scheint jedoch, dass dieser Artikel eine w√ºrdige Einf√ºhrung in Unity f√ºr diejenigen sein wird, die mit diesem Tool nicht vertraut sind. </font><font style="vertical-align: inherit;">Oder kann jemand mit Erfahrung einen Trick daraus ziehen? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Allgemeinen, Freunde, hoffe ich, dass Ihnen mein Artikel gefallen hat. </font><font style="vertical-align: inherit;">Schreiben Sie Ihre Fragen in die Kommentare, ich werde versuchen zu beantworten. </font><font style="vertical-align: inherit;">Der Quellcode des Projekts kann auf den Github heruntergeladen werden: </font></font><a href="https://github.com/zapolnov/otus_zombies"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/zapolnov/otus_zombies</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sie ben√∂tigen Unity 2019.3.0f3 oder h√∂her, es kann komplett kostenlos und ohne SMS von der offiziellen Website heruntergeladen werden: </font></font><a href="https://store.unity.com/download"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://store.unity.com/download</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Links zu Assets, die im Artikel verwendet werden: </font></font><br><br><ul><li> <a href="https://assetstore.unity.com/packages/3d/environments/industrial/rpg-fps-game-assets-for-pc-mobile-industrial-set-v2-0-86679">https://assetstore.unity.com/packages/3d/environments/industrial/rpg-fps-game-assets-for-pc-mobile-industrial-set-v2-0-86679</a> </li><li> <a href="https://assetstore.unity.com/packages/3d/characters/toony-tiny-people-demo-113188">https://assetstore.unity.com/packages/3d/characters/toony-tiny-people-demo-113188</a> </li><li> <a href="https://assetstore.unity.com/packages/2d/gui/icons/crosshairs-plus-139902">https://assetstore.unity.com/packages/2d/gui/icons/crosshairs-plus-139902</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485210/">https://habr.com/ru/post/de485210/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485200/index.html">Mess am Start: Post-Mortem zur Startgeschwindigkeit einer iOS-Anwendung</a></li>
<li><a href="../de485202/index.html">Unterdr√ºckungssystem</a></li>
<li><a href="../de485204/index.html">Zur√ºck zum Anfang: Warum Amazon bald wieder mehr als 1 Billion US-Dollar kapitalisiert</a></li>
<li><a href="../de485206/index.html">Wie hat mich Typescript entt√§uscht und ist es das wert?</a></li>
<li><a href="../de485208/index.html">Aufbau einer fehlertoleranten IT-Infrastruktur. Teil 2. Installieren und Konfigurieren des oVirt 4.3-Clusters</a></li>
<li><a href="../de485214/index.html">CLRium Nr. 7: Praktisch. Seminar, Hausaufgaben mit Verifikation, Mentoring</a></li>
<li><a href="../de485218/index.html">Reserviere Konstanten und Git Hooks in C #</a></li>
<li><a href="../de485220/index.html">Die Entwicklung der Web Application Firewall: von Firewalls zu maschinell erlernbaren cloudbasierten Sicherheitssystemen</a></li>
<li><a href="../de485222/index.html">Wie kann man mit Meinungsbildnern in China zusammenarbeiten? F√ºnf praktische Tipps</a></li>
<li><a href="../de485224/index.html">Wie f√§llt die Warenlieferung ab dem 1. Januar 2020 unter die Zollgrenze?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>