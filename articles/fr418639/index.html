<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤲 🏠 🎶 Akka Streams pour les simples mortels 👌🏿 ☎️ 👩🏽‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Comment puis-je imprimer un flux continu de messages de Twitter avec quelques lignes de code en ajoutant des données météorologiques aux endroits où v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Akka Streams pour les simples mortels</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/418639/">  Comment puis-je imprimer un flux continu de messages de Twitter avec quelques lignes de code en ajoutant des données météorologiques aux endroits où vivent leurs auteurs?  Et comment pouvez-vous limiter la vitesse des demandes au fournisseur météo pour qu'il ne nous liste pas? <br><br>  Aujourd'hui, nous vous expliquerons comment procéder, mais nous découvrirons tout d'abord la technologie Akka Streams, qui rend le travail avec les flux de données en temps réel aussi simple que les programmeurs travaillant avec des expressions LINQ sans nécessiter la mise en œuvre d'acteurs individuels ou d'interfaces Reactive Streams . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ibpnza_PCr0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  L'article est basé sur une transcription du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapport de Vagif Abilov</a> de notre conférence de décembre DotNext 2017 Moscou. <br><a name="habracut"></a><br>  Je m'appelle Vagif, je travaille pour la société norvégienne Miles.  Aujourd'hui, nous allons parler de la bibliothèque Akka Streams. <br><br>  Akka et Reactive Streams sont l'intersection d'ensembles assez étroits, et on pourrait avoir l'impression que c'est une niche telle que vous devez avoir une grande connaissance pour entrer, mais juste le contraire.  Et cet article est destiné à montrer qu'en utilisant Akka Streams, vous pouvez éviter la programmation de bas niveau qui est requise lors de l'utilisation de Reactive Streams et Akka.NET.  Pour l'avenir, je peux dire immédiatement: si au tout début de notre projet, sur lequel nous utilisons Akka, nous connaissions l'existence d'Akka Streams, nous écririons beaucoup différemment, nous économiserions à la fois du temps et du code. <br><blockquote> <i>"Peut-être que le pire que vous puissiez faire est d'amener les personnes qui ne souffrent pas à prendre votre aspirine."</i> <br>  Max Kreminski <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Portes fermées, maux de tête et besoins intellectuels»</a> </blockquote>  Avant d'entrer dans les détails techniques, un peu sur ce que votre chemin vers Akka Streams peut s'avérer être et ce qui peut vous y conduire.  Un jour, je suis tombé sur le blog de Max Kreminski, où il a posé une telle question philosophique aux programmeurs: comment ou pourquoi il est impossible pour un programmeur d'expliquer ce que sont les monades.  Il l'a expliqué de cette façon: très souvent, les gens vont immédiatement aux détails techniques, expliquant à quel point la programmation est magnifiquement fonctionnelle et à quel point il y a du sens dans la monade, sans prendre la peine de se demander pourquoi le programmeur pourrait en avoir besoin.  Dessiner une analogie, c'est comme essayer de vendre de l'aspirine sans se soucier de savoir si votre patient souffre. <br><br>  En utilisant cette analogie, je voudrais poser la question suivante: si Akka Streams est de l'aspirine, quelle devrait être la douleur qui vous y conduira? <br><br><h1>  Flux de données </h1><br>  Parlons d'abord des flux de données.  Le flux peut être assez simple, linéaire. <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Votre navigateur ne prend pas en charge la vidéo HTML5. <source src="https://media.giphy.com/media/ZNejul2eTftImnVrsY/giphy.mp4" type="video/mp4"></video></div></div></div><br>  Ici, nous avons un certain consommateur de données (un lapin dans la vidéo).  Il consomme des données à une vitesse qui lui convient.  Il s'agit de l'interaction idéale du consommateur avec le flux: elle établit la bande passante et les données y circulent tranquillement.  Ce flux de données simple peut être infini ou se terminer. <br><br>  Mais le flux peut être plus complexe.  Si vous plantez plusieurs lapins côte à côte, nous aurons déjà une parallélisation des flux.  Ce que Reactive Streams essaie de résoudre, c'est précisément comment nous pouvons communiquer avec les flux à un niveau plus conceptuel, c'est-à-dire, que nous parlions simplement d'une sorte de mesure de capteur de température, où les mesures linéaires entrent en jeu. , ou nous avons des mesures en continu de milliers de capteurs de température entrant dans le système via des files d'attente RabbitMQ et stockés dans les journaux système.  Tout ce qui précède peut être considéré comme un seul flux composite.  Si vous allez encore plus loin, la gestion automatisée de la production (par exemple, par une boutique en ligne) peut également être réduite à un flux de données, et ce serait formidable si nous pouvions parler de la planification d'un tel flux, quelle que soit sa complexité. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a7c/fa0/3af/a7cfa03af65ad4d88c1ce13d316e272e.jpg"><br><br>  Pour les projets modernes, le support des threads n'est pas très bon.  Si je me souviens bien, Aaron Stannard, dont vous voyez le tweet dans l'image, voulait obtenir un flux d'un fichier de plusieurs gigaoctets contenant CSV, c'est-à-dire  texte, et il s'est avéré qu'il n'y a rien que vous pouvez simplement prendre et utiliser immédiatement, sans un tas d'actions supplémentaires.  Mais il n'a tout simplement pas pu obtenir un flux de valeurs CSV, ce qui l'a attristé.  Il y a peu de solutions (à l'exception de certaines zones spéciales), beaucoup est réalisé par les anciennes méthodes, lorsque nous ouvrons tout cela, commençons la lecture, la mise en mémoire tampon, dans le pire des cas, nous obtenons quelque chose comme le bloc-notes, qui dit que le fichier est trop gros. <br><br>  À un niveau conceptuel élevé, nous sommes tous engagés dans le traitement des flux de données, et Akka Streams vous aidera si: <br><br><ul><li>  Vous connaissez Akka, mais vous voulez vous épargner les détails associés à l'écriture du code d'acteur et à sa coordination; <br></li><li>  Vous connaissez les flux réactifs et souhaitez utiliser une implémentation prête à l'emploi de leurs spécifications; <br></li><li>  Les éléments de bloc Akka Streams pour les étapes conviennent à la modélisation de votre processus; <br></li><li>  Vous souhaitez profiter de la contre-pression (contre-pression) d'Akka Streams pour gérer et affiner dynamiquement les étapes de débit de votre flux de travail. <br></li></ul><br><h1>  Des acteurs aux Akka Streams </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/9e2/067/5d1/9e20675d1a251ffc62b578eba2e7167d.jpg"><br><br>  La première façon est celle des acteurs aux Akka Streams, à ma façon. <br><br>  La photo montre pourquoi nous avons commencé à utiliser le modèle d'acteur.  Nous étions épuisés par le contrôle manuel des flux, l'état partagé, c'est tout.  Tous ceux qui ont travaillé avec de grands systèmes, avec plusieurs threads, comprennent combien cela prend du temps et combien il est facile de s'y tromper, ce qui peut être fatal pour l'ensemble du processus.  Cela nous a conduit au modèle des acteurs.  Nous ne regrettons pas le choix fait, mais, bien sûr, lorsque vous commencez à travailler et à programmer davantage, ce n'est pas que l'enthousiasme initial cède la place à autre chose, mais vous commencez à réaliser que quelque chose pourrait être fait encore plus efficacement. <br><blockquote>  <i>«Par défaut, les destinataires de leurs messages sont entrés dans le code des acteurs.</i>  <i>Si je crée un acteur A qui envoie un message à l'acteur B et que vous souhaitez remplacer le destinataire par l'acteur C, dans le cas général, cela ne fonctionnera pas pour vous. »</i> <br>  Noel Welch (underscore.io) </blockquote>  Les acteurs critiqués pour ne pas avoir composé.  L'un des premiers à écrire à ce sujet sur son blog a été Noel Welch, l'un des développeurs d'Underscore.  Il a remarqué que le système d'acteurs ressemble à ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d8f/e3b/3dd/d8fe3b3dd378bb187c4a85de3e982960.jpg"><br><br>  Si vous n'utilisez aucun élément supplémentaire, comme une injection de dépendance, l'adresse de son destinataire est cousue dans l'acteur. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3df/62f/78b/3df62f78bf5f64bda875c5f448057427.jpg"><br><br>  Quand ils commencent à s'envoyer des messages, vous définissez tout cela à l'avance, en programmant les acteurs.  Et sans astuces supplémentaires, un tel système rigide est obtenu. <br>  Un des développeurs d'Akka, Roland Kuhn, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">expliqué</a> ce que l'on entend généralement par mauvaise disposition.  La méthode acteur est basée sur la méthode tell, c'est-à-dire les messages unidirectionnels: elle est de type void, c'est-à-dire qu'elle ne renvoie rien (ou unité, selon la langue).  Il est donc impossible de construire une description du processus à partir d'une chaîne d'acteurs.  Alors tu as envoyé dire, alors quoi?  Arrêter  Nous sommes devenus nuls.  Vous pouvez le comparer, par exemple, avec des expressions LINQ, où chaque élément de l'expression renvoie IQueryable, IEnumerable, et tout cela peut être facilement compilé.  Les acteurs ne donnent pas une telle opportunité.  Dans le même temps, Roland Kuhn s'est opposé au fait qu'ils, disent-ils, ne composent pas en principe, affirmant qu'en fait ils sont compilés d'autres manières, dans le même sens où la société humaine se prête à l'agencement.  Cela ressemble à un argument philosophique, mais si vous y réfléchissez, l'analogie est logique - oui, les acteurs s'envoient des messages unidirectionnels, mais nous communiquons également les uns avec les autres, en prononçant des messages unidirectionnels, mais en même temps, nous interagissons assez efficacement, c'est-à-dire que nous créons des systèmes complexes.  Néanmoins, une telle critique des acteurs existe. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SampleActor</span></span> : <span class="hljs-title"><span class="hljs-title">ReceiveActor</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleActor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Idle(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PreStart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Idle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Receive&lt;Job&gt;(job =&gt; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Working</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Receive&lt;Cancel&gt;(job =&gt; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>); } }</code> </pre> <br>  De plus, l'implémentation de l'acteur nécessite au moins d'écrire une classe si vous travaillez en C #, ou des fonctions si vous travaillez en F #.  Dans l'exemple ci-dessus - code passe-partout, que vous devez de toute façon écrire.  Bien qu'il ne soit pas très volumineux, c'est un certain nombre de lignes que vous devrez toujours écrire à ce bas niveau.  Presque tout le code qui est présent ici est une sorte de cérémonie.  Ce qui se passe lorsqu'un acteur reçoit directement un message ne s'affiche pas du tout ici.  Et tout cela doit être écrit.  Bien sûr, ce n'est pas beaucoup, mais c'est la preuve que nous travaillons avec des acteurs de bas niveau, créant de telles méthodes de vide. <br><br>  Et si nous pouvions passer à un niveau différent et supérieur, nous poser des questions sur la modélisation de notre processus, qui comprend le traitement de données provenant de diverses sources qui sont mélangées, converties et transférées? <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> results = db.Companies .Join(db.People, c =&gt; c.CompanyID, p =&gt; p.PersonID, (c, p) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { c, p }) .Where(z =&gt; zcCreated &gt;= fromDate) .OrderByDescending(z =&gt; zcCreated) .Select(z =&gt; zp) .ToList();</code> </pre> <br>  Un analogue de cette approche peut être ce que nous avons tous l'habitude de travailler avec LINQ depuis dix ans.  Nous ne nous demandons pas comment fonctionne Join.  Nous savons qu'il existe un tel fournisseur LINQ qui fera tout cela pour nous, et nous sommes intéressés à un niveau supérieur pour répondre à la demande.  Et nous pouvons généralement mélanger les bases de données ici, nous pouvons envoyer des demandes distributives.  Et si vous pouviez décrire le processus de cette façon? <br><br><pre> <code class="cs hljs">HttpGet pageUrl |&gt; fun s -&gt; Regex.Replace(s, <span class="hljs-string"><span class="hljs-string">"[^A-Za-z']"</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span>) |&gt; fun s -&gt; Regex.Split(s, <span class="hljs-string"><span class="hljs-string">" +"</span></span>) |&gt; Set.ofArray |&gt; Set.filter (fun word -&gt; not (Spellcheck word)) |&gt; Set.iter (fun word -&gt; printfn <span class="hljs-string"><span class="hljs-string">" %s"</span></span> word)</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">(Source)</a> <br><br>  Ou, par exemple, des transformations fonctionnelles.  Ce que beaucoup de gens aiment à propos de la programmation fonctionnelle, c'est que vous pouvez transmettre des données à travers une série de transformations, et vous obtenez un code compact assez clair, quelle que soit la langue dans laquelle vous l'écrivez.  C'est assez facile à lire.  Le code de l'image est spécialement écrit en F #, mais en général, probablement, tout le monde comprend ce qui se passe ici. <br><br><pre> <code class="cs hljs">val <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> = Source(<span class="hljs-number"><span class="hljs-number">1</span></span> to <span class="hljs-number"><span class="hljs-number">10</span></span>) val <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> = Sink.ignore val bcast = builder.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(Broadcast[Int](<span class="hljs-number"><span class="hljs-number">2</span></span>)) val merge = builder.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(Merge[Int](<span class="hljs-number"><span class="hljs-number">2</span></span>)) val f1,f2,f3,f4 = Flow[Int].map(_ + <span class="hljs-number"><span class="hljs-number">10</span></span>) source ~&gt; f1 ~&gt; bcast ~&gt; f2 ~&gt; merge ~&gt; f3 ~&gt; sink bcast ~&gt; f4 ~&gt; merge ~&gt;</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">(Source)</a> <br><br>  Et alors?  Dans l'exemple ci-dessus, nous avons une source de données source, qui se compose d'entiers de 1 à 10. C'est ce qu'on appelle le DSL graphique (langage spécifique au domaine).  Les éléments de la langue du domaine dans l'exemple ci-dessus sont des flèches unidirectionnelles - ce sont des opérateurs supplémentaires définis par des outils de langue qui montrent graphiquement la direction du flux.  Nous passons Source à travers une série de transformations - pour faciliter la démonstration, elles ajoutent toutes un dix au nombre.  Vient ensuite la diffusion: nous multiplions les canaux, c'est-à-dire que chaque numéro entre dans deux canaux.  Ensuite, nous ajoutons à nouveau 10, mélangons nos flux de données, obtenons un nouveau flux, en ajoutons également 10, et tout cela va à notre flux de données, dans lequel rien ne se passe.  Il s'agit du vrai code écrit en Scala, qui fait partie d'Akka Streams, implémenté dans ce langage.  C'est-à-dire que vous spécifiez les phases de la transformation de vos données, indiquez quoi en faire, spécifiez la source, le stock, certains points de contrôle, puis formez un tel graphique à l'aide du DSL graphique.  C'est tout le code pour un seul programme.  Quelques lignes de code montrent ce qui se passe dans le processus. <br><br>  Oublions comment écrire le code de définition pour les acteurs individuels et apprenons plutôt les primitives de mise en page de haut niveau qui créeront et connecteront les acteurs requis en eux-mêmes.  Lorsque nous exécutons un tel graphique, le système qui fournit Akka Streams créera lui-même l'acteur requis, y enverra toutes ces données, les traitera comme il se doit et les transmettra finalement au destinataire final. <br><br><pre> <code class="hljs pgsql">var runnable = Source .<span class="hljs-keyword"><span class="hljs-keyword">From</span></span>(Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>)) .Via(Flow.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;().<span class="hljs-keyword"><span class="hljs-keyword">Select</span></span>(x =&gt; x * <span class="hljs-number"><span class="hljs-number">2</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">To</span></span>(Sink.<span class="hljs-keyword"><span class="hljs-keyword">ForEach</span></span>&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;(x =&gt; Console.<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(x.ToString));</code> </pre> <br>  L'exemple ci-dessus montre à quoi cela pourrait ressembler en C #.  La manière la plus simple: nous avons une source de données - ce sont des nombres de 1 à 1000 (comme vous pouvez le voir, dans Akka Streams, tout IEnumerable peut devenir une source de flux de données, ce qui est très pratique).  Nous faisons un calcul simple, disons, nous multiplions par deux, puis sur le flux de données tout cela est affiché à l'écran. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> graph = GraphDsl.Create(builder =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bcast = builder.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Broadcast&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> merge = builder.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Merge&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> count = Flow.FromFunction(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(x =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum = Flow.Create&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;().Sum((x, y) =&gt; x + y); builder.From(bcast.Out(<span class="hljs-number"><span class="hljs-number">0</span></span>)).To(merge.In(<span class="hljs-number"><span class="hljs-number">0</span></span>)); builder.From(bcast.Out(<span class="hljs-number"><span class="hljs-number">1</span></span>)).Via(count).Via(sum).To(merge.In(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FlowShape&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(bcast.In, merge.Out); });</code> </pre> <br>  Ce qui est illustré dans l'exemple ci-dessus est appelé «DSL graphique en C #».  En fait, il n'y a pas de graphiques ici, c'est un port avec Scala, mais en C # il n'y a aucun moyen de définir les opérateurs de cette façon, donc cela semble un peu plus encombrant, mais toujours assez compact pour comprendre ce qui se passe ici.  Donc, nous créons un certain graphique (il existe différents types de graphiques, ici on l'appelle FlowShape) à partir de différents composants, où il y a une source de données et il y a des transformations.  Nous envoyons des données à un canal dans lequel nous générons le comptage, c'est-à-dire le nombre d'éléments de données à transmettre, et dans l'autre, nous générons la somme, puis nous mélangons le tout.  Ensuite, nous verrons des exemples plus intéressants que le simple traitement de nombres entiers. <br>  C'est le premier chemin qui peut vous conduire à Akka Streams, si vous avez de l'expérience avec un modèle d'acteur et que vous avez pensé à écrire manuellement chacun, même l'acteur le plus simple.  La deuxième façon dont Akka Streams arrive à travers Reactive Streams. <br><br><h1>  Des flux réactifs aux flux Akka </h1><br>  Qu'est-ce que les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">flux réactifs</a> ?  Il s'agit d'une initiative conjointe visant à développer une norme pour le traitement asynchrone des flux de données.  Il définit l'ensemble minimal d'interfaces, de méthodes et de protocoles qui décrivent les opérations et entités nécessaires pour atteindre l'objectif - traitement asynchrone des données en temps réel avec une contre-pression non bloquante (contre-pression).  Il permet diverses implémentations utilisant différents langages de programmation. <br><br>  Reactive Streams vous permet de traiter un nombre potentiellement illimité d'éléments dans une séquence et de transférer des éléments de manière asynchrone entre les composants avec une contre-pression non bloquante. <br><br>  La liste des initiateurs de la création de Reactive Streams est assez impressionnante: voici Netflix, Oracle et Twitter. <br><br>  La spécification est très simple pour rendre l'implémentation dans différentes langues et plates-formes aussi accessible que possible.  Les principaux composants de l'API Reactive Streams: <br><br><ol><li>  Éditeur <br></li><li>  Abonné <br></li><li>  Abonnement <br></li><li>  Processeur <br></li></ol><br>  Essentiellement, cette spécification n'implique pas que vous commencerez manuellement à implémenter ces interfaces.  Il est entendu que certains développeurs de bibliothèques le feront pour vous.  Et Akka Streams est l'une des implémentations de cette spécification. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IPublisher</span></span>&lt;<span class="hljs-title"><span class="hljs-title">out</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Subscribe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ISubscriber&lt;T&gt; subscriber</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ISubscriber</span></span>&lt;<span class="hljs-title"><span class="hljs-title">in</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnSubscribe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ISubscription subscription</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnNext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T element</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Exception cause</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnComplete</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; }</code> </pre> <br>  Les interfaces, comme vous pouvez le voir dans l'exemple, sont vraiment très simples: par exemple, Publisher ne contient qu'une seule méthode - «s'abonner».  L'abonné, l'abonné, ne contient que quelques réactions à l'événement. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ISubscription</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Request</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Cancel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IProcessor</span></span>&lt;<span class="hljs-title"><span class="hljs-title">in</span></span> <span class="hljs-title"><span class="hljs-title">T1</span></span>, <span class="hljs-title"><span class="hljs-title">out</span></span> <span class="hljs-title"><span class="hljs-title">T2</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">ISubscriber</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T1</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">IPublisher</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T2</span></span>&gt; { }</code> </pre> <br>  Enfin, l'abonnement contient deux méthodes - «démarrer» et «refuser».  Le processeur ne définit aucune nouvelle méthode, il associe un éditeur et un abonné. <br><br>  Qu'est-ce qui distingue les flux réactifs des autres implémentations de flux?  Reactive Streams combine des modèles push et pull.  Pour le support, il s'agit du scénario de performances le plus efficace.  Supposons que vous ayez un abonné lent aux données.  Dans ce cas, pousser pour lui peut être fatal: si vous lui envoyez une énorme quantité de données, il ne pourra pas les traiter.  Il est préférable d'utiliser pull pour que l'abonné récupère lui-même les données de l'éditeur.  Mais si l'éditeur est lent, il s'avère que l'abonné est bloqué tout le temps, attendant tout le temps.  Une solution intermédiaire peut être la configuration: nous avons un fichier de configuration dans lequel nous déterminons lequel est le plus rapide.  Et si leurs vitesses changent? <br><br>  Ainsi, l'implémentation la plus élégante est celle dans laquelle nous pouvons changer dynamiquement les modèles push et pull. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/971/ab6/298/971ab6298b3f313b90503cf6a860e188.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">(Source (Apache Flink))</a> <br><br>  Le diagramme montre comment cela peut se produire.  Cette démo utilise Apache Flink.  Yellow est un éditeur, producteur de données, il était fixé à environ 50% de ses capacités.  L'abonné essaie de choisir la meilleure stratégie - elle se révèle être push.  Ensuite, nous avons réinitialisé l'abonné à une vitesse d'environ 20%, et il passe pour tirer.  Ensuite, nous allons à 100%, revenons à nouveau à 20%, au modèle de traction, etc. Tout cela se produit dans la dynamique, vous n'avez pas besoin d'arrêter le service, entrez quelque chose dans la configuration.  Ceci est une illustration du fonctionnement de la contre-pression dans Akka Streams. <br><br><h1>  Principes d'Akka Streams </h1><br>  Bien sûr, Akka Streams ne gagnerait pas en popularité s'il n'y avait pas de blocs intégrés très faciles à utiliser.  Il y en a beaucoup.  Ils sont divisés en trois groupes principaux: <br><br><ol><li>  Source de données (Source) - étape de traitement avec une sortie. <br></li><li>  Le récepteur est une étape de traitement à entrée unique. <br></li><li>  Checkpoint (Flow) - étape de traitement avec une entrée et une sortie.  Des transformations fonctionnelles ont lieu ici, et pas nécessairement dans la mémoire: il peut s'agir, par exemple, d'un appel à un service web, à certains éléments de parallélisme, multi-thread. <br></li></ol><br>  De ces trois types, des graphiques peuvent être formés.  Ce sont déjà des étapes de traitement plus complexes, qui sont construites à partir de sources, de drains et de points de contrôle.  Mais tous les graphiques ne peuvent pas être exécutés: s'il y a des trous dedans, c'est-à-dire des entrées et des sorties ouvertes, alors ce graphique n'est pas exécuté. <br>  Un graphe est un graphe exécutable, s'il est fermé, c'est-à-dire qu'il y a une sortie pour chaque entrée: si les données sont entrées, elles doivent être allées quelque part. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/41f/059/a3c/41f059a3cebba7f1e023c8036a29cc8e.jpg"><br><br>  Akka Streams a des sources intégrées: dans l'image, vous voyez combien d'entre elles.  Leurs noms sont à peu près un à un et reflètent ce que Scala ou la JVM a, à l'exception de certaines sources utiles spécifiques à .NET.  Les deux premiers (FromEnumerator et From) sont parmi les plus importants: toute numérotation, tout ienumerable peut être transformé en source de flux. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/504/3cb/0e7/5043cb0e7cd9fb15e6b00582b5230103.jpg"><br><br>  Il existe des drains intégrés: certains d'entre eux ressemblent aux méthodes LINQ, par exemple, First, Last, FirstOrDefault.  Bien sûr, tout ce que vous obtenez, vous pouvez le vider dans des fichiers, dans des flux, non pas dans des flux Akka, mais dans des flux .NET.  Et encore une fois, si vous avez des acteurs dans votre système, vous pouvez les utiliser à la fois en entrée et en sortie du système, c'est-à-dire, si vous le souhaitez, les intégrer dans votre système fini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0a6/947/229/0a6947229a7ddbb5577b39634a4b6c11.jpg"><br><br>  Et il existe un grand nombre de points de contrôle intégrés, qui rappellent peut-être encore plus LINQ, car ici il y a Select, SelectMany et GroupBy, c'est-à-dire tout ce que nous avons l'habitude de travailler avec LINQ. <br><br>  Par exemple, Select in Scala est appelé SelectAsync: il est suffisamment puissant car il prend le niveau de parallélisme comme l'un des arguments.  Autrement dit, vous pouvez indiquer que, par exemple, Select envoie des données à un service Web en parallèle sur dix threads, puis elles sont toutes collectées et transmises.  En fait, vous déterminez le degré de mise à l'échelle du point de contrôle avec une ligne de code. <br><br>  Une déclaration de flux est son plan d'exécution, c'est-à-dire qu'un graphique, même un graphique d'exécution, ne peut pas être exécuté comme ça - il doit être matérialisé.  Il doit y avoir un système instancié, un système d'acteur, vous devez lui donner un flux, ce plan d'exécution, puis il sera exécuté.  De plus, au moment de l'exécution, il est hautement optimisé, tout comme lorsque vous envoyez une expression LINQ à une base de données: un fournisseur peut optimiser votre SQL pour une sortie de données plus efficace, en remplaçant essentiellement la commande de requête par une autre.  Même chose avec Akka Streams: à partir de la version 2.0, vous pouvez définir un certain nombre de points de contrôle, et le système comprendra que certains d'entre eux peuvent être combinés afin qu'ils soient exécutés par un seul acteur (fusion d'opérateur).  Les points de contrôle, en règle générale, conservent l'ordre des éléments de traitement. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> results = db.Companies .Join(db.People, c =&gt; c.CompanyID, p =&gt; p.PersonID, (c, p) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { c, p }) .Where(z =&gt; zcCreated &gt;= fromDate) .OrderByDescending(z =&gt; zcCreated) .Select(z =&gt; zp) .ToList();</code> </pre> <br>  La matérialisation du flux peut être comparée au dernier élément ToList de l'expression LINQ dans l'exemple ci-dessus.  Si nous n'écrivons pas ToList, nous obtenons alors une expression LINQ non matérialisée qui n'entraînera pas le transfert des données vers le serveur SQL ou Oracle, car la plupart des fournisseurs LINQ prennent en charge l'exécution dite de requête différée (exécution de requête retardée), t c'est-à-dire que la demande n'est exécutée que lorsqu'une commande est donnée pour donner un résultat.  Selon ce qui est demandé - une liste ou le premier résultat - l'équipe la plus efficace sera formée.  Lorsque nous disons ToList, nous demandons ainsi au fournisseur LINQ de nous donner le résultat final. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> runnable = Source .From(Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>)) .Via(Flow.Create&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;().Select(x =&gt; x * <span class="hljs-number"><span class="hljs-number">2</span></span>) .To(Sink.ForEach&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(x =&gt; Console.Write(x.ToString));</code> </pre> <br>  Akka Streams fonctionne de la même manière.  Dans l'image est notre graphique lancé, qui se compose d'une source de points de contrôle et de ruissellement, et nous voulons maintenant l'exécuter. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> runnable = Source .From(Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>)) .Via(Flow.Create&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;().Select(x =&gt; x * <span class="hljs-number"><span class="hljs-number">2</span></span>) .To(Sink.ForEach&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(x =&gt; Console.Write(x.ToString)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> system = ActorSystem.Create(<span class="hljs-string"><span class="hljs-string">"MyActorSystem"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> materializer = ActorMaterializer.Create(system)) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> runnable.Run(materializer); }</code> </pre> <br>  Pour que cela se produise, nous devons créer un système d'acteurs, en lui il y a un matérialisant, lui passer notre graphique, et il l'exécutera.  Si nous le recréons, il l'exécutera à nouveau et d'autres résultats pourront être obtenus. <br><br>  En plus de la matérialisation du flux, en parlant de la partie matérielle d'Akka Streams, il convient de mentionner les valeurs matérialisées. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> output = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> source1 = Source.From(Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sink1 = Sink.ForEach&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(output.Add); IRunnableGraph&lt;NotUsed&gt; runnable1 = source1.To(sink1); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> source2 = Source.From(Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sink2 = Sink.Sum&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;((x,y) =&gt; x + y); IRunnableGraph&lt;Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; runnable2 = source2.ToMaterialized(sink2, Keep.Right);</code> </pre> <br>  Lorsque nous avons un flux qui va de la source aux points de contrôle vers le drain, alors si nous ne demandons pas de valeurs intermédiaires, elles ne sont pas disponibles, car elles seront exécutées de la manière la plus efficace.  C'est comme une boîte noire.  Mais il peut être intéressant pour nous de retirer certaines valeurs intermédiaires, car à chaque point à gauche, certaines valeurs entrent, d'autres valeurs sortent à droite, et vous pouvez spécifier un graphique pour indiquer ce qui vous intéresse.  Dans l'exemple ci-dessus, un graphique de départ dans lequel NotUsed est indiqué, c'est-à-dire qu'aucune valeur matérialisée ne nous intéresse.  Ci-dessous, nous le créons avec l'indication que sur le côté droit du ruissellement, c'est-à-dire, une fois toutes les transformations terminées, nous devons donner des valeurs matérialisées.  Nous obtenons la tâche graphique - une tâche, à la fin de laquelle nous obtenons un int, c'est-à-dire ce qui se passe à la fin de ce graphique.  Vous pouvez indiquer dans chaque paragraphe que vous avez besoin d'une sorte de valeurs matérialisées, tout cela sera progressivement collecté. <br><br>  Pour transférer des données dans les flux Akka Streams ou pour les retirer de là, bien sûr, une sorte d'interaction avec le monde extérieur est nécessaire.  Les étages source intégrés contiennent une large gamme de flux de données réactifs: <br><br><ul><li>  Source.FromEnumerator et Source.From vous permettent de transférer des données à partir de n'importe quelle source qui implémente IEnumerable; <br></li><li>  Déplier et DéplierAsync génèrent les résultats des calculs de fonction à condition qu'il renvoie des valeurs non nulles; <br></li><li>  FromInputStream transforme un flux; <br></li><li>  FromFile analyse le contenu du fichier dans le flux réactif; <br></li><li>  ActorPublisher convertit les messages des acteurs. <br></li></ul><br>  Comme je l'ai déjà dit, pour les développeurs .NET, il est très productif d'utiliser Enumerator ou IEnumerable, mais parfois c'est trop primitif, trop inefficace pour accéder aux données.  Des sources plus complexes contenant une grande quantité de données nécessitent des connecteurs spéciaux.  Ces connecteurs sont écrits.  Il existe un projet open source Alpakka, qui est apparu à l'origine dans Scala et est maintenant dans .NET.  De plus, Akka a des acteurs dits persistants et ils ont leurs propres flux qui peuvent être utilisés (par exemple, Akka Persistence Query forme le flux de contenu du Akka Event Journal). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/109/c40/b29/109c40b2934e0a4a4e280b27d2cd1e8b.jpg"><br><br>  Si vous travaillez avec Scala, le moyen le plus simple est pour vous: il existe un grand nombre de connecteurs et vous trouverez sûrement quelque chose à votre goût.  Pour information, Kafka est la soi-disant Reactive Kafka, pas Kafka Streams.  Pour autant que je sache, Kafka Streams ne supporte pas la contre-pression.  Reactive Kafka est une implémentation de flux de Kafka qui prend en charge Reactive Streams. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f24/160/09d/f2416009d41f26f08e665b2d510aa7db.jpg"><br><br>  La liste des connecteurs Alpakka .NET est plus modeste, mais elle est réapprovisionnée et il y a un élément de concurrence.  Il y a un tweet de demi-an de David Fowler de Microsoft, qui a déclaré que SignalR peut désormais échanger des données avec Reactive Extensions, et l'un des développeurs d'Akka a répondu qu'il se trouvait en fait dans Akka Streams depuis un certain temps.  Akka prend en charge divers services de Microsoft Azure.  CSV est le résultat de la frustration d'Aaron Stannard lorsqu'il a découvert qu'il n'y avait pas de bon flux pour CSV: maintenant Akka a son propre flux pour CSV XML.  Il y a AMQP (en réalité, RabbitMQ), il est en cours de développement, mais est disponible pour utilisation, ça marche.  Kafka est également en cours de développement.  Cette liste continuera de s'étendre. <br><br>  Quelques mots sur les alternatives, car si vous travaillez avec des flux de données, Akka Streams n'est bien sûr pas le seul moyen de gérer ces flux.  Très probablement, dans votre projet, le choix de la façon d'implémenter les threads dépendra de nombreux autres facteurs qui peuvent devenir essentiels.  Par exemple, si vous travaillez beaucoup avec Microsoft Azure et Orléans est organiquement intégré aux besoins de votre projet avec leur prise en charge des acteurs virtuels, ou, comme ils les appellent, grains, alors ils ont leur propre implémentation qui ne répond pas à la spécification Reactive Streams - Orleans Streams, qui il sera le plus proche de vous et il est logique que vous y prêtiez attention.  Si vous travaillez beaucoup avec TPL, il y a TPL DataFlow - cela peut être l'analogie la plus proche des flux Akka: il existe également des primitives pour lier les flux de données, ainsi que des outils de mise en mémoire tampon et de limitation de la bande passante (BoundedCapacity, MaxMessagePerTask).  Si les idées du modèle d'acteur sont proches de vous, alors Akka Streams est un moyen de résoudre ce problème et de gagner beaucoup de temps sans avoir à écrire chaque acteur manuellement. <br><br><h1>  Exemple d'implémentation: flux du journal des événements </h1><br>  Regardons quelques exemples d'implémentation.   —     ,    .        Akka Streams,   ,        - ,     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/43e/de0/51f/43ede051f01ec132e11502f9cebaccaf.png"><br><br>      .     :    15  23 ,   7 .           —      .     Kibana Dashboard. <br> Kibana    Elasticsearch ,   Elasticsearch  ,    ,      ,        ,    .     ,      ,    , . .    .      (event journal) Akka,      Microsoft SQL Server.    ,          . <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> EventJournal ( Ordering <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, PersistenceID <span class="hljs-keyword"><span class="hljs-keyword">NVARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, SequenceNr <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Timestamp</span></span> <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, IsDeleted <span class="hljs-built_in"><span class="hljs-built_in">BIT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, Manifest <span class="hljs-keyword"><span class="hljs-keyword">NVARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">500</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, Payload VARBINARY(<span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, Tags <span class="hljs-keyword"><span class="hljs-keyword">NVARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> QU_EventJournal <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span> (PersistenceID, SequenceNr) )</code> </pre> <br>   ,  ,   ,  ,   SQL Server,     eventstore   Akka, eventJournal.     eventstore. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cae/28e/b8e/cae28eb8efd64485e534c63d90550ce2.jpg"><br><br>    ,     .  ,    ,       ,      ,   -    :     ,  .      ,         . . .  -  .       ,    .       ,   .    ,     Akka  persistence query. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b2/bb9/08b/6b2bb908be095a552de279cbefad7f1b.jpg"><br><br>          ,   ,          . <br><br>   (persistence queries): <br><br><ul><li> AllPersistencelds </li><li> CurrentPersistencelds </li><li> EventsByPersistenceld </li><li> CurrentEventsByPersistenceld </li><li> EventsByTag </li><li> CurrentEventsByTag </li></ul><br>      ,    , ,   Current —  ,      .     —    .   EventsByTag. <br><br><pre> <code class="hljs kotlin">let system = mailbox.Context.System let queries = PersistenceQuery.Get(system) .ReadJournalFor&lt;SqlReadJournal&gt;(SqlReadJournal.Identifier) let mat = ActorMaterializer.Create(system) let offset = getCurrentOffset client config let ks = KillSwitches.Shared <span class="hljs-string"><span class="hljs-string">"persistence-elastic"</span></span> let task = queries.EventsByTag(PersistenceUtils.anyEventTag, offset) .Select(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> e -&gt; ElasticTypes.EventEnvelope.FromAkka e) .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GroupedWithin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config.BatchSize, config.BatchTimeout)</span></span></span></span> .Via(ks.Flow()) .RunForeach((<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> batch -&gt; processItems client batch), mat) .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ContinueWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(handleStreamError mailbox, TaskContinuationOptions.OnlyOnFaulted)</span></span></span></span> |&gt; Async.AwaitTaskVoid</code> </pre> <br>  ,    .     F#,   C#      .   EventsByTag,    Akka Streams,      ,     Elasticsearch. . .   -   ,       ,   ,    —          .        . <br><br>       .   ,       ,    ,       ,  Twitter      ,   —  ,   , ,    .     ,   Akka Streams. <br><br><h1>  :   </h1><br>    Akka  Scala,  Akka.NET,      ,      ,        ,      , . .          -  .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tweetinvi</a> —   ,     Twitter,         .      Reactive Streams, . .      ,    ,     ,  ,   -  Akka,      ,     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/acf/ac1/103/acfac11035eee1b69f2eb4c148f2f7f4.jpg"><br><br>       ,      , . .  Broadcast-.        ,     ,       .         :     ,         ,    ,    ,          . <br><br>      GitHub-,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AkkaStreamsDemo</a> .    (      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   </a> ). <br><br>  Commençons par un simple.        Twitter:   Program.cs <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> useCachedTweets = <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  ,     Twitter,     ,  .      RunnableGraph. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IRunnableGraph&lt;IActorRef&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRunnableGraph</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tweetSource = Source.ActorRef&lt;ITweet&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>, OverflowStrategy.DropHead); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> formatFlow = Flow.Create&lt;ITweet&gt;().Select(Utils.FormatTweet); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> writeSink = Sink.ForEach&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(Console.WriteLine); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tweetSource.Via(formatFlow).To(writeSink); }</code> </pre> <br> ( <a href=""></a> ) <br><br>      ,     .   ,      ,  (     )      . <br><br> StartTweetStream —      Tweetinvi. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartTweetStream</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IActorRef actor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stream = Stream.CreateSampleStream(); stream.TweetReceived += (_, arg) =&gt; { arg.Tweet.Text = arg.Tweet.Text.Replace(<span class="hljs-string"><span class="hljs-string">"\r"</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span>).Replace(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> json = JsonConvert.SerializeObject(arg.Tweet); File.AppendAllText(<span class="hljs-string"><span class="hljs-string">"tweets.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{json}</span></span></span><span class="hljs-string">\r\n"</span></span>); actor.Tell(arg.Tweet); }; stream.StartStream(); }</code> </pre> <br> ( <a href=""></a> ) <br><br>  CreateSampleStream    ,       .      ,   ,    ,  : «  ».     IEnumerable,       . <br><br>  <a href="">TweetEnumerator</a>   :     ,     Current, MoveNext, Reset,   Dispose,    .    ,      .   ,      .      . <br><br>     useCachedTweets  true,    . CashedTweets —    ,       50000 ,     , ,    .    ,         ,   .   —    .          ,   . <br><br> TweetsWithBroadcast: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> graph = GraphDsl.Create(b =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> broadcast = b.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Broadcast&lt;ITweet&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> merge = b.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Merge&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); b.From(broadcast.Out(<span class="hljs-number"><span class="hljs-number">0</span></span>)) .Via(Flow.Create&lt;ITweet&gt;().Select(tweet =&gt; tweet.CreatedBy)) .Via(formatUser) .To(merge.In(<span class="hljs-number"><span class="hljs-number">0</span></span>)); b.From(broadcast.Out(<span class="hljs-number"><span class="hljs-number">1</span></span>)) .Via(Flow.Create&lt;ITweet&gt;().Select(tweet =&gt; tweet.Coordinates)) .Via(formatCoordinates) .To(merge.In(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FlowShape&lt;ITweet, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(broadcast.In, merge.Out); });</code> </pre> <br> ( <a href=""></a> ) <br><br>   Scala,    ,   DSL.    Broadcast    — out(0), out(1) —      CreatedBy,    ,        .    . <br><br>     —   .    . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> graph = GraphDsl.Create(b =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> broadcast = b.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Broadcast&lt;ITweet&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> merge = b.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Merge&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); b.From(broadcast.Out(<span class="hljs-number"><span class="hljs-number">0</span></span>)) .Via(Flow.Create&lt;ITweet&gt;().Select(tweet =&gt; tweet.CreatedBy) .Throttle(<span class="hljs-number"><span class="hljs-number">10</span></span>, TimeSpan.FromSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, ThrottleMode.Shaping)) .Via(formatUser) .To(merge.In(<span class="hljs-number"><span class="hljs-number">0</span></span>)); b.From(broadcast.Out(<span class="hljs-number"><span class="hljs-number">1</span></span>)) .Via(Flow.Create&lt;ITweet&gt;().Select(tweet =&gt; tweet.Coordinates) .Buffer(<span class="hljs-number"><span class="hljs-number">10</span></span>, OverflowStrategy.DropNew) .Throttle(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeSpan.FromSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">10</span></span>, ThrottleMode.Shaping)) .Via(formatCoordinates) .To(merge.In(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FlowShape&lt;ITweet, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(broadcast.In, merge.Out); });}</code> </pre> <br> ( <a href=""></a> ) <br><br>          10   ,               10.    ,    ,  ,    . , ,   Akka Streams   Reactive Streams:     .   ,     ,   ,  ,    -  .    , ,    ,          .    ,      .   ,    ,    .     Buffer(10, OverFlowStrategy.DropHead).      ,         .      10        ,      .  , ,  - ,   —      - ,   , ,   , . .          . ,      . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> graph = GraphDsl.Create(b =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> broadcast = b.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Broadcast&lt;ITweet&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> merge = b.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Merge&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); b.From(broadcast.Out(<span class="hljs-number"><span class="hljs-number">0</span></span>)) .Via(Flow.Create&lt;ITweet&gt;().Select(tweet =&gt; tweet.CreatedBy) .Throttle(<span class="hljs-number"><span class="hljs-number">10</span></span>, TimeSpan.FromSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, ThrottleMode.Shaping)) .Via(formatUser) .To(merge.In(<span class="hljs-number"><span class="hljs-number">0</span></span>)); b.From(broadcast.Out(<span class="hljs-number"><span class="hljs-number">1</span></span>)) .Via(Flow.Create&lt;ITweet&gt;().Select(tweet =&gt; tweet.Coordinates) .Buffer(<span class="hljs-number"><span class="hljs-number">10</span></span>, OverflowStrategy.DropNew) .Throttle(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeSpan.FromSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">10</span></span>, ThrottleMode.Shaping)) .Via(Flow.Create&lt;ICoordinates&gt;().SelectAsync(<span class="hljs-number"><span class="hljs-number">5</span></span>, Utils.GetWeatherAsync)) .Via(formatTemperature) .To(merge.In(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FlowShape&lt;ITweet, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(broadcast.In, merge.Out); });</code> </pre> <br> ( <a href=""></a> ) <br><br>     ,    SelectAsync,     .         ,    ,        5:  ,    5  ,     ,       .    ,    ,     . <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWeatherAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ICoordinates coordinates</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> requestUrl = <span class="hljs-string"><span class="hljs-string">$"http://api.met.no/weatherapi/locationforecast/1.9/?lat=</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{coordinates.Latitude}</span></span></span><span class="hljs-string">;lon=</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{coordinates.Latitude}</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> httpClient.GetStringAsync(requestUrl); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> doc = XDocument.Parse(result); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = doc.Root.Descendants(<span class="hljs-string"><span class="hljs-string">"temperature"</span></span>).First().Attribute(<span class="hljs-string"><span class="hljs-string">"value"</span></span>).Value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span>.Parse(temp); }</code> </pre> <br> ( <a href=""></a> ) <br><br>    .     -,      ,   -  ,   HttpClient   ,   XML,   ,     . <br><br>  ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> ,      ,      .     10     10    ,          ,   . <br><br>  ,    —   ,       .     ,     Akka Streams,   ,    . ,       ,  . <br><br>      , ,  ,       Akka Streams,        .  ,        ,      Akka Streams,       C#      ,      ,        ,    ,    . <br><br><h1>   </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/17a/f2f/c2b/17af2fc2bfbacfc95fbe5bc9504a346e.jpg"><br><br>    Akka Streams   ,         ?  DotNext 2017 Moscow    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a>  Azure Functions.   -     ,      deployment,    ,      (      - ,     ,   ),            .     ,        ,    ,        .        ,      ,    Akka Streams, ..    ,            .                 . <br><br>  Akka Streams       , ,   ,     ,   ,      .    ,         ,     ,      ,    ,           .   Akka Streams —  ,     ,          . <br><br>        ,       Akka Streams,  «Akka Stream Rap».  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>  ,    . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1Ct3eIQ0Tgc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><blockquote> <i>This is the Akka Stream. <br><br> This is the Source that feeds the Akka Stream. <br><br> This is the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Streams. <br><br> This is the Balance that splits the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is the Zip that combines from the Balance that splits the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is the Drop that removes from the Zip that combines from the Balance that splits the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is TakeWhile that pulls from the Drop that removes from the Zip that combines from the Balance that splits the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is the Throttle that speeds down the TakeWhile that pulls from the Drop that removes from the Zip that combines from the Balance that splits the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is the Bidiflow that turns back the Throttle that speeds down the TakeWhile that pulls from the Drop that removes from the Zip that combines from the Balance that splits the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the source that feeds the Akka Streams. <br><br> This is the Sink that is filled from the Bidiflow that turns back the Throttle that speeds down the TakeWhile that pulls from the Drop that removes from the Zip that combines from the Balance that splits the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream.</i> </blockquote> <b> .</b>         — 22-23      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DotNext 2018 Moscow</a> ,        .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>    (     ). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr418639/">https://habr.com/ru/post/fr418639/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418629/index.html">Comment vérifier indépendamment si vous pouvez breveter votre produit et effectuer une recherche de brevets</a></li>
<li><a href="../fr418631/index.html">7 directives de code javascript</a></li>
<li><a href="../fr418633/index.html">Réactivité JavaScript: un exemple simple et intuitif</a></li>
<li><a href="../fr418635/index.html">Création d'une machine d'arcade d'émulation. Partie 1</a></li>
<li><a href="../fr418637/index.html">Kubernetes aux masses: Slurm démarre le 3 août</a></li>
<li><a href="../fr418641/index.html">Une erreur qui empêche un designer de grandir</a></li>
<li><a href="../fr418643/index.html">Assis vs debout: comment mieux travailler?</a></li>
<li><a href="../fr418645/index.html">Articles de la conférence de printemps C ++ Russie 2018</a></li>
<li><a href="../fr418647/index.html">TESS lance la recherche d'exoplanètes</a></li>
<li><a href="../fr418649/index.html">La génération continue de versions alternatives de TLS résoudra le problème d'ossification de l'ancien protocole</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>