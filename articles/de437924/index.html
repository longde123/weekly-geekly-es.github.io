<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👓 👇🏾 👈 Blockchain Sharding 🛣️ 💿 🛠️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits, ich bin einer der Entwickler von Near Protocol, das unter anderem Sharding implementiert. In diesem Artikel möchte ich detailliert e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Blockchain Sharding</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437924/"><p>  Hallo allerseits, ich bin einer der Entwickler von Near Protocol, das unter anderem Sharding implementiert. In diesem Artikel möchte ich detailliert erläutern, was Sharding in der Blockchain im Allgemeinen ist, wie es funktioniert, und eine Reihe von Problemen ansprechen, die beim Erstellen auftreten. </p><br><p>  Es ist bekannt, dass Ethereum, die beliebteste dApps-Plattform, weniger als 20 Transaktionen pro Sekunde verarbeitet.  Aufgrund dieser Einschränkung sind der Preis für Transaktionen und die Zeit für deren Bestätigung sehr hoch: Trotz der Tatsache, dass ein Block alle 10-12 Sekunden einmal in Ethereum veröffentlicht wird, beträgt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die</a> Zeit zwischen dem Senden einer Transaktion und dem tatsächlichen Fall in den Block laut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ETH-Tankstelle</a> durchschnittlich 1,2 Minuten.  Aufgrund der geringen Bandbreite, der hohen Preise und der langen Transaktionsbestätigung können keine Hochleistungsdienste auf Ethereum gestartet werden. </p><br><p>  Der Hauptgrund dafür, dass Ethereum nicht mehr als 20 Transaktionen pro Sekunde verarbeiten kann, ist, dass jeder Knoten in Ethereum jede Transaktion überprüfen muss.  In den fünf Jahren seit der Veröffentlichung von Ethereum wurden viele Ideen vorgeschlagen, um dieses Problem zu lösen.  Diese Lösungen können grob in zwei Gruppen unterteilt werden: diejenigen, die anbieten, Transaktionen an eine kleine Gruppe von Knoten mit sehr guter Hardware zu delegieren, und diejenigen, die jedem Knoten anbieten, nur eine Teilmenge aller Transaktionen zu verarbeiten.  Ein Beispiel für den ersten Ansatz ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thunder</a> , bei dem Blöcke nur von einem Knoten erstellt werden, wodurch nach Angaben der Entwickler 1200 Transaktionen pro Sekunde empfangen werden können, was 100-mal mehr ist als bei Ethereum.  Weitere Beispiele aus der ersten Kategorie sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Algorand</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SpaceMesh</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Solana</a> .  Alle diese Protokolle verbessern verschiedene Aspekte des Protokolls und ermöglichen es Ihnen, mehr Transaktionen als in Ethereum auszuführen. Alle Protokolle sind jedoch durch die Geschwindigkeit eines (wenn auch sehr leistungsfähigen) Computers begrenzt. </p><a name="habracut"></a><br><p>  Der zweite Ansatz, bei dem jeder Knoten nur eine Teilmenge von Transaktionen verarbeitet, wird als Sharding bezeichnet.  Auf diese Weise plant die Ethereum Foundation, die Bandbreite von Ethereum zu erhöhen. </p><br><p>  In diesem Beitrag werde ich Ihnen am Beispiel mehrerer Protokolle, die derzeit entwickelt werden, erklären, wie Sharding in Blockchain funktioniert. </p><br><div class="spoiler">  <b class="spoiler_title">Terminologie</b> <div class="spoiler_text"><p>  Da die Terminologie nicht standardisiert ist, werde ich im Artikel die folgenden russischen Begriffe verwenden: </p><br><p>  <strong>Eine Blockchain</strong> ist entweder eine Technologie im Allgemeinen oder eine Datenstruktur, die alle Blöcke einschließlich Gabeln enthält. </p><br><p>  <strong>Eine Kette</strong> ist eine bestimmte Kette in der Blockchain, dh alle Blöcke, die ausgehend von einem Block über Links zum vorherigen Block erreichbar sind. </p><br><p>  <strong>Die kanonische Kette</strong> ist eine Kette in der Blockchain, die der Teilnehmer, der die Blockchain beobachtet, als die aktuelle Kette betrachtet.  In der Proof of Work-Blockchain ist dies beispielsweise die Kette mit der größten Komplexität. </p><br><p>  <strong>Ein Netzwerk</strong> besteht aus vielen Teilnehmern, die Blockchain erstellen und verwenden. </p><br><p>  <strong>Ein Knoten</strong> ist ein Server, der ein Netzwerk unterstützt oder verwendet. </p></div></div><br><h2 id="samyy-prostoy-sharding">  Das einfachste Splittern </h2><br><p>  In der einfachsten Implementierung werden wir anstelle einer Blockchain mehrere unterstützen und jede solche Blockchain als "Shard" bezeichnen.  Jeder Shard wird von einer unabhängigen Gruppe von Knoten unterstützt, die Transaktionen überprüfen und Blöcke erstellen.  Im Folgenden werde ich solche Knoten als Validatoren bezeichnen. </p><br><p>  Jeder Shard ist für eine Teilmenge von Verträgen und Konten verantwortlich.  Nehmen Sie vorerst an, dass Transaktionen immer nur mit Verträgen und Konten innerhalb desselben Shards ausgeführt werden.  Ein derart vereinfachtes Design reicht aus, um einige interessante Probleme und Merkmale des Splitterns aufzuzeigen. </p><br><h2 id="naznachenie-validatorov-i-centralnyy-blokcheyn">  Termin für Validatoren und zentrale Blockchain </h2><br><p>  Das erste Problem mit der Tatsache, dass jeder Shard seine eigenen Validatoren hat, ist, dass wenn wir 10 Shadras haben, jeder Shard jetzt 10-mal weniger zuverlässig ist als eine Blockchain.  Wenn also eine Blockchain mit X-Validatoren beschließt, eine harte Gabel in einem Shard-System mit 10 Shards zu erstellen und die X-Validatoren zwischen 10 Shards aufteilt, gibt es jetzt nur noch X / 10-Validatoren in jedem Shard. Um die Kontrolle über den Shard zu erlangen, müssen Sie die Kontrolle über 5,1% erlangen (51) % / 10) Validatoren. </p><br><p>  Was zu der ersten interessanten Frage führt: Wer weist Shards Validatoren zu?  Die Kontrolle über 5,1% der Validatoren ist nur dann ein Problem, wenn sich alle 5,1% der Validatoren im selben Shard befinden.  Wenn die Validatoren selbst nicht auswählen können, welchem ​​Shard sie zugewiesen sind, können sie keine Kontrolle über 5,1% der Validatoren erlangen, bevor sie den Shards zugewiesen werden. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6c8/bd1/f09/6c8bd1f0949baeb207f4d7e6c6c81d8f.png" alt="Bild"></p><br><p>  Fast alle vorhandenen vorgeschlagenen Sharding-Designs verwenden eine Zufallszahlenquelle, um Shards Validatoren zuzuweisen.  Das Erhalten von Zufallszahlen in einem verteilten System, in dem sich die Teilnehmer nicht gegenseitig vertrauen, ist heute kein vollständig gelöstes Problem, das wir in diesem Artikel nicht ansprechen werden, und nehmen einfach an, dass wir eine solche Quelle von Zufallszahlen haben. </p><br><p>  Sowohl der Empfang von Zufallszahlen als auch die Ernennung von Validatoren sind systemweite Berechnungen, die für keinen bestimmten Shard spezifisch sind.  Für solche Berechnungen verfügen moderne Shard-Blockchain-Designs über eine zusätzliche dedizierte Blockchain, die ausschließlich zur Durchführung systemweiter Berechnungen vorhanden ist.  Zusätzlich zu Zufallszahlen und der Ernennung von Validatoren können solche Berechnungen das Abrufen von Hashes der letzten Blöcke aus Shards und deren Speicherung umfassen.  Verarbeitung von Sicherheiten in Proof-of-Stake-Systemen und Untersuchung von Hinweisen auf unangemessenes Verhalten mit der damit verbundenen Auswahl solcher Sicherheiten;  Shards neu ausgleichen, wenn eine solche Funktion bereitgestellt wird.  Eine solche Blockchain wird in Ethereum 2.0 und Near Protocol als Beacon-Kette, in PolkaDot als Relay-Kette und in Cosmos als Cosmos Hub bezeichnet. </p><br><p>  In diesem Beitrag werden wir eine solche Blockchain die "zentrale Blockchain" nennen.  Die Existenz einer zentralen Blockchain führt uns zum nächsten interessanten Thema - dem quadratischen Sharding. </p><br><h2 id="kvadratichnoe-shardirovanie">  Quadratisches Splittern </h2><br><p>  Sharding wird oft als eine Lösung dargestellt, die mit zunehmender Anzahl von Knoten unendlich skaliert.  Wahrscheinlich können Sie mit dieser Eigenschaft wirklich ein System erstellen, aber Systeme mit einer zentralen Blockchain haben eine Obergrenze für die Anzahl der Shards und daher keine unendliche Skalierbarkeit.  Es ist leicht zu verstehen, warum: Die zentrale Blockchain führt einige Berechnungen durch, z. B. das Zuweisen von Validatoren und das Beibehalten der neuesten Shard-Zustände, deren Komplexität proportional zur Anzahl der Shards ist.  Da die zentrale Blockchain selbst nicht sharded ist und ihr Durchsatz durch den Durchsatz jedes Knotens begrenzt ist, ist die Anzahl der Shards, die sie unterstützen kann, begrenzt. </p><br><p>  Mal sehen, wie sich der Durchsatz des gesamten Systems ändert, wenn sich die Leistung der Knoten, die es unterstützen, k-mal erhöht.  Jeder Shard kann k-mal mehr Transaktionen verarbeiten, und die zentrale Blockchain kann k-mal mehr Shards unterstützen.  Somit wächst der Durchsatz des gesamten Systems um das k ^ 2-fache.  Daher der Name "quadratisches Sharding". </p><br><p>  Es ist schwer vorherzusagen, wie viel Shard heute die zentrale Blockchain unterstützen kann, aber höchstwahrscheinlich werden wir in naher Zukunft nicht an das Transaktionslimit für eine Sharded-Blockchain mit quadratischem Sharding herankommen.  Höchstwahrscheinlich werden wir bald an die Grenze stoßen, wie viele Knoten benötigt werden, um eine solche Anzahl von Shards zu unterstützen. </p><br><h2 id="shardirovanie-sostoyaniya">  Staatliche Scherbe </h2><br><p>  Der Status enthält alle Informationen zu allen Konten und Verträgen.  Bisher haben wir über Sharding im Allgemeinen gesprochen, ohne genau anzugeben, was Sharding ist.  Knoten in der Blockchain führen die folgenden drei Aufgaben aus: 1) Transaktionen ausführen 2) Transaktionen und Blöcke an andere Knoten weiterleiten und 3) den Status und den Verlauf der Blockchain speichern.  Jede dieser drei Aufgaben ist mit einer ständig zunehmenden Belastung der Knoten verbunden: </p><br><ol><li>  Die Notwendigkeit, Transaktionen durchzuführen, erfordert mehr Rechenleistung mit einer Zunahme der Anzahl von Transaktionen; </li><li>  Die Notwendigkeit, Transaktionen weiterzuleiten, erfordert mehr Netzwerkbandbreite, wenn die Transaktionen zunehmen. </li><li>  Die Notwendigkeit, Status und Verlauf beizubehalten, erfordert mehr Speicherplatz, wenn die Größe des Status und / oder des Verlaufs zunimmt.  Es ist wichtig zu beachten, dass im Gegensatz zu den ersten beiden Punkten der erforderliche Speicherplatz zunimmt, auch wenn sich die Anzahl der Transaktionen pro Zeiteinheit nicht ändert. </li></ol><br><p>  Aus der obigen Liste geht hervor, dass der Speicherplatz das größte Problem darstellt, da nur der Speicherplatz wächst, selbst wenn die Anzahl der Transaktionen nicht wächst, in der Praxis jedoch nicht.  Heutzutage belegt der Status von Ethereum etwa 100 GB, was auf jedem modernen Computer problemlos gespeichert werden kann. Die Anzahl der Transaktionen, die Ethereum verarbeiten kann, ist jedoch auf mehrere zehn pro Sekunde begrenzt und hängt von der Rechenleistung und dem Netzwerk ab. </p><br><p>  Zilliqa ist das bekannteste Projekt, das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Computer und Netzwerk zerstört,</a> aber keinen Staat.  Das Berechnen von Sharding ist einfacher als das Sharding-Status, da alle Knoten alle Status haben und dennoch problemlos Verträge ausführen können, die andere Verträge verursachen oder Konten auf verschiedenen Shards beeinflussen.  In dieser Hinsicht ist das Design von Zilliqa zu vereinfacht, Kritik am Design auf Englisch kann hier gelesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> . </p><br><p>  Obwohl State Sharding ohne Shading-Berechnungen vorgeschlagen wurde, sind mir keine Projekte bekannt, die dies wirklich tun. Daher gehen wir davon aus, dass State Sharding Sharding-Berechnungen impliziert. </p><br><p>  In der Praxis isoliert die Tatsache, dass der Zustand auf irgendeine Weise zerplatzt ist, die Scherben und ermöglicht es ihnen, unabhängige Blockchains zu sein, wie wir oben definiert haben.  Validatoren in Shards speichern nur einen für ihren Shard spezifischen Status, und nur Transaktionen, die diesen Status betreffen, werden ausgeführt und weitergeleitet.  Dies reduziert die Belastung des Prozessors, der Festplatte und des Netzwerks linear mit der Anzahl der Shards, bringt jedoch neue Probleme mit sich, wie z. B. Inter-Shard-Transaktionen. </p><br><h2 id="mezhdu-shardovye-tranzakcii">  Inter-Shard-Transaktionen </h2><br><p>  Bisher haben wir Shards als unabhängige Blockchains in Bezug auf die Ausführung von Transaktionen gesehen.  Mit diesem Design ist es beispielsweise unmöglich, eine Transaktion abzuschließen, bei der Geld zwischen zwei Konten auf zwei verschiedenen Shards übertragen wird, oder einen Kontakt auf einem Shard aus einem Vertrag mit einem anderen herzustellen.  Ich möchte beide Szenarien unterstützen. </p><br><p>  Der Einfachheit halber betrachten wir nur Transaktionen, die Geld überweisen, und wir gehen davon aus, dass jeder Teilnehmer ein Konto auf genau einem Shard hat.  Wenn ein Teilnehmer auf einem Shard Geld an einen Teilnehmer auf demselben Shard überweisen möchte, können die Validatoren dieses Shards diese Transaktion verarbeiten und auf den Staat anwenden.  Aber wenn Alice zum Beispiel ein Konto auf Shard Nr. 1 hat und sie Geld mit einem Konto auf Shard Nr. 2 an Bob senden möchte, weder Shard-Validatoren Nr. 1 (die Bob kein Geld hinzufügen können) noch Shard-Validatoren Nr. 2 (die Alice nicht bekommen können) ) kann die Transaktion nicht abschließen und den Status nicht aktualisieren. </p><br><p>  Es gibt zwei große Gruppen von Ansätzen zur Lösung dieses Problems: </p><br><ol><li><p>  <strong>Synchron</strong> : Bei jeder Transaktion mit mehreren Shards werden Blöcke in Shards mit Statusaktualisierungen für diese Transaktion gleichzeitig erstellt, und Validatoren in diesen Shards arbeiten zusammen, um solche Blöcke zu erstellen.  Das aufwendigste Design dieses Ansatzes, das mir bekannt ist, sind Merge Blocks, die hier (auf Englisch) beschrieben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> . </p><br></li><li><p>  <strong>Asynchron</strong> : Eine Inter-Shard-Transaktion wird in Shards ausgeführt, die davon betroffen sind. Asynchron: Der Teil der Transaktion, der Bob Geld hinzufügt, wird in Shard 2 ausgeführt, wenn die Validatoren im Shard Beweise dafür haben, dass der Teil der Transaktion, der Geld von Alice abzieht, in ausgeführt wurde Scherbe # 1.  Dieser Ansatz ist in den heute entwickelten Systemen populärer, da für die Blockproduktion keine zusätzliche Synchronisation zwischen Shards erforderlich ist.  Solche Systeme werden heute in Cosmos, Ethereum Serenity, Near Protocol, Kadena und anderen angeboten.  Das Problem bei diesem Ansatz besteht darin, dass, wenn die Blöcke unabhängig voneinander erstellt werden, wahrscheinlich einer der Blöcke, die die Statusaktualisierung für die Transaktion enthalten, nicht in der kanonischen Kette in ihrem Shard enthalten ist und die Transaktion daher nur teilweise abgeschlossen wird.  Betrachten Sie zum Beispiel die folgende Abbildung.  Es zeigt zwei Shards, in denen die Gabeln aufgetreten sind, und eine Inter-Shard-Transaktion, deren Statusaktualisierung sich in den Blöcken A bzw. X 'widerspiegelt.  Wenn sich herausstellt, dass die Ketten AB und V'-X'-Y'-Z 'in ihren Scherben kanonisch sind, ist die Transaktion vollständig abgeschlossen.  Wenn die Ketten A'-B'-C'-D 'und VX kanonisch sind, wird die Transaktion vollständig abgebrochen, was akzeptabel ist.  Wenn beispielsweise AB und VX kanonisch werden, wird ein Teil der Transaktion abgeschlossen, der andere abgebrochen und die Transaktion teilweise abgeschlossen. </p><br></li></ol><br><p><img src="https://habrastorage.org/getpro/habr/post_images/640/162/e6c/640162e6c138290296c5186fab24e5d1.png" alt="Bild"></p><br><p>  Das oben beschriebene Szenario ist eines der großen Probleme beim Sharding, bei dem nicht alle vorgeschlagenen Lösungen optimal sind.  Wir werden es weiter unten ansprechen. </p><br><h2 id="plohoe-povedenie">  Schlechtes Benehmen </h2><br><p>  Nachdem wir herausgefunden haben, wie Shard-Blockchains funktionieren, und die Konzepte der zentralen Blockchain, die Ernennung von Validatoren und Cross-Shard-Transaktionen untersucht haben, werden wir uns am Ende dieses Artikels mit einem weiteren interessanten Thema befassen: Was kann ein Teilnehmer, der versucht, das System anzugreifen, tun, wenn er es schafft? Kontrolle über eine ausreichend große Anzahl von Validatoren in einem Shard. </p><br><h3 id="celenapravlennye-forki">  Gezielte Gabeln </h3><br><p>  Wenn der Teilnehmer genügend Kontrolle über die Scherbe hat, kann er gezielt Gabeln erstellen.  Bei der Erstellung von Gabeln spielt es keine Rolle, welcher Konsens in Shards verwendet wird. Insbesondere spielt es keine Rolle, ob es sich um BFT handelt oder nicht. Wenn eine ausreichende Anzahl von Validatoren unter der Kontrolle eines Angreifers steht, kann eine Gabel erstellt werden.  Das Ziel der Abzweigung könnte beispielsweise darin bestehen, eine Transaktion zurückzusetzen, die für etwas außerhalb der Blockchain bezahlt hat. </p><br><p>  Es wird behauptet, dass es einfacher ist, die Kontrolle über 50% des Shards zu erlangen als über 50% des gesamten Netzwerks (zum Beispiel, weil ein Teilnehmer versuchen kann, Validatoren zu hacken oder zu bestechen, nachdem sie dem Shard zugewiesen wurden).  Per Definition ändern Inter-Shard-Transaktionen den Status in mehreren Shards.  Solche Änderungen fallen in einige Blöcke in den Blockketten der entsprechenden Shards.  Es ist notwendig, dass entweder alle derartigen Blöcke finalisiert werden (d. H. Zur kanonischen Kette in ihren jeweiligen Scherben gehörten) oder dass nicht alle finalisiert werden sollten (d. H. Nicht zur kanonischen Kette in ihren Scherben gehörten).  Da wir davon ausgehen, dass einige Teilnehmer mit schlechten Absichten im Prinzip die Kontrolle über den Shard erlangen können, können wir nicht davon ausgehen, dass Gabeln nicht auftreten, selbst wenn ein byzantinischer Konsens erreicht wurde oder eine große Anzahl von Blöcken auf einem Block mit einer Transaktion aufgebaut wurde. </p><br><p>  Dieses Problem hat viele Lösungen, von denen die einfachste manchmal darin besteht, den Hash des letzten Blocks im Shard in der zentralen Blockchain zu speichern.  Der kanonische Kettenauswahlalgorithmus in Shards wird dann so geändert, dass kein Ziel den letzten Block enthält, der in der zentralen kanonischen Blockchain gespeichert ist.  Um Situationen vollständig zu vermeiden, in denen eine Transaktion teilweise abgeschlossen ist, weil sich einige der Blöcke, die ihre Statusaktualisierung enthalten, außerhalb der kanonischen Ketten befinden, können Sie den Algorithmus zum Ausführen von Inter-Shard-Transaktionen so ändern, dass Shard A den Beweis der Transaktion in Shard B erst im Block akzeptiert Das Status-Update für die Transaktion in Shard B wurde nicht in der zentralen Blockchain gespeichert. </p><br><h3 id="sozdanie-nevalidnyh-blokov">  Ungültige Blöcke erstellen </h3><br><p>  Wenn der Teilnehmer die Kontrolle über eine ausreichend große Anzahl von Validatoren im Shard erlangen konnte, kann er versuchen, einen vollständig ungültigen Block zu erstellen.  Angenommen, der Status vor dem Block war so, dass Alice 10 Token hatte, und in Bob - 0 enthält der Block nur eine Transaktion, die 10 Token von Alices Konto an Bobs Konto sendet, im neuen Status jedoch 0 Token von Alice und 1000 mit Bob. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e68/edd/049/e68edd049344263dd671209a10be0890.png" alt="Bild"></p><br><p>  In einer klassischen, nicht gesplitteten Blockchain ist das Erstellen eines solchen Blocks unmöglich, da alle Teilnehmer, wie diejenigen, die Blöcke erstellen, und diejenigen, die einfach die Blockchain verwenden, alle Blöcke überprüfen und jeden Block, der solche Fehler enthält, sofort verwerfen.  Selbst wenn die vom Angreifer kontrollierten Validatoren die Kette schneller erstellen können, können sie die längere Kette mit dem ungültigen Block nicht als kanonische übergeben, da alle Netzwerkteilnehmer den ungültigen Block und alle darauf erstellten Blöcke sofort verwerfen.  Ehrliche Validatoren bauen weiterhin auf dem letzten gültigen Block auf, und alle Netzwerkteilnehmer sehen ihre Kette als kanonisch an. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1c5/0a8/b45/1c50a8b45dfda77a14262225dc3351ca.png" alt="Bild"></p><br><p>  Die obige Abbildung zeigt fünf Validatoren, von denen drei unter der Kontrolle des Angreifers stehen.  Sie erstellten den ungültigen Block A 'und bauten dann die Kette weiter auf.  Zwei private Prüfer verwarfen Block A 'sofort als ungültig und bauten weiter auf dem letzten gültigen Block auf, den sie kannten, wodurch eine Gabelung erstellt wurde.  Da es in einer ehrlichen Kette weniger Validatoren gibt als in einer unehrlichen, ist ihre Kette kürzer.  In der klassischen Blockchain ohne Hardware validieren jedoch alle Teilnehmer des Systems alle Blöcke, die sie sehen.  Somit sieht jeder Teilnehmer, der die Blockchain verwendet, dass A 'ungültig ist, verwirft es und verwirft daher B', C 'und D' als auf dem ungültigen Block aufgebaut, und somit sehen alle Teilnehmer AB als eine kanonische Kette. </p><br><p>  In einem Shard-Design kann kein Teilnehmer alle Blöcke in allen Blockchains validieren.  Daher benötigen wir einen Mechanismus, mit dem Validatoren in einem bestimmten Shard sicherstellen können, dass zu keinem Zeitpunkt in der Vergangenheit ein ungültiger Block in einem anderen Shard erstellt wurde, von dem sie eine Inter-Shard-Transaktion erhalten haben. </p><br><p>     ,        ,              .         ,   ,   (      ). </p><br><p>     ,       : </p><br><ol><li>  -           .    ,         2/3       .         ,         ,              ,   .           ,  ,     ,           -           ,   .     ,    . </li><li>  -  ,  ,    ,  ,     , .   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zk-SNARKs</a> (   zk,  zero-knowledge,     ,       non-zk SNARKs).  ,  zk-SNARKs  ,          . </li></ol><br><p>  ,   ,   ,      ,          .     —   . </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich schreibe viel über Blockchain und Sharding auf Englisch. </font><font style="vertical-align: inherit;">Wir interviewen auch regelmäßig Autoren anderer Protokolle wie Cosmos und Solana und vertiefen uns in technische Details. </font><font style="vertical-align: inherit;">Wenn Sie sich für das Thema interessieren, können Sie neuen Posts und Videos folgen, indem Sie meinen Twitter </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@AlexSkidanov abonnieren</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437924/">https://habr.com/ru/post/de437924/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437912/index.html">Ein kleines Notizbuch für einen Systemadministrator</a></li>
<li><a href="../de437914/index.html">Jaxb (XJC) generiert Klassen aus XML-Schema (XSD) mit Klassen- und Feldbeschreibungen als Anmerkungen. XJC-Plugin</a></li>
<li><a href="../de437916/index.html">Geben Sie den E-Book-Reader in jede Tasche! Rückblick auf die neuesten Innovationen von ONYX BOOX</a></li>
<li><a href="../de437918/index.html">Videoaufnahme mit automatischem Pausenauswurf durch freie Software mit Fahrradbau</a></li>
<li><a href="../de437922/index.html">Angriffsmodell: Wo es hauptsächlich in der elektronischen Beschaffung missbraucht wird und wie man damit umgeht</a></li>
<li><a href="../de437926/index.html">Der maßgebliche Leitfaden zum Blockchain-Sharding</a></li>
<li><a href="../de437928/index.html">Wie man Englisch lernt</a></li>
<li><a href="../de437930/index.html">Leuchte Combo</a></li>
<li><a href="../de437932/index.html">Intel Optane Memory H10: Optane Cache + QLC 3D NAND</a></li>
<li><a href="../de437934/index.html">Zeitmanagement im wirklichen Leben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>