<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëì üëáüèæ üëà Blockchain Sharding üõ£Ô∏è üíø üõ†Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits, ich bin einer der Entwickler von Near Protocol, das unter anderem Sharding implementiert. In diesem Artikel m√∂chte ich detailliert e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Blockchain Sharding</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437924/"><p>  Hallo allerseits, ich bin einer der Entwickler von Near Protocol, das unter anderem Sharding implementiert. In diesem Artikel m√∂chte ich detailliert erl√§utern, was Sharding in der Blockchain im Allgemeinen ist, wie es funktioniert, und eine Reihe von Problemen ansprechen, die beim Erstellen auftreten. </p><br><p>  Es ist bekannt, dass Ethereum, die beliebteste dApps-Plattform, weniger als 20 Transaktionen pro Sekunde verarbeitet.  Aufgrund dieser Einschr√§nkung sind der Preis f√ºr Transaktionen und die Zeit f√ºr deren Best√§tigung sehr hoch: Trotz der Tatsache, dass ein Block alle 10-12 Sekunden einmal in Ethereum ver√∂ffentlicht wird, betr√§gt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die</a> Zeit zwischen dem Senden einer Transaktion und dem tats√§chlichen Fall in den Block laut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ETH-Tankstelle</a> durchschnittlich 1,2 Minuten.  Aufgrund der geringen Bandbreite, der hohen Preise und der langen Transaktionsbest√§tigung k√∂nnen keine Hochleistungsdienste auf Ethereum gestartet werden. </p><br><p>  Der Hauptgrund daf√ºr, dass Ethereum nicht mehr als 20 Transaktionen pro Sekunde verarbeiten kann, ist, dass jeder Knoten in Ethereum jede Transaktion √ºberpr√ºfen muss.  In den f√ºnf Jahren seit der Ver√∂ffentlichung von Ethereum wurden viele Ideen vorgeschlagen, um dieses Problem zu l√∂sen.  Diese L√∂sungen k√∂nnen grob in zwei Gruppen unterteilt werden: diejenigen, die anbieten, Transaktionen an eine kleine Gruppe von Knoten mit sehr guter Hardware zu delegieren, und diejenigen, die jedem Knoten anbieten, nur eine Teilmenge aller Transaktionen zu verarbeiten.  Ein Beispiel f√ºr den ersten Ansatz ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thunder</a> , bei dem Bl√∂cke nur von einem Knoten erstellt werden, wodurch nach Angaben der Entwickler 1200 Transaktionen pro Sekunde empfangen werden k√∂nnen, was 100-mal mehr ist als bei Ethereum.  Weitere Beispiele aus der ersten Kategorie sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Algorand</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SpaceMesh</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Solana</a> .  Alle diese Protokolle verbessern verschiedene Aspekte des Protokolls und erm√∂glichen es Ihnen, mehr Transaktionen als in Ethereum auszuf√ºhren. Alle Protokolle sind jedoch durch die Geschwindigkeit eines (wenn auch sehr leistungsf√§higen) Computers begrenzt. </p><a name="habracut"></a><br><p>  Der zweite Ansatz, bei dem jeder Knoten nur eine Teilmenge von Transaktionen verarbeitet, wird als Sharding bezeichnet.  Auf diese Weise plant die Ethereum Foundation, die Bandbreite von Ethereum zu erh√∂hen. </p><br><p>  In diesem Beitrag werde ich Ihnen am Beispiel mehrerer Protokolle, die derzeit entwickelt werden, erkl√§ren, wie Sharding in Blockchain funktioniert. </p><br><div class="spoiler">  <b class="spoiler_title">Terminologie</b> <div class="spoiler_text"><p>  Da die Terminologie nicht standardisiert ist, werde ich im Artikel die folgenden russischen Begriffe verwenden: </p><br><p>  <strong>Eine Blockchain</strong> ist entweder eine Technologie im Allgemeinen oder eine Datenstruktur, die alle Bl√∂cke einschlie√ülich Gabeln enth√§lt. </p><br><p>  <strong>Eine Kette</strong> ist eine bestimmte Kette in der Blockchain, dh alle Bl√∂cke, die ausgehend von einem Block √ºber Links zum vorherigen Block erreichbar sind. </p><br><p>  <strong>Die kanonische Kette</strong> ist eine Kette in der Blockchain, die der Teilnehmer, der die Blockchain beobachtet, als die aktuelle Kette betrachtet.  In der Proof of Work-Blockchain ist dies beispielsweise die Kette mit der gr√∂√üten Komplexit√§t. </p><br><p>  <strong>Ein Netzwerk</strong> besteht aus vielen Teilnehmern, die Blockchain erstellen und verwenden. </p><br><p>  <strong>Ein Knoten</strong> ist ein Server, der ein Netzwerk unterst√ºtzt oder verwendet. </p></div></div><br><h2 id="samyy-prostoy-sharding">  Das einfachste Splittern </h2><br><p>  In der einfachsten Implementierung werden wir anstelle einer Blockchain mehrere unterst√ºtzen und jede solche Blockchain als "Shard" bezeichnen.  Jeder Shard wird von einer unabh√§ngigen Gruppe von Knoten unterst√ºtzt, die Transaktionen √ºberpr√ºfen und Bl√∂cke erstellen.  Im Folgenden werde ich solche Knoten als Validatoren bezeichnen. </p><br><p>  Jeder Shard ist f√ºr eine Teilmenge von Vertr√§gen und Konten verantwortlich.  Nehmen Sie vorerst an, dass Transaktionen immer nur mit Vertr√§gen und Konten innerhalb desselben Shards ausgef√ºhrt werden.  Ein derart vereinfachtes Design reicht aus, um einige interessante Probleme und Merkmale des Splitterns aufzuzeigen. </p><br><h2 id="naznachenie-validatorov-i-centralnyy-blokcheyn">  Termin f√ºr Validatoren und zentrale Blockchain </h2><br><p>  Das erste Problem mit der Tatsache, dass jeder Shard seine eigenen Validatoren hat, ist, dass wenn wir 10 Shadras haben, jeder Shard jetzt 10-mal weniger zuverl√§ssig ist als eine Blockchain.  Wenn also eine Blockchain mit X-Validatoren beschlie√üt, eine harte Gabel in einem Shard-System mit 10 Shards zu erstellen und die X-Validatoren zwischen 10 Shards aufteilt, gibt es jetzt nur noch X / 10-Validatoren in jedem Shard. Um die Kontrolle √ºber den Shard zu erlangen, m√ºssen Sie die Kontrolle √ºber 5,1% erlangen (51) % / 10) Validatoren. </p><br><p>  Was zu der ersten interessanten Frage f√ºhrt: Wer weist Shards Validatoren zu?  Die Kontrolle √ºber 5,1% der Validatoren ist nur dann ein Problem, wenn sich alle 5,1% der Validatoren im selben Shard befinden.  Wenn die Validatoren selbst nicht ausw√§hlen k√∂nnen, welchem ‚Äã‚ÄãShard sie zugewiesen sind, k√∂nnen sie keine Kontrolle √ºber 5,1% der Validatoren erlangen, bevor sie den Shards zugewiesen werden. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6c8/bd1/f09/6c8bd1f0949baeb207f4d7e6c6c81d8f.png" alt="Bild"></p><br><p>  Fast alle vorhandenen vorgeschlagenen Sharding-Designs verwenden eine Zufallszahlenquelle, um Shards Validatoren zuzuweisen.  Das Erhalten von Zufallszahlen in einem verteilten System, in dem sich die Teilnehmer nicht gegenseitig vertrauen, ist heute kein vollst√§ndig gel√∂stes Problem, das wir in diesem Artikel nicht ansprechen werden, und nehmen einfach an, dass wir eine solche Quelle von Zufallszahlen haben. </p><br><p>  Sowohl der Empfang von Zufallszahlen als auch die Ernennung von Validatoren sind systemweite Berechnungen, die f√ºr keinen bestimmten Shard spezifisch sind.  F√ºr solche Berechnungen verf√ºgen moderne Shard-Blockchain-Designs √ºber eine zus√§tzliche dedizierte Blockchain, die ausschlie√ülich zur Durchf√ºhrung systemweiter Berechnungen vorhanden ist.  Zus√§tzlich zu Zufallszahlen und der Ernennung von Validatoren k√∂nnen solche Berechnungen das Abrufen von Hashes der letzten Bl√∂cke aus Shards und deren Speicherung umfassen.  Verarbeitung von Sicherheiten in Proof-of-Stake-Systemen und Untersuchung von Hinweisen auf unangemessenes Verhalten mit der damit verbundenen Auswahl solcher Sicherheiten;  Shards neu ausgleichen, wenn eine solche Funktion bereitgestellt wird.  Eine solche Blockchain wird in Ethereum 2.0 und Near Protocol als Beacon-Kette, in PolkaDot als Relay-Kette und in Cosmos als Cosmos Hub bezeichnet. </p><br><p>  In diesem Beitrag werden wir eine solche Blockchain die "zentrale Blockchain" nennen.  Die Existenz einer zentralen Blockchain f√ºhrt uns zum n√§chsten interessanten Thema - dem quadratischen Sharding. </p><br><h2 id="kvadratichnoe-shardirovanie">  Quadratisches Splittern </h2><br><p>  Sharding wird oft als eine L√∂sung dargestellt, die mit zunehmender Anzahl von Knoten unendlich skaliert.  Wahrscheinlich k√∂nnen Sie mit dieser Eigenschaft wirklich ein System erstellen, aber Systeme mit einer zentralen Blockchain haben eine Obergrenze f√ºr die Anzahl der Shards und daher keine unendliche Skalierbarkeit.  Es ist leicht zu verstehen, warum: Die zentrale Blockchain f√ºhrt einige Berechnungen durch, z. B. das Zuweisen von Validatoren und das Beibehalten der neuesten Shard-Zust√§nde, deren Komplexit√§t proportional zur Anzahl der Shards ist.  Da die zentrale Blockchain selbst nicht sharded ist und ihr Durchsatz durch den Durchsatz jedes Knotens begrenzt ist, ist die Anzahl der Shards, die sie unterst√ºtzen kann, begrenzt. </p><br><p>  Mal sehen, wie sich der Durchsatz des gesamten Systems √§ndert, wenn sich die Leistung der Knoten, die es unterst√ºtzen, k-mal erh√∂ht.  Jeder Shard kann k-mal mehr Transaktionen verarbeiten, und die zentrale Blockchain kann k-mal mehr Shards unterst√ºtzen.  Somit w√§chst der Durchsatz des gesamten Systems um das k ^ 2-fache.  Daher der Name "quadratisches Sharding". </p><br><p>  Es ist schwer vorherzusagen, wie viel Shard heute die zentrale Blockchain unterst√ºtzen kann, aber h√∂chstwahrscheinlich werden wir in naher Zukunft nicht an das Transaktionslimit f√ºr eine Sharded-Blockchain mit quadratischem Sharding herankommen.  H√∂chstwahrscheinlich werden wir bald an die Grenze sto√üen, wie viele Knoten ben√∂tigt werden, um eine solche Anzahl von Shards zu unterst√ºtzen. </p><br><h2 id="shardirovanie-sostoyaniya">  Staatliche Scherbe </h2><br><p>  Der Status enth√§lt alle Informationen zu allen Konten und Vertr√§gen.  Bisher haben wir √ºber Sharding im Allgemeinen gesprochen, ohne genau anzugeben, was Sharding ist.  Knoten in der Blockchain f√ºhren die folgenden drei Aufgaben aus: 1) Transaktionen ausf√ºhren 2) Transaktionen und Bl√∂cke an andere Knoten weiterleiten und 3) den Status und den Verlauf der Blockchain speichern.  Jede dieser drei Aufgaben ist mit einer st√§ndig zunehmenden Belastung der Knoten verbunden: </p><br><ol><li>  Die Notwendigkeit, Transaktionen durchzuf√ºhren, erfordert mehr Rechenleistung mit einer Zunahme der Anzahl von Transaktionen; </li><li>  Die Notwendigkeit, Transaktionen weiterzuleiten, erfordert mehr Netzwerkbandbreite, wenn die Transaktionen zunehmen. </li><li>  Die Notwendigkeit, Status und Verlauf beizubehalten, erfordert mehr Speicherplatz, wenn die Gr√∂√üe des Status und / oder des Verlaufs zunimmt.  Es ist wichtig zu beachten, dass im Gegensatz zu den ersten beiden Punkten der erforderliche Speicherplatz zunimmt, auch wenn sich die Anzahl der Transaktionen pro Zeiteinheit nicht √§ndert. </li></ol><br><p>  Aus der obigen Liste geht hervor, dass der Speicherplatz das gr√∂√üte Problem darstellt, da nur der Speicherplatz w√§chst, selbst wenn die Anzahl der Transaktionen nicht w√§chst, in der Praxis jedoch nicht.  Heutzutage belegt der Status von Ethereum etwa 100 GB, was auf jedem modernen Computer problemlos gespeichert werden kann. Die Anzahl der Transaktionen, die Ethereum verarbeiten kann, ist jedoch auf mehrere zehn pro Sekunde begrenzt und h√§ngt von der Rechenleistung und dem Netzwerk ab. </p><br><p>  Zilliqa ist das bekannteste Projekt, das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Computer und Netzwerk zerst√∂rt,</a> aber keinen Staat.  Das Berechnen von Sharding ist einfacher als das Sharding-Status, da alle Knoten alle Status haben und dennoch problemlos Vertr√§ge ausf√ºhren k√∂nnen, die andere Vertr√§ge verursachen oder Konten auf verschiedenen Shards beeinflussen.  In dieser Hinsicht ist das Design von Zilliqa zu vereinfacht, Kritik am Design auf Englisch kann hier gelesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> . </p><br><p>  Obwohl State Sharding ohne Shading-Berechnungen vorgeschlagen wurde, sind mir keine Projekte bekannt, die dies wirklich tun. Daher gehen wir davon aus, dass State Sharding Sharding-Berechnungen impliziert. </p><br><p>  In der Praxis isoliert die Tatsache, dass der Zustand auf irgendeine Weise zerplatzt ist, die Scherben und erm√∂glicht es ihnen, unabh√§ngige Blockchains zu sein, wie wir oben definiert haben.  Validatoren in Shards speichern nur einen f√ºr ihren Shard spezifischen Status, und nur Transaktionen, die diesen Status betreffen, werden ausgef√ºhrt und weitergeleitet.  Dies reduziert die Belastung des Prozessors, der Festplatte und des Netzwerks linear mit der Anzahl der Shards, bringt jedoch neue Probleme mit sich, wie z. B. Inter-Shard-Transaktionen. </p><br><h2 id="mezhdu-shardovye-tranzakcii">  Inter-Shard-Transaktionen </h2><br><p>  Bisher haben wir Shards als unabh√§ngige Blockchains in Bezug auf die Ausf√ºhrung von Transaktionen gesehen.  Mit diesem Design ist es beispielsweise unm√∂glich, eine Transaktion abzuschlie√üen, bei der Geld zwischen zwei Konten auf zwei verschiedenen Shards √ºbertragen wird, oder einen Kontakt auf einem Shard aus einem Vertrag mit einem anderen herzustellen.  Ich m√∂chte beide Szenarien unterst√ºtzen. </p><br><p>  Der Einfachheit halber betrachten wir nur Transaktionen, die Geld √ºberweisen, und wir gehen davon aus, dass jeder Teilnehmer ein Konto auf genau einem Shard hat.  Wenn ein Teilnehmer auf einem Shard Geld an einen Teilnehmer auf demselben Shard √ºberweisen m√∂chte, k√∂nnen die Validatoren dieses Shards diese Transaktion verarbeiten und auf den Staat anwenden.  Aber wenn Alice zum Beispiel ein Konto auf Shard Nr. 1 hat und sie Geld mit einem Konto auf Shard Nr. 2 an Bob senden m√∂chte, weder Shard-Validatoren Nr. 1 (die Bob kein Geld hinzuf√ºgen k√∂nnen) noch Shard-Validatoren Nr. 2 (die Alice nicht bekommen k√∂nnen) ) kann die Transaktion nicht abschlie√üen und den Status nicht aktualisieren. </p><br><p>  Es gibt zwei gro√üe Gruppen von Ans√§tzen zur L√∂sung dieses Problems: </p><br><ol><li><p>  <strong>Synchron</strong> : Bei jeder Transaktion mit mehreren Shards werden Bl√∂cke in Shards mit Statusaktualisierungen f√ºr diese Transaktion gleichzeitig erstellt, und Validatoren in diesen Shards arbeiten zusammen, um solche Bl√∂cke zu erstellen.  Das aufwendigste Design dieses Ansatzes, das mir bekannt ist, sind Merge Blocks, die hier (auf Englisch) beschrieben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> . </p><br></li><li><p>  <strong>Asynchron</strong> : Eine Inter-Shard-Transaktion wird in Shards ausgef√ºhrt, die davon betroffen sind. Asynchron: Der Teil der Transaktion, der Bob Geld hinzuf√ºgt, wird in Shard 2 ausgef√ºhrt, wenn die Validatoren im Shard Beweise daf√ºr haben, dass der Teil der Transaktion, der Geld von Alice abzieht, in ausgef√ºhrt wurde Scherbe # 1.  Dieser Ansatz ist in den heute entwickelten Systemen popul√§rer, da f√ºr die Blockproduktion keine zus√§tzliche Synchronisation zwischen Shards erforderlich ist.  Solche Systeme werden heute in Cosmos, Ethereum Serenity, Near Protocol, Kadena und anderen angeboten.  Das Problem bei diesem Ansatz besteht darin, dass, wenn die Bl√∂cke unabh√§ngig voneinander erstellt werden, wahrscheinlich einer der Bl√∂cke, die die Statusaktualisierung f√ºr die Transaktion enthalten, nicht in der kanonischen Kette in ihrem Shard enthalten ist und die Transaktion daher nur teilweise abgeschlossen wird.  Betrachten Sie zum Beispiel die folgende Abbildung.  Es zeigt zwei Shards, in denen die Gabeln aufgetreten sind, und eine Inter-Shard-Transaktion, deren Statusaktualisierung sich in den Bl√∂cken A bzw. X 'widerspiegelt.  Wenn sich herausstellt, dass die Ketten AB und V'-X'-Y'-Z 'in ihren Scherben kanonisch sind, ist die Transaktion vollst√§ndig abgeschlossen.  Wenn die Ketten A'-B'-C'-D 'und VX kanonisch sind, wird die Transaktion vollst√§ndig abgebrochen, was akzeptabel ist.  Wenn beispielsweise AB und VX kanonisch werden, wird ein Teil der Transaktion abgeschlossen, der andere abgebrochen und die Transaktion teilweise abgeschlossen. </p><br></li></ol><br><p><img src="https://habrastorage.org/getpro/habr/post_images/640/162/e6c/640162e6c138290296c5186fab24e5d1.png" alt="Bild"></p><br><p>  Das oben beschriebene Szenario ist eines der gro√üen Probleme beim Sharding, bei dem nicht alle vorgeschlagenen L√∂sungen optimal sind.  Wir werden es weiter unten ansprechen. </p><br><h2 id="plohoe-povedenie">  Schlechtes Benehmen </h2><br><p>  Nachdem wir herausgefunden haben, wie Shard-Blockchains funktionieren, und die Konzepte der zentralen Blockchain, die Ernennung von Validatoren und Cross-Shard-Transaktionen untersucht haben, werden wir uns am Ende dieses Artikels mit einem weiteren interessanten Thema befassen: Was kann ein Teilnehmer, der versucht, das System anzugreifen, tun, wenn er es schafft? Kontrolle √ºber eine ausreichend gro√üe Anzahl von Validatoren in einem Shard. </p><br><h3 id="celenapravlennye-forki">  Gezielte Gabeln </h3><br><p>  Wenn der Teilnehmer gen√ºgend Kontrolle √ºber die Scherbe hat, kann er gezielt Gabeln erstellen.  Bei der Erstellung von Gabeln spielt es keine Rolle, welcher Konsens in Shards verwendet wird. Insbesondere spielt es keine Rolle, ob es sich um BFT handelt oder nicht. Wenn eine ausreichende Anzahl von Validatoren unter der Kontrolle eines Angreifers steht, kann eine Gabel erstellt werden.  Das Ziel der Abzweigung k√∂nnte beispielsweise darin bestehen, eine Transaktion zur√ºckzusetzen, die f√ºr etwas au√üerhalb der Blockchain bezahlt hat. </p><br><p>  Es wird behauptet, dass es einfacher ist, die Kontrolle √ºber 50% des Shards zu erlangen als √ºber 50% des gesamten Netzwerks (zum Beispiel, weil ein Teilnehmer versuchen kann, Validatoren zu hacken oder zu bestechen, nachdem sie dem Shard zugewiesen wurden).  Per Definition √§ndern Inter-Shard-Transaktionen den Status in mehreren Shards.  Solche √Ñnderungen fallen in einige Bl√∂cke in den Blockketten der entsprechenden Shards.  Es ist notwendig, dass entweder alle derartigen Bl√∂cke finalisiert werden (d. H. Zur kanonischen Kette in ihren jeweiligen Scherben geh√∂rten) oder dass nicht alle finalisiert werden sollten (d. H. Nicht zur kanonischen Kette in ihren Scherben geh√∂rten).  Da wir davon ausgehen, dass einige Teilnehmer mit schlechten Absichten im Prinzip die Kontrolle √ºber den Shard erlangen k√∂nnen, k√∂nnen wir nicht davon ausgehen, dass Gabeln nicht auftreten, selbst wenn ein byzantinischer Konsens erreicht wurde oder eine gro√üe Anzahl von Bl√∂cken auf einem Block mit einer Transaktion aufgebaut wurde. </p><br><p>  Dieses Problem hat viele L√∂sungen, von denen die einfachste manchmal darin besteht, den Hash des letzten Blocks im Shard in der zentralen Blockchain zu speichern.  Der kanonische Kettenauswahlalgorithmus in Shards wird dann so ge√§ndert, dass kein Ziel den letzten Block enth√§lt, der in der zentralen kanonischen Blockchain gespeichert ist.  Um Situationen vollst√§ndig zu vermeiden, in denen eine Transaktion teilweise abgeschlossen ist, weil sich einige der Bl√∂cke, die ihre Statusaktualisierung enthalten, au√üerhalb der kanonischen Ketten befinden, k√∂nnen Sie den Algorithmus zum Ausf√ºhren von Inter-Shard-Transaktionen so √§ndern, dass Shard A den Beweis der Transaktion in Shard B erst im Block akzeptiert Das Status-Update f√ºr die Transaktion in Shard B wurde nicht in der zentralen Blockchain gespeichert. </p><br><h3 id="sozdanie-nevalidnyh-blokov">  Ung√ºltige Bl√∂cke erstellen </h3><br><p>  Wenn der Teilnehmer die Kontrolle √ºber eine ausreichend gro√üe Anzahl von Validatoren im Shard erlangen konnte, kann er versuchen, einen vollst√§ndig ung√ºltigen Block zu erstellen.  Angenommen, der Status vor dem Block war so, dass Alice 10 Token hatte, und in Bob - 0 enth√§lt der Block nur eine Transaktion, die 10 Token von Alices Konto an Bobs Konto sendet, im neuen Status jedoch 0 Token von Alice und 1000 mit Bob. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e68/edd/049/e68edd049344263dd671209a10be0890.png" alt="Bild"></p><br><p>  In einer klassischen, nicht gesplitteten Blockchain ist das Erstellen eines solchen Blocks unm√∂glich, da alle Teilnehmer, wie diejenigen, die Bl√∂cke erstellen, und diejenigen, die einfach die Blockchain verwenden, alle Bl√∂cke √ºberpr√ºfen und jeden Block, der solche Fehler enth√§lt, sofort verwerfen.  Selbst wenn die vom Angreifer kontrollierten Validatoren die Kette schneller erstellen k√∂nnen, k√∂nnen sie die l√§ngere Kette mit dem ung√ºltigen Block nicht als kanonische √ºbergeben, da alle Netzwerkteilnehmer den ung√ºltigen Block und alle darauf erstellten Bl√∂cke sofort verwerfen.  Ehrliche Validatoren bauen weiterhin auf dem letzten g√ºltigen Block auf, und alle Netzwerkteilnehmer sehen ihre Kette als kanonisch an. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1c5/0a8/b45/1c50a8b45dfda77a14262225dc3351ca.png" alt="Bild"></p><br><p>  Die obige Abbildung zeigt f√ºnf Validatoren, von denen drei unter der Kontrolle des Angreifers stehen.  Sie erstellten den ung√ºltigen Block A 'und bauten dann die Kette weiter auf.  Zwei private Pr√ºfer verwarfen Block A 'sofort als ung√ºltig und bauten weiter auf dem letzten g√ºltigen Block auf, den sie kannten, wodurch eine Gabelung erstellt wurde.  Da es in einer ehrlichen Kette weniger Validatoren gibt als in einer unehrlichen, ist ihre Kette k√ºrzer.  In der klassischen Blockchain ohne Hardware validieren jedoch alle Teilnehmer des Systems alle Bl√∂cke, die sie sehen.  Somit sieht jeder Teilnehmer, der die Blockchain verwendet, dass A 'ung√ºltig ist, verwirft es und verwirft daher B', C 'und D' als auf dem ung√ºltigen Block aufgebaut, und somit sehen alle Teilnehmer AB als eine kanonische Kette. </p><br><p>  In einem Shard-Design kann kein Teilnehmer alle Bl√∂cke in allen Blockchains validieren.  Daher ben√∂tigen wir einen Mechanismus, mit dem Validatoren in einem bestimmten Shard sicherstellen k√∂nnen, dass zu keinem Zeitpunkt in der Vergangenheit ein ung√ºltiger Block in einem anderen Shard erstellt wurde, von dem sie eine Inter-Shard-Transaktion erhalten haben. </p><br><p>     ,        ,              .         ,   ,   (      ). </p><br><p>     ,       : </p><br><ol><li>  -           .    ,         2/3       .         ,         ,              ,   .           ,  ,     ,           -           ,   .     ,    . </li><li>  -  ,  ,    ,  ,     , .   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zk-SNARKs</a> (   zk,  zero-knowledge,     ,       non-zk SNARKs).  ,  zk-SNARKs  ,          . </li></ol><br><p>  ,   ,   ,      ,          .     ‚Äî   . </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich schreibe viel √ºber Blockchain und Sharding auf Englisch. </font><font style="vertical-align: inherit;">Wir interviewen auch regelm√§√üig Autoren anderer Protokolle wie Cosmos und Solana und vertiefen uns in technische Details. </font><font style="vertical-align: inherit;">Wenn Sie sich f√ºr das Thema interessieren, k√∂nnen Sie neuen Posts und Videos folgen, indem Sie meinen Twitter </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@AlexSkidanov abonnieren</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437924/">https://habr.com/ru/post/de437924/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437912/index.html">Ein kleines Notizbuch f√ºr einen Systemadministrator</a></li>
<li><a href="../de437914/index.html">Jaxb (XJC) generiert Klassen aus XML-Schema (XSD) mit Klassen- und Feldbeschreibungen als Anmerkungen. XJC-Plugin</a></li>
<li><a href="../de437916/index.html">Geben Sie den E-Book-Reader in jede Tasche! R√ºckblick auf die neuesten Innovationen von ONYX BOOX</a></li>
<li><a href="../de437918/index.html">Videoaufnahme mit automatischem Pausenauswurf durch freie Software mit Fahrradbau</a></li>
<li><a href="../de437922/index.html">Angriffsmodell: Wo es haupts√§chlich in der elektronischen Beschaffung missbraucht wird und wie man damit umgeht</a></li>
<li><a href="../de437926/index.html">Der ma√ügebliche Leitfaden zum Blockchain-Sharding</a></li>
<li><a href="../de437928/index.html">Wie man Englisch lernt</a></li>
<li><a href="../de437930/index.html">Leuchte Combo</a></li>
<li><a href="../de437932/index.html">Intel Optane Memory H10: Optane Cache + QLC 3D NAND</a></li>
<li><a href="../de437934/index.html">Zeitmanagement im wirklichen Leben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>