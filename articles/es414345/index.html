<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßòüèø ‚òÉÔ∏è üÖæÔ∏è Desarrollo inverso del interruptor de tiempo VL-76-S üéí ü§≥üèº üì®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="√ârase una vez el interruptor de tiempo digital electr√≥nico VL-76-S, nuevo, empaquetado pero en mal estado. No se encontraron defectos en las placas de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desarrollo inverso del interruptor de tiempo VL-76-S</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414345/">  √ârase una vez el interruptor de tiempo digital electr√≥nico VL-76-S, nuevo, empaquetado pero en mal estado.  No se encontraron defectos en las placas de circuito impreso en el interior.  Por lo tanto, matrimonio de f√°brica, firmware roto. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cn/vj/2v/cnvj2vs2aonwmvjljydwos0ewqi.jpeg"></div><br>  <i>Vista general del rel√©.</i> <br><a name="habracut"></a><br>  Lo que nos sorprendi√≥ fue el uso del popular y sencillo microcontrolador ATTiny2313.  Externamente, este dise√±o consiste en un maestro en forma de tres d√©cadas de interruptores y un terminal al que se conectan la alimentaci√≥n de 220 V y los contactos de un rel√© EM.  El rango de la tarea es 0.1 ... 99.9 minutos.  en incrementos de 0.1 min  (6 segundos)  No hay circuitos ni firmware en este dise√±o en Internet, lo cual no es sorprendente.  Sin pensarlo dos veces, decid√≠ dibujar el circuito de las placas de circuito impreso y en el futuro escribir el programa en el MK. <br><br>  El dise√±o consta de tres placas de circuito impreso interconectadas.  En la primera placa, se hacen una fuente de alimentaci√≥n y un rel√© TRA3.  La fuente de alimentaci√≥n se realiza de acuerdo con un circuito sin transformador: los condensadores de enfriamiento se utilizan para reducir el voltaje.  En la segunda placa est√° el ATTiny2313 MK y otros elementos auxiliares.  En la tercera placa hay interruptores (puntos de ajuste) y un LED de control. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/be/ew/4h/beew4hzen1salm0a6x7mlwhak2g.jpeg"></div><br>  <i>Foto del tercer tablero desde atr√°s.</i> <br><br>  Comenzar√© la descripci√≥n con el tercer tablero.  Los interruptores son interruptores de 10 posiciones.  No hay marcas en ellos, cada uno de ellos tiene 5 contactos.  Por lo tanto, dependiendo de la posici√≥n, ciertos contactos est√°n cerrados en varias combinaciones.  Invocando contactos, inmediatamente capt√© el patr√≥n: una salida fija (general) se cierra con las otras cuatro salidas (informaci√≥n) de acuerdo con la representaci√≥n binaria del n√∫mero correspondiente al n√∫mero de la posici√≥n seleccionada.  Por ejemplo, si se selecciona la posici√≥n "3", la salida general (quinta consecutiva) se cierra con la salida de la tercera y cuarta, ya que el n√∫mero "3" en representaci√≥n binaria es "0011".  Aqu√≠ hay un cambio tan complicado.  Y hay tres de ellos.  Est√°n conectados a trav√©s de conectores XP1 y XP2 a la segunda placa con MK.  Un conector XP3 conecta un LED y alguna otra basura innecesaria sin soldar, para lo cual hay un lugar en la placa.  Lo m√°s probable es que este sea un interruptor DPDT com√∫n de seis pines (como uno cuadrado, PB22E06, por ejemplo).  Quiz√°s la placa sea universal, pero no se usa en este modelo en particular. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/tv/rq/lotvrq9ovoeetew2zmaa6sauury.jpeg"></div><br>  <i>Foto de la segunda placa (principal).</i> <br><br>  Al llamar a los contactos de los conmutadores, no entend√≠ de inmediato el principio de su conexi√≥n a los puertos MK.  En la placa principal, 8 transistores SMD son inmediatamente evidentes.  M√°s tarde descubri√≥ que estos transistores se usan como pares de diodos con un √°nodo com√∫n.  Sus bases van a los puertos MK, y los colectores y emisores van a cambiar los contactos.  Luego me explicaron que en tales casos hay pares de diodos, suenan como transistores, pero no son transistores.  En total, tenemos 16 conductores que dejan los pares de diodos en la tercera placa.  Tres cuartos de ellos (12 piezas) llegan a los contactos de informaci√≥n de los interruptores (tres a cuatro), y 4 permanecen libres.  Es f√°cil adivinar que, en teor√≠a, se proporcionan para el cuarto interruptor, que de alguna manera no est√° ausente, porque no hay espacio para ello en el tablero.  Sin embargo, para no violar la l√≥gica del razonamiento, mencionar√© este cuarto interruptor imaginario.  Los extremos comunes de los interruptores segundo y tercero, as√≠ como el primero y el cuarto (pero el cuarto no proporciona la placa) est√°n conectados por pares entre s√≠ mediante pistas en la placa principal en los conectores de acoplamiento XS1 y XS2.  Estos dos pares est√°n conectados a las salidas de los grupos de transistores.  Estos dos grupos id√©nticos est√°n formados en los transistores BC857 y BC847 (estructuras diferentes).  Sus entradas est√°n conectadas a la MK.  Al aplicar un "0" l√≥gico a la entrada de este grupo, la salida tambi√©n ser√° un "0" l√≥gico.  Adem√°s, en la placa hay un conector XP2 para firmware MK, conectado a los terminales SPI de la interfaz MK, un conector XS3 para un LED y un conector XP1 conectado por un cable a la primera placa.  Debe recordarse que algunos de los puertos MK pueden usarse tanto para SPI (para firmware) como para entrada-salida ordinaria (funciona en el circuito). <br><br>  Todo lo anterior se refleja en los diagramas que dibuj√© primero en borrador, luego en SPlan.  Las clasificaciones de los elementos de radio que no estaban marcados (por ejemplo, condensadores SMD) est√°n ausentes en los diagramas, no son tan importantes.  Primero, dar√© un diagrama de la placa principal y la placa con los colocadores (firmas de las im√°genes a continuaci√≥n). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4c/r8/gr/4cr8gr6u5edycy869h9wuyprgs0.gif"></div><br>  <i>Esquema del tablero principal.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pg/sx/uy/pgsxuy7cgafwqwabsx39prgwkgw.gif"></div><br><br>  <i>Esquema del tercer tablero con setters</i> <br><br>  Considere c√≥mo el interrogatorio de cada setter.  Las se√±ales de los puertos PB4 y PB5 MK l√≥gica "0" abren los transistores VT2 y VT1, seguidos de VT4 y VT3, que se conectan a los contactos comunes del bus cero de los interruptores No. 1 y No. 2-No. 3, respectivamente.  Esto sucede a su vez.  Primero, el "0" l√≥gico proviene de PB4 (PB5 hasta ahora se ha establecido en "1" l√≥gico), conectando el segundo y el tercer conmutador.  En este estado, los valores de las se√±ales son grabados a su vez por el controlador desde los puertos de entrada PB3, PB2, PB1, PB0 a trav√©s de los grupos de diodos 2VD1 ... 2VD4 desde el segundo y cuatro interruptores faltantes.  Inmediatamente, los valores de las se√±ales de los pines PD6, PD5, PD4, PD3 MK son fijos, a los cuales las se√±ales del primer y tercer conmutadores llegan a trav√©s de los grupos de diodos 2VD5 ... 2VD8.  Pero, dado que solo el segundo y el tercer conmutadores est√°n conectados por un contacto com√∫n, las se√±ales del segundo conmutador llegar√°n a los primeros puertos especificados del MK, y el cuarto ser√° ignorado.  Del mismo modo, las se√±ales del tercer interruptor llegar√°n a la segunda mitad del MK, y el primero ser√° ignorado.  En esta etapa, el controlador sabe en qu√© posiciones est√°n instalados los interruptores segundo y tercero.  Despu√©s de eso, PB4 se establece en "unidad", apagando los interruptores segundo y tercero, y PB5 se establece en "cero".  En este caso, el primer interruptor y el cuarto que faltan est√°n conectados por un extremo com√∫n al "caso".  Su interrogaci√≥n ocurre exactamente igual que en el caso anterior, pero ahora se registrar√°n las se√±ales de esos interruptores que se ignoraron la √∫ltima vez.  Por lo tanto, el controlador conoce la informaci√≥n de posici√≥n de todos los interruptores.  Este proceso es similar a sondear un teclado matricial, pero en este caso una matriz de 4 capas con dimensiones de 2 por 2 con un elemento faltante. <br><br>  Resistencias R8 ... R15 - pull-ups.  Aunque, fue posible "parar" en el MK en s√≠.  Frecuencia de reloj precisa MK proporciona cuarzo a 10 MHz.  R1 y C4 - Circuito de reinicio MK.  No hay nada m√°s interesante en este foro. <br><br><img src="https://habrastorage.org/webt/5u/u-/8s/5uu-8sh8ffhwe3qcxqs6gzppcqa.jpeg"><br>  <i>Foto de la primera placa (de potencia) desde el lado de los elementos.</i> <br><br><img src="https://habrastorage.org/webt/oe/ln/3-/oeln3-vbwunn8pr0ku2gcwloywm.jpeg"><br>  <i>Foto de la primera placa (alimentaci√≥n) desde la parte posterior.</i> <br><br>  Pasemos al esquema del primer tablero (Fig. Arriba).  El esquema parec√≠a muy interesante y en algunos lugares incomprensible. <br><br><img src="https://habrastorage.org/webt/ku/br/ys/kubrysrquhsy3n1xfwmeuvnh8qw.gif"><br>  <i>Esquema de la primera placa (potencia).</i> <br><br>  C1C2 - para reducir el voltaje.  R1 - para descargar lo anterior.  Despu√©s del puente de diodos DB1 hay dos electrolitos.  Para complicar el circuito (o por confiabilidad) - esquema de estabilizaci√≥n en cascada VT3R6VD3 - VT7R12VD5.  VD5 es similar a un transistor SMD de emisor no utilizado.  Esto proporciona un voltaje de CC estabilizado de 12V.  El siguiente es el regulador lineal VR1 a 5V.  Al mismo tiempo, el voltaje se elimina del puente de diodos DB1 a trav√©s del diodo VD2 a otro estabilizador VT1R3VD1 de 24V.  Este voltaje se suministra a la bobina del rel√© EM Rel1 y a R17.  Lo √∫ltimo no est√° claro por qu√©.  En el otro extremo de R17 viene la se√±al del grupo de transistores VT9VT10.  El circuito de este grupo es similar al circuito de la placa principal.  Una se√±al de un puerto MK PB6 separado llega a la entrada de este grupo de transistores a trav√©s del conector.  ¬øPor qu√© es necesario?  ¬øPor qu√© conectar una resistencia R17 a 24V?  Lo m√°s probable es que haya una idea de que, en lugar de una resistencia, puede colocar algo m√°s, por ejemplo, un LED de control interno, programando el puerto PB6 MK de cierta manera.  O un nodo de conmutaci√≥n adicional.  Pero, de todos modos, esto no tiene sentido, como dicen mis conocidos ingenieros de radio, despu√©s de haber mirado la placa de dise√±o.  El segundo extremo del rel√© EM Rel1 est√° conectado a un grupo de transistores similar VT2VT5, y est√° conectado al puerto MK PD0.  La se√±al "0" de este puerto activa el rel√© EM en ejecuci√≥n.  Lo m√°s interesante es que el LED externo est√° conectado no paralelo al rel√© EM, sino a la brecha del emisor del transistor VT2, adem√°s, a trav√©s de dos conectores (que pasan por la placa principal).  En el terminal, los n√∫meros de pin 1 y 2, a juzgar por la etiqueta en el rel√©, permanecen vac√≠os.  Pero en el circuito, el contacto No. 2 est√° conectado a un cable com√∫n, y el contacto No. 1 se alimenta a la entrada del grupo de transistores VT6VT8.  La salida de este grupo se env√≠a al puerto PD2 MK.  M√°s tarde, le√≠ en la especificaci√≥n para este modelo de rel√© que estos contactos se utilizan para controlar otros modelos de rel√©, ensamblados en el mismo caso.  El modelo que estoy considerando no implica control, pero se puede implementar al escribir un programa en MK, ya que el esquema brinda esta oportunidad.  Bajo el control puede significar un inicio, reinicio (tanto en "disparador" como en modo normal) y todo lo que se le ocurra.  Las especificaciones para otros rel√©s muestran diagramas de temporizaci√≥n que muestran el comportamiento de los rel√©s dependiendo de una se√±al de control dada.  Tambi√©n dice a continuaci√≥n: a petici√≥n del cliente, podemos implementar cualquier diagrama posible.  Y el √∫ltimo momento en el esquema.  Esta se√±al de control del terminal No. 1 tambi√©n llega al in√∫til transistor VT4, alimentado por un voltaje de 12V.  Esto, nuevamente, es una complicaci√≥n del esquema.  ¬øO tal vez todav√≠a hay alguna idea establecida?  No profundic√© profundamente.  Estar√© encantado de cualquier comentario. <br><br>  Las marcas de los terminales de los conectores se firman a trav√©s del punto despu√©s del nombre del conector en s√≠.  Los n√∫meros romanos despu√©s del s√≠mbolo "~" indican conclusiones in√∫tiles y faltantes.  Los √∫ltimos no son pocos en el esquema, pero no me detendr√© en ellos.  A continuaci√≥n les doy bocetos de cada placa con las designaciones de conectores, conclusiones y elementos b√°sicos. <br><br><img src="https://habrastorage.org/webt/9g/nt/94/9gnt940dbha1c-50htijfyd3erq.gif"><br>  <i>Bocetos de tablero.</i> <br><br>  Considere la descripci√≥n del c√≥digo fuente para el programa MK.  El programa en s√≠ es simple y lo escrib√≠ en CVAVR durante 20 minutos.  Discutir√© el algoritmo por el cual se ejecutar√° el programa.  Esta informaci√≥n puede parecer bastante banal para algunos, pero no ser√° superflua para los principiantes.  En mi versi√≥n del algoritmo, los temporizadores en el rel√© de tiempo ser√°n interrogados no una vez, sino continuamente.  Adem√°s, el sondeo continuar√° incluso despu√©s de que se haya disparado el rel√©.  Esto le permitir√° hacer ajustes sobre la marcha.  Quiz√°s este algoritmo no coincida con el algoritmo original para el funcionamiento de este rel√©, pero no estoy familiarizado con el algoritmo original.  Es en el ejemplo del algoritmo mencionado anteriormente que se considerar√° la descripci√≥n del programa. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo fuente para el programa C con descripci√≥n.</b> <div class="spoiler_text">  Conectamos la biblioteca para trabajar con el ATTiny2313 MK, as√≠ como la biblioteca de funciones de retraso. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;tiny2313.h&gt; #include &lt;delay.h&gt;</span></span></span></span></code> </pre> <br>  A continuaci√≥n, hacemos la macro sustituci√≥n necesaria, de acuerdo con las asignaciones de circuito de los puertos MK.  Estas sustituciones son convenientes porque en el texto del programa en lugar de, por ejemplo, PORTB.5, puede escribir getAD, que es m√°s conveniente.  La compilaci√≥n getAD se interpretar√° como PORTB.5.  Entonces, la primera sustituci√≥n son las salidas para conectar el primer (A) y el cuarto (D) conmutadores de punto de ajuste.  El segundo es para el segundo (B) y el tercero (C).  Lo siguiente es la sustituci√≥n para habilitar el rel√©.  Y, finalmente, la sustituci√≥n "Ctrl" que no se utiliza en el programa y en el modelo en consideraci√≥n.  No puedes escribirlo. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> getAD PORTB.5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> getBC PORTB.4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RL PORTD.0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Ctrl PIND.2</span></span></code> </pre><br>  Las variables A, B, C se utilizan para almacenar el n√∫mero de posici√≥n de los tres interruptores correspondientes y tomar valores de 0 a 9. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> A,B,C;</code> </pre><br>  Variable i: el valor actual del n√∫mero de d√©cimas de minuto (6 segundos), es decir, el n√∫mero del "tic" m√≠nimo del rel√©.  La variable t es el n√∫mero de d√©cimas de minuto (ticks) recibidas del maestro. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>,t;</code> </pre><br>  La funci√≥n principal del programa se presenta a continuaci√≥n.  En las primeras 6 l√≠neas no entend√≠.  Se forman utilizando la utilidad auxiliar CodeWizadAVR y est√°n asociados con la presencia de cuarzo externo a 10 MHz. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> optsize- CLKPR=0x80; CLKPR=0x00; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _OPTIMIZE_SIZE_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> optsize+ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  Las siguientes dos l√≠neas configuran el puerto B de nuestro MK.  Seg√∫n el esquema, colocamos los 4 bits m√°s bajos en la entrada y los m√°s significativos en la salida (PB7 no se usa y PB6 es in√∫til, pero, en teor√≠a, la salida).  Por lo tanto, de acuerdo con los principios de configuraci√≥n de MK, que no describir√©, escribimos el n√∫mero 240 en el registro DDRB (F0 en notaci√≥n hexadecimal).  El nivel de salida inicial es "1", excepto el PB7 innecesario.  Y por si acaso, conectemos las "resistencias pull-up" de MK a las entradas, aunque ya est√©n instaladas en el circuito.  Para hacer esto, configuremos el registro PORTB en 7F en notaci√≥n hexadecimal. <br><br><pre> <code class="cpp hljs">PORTB=<span class="hljs-number"><span class="hljs-number">0x7F</span></span>; DDRB=<span class="hljs-number"><span class="hljs-number">0xF0</span></span>;</code> </pre><br>  El puerto D se configura de la misma manera: todos los pines en la entrada, excepto los dos inferiores.  Las "resistencias pull-up" en la entrada y el nivel de salida inicial "1" en la salida son similares. <br><br><pre> <code class="cpp hljs">PORTD=<span class="hljs-number"><span class="hljs-number">0x7D</span></span>; DDRD=<span class="hljs-number"><span class="hljs-number">0x03</span></span>;</code> </pre><br>  Las siguientes cinco l√≠neas se relacionan con la configuraci√≥n de uno de los temporizadores MK.  Este temporizador tiene diecis√©is d√≠gitos, es decir, proporciona una puntuaci√≥n de hasta 2 ^ 16 = 65536.  La frecuencia de conteo est√° determinada por la frecuencia del reloj MK y el coeficiente de divisi√≥n (uno de los cinco predefinidos).  En el programa descrito, se decidi√≥ mantener una cuenta durante 6 segundos (el paso m√≠nimo de la tarea), luego aumentar la variable i en 1 y restablecer el temporizador al comienzo del conteo.  Para garantizar lo anterior, debe tomar la relaci√≥n de divisi√≥n m√°xima de 1024 y contar hasta 58594. Esta √∫ltima es f√°cil de calcular.  Frecuencia MK - 10,000,000 Hz.  Usando una relaci√≥n de divisi√≥n de 1024, la frecuencia del temporizador ser√° de 10,000,000 / 1,024 = 9,765.625 Hz, y el per√≠odo ser√° de 1,024,000 / 10,000,000 = 0.0001024 s.  En 6 segundos, se apilar√°n 6 / 0.0001024 = 58593.75 de dichos per√≠odos.  Este n√∫mero se encuentra dentro del temporizador de 16 bits, pero no es un entero, por lo que debe redondear a 58594. En este caso, el error de nuestro rel√© de tiempo ser√° insignificante: 58594-58593.75 = 0.25;  0.25 * 0.0001024 = 0.0000256;  0.0000256 * 999 = 0.0255744.  Es decir, durante el per√≠odo de tiempo m√°ximo posible (99,9 minutos), la inexactitud de este rel√© de tiempo ser√° de aproximadamente 25,6 milisegundos, lo cual es bastante aceptable en la pr√°ctica.  Por cierto, el fabricante tambi√©n estipula el error del dispositivo, y nuestro error no ser√° peor.  En el registro de configuraci√≥n del temporizador TCCR1B, escriba el valor 5. Sin entrar en detalles, esto significa que se inicia el temporizador y el coeficiente de divisi√≥n es 1024. En el registro TCNT1, escribimos el valor 0. Este registro es de 16 bits y se divide en dos mitades de 8 bits: la m√°s joven (L ) y senior (H).  El valor se escribe en √©l, desde donde el temporizador seguir√° contando.  Necesitamos contar desde cero.  El valor OCR1A registra antes de que el temporizador leer√°, despu√©s de lo cual llamar√° a la funci√≥n de interrupci√≥n.  En este momento, se interrumpe la funci√≥n principal del programa y se realizan las acciones especificadas en la funci√≥n de esta interrupci√≥n.  Despu√©s de practicar la interrupci√≥n, la funci√≥n principal continuar√° ejecut√°ndose.  Este valor, como se dijo anteriormente, es igual a 58594 (E4E2 en notaci√≥n hexadecimal).  Dado que el registro OCR1A tambi√©n se divide en dos mitades, escribimos el valor anterior en partes. <br><br><pre> <code class="cpp hljs">TCCR1B=<span class="hljs-number"><span class="hljs-number">0x05</span></span>; TCNT1H=<span class="hljs-number"><span class="hljs-number">0x00</span></span>; TCNT1L=<span class="hljs-number"><span class="hljs-number">0x00</span></span>; OCR1AH=<span class="hljs-number"><span class="hljs-number">0xE4</span></span>; OCR1AL=<span class="hljs-number"><span class="hljs-number">0xE2</span></span>;</code> </pre><br>  Las siguientes dos l√≠neas configuran la resoluci√≥n de las interrupciones correctamente (no entre en detalles). <br><br><pre> <code class="cpp hljs">TIMSK=<span class="hljs-number"><span class="hljs-number">0x40</span></span>; <span class="hljs-meta"><span class="hljs-meta">#asm(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sei"</span></span></span><span class="hljs-meta">)</span></span></code> </pre><br>  En el ciclo principal, los interruptores de configuraci√≥n se sondean constantemente (de acuerdo con el algoritmo en la descripci√≥n del circuito) utilizando 30 ms de retraso para un funcionamiento correcto y estable.  Al establecer el valor "0" en PORTB.5 (getAD = 0), preparamos el primer interruptor.  Sus conclusiones est√°n conectadas al puerto D del MK a los pines 6, 5, 4, 3. La direcci√≥n es de la m√°s joven a la m√°s antigua.  Es decir, el bit de orden inferior del conmutador est√° conectado al bit de orden relativamente bajo (bit 3) del puerto MK.  Por lo tanto, para recibir informaci√≥n del puerto D del MK en la posici√≥n del primer conmutador, es necesario hacer un desplazamiento bit a la derecha en tres posiciones (PIND &gt;&gt; 3), invertir los bits recibidos con la operaci√≥n "~" (ya que la informaci√≥n vendr√° en "0", seg√∫n el esquema) y restablezca los cuatro bits altos innecesarios del valor de 8 bits recibido.  La √∫ltima operaci√≥n se realiza mediante la multiplicaci√≥n l√≥gica en bits del resultado por el n√∫mero 15 (00001111 en representaci√≥n binaria).  Despu√©s de esta operaci√≥n, a la variable A se le asignar√° el valor de posici√≥n del primer interruptor.  A continuaci√≥n, se apaga el primer interruptor y se preparan el segundo y el tercero.  El valor del segundo conmutador a la variable B se toma del puerto B del MK de manera similar, pero sin una operaci√≥n de cambio, ya que los terminales de este conmutador est√°n conectados a los pines m√°s bajos del puerto B del MK y tambi√©n en forma co-direccional.  La informaci√≥n del tercer cambio a la variable C se elimina de la misma manera que la primera.  Despu√©s de eso, los interruptores segundo y tercero (getBC = 1) est√°n "cerrados" y el valor establecido (el n√∫mero de d√©cimas de minuto) de los tres interruptores se calcula en la variable t. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>){ delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); getAD=<span class="hljs-number"><span class="hljs-number">0</span></span>; delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); A=(~(PIND&gt;&gt;<span class="hljs-number"><span class="hljs-number">3</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">15</span></span>); delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); getAD=<span class="hljs-number"><span class="hljs-number">1</span></span>; getBC=<span class="hljs-number"><span class="hljs-number">0</span></span>; delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); B=(~PINB)&amp;<span class="hljs-number"><span class="hljs-number">15</span></span>; C=(~(PIND&gt;&gt;<span class="hljs-number"><span class="hljs-number">3</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">15</span></span>); delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); getBC=<span class="hljs-number"><span class="hljs-number">1</span></span>; t=<span class="hljs-number"><span class="hljs-number">100</span></span>*A+<span class="hljs-number"><span class="hljs-number">10</span></span>*B+C; } }</code> </pre><br>  La comparaci√≥n de esta variable y una variable similar en tiempo real ocurre en la funci√≥n de interrupci√≥n. <br><br><pre> <code class="cpp hljs">interrupt [TIM1_COMPA] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timer1_compa_isr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ i+=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i&gt;=t){ RL=<span class="hljs-number"><span class="hljs-number">0</span></span>; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ RL=<span class="hljs-number"><span class="hljs-number">1</span></span>; } TCNT1H=<span class="hljs-number"><span class="hljs-number">0x00</span></span>; TCNT1L=<span class="hljs-number"><span class="hljs-number">0x00</span></span>; }</code> </pre><br>  Si la √∫ltima variable excede el valor establecido, el "rel√© de ejecuci√≥n" (RL = 0) se encender√° en "0".  Adem√°s, se apagar√° si, al mismo tiempo, los interruptores se configuran en un valor mayor que el que se ejecut√≥ en la variable i.  En la misma funci√≥n de interrupci√≥n, la variable i aumenta en 1 y el temporizador se restablece a 0. <br><br>  Los bits de FUSIBLE se cancelaron de MK y se dejaron sin cambios.  Los analic√©, todo est√° bien all√≠. <br><br><img src="https://habrastorage.org/webt/zv/dt/ll/zvdtllilqlufxumtsv98xelmwnc.png"><br><br><br></div></div><br>  Por lo tanto, no solo se copi√≥ el diagrama del dispositivo, sino que tambi√©n se desarroll√≥ un programa MK, que no difiere en funcionalidad del propietario.  Adem√°s, a nivel de software se hizo posible cambiar de manera bastante flexible (y, lo m√°s importante, libre) los par√°metros de tiempo del dispositivo y usar la salida de control (No. 1 en el terminal) en varias funcionalidades.  El programa es tan simple que puede (incluso mejor) escribirse en ensamblador, pero a√∫n no lo estoy haciendo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es414345/">https://habr.com/ru/post/es414345/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es414335/index.html">Antecedentes Roskomnadzor, ¬øqu√© eres?</a></li>
<li><a href="../es414337/index.html">Pensamiento de estilo Ramda: inmutabilidad y objetos</a></li>
<li><a href="../es414339/index.html">Gran recorrido fotogr√°fico por el nuevo sitio de coworking de Mosc√∫ #tceh</a></li>
<li><a href="../es414341/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 256 (del 3 al 12 de junio)</a></li>
<li><a href="../es414343/index.html">Traducci√≥n Autom√°tica Neural de Google</a></li>
<li><a href="../es414349/index.html">Obtenga estad√≠sticas de costos de MCC: Tinkoff y Rocketbank</a></li>
<li><a href="../es414351/index.html">Instrumentos musicales m√°s inusuales: Hammond Organ, Vako Orchestron y Synclavier</a></li>
<li><a href="../es414353/index.html">Kivy De la creaci√≥n a la producci√≥n es un paso. Parte 2</a></li>
<li><a href="../es414355/index.html">Vida despu√©s de la explosi√≥n</a></li>
<li><a href="../es414357/index.html">Utilizamos la API web de Bluetooth para conectar el monitor de frecuencia card√≠aca y desarrollar la aplicaci√≥n usando Vue.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>