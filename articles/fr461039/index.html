<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ® ğŸ”— ğŸ‘¨ğŸ½â€ğŸ“ Le livre Â«Algorithme parfait. Algorithmes graphiques et structures de donnÃ©es " ğŸ¥‡ ğŸ•ï¸ ğŸ‡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, habrozhiteli! Les algorithmes sont le cÅ“ur et l'Ã¢me de l'informatique. Vous ne pouvez pas vous en passer, ils sont partout - du routage rÃ©seau ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le livre Â«Algorithme parfait. Algorithmes graphiques et structures de donnÃ©es "</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/461039/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/e5/2z/76/e52z769bpr1nib4vz_bij_xvkgo.jpeg" align="left" alt="image"></a>  Salut, habrozhiteli!  Les algorithmes sont le cÅ“ur et l'Ã¢me de l'informatique.  Vous ne pouvez pas vous en passer, ils sont partout - du routage rÃ©seau et des calculs gÃ©nomiques Ã  la cryptographie et Ã  l'apprentissage automatique.  L 'Â«algorithme parfaitÂ» fera de vous un vÃ©ritable pro qui dÃ©finira les tÃ¢ches et les rÃ©soudra magistralement Ã  la fois dans la vie et lors d'un entretien lors de l'embauche d'une entreprise informatique. <br><br>  Dans le deuxiÃ¨me livre, Tim Rafgarden, le gourou des algorithmes, parle de la recherche de graphes et de son application, de l'algorithme de recherche de chemin le plus court, et de l'utilisation et de la mise en Å“uvre de certaines structures de donnÃ©es: tas, arbres de recherche, tables de hachage et filtre Bloom. <br><br>  Cet article prÃ©sente un extrait de Bloom Filters: The Basics. <br><a name="habracut"></a><br><h3>  De quoi parle ce livre </h3><br>  La deuxiÃ¨me partie du livre Â«Algorithme parfaitÂ» est un cours d'introduction sur les bases de l'alphabÃ©tisation sur les trois sujets suivants. <br><br>  <b>Recherche graphique et applications</b> .  Les graphiques modÃ©lisent un certain nombre de types de rÃ©seaux diffÃ©rents, notamment la route, la communication, les rÃ©seaux sociaux et les rÃ©seaux de dÃ©pendances entre les tÃ¢ches.  Les graphiques peuvent Ãªtre complexes, mais il existe des primitives incroyablement rapides pour parler de la structure des graphiques.  Nous commencerons par des algorithmes de recherche de graphes linÃ©aires, depuis des applications allant de l'analyse de rÃ©seau Ã  la construction d'une sÃ©quence d'opÃ©rations. <br><br>  <b>Les chemins les plus courts</b> .  Dans le problÃ¨me de chemin le plus court, l'objectif est de calculer le meilleur itinÃ©raire dans le rÃ©seau du point A au point B. Cette tÃ¢che a des applications Ã©videntes, telles que le calcul des itinÃ©raires de trafic, et se produit Ã©galement sous forme dÃ©guisÃ©e dans de nombreuses autres tÃ¢ches universelles.  Nous gÃ©nÃ©raliserons l'un de nos algorithmes de recherche de graphes et arriverons au cÃ©lÃ¨bre algorithme de recherche de chemin le plus court de Dijkstra. <br><br>  <b>Structures de donnÃ©es</b> .  Ce livre fera de vous un utilisateur trÃ¨s instruit de plusieurs structures de donnÃ©es diffÃ©rentes conÃ§ues pour prendre en charge un ensemble Ã©volutif d'objets avec leurs clÃ©s associÃ©es.  L'objectif principal est de dÃ©velopper une intuition sur la structure de donnÃ©es qui convient Ã  votre application.  Des sections supplÃ©mentaires fournissent des instructions pour implÃ©menter ces structures de donnÃ©es Ã  partir de zÃ©ro. <br><br>  Tout d'abord, nous discutons des tas qui peuvent rapidement identifier l'objet stockÃ© avec la plus petite clÃ©, et sont Ã©galement utiles pour le tri, la mise en Å“uvre d'une file d'attente prioritaire et la mise en Å“uvre de l'algorithme presque linÃ©aire-temporel de Dijkstra.  Les arborescences de recherche maintiennent l'ordre complet des clÃ©s sur les objets stockÃ©s et prennent en charge une gamme d'opÃ©rations encore plus large.  Les tables de hachage sont optimisÃ©es pour les opÃ©rations de recherche ultrarapides et sont rÃ©pandues dans les programmes modernes.  Nous examinons Ã©galement le filtre Bloom, un proche parent de la table de hachage, qui utilise moins d'espace en raison d'erreurs alÃ©atoires. <br><br>  Vous pouvez vous familiariser avec le contenu du livre plus en dÃ©tail dans les sections Â«ConclusionsÂ», qui complÃ¨tent chaque chapitre et identifient les points les plus importants.  Les sections du livre, marquÃ©es d'un astÃ©risque, sont les plus avancÃ©es en termes de niveau d'information prÃ©sentÃ©.  Si le livre est conÃ§u pour une familiarisation superficielle avec le sujet, le lecteur peut les ignorer sans perdre l'intÃ©gritÃ© de l'Ã©crit. <br><br>  <b>Sujets traitÃ©s en trois autres parties</b> .  La premiÃ¨re partie du livre Â«Algorithme parfait.  Fundamentals Â»couvre la notation asymptotique (la notation O-large et ses proches parents), les algorithmesÂ« diviser pour mieux rÃ©gner Â»et le thÃ©orÃ¨me de la relation de rÃ©currence principale - la mÃ©thode principale, le tri rapide randomisÃ© et son analyse, ainsi que les algorithmes de sÃ©lection linÃ©aire-temporelle.  La troisiÃ¨me partie traite des algorithmes gourmands (planification, travÃ©es minimales, clustering, codes Huffman) et de la programmation dynamique (problÃ¨me de sac Ã  dos, alignement de sÃ©quence, chemins les plus courts, arbres de recherche optimaux).  La quatriÃ¨me partie est consacrÃ©e Ã  l'exhaustivitÃ© de NP, Ã  ce qu'elle signifie pour un concepteur d'algorithmes et aux stratÃ©gies de rÃ©solution de problÃ¨mes de calcul insolubles, y compris l'analyse heuristique et la recherche locale. <br><br><h3>  12.5.  Filtres Bloom: les bases </h3><br>  Les filtres Bloom sont des parents proches des tables de hachage.  Ils sont trÃ¨s compacts, mais font rÃ©guliÃ¨rement des erreurs.  Cette section dÃ©crit comment les filtres Bloom sont bons et comment ils sont mis en Å“uvre, tandis que la section 12.6 prÃ©sente une courbe de compromis entre la quantitÃ© d'espace utilisÃ© par le filtre et son taux d'erreur. <br><br><h3>  12.5.1.  OpÃ©rations prises en charge </h3><br>  La raison de l'existence de filtres Bloom est essentiellement la mÃªme que celle d'une table de hachage: opÃ©rations d'insertion et de visualisation ultra-rapides, grÃ¢ce auxquelles vous pouvez vous rappeler rapidement ce que vous avez vu et ce qui ne l'a pas Ã©tÃ©.  Pourquoi devrions-nous Ãªtre gÃªnÃ©s par une structure de donnÃ©es diffÃ©rente avec le mÃªme ensemble d'opÃ©rations?  Parce que les filtres Bloom sont prÃ©fÃ©rables aux tables de hachage dans les applications oÃ¹ l'espace vaut son pesant d'or, et une erreur alÃ©atoire n'est pas un obstacle Ã  la transaction. <br><br>  Comme les tables de hachage avec adressage ouvert, les filtres Bloom sont beaucoup plus faciles Ã  implÃ©menter et Ã  imaginer lorsqu'ils ne prennent en charge que les opÃ©rations d'insertion et de visualisation (et sans l'opÃ©ration de suppression).  Nous allons nous concentrer sur ce cas. <br><br><blockquote>  FILTRES BLOOM: OPÃ‰RATIONS SUPPORTÃ‰ES <br><br>  Vue: avec la touche k, retournez Â«ouiÂ» si k a Ã©tÃ© prÃ©cÃ©demment insÃ©rÃ© dans le filtre Bloom, et Â«nonÂ» sinon. <br>  Coller: ajoutez une nouvelle clÃ© k au filtre Bloom. </blockquote><br>  Les filtres Bloom sont trÃ¨s efficaces sur le plan spatial;  gÃ©nÃ©ralement, ils peuvent nÃ©cessiter seulement 8 bits par insert.  C'est assez incroyable, car 8 bits est complÃ¨tement insuffisant pour se souvenir mÃªme d'une clÃ© 32 bits ou d'un pointeur sur un objet!  Pour cette raison, l'opÃ©ration Afficher dans le filtre Bloom renvoie uniquement la rÃ©ponse Â«ouiÂ» / Â«nonÂ», tandis que dans la table de hachage, cette opÃ©ration renvoie un pointeur sur l'objet souhaitÃ© (s'il est trouvÃ©).  C'est pourquoi l'opÃ©ration d'insertion accepte dÃ©sormais uniquement la clÃ© et non le (pointeur vers) l'objet. <br><br>  Contrairement Ã  toutes les autres structures de donnÃ©es que nous avons Ã©tudiÃ©es, les filtres Bloom peuvent Ãªtre erronÃ©s.  Il existe deux types d'erreurs: les faux nÃ©gatifs lorsque l'opÃ©ration View renvoie Â«falseÂ» mÃªme si la clÃ© demandÃ©e a dÃ©jÃ  Ã©tÃ© insÃ©rÃ©e plus tÃ´t, et les fausses dÃ©clarations (ou positives) lorsque l'opÃ©ration View renvoie Â«trueÂ», bien que la clÃ© demandÃ©e n'ait pas encore Ã©tÃ© insÃ©rÃ©e dans le passÃ©. .  Dans la section 12.5.3, nous verrons que les filtres Bloom de base ne souffrent jamais de faux nÃ©gatifs, mais ils peuvent avoir des Â«Ã©lÃ©ments fantÃ´mesÂ» sous la forme de fausses dÃ©clarations.  La section 12.6 montre que la frÃ©quence des fausses dÃ©clarations peut Ãªtre contrÃ´lÃ©e en ajustant de maniÃ¨re appropriÃ©e l'utilisation de l'espace.  Une implÃ©mentation typique d'un filtre Bloom peut avoir un taux d'erreur d'environ 1% ou 0,1%. <br><br>  Les temps d'exÃ©cution des opÃ©rations d'insertion et de visualisation sont aussi rapides que dans la table de hachage.  Et mieux encore, ces opÃ©rations sont garanties d'Ãªtre effectuÃ©es en temps constant, quelle que soit la mise en Å“uvre du filtre Bloom et de l'ensemble de donnÃ©es1.  Cependant, l'implÃ©mentation et l'ensemble de donnÃ©es affectent le taux d'erreur du filtre. <br><br>  Pour rÃ©sumer les avantages et les inconvÃ©nients des filtres Bloom sur les tables de hachage: <br><br><blockquote>  FILTRE BLOOM CONTRE LES TABLES DE HACHAGE <br><br>  1. Avantages: plus efficace spatialement. <br><br>  2. Avantages: opÃ©rations permanentes garanties pour chaque ensemble de donnÃ©es. <br><br>  3. InconvÃ©nients: impossible de stocker des pointeurs sur des objets. <br><br>  4. InconvÃ©nients: suppressions plus complexes par rapport Ã  une table de hachage avec un embrayage. <br><br>  5. InconvÃ©nients: probabilitÃ© non nulle d'une fausse dÃ©claration. </blockquote><br>  La liste des indicateurs pour les filtres Bloom de base est la suivante. <br><br>  Tableau 12.4.  Filtres Bloom de base: opÃ©rations prises en charge et leur temps d'exÃ©cution.  Le signe de la dague (â€ ) indique que l'opÃ©ration de visualisation a une probabilitÃ© contrÃ´lable mais non nulle de fausses dÃ©clarations <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j2/s0/bc/j2s0bcwhevqsy2-scnfyznyywpi.png" alt="image"></div><br>  Les filtres Bloom doivent Ãªtre utilisÃ©s Ã  la place des tables de hachage dans les applications oÃ¹ leurs avantages sont importants et leurs inconvÃ©nients ne sont pas un obstacle Ã  la transaction. <br><br><blockquote>  QUAND UTILISER LE FILTRE BLOOM <br><br>  Si une application nÃ©cessite une recherche rapide avec un ensemble d'objets en Ã©volution dynamique, l'espace vaut son pesant d'or et un petit nombre acceptable de fausses allÃ©gations, alors le filtre Bloom est gÃ©nÃ©ralement la structure de donnÃ©es prÃ©fÃ©rÃ©e. </blockquote><br><h3>  12.5.2.  Les applications </h3><br>  Ensuite, il y a trois utilisations avec des analyses rÃ©pÃ©tÃ©es, oÃ¹ Ã©conomiser de l'espace peut Ãªtre important, et les fausses dÃ©clarations ne sont pas un obstacle Ã  la transaction. <br><br>  Correcteurs orthographiques.  Dans les annÃ©es 1970, les filtres Bloom Ã©taient utilisÃ©s pour implÃ©menter des correcteurs orthographiques - correcteurs orthographiques.  Au stade du prÃ©traitement, chaque mot du dictionnaire est insÃ©rÃ© dans le filtre Bloom.  L'orthographe d'un document se rÃ©sume Ã  une opÃ©ration. Regardez un mot dans un document, en marquant tous les mots pour lesquels cette opÃ©ration renvoie Â«nonÂ». <br><br>  Dans cette annexe, une fausse dÃ©claration correspond Ã  un mot invalide que le correcteur orthographique accepte par inadvertance.  De telles erreurs ne rendaient pas les vÃ©rificateurs orthographiques idÃ©aux.  Cependant, au dÃ©but des annÃ©es 1970, l'espace valait son pesant d'or, donc l'utilisation de filtres Bloom Ã  cette Ã©poque Ã©tait une stratÃ©gie gagnant-gagnant. <br><br>  <b>Mots de passe interdits</b> .  Une ancienne application qui reste valable Ã  ce jour suit les mots de passe interdits - des mots de passe trop courants ou trop faciles Ã  deviner.  Initialement, tous les mots de passe interdits sont insÃ©rÃ©s dans le filtre Bloom;  des mots de passe interdits supplÃ©mentaires peuvent Ãªtre insÃ©rÃ©s ultÃ©rieurement, si nÃ©cessaire.  Lorsqu'un utilisateur essaie de dÃ©finir ou de rÃ©initialiser son mot de passe, le systÃ¨me recherche le mot de passe proposÃ© dans le filtre Bloom.  Si la recherche renvoie Â«ouiÂ», l'utilisateur est invitÃ© Ã  rÃ©essayer avec un mot de passe diffÃ©rent.  Ici, une fausse dÃ©claration est traduite en un mot de passe fort, que le systÃ¨me rejette. <br><br>  Pourvu que le taux d'erreur ne soit pas trop Ã©levÃ©, disons pas plus de 1% ou 0,1%, cela n'a pas beaucoup d'importance.  De temps en temps, certains utilisateurs auront besoin d'une nouvelle tentative pour trouver un mot de passe acceptable pour le systÃ¨me. <br><br>  <b>Routeurs Internet</b> .  Un certain nombre d'applications Ã©tonnantes de filtres Bloom se dÃ©roulent au plus profond d'Internet, oÃ¹ les paquets de donnÃ©es transitent par des routeurs avec une vitesse de streaming.  Il existe de nombreuses raisons pour lesquelles un routeur peut vouloir rappeler rapidement ce qu'il a vu dans le passÃ©.  Par exemple, un routeur peut vouloir trouver l'adresse IP source d'un paquet dans la liste des adresses IP bloquÃ©es, suivre le contenu du cache afin d'Ã©viter les vues de cache parasites ou conserver des statistiques qui aident Ã  identifier une attaque de rÃ©seau par dÃ©ni de service.  Le taux d'arrivÃ©e des paquets nÃ©cessite des vues ultrarapides et la mÃ©moire limitÃ©e du routeur fait de l'espace un pesant d'or.  Ces applications sont directement gÃ©rÃ©es par le filtre Bloom. <br><br><h3>  12.5.3.  ImplÃ©mentation </h3><br>  En regardant Ã  l'intÃ©rieur du filtre Bloom, vous pouvez voir une mise en Å“uvre Ã©lÃ©gante.  La structure de donnÃ©es prend en charge une chaÃ®ne de n bits ou, Ã©galement, un tableau A de longueur n dans lequel chaque Ã©lÃ©ment est 0 ou 1. (Tous les Ã©lÃ©ments sont initialisÃ©s Ã  zÃ©ro.) Cette structure utilise Ã©galement m fonctions de hachage h1, h2, ..., hm , tandis que chacun mappe l'univers U de toutes les clÃ©s possibles Ã  l'ensemble {0, 1, 2, ..., n - 1} de positions dans le tableau.  Le paramÃ¨tre m est proportionnel au nombre de bits utilisÃ©s par le filtre Bloom pour l'insertion et, en rÃ¨gle gÃ©nÃ©rale, est une petite constante (par exemple, 5). <br><br>  Chaque fois qu'une clÃ© est insÃ©rÃ©e dans un filtre Bloom, chacune des m fonctions de hachage dÃ©finit un indicateur, dÃ©finissant le bit correspondant du tableau A sur 1. <br><br><blockquote>  FILTRE BLOOM: INSÃ‰RER (SUR TOUCHE) <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span> to m <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> A[hi(k)] := <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </blockquote><br>  Par exemple, si m = 3 et h1 (k) = 23, h2 (k) = 17 et h3 (k) = 5, l'insertion de k entraÃ®ne la mise Ã  Ã©galitÃ© des 5e, 17e et 23e bits du tableau. 1 (Fig.12.5). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ma/-d/zf/ma-dzftjbgtmytk1uoelbb0q17o.png" alt="image"></div><br>  Dans l'opÃ©ration Afficher, le filtre Bloom recherche l'empreinte digitale qui aurait pu rester sur l'insert k. <br><br><blockquote>  FILTRE BLOOM: VUE (TOUCHE CLÃ‰) <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span> to m <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> A [hi (k)] = <span class="hljs-number"><span class="hljs-number">0</span></span> then <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Â«Â» <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Â«Â»</code> </pre> </blockquote><br>  Nous pouvons maintenant voir pourquoi les filtres Bloom ne peuvent pas souffrir de faux nÃ©gatifs.  Lorsque la clÃ© k est insÃ©rÃ©e, les m bits correspondants sont mis Ã  1. Pendant la durÃ©e de vie du filtre Bloom, les bits peuvent changer leur valeur de 0 Ã  1, mais pas l'inverse.  Ainsi, ces m bits restent 1 pour toujours.  Chaque opÃ©ration View k suivante est garantie de renvoyer la bonne rÃ©ponse oui. <br><br>  Nous pouvons Ã©galement voir comment de fausses dÃ©clarations surviennent.  Supposons que m = 3 et les quatre clÃ©s k1, k2, k3, k4 aient les valeurs de hachage suivantes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m0/uo/7r/m0uo7rbq7ewvpqhhmpvdmx8pfs4.png" alt="image"></div><br>  Supposons que nous insÃ©rions k1, k2, k3 et k4 dans un filtre Bloom (figure 12.6).  Ces trois insertions conduisent Ã  un total de neuf bits mis Ã  1, dont trois bits dans l'empreinte digitale de la clÃ© k1 (5, 17 et 23).  Ã€ ce stade, le filtre Bloom ne peut plus distinguer si la clÃ© k1 a Ã©tÃ© insÃ©rÃ©e ou non.  MÃªme si k1 n'a pas Ã©tÃ© insÃ©rÃ© dans le filtre, la recherche retournera Â«ouiÂ», ce qui est une fausse dÃ©claration. <br><br>  Intuitivement, nous pouvons supposer qu'avec une augmentation de la taille n du filtre Bloom, le nombre de superpositions entre les empreintes digitales de diffÃ©rentes clÃ©s devrait diminuer, ce qui, Ã  son tour, conduit Ã  un plus petit nombre de fausses dÃ©clarations.  Mais l'objectif principal du filtre Bloom est de gagner de l'espace.  Existe-t-il un terrain d'entente oÃ¹ n et la frÃ©quence des fausses dÃ©clarations sont simultanÃ©ment petits?  La rÃ©ponse n'est pas Ã©vidente et nÃ©cessite une analyse mathÃ©matique entreprise dans la section suivante. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gz/ib/_o/gzib_oomyz17bbrtney0kyxiru4.png" alt="image"></div><br><br>  Â»Plus d'informations sur le livre sont disponibles sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le site Web de l'Ã©diteur</a> <br>  Â» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Contenu</a> <br>  Â» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Extrait</a> <br><br>  Pour Khabrozhiteley 20% de rÃ©duction sur le coupon - <b>Algorithmes</b> <br>  Lors du paiement de la version papier du livre, un livre Ã©lectronique est envoyÃ© par e-mail. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr461039/">https://habr.com/ru/post/fr461039/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr461029/index.html">Un lac de donnÃ©es marketing - des tableaux monstrueux aux rapports et visualisations</a></li>
<li><a href="../fr461031/index.html">Nous connectons des cartes en ligne au navigateur sur le smartphone. Partie 1 - Cartes raster standard</a></li>
<li><a href="../fr461033/index.html">D'oÃ¹ vient cette config? [Debian / Ubuntu]</a></li>
<li><a href="../fr461035/index.html">Ã‰pisodes instructifs de la sÃ©rie Silicon Valley (Saison 1)</a></li>
<li><a href="../fr461037/index.html">Et me voici "rÃ©el"</a></li>
<li><a href="../fr461041/index.html">Arrondi ou Ã  angle aigu?</a></li>
<li><a href="../fr461043/index.html">La gestion des conflits en Ã©quipe - un Ã©quilibre ou une nÃ©cessitÃ© vitale?</a></li>
<li><a href="../fr461045/index.html">Obtenez un extrait de Rosreestr via FSIS USRN et python. Partie 1</a></li>
<li><a href="../fr461047/index.html">Ã‰crire ou ne pas Ã©crire. Lettres aux autoritÃ©s lors des Ã©vÃ©nements</a></li>
<li><a href="../fr461049/index.html">ONYX BOOX Faust - Celui qui cherche n'est pas obligÃ© d'errer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>