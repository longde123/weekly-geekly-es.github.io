<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💙 🤲🏿 🦁 Newtype kekuatan besar 🎧 ⚾️ 👨🏻‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Newtype adalah deklarasi tipe data khusus. Sehingga hanya berisi satu konstruktor dan bidang. 



newtype Foo a = Bar a newtype Id = MkId Word  

 Per...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Newtype kekuatan besar</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425405/">  Newtype adalah deklarasi tipe data khusus.  Sehingga hanya berisi satu konstruktor dan bidang. <br><br><pre><code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Foo</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bar</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Id</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span></span></code> </pre> <br><img src="https://habrastorage.org/webt/_5/zw/n9/_5zwn9jwjjngjatmg_y57dwddaq.png"><br><h3>  Pertanyaan Pemula yang Umum </h3><br>  <i>Apa perbedaan dari <b>data</b> tipe data?</i> <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Foo</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bar</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Id</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span></span></code> </pre><br>  <b>Spesifisitas</b> utama dari <b>tipe baru</b> adalah bahwa ia terdiri dari bagian yang sama dengan satu-satunya bidang.  Lebih tepatnya, ini berbeda dari yang asli di tingkat tipe, tetapi memiliki representasi yang sama dalam memori, dan dihitung secara ketat (tidak malas). <br>  Singkatnya - <b>jenis baru</b> lebih efektif karena presentasi mereka. <br><br>  <i>Ya, itu tidak ada artinya bagi saya ... Saya akan menggunakan <b>data</b></i> <br>  Tidak, well, pada akhirnya, Anda selalu dapat mengaktifkan bidang ekstensi <b>-funpack-strict-</b> :) untuk <b>bidang</b> ketat (tidak malas) atau tentukan secara langsung <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Id</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkId</span></span></span><span class="hljs-class"> !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span></span></code> </pre><br>  Namun, kekuatan <b>tipe baru</b> tidak terbatas pada efisiensi komputasi.  Mereka jauh lebih kuat! <a name="habracut"></a><br><br><h2>  3 peran <b>tipe baru</b> </h2><br><img src="https://habrastorage.org/webt/6t/zt/kp/6tztkpdj2y4fosehxg3_ogz-ark.jpeg"><br><br><h3>  Menyembunyikan Implementasi </h3><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Data.Id (<span class="hljs-type"><span class="hljs-type">Id</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Id</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span></span></code> </pre><br>  <b>newtype</b> berbeda dari yang asli, hanya <b>Word secara</b> internal. <br>  Tapi kami menyembunyikan konstruktor <b>MkId di</b> luar modul. <br><br><h3>  Implementasi implementasi </h3><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Id</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Num</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  Meskipun ini tidak dalam standar Haskell2010, dengan memperluas output tipe baru generik, Anda dapat secara otomatis menyimpulkan perilaku <b>tipe baru</b> sama dengan perilaku bidang internal.  Dalam kasus kami, perilaku <b>Eq Id</b> dan <b>Num Id</b> sama dengan <b>Eq Word</b> dan <b>Num Word</b> . <br><br>  Jauh lebih banyak yang bisa dicapai melalui perluasan pemuliaan yang disempurnakan ( <b>DerivingVia</b> ), tetapi lebih banyak tentang itu nanti. <br><br><h3>  Implementasi pilihan </h3><br>  Terlepas dari konstruktornya sendiri, dalam beberapa kasus Anda dapat menggunakan representasi internal Anda. <br><br><h4>  Tantangan </h4><br>  Ada daftar bilangan bulat.  Temukan jumlah maksimum dan total hanya dalam satu pass pada daftar. <br>  Dan jangan gunakan <b>paket</b> <b>foldl</b> and <b>folds</b> . <br><br><h4>  Jawaban khas </h4><br>  Tentu saja, <b>lipat</b> !  :) <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foldr</span></span> :: <span class="hljs-type"><span class="hljs-type">Foldable</span></span> t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; ta -&gt; b <span class="hljs-comment"><span class="hljs-comment">{- -- instance Foldable [] foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b -}</span></span></code> </pre><br>  Dan, fungsi terakhir dijelaskan seperti ini: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">aggregate</span></span> :: [<span class="hljs-type"><span class="hljs-type">Integer</span></span>] -&gt; (<span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Integer</span></span>, <span class="hljs-type"><span class="hljs-type">Integer</span></span>) aggregate = foldr (\el (m, s) -&gt; (<span class="hljs-type"><span class="hljs-type">Just</span></span> el `max` m, el + s)) (<span class="hljs-type"><span class="hljs-type">Nothing</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">{- ghci&gt; aggregate [1, 2, 3, 4] (Just 4, 10) -}</span></span></code> </pre><br>  Jika Anda melihat lebih dekat, Anda dapat melihat operasi serupa di kedua sisi: <b>Hanya el `max` m</b> dan <b>el + s</b> .  Dalam kedua kasus, pemetaan dan operasi biner.  Dan elemen yang kosong adalah <b>Nothing</b> dan <b>0</b> . <br><br>  Ya, ini adalah monoids! <br><br><div class="spoiler">  <b class="spoiler_title">Monoid dan Semigroup lebih terinci</b> <div class="spoiler_text">  Semigroup adalah properti dari operasi biner asosiatif <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">x</span></span> ⋄ (y ⋄ z) == (x ⋄ y) ⋄ z</code> </pre><br>  Monoid adalah properti dari operasi asosiatif (mis., Semigroup) <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">x</span></span> ⋄ (y ⋄ z) == (x ⋄ y) ⋄ z</code> </pre><br>  yang memiliki elemen kosong yang tidak mengubah elemen apa pun di kanan atau di sebelah kiri <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">x</span></span> ⋄ empty == x == empty ⋄ x</code> </pre><br></div></div><br>  <b>Maks</b> dan <b>(+)</b> keduanya asosiatif, keduanya memiliki elemen kosong - <b>Tidak ada</b> dan <b>0</b> . <br><br>  Dan kombinasi pemetaan monoids bersama dengan konvolusi <b>Lipat</b> ! <br><br><div class="spoiler">  <b class="spoiler_title">Lipat lebih detail</b> <div class="spoiler_text">  Ingat definisi lipat: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Foldable</span></span></span><span class="hljs-class"> t </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> foldMap :: (<span class="hljs-type"><span class="hljs-type">Monoid</span></span> m) =&gt; (a -&gt; m) -&gt; ta -&gt; m ...</code> </pre><br></div></div><br>  Mari kita terapkan perilaku lipat ke <b>max</b> dan <b>(+)</b> .  Kami dapat mengatur tidak lebih dari satu implementasi monoid <b>Word</b> .  Saatnya mengambil keuntungan dari penerapan pilihan jenis baru! <br><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span> <span class="hljs-comment"><span class="hljs-comment">-- already in Data.Semigroup &amp; Data.Monoid newtype Sum a = Sum {getSum :: a} deriving (Num, Eq, Ord) instance (Num a, Ord a) =&gt; Semigroup (Sum a) where (&lt;&gt;) = (+) instance (Num a, Ord a) =&gt; Monoid (Sum a) where mempty = Sum 0 newtype Max a = Max {getMax :: a} deriving (Num, Eq, Ord) instance (Num a, Ord a) =&gt; Semigroup (Max a) where (&lt;&gt;) = max</span></span></code> </pre><br>  Perlu untuk membuat komentar. <br><br>  Faktanya adalah bahwa untuk menjadi monoid untuk tipe data <b>Max</b> , kita membutuhkan elemen minimal, yaitu, agar elemen kosong ada.  Jadi, hanya <b>Max a yang</b> terbatas <b>yang</b> bisa menjadi monoid. <br><br><div class="spoiler">  <b class="spoiler_title">Secara teori benar maksimum elemen monoid</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Max</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Max</span></span></span><span class="hljs-class"> a instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Semigroup</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Max</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bounded</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monoid</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Max</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)</span></span></code> </pre><br></div></div><br>  Jadi entah bagaimana kita harus mengubah tipe data kita sehingga elemen kosong muncul dan kita dapat menggunakan koagulasi. <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- already in Prelude data Maybe a = Nothing | Just a instance Semigroup a =&gt; Semigroup (Maybe a) where Nothing &lt;&gt; b = b b &lt;&gt; Nothing = b (Just a) &lt;&gt; (Just b) = Just (a &lt;&gt; b) instance Semigroup a =&gt; Monoid (Maybe a) where mempty = Nothing -- ------ instance Functor Maybe where fmap _ Nothing = Nothing fmap f (Just b) = Just (fb)</span></span></code> </pre><br>  Unsur konjugat <b>Mungkin</b> mengubah semi-grup menjadi monoid! <br><br><div class="spoiler">  <b class="spoiler_title">Liberalisasi pembatasan dalam versi terbaru GHC</b> <div class="spoiler_text">  Kembali di GHC 8.2, diperlukan batasan tipe monoid <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monoid</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monoid</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  yang berarti kami membutuhkan jenis baru lainnya: <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- already in Data.Semigroup &amp; Data.Monoid newtype Option a = Option {getOption :: Maybe a} deriving (Eq, Ord, Semigroup) instance (Ord a, Semigroup a) =&gt; Monoid (Option a) where mempty = Option Nothing</span></span></code> </pre><br>  Dan itu sudah jauh lebih sederhana di GHC 8.4, di mana hanya diperlukan semigroup dalam pembatasan jenis, dan bahkan tidak perlu membuat jenis Opsi. <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Semigroup</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monoid</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)</span></span></code> </pre><br></div></div><br><h4>  Respon Lipat </h4><br>  Nah, sekarang perbarui kode menggunakan collapsibility dan panah. <br>  Kami ingat bahwa (.) Hanya komposisi fungsional: <br><br><pre> <code class="haskell hljs"> (.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c f . g = \x -&gt; f (gx)</code> </pre> <br>  Dan ingat bahwa <b>fmap</b> adalah functor: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fmap</span></span> :: <span class="hljs-type"><span class="hljs-type">Functor</span></span> f =&gt; (a -&gt; b) -&gt; fa -&gt; fb</code> </pre> <br>  dan implementasinya untuk <b>Maybe</b> dijelaskan sedikit lebih tinggi. <br><br><div class="spoiler">  <b class="spoiler_title">Panah lebih detail</b> <div class="spoiler_text">  Panah adalah properti dari beberapa fungsi yang memungkinkan Anda untuk bekerja dengannya dalam diagram blok. <br>  Lebih detail dapat ditemukan di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panah: Antarmuka Umum ke Komputasi</a> <br>  Dalam kasus kami, kami menggunakan fungsi Panah <br>  Yaitu <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Arrow</span></span></span><span class="hljs-class"> (-&gt;)</span></span></code> </pre> <br>  Kami akan menggunakan fungsi: <br><br><pre> <code class="haskell hljs">(***) :: <span class="hljs-type"><span class="hljs-type">Arrow</span></span> a =&gt; abc -&gt; ab' c' -&gt; a (b, b') (c, c') (&amp;&amp;&amp;) :: <span class="hljs-type"><span class="hljs-type">Arrow</span></span> a =&gt; abc -&gt; abc' -&gt; ab (c, c')</code> </pre> <br>  Untuk kasus kami <pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">abc</span></span> == (-&gt;) bc == b -&gt; c</code> </pre> <br>  Dan, karenanya, tanda tangan dari fungsi kami dikurangi menjadi: <br><br><pre> <code class="haskell hljs">(***) :: (b -&gt; c) -&gt; (b' -&gt; c') -&gt; ((b, b') -&gt; (c, c')) (&amp;&amp;&amp;) :: (b -&gt; c) -&gt; (b -&gt; c') -&gt; (b -&gt; (c, c'))</code> </pre> <br>  Atau dengan kata-kata yang cukup sederhana, fungsi <b>(***)</b> menggabungkan dua fungsi dengan satu argumen (dan satu tipe output) ke dalam fungsi dengan kerja sepasang argumen pada input dan pada output, masing-masing, sepasang tipe output. <br><br>  Fungsi <b>(&amp;&amp;&amp;)</b> adalah versi <b>singkat (***)</b> , di mana tipe argumen input dari kedua fungsi adalah sama, dan pada input kita tidak memiliki sepasang argumen, tetapi satu argumen. <br></div></div><br>  Total, fungsi pemersatu telah memperoleh formulir: <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Semigroup <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Monoid <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Arrow aggregate :: [Integer] -&gt; (<span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Integer</span></span>, <span class="hljs-type"><span class="hljs-type">Integer</span></span>) aggregate = (<span class="hljs-title"><span class="hljs-title">fmap</span></span> <span class="hljs-title"><span class="hljs-title">getMax</span></span> *** <span class="hljs-title"><span class="hljs-title">getSum</span></span>) . (<span class="hljs-title"><span class="hljs-title">foldMap</span></span> (<span class="hljs-type"><span class="hljs-type">Just</span></span> . <span class="hljs-type"><span class="hljs-type">Max</span></span> &amp;&amp;&amp; <span class="hljs-type"><span class="hljs-type">Sum</span></span>)) <span class="hljs-comment"><span class="hljs-comment">{- -- for GHC 8.2 aggregate = (fmap getMax . getOption *** getSum) . (foldMap (Option . Just . Max &amp;&amp;&amp; Sum)) -}</span></span></code> </pre><br>  Ternyata sangat singkat! <br><br>  Namun, masih melelahkan untuk membungkus dan membalikkan data dari tipe bersarang! <br>  Anda dapat menguranginya lebih jauh, dan konversi paksa bebas sumber daya akan membantu kami! <br><br><h2>  Konversi paksa yang aman dan bebas sumber daya dan mengetikkan peran </h2><br>  Ada fungsi dari paket <b>Unsafe.Coerce</b> - <b>unsafeCoerce</b> <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Unsafe.Coerce(<span class="hljs-title"><span class="hljs-title">unsafeCoerce</span></span>) unsafeCoerce :: a -&gt; b</code> </pre><br>  Fungsi secara paksa tidak aman mengubah tipe: dari <b>a</b> ke <b>b</b> . <br>  Bahkan, fungsinya ajaib, ia memberitahu kompiler untuk mempertimbangkan data tipe <b>a sebagai</b> tipe <b>b</b> , tanpa mempertimbangkan konsekuensi dari langkah ini. <br><br>  Ini dapat digunakan untuk mengonversi tipe bersarang, tetapi Anda harus sangat berhati-hati. <br><br>  Pada 2014, ada revolusi dengan <b>tipe baru</b> , yaitu konversi yang aman dan tanpa sumber daya! <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Coerce(<span class="hljs-title"><span class="hljs-title">coerce</span></span>) coerce :: Coercible ab =&gt; a -&gt; b</code> </pre><br>  Fitur ini telah membuka era baru dalam bekerja dengan <b>tipe baru</b> . <br><br>  <b>Coercible</b> Forced Converter bekerja dengan tipe yang memiliki struktur yang sama dalam memori.  Itu terlihat seperti kelas tipe, tetapi pada kenyataannya GHC mengkonversi tipe pada waktu kompilasi dan tidak mungkin untuk mendefinisikan instance sendiri. <br>  Fungsi <b>Data.Coerce.coerce</b> memungkinkan Anda untuk mengkonversi tipe tanpa sumber daya, tetapi untuk ini kita perlu memiliki akses ke konstruktor tipe. <br><br>  Sekarang sederhanakan fungsi kami: <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Semigroup <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Monoid <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Arrow <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Coerce aggregate :: [Integer] -&gt; (<span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Integer</span></span>, <span class="hljs-type"><span class="hljs-type">Integer</span></span>) aggregate = coerce . (<span class="hljs-title"><span class="hljs-title">foldMap</span></span> (<span class="hljs-type"><span class="hljs-type">Just</span></span> . <span class="hljs-type"><span class="hljs-type">Max</span></span> &amp;&amp;&amp; <span class="hljs-type"><span class="hljs-type">Sum</span></span>)) <span class="hljs-comment"><span class="hljs-comment">-- coerce :: (Maybe (Max Integer), Sum Integer) -&gt; (Maybe Integer, Integer)</span></span></code> </pre><br>  Kami menghindari rutinitas menarik tipe bersarang, kami melakukan ini tanpa menghabiskan sumber daya hanya dengan satu fungsi. <br><br><h3>  Peran Tipe Data Bersarang </h3><br>  Dengan fungsi <b>paksaan,</b> kami dapat memaksa konversi dari semua tipe bersarang. <br>  Tetapi apakah perlu menggunakan fitur ini secara luas? <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- already in Data.Ord -- Down a - reversed order newtype Down a = Down a deriving (Eq, Show) instance Ord a =&gt; Ord (Down a) where compare (Down x) (Down y) = y `compare` x import Data.List(sort) -- Sorted data Sorted a = Sorted [a] deriving (Show, Eq, Ord) fromList2Sorted :: Ord a =&gt; [a] -&gt; Sorted a fromList2Sorted = Sorted . sort -- minimum: O(1) ! minView :: Sorted a -&gt; Maybe a minView (Sorted []) = Nothing minView (Sorted (a : _)) = Just a</span></span></code> </pre><br>  Secara semantik, tidak masuk akal untuk mengonversi ke <b>Sorted a</b> from <b>Sorted (Down a)</b> . <br>  Namun, Anda dapat mencoba: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> h = fromList2Sorted [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>] :: <span class="hljs-type"><span class="hljs-type">Sorted</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> ghci&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hDown = fromList2Sorted $ fmap <span class="hljs-type"><span class="hljs-type">Down</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>] :: <span class="hljs-type"><span class="hljs-type">Sorted</span></span> (<span class="hljs-type"><span class="hljs-type">Down</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span>) ghci&gt; minView h <span class="hljs-type"><span class="hljs-type">Just</span></span> (<span class="hljs-type"><span class="hljs-type">Down</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) ghci&gt; minView (coerce h :: <span class="hljs-type"><span class="hljs-type">Sorted</span></span> (<span class="hljs-type"><span class="hljs-type">Down</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span>)) <span class="hljs-type"><span class="hljs-type">Just</span></span> (<span class="hljs-type"><span class="hljs-type">Down</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) ghci&gt; minView hDown <span class="hljs-type"><span class="hljs-type">Just</span></span> (<span class="hljs-type"><span class="hljs-type">Down</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  Semuanya akan baik-baik saja, tetapi jawaban yang benar adalah <b>Just (Down 3)</b> . <br>  Yaitu, untuk memotong perilaku yang salah, ketik peran diperkenalkan. <br><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE RoleAnnotations #-}</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> role </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sorted</span></span></span><span class="hljs-class"> nominal</span></span></code> </pre><br>  Mari kita coba sekarang: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; minView (coerce h :: <span class="hljs-type"><span class="hljs-type">Sorted</span></span> (<span class="hljs-type"><span class="hljs-type">Down</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span>)) error: <span class="hljs-type"><span class="hljs-type">Couldn't</span></span> match <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int'</span></span></span><span class="hljs-class"> with '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Down</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int'</span></span></span><span class="hljs-class"> arising from a use of 'coerce'</span></span></code> </pre><br>  Secara signifikan lebih baik! <br><br>  Total ada 3 peran ( <b>tipe peran</b> ): <br><br><ul><li>  <b>representasional</b> - setara jika representasi yang sama </li><li>  <b>nominal</b> - harus memiliki tipe yang persis sama </li><li>  <b>phantom</b> - independen dari konten nyata.  Setara dengan apa pun </li></ul><br>  Dalam kebanyakan kasus, kompiler cukup pintar untuk mengungkapkan peran tipe, tetapi dapat membantu. <br><br><h2>  Perilaku Deriving DerivingVia yang Dimurnikan </h2><br>  Berkat perluasan bahasa <b>DerivingVia,</b> peran distribusi <b>tipe baru telah</b> meningkat. <br><br>  Dimulai dengan GHC 8.6, yang baru-baru ini dirilis, ekstensi baru ini telah muncul. <br><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE DerivingVia #-}</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Id</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Semigroup</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monoid</span></span></span><span class="hljs-class">) via </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Max</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span></span></code> </pre><br>  Seperti yang Anda lihat, perilaku tipe disimpulkan secara otomatis karena penyempurnaan cara output. <br>  <b>DerivingVia</b> dapat diterapkan untuk semua jenis yang mendukung <b>Coercible</b> dan yang <b>paling</b> penting - sepenuhnya tanpa konsumsi sumber daya! <br><br>  Terlebih lagi, <b>DerivingVia</b> dapat diterapkan tidak hanya untuk <b>tipe baru</b> , tetapi juga untuk semua jenis isomorfik jika mereka mendukung <b>generik</b> generik dan konversi paksa yang dipaksakan. <br><br><h2>  Kesimpulan </h2><br>  Jenis tipe <b>baru</b> adalah kekuatan yang sangat menyederhanakan dan meningkatkan kode, menghilangkan rutin dan mengurangi konsumsi sumber daya. <br><br>  <i>Terjemahan asli</i> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The Great Power oftype</a> <i>(Hiromi Ishii)</i> <br><br>  <i><b>PS</b> Saya pikir, setelah artikel ini, diterbitkan lebih dari setahun yang lalu [bukan oleh artikel saya], <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Keajaiban tipe baru di Haskell</a> tentang Tipe baru akan menjadi sedikit lebih jelas!</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425405/">https://habr.com/ru/post/id425405/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425393/index.html">Pihak server QIWI 3.0: melaporkan + video lengkap dari semua laporan</a></li>
<li><a href="../id425395/index.html">10 fakta fisik yang seharusnya Anda ketahui di sekolah tetapi mungkin tidak diketahui</a></li>
<li><a href="../id425397/index.html">10 perpustakaan yang harus diketahui oleh setiap pengembang Android</a></li>
<li><a href="../id425401/index.html">Laporan Club of Rome 2018, Bab 1.11: Teknologi Mengganggu dan Revolusi Digital</a></li>
<li><a href="../id425403/index.html">Keuangan pembuat Craigslist: situs melawan berita palsu, diskriminasi dan ekses raksasa internet</a></li>
<li><a href="../id425407/index.html">Firecore - gim seru di AVR</a></li>
<li><a href="../id425409/index.html">DevBoy: membuat generator sinyal</a></li>
<li><a href="../id425411/index.html">Scrum sudah mati</a></li>
<li><a href="../id425413/index.html">Apakah joon sangat baik?</a></li>
<li><a href="../id425415/index.html">Perl 5: bagaimana makro menyembunyikan kesalahan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>