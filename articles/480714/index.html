<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òùüèæ üë©üèæ‚Äç‚öñÔ∏è ‚ôÇÔ∏è C√≥mo agregar c√≥dec a FFmpeg üï∂Ô∏è ü§± üçè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="FFmpeg es un gran proyecto de c√≥digo abierto, una especie de enciclopedia multimedia. Con FFmpeg puede resolver una gran cantidad de tareas multimedia...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo agregar c√≥dec a FFmpeg</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480714/"><hr><p>  FFmpeg es un gran proyecto de c√≥digo abierto, una especie de enciclopedia multimedia.  Con FFmpeg puede resolver una gran cantidad de tareas multimedia de computadora.  Pero a√∫n as√≠, a veces es necesario expandir FFmpeg.  La forma est√°ndar es realizar cambios en el c√≥digo del proyecto y luego compilar la nueva versi√≥n.  El art√≠culo detalla c√≥mo agregar un nuevo c√≥dec.  Tambi√©n se consideran algunas caracter√≠sticas para conectar funciones externas a FFmpeg.  Si no es necesario agregar un c√≥dec, el art√≠culo puede ser √∫til para comprender mejor la arquitectura de los c√≥decs FFmpeg y su configuraci√≥n.  Se supone que el lector est√° familiarizado con la arquitectura de FFmpeg, el proceso de compilaci√≥n de FFmpeg, y tambi√©n tiene experiencia en programaci√≥n utilizando la API de FFmpeg.  La descripci√≥n es v√°lida para FFmpeg 4.2 "Ada", agosto de 2019. <br></p><hr><a name="habracut"></a><br><h1>  Tabla de contenidos </h1><br><div class="spoiler">  <b class="spoiler_title">Tabla de contenidos</b> <div class="spoiler_text"><p> <a href="https://habr.com/ru/post/480714/">Introduccion</a> <br>  <a href="https://habr.com/ru/post/480714/">1. Identificaci√≥n del c√≥dec</a> <br>  <a href="https://habr.com/ru/post/480714/">1.1.</a>  <a href="https://habr.com/ru/post/480714/">ID de c√≥dec</a> <br>  <a href="https://habr.com/ru/post/480714/">1.2.</a>  <a href="https://habr.com/ru/post/480714/">C√≥dec</a> <br>  <a href="https://habr.com/ru/post/480714/">2. Agregar un nuevo c√≥dec a FFmpeg</a> <br>  <a href="https://habr.com/ru/post/480714/">3. Descripci√≥n detallada del contexto y funciones requeridas.</a> <br>  <a href="https://habr.com/ru/post/480714/">3.1.</a>  <a href="https://habr.com/ru/post/480714/">Contexto de c√≥dec</a> <br>  <a href="https://habr.com/ru/post/480714/">3.2.</a>  <a href="https://habr.com/ru/post/480714/">Las funciones</a> <br>  <a href="https://habr.com/ru/post/480714/">3.3.</a>  <a href="https://habr.com/ru/post/480714/">Sellos de tiempo</a> <br>  <a href="https://habr.com/ru/post/480714/">3.4.</a>  <a href="https://habr.com/ru/post/480714/">Otras funciones utilizadas por el c√≥dec</a> <br>  <a href="https://habr.com/ru/post/480714/">4. Implementaci√≥n externa del c√≥dec</a> <br>  <a href="https://habr.com/ru/post/480714/">4.1.</a>  <a href="https://habr.com/ru/post/480714/">Conexi√≥n de funci√≥n externa</a> <br>  <a href="https://habr.com/ru/post/480714/">4.2.</a>  <a href="https://habr.com/ru/post/480714/">Decodificador externo</a> <br>  <a href="https://habr.com/ru/post/480714/">Conclusi√≥n</a> <br>  <a href="https://habr.com/ru/post/480714/">Recursos</a> <br></p><br></div></div><br><a name="id-introdaction"></a><h1>  Introduccion </h1><br><p>  El c√≥dec (c√≥dec, proviene de la combinaci√≥n de los t√©rminos COder y DECoder) es un t√©rmino muy com√∫n y, como suele suceder en tales casos, su significado var√≠a un poco seg√∫n el contexto.  El significado principal es software o hardware para comprimir / descomprimir datos de medios.  En lugar de los t√©rminos compresi√≥n / descompresi√≥n, a menudo se usan los t√©rminos codificaci√≥n / decodificaci√≥n.  Pero en algunos casos, se entiende que un c√≥dec significa simplemente un formato de compresi√≥n (tambi√©n dicen el formato de c√≥dec), independientemente de los medios utilizados para la compresi√≥n / descompresi√≥n.  Veamos c√≥mo se usa el t√©rmino c√≥dec en FFmpeg. <br></p><br><a name="id-1"></a><br><h1>  1. Identificaci√≥n del c√≥dec </h1><br><p>  Los c√≥decs FFmpeg se compilan en la biblioteca <b>libavcodec</b> . <br></p><br><a name="id-1-1"></a><br><h2>  1.1.  ID de c√≥dec </h2><br><p> La <code>enum AVCodecID</code> define en el <code>enum AVCodecID</code> <code>libavcodec/avcodec.h</code> .  Cada elemento de esta enumeraci√≥n identifica el formato de compresi√≥n.  Los elementos de esta enumeraci√≥n deben tener la forma <code>AV_CODEC_ID_XXX</code> , donde <code>XXX</code> nombre √∫nico del identificador de c√≥dec en may√∫sculas.  Aqu√≠ hay ejemplos de identificadores de c√≥dec: <code>AV_CODEC_ID_H264</code> , <code>AV_CODEC_ID_AAC</code> .  Para obtener una descripci√≥n m√°s detallada del identificador de c√≥dec, use la estructura <code>AVCodecDescriptor</code> (declarada en <code>libavcodec/avcodec.h</code> , en forma abreviada): <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AVCodecDescriptor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> AVCodecID id; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> AVMediaType type; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *long_name; <span class="hljs-comment"><span class="hljs-comment">// ... } AVCodecDescriptor;</span></span></code> </pre> <br><p>  El miembro clave de esta estructura es <code>id</code> , el resto de los miembros proporcionan informaci√≥n adicional sobre el identificador de c√≥dec.  Cada identificador de c√≥dec est√° asociado de forma exclusiva con un tipo de medio (miembro de <code>type</code> ) y tiene un nombre √∫nico (miembro de <code>name</code> ), escrito en min√∫sculas.  Una matriz de tipo <code>AVCodecDescriptor</code> define en el archivo <code>libavcodec/codec_desc.c</code> <code>AVCodecDescriptor</code> .  Para cada identificador de c√≥dec, hay un elemento de matriz correspondiente.  Los elementos de esta matriz deben ordenarse por valores de <code>id</code> , ya que la b√∫squeda binaria se usa para buscar elementos.  Para obtener informaci√≥n sobre el identificador de c√≥dec, puede usar las funciones: <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> AVCodecDescriptor* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_descriptor_get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVCodecID id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> AVCodecDescriptor* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_descriptor_get_by_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *name)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">enum</span></span></span><span class="hljs-function"> AVMediaType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_get_type</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVCodecID codec_id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_get_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVCodecID id)</span></span></span></span>;</code> </pre> <br><a name="id-1-2"></a><br><h2>  1.2.  C√≥dec </h2><br><p>  El c√≥dec mismo, un conjunto de herramientas necesarias para realizar la codificaci√≥n / decodificaci√≥n de datos multimedia, combina la estructura <code>AVCodec</code> (declarada en <code>libavcodec/avcodec.h</code> ).  Aqu√≠ est√° su versi√≥n resumida, m√°s completa se discutir√° a continuaci√≥n. <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AVCodec</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *long_name; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> AVMediaType type; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> AVCodecID id; <span class="hljs-comment"><span class="hljs-comment">// ... } AVCodec;</span></span></code> </pre> <br><p>  El miembro m√°s importante de esta estructura es <code>id</code> , el identificador de c√≥dec, tambi√©n hay un miembro que define el tipo de medio ( <code>type</code> ), pero su valor debe coincidir con el valor del mismo miembro de <code>AVCodecDescriptor</code> .  Los c√≥decs se dividen en dos categor√≠as: codificadores, que comprimen o codifican los medios, y decodificadores, que realizan la operaci√≥n opuesta: descomprimir o decodificar.  (A veces, en textos rusos, en lugar del t√©rmino, el codificador usa papel de calco del ingl√©s: el codificador). No hay ning√∫n miembro especial en <code>AVCodec</code> defina la categor√≠a de c√≥dec (aunque la categor√≠a se puede determinar indirectamente utilizando las funciones <code>av_codec_is_encoder()</code> y <code>av_codec_is_decoder()</code> , esta categor√≠a se determina durante el registro. A continuaci√≥n se mostrar√° c√≥mo se har√°: Varios c√≥decs pueden tener el mismo identificador de c√≥dec. Si tienen la misma categor√≠a, deben diferir por nombre ( <code>name</code> miembro). Un codificador y decodificador que tenga el mismo identificador de c√≥dec puede tener uno  el mismo nombre, que tambi√©n puede coincidir con el nombre del identificador de c√≥dec (pero estas coincidencias son opcionales). Tal situaci√≥n puede generar cierta confusi√≥n, pero no hay nada que hacer, debe comprender claramente a qu√© entidad pertenece el nombre. Dentro de una categor√≠a, el nombre El c√≥dec debe ser √∫nico. Para buscar c√≥decs registrados, hay funciones: <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">AVCodec* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_find_encoder_by_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *name)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">AVCodec* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_find_decoder_by_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *name)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">AVCodec* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_find_encoder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVCodecID id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">AVCodec* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_find_decoder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVCodecID id)</span></span></span></span>;</code> </pre> <br><p>  Dado que varios c√≥decs pueden tener el mismo identificador, las dos √∫ltimas funciones devuelven uno de ellos, que puede considerarse el c√≥dec predeterminado para un identificador de c√≥dec dado. <br></p><br><p>  Se puede solicitar una lista de todos los c√≥decs registrados con el comando <br></p><br><p> <code>ffmpeg -codecs &gt;codecs.txt</code> <br> </p><br><p>  Despu√©s de ejecutar el comando, el archivo <code>codecs.txt</code> contendr√° esta lista.  Cada identificador de c√≥dec estar√° representado por un registro separado (l√≠nea).  Aqu√≠, por ejemplo, la entrada para el identificador de c√≥dec <code>AV_CODEC_ID_H264</code> : <br></p><br><p> <code>DEV.LS <br> h264 <br> H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 <br> (decoders: h264 h264_qsv h264_cuvid) <br> (encoders: libx264 libx264rgb h264_amf h264_nvenc h264_qsv nvenc nvenc_h264) <br></code> <br></p><br><p>  Al comienzo de la grabaci√≥n, hay caracteres especiales que determinan las caracter√≠sticas comunes disponibles para este identificador de c√≥dec: <code>D</code> - los decodificadores est√°n registrados, <code>E</code> - los codificadores est√°n registrados, <code>V</code> - se usa para video, <code>L</code> - existe la posibilidad de compresi√≥n con p√©rdidas, <code>S</code> - existe la posibilidad de compresi√≥n sin p√©rdidas.  Luego viene el nombre del identificador de c√≥dec ( <code>h264</code> ), seguido de un nombre de identificador de c√≥dec largo ( <code>H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10</code> ), y luego una lista de nombres de decodificadores y codificadores registrados. <br></p><br><a name="id-2"></a><br><h1>  2. Agregar un nuevo c√≥dec a FFmpeg </h1><br><p>  Consideraremos el procedimiento para agregar un nuevo c√≥dec a FFmpeg usando un ejemplo de c√≥dec de audio, al que llamaremos <code>FROX</code> . <br></p><br><p>  <b>Paso 1. Agregue un nuevo elemento a la <code>enum AVCodecID</code> .</b> <br></p><br><p>  Este listado est√° en el <code>libavcodec/avcodec.h</code> .  Al agregar, debe seguir las reglas: <br></p><br><ol><li>  El valor de un elemento no debe coincidir con los valores de los elementos de enumeraci√≥n existentes; </li><li>  No cambie los valores de los elementos de enumeraci√≥n existentes; </li><li>  Publique un nuevo valor en un grupo de c√≥decs similares. </li></ol><br><p>  Seg√∫n la plantilla, el identificador de este elemento debe ser <code>AV_CODEC_ID_FROX</code> .  Col√≥quelo antes de <code>AV_CODEC_ID_PCM_S64LE</code> y d√© el valor <code>0x10700</code> . <br></p><br><p>  <b>Paso 2. Agregue el elemento a la matriz <code>codec_descriptors</code> (archivo <code>libavcodec/codec_desc.c</code> ).</b> <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AVCodecDescriptor codec_descriptors[] = { <span class="hljs-comment"><span class="hljs-comment">// ... { .id = AV_CODEC_ID_FROX, .type = AVMEDIA_TYPE_AUDIO, .name = "frox", .long_name = NULL_IF_CONFIG_SMALL("FROX audio"), .props = AV_CODEC_PROP_LOSSLESS, }, // ... };</span></span></code> </pre> <br><p>  Debe agregar el elemento al lugar "correcto", no se debe violar la monotonicidad de los elementos de la matriz por el valor de <code>id</code> . <br></p><br><p>  <b>Paso 3. Defina instancias de <code>AVCodec</code> por separado para el codificador y el decodificador.</b> <br></p><br><p>  Para hacer esto, primero debe determinar la estructura para el contexto del c√≥dec y varias funciones que realizar√°n la codificaci√≥n / decodificaci√≥n real y algunas otras operaciones necesarias.  En esta secci√≥n, estas definiciones se realizar√°n de manera extremadamente esquem√°tica; m√°s adelante se realizar√° una descripci√≥n m√°s detallada.  <code>libavcodec/frox.c</code> el c√≥digo en el archivo <code>libavcodec/frox.c</code> <br></p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"avcodec.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// context typedef struct FroxContext { // ... } FroxContext; // decoder static int frox_decode_init(AVCodecContext *codec_ctx) { return -1; } static int frox_decode_close(AVCodecContext *codec_ctx) { return -1; } static int frox_decode(AVCodecContext *codec_ctx, void* outdata, int *outdata_size, AVPacket *pkt) { return -1; } AVCodec ff_frox_decoder = { .name = "frox_dec", .long_name = NULL_IF_CONFIG_SMALL("FROX audio decoder"), .type = AVMEDIA_TYPE_AUDIO, .id = AV_CODEC_ID_FROX, .priv_data_size = sizeof(FroxContext), .init = frox_decode_init, .close = frox_decode_close, .decode = frox_decode, .capabilities = AV_CODEC_CAP_LOSSLESS, .sample_fmts = (const enum AVSampleFormat[]) {AV_SAMPLE_FMT_FLT, AV_SAMPLE_FMT_NONE}, .channel_layouts = (const int64_t[]) {AV_CH_LAYOUT_MONO, 0 }, }; // encoder static int frox_encode_init(AVCodecContext *codec_ctx) { return -1; } static int frox_encode_close(AVCodecContext *codec_ctx) { return -1; } static int frox_encode(AVCodecContext *codec_ctx, AVPacket *pkt, const AVFrame *frame, int *got_pkt_ptr) { return -1; } AVCodec ff_frox_encoder = { .name = "frox_enc", .long_name = NULL_IF_CONFIG_SMALL("FROX audio encoder"), .type = AVMEDIA_TYPE_AUDIO, .id = AV_CODEC_ID_FROX, .priv_data_size = sizeof(FroxContext), .init = frox_encode_init, .close = frox_encode_close, .encode2 = frox_encode, .sample_fmts = (const enum AVSampleFormat[]) {AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_NONE}, .channel_layouts = (const int64_t[]) {AV_CH_LAYOUT_MONO, 0 }, };</span></span></span></span></code> </pre> <br><p>  Para simplificar, en este ejemplo, el codificador y el decodificador tienen el mismo contexto: <code>FroxContext</code> , pero la mayor√≠a de las veces el codificador y el decodificador tienen contextos diferentes.  Tambi√©n tenga en cuenta que los <code>AVCodec</code> instancia <code>AVCodec</code> deben seguir un patr√≥n especial. <br></p><br><p>  <b>Paso 4. Agregue instancias de <code>AVCodec</code> a la lista de registro.</b> <br></p><br><p>  Vaya al archivo <code>libavcodec/allcodecs.c</code> .  Al principio de este archivo hay una lista de declaraciones de todos los c√≥decs registrados.  Agregue nuestros c√≥decs a esta lista: <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> AVCodec ff_frox_decoder; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> AVCodec ff_frox_encoder;</code> </pre> <br><p>  Durante la ejecuci√≥n, el script de <code>configure</code> encuentra todas esas declaraciones y genera el <code>libavcodec/codec_list.c</code> , que contiene una matriz de punteros a los c√≥decs declarados en <code>libavcodec/allcodecs.c</code> .  Despu√©s de ejecutar el script en el archivo <code>libavcodec/codec_list.c</code> veremos: <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AVCodec * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> codec_list[] = { <span class="hljs-comment"><span class="hljs-comment">// ... &amp;ff_frox_encoder, // ... &amp;ff_frox_decoder, // ... NULL };</span></span></code> </pre> <br><p>  Adem√°s, durante la ejecuci√≥n del script de <code>configure</code> , se <code>config.h</code> archivo <code>config.h</code> , en el que encontramos las declaraciones <br></p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONFIG_FROX_DECODER 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONFIG_FROX_ENCODER 1</span></span></code> </pre> <br><p>  <b>Paso 5. Edite <code>libavcodec/Makefile</code></b> <br></p><br><p>  Abra <code>libavcodec/Makefile</code> .  Encontramos la secci√≥n <code># decoders/encoders</code> , y agregamos all√≠ <br></p><br><pre> <code class="cpp hljs">OBJS-$(CONFIG_FROX_DECODER) += frox.o OBJS-$(CONFIG_FROX_ENCODER) += frox.o</code> </pre> <br><p>  <b>Paso 6. Edite el c√≥digo del multiplexor y demultiplexor.</b> <br></p><br><p>  El multiplexor (muxer) y el demultiplexor (demuxer) deben "conocer" el nuevo c√≥dec.  Al grabar, es necesario registrar la informaci√≥n de identificaci√≥n para este c√≥dec, mientras lee, determinar el identificador del c√≥dec a partir de la informaci√≥n de identificaci√≥n.  Esto es lo que debe hacer para el formato <code>matroska</code> ( <code>*.mkv</code> ). <br></p><br><p>  1. En el archivo <code>libavformat/matroska.c</code> , agregue un elemento para el nuevo c√≥dec a la matriz <code>libavformat/matroska.c</code> : <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CodecTags ff_mkv_codec_tags[] = { <span class="hljs-comment"><span class="hljs-comment">// ... {"A_FROX", AV_CODEC_ID_FROX}, // ... };</span></span></code> </pre> <br><p>  Cadena <code>"A_FROX"</code> y el multiplexor lo escribir√° en el archivo como informaci√≥n de identificaci√≥n.  En esta matriz, est√° asociada con el identificador de c√≥dec, por lo tanto, al leer, el demultiplexor puede determinarlo f√°cilmente.  El demultiplexor escribe el identificador de c√≥dec en el miembro <code>codec_id</code> de la estructura <code>codec_id</code> .  Un puntero a esta estructura es un miembro de la estructura <code>AVStream</code> . <br></p><br><p>  2. En el archivo <code>libavformat/matroskaenc.c</code> , agregue el elemento a la matriz Additional_audio_tags: <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AVCodecTag additional_audio_tags[] = { <span class="hljs-comment"><span class="hljs-comment">// ... { AV_CODEC_ID_FROX, 0XFFFFFFFF }, // ... };</span></span></code> </pre> <br><p>  Entonces todo est√° listo.  Primero, ejecute el script de <code>configure</code> .  Despu√©s de eso, debe asegurarse de que se realicen los cambios descritos anteriormente en los archivos <code>libavcodec/codec_list.c</code> y <code>config.h</code> .  Entonces puedes ejecutar la compilaci√≥n: <br></p><br><p> <code>make clean <br> make <br></code> <br></p><br><p>  Si la compilaci√≥n se realiz√≥ <code>ffmpeg.exe</code> , aparece el ejecutable <code>ffmpeg</code> (o <code>ffmpeg.exe</code> , si el sistema operativo de destino es Windows).  Ejecutar el comando <br></p><br><p> <code>./ffmpeg -codecs &gt;codecs.txt <br></code> <br></p><br><p>  y aseg√∫rese de que FFmpeg "vea" nuestros nuevos c√≥decs, encontramos la entrada en el archivo <code>codecs.txt</code> <br></p><br><p> <code>DEA..S frox FROX audio (decoders: frox_dec) (encoders: frox_enc) <br></code> <br></p><br><a name="id-3"></a><br><h1>  3. Descripci√≥n detallada del contexto y funciones requeridas. </h1><br><p>  En esta secci√≥n, describimos con m√°s detalle c√≥mo puede verse la estructura del contexto del c√≥dec y las funciones necesarias. <br></p><br><a name="id-3-1"></a><br><h2>  3.1.  Contexto de c√≥dec </h2><br><p>  El contexto del c√≥dec puede admitir la instalaci√≥n de opciones.  Para los codificadores, este soporte se usa con la frecuencia suficiente, para los decodificadores con menos frecuencia.  La estructura que soporta la instalaci√≥n de opciones debe tener un puntero a la estructura <code>AVClass</code> como primer miembro y luego las opciones mismas. <br></p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"libavutil/opt.h"</span></span></span><span class="hljs-meta"> typedef struct FroxContext { const AVClass *av_class; int frox_int; char *frox_str; uint8_t *frox_bin; int bin_size; } FroxContext;</span></span></code> </pre> <br><p>  A continuaci√≥n, debe definir una matriz de tipo <code>AVOption</code> , cada elemento del cual describe una opci√≥n espec√≠fica. <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AVOption frox_options[] = { { <span class="hljs-string"><span class="hljs-string">"frox_int"</span></span>, <span class="hljs-string"><span class="hljs-string">"This is a demo option of int type."</span></span>, offsetof(FroxContext, frox_int), AV_OPT_TYPE_INT, { .i64 = <span class="hljs-number"><span class="hljs-number">-1</span></span> }, <span class="hljs-number"><span class="hljs-number">1</span></span>, SHRT_MAX }, { <span class="hljs-string"><span class="hljs-string">"frox_str"</span></span>, <span class="hljs-string"><span class="hljs-string">"This is a demo option of string type."</span></span>, offsetof(FroxContext, frox_str), AV_OPT_TYPE_STRING }, { <span class="hljs-string"><span class="hljs-string">"frox_bin"</span></span>, <span class="hljs-string"><span class="hljs-string">"This is a demo option of binary type."</span></span>, offsetof(FroxContext, frox_bin), AV_OPT_TYPE_BINARY }, { <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> }, };</code> </pre> <br><p>  Para cada opci√≥n, debe definir un nombre, descripci√≥n, desplazamiento en la estructura, tipo.  Tambi√©n puede definir un valor predeterminado y para opciones enteras un rango de valores v√°lidos. <br></p><br><p>  A continuaci√≥n, debe definir una instancia de tipo <code>AVClass</code> . <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AVClass frox_class = { .class_name = <span class="hljs-string"><span class="hljs-string">"FroxContext"</span></span>, .item_name = av_default_item_name, .option = frox_options, .version = LIBAVUTIL_VERSION_INT, };</code> </pre> <br><p>  Se debe utilizar un puntero a esta instancia para inicializar el miembro <code>AVCodec</code> correspondiente. <br></p><br><pre> <code class="cpp hljs">AVCodec ff_frox_decoder = { <span class="hljs-comment"><span class="hljs-comment">// ... .priv_data_size = sizeof(FroxContext), .priv_class = &amp;frox_class, // ... }; AVCodec ff_frox_encoder = { // ... .priv_data_size = sizeof(FroxContext), .priv_class = &amp;frox_class, // ... };</span></span></code> </pre> <br><p>  Ahora al ejecutar la funci√≥n <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">AVCodecContext *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_alloc_context3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVCodec *codec)</span></span></span></span>;</code> </pre> <br><p>  se <code>AVCodecContext</code> una instancia de la estructura <code>AVCodecContext</code> y se inicializa el miembro del <code>codec</code> .  A continuaci√≥n, en funci√≥n del valor <code>codec-&gt;priv_data_size</code> , se <code>codec-&gt;priv_data_size</code> la memoria necesaria para la instancia de <code>FroxContext</code> , utilizando el valor <code>codec-&gt;priv_class</code> primer miembro de esta instancia y luego se <code>av_opt_set_defaults()</code> funci√≥n <code>av_opt_set_defaults()</code> , que establecer√° los valores predeterminados para las opciones.  Un puntero a una instancia de <code>FroxContext</code> estar√° disponible a trav√©s del miembro <code>priv_data</code> de la estructura <code>priv_data</code> . <br></p><br><p>  Al trabajar con la API de FFmpeg, los valores para las opciones se pueden establecer directamente. <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AVCodec *codec; <span class="hljs-comment"><span class="hljs-comment">// ... AVCodecContext *codec_ctx = avcodec_alloc_context3(codec); // ... av_opt_set(codec_ctx-&gt;priv_data, "frox_str", "meow", 0); av_opt_set_int(codec_ctx-&gt;priv_data, "frox_int", 42, 0);</span></span></code> </pre> <br><p>  Otra forma es usar el diccionario de opciones, que se pasar√° como el tercer argumento al llamar a <code>avcodec_open2()</code> (ver m√°s abajo). <br></p><br><p>  Usando la funci√≥n <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> AVOption* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">av_opt_next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVOption* prev)</span></span></span></span>;</code> </pre> <br><p>  Puede obtener una lista de todas las opciones admitidas por el contexto de c√≥dec.  Esto es √∫til al examinar un c√≥dec.  Pero antes de eso, debe asegurarse de que <code>codec_ctx-&gt;codec-&gt;priv_class</code> configurado en un valor distinto de cero, de lo contrario, el contexto no admite opciones y cualquier operaci√≥n con opciones bloquear√° el programa. <br></p><br><a name="id-3-2"></a><br><h2>  3.2.  Las funciones </h2><br><p>  Examinemos ahora con m√°s detalle c√≥mo se organizan las funciones utilizadas en la inicializaci√≥n del c√≥dec y la codificaci√≥n / decodificaci√≥n real.  Por lo general, siempre necesitan obtener un puntero a un <code>FroxContext</code> . <br></p><br><pre> <code class="cpp hljs">AVCodecContext *codec_ctx; <span class="hljs-comment"><span class="hljs-comment">// ... FroxContext* frox_ctx = codec_ctx-&gt;priv_data;</span></span></code> </pre> <br><p>  Las <code>frox_decode_init()</code> y <code>frox_encode_init()</code> cuando se ejecute la funci√≥n <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_open2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AVCodecContext *codec_ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVCodec *codec, AVDictionary **options)</span></span></span></span>;</code> </pre> <br><p>  Deben asignar los recursos necesarios para que funcione el c√≥dec y, si es necesario, inicializar algunos miembros de la estructura <code>AVCodecContext</code> , por ejemplo, <code>frame_size</code> para un <code>frame_size</code> audio. <br></p><br><p>  Las <code>frox_decode_close()</code> y <code>frox_encode_close()</code> cuando se ejecuten <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AVCodecContext *codec_ctx)</span></span></span></span>;</code> </pre> <br><p>  Necesitan liberar los recursos asignados. <br></p><br><p>  Considere una funci√≥n para implementar la decodificaci√≥n <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frox_decode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AVCodecContext *codec_ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *outdata, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *outdata_size, AVPacket *pkt)</span></span></span></span>;</code> </pre> <br><p>  Ella debe implementar las siguientes operaciones: <br></p><br><ol><li>  Decodificaci√≥n real; </li><li>  Asignaci√≥n del b√∫fer necesario para la trama de salida; </li><li>  Copie los datos decodificados al buffer de cuadros </li></ol><br><p>  Considere c√≥mo asignar el b√∫fer necesario para el marco de salida.  El par√°metro <code>outdata</code> realidad apunta a un <code>AVFrame</code> , por lo que primero debe realizar una conversi√≥n de tipo: <br></p><br><pre> <code class="cpp hljs">AVFrame* frm = outdata;</code> </pre> <br><p>  A continuaci√≥n, debe asignar un b√∫fer para almacenar datos de trama.  Para hacer esto, inicialice los miembros de <code>AVFrame</code> que determinan el tama√±o del b√∫fer de trama.  Para audio, esto es <code>nb_samples</code> , <code>channel_layout</code> , <code>format</code> (para <code>width</code> , <code>height</code> , <code>format</code> video). <br></p><br><p>  Despu√©s de eso, debes llamar a la funci√≥n <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">av_frame_get_buffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AVFrame* frm, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> alignment)</span></span></span></span>;</code> </pre> <br><p>  El puntero al marco, que es el par√°metro de datos <code>outdata</code> convertidos, se usa como primer argumento; se recomienda pasar cero como segundo argumento.  Despu√©s de usar el marco (esto ya ocurre fuera del c√≥dec), la funci√≥n libera el b√∫fer asignado por esta funci√≥n <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">av_frame_unref</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AVFrame* frm)</span></span></span></span>;</code> </pre> <br><p>  La funci√≥n <code>frox_decode()</code> deber√≠a devolver el n√∫mero de bytes utilizados para la decodificaci√≥n del paquete al que apunta <code>pkt</code> .  Si se completa la formaci√≥n de trama, la variable a la que apunta <code>outdata_size</code> asigna un valor distinto de cero; de lo contrario, esta variable obtiene el valor <code>0</code> . <br></p><br><p>  Considere una funci√≥n para implementar la codificaci√≥n <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frox_encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AVCodecContext *codec_ctx, AVPacket *pkt, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVFrame *frame, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *got_pkt_ptr)</span></span></span></span>;</code> </pre> <br><p>  Ella debe implementar las siguientes operaciones: <br></p><br><ol><li>  Codificaci√≥n real; </li><li>  Asignaci√≥n del b√∫fer necesario para el paquete de salida; </li><li>  Copie los datos codificados al b√∫fer de paquetes. </li></ol><br><p>  Para seleccionar el b√∫fer requerido, use la funci√≥n <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">av_new_packet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AVPacket *pkt, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pack_size)</span></span></span></span>;</code> </pre> <br><p>  El par√°metro <code>pkt</code> utiliza como primer argumento, y el tama√±o de los datos codificados es el segundo.  Despu√©s de usar el paquete (esto ya ocurre fuera del c√≥dec), los buffers asignados por esta funci√≥n son liberados por la funci√≥n <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">av_packet_unref</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AVPacket *pkt)</span></span></span></span>;</code> </pre> <br><p>  Si el paquete se completa, la variable a la que apunta <code>got_pkt_ptr</code> asigna un valor distinto de cero; de lo contrario, esta variable obtiene el valor <code>0</code> .  Si no hay error, la funci√≥n devuelve cero, de lo contrario, un c√≥digo de error. <br></p><br><p>  Al implementar el c√≥dec, generalmente se usa el registro (para errores, esto puede considerarse un requisito obligatorio).  Aqu√≠ hay un ejemplo: <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frox_decode_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AVCodecContext *codec_ctx)</span></span></span><span class="hljs-function"> </span></span>{ av_log(codec_ctx, AV_LOG_INFO, <span class="hljs-string"><span class="hljs-string">"FROX decode close\n"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  En este caso, cuando salga al registro, el nombre del c√≥dec se usar√° como nombre de contexto. <br></p><br><a name="id-3-3"></a><br><h2>  3.3.  Sellos de tiempo </h2><br><p>  Para establecer el tiempo en FFmpeg, se usa una base de tiempo, especificada en segundos usando el n√∫mero racional representado por el tipo <code>AVRational</code> .  (Se utiliza un enfoque similar en C ++ 11. Por ejemplo, 1/1000 establece el milisegundo). Los marcos y los paquetes tienen marcas de tiempo del tipo <code>int64_t</code> , sus valores contienen tiempo en las unidades de tiempo correspondientes.  Un cuadro, es decir, una estructura <code>AVFrame</code> , tiene un miembro <code>pts</code> (marca de tiempo de presentaci√≥n), cuyo valor determina el tiempo relativo de la escena capturada en el cuadro.  Un paquete, es decir, una estructura <code>AVPacket</code> , tiene miembros <code>pts</code> (marca de tiempo de presentaci√≥n) y <code>dts</code> (marca de tiempo de descompresi√≥n).  El valor <code>dts</code> determina el tiempo relativo de transmisi√≥n del paquete para la decodificaci√≥n.  Para los c√≥decs simples, es lo mismo que <code>pts</code> , pero para los c√≥decs complejos puede ser diferente (por ejemplo, para <code>h264</code> cuando se usan cuadros B), es decir, los paquetes se pueden decodificar en el orden incorrecto en el que se deben usar los cuadros. <br></p><br><p>  La unidad de tiempo se define para la secuencia y el c√≥dec, la estructura <code>AVStream</code> tiene un miembro correspondiente: <code>time_base</code> , el mismo miembro tiene la estructura <code>AVCodecContext</code> . <br></p><br><p>  Las marcas de tiempo del paquete extra√≠do de la secuencia utilizando <code>av_read_frame()</code> se especificar√°n en unidades de tiempo de esta secuencia.  Al decodificar, no se utiliza la unidad de tiempo del c√≥dec.  Para un decodificador de video, por lo general simplemente no est√° configurado, para un decodificador de audio tiene un valor est√°ndar: el inverso de la frecuencia de muestreo.  El decodificador debe establecer una marca de tiempo para el marco de salida en funci√≥n de la marca de tiempo del paquete.  FFmpeg define de forma independiente dicha etiqueta y la escribe en el miembro <code>best_effort_timestamp</code> de la estructura <code>best_effort_timestamp</code> .  Todas estas marcas de tiempo utilizar√°n la unidad de tiempo de la secuencia de la que se extrae el paquete. <br></p><br><p>  Para el codificador, debe especificar la unidad de tiempo.  En el c√≥digo del cliente que organiza la decodificaci√≥n, debe establecer el valor para el miembro <code>time_base</code> de la estructura <code>time_base</code> antes de llamar a <code>avcodec_open2()</code> .  Por lo general, toma la unidad de tiempo utilizada para las marcas de tiempo del marco codificado.  Si esto no se hace, los codificadores de video generalmente dan un error, los codificadores de audio establecen el valor predeterminado: el inverso de la frecuencia de muestreo.  No est√° del todo claro si un c√≥dec puede cambiar una unidad de tiempo dada.  Por si acaso, es mejor verificar siempre el valor de <code>time_base</code> despu√©s de llamar a <code>avcodec_open2()</code> y, si ha cambiado, recalcular las marcas de tiempo de los marcos de entrada por unidad de tiempo del c√≥dec.  En el proceso de codificaci√≥n, debe instalar los <code>pts</code> y <code>dts</code> paquete.  Despu√©s de la codificaci√≥n, antes de escribir un paquete en el flujo de salida, es necesario volver a calcular las marcas de tiempo del paquete desde la unidad de tiempo del c√≥dec a la unidad de tiempo del flujo.  Para hacer esto, use la funci√≥n <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">av_packet_rescale_ts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AVPacket *pkt, AVRational tb_src, AVRational tb_dst)</span></span></span></span>;</code> </pre> <br><p>  Al escribir paquetes en la secuencia, es necesario asegurarse de que los valores <code>dts</code> aumenten estrictamente; de ‚Äã‚Äãlo contrario, el multiplexor arrojar√° un error.  (Para obtener m√°s informaci√≥n, consulte la documentaci√≥n de la funci√≥n <code>av_interleaved_write_frame()</code> ). <br></p><br><a name="id-3-4"></a><br><h2>  3.4.  Otras funciones utilizadas por el c√≥dec </h2><br><p>  Cuando inicializa una instancia de <code>AVCodec</code> , se pueden registrar dos funciones m√°s.  Estos son los miembros relevantes de <code>AVCodec</code> : <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AVCodec</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... void (*init_static_data)(AVCodec *codec); void (*flush)(AVCodecContext *codec_ctx); // ... } AVCodec;</span></span></code> </pre> <br><p>  El primero de ellos se llama una vez al registrarse el c√≥dec. <br></p><br><p>  El segundo restablece el estado interno del c√≥dec, se llamar√° durante la ejecuci√≥n de la funci√≥n. <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_flush_buffers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AVCodecContext *codec_ctx)</span></span></span></span>;</code> </pre> <br><p>  Esta llamada es necesaria, por ejemplo, cuando se cambia por la fuerza la posici√≥n de reproducci√≥n actual. <br></p><br><a name="id-4"></a><br><h1>  4. Implementaci√≥n externa del c√≥dec </h1><br><a name="id-4-1"></a><br><h2>  4.1.  Conexi√≥n de funci√≥n externa </h2><br><p>  Considere la siguiente organizaci√≥n de c√≥dec: el c√≥dec registrado en FFmpeg desempe√±a el papel de un marco y delega el procedimiento de codificaci√≥n / decodificaci√≥n real a funciones externas (alg√∫n tipo de complementos) implementadas fuera de FFmpeg. <br></p><br><p>        .  Aqu√≠ hay algunos de ellos: <br></p><br><ol><li>       ,   FFmpeg    ; </li><li>     C,    ,   C++; </li><li>     framework,     FFmpeg. </li></ol><br><p>    ,   FFmpeg       ¬´¬ª,         FFmpeg API.             ¬´¬ª FFmpeg       (  ,     ),     .    ‚Äî     .         . <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">dec_extern_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">*, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">*)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frox_decode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AVCodecContext* codec_ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* outdata, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *outdata_size, AVPacket* pkt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* out_buff; <span class="hljs-comment"><span class="hljs-comment">//      out_buff FroxContext *fc = codec_ctx-&gt;priv_data; if (fc-&gt;bin_size &gt; 0) { if (fc-&gt;bin_size == sizeof(dec_extern_t)) { dec_extern_t edec; memcpy(&amp;edec, fc-&gt;frox_bin, fc-&gt;bin_size); ret = (*edec)(pkt-&gt;data, pkt-&gt;size, out_buff); if (ret &gt;= 0) { //     out_buff   } } else { /*  */ } } else { /*    */ } // ... return ret; }</span></span></code> </pre> <br><p>    FFmpeg API (     C++)    . <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecodeFroxData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buff, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* outBuff)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">dec_extern_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">*, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">*)</span></span></span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt; #include &lt;libavutil/opt.h&gt; } // ... AVCodecContext* ctx; // ... dec_extern_t dec = DecodeFroxData; void* pv = &amp;dec; auto pb = static_cast&lt;const uint8_t*&gt;(pv); auto sz = sizeof(dec); av_opt_set_bin(ctx-&gt;priv_data, "frox_bin", pb, sz, 0);</span></span></span></span></code> </pre> <br><a name="id-4-2"></a><br><h2> 4.2.   </h2><br><p>       ‚Äî     .        ,   . ,      .  ,   ,  FFmpeg     ,   ¬´¬ª ,        .         .     ,   .   FFmpeg API  -       ,   ,      .     .        ,        .     PC (Windows)      DirectShow  AVI .  PC             -   DirectShow.     32- FourCC. (   <code>biCompression</code>  <code>BITMAPINFOHEADER</code> .)  ,      DirectShow   ,   PC    -.        FFmpeg  , ,   ,   <code>codec_tag</code>  <code>AVCodecParameters</code>   FourCC,     .       FFmpeg API    ,    .             FFmpeg   FFmpeg API. <br></p><br><p>          ,   <code>*.mkv</code>  FFmpeg     ( <code>ENCODER</code> ). <br></p><br><a name="id-concl"></a><br><h1>  Conclusi√≥n </h1><br><p>        ,   ,       FFmpeg: , changelog,     ..     ¬´¬ª  FFmpeg,     ,     . <br></p><br><a name="id-refs"></a><br><h1>  Recursos </h1><br><p> <b>   FFmpeg</b> </p><br><p> [1] <a href="https://ffmpeg.org/" rel="nofollow">FFmpeg ‚Äî  </a> <br> [2] <a href="https://ffmpeg.org/documentation.html" rel="nofollow">FFmpeg ‚Äî </a> <br> [3] <a href="https://ru.wikipedia.org/wiki/FFmpeg" rel="nofollow">FFmpeg ‚Äî </a> <br> [4] <a href="https://help.ubuntu.ru/wiki/ffmpeg" rel="nofollow">FFmpeg ‚Äî    Ubuntu</a> <br></p><br><p> <b></b> </p><br><p> [5] <a href="https://trac.ffmpeg.org/wiki/CompilationGuide" rel="nofollow">FFmpeg Compilation Guide</a> <br> [6] Compilation of FFmpeg 4.0 in Windows 10 <br></p><br><p> <b>   FFmpeg API</b> </p><br><p> [7] <a href="https://habr.com/ru/post/137793/">   ffmpeg</a> <br></p><br><p> <b> </b> </p><br><p> [8] <a href="https://wiki.multimedia.cx/index.php/FFmpeg_codec_HOWTO" rel="nofollow">FFmpeg codec HOWTO</a> <br> [9] <a href="http://ogorkis.net/ffmpeg" rel="nofollow">FFmpeg video codec tutorial</a> <br></p><br><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/480714/">https://habr.com/ru/post/480714/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../480702/index.html">Recursos humanos y talentos, expertos y creativos: c√≥mo fue el octavo Seminario Habrase</a></li>
<li><a href="../480704/index.html">Hacer que el contenido receptivo se cargue en el sitio</a></li>
<li><a href="../480708/index.html">Las d√©cadas est√°n llegando a su fin. ¬øQu√© aplicaciones en Google Play fueron las m√°s descargadas en los √∫ltimos 10 a√±os?</a></li>
<li><a href="../480710/index.html">Refactorizando juegos SFML</a></li>
<li><a href="../480712/index.html">El vuelo con un dos√≠metro en el bolsillo</a></li>
<li><a href="../480716/index.html">Matlab vs. Julia vs. Pit√≥n</a></li>
<li><a href="../480718/index.html">6 consejos para una revisi√≥n exitosa del c√≥digo</a></li>
<li><a href="../480724/index.html">Idiomas transcompilados: proyectos de conversi√≥n de c√≥digo a c√≥digo</a></li>
<li><a href="../480734/index.html">Que TestMace es mejor que Postman</a></li>
<li><a href="../480736/index.html">¬øPor qu√© no todos los errores deben corregirse para mejorar un producto de TI?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>