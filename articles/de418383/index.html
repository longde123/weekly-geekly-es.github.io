<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôéÔ∏è üíÜüèª üö∂üèæ Android-Animationen basierend auf Kotlin und RxJava ü§º üòÑ üë®üèª‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Im vergangenen Jahr sprach Ivan ≈†koriƒá von PSPDFKit bei MBLT DEV mit einem Bericht √ºber das Erstellen von Animationen in Android basierend...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Android-Animationen basierend auf Kotlin und RxJava</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/e-Legion/blog/418383/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/2g/5z/pi/2g5zpitzszs5lxzgdighjoo14u4.png"></a> <br><br>  Hallo Habr!  Im vergangenen Jahr sprach Ivan ≈†koriƒá von PSPDFKit bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MBLT DEV</a> mit einem Bericht √ºber das Erstellen von Animationen in Android basierend auf Kotlin und der RxJava-Bibliothek. <br><br>  Ich verwende jetzt die Techniken aus dem Bericht bei der Arbeit an meinem Projekt, sie helfen sehr.  Unter der Zwischensequenz befindet sich die Abschrift des Berichts und des Videos. Jetzt k√∂nnen Sie diese Tricks nutzen. <a name="habracut"></a><br><br><h2>  Animation </h2><br>  In Android gibt es 4 Klassen, die wie standardm√§√üig angewendet werden: <br><br><ol><li>  <b>ValueAnimator</b> - Diese Klasse bietet einen einfachen Synchronisationsmechanismus zum Ausf√ºhren von Animationen, mit denen animierte Werte berechnet und f√ºr die Ansicht festgelegt werden. </li><li>  <b>ObjectAnimator</b> ist eine Unterklasse von ValueAnimator, mit der Sie Animationen f√ºr Objekteigenschaften unterst√ºtzen k√∂nnen. </li><li>  <b>AnimatorSet</b> wird verwendet, um eine Animationssequenz zu erstellen.  Sie haben beispielsweise eine Folge von Animationen: <br><br><ol><li>  Ansichtsbl√§tter auf der linken Seite des Bildschirms. </li><li>  Nach Abschluss der ersten Animation m√∂chten wir eine Erscheinungsanimation f√ºr eine andere Ansicht usw. ausf√ºhren. </li></ol></li><li>  <b>ViewPropertyAnimator</b> - <b>Startet</b> und optimiert automatisch Animationen f√ºr die ausgew√§hlte View-Eigenschaft.  Wir werden es haupts√§chlich benutzen.  Daher werden wir diese API verwenden und sie dann im Rahmen der reaktiven Programmierung in RxJava einf√ºgen. </li></ol><br><cut></cut><br><h3>  ValueAnimator </h3><br>  Lassen Sie uns <b>das ValueAnimator-</b> Framework <b>analysieren</b> .  Es wird verwendet, um den Wert zu √§ndern.  Sie legen den Wertebereich √ºber <b>ValueAnimator.ofFloat</b> f√ºr den primitiven Float-Typ von 0 bis 100 fest. Geben Sie den Wert f√ºr die <b>Dauer</b> an und starten Sie die Animation. <br>  Betrachten Sie ein Beispiel: <br><br><pre><code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> animator = ValueAnimator.ofFloat(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">100f</span></span>) animator.duration = <span class="hljs-number"><span class="hljs-number">1000</span></span> animator.start() animator.addUpdateListener(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : ValueAnimator.AnimatorUpdateListener { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ValueAnimator</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> animatedValue = animation.animatedValue <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> textView.translationX = animatedValue } })</code> </pre> <br>  Hier f√ºgen wir den <b>UpdateListener hinzu</b> und verschieben mit jedem Update unsere Ansicht horizontal und √§ndern ihre Position von 0 auf 100, obwohl dies keine sehr gute M√∂glichkeit ist, diesen Vorgang auszuf√ºhren. <br><br><h3>  ObjectAnimator </h3><br>  Ein weiteres Beispiel f√ºr die Implementierung einer Animation ist ObjectAnimator: <br><br><pre> <code class="hljs pgsql">val objectAnimator = ObjectAnimator.ofFloat(textView, "translationX", <span class="hljs-number"><span class="hljs-number">100</span></span>f) objectAnimator.duration = <span class="hljs-number"><span class="hljs-number">1000</span></span> objectAnimator.<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>()</code> </pre> <br>  Wir geben ihm den Befehl, den spezifischen View-Parameter auf den angegebenen Wert in die gew√ºnschte View zu √§ndern und die Zeit mit der <b>setDuration-</b> Methode <b>einzustellen</b> .  Die <b>Quintessenz</b> ist, dass Ihre Klasse die <b>setTranslationX-</b> Methode haben muss, dann wird das System diese Methode durch Reflexion finden und dann wird die Ansicht animiert.  Das Problem ist, dass hier Reflexion verwendet wird. <br><br><h3>  Animatorset </h3><br>  Betrachten Sie nun die <b>AnimatorSet-</b> Klasse: <br><br><pre> <code class="hljs pgsql">val bouncer = AnimatorSet() bouncer.play(bounceAnim).<span class="hljs-keyword"><span class="hljs-keyword">before</span></span>(squashAnim1) bouncer.play(squashAnim1).<span class="hljs-keyword"><span class="hljs-keyword">before</span></span>(squashAnim2) val fadeAnim = ObjectAnimator.ofFloat(newBall, "alpha", <span class="hljs-number"><span class="hljs-number">1</span></span>f, <span class="hljs-number"><span class="hljs-number">0</span></span>f) fadeAnim.duration = <span class="hljs-number"><span class="hljs-number">250</span></span> val animatorSet = AnimatorSet() animatorSet.play(bouncer).<span class="hljs-keyword"><span class="hljs-keyword">before</span></span>(fadeAnim) animatorSet.<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>()</code> </pre> <br>  In der Tat ist es nicht sehr bequem zu verwenden, insbesondere f√ºr eine gro√üe Anzahl von Objekten.  Wenn Sie komplexere Animationen erstellen m√∂chten, legen Sie beispielsweise eine Verz√∂gerung zwischen dem Erscheinen von Animationen fest. Je mehr Animationen Sie ausf√ºhren m√∂chten, desto schwieriger ist die Steuerung. <br><br><h3>  ViewPropertyAnimator </h3><br>  Die letzte Klasse ist <b>ViewPropertyAnimator</b> .  Es ist eine der besten Klassen zum Animieren von View.  Dies ist eine gro√üartige API zum Einf√ºhren einer Folge von Animationen, die Sie ausf√ºhren: <br><br><pre> <code class="hljs kotlin">ViewCompat.animate(textView) .translationX(<span class="hljs-number"><span class="hljs-number">50f</span></span>) .translationY(<span class="hljs-number"><span class="hljs-number">100f</span></span>) .setDuration(<span class="hljs-number"><span class="hljs-number">1000</span></span>) .setInterpolator(AccelerateDecelerateInterpolator()) .setStartDelay(<span class="hljs-number"><span class="hljs-number">50</span></span>) .setListener(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : Animator.AnimatorListener { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationRepeat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Animator</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Animator</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationCancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Animator</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationStart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Animator</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} })</code> </pre><br>  Wir starten die <b>ViewCompat.animate-</b> Methode, die <b>ViewPropertyAnimator zur√ºckgibt</b> , und setzen f√ºr die Animation <b>√ºbersetzenX</b> den Wert auf 50, f√ºr den Parameter <b>translatonY</b> auf 100. Dann geben wir die Dauer der Animation sowie den Interpolator an.  Der Interpolator bestimmt die Reihenfolge, in der Animationen angezeigt werden.  In diesem Beispiel wird ein Interpolator verwendet, der den Start der Animation beschleunigt und am Ende eine Verlangsamung hinzuf√ºgt.  Wir f√ºgen auch eine Verz√∂gerung hinzu, um die Animation zu starten.  Zus√§tzlich haben wir einen <b>AnimatorListener</b> .  Damit k√∂nnen Sie bestimmte Ereignisse abonnieren, die w√§hrend der Animation auftreten.  Diese Schnittstelle verf√ºgt √ºber 4 Methoden: <b>onAnimationStart</b> , <b>onAnimationCancel</b> , <b>onAnimationEnd</b> , <b>onAnimationRepeat</b> . <br><br>  In der Regel sind wir nur daran interessiert, die Animation zu vervollst√§ndigen.  In API Level 16 <br>  hinzugef√ºgt mitEndAction: <br><br><pre> <code class="hljs pgsql">.withEndAction({ //API <span class="hljs-number"><span class="hljs-number">16</span></span>+ //<span class="hljs-keyword"><span class="hljs-keyword">do</span></span> something here <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> animation ends })</code> </pre> <br>  Darin k√∂nnen Sie die <b>Runnable-</b> Oberfl√§che definieren. Nach Abschluss einer bestimmten Animation wird eine Aktion ausgef√ºhrt. <br><br>  Nun ein paar Kommentare zum Prozess der Erstellung von Animationen im Allgemeinen: <br><br><ol><li>  Die <b>start ()</b> -Methode ist optional: Sobald Sie die <b>animate ()</b> -Methode aufrufen, wird eine Folge von Animationen eingef√ºhrt.  Wenn der <b>ViewPropertyAnimator</b> konfiguriert ist, startet das System die Animation, sobald es dazu bereit ist. </li><li>  Nur eine <b>ViewPropertyAnimator-</b> Klasse kann nur eine bestimmte Ansicht animieren.  Wenn Sie beispielsweise mehrere Animationen ausf√ºhren m√∂chten, um etwas zu verschieben und gleichzeitig die Gr√∂√üe zu erh√∂hen, m√ºssen Sie dies in einem Animator angeben. </li></ol><br><h3>  Warum haben wir uns f√ºr RxJava entschieden? </h3><br>  Beginnen wir mit einem einfachen Beispiel.  Angenommen, wir erstellen eine FadeIn-Methode: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, duration: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Completable { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> animationSubject = CompletableSubject.create() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> animationSubject.doOnSubscribe { ViewCompat.animate(view) .setDuration(duration) .alpha(<span class="hljs-number"><span class="hljs-number">1f</span></span>) .withEndAction { animationSubject.onComplete() } } }</code> </pre> <br>  Dies ist eine ziemlich primitive L√∂sung, und um sie auf Ihr Projekt anzuwenden, m√ºssen Sie einige Nuancen ber√ºcksichtigen. <br><br>  Wir werden ein <b>CompletableSubject</b> erstellen, mit dem wir warten, bis die Animationen abgeschlossen sind, und dann die <b>onComplete-</b> Methode verwenden, um Nachrichten an Abonnenten zu senden.  Um Animationen nacheinander auszuf√ºhren, m√ºssen Sie die Animation nicht sofort starten, sondern sobald jemand sie abonniert.  Auf diese Weise k√∂nnen Sie mehrere Animationen im reaktiven Stil nacheinander ausf√ºhren. <br><br>  Betrachten Sie die Animation selbst.  Darin √ºbertragen wir die Ansicht, √ºber die die Animation ausgef√ºhrt wird, und geben auch die Dauer der Animation an.  Und da diese Animation Erscheinungsbild ist, m√ºssen wir Transparenz 1 angeben. <br><br>  Versuchen wir, unsere Methode zu verwenden und eine einfache Animation zu erstellen.  Angenommen, wir haben 4 Schaltfl√§chen auf dem Bildschirm und m√∂chten f√ºr sie eine Animation mit einer Dauer von 1 Sekunde hinzuf√ºgen: <br><br><pre> <code class="hljs go">val durationMs = <span class="hljs-number"><span class="hljs-number">1000</span></span>L button1.alpha = <span class="hljs-number"><span class="hljs-number">0f</span></span> button2.alpha = <span class="hljs-number"><span class="hljs-number">0f</span></span> button3.alpha = <span class="hljs-number"><span class="hljs-number">0f</span></span> button4.alpha = <span class="hljs-number"><span class="hljs-number">0f</span></span> fadeIn(button1, durationMs) .andThen(fadeIn(button2, durationMs)) .andThen(fadeIn(button3, durationMs)) .andThen(fadeIn(button4, durationMs)) .subscribe()</code> </pre><br>  Das Ergebnis ist solch ein pr√§gnanter Code.  Mit dem Operator <b>andThen</b> k√∂nnen <b>Sie</b> Animationen nacheinander ausf√ºhren.  Wenn wir es abonnieren, sendet es das <b>doOnSubscribe-</b> Ereignis an <b>Completable</b> , das das erste in der Ausf√ºhrungswarteschlange ist.  Nach seiner Fertigstellung wird er die zweite, dritte usw. der Kette abonnieren.  Wenn daher irgendwann ein Fehler auftritt, l√∂st die gesamte Sequenz einen Fehler aus.  Sie m√ºssen vor dem Start der Animation auch Alpha 0 angeben, damit die Schaltfl√§chen nicht sichtbar sind.  Und so wird es aussehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sq/-m/02/sq-m02uv2i1uu85udver9fwzqww.gif"></div><br>  Mit <b>Kotlin</b> k√∂nnen wir die Erweiterungen verwenden: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(duration: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Completable { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> animationSubject = CompletableSubject.create() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> animationSubject.doOnSubscribe { ViewCompat.animate(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .setDuration(duration) .alpha(<span class="hljs-number"><span class="hljs-number">1f</span></span>) .withEndAction { animationSubject.onComplete() } } }</code> </pre> <br>  F√ºr die View-Klasse wurde eine Erweiterungsfunktion hinzugef√ºgt.  In Zukunft muss das View-Argument nicht mehr an die fadeIn-Methode √ºbergeben werden.  Jetzt k√∂nnen Sie alle Aufrufe von View durch das Schl√ºsselwort this in der Methode ersetzen.  Dazu ist <b>Kotlin</b> in der Lage <b>.</b> <br><br>  Mal sehen, wie sich der Aufruf dieser Funktion in unserer Animationskette ge√§ndert hat: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">button1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">durationMs</span></span>) <span class="hljs-selector-class"><span class="hljs-selector-class">.andThen</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">durationMs</span></span>)) <span class="hljs-selector-class"><span class="hljs-selector-class">.andThen</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button3</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">durationMs</span></span>)) <span class="hljs-selector-class"><span class="hljs-selector-class">.andThen</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button4</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">durationMs</span></span>)) <span class="hljs-selector-class"><span class="hljs-selector-class">.subscribe</span></span>()</code> </pre><br>  Jetzt sieht der Code verst√§ndlicher aus.  Es wird klargestellt, dass wir eine Animation mit einer bestimmten Dauer auf die gew√ºnschte Anzeige anwenden m√∂chten.  Mit dem Operator <b>andThen</b> erstellen <b>wir</b> eine sequentielle Kette von Animationen f√ºr die zweite, dritte Schaltfl√§che usw. <br><br>  Wir geben immer die Dauer der Animationen an, dieser Wert ist f√ºr alle Anzeigen gleich - 1000 Millisekunden.  <b>Kotlin</b> kommt wieder zur Rettung.  Wir k√∂nnen einen Standardzeitwert festlegen. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(duration: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1000</span></span></span></span><span class="hljs-function"><span class="hljs-params">L)</span></span></span></span>:</code> </pre> <br>  Wenn Sie den Parameter <b>dauer</b> nicht angeben, wird die Zeit automatisch auf 1 Sekunde eingestellt.  Wenn wir jedoch m√∂chten, dass die Schaltfl√§che bei Nummer 2 diese Zeit auf 2 Sekunden erh√∂ht, geben wir diesen Wert einfach in der Methode an: <br><br><pre> <code class="hljs erlang">button1.fadeIn() .<span class="hljs-keyword"><span class="hljs-keyword">and</span></span>Then(button2.fadeIn(duration = <span class="hljs-number"><span class="hljs-number">2000</span></span>L)) .<span class="hljs-keyword"><span class="hljs-keyword">and</span></span>Then(button3.fadeIn()) .<span class="hljs-keyword"><span class="hljs-keyword">and</span></span>Then(button4.fadeIn()) .subscribe()</code> </pre><br><h3>  Ausf√ºhren von zwei Animationen </h3><br>  Mit dem Operator <b>andThen</b> konnten wir eine Folge von Animationen <b>ausf√ºhren</b> .  Was ist, wenn ich 2 Animationen gleichzeitig ausf√ºhren muss?  Zu diesem <b>Zweck</b> gibt es in <b>RxJava</b> einen <b>mergeWith-</b> Operator, mit dem Sie <b>Completable-</b> Elemente so kombinieren k√∂nnen, dass sie gleichzeitig gestartet werden.  Diese Anweisung startet alle Elemente und endet, nachdem das letzte Element angezeigt wurde.  Wenn wir √§ndern <b>und</b> dann <b>zusammenf√ºhren</b> , erhalten wir eine Animation, in der alle Schaltfl√§chen gleichzeitig <b>angezeigt werden</b> , Schaltfl√§che 2 jedoch etwas l√§nger als die anderen: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">button1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>() <span class="hljs-selector-class"><span class="hljs-selector-class">.mergeWith</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>(2000)) <span class="hljs-selector-class"><span class="hljs-selector-class">.mergeWith</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button3</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>()) <span class="hljs-selector-class"><span class="hljs-selector-class">.mergeWith</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button4</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>()) <span class="hljs-selector-class"><span class="hljs-selector-class">.subscribe</span></span>()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jd/fw/xb/jdfwxbgedu3gnufrsrfqezc46ga.gif"></div><br>  Jetzt k√∂nnen wir Animationen gruppieren.  Versuchen wir, die Aufgabe zu verkomplizieren: Wir m√∂chten beispielsweise, dass die Schaltfl√§chen 1 und 2 gleichzeitig angezeigt werden und dann die Schaltfl√§chen 3 und 4: <br><br><pre> <code class="hljs css">(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>()<span class="hljs-selector-class"><span class="hljs-selector-class">.mergeWith</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>())) <span class="hljs-selector-class"><span class="hljs-selector-class">.andThen</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button3</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>()<span class="hljs-selector-class"><span class="hljs-selector-class">.mergeWith</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button4</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>())) <span class="hljs-selector-class"><span class="hljs-selector-class">.subscribe</span></span>()</code> </pre> <br>  Wir kombinieren die erste und zweite Schaltfl√§che mit dem Operator <b>mergeWith</b> , wiederholen die Aktion f√ºr die dritte und vierte und starten diese Gruppen nacheinander mit dem Operator <b>andThen</b> .  Jetzt verbessern wir den Code durch Hinzuf√ºgen der <b>fadeInTogether-</b> Methode: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeInTogether</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, second: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Completable { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first.fadeIn() .mergeWith(second.fadeIn()) }</code> </pre> <br>  Damit k√∂nnen Sie die FadeIn-Animation f√ºr zwei Ansichten gleichzeitig ausf√ºhren.  Wie sich die Animationskette ver√§ndert hat: <br><br><pre> <code class="hljs erlang"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeInTogether</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(button1, button2)</span></span></span><span class="hljs-function"> .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">andThen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fadeInTogether(button3, button4))</span></span></span><span class="hljs-function"> .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre> <br>  Das Ergebnis ist die folgende Animation: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hk/xw/pe/hkxwpemdtbmksyv_r7mq2qx3bcw.gif"></div><br>  Betrachten Sie ein komplexeres Beispiel.  Angenommen, wir m√ºssen eine Animation mit einer bestimmten Verz√∂gerung anzeigen.  Die <b>Intervallanweisung</b> hilft: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> timeObservable = Observable.interval(<span class="hljs-number"><span class="hljs-number">100</span></span>, TimeUnit.MILLISECONDS) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> btnObservable = Observable.just(button1, button2, button3, button4) }</code> </pre> <br>  Alle 100 Millisekunden werden Werte generiert.  Jede Schaltfl√§che wird nach 100 Millisekunden angezeigt.  Als n√§chstes geben wir ein anderes Observable an, das Schaltfl√§chen ausgibt.  In diesem Fall haben wir 4 Tasten.  Wir verwenden den <b>Zip-</b> Operator. <br><br><img src="https://habrastorage.org/webt/g5/qq/yi/g5qqyih178patmj5cjpfyoevkkw.png" alt="Bild"><br><br>  Vor uns liegen die Ereignisse: <br><br><pre> <code class="hljs mel">Observable.zip(timeObservable, btnObservable, BiFunction&lt;Long, View, Disposable&gt; { _, <span class="hljs-keyword"><span class="hljs-keyword">button</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">button</span></span>.fadeIn().subscribe() })</code> </pre> <br>  Der erste entspricht <b>timeObservable</b> .  Dieses <b>Observable</b> generiert in regelm√§√üigen Abst√§nden Zahlen.  Angenommen, es sind 100 Millisekunden. <br><br>  Das zweite <b>Observable</b> generiert eine Ansicht.  Der <b>Zip-</b> Operator wartet, bis das erste Objekt im ersten Thread angezeigt wird, und verbindet es mit dem ersten Objekt aus dem zweiten Thread.  Trotz der Tatsache, dass alle diese 4 Objekte im zweiten Thread sofort erscheinen, wartet er, bis die Objekte im ersten Thread erscheinen.  Somit wird das erste Objekt aus dem ersten Stream in Form unserer Ansicht mit dem ersten Objekt aus dem zweiten Objekt verbunden, und 100 Millisekunden sp√§ter, wenn ein neues Objekt angezeigt wird, kombiniert der Bediener es mit dem zweiten Objekt.  Daher wird die Ansicht mit einer gewissen Verz√∂gerung angezeigt. <br><br>  <b>Besch√§ftigen</b> wir uns mit <b>BiFinction</b> in <b>RxJava</b> .  Diese Funktion empf√§ngt zwei Objekte als Eingabe, f√ºhrt einige Operationen an ihnen aus und gibt ein drittes Objekt zur√ºck.  Wir m√∂chten uns Zeit nehmen und Objekte <b>anzeigen</b> und verf√ºgbar machen, da wir die <b>fadeIn-</b> Animation <b>aufrufen</b> und abonnieren, um zu <b>abonnieren</b> .  Der Wert der Zeit ist uns nicht wichtig.  Als Ergebnis erhalten wir diese Animation: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8q/wa/1z/8qwa1z75xolp2jb-hsznqzncykw.gif"></div><br><h3>  Vanogogh </h3><br>  Ich erz√§hle Ihnen von dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projekt</a> , das Ivan f√ºr MBLT DEV 2017 entwickelt hat. <br><br>  Die von Ivan entwickelte Bibliothek pr√§sentiert verschiedene Muscheln f√ºr Animationen.  Wir haben dies bereits oben ber√ºcksichtigt.  Es enth√§lt auch vorgefertigte Animationen, die Sie verwenden k√∂nnen.  Sie erhalten eine Reihe allgemeiner Tools zum Erstellen eigener Animationen.  Diese Bibliothek bietet Ihnen leistungsf√§higere Komponenten f√ºr die reaktive Programmierung. <br><br>  Betrachten Sie die Bibliothek anhand eines Beispiels: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> : AnimationCompletable { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AnimationBuilder.forView(view) .alpha(<span class="hljs-number"><span class="hljs-number">1f</span></span>) .duration(<span class="hljs-number"><span class="hljs-number">2000L</span></span>) .build().toCompletable() }</code> </pre> <br>  Angenommen, Sie m√∂chten eine angezeigte Animation erstellen, diesmal wird jedoch anstelle des <b>Completable-</b> Objekts eine <b>AnimationCompletable</b> angezeigt.  Diese Klasse erbt von <b>Completable</b> , sodass jetzt mehr Funktionen angezeigt werden.  Ein wichtiges Merkmal des vorherigen Codes war, dass es unm√∂glich war, Animationen abzubrechen.  Jetzt k√∂nnen Sie ein <b>AnimationCompletable-</b> Objekt erstellen, mit dem die Animation gestoppt wird, sobald wir uns abmelden. <br><br>  Erstellen Sie eine neue Animation mit <b>AnimationBuilder</b> - einer der Bibliotheksklassen.  Geben Sie an, auf welche Ansicht die Animation angewendet werden soll.  Im Wesentlichen kopiert diese Klasse das Verhalten von <b>ViewPropertyAnimator</b> , jedoch mit dem Unterschied, dass die Ausgabe ein Stream ist. <br><br>  Als n√§chstes setzen Sie Alpha 1f und die Dauer betr√§gt 2 Sekunden.  Dann sammeln wir die Animation.  Sobald wir <b>die Build-</b> Anweisung <b>aufrufen,</b> wird eine Animation angezeigt.  Wir weisen Animationen die Eigenschaft eines unver√§nderlichen Objekts zu, damit diese Eigenschaften f√ºr den Start gespeichert werden.  Die Animation selbst wird jedoch nicht gestartet. <br><br>  Rufen Sie <b>toCompletable auf</b> , um eine <b>AnimationCompletable zu</b> erstellen.  Die Parameter dieser Animation werden in eine Art Shell f√ºr die reaktive Programmierung eingeschlossen, und sobald Sie sie abonnieren, wird die Animation gestartet.  Wenn Sie es ausschalten, bevor der Vorgang abgeschlossen ist, wird die Animation beendet.  Sie k√∂nnen jetzt auch eine R√ºckruffunktion hinzuf√ºgen.  Sie k√∂nnen die Operatoren <b>doOnAnimationReady</b> , <b>doOnAnimationStart</b> , <b>doOnAnimationEnd</b> und dergleichen schreiben: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> : AnimationCompletable { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AnimationBuilder.forView(view) .alpha(<span class="hljs-number"><span class="hljs-number">1f</span></span>) .duration(<span class="hljs-number"><span class="hljs-number">2000L</span></span>) .buildCompletable() .doOnAnimationReady { view.alpha = <span class="hljs-number"><span class="hljs-number">0f</span></span> } }</code> </pre> <br>  In diesem Beispiel haben wir gezeigt, wie bequem es ist, <b>AnimationBuilder</b> zu verwenden, und den Status unserer Ansicht ge√§ndert, bevor die Animation gestartet wird. <br><br><h3>  Video melden </h3><br>  Wir haben uns eine der Optionen zum Erstellen, Komponieren und Optimieren von Animationen mit Kotlin und RxJava angesehen.  Hier ist ein Link zu einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projekt</a> , das grundlegende Animationen und Beispiele f√ºr diese sowie die Hauptschalen f√ºr die Arbeit mit Animationen beschreibt. <br><br>  Zus√§tzlich zur Entschl√ºsselung teile ich ein Video des Berichts: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Yv80bdUnJgw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Referenten MBLT DEV 2018 </h3><br>  Vor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MBLT DEV 2018</a> verbleiben noch etwas mehr als zwei Monate.  Wir werden folgende Auff√ºhrungen haben: <br><br><ul><li>  Laura Morinigo, Google Entwickler-Expertin </li><li>  Kaushik Gopal, Autor des fragmentierten Podcasts </li><li>  Artyom Rudoi, Badoo </li><li>  Dina Sidorova, Google und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">andere</a> . </li></ul><br>  Morgen wird sich der Ticketpreis √§ndern.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Registrieren Sie sich noch</a> heute. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418383/">https://habr.com/ru/post/de418383/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418371/index.html">Mikrotask f√ºr Programmierer und eine alternative Zahlungsmethode in Kryptow√§hrung</a></li>
<li><a href="../de418375/index.html">√úbersicht √ºber Uniz Slash + 3D-Fotodrucker</a></li>
<li><a href="../de418377/index.html">Kotlin: zwei L√∂ffel Teer in einem Fass Honig</a></li>
<li><a href="../de418379/index.html">Bioelektrische Kinderprothese. Teil 2</a></li>
<li><a href="../de418381/index.html">Was ist neu in DevTools in Chrome Version 68?</a></li>
<li><a href="../de418385/index.html">Wie ich einen Computer f√ºr alte Spiele zusammengebaut habe</a></li>
<li><a href="../de418387/index.html">Physiker Dialog √ºber die Seele</a></li>
<li><a href="../de418389/index.html">RabbitMQ vs. Kafka: Verwenden von Kafka in ereignisorientierten Anwendungen</a></li>
<li><a href="../de418391/index.html">OSPF (Teil 1)</a></li>
<li><a href="../de418393/index.html">[Freitag] Wie wir 3D Web ges√§gt haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>