<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖌️ ✋🏾 😿 Nous écrivons une «calculatrice» en C #. Partie I. Calcul de la valeur, dérivé, simplification et autres oies 👨🏻‍🚒 🦍 🚓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut 

 Pour une raison quelconque, notre calculatrice est associée à quelque chose que chaque débutant devrait écrire. Peut-être parce que les ordin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous écrivons une «calculatrice» en C #. Partie I. Calcul de la valeur, dérivé, simplification et autres oies</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482228/">  Salut <br><br>  Pour une raison quelconque, notre calculatrice est associée à quelque chose que chaque débutant devrait écrire.  Peut-être parce que les ordinateurs ont été créés à cet effet pour compter.  Mais nous écrirons une calculatrice difficile, pas sympa bien sûr, mais pour pouvoir faire des opérations algébriques de base, comme la différenciation, la simplification, et des fonctionnalités comme la compilation pour accélérer les calculs. <br><br><div class="spoiler">  <b class="spoiler_title">Moins d'eau!</b>  <b class="spoiler_title">De quoi parle l'article?</b> <div class="spoiler_text">  Ici, il sera superficiel de construire une expression, d'analyser à partir d'une chaîne, de substitution de variables, de dérivé analytique, de résoudre numériquement une équation et une certaine intégrale, de rendre au format LaTeX, de nombres complexes, de compiler des fonctions, de simplifier, d'étendre les crochets et de bla bla bla.  Probablement pas dans un article. <br>  <i>Pour ceux qui ont un besoin urgent de cloner quelque chose, un <a href="https://github.com/Angourisoft/MathS" rel="nofollow">lien vers le référentiel</a> .</i> <br></div></div><br>  Nous prenons les cookies restants de la nouvelle année, et avons roulé! <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">À qui s'adresse cet article?</b> <div class="spoiler_text">  Je pense que l'article peut être utile à un débutant, mais peut-être que ceux qui sont un peu plus expérimentés trouveront aussi quelque chose d'intéressant.  Cependant, j'espère écrire un article afin qu'il puisse être lu sans être du tout programmeur C #. <br></div></div><br><h2>  Assemblage d'expression </h2><br><h3>  Qu'est-ce qu'une expression? </h3><br><div class="spoiler">  <b class="spoiler_title">Quand j'étais petit ...</b> <div class="spoiler_text">  Ensuite, bien sûr, je voulais écrire une calculatrice.  Que devrait-il pouvoir faire?  Quatre opérations de base, et en principe bien plus.  Donc, ma tâche était de calculer la valeur d'une expression de chaîne, par exemple, «1 + (3/4 - (5 + 3 * 1))».  J'ai pris mon dauphin préféré et j'ai écrit un analyseur, qui est d'abord récursivement placé entre crochets, puis a remplacé l'expression entre crochets par une valeur et a supprimé les crochets.  Fondamentalement, une façon tout à fait fonctionnelle pour moi à cette époque. <br></div></div><br>  Bien sûr, ce n'est pas une ligne.  Il est assez évident qu'une formule mathématique est soit un arbre, soit une pile, et ici nous nous arrêtons au premier.  Autrement dit, chaque nœud, chaque nœud de cet arbre, est une sorte d'opération, variable ou constante. <br><br><img src="https://habrastorage.org/webt/ih/id/g2/ihidg2enlm7vi-es5t5agdoplks.png"><br><br>  Une opération est soit une fonction, soit un opérateur, en principe, à peu près la même chose.  Ses enfants sont les arguments d'une fonction (opérateur). <br><br><h3>  Hiérarchie des classes dans votre code </h3><br>  Bien sûr, l'implémentation peut être quelconque.  Cependant, l'idée est que si votre arbre se compose uniquement de nœuds et de feuilles, ils sont différents.  Par conséquent, j'appelle ces «choses» - des entités.  Par conséquent, la classe supérieure sera l'entité de classe abstraite. <br><br><div class="spoiler">  <b class="spoiler_title">Abstrait?</b> <div class="spoiler_text">  Comme tout le monde le sait grâce à l'apprentissage des langues de base, une classe abstraite est bonne car elle généralise certaines classes d'une part, et d'autre part vous permet de séparer la logique et le comportement de certains objets.  Un objet d'une classe abstraite ne peut pas être créé, mais son héritier le peut. <br></div></div><br>  Et il y aura également quatre classes successives: NumberEntity, VariableEntity, OperatorEntity, FunctionEntity. <br><br><h3>  Comment construire une expression? </h3><br>  Tout d'abord, nous allons construire une expression dans le code, c'est-à-dire <br><br><pre><code class="plaintext hljs">var x = new VariableEntity("x"); var expr = x * x + 3 * x + 12;</code> </pre> <br>  Si vous déclarez une classe VariableEntity vide, un tel code vous générera une erreur, disent-ils, ne sait pas comment multiplier et additionner. <br><br><h5>  Remplacer les opérateurs </h5><br>  Une fonctionnalité très importante et utile de la plupart des langues, vous permettant de personnaliser l'exécution des opérations arithmétiques.  Il est implémenté syntaxiquement différemment selon la langue.  Par exemple, une implémentation en C # <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> YourClass <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> +(YourClass a, YourClass b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> YourClass(a.ToString() + b.ToString()); }</code> </pre><br>  <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/operator-overloading" rel="nofollow">En savoir plus sur la substitution des instructions en C #</a> <br>  Le navet est implémenté <a href="" rel="nofollow">ici</a> . <br><br><h5>  Casting (non) explicite </h5><br>  Dans les langages compilés tels que C #, une telle chose est généralement présente et vous permet de transtyper le type si nécessaire sans appeler en plus myvar.ToAnotherType ().  Ainsi, par exemple, il serait pratique d'écrire <br><br><pre> <code class="plaintext hljs">NumberEntity myvar = 3;</code> </pre><br>  Au lieu de l'habituel <br><br><pre> <code class="plaintext hljs">NumberEntity myvar = new NumberEntity(3);</code> </pre><br>  <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/user-defined-conversion-operators" rel="nofollow">En savoir plus sur la coulée de caractères en C #</a> <br>  Le navet est mis en place sur <a href="" rel="nofollow">cette</a> ligne. <br><br><h5>  Accrocher </h5><br>  La classe Entity a un champ Enfants - ce n'est qu'une liste d'entités, qui sont les arguments de cette entité. <br><br><div class="spoiler">  <b class="spoiler_title">Réflexions</b> <div class="spoiler_text">  En fait, seules deux classes d'objets peuvent avoir des enfants: OperatorEntity et FunctionEntity.  Autrement dit, vous pouvez en principe créer une sorte de NodeEntity et en hériter ces deux classes, créer une LeafEntity et en hériter VariableEntity et NumberEntity. <br><img src="https://habrastorage.org/webt/ft/i6/kj/fti6kj3h23-tmsd8g30gyyqtyks.png"><br></div></div><br>  Lorsque nous appelons une fonction ou un opérateur, nous devons créer une nouvelle entité et y mettre les enfants à partir desquels la fonction ou l'opérateur est appelé.  Par exemple, le montant en théorie devrait ressembler à ceci: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Entity <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> +(Entity a, Entity b){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OperatorEntity(<span class="hljs-string"><span class="hljs-string">"+"</span></span>); res.Children.Add(a); res.Children.Add(b); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre><br>  Autrement dit, si nous avons l'entité x et l'entité 3, alors x + 3 renverra l'essence de l'opérateur de somme avec deux enfants: 3 et x.  Ainsi, nous pouvons construire des arbres d'expression. <br><br>  Un appel de fonction est plus simple et pas aussi beau qu'avec un opérateur: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sin</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Entity a</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FunctionEntity(<span class="hljs-string"><span class="hljs-string">"sin"</span></span>); res.Children.Add(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre><br>  La pendaison de navets est implémentée <a href="" rel="nofollow">ici</a> . <br><br>  Ok, nous avons créé un arbre d'expression. <br><br><h2>  Substitution variable </h2><br>  Ici, tout est extrêmement simple.  Nous avons Entity - nous vérifions s'il s'agit d'une variable elle-même, si c'est le cas, nous renvoyons la valeur, sinon nous parcourons les enfants. <br><br>  <a href="" rel="nofollow">Cet</a> énorme fichier de 48 lignes implémente une fonction aussi complexe. <br><br><h2>  Calcul de la valeur </h2><br>  En fait, pour ce que tout cela est.  Ici, nous sommes censés ajouter une sorte de méthode à Entity <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Eval</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsLeaf) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MathFunctions.InvokeEval(Name, Children); }</code> </pre><br>  La feuille est inchangée, mais pour tout le reste, nous avons un calcul personnalisé.  Encore une fois, je vais donner un exemple: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Eval</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;Entity&gt; args</span></span></span><span class="hljs-function">)</span></span> { MathFunctions.AssertArgs(args.Count, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = args[<span class="hljs-number"><span class="hljs-number">0</span></span>].Eval(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> NumberEntity) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NumberEntity(Number.Sin((r <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> NumberEntity).Value)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r.Sin(); }</code> </pre><br>  Si l'argument est un nombre, alors nous produirons une fonction numérique, sinon nous le renverrons tel qu'il était. <br><br><h3>  Numéro? </h3><br>  C'est l'unité, le nombre le plus simple.  Des opérations arithmétiques peuvent y être effectuées.  Par défaut, c'est complexe.  Il a également des opérations telles que Sin, Cos et d'autres définies. <br><br>  Si vous êtes intéressé, le numéro est décrit <a href="" rel="nofollow">ici</a> . <br><br><h2>  Dérivé </h2><br>  Tout le monde peut calculer la dérivée numériquement, et une telle fonction s'écrit vraiment sur une seule ligne: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Derivative</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Func&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; f, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> =&gt; (f(x + <span class="hljs-number"><span class="hljs-number">1.0e-5</span></span>) - f(x)) * <span class="hljs-number"><span class="hljs-number">1.0e+5</span></span>;</code> </pre><br>  Mais bien sûr, nous voulons un dérivé analytique.  Puisque nous avons déjà un arbre d'expression, nous pouvons remplacer récursivement chaque nœud conformément à la règle de différenciation.  Cela devrait fonctionner comme ceci: <br><br><img src="https://habrastorage.org/webt/6g/7t/6c/6g7t6ctcfoill4nroqcknz6gaa4.png"><br><br>  Voici, par exemple, comment le montant est implémenté dans mon code: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Derive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;Entity&gt; args, VariableEntity variable</span></span></span><span class="hljs-function">)</span></span> { MathFunctions.AssertArgs(args.Count, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = args[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.Derive(variable) + b.Derive(variable); }</code> </pre><br>  Mais le travail <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Derive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;Entity&gt; args, VariableEntity variable</span></span></span><span class="hljs-function">)</span></span> { MathFunctions.AssertArgs(args.Count, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = args[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.Derive(variable) * b + b.Derive(variable) * a; }</code> </pre><br>  Et voici une solution de contournement en soi: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Derive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">VariableEntity x</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsLeaf) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> VariableEntity &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Name == x.Name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NumberEntity(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NumberEntity(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MathFunctions.InvokeDerive(Name, Children, x); }</code> </pre><br>  Il s'agit de la méthode Entity.  Et comme nous le voyons, la feuille n'a que deux états - soit c'est une variable par laquelle nous différencions, puis sa dérivée est 1, ou c'est une constante (nombre ou VariableEntity), puis sa dérivée est 0, ou un nœud, puis il y a une référence par nom (InvokeDerive fait référence au dictionnaire de fonctions, où se trouve celle désirée (par exemple, la somme ou le sinus)). <br><br>  Notez que je ne laisse pas quelque chose comme dy / dx ici et dis tout de suite que la dérivée de la variable <b>non</b> par laquelle nous différencions est 0. Mais ici, <a href="https://habr.com/ru/post/150043/">cela se</a> fait différemment. <br><br>  Toute différenciation est décrite dans <a href="" rel="nofollow">un seul fichier</a> , mais plus n'est pas nécessaire. <br><br><h2>  Simplification de l'expression.  Patterns </h2><br>  La simplification de l'expression n'est généralement pas triviale en principe.  Eh bien, par exemple, quelle expression est la plus simple: <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-msubsup" id="MJXp-Span-2"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-3" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-4" style="vertical-align: 0.5em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-5" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-msubsup" id="MJXp-Span-6"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-7" style="margin-right: 0.05em;">y</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-8" style="vertical-align: 0.5em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-1"> x ^ 2 - y ^ 2 </script>  ou <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-9"><span class="MJXp-mo" id="MJXp-Span-10" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11">x</span><span class="MJXp-mo" id="MJXp-Span-12" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-13">y</span><span class="MJXp-mo" id="MJXp-Span-14" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-15" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-16">x</span><span class="MJXp-mo" id="MJXp-Span-17" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-18">y</span><span class="MJXp-mo" id="MJXp-Span-19" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-2"> (x - y) (x + y) </script>  ?  Mais nous adhérons à certaines idées, et sur la base de celles-ci, nous voulons établir ces règles qui simplifient précisément l'expression. <br><br>  Il est possible d'écrire à chaque Eval que si nous avons la somme et que les enfants sont des œuvres, alors nous trierons quatre options, et si quelque chose est égal quelque part, nous éliminerons le facteur ... Mais bien sûr, je ne veux pas faire ça.  Par conséquent, vous pouvez deviner le système de règles et de modèles.  Alors que voulons-nous?  Quelque chose comme cette syntaxe: <br><br><pre> <code class="plaintext hljs">{ any1 / (any2 / any3) -&gt; any1 * any3 / any2 }, { const1 * var1 + const2 * var1 -&gt; (const1 + const2) * var1 }, { any1 + any1 * any2 -&gt; any1 * (Num(1) + any2) },</code> </pre><br>  Voici un exemple d'arbre dans lequel un sous-arbre a été trouvé (encerclé en vert) qui correspond au modèle any1 + const1 * any1 (any1 trouvé est encerclé en orange). <br><br><img src="https://habrastorage.org/webt/fe/jp/-l/fejp-l9krgdtvhw8d-ccpcekuko.png"><br><br>  Comme vous pouvez le voir, il est parfois important pour nous que la même entité soit répétée, par exemple, pour raccourcir l'expression x + a * x, nous avons besoin de x pour être là et là, car x + a * y n'est plus réduit.  Par conséquent, nous devons créer un algorithme qui non seulement vérifie que l’arbre correspond au modèle, mais <br><br><ol><li>  Vérifiez que le même modèle d'entité correspond à la même entité. </li><li>  Ecrire ce qui correspond à quoi, puis substituer. </li></ol><br>  Le point d'entrée ressemble à ceci: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> Dictionary&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">, Entity&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EqFits</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Entity tree</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, Entity&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tree.PatternMakeMatch(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, res)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre><br>  Et dans tree.PaternMakeMatch, nous remplissons récursivement le dictionnaire avec les clés et leurs valeurs.  Voici un exemple de liste des entités de modèle elles-mêmes: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Pattern any1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pattern(<span class="hljs-number"><span class="hljs-number">100</span></span>, PatType.COMMON); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Pattern any2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pattern(<span class="hljs-number"><span class="hljs-number">101</span></span>, PatType.COMMON); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Pattern const1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pattern(<span class="hljs-number"><span class="hljs-number">200</span></span>, PatType.NUMBER); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Pattern const2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pattern(<span class="hljs-number"><span class="hljs-number">201</span></span>, PatType.NUMBER); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Pattern func1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pattern(<span class="hljs-number"><span class="hljs-number">400</span></span>, PatType.FUNCTION);</code> </pre><br>  Lorsque nous écrivons any1 * const1 - func1 et ainsi de suite, chaque nœud aura un numéro - c'est la clé.  En d'autres termes, lors du remplissage du dictionnaire, ces nombres apparaîtront sous forme de clés: 100, 101, 200, 201, 400 ... Et lors de la construction d'un arbre, nous regarderons la valeur correspondant à la clé et la remplacerons. <br><br>  Mis en œuvre <a href="https://github.com/Angourisoft/MathS/tree/master/AngouriMath/Functions/Evaluation/Patterns" rel="nofollow">ici</a> . <br><br><h2>  Simplification.  Tri des arbres </h2><br>  Dans l' <a href="https://habr.com/ru/post/150043/">article</a> que j'ai déjà abordé, l'auteur a décidé de le faire simplement, et trié pratiquement par hachage de l'arbre.  Il a réussi à réduire a et -a, b + c + b pour tourner 2b + c.  Mais nous voulons bien sûr aussi que (x + y) + x * y - 3 * x soit réduit, et en général des choses plus compliquées. <br><br><h5>  Les modèles ne fonctionnent pas? </h5><br>  En général, ce que nous faisions auparavant, les motifs sont une chose monstrueusement merveilleuse.  Cela vous permettra de réduire la différence entre les carrés, et la somme des carrés du sinus et du cosinus, et d'autres choses complexes.  Mais la paume élémentaire, ((((((x + 1) + 1) + 1) + 1), elle ne se réduira pas, car la règle principale ici est la commutativité des termes.  Par conséquent, la première étape consiste à isoler les «enfants linéaires». <br><br><h5>  "Enfants linéaires" </h5><br>  En fait, pour chaque nœud de la somme ou de la différence (et, soit dit en passant, le produit / la division), nous voulons obtenir une liste de termes (facteurs). <br><br><img src="https://habrastorage.org/webt/-x/ku/yw/-xkuywdj1ovbr9rsam0lrhhcw0q.png"><br><br>  C'est fondamentalement simple.  Laissez la fonction LinearChildren (Entity node) renvoyer une liste, puis nous regardons l'enfant dans node.Children: si l'enfant n'est pas une somme, alors result.Add (enfant), sinon result.AddRange (LinearChildren (enfant)). <br><br>  Pas la plus belle manière mise en œuvre <a href="" rel="nofollow">ici</a> . <br><br><h5>  Regroupement d'enfants </h5><br>  Nous avons donc une liste d'enfants, mais que faire ensuite?  Supposons que nous ayons sin (x) + x + y + sin (x) + 2 * x.  De toute évidence, notre algorithme recevra cinq termes.  Ensuite, nous voulons regrouper par similitude, par exemple, x ressemble à 2 * x de plus que sin (x). <br><br>  Voici un bon regroupement: <br><br><img src="https://habrastorage.org/webt/s6/qz/eo/s6qzeoeqfech1ow5c8n_nciq9ek.png"><br><br>  Étant donné que les modèles qu'il contient vont continuer à gérer la conversion de 2 * x + x en 3 * x. <br><br>  Autrement dit, nous groupons d'abord par un <i>hachage</i> , puis faisons MultiHang - conversion de la sommation n-aire en binaire. <br><br><h5>  Hachage de nœud </h5><br>  D'une part <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-20"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21">x</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-3"> x </script>  et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-22"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23">x</span><span class="MJXp-mo" id="MJXp-Span-24" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-25">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-4"> x + 1 </script>  devrait être placé dans un groupe.  D'un autre côté, si disponible <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-26"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27">a</span><span class="MJXp-mo" id="MJXp-Span-28" style="margin-left: 0.267em; margin-right: 0.267em;">∗</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-29">x</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-5"> a * x </script>  mettre en un seul groupe avec <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-30"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31">y</span><span class="MJXp-mo" id="MJXp-Span-32" style="margin-left: 0.267em; margin-right: 0.267em;">∗</span><span class="MJXp-mo" id="MJXp-Span-33" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-34">x</span><span class="MJXp-mo" id="MJXp-Span-35" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-36">1</span><span class="MJXp-mo" id="MJXp-Span-37" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-6"> y * (x + 1) </script>  inutile. <br><br><div class="spoiler">  <b class="spoiler_title">Réflexions</b> <div class="spoiler_text">  Si vous y pensez, alors <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-38"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-39">a</span><span class="MJXp-mo" id="MJXp-Span-40" style="margin-left: 0.267em; margin-right: 0.267em;">∗</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-41">x</span><span class="MJXp-mo" id="MJXp-Span-42" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43">y</span><span class="MJXp-mo" id="MJXp-Span-44" style="margin-left: 0.267em; margin-right: 0.267em;">∗</span><span class="MJXp-mo" id="MJXp-Span-45" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-46">x</span><span class="MJXp-mo" id="MJXp-Span-47" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-48">1</span><span class="MJXp-mo" id="MJXp-Span-49" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-50" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mo" id="MJXp-Span-51" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52">a</span><span class="MJXp-mo" id="MJXp-Span-53" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-54">y</span><span class="MJXp-mo" id="MJXp-Span-55" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-56" style="margin-left: 0.267em; margin-right: 0.267em;">∗</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-57">x</span><span class="MJXp-mo" id="MJXp-Span-58" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-59">y</span></span></span><script type="math/tex" id="MathJax-Element-7"> a * x + y * (x + 1) = (a + y) * x + y </script>  .  Bien qu'il me semble, ce n'est pratiquement pas plus facile, et certainement pas nécessaire.  Quoi qu'il en soit, la simplification n'est jamais une chose évidente, et ce n'est certainement pas la première chose à écrire lors de l'écriture d'une «calculatrice». <br></div></div><br>  Par conséquent, nous implémentons le tri à plusieurs niveaux.  Tout d'abord, nous prétendons que <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-60"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-61">x</span><span class="MJXp-mo" id="MJXp-Span-62" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-63">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-8"> x + 1 </script>  - la même chose.  Trié, calmé.  Ensuite, nous prétendons que <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-64"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-65">x</span><span class="MJXp-mo" id="MJXp-Span-66" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-67">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9"> x + 1 </script>  ne peut être placé qu'avec d'autres <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-68"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-69">x</span><span class="MJXp-mo" id="MJXp-Span-70" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-71">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> x + 1 </script>  .  Et maintenant notre <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-72"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-73">a</span><span class="MJXp-mo" id="MJXp-Span-74" style="margin-left: 0.267em; margin-right: 0.267em;">∗</span><span class="MJXp-mo" id="MJXp-Span-75" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-76">x</span><span class="MJXp-mo" id="MJXp-Span-77" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-78">1</span><span class="MJXp-mo" id="MJXp-Span-79" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-11"> a * (x + 1) </script>  et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-80"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-81">y</span><span class="MJXp-mo" id="MJXp-Span-82" style="margin-left: 0.267em; margin-right: 0.267em;">∗</span><span class="MJXp-mo" id="MJXp-Span-83" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-84">x</span><span class="MJXp-mo" id="MJXp-Span-85" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-86">1</span><span class="MJXp-mo" id="MJXp-Span-87" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> y * (x + 1) </script>  enfin fait équipe.  Mis en œuvre tout simplement: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Hash</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SortLevel level</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> FunctionEntity) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Name + <span class="hljs-string"><span class="hljs-string">"_"</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Join(<span class="hljs-string"><span class="hljs-string">"_"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> child <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Children <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> child.Hash(level)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> NumberEntity) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> level == SortLevel.HIGH_LEVEL ? <span class="hljs-string"><span class="hljs-string">""</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Name + <span class="hljs-string"><span class="hljs-string">" "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> VariableEntity) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"v_"</span></span> + Name; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (level == SortLevel.LOW_LEVEL ? <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Name + <span class="hljs-string"><span class="hljs-string">"_"</span></span> : <span class="hljs-string"><span class="hljs-string">""</span></span>) + <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Join(<span class="hljs-string"><span class="hljs-string">"_"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> child <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Children <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> child.Hash(level) != <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> child.Hash(level)); }</code> </pre><br>  Comme vous pouvez le voir, la fonction affecte le tri de quelque manière que ce soit (bien sûr, car <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-88"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-89">f</span><span class="MJXp-mo" id="MJXp-Span-90" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-91">x</span><span class="MJXp-mo" id="MJXp-Span-92" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> f (x) </script>  avec <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-93"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-94">x</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> x </script>  généralement pas connecté dans le cas général).  Comme une variable, <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-95"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-96">x</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> x </script>  avec <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-97"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-98">y</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> y </script>  Eh bien, ça ne va pas se mélanger.  Mais les constantes et les opérateurs ne sont pas pris en compte à tous les niveaux.  Dans cet ordre, le processus de simplification lui-même <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Simplify</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      :   ,   ,     . . var stage1 = this.InnerSimplify(); Entity res = stage1; for (int i = 0; i &lt; level; i++) { //     .    -  x  x+1 (  ),  -  x-1  x+1 (,   ),  -  x+1  x+1 ( ). switch (i) { case 0: res = res.Sort(SortLevel.HIGH_LEVEL); break; case 2: res = res.Sort(SortLevel.MIDDLE_LEVEL); break; case 4: res = res.Sort(SortLevel.LOW_LEVEL); break; } //    . res = TreeAnalyzer.Replace(Patterns.CommonRules, res).InnerSimplify(); } return res; }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Réflexions</b> <div class="spoiler_text">  Est-ce la meilleure mise en œuvre?  Insérez des messages privés, il y aura peut-être de meilleures idées.  J'ai longtemps pensé comment le faire le plus magnifiquement possible, même si à mon avis, c'est loin d'être «beau». <br></div></div><br>  Je trie l'arbre <a href="" rel="nofollow">ici</a> . <br><br><h2>  "Compilation" des fonctions </h2><br>  Entre guillemets - car ce n'est pas dans le code IL lui-même, mais seulement dans un ensemble d'instructions très rapide.  Mais c'est très simple. <br><br><h5>  Problème de remplacement </h5><br>  Pour calculer la valeur d'une fonction, il suffit d'appeler la substitution de variable et eval, par exemple <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = MathS.Var(<span class="hljs-string"><span class="hljs-string">"x"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> expr = x * x + <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = expr.Substitute(x, <span class="hljs-number"><span class="hljs-number">5</span></span>).Eval();</code> </pre><br>  Mais cela fonctionne lentement, environ 1,5 microsecondes par sinus. <br><br><h5>  Instructions </h5><br>  Pour accélérer le calcul, nous effectuons un calcul de fonction sur la pile, à savoir: <br><br>  1) Nous arrivons avec la classe FastExpression, qui aura une liste d'instructions <br><br>  2) Lors de la compilation des instructions sont empilées dans l'ordre inverse, c'est-à-dire, s'il y a une fonction x * x + sin (x) + 3, alors les instructions seront quelque chose comme ceci: <br><br><pre> <code class="plaintext hljs">PUSHVAR 0 //    0 - x CALL 6 //    6 -  PUSHCONST 3 CALL 0 //    0 -  PUSHVAR 0 PUSHVAR 0 CALL 2 CALL 0</code> </pre><br>  Ensuite, une fois appelé, nous exécutons ces instructions et retournons Number. <br><br>  Un exemple d'exécution d'une instruction sum: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sumf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Stack&lt;Number&gt; stack</span></span></span><span class="hljs-function">)</span></span> { Number n1 = stack.Pop(); Number n2 = stack.Pop(); stack.Push(n1 + n2); }</code> </pre><br>  L'appel sinus a été réduit de 1500 à 60 n (le système Complex.Sin fonctionne pendant 30 n). <br>  Le navet est implémenté <a href="https://github.com/Angourisoft/MathS/tree/master/AngouriMath/Functions/Evaluation/Compilation" rel="nofollow">ici</a> . <br><br>  Fuh, tout semble être pour le moment.  Bien qu'il y ait encore quelque chose à dire, mais il me semble que le volume d'un article est suffisant.  Quelqu'un est-il intéressé par la suite?  À savoir: analyse à partir d'une chaîne, mise en forme en latex, une certaine intégrale et autres goodies. <br><br>  <a href="https://github.com/Angourisoft/MathS" rel="nofollow">Lien vers le référentiel</a> avec tout le code, ainsi que des tests et des échantillons. <br><br><div class="spoiler">  <b class="spoiler_title">Réflexions</b> <div class="spoiler_text">  En fait, je continue de travailler sur ce projet.  Il est distribué sous MIT (c'est-à-dire, faites ce que vous voulez avec lui), et il ne deviendra jamais fermé ou commercial.  De plus, s'il existe des idées d'amélioration et de contribution, les demandes de tirage sont les bienvenues. <br></div></div><br>  Merci de votre attention! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr482228/">https://habr.com/ru/post/fr482228/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr482212/index.html">Tu parles de ... fromage?</a></li>
<li><a href="../fr482216/index.html">23 réponses à la dépression d'un psychiatre professionnel Maxim Malyavin (dpmmax)</a></li>
<li><a href="../fr482220/index.html">Localisation du marqueur Aruco</a></li>
<li><a href="../fr482222/index.html">Application Web sur Kotlin + Spring Boot + Vue.js (module complémentaire)</a></li>
<li><a href="../fr482224/index.html">Quand un designer doit être un petit programmeur</a></li>
<li><a href="../fr482230/index.html">La bataille des serveurs WEB. Partie 2 - Scénario HTTPS réaliste:</a></li>
<li><a href="../fr482232/index.html">StackOverflow est plus qu'un simple référentiel de réponses à des questions stupides</a></li>
<li><a href="../fr482234/index.html">Modélisation numérique à analogique et mixte dans PADS Professional</a></li>
<li><a href="../fr482240/index.html">Nous démontons les premiers appareils TP-Link avec Wi-Fi 6: routeur Archer AX6000 et adaptateur Archer TX3000E</a></li>
<li><a href="../fr482244/index.html">Résultats des tests de caméras aveugles: iPhone, Pixel, Huawei, Samsung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>