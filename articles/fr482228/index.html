<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñåÔ∏è ‚úãüèæ üòø Nous √©crivons une ¬´calculatrice¬ª en C #. Partie I. Calcul de la valeur, d√©riv√©, simplification et autres oies üë®üèª‚Äçüöí ü¶ç üöì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut 

 Pour une raison quelconque, notre calculatrice est associ√©e √† quelque chose que chaque d√©butant devrait √©crire. Peut-√™tre parce que les ordin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous √©crivons une ¬´calculatrice¬ª en C #. Partie I. Calcul de la valeur, d√©riv√©, simplification et autres oies</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482228/">  Salut <br><br>  Pour une raison quelconque, notre calculatrice est associ√©e √† quelque chose que chaque d√©butant devrait √©crire.  Peut-√™tre parce que les ordinateurs ont √©t√© cr√©√©s √† cet effet pour compter.  Mais nous √©crirons une calculatrice difficile, pas sympa bien s√ªr, mais pour pouvoir faire des op√©rations alg√©briques de base, comme la diff√©renciation, la simplification, et des fonctionnalit√©s comme la compilation pour acc√©l√©rer les calculs. <br><br><div class="spoiler">  <b class="spoiler_title">Moins d'eau!</b>  <b class="spoiler_title">De quoi parle l'article?</b> <div class="spoiler_text">  Ici, il sera superficiel de construire une expression, d'analyser √† partir d'une cha√Æne, de substitution de variables, de d√©riv√© analytique, de r√©soudre num√©riquement une √©quation et une certaine int√©grale, de rendre au format LaTeX, de nombres complexes, de compiler des fonctions, de simplifier, d'√©tendre les crochets et de bla bla bla.  Probablement pas dans un article. <br>  <i>Pour ceux qui ont un besoin urgent de cloner quelque chose, un <a href="https://github.com/Angourisoft/MathS" rel="nofollow">lien vers le r√©f√©rentiel</a> .</i> <br></div></div><br>  Nous prenons les cookies restants de la nouvelle ann√©e, et avons roul√©! <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">√Ä qui s'adresse cet article?</b> <div class="spoiler_text">  Je pense que l'article peut √™tre utile √† un d√©butant, mais peut-√™tre que ceux qui sont un peu plus exp√©riment√©s trouveront aussi quelque chose d'int√©ressant.  Cependant, j'esp√®re √©crire un article afin qu'il puisse √™tre lu sans √™tre du tout programmeur C #. <br></div></div><br><h2>  Assemblage d'expression </h2><br><h3>  Qu'est-ce qu'une expression? </h3><br><div class="spoiler">  <b class="spoiler_title">Quand j'√©tais petit ...</b> <div class="spoiler_text">  Ensuite, bien s√ªr, je voulais √©crire une calculatrice.  Que devrait-il pouvoir faire?  Quatre op√©rations de base, et en principe bien plus.  Donc, ma t√¢che √©tait de calculer la valeur d'une expression de cha√Æne, par exemple, ¬´1 + (3/4 - (5 + 3 * 1))¬ª.  J'ai pris mon dauphin pr√©f√©r√© et j'ai √©crit un analyseur, qui est d'abord r√©cursivement plac√© entre crochets, puis a remplac√© l'expression entre crochets par une valeur et a supprim√© les crochets.  Fondamentalement, une fa√ßon tout √† fait fonctionnelle pour moi √† cette √©poque. <br></div></div><br>  Bien s√ªr, ce n'est pas une ligne.  Il est assez √©vident qu'une formule math√©matique est soit un arbre, soit une pile, et ici nous nous arr√™tons au premier.  Autrement dit, chaque n≈ìud, chaque n≈ìud de cet arbre, est une sorte d'op√©ration, variable ou constante. <br><br><img src="https://habrastorage.org/webt/ih/id/g2/ihidg2enlm7vi-es5t5agdoplks.png"><br><br>  Une op√©ration est soit une fonction, soit un op√©rateur, en principe, √† peu pr√®s la m√™me chose.  Ses enfants sont les arguments d'une fonction (op√©rateur). <br><br><h3>  Hi√©rarchie des classes dans votre code </h3><br>  Bien s√ªr, l'impl√©mentation peut √™tre quelconque.  Cependant, l'id√©e est que si votre arbre se compose uniquement de n≈ìuds et de feuilles, ils sont diff√©rents.  Par cons√©quent, j'appelle ces ¬´choses¬ª - des entit√©s.  Par cons√©quent, la classe sup√©rieure sera l'entit√© de classe abstraite. <br><br><div class="spoiler">  <b class="spoiler_title">Abstrait?</b> <div class="spoiler_text">  Comme tout le monde le sait gr√¢ce √† l'apprentissage des langues de base, une classe abstraite est bonne car elle g√©n√©ralise certaines classes d'une part, et d'autre part vous permet de s√©parer la logique et le comportement de certains objets.  Un objet d'une classe abstraite ne peut pas √™tre cr√©√©, mais son h√©ritier le peut. <br></div></div><br>  Et il y aura √©galement quatre classes successives: NumberEntity, VariableEntity, OperatorEntity, FunctionEntity. <br><br><h3>  Comment construire une expression? </h3><br>  Tout d'abord, nous allons construire une expression dans le code, c'est-√†-dire <br><br><pre><code class="plaintext hljs">var x = new VariableEntity("x"); var expr = x * x + 3 * x + 12;</code> </pre> <br>  Si vous d√©clarez une classe VariableEntity vide, un tel code vous g√©n√©rera une erreur, disent-ils, ne sait pas comment multiplier et additionner. <br><br><h5>  Remplacer les op√©rateurs </h5><br>  Une fonctionnalit√© tr√®s importante et utile de la plupart des langues, vous permettant de personnaliser l'ex√©cution des op√©rations arithm√©tiques.  Il est impl√©ment√© syntaxiquement diff√©remment selon la langue.  Par exemple, une impl√©mentation en C # <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> YourClass <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> +(YourClass a, YourClass b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> YourClass(a.ToString() + b.ToString()); }</code> </pre><br>  <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/operator-overloading" rel="nofollow">En savoir plus sur la substitution des instructions en C #</a> <br>  Le navet est impl√©ment√© <a href="" rel="nofollow">ici</a> . <br><br><h5>  Casting (non) explicite </h5><br>  Dans les langages compil√©s tels que C #, une telle chose est g√©n√©ralement pr√©sente et vous permet de transtyper le type si n√©cessaire sans appeler en plus myvar.ToAnotherType ().  Ainsi, par exemple, il serait pratique d'√©crire <br><br><pre> <code class="plaintext hljs">NumberEntity myvar = 3;</code> </pre><br>  Au lieu de l'habituel <br><br><pre> <code class="plaintext hljs">NumberEntity myvar = new NumberEntity(3);</code> </pre><br>  <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/user-defined-conversion-operators" rel="nofollow">En savoir plus sur la coul√©e de caract√®res en C #</a> <br>  Le navet est mis en place sur <a href="" rel="nofollow">cette</a> ligne. <br><br><h5>  Accrocher </h5><br>  La classe Entity a un champ Enfants - ce n'est qu'une liste d'entit√©s, qui sont les arguments de cette entit√©. <br><br><div class="spoiler">  <b class="spoiler_title">R√©flexions</b> <div class="spoiler_text">  En fait, seules deux classes d'objets peuvent avoir des enfants: OperatorEntity et FunctionEntity.  Autrement dit, vous pouvez en principe cr√©er une sorte de NodeEntity et en h√©riter ces deux classes, cr√©er une LeafEntity et en h√©riter VariableEntity et NumberEntity. <br><img src="https://habrastorage.org/webt/ft/i6/kj/fti6kj3h23-tmsd8g30gyyqtyks.png"><br></div></div><br>  Lorsque nous appelons une fonction ou un op√©rateur, nous devons cr√©er une nouvelle entit√© et y mettre les enfants √† partir desquels la fonction ou l'op√©rateur est appel√©.  Par exemple, le montant en th√©orie devrait ressembler √† ceci: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Entity <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> +(Entity a, Entity b){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OperatorEntity(<span class="hljs-string"><span class="hljs-string">"+"</span></span>); res.Children.Add(a); res.Children.Add(b); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre><br>  Autrement dit, si nous avons l'entit√© x et l'entit√© 3, alors x + 3 renverra l'essence de l'op√©rateur de somme avec deux enfants: 3 et x.  Ainsi, nous pouvons construire des arbres d'expression. <br><br>  Un appel de fonction est plus simple et pas aussi beau qu'avec un op√©rateur: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sin</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Entity a</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FunctionEntity(<span class="hljs-string"><span class="hljs-string">"sin"</span></span>); res.Children.Add(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre><br>  La pendaison de navets est impl√©ment√©e <a href="" rel="nofollow">ici</a> . <br><br>  Ok, nous avons cr√©√© un arbre d'expression. <br><br><h2>  Substitution variable </h2><br>  Ici, tout est extr√™mement simple.  Nous avons Entity - nous v√©rifions s'il s'agit d'une variable elle-m√™me, si c'est le cas, nous renvoyons la valeur, sinon nous parcourons les enfants. <br><br>  <a href="" rel="nofollow">Cet</a> √©norme fichier de 48 lignes impl√©mente une fonction aussi complexe. <br><br><h2>  Calcul de la valeur </h2><br>  En fait, pour ce que tout cela est.  Ici, nous sommes cens√©s ajouter une sorte de m√©thode √† Entity <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Eval</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsLeaf) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MathFunctions.InvokeEval(Name, Children); }</code> </pre><br>  La feuille est inchang√©e, mais pour tout le reste, nous avons un calcul personnalis√©.  Encore une fois, je vais donner un exemple: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Eval</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;Entity&gt; args</span></span></span><span class="hljs-function">)</span></span> { MathFunctions.AssertArgs(args.Count, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = args[<span class="hljs-number"><span class="hljs-number">0</span></span>].Eval(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> NumberEntity) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NumberEntity(Number.Sin((r <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> NumberEntity).Value)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r.Sin(); }</code> </pre><br>  Si l'argument est un nombre, alors nous produirons une fonction num√©rique, sinon nous le renverrons tel qu'il √©tait. <br><br><h3>  Num√©ro? </h3><br>  C'est l'unit√©, le nombre le plus simple.  Des op√©rations arithm√©tiques peuvent y √™tre effectu√©es.  Par d√©faut, c'est complexe.  Il a √©galement des op√©rations telles que Sin, Cos et d'autres d√©finies. <br><br>  Si vous √™tes int√©ress√©, le num√©ro est d√©crit <a href="" rel="nofollow">ici</a> . <br><br><h2>  D√©riv√© </h2><br>  Tout le monde peut calculer la d√©riv√©e num√©riquement, et une telle fonction s'√©crit vraiment sur une seule ligne: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Derivative</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Func&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; f, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> =&gt; (f(x + <span class="hljs-number"><span class="hljs-number">1.0e-5</span></span>) - f(x)) * <span class="hljs-number"><span class="hljs-number">1.0e+5</span></span>;</code> </pre><br>  Mais bien s√ªr, nous voulons un d√©riv√© analytique.  Puisque nous avons d√©j√† un arbre d'expression, nous pouvons remplacer r√©cursivement chaque n≈ìud conform√©ment √† la r√®gle de diff√©renciation.  Cela devrait fonctionner comme ceci: <br><br><img src="https://habrastorage.org/webt/6g/7t/6c/6g7t6ctcfoill4nroqcknz6gaa4.png"><br><br>  Voici, par exemple, comment le montant est impl√©ment√© dans mon code: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Derive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;Entity&gt; args, VariableEntity variable</span></span></span><span class="hljs-function">)</span></span> { MathFunctions.AssertArgs(args.Count, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = args[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.Derive(variable) + b.Derive(variable); }</code> </pre><br>  Mais le travail <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Derive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;Entity&gt; args, VariableEntity variable</span></span></span><span class="hljs-function">)</span></span> { MathFunctions.AssertArgs(args.Count, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = args[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.Derive(variable) * b + b.Derive(variable) * a; }</code> </pre><br>  Et voici une solution de contournement en soi: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Derive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">VariableEntity x</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsLeaf) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> VariableEntity &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Name == x.Name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NumberEntity(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NumberEntity(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MathFunctions.InvokeDerive(Name, Children, x); }</code> </pre><br>  Il s'agit de la m√©thode Entity.  Et comme nous le voyons, la feuille n'a que deux √©tats - soit c'est une variable par laquelle nous diff√©rencions, puis sa d√©riv√©e est 1, ou c'est une constante (nombre ou VariableEntity), puis sa d√©riv√©e est 0, ou un n≈ìud, puis il y a une r√©f√©rence par nom (InvokeDerive fait r√©f√©rence au dictionnaire de fonctions, o√π se trouve celle d√©sir√©e (par exemple, la somme ou le sinus)). <br><br>  Notez que je ne laisse pas quelque chose comme dy / dx ici et dis tout de suite que la d√©riv√©e de la variable <b>non</b> par laquelle nous diff√©rencions est 0. Mais ici, <a href="https://habr.com/ru/post/150043/">cela se</a> fait diff√©remment. <br><br>  Toute diff√©renciation est d√©crite dans <a href="" rel="nofollow">un seul fichier</a> , mais plus n'est pas n√©cessaire. <br><br><h2>  Simplification de l'expression.  Patterns </h2><br>  La simplification de l'expression n'est g√©n√©ralement pas triviale en principe.  Eh bien, par exemple, quelle expression est la plus simple: <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-msubsup" id="MJXp-Span-2"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-3" style="margin-right: 0.05em;">x</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-4" style="vertical-align: 0.5em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-5" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-msubsup" id="MJXp-Span-6"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-7" style="margin-right: 0.05em;">y</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-8" style="vertical-align: 0.5em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-1"> x ^ 2 - y ^ 2 </script>  ou <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-9"><span class="MJXp-mo" id="MJXp-Span-10" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11">x</span><span class="MJXp-mo" id="MJXp-Span-12" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-13">y</span><span class="MJXp-mo" id="MJXp-Span-14" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-15" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-16">x</span><span class="MJXp-mo" id="MJXp-Span-17" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-18">y</span><span class="MJXp-mo" id="MJXp-Span-19" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-2"> (x - y) (x + y) </script>  ?  Mais nous adh√©rons √† certaines id√©es, et sur la base de celles-ci, nous voulons √©tablir ces r√®gles qui simplifient pr√©cis√©ment l'expression. <br><br>  Il est possible d'√©crire √† chaque Eval que si nous avons la somme et que les enfants sont des ≈ìuvres, alors nous trierons quatre options, et si quelque chose est √©gal quelque part, nous √©liminerons le facteur ... Mais bien s√ªr, je ne veux pas faire √ßa.  Par cons√©quent, vous pouvez deviner le syst√®me de r√®gles et de mod√®les.  Alors que voulons-nous?  Quelque chose comme cette syntaxe: <br><br><pre> <code class="plaintext hljs">{ any1 / (any2 / any3) -&gt; any1 * any3 / any2 }, { const1 * var1 + const2 * var1 -&gt; (const1 + const2) * var1 }, { any1 + any1 * any2 -&gt; any1 * (Num(1) + any2) },</code> </pre><br>  Voici un exemple d'arbre dans lequel un sous-arbre a √©t√© trouv√© (encercl√© en vert) qui correspond au mod√®le any1 + const1 * any1 (any1 trouv√© est encercl√© en orange). <br><br><img src="https://habrastorage.org/webt/fe/jp/-l/fejp-l9krgdtvhw8d-ccpcekuko.png"><br><br>  Comme vous pouvez le voir, il est parfois important pour nous que la m√™me entit√© soit r√©p√©t√©e, par exemple, pour raccourcir l'expression x + a * x, nous avons besoin de x pour √™tre l√† et l√†, car x + a * y n'est plus r√©duit.  Par cons√©quent, nous devons cr√©er un algorithme qui non seulement v√©rifie que l‚Äôarbre correspond au mod√®le, mais <br><br><ol><li>  V√©rifiez que le m√™me mod√®le d'entit√© correspond √† la m√™me entit√©. </li><li>  Ecrire ce qui correspond √† quoi, puis substituer. </li></ol><br>  Le point d'entr√©e ressemble √† ceci: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> Dictionary&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">, Entity&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EqFits</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Entity tree</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, Entity&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tree.PatternMakeMatch(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, res)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre><br>  Et dans tree.PaternMakeMatch, nous remplissons r√©cursivement le dictionnaire avec les cl√©s et leurs valeurs.  Voici un exemple de liste des entit√©s de mod√®le elles-m√™mes: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Pattern any1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pattern(<span class="hljs-number"><span class="hljs-number">100</span></span>, PatType.COMMON); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Pattern any2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pattern(<span class="hljs-number"><span class="hljs-number">101</span></span>, PatType.COMMON); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Pattern const1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pattern(<span class="hljs-number"><span class="hljs-number">200</span></span>, PatType.NUMBER); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Pattern const2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pattern(<span class="hljs-number"><span class="hljs-number">201</span></span>, PatType.NUMBER); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Pattern func1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pattern(<span class="hljs-number"><span class="hljs-number">400</span></span>, PatType.FUNCTION);</code> </pre><br>  Lorsque nous √©crivons any1 * const1 - func1 et ainsi de suite, chaque n≈ìud aura un num√©ro - c'est la cl√©.  En d'autres termes, lors du remplissage du dictionnaire, ces nombres appara√Ætront sous forme de cl√©s: 100, 101, 200, 201, 400 ... Et lors de la construction d'un arbre, nous regarderons la valeur correspondant √† la cl√© et la remplacerons. <br><br>  Mis en ≈ìuvre <a href="https://github.com/Angourisoft/MathS/tree/master/AngouriMath/Functions/Evaluation/Patterns" rel="nofollow">ici</a> . <br><br><h2>  Simplification.  Tri des arbres </h2><br>  Dans l' <a href="https://habr.com/ru/post/150043/">article</a> que j'ai d√©j√† abord√©, l'auteur a d√©cid√© de le faire simplement, et tri√© pratiquement par hachage de l'arbre.  Il a r√©ussi √† r√©duire a et -a, b + c + b pour tourner 2b + c.  Mais nous voulons bien s√ªr aussi que (x + y) + x * y - 3 * x soit r√©duit, et en g√©n√©ral des choses plus compliqu√©es. <br><br><h5>  Les mod√®les ne fonctionnent pas? </h5><br>  En g√©n√©ral, ce que nous faisions auparavant, les motifs sont une chose monstrueusement merveilleuse.  Cela vous permettra de r√©duire la diff√©rence entre les carr√©s, et la somme des carr√©s du sinus et du cosinus, et d'autres choses complexes.  Mais la paume √©l√©mentaire, ((((((x + 1) + 1) + 1) + 1), elle ne se r√©duira pas, car la r√®gle principale ici est la commutativit√© des termes.  Par cons√©quent, la premi√®re √©tape consiste √† isoler les ¬´enfants lin√©aires¬ª. <br><br><h5>  "Enfants lin√©aires" </h5><br>  En fait, pour chaque n≈ìud de la somme ou de la diff√©rence (et, soit dit en passant, le produit / la division), nous voulons obtenir une liste de termes (facteurs). <br><br><img src="https://habrastorage.org/webt/-x/ku/yw/-xkuywdj1ovbr9rsam0lrhhcw0q.png"><br><br>  C'est fondamentalement simple.  Laissez la fonction LinearChildren (Entity node) renvoyer une liste, puis nous regardons l'enfant dans node.Children: si l'enfant n'est pas une somme, alors result.Add (enfant), sinon result.AddRange (LinearChildren (enfant)). <br><br>  Pas la plus belle mani√®re mise en ≈ìuvre <a href="" rel="nofollow">ici</a> . <br><br><h5>  Regroupement d'enfants </h5><br>  Nous avons donc une liste d'enfants, mais que faire ensuite?  Supposons que nous ayons sin (x) + x + y + sin (x) + 2 * x.  De toute √©vidence, notre algorithme recevra cinq termes.  Ensuite, nous voulons regrouper par similitude, par exemple, x ressemble √† 2 * x de plus que sin (x). <br><br>  Voici un bon regroupement: <br><br><img src="https://habrastorage.org/webt/s6/qz/eo/s6qzeoeqfech1ow5c8n_nciq9ek.png"><br><br>  √âtant donn√© que les mod√®les qu'il contient vont continuer √† g√©rer la conversion de 2 * x + x en 3 * x. <br><br>  Autrement dit, nous groupons d'abord par un <i>hachage</i> , puis faisons MultiHang - conversion de la sommation n-aire en binaire. <br><br><h5>  Hachage de n≈ìud </h5><br>  D'une part <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-20"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21">x</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-3"> x </script>  et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-22"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23">x</span><span class="MJXp-mo" id="MJXp-Span-24" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-25">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-4"> x + 1 </script>  devrait √™tre plac√© dans un groupe.  D'un autre c√¥t√©, si disponible <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-26"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27">a</span><span class="MJXp-mo" id="MJXp-Span-28" style="margin-left: 0.267em; margin-right: 0.267em;">‚àó</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-29">x</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-5"> a * x </script>  mettre en un seul groupe avec <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-30"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31">y</span><span class="MJXp-mo" id="MJXp-Span-32" style="margin-left: 0.267em; margin-right: 0.267em;">‚àó</span><span class="MJXp-mo" id="MJXp-Span-33" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-34">x</span><span class="MJXp-mo" id="MJXp-Span-35" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-36">1</span><span class="MJXp-mo" id="MJXp-Span-37" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-6"> y * (x + 1) </script>  inutile. <br><br><div class="spoiler">  <b class="spoiler_title">R√©flexions</b> <div class="spoiler_text">  Si vous y pensez, alors <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-38"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-39">a</span><span class="MJXp-mo" id="MJXp-Span-40" style="margin-left: 0.267em; margin-right: 0.267em;">‚àó</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-41">x</span><span class="MJXp-mo" id="MJXp-Span-42" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43">y</span><span class="MJXp-mo" id="MJXp-Span-44" style="margin-left: 0.267em; margin-right: 0.267em;">‚àó</span><span class="MJXp-mo" id="MJXp-Span-45" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-46">x</span><span class="MJXp-mo" id="MJXp-Span-47" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-48">1</span><span class="MJXp-mo" id="MJXp-Span-49" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-50" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mo" id="MJXp-Span-51" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52">a</span><span class="MJXp-mo" id="MJXp-Span-53" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-54">y</span><span class="MJXp-mo" id="MJXp-Span-55" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-56" style="margin-left: 0.267em; margin-right: 0.267em;">‚àó</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-57">x</span><span class="MJXp-mo" id="MJXp-Span-58" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-59">y</span></span></span><script type="math/tex" id="MathJax-Element-7"> a * x + y * (x + 1) = (a + y) * x + y </script>  .  Bien qu'il me semble, ce n'est pratiquement pas plus facile, et certainement pas n√©cessaire.  Quoi qu'il en soit, la simplification n'est jamais une chose √©vidente, et ce n'est certainement pas la premi√®re chose √† √©crire lors de l'√©criture d'une ¬´calculatrice¬ª. <br></div></div><br>  Par cons√©quent, nous impl√©mentons le tri √† plusieurs niveaux.  Tout d'abord, nous pr√©tendons que <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-60"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-61">x</span><span class="MJXp-mo" id="MJXp-Span-62" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-63">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-8"> x + 1 </script>  - la m√™me chose.  Tri√©, calm√©.  Ensuite, nous pr√©tendons que <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-64"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-65">x</span><span class="MJXp-mo" id="MJXp-Span-66" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-67">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9"> x + 1 </script>  ne peut √™tre plac√© qu'avec d'autres <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-68"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-69">x</span><span class="MJXp-mo" id="MJXp-Span-70" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-71">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> x + 1 </script>  .  Et maintenant notre <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-72"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-73">a</span><span class="MJXp-mo" id="MJXp-Span-74" style="margin-left: 0.267em; margin-right: 0.267em;">‚àó</span><span class="MJXp-mo" id="MJXp-Span-75" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-76">x</span><span class="MJXp-mo" id="MJXp-Span-77" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-78">1</span><span class="MJXp-mo" id="MJXp-Span-79" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-11"> a * (x + 1) </script>  et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-80"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-81">y</span><span class="MJXp-mo" id="MJXp-Span-82" style="margin-left: 0.267em; margin-right: 0.267em;">‚àó</span><span class="MJXp-mo" id="MJXp-Span-83" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-84">x</span><span class="MJXp-mo" id="MJXp-Span-85" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-86">1</span><span class="MJXp-mo" id="MJXp-Span-87" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> y * (x + 1) </script>  enfin fait √©quipe.  Mis en ≈ìuvre tout simplement: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Hash</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SortLevel level</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> FunctionEntity) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Name + <span class="hljs-string"><span class="hljs-string">"_"</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Join(<span class="hljs-string"><span class="hljs-string">"_"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> child <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Children <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> child.Hash(level)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> NumberEntity) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> level == SortLevel.HIGH_LEVEL ? <span class="hljs-string"><span class="hljs-string">""</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Name + <span class="hljs-string"><span class="hljs-string">" "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> VariableEntity) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"v_"</span></span> + Name; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (level == SortLevel.LOW_LEVEL ? <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Name + <span class="hljs-string"><span class="hljs-string">"_"</span></span> : <span class="hljs-string"><span class="hljs-string">""</span></span>) + <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Join(<span class="hljs-string"><span class="hljs-string">"_"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> child <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Children <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> child.Hash(level) != <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> child.Hash(level)); }</code> </pre><br>  Comme vous pouvez le voir, la fonction affecte le tri de quelque mani√®re que ce soit (bien s√ªr, car <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-88"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-89">f</span><span class="MJXp-mo" id="MJXp-Span-90" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-91">x</span><span class="MJXp-mo" id="MJXp-Span-92" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> f (x) </script>  avec <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-93"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-94">x</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> x </script>  g√©n√©ralement pas connect√© dans le cas g√©n√©ral).  Comme une variable, <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-95"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-96">x</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> x </script>  avec <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-97"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-98">y</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> y </script>  Eh bien, √ßa ne va pas se m√©langer.  Mais les constantes et les op√©rateurs ne sont pas pris en compte √† tous les niveaux.  Dans cet ordre, le processus de simplification lui-m√™me <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Simplify</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      :   ,   ,     . . var stage1 = this.InnerSimplify(); Entity res = stage1; for (int i = 0; i &lt; level; i++) { //     .    -  x  x+1 (  ),  -  x-1  x+1 (,   ),  -  x+1  x+1 ( ). switch (i) { case 0: res = res.Sort(SortLevel.HIGH_LEVEL); break; case 2: res = res.Sort(SortLevel.MIDDLE_LEVEL); break; case 4: res = res.Sort(SortLevel.LOW_LEVEL); break; } //    . res = TreeAnalyzer.Replace(Patterns.CommonRules, res).InnerSimplify(); } return res; }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">R√©flexions</b> <div class="spoiler_text">  Est-ce la meilleure mise en ≈ìuvre?  Ins√©rez des messages priv√©s, il y aura peut-√™tre de meilleures id√©es.  J'ai longtemps pens√© comment le faire le plus magnifiquement possible, m√™me si √† mon avis, c'est loin d'√™tre ¬´beau¬ª. <br></div></div><br>  Je trie l'arbre <a href="" rel="nofollow">ici</a> . <br><br><h2>  "Compilation" des fonctions </h2><br>  Entre guillemets - car ce n'est pas dans le code IL lui-m√™me, mais seulement dans un ensemble d'instructions tr√®s rapide.  Mais c'est tr√®s simple. <br><br><h5>  Probl√®me de remplacement </h5><br>  Pour calculer la valeur d'une fonction, il suffit d'appeler la substitution de variable et eval, par exemple <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = MathS.Var(<span class="hljs-string"><span class="hljs-string">"x"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> expr = x * x + <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = expr.Substitute(x, <span class="hljs-number"><span class="hljs-number">5</span></span>).Eval();</code> </pre><br>  Mais cela fonctionne lentement, environ 1,5 microsecondes par sinus. <br><br><h5>  Instructions </h5><br>  Pour acc√©l√©rer le calcul, nous effectuons un calcul de fonction sur la pile, √† savoir: <br><br>  1) Nous arrivons avec la classe FastExpression, qui aura une liste d'instructions <br><br>  2) Lors de la compilation des instructions sont empil√©es dans l'ordre inverse, c'est-√†-dire, s'il y a une fonction x * x + sin (x) + 3, alors les instructions seront quelque chose comme ceci: <br><br><pre> <code class="plaintext hljs">PUSHVAR 0 //    0 - x CALL 6 //    6 -  PUSHCONST 3 CALL 0 //    0 -  PUSHVAR 0 PUSHVAR 0 CALL 2 CALL 0</code> </pre><br>  Ensuite, une fois appel√©, nous ex√©cutons ces instructions et retournons Number. <br><br>  Un exemple d'ex√©cution d'une instruction sum: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sumf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Stack&lt;Number&gt; stack</span></span></span><span class="hljs-function">)</span></span> { Number n1 = stack.Pop(); Number n2 = stack.Pop(); stack.Push(n1 + n2); }</code> </pre><br>  L'appel sinus a √©t√© r√©duit de 1500 √† 60 n (le syst√®me Complex.Sin fonctionne pendant 30 n). <br>  Le navet est impl√©ment√© <a href="https://github.com/Angourisoft/MathS/tree/master/AngouriMath/Functions/Evaluation/Compilation" rel="nofollow">ici</a> . <br><br>  Fuh, tout semble √™tre pour le moment.  Bien qu'il y ait encore quelque chose √† dire, mais il me semble que le volume d'un article est suffisant.  Quelqu'un est-il int√©ress√© par la suite?  √Ä savoir: analyse √† partir d'une cha√Æne, mise en forme en latex, une certaine int√©grale et autres goodies. <br><br>  <a href="https://github.com/Angourisoft/MathS" rel="nofollow">Lien vers le r√©f√©rentiel</a> avec tout le code, ainsi que des tests et des √©chantillons. <br><br><div class="spoiler">  <b class="spoiler_title">R√©flexions</b> <div class="spoiler_text">  En fait, je continue de travailler sur ce projet.  Il est distribu√© sous MIT (c'est-√†-dire, faites ce que vous voulez avec lui), et il ne deviendra jamais ferm√© ou commercial.  De plus, s'il existe des id√©es d'am√©lioration et de contribution, les demandes de tirage sont les bienvenues. <br></div></div><br>  Merci de votre attention! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr482228/">https://habr.com/ru/post/fr482228/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr482212/index.html">Tu parles de ... fromage?</a></li>
<li><a href="../fr482216/index.html">23 r√©ponses √† la d√©pression d'un psychiatre professionnel Maxim Malyavin (dpmmax)</a></li>
<li><a href="../fr482220/index.html">Localisation du marqueur Aruco</a></li>
<li><a href="../fr482222/index.html">Application Web sur Kotlin + Spring Boot + Vue.js (module compl√©mentaire)</a></li>
<li><a href="../fr482224/index.html">Quand un designer doit √™tre un petit programmeur</a></li>
<li><a href="../fr482230/index.html">La bataille des serveurs WEB. Partie 2 - Sc√©nario HTTPS r√©aliste:</a></li>
<li><a href="../fr482232/index.html">StackOverflow est plus qu'un simple r√©f√©rentiel de r√©ponses √† des questions stupides</a></li>
<li><a href="../fr482234/index.html">Mod√©lisation num√©rique √† analogique et mixte dans PADS Professional</a></li>
<li><a href="../fr482240/index.html">Nous d√©montons les premiers appareils TP-Link avec Wi-Fi 6: routeur Archer AX6000 et adaptateur Archer TX3000E</a></li>
<li><a href="../fr482244/index.html">R√©sultats des tests de cam√©ras aveugles: iPhone, Pixel, Huawei, Samsung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>