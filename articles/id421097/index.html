<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òïÔ∏è üëâüèø üëµüèæ Komposisi UIViewControllers dan navigasi di antara mereka (dan tidak hanya) üò≠ üïñ üï¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel ini saya ingin berbagi pengalaman yang telah berhasil kami gunakan selama beberapa tahun di aplikasi iOS kami, 3 di antaranya saat ini a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Komposisi UIViewControllers dan navigasi di antara mereka (dan tidak hanya)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421097/"><p><img src="https://habrastorage.org/webt/x7/yt/ll/x7ytllwqwgvgxy2rvtmdwj3qkia.png"></p><br><p>  Dalam artikel ini saya ingin berbagi pengalaman yang telah berhasil kami gunakan selama beberapa tahun di aplikasi iOS kami, 3 di antaranya saat ini ada di Appstore.  Pendekatan ini telah bekerja dengan baik dan kami baru saja memisahkannya dari sisa kode dan mendesainnya menjadi pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RouteComposer yang</a> terpisah, yang akan dibahas pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kenyataannya</a> . </p><a name="habracut"></a><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/ekazaev/route-composer</a> </p><br><p>  Tetapi, sebagai permulaan, mari kita coba mencari tahu apa yang dimaksud dengan komposisi pengontrol tampilan di iOS. </p><br><p> Sebelum melanjutkan ke penjelasan itu sendiri, saya mengingatkan Anda bahwa di iOS itu paling sering dipahami sebagai view controller atau <code>UIViewController</code> .  Ini adalah kelas yang diwarisi dari <code>UIViewController</code> standar, yang merupakan pengontrol pola MVC dasar yang direkomendasikan Apple untuk digunakan untuk mengembangkan aplikasi iOS. </p><br><p>  Anda dapat menggunakan pola arsitektur alternatif seperti MVVM, VIP, VIPER, tetapi di dalamnya <code>UIViewController</code> akan terlibat dengan satu atau lain cara, yang berarti bahwa perpustakaan ini dapat digunakan bersama mereka.  Esensi dari <code>UIViewController</code> digunakan untuk mengontrol <code>UIView</code> , yang paling sering mewakili layar atau bagian penting dari layar, memproses peristiwa dari itu dan menampilkan beberapa data di dalamnya. </p><br><p><img src="https://habrastorage.org/webt/5v/ia/-3/5via-37-mfc9leww-hwfvcu20eg.png"></p><br><p>  Semua <code>UIViewController</code> dapat dibagi secara kondisional menjadi <strong>Pengendali Tampilan Normal</strong> , yang bertanggung jawab untuk beberapa area yang terlihat di layar, dan <strong>Pengontrol Tampilan Kontainer</strong> , yang, selain menampilkan diri mereka sendiri dan beberapa kontrol mereka, juga dapat menampilkan pengontrol tampilan anak yang terintegrasi di dalamnya dengan satu atau lain cara. . </p><br><p>  Pengontrol tampilan wadah standar yang disertakan dengan Cocoa Touch meliputi: <code>UINavigationConroller</code> , <code>UITabBarController</code> , <code>UISplitController</code> , <code>UIPageController</code> , dan beberapa lainnya.  Selain itu, pengguna dapat membuat pengontrol tampilan wadah kustom mereka sendiri mengikuti aturan Cocoa Touch yang dijelaskan dalam dokumentasi Apple. </p><br><p>  Proses memperkenalkan pengendali tampilan standar ke pengendali tampilan wadah, serta integrasi pengendali tampilan ke tumpukan pengendali, kami akan memanggil <strong>komposisi</strong> dalam artikel ini. </p><br><p>  Mengapa, kemudian, solusi standar untuk komposisi pengontrol tampilan ternyata tidak optimal bagi kami, dan kami mengembangkan perpustakaan yang memfasilitasi pekerjaan kami. </p><br><p>  Mari kita lihat komposisi beberapa pengontrol tampilan wadah standar sebagai contoh: </p><br><h3 id="primery-kompozicii-v-standartnyh-konteynerah">  Contoh komposisi dalam wadah standar </h3><br><h4 id="uinavigationcontroller"> <code>UINavigationController</code> </h4> <br><p><img src="https://habrastorage.org/webt/zx/fc/su/zxfcsucgp6qusx4kkkfccphmzz0.png"></p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tableViewController = <span class="hljs-type"><span class="hljs-type">UITableViewController</span></span>(style: .plain) <span class="hljs-comment"><span class="hljs-comment">//        let navigationController = UINavigationController(rootViewController: tableViewController) // ... //        let detailViewController = UIViewController(nibName: "DetailViewController", bundle: nil) navigationController.pushViewController(detailViewController, animated: true) // ... //     navigationController.popToRootViewController(animated: true)</span></span></code> </pre> <br><h4 id="uitabbarcontroller"> <code>UITabBarController</code> </h4> <br><p><img src="https://habrastorage.org/webt/vi/2t/bx/vi2tbxjzyl9xs_rhrcpbx9p9lp8.png"></p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstViewController = <span class="hljs-type"><span class="hljs-type">UITableViewController</span></span>(style: .plain) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> secondViewController = <span class="hljs-type"><span class="hljs-type">UIViewController</span></span>() <span class="hljs-comment"><span class="hljs-comment">//   let tabBarController = UITabBarController() //         tabBarController.viewControllers = [firstViewController, secondViewController] //        tabBarController.selectedViewController = secondViewController</span></span></code> </pre> <br><h4 id="uisplitviewcontroller"> <code>UISplitViewController</code> </h4> <br><p><img src="https://habrastorage.org/webt/gs/jx/ll/gsjxllx4rm_tjpukwtawibmffsg.png"></p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstViewController = <span class="hljs-type"><span class="hljs-type">UITableViewController</span></span>(style: .plain) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> secondViewController = <span class="hljs-type"><span class="hljs-type">UIViewController</span></span>() <span class="hljs-comment"><span class="hljs-comment">//   let splitViewController = UISplitViewController() //        splitViewController.viewControllers = [firstViewController] //        splitViewController.showDetailViewController(secondViewController, sender: nil)</span></span></code> </pre> <br><h3 id="primery-integracii-kompozicii-vyu-kotrollerov-v-stek">  Contoh integrasi (komposisi) pengendali tampilan pada stack </h3><br><h4 id="ustanovka-vyu-kontrolera-rutom">  Menginstal root pengontrol tampilan </h4><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> window: <span class="hljs-type"><span class="hljs-type">UIWindow</span></span> = <span class="hljs-comment"><span class="hljs-comment">//... window.rootViewController = viewController window.makeKeyAndVisible()</span></span></code> </pre> <br><h4 id="modalnaya-prezentaciya-vyu-kontrolera">  Modal presentasi pengendali tampilan </h4><br><pre> <code class="swift hljs">window.rootViewController.present(splitViewController, animated: animated, completion: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br><h3 id="pochemu-my-reshili-sozdat-biblioteku-dlya-kompozicii">  Mengapa kami memutuskan untuk membuat perpustakaan untuk komposisi </h3><br><p>  Seperti yang dapat Anda lihat dari contoh di atas, tidak ada cara tunggal untuk mengintegrasikan pengontrol tampilan konvensional ke dalam wadah, seperti halnya tidak ada cara tunggal untuk membangun setumpuk pengontrol tampilan.  Dan, jika Anda ingin sedikit mengubah tata letak aplikasi Anda atau cara Anda menavigasi di dalamnya, Anda akan memerlukan perubahan signifikan pada kode aplikasi, Anda juga akan memerlukan tautan ke objek kontainer sehingga Anda dapat memasukkan pengontrol tampilan Anda ke dalamnya, dll.  Artinya, metode standar itu sendiri menyiratkan jumlah pekerjaan yang cukup besar, serta keberadaan tautan untuk melihat pengontrol untuk menghasilkan tindakan dan presentasi dari pengontrol lain. </p><br><p>  Semua ini menambah sakit kepala pada berbagai metode penautan-dip ke aplikasi (misalnya, menggunakan tautan Universal), karena Anda harus menjawab pertanyaan: <em>bagaimana jika pengontrol perlu diperlihatkan kepada pengguna karena dia mengklik tautan di safari sudah ditunjukkan, atau saya melihat pengontrol yang seharusnya menunjukkan bahwa itu belum dibuat</em> , memaksa Anda untuk berjalan melalui pohon pengontrol tampilan dan menulis kode yang terkadang mata Anda mulai berdarah dan yang coba disembunyikan oleh pengembang iOS.  Selain itu, tidak seperti arsitektur Android di mana setiap layar dibangun secara terpisah, di iOS, untuk menunjukkan beberapa bagian dari aplikasi segera setelah peluncuran, mungkin perlu untuk membangun setumpuk pengendali yang agak besar yang akan disembunyikan di bawah yang Anda perlihatkan berdasarkan permintaan. </p><br><p>  Akan luar biasa hanya untuk memanggil metode seperti <code>goToAccount()</code> , <code>goToMenu()</code> atau <code>goToProduct(withId: "012345")</code> ketika pengguna mengklik tombol atau ketika aplikasi <code>goToProduct(withId: "012345")</code> tautan universal dari aplikasi lain dan tidak berpikir tentang mengintegrasikan pengontrol tampilan ini ke stack, mengetahui bahwa pembuat view controller ini telah menyediakan implementasi ini. </p><br><p>  Selain itu, seringkali, aplikasi kami terdiri dari sejumlah besar layar yang dikembangkan oleh tim yang berbeda, dan untuk menuju ke salah satu layar selama proses pengembangan, Anda harus melalui layar lain yang mungkin belum dibuat.  Di perusahaan kami, kami menggunakan pendekatan yang kami sebut <em>cawan Petri</em> .  Artinya, dalam mode pengembangan, pengembang dan tester memiliki akses ke daftar semua layar aplikasi dan ia dapat pergi ke salah satu dari mereka (tentu saja, beberapa dari mereka mungkin memerlukan beberapa parameter input). </p><br><p><img src="https://habrastorage.org/webt/5l/wx/cv/5lwxcvup0mtdaedrgjsxokbsdti.png"></p><br><p>  Anda dapat berinteraksi dengan mereka dan menguji secara individual, dan kemudian mengumpulkannya ke dalam aplikasi akhir untuk produksi.  Pendekatan ini sangat memudahkan pengembangan, tetapi, seperti yang Anda lihat dari contoh di atas, komposisi neraka dimulai ketika Anda perlu menyimpan kode beberapa cara untuk mengintegrasikan pengontrol tampilan ke stack. </p><br><p>  Tetap menambahkan bahwa semua ini akan dikalikan dengan N segera setelah tim pemasaran Anda menyatakan keinginan untuk melakukan pengujian A / B pada pengguna langsung dan memeriksa metode navigasi mana yang bekerja lebih baik, misalnya, bilah tab atau menu hamburger? </p><br><ul><li><del>  Mari kita potong kaki Susanin </del>  Mari kita tunjukkan 50% dari pengguna Tab Bar, dan ke menu Hamburger lainnya, dan dalam sebulan kami akan memberi tahu Anda pengguna mana yang melihat lebih banyak dari penawaran khusus kami? </li></ul><br><p>  Saya akan mencoba memberi tahu Anda bagaimana kami mendekati solusi untuk masalah ini dan akhirnya mengalokasikannya ke perpustakaan RouteComposer. </p><br><h3 id="susanin-route-composer"><del>  Susanin </del>  Rute komposer </h3><br><p>  Setelah menganalisis semua skenario komposisi dan navigasi, kami mencoba untuk abstrak kode yang diberikan dalam contoh di atas dan mengidentifikasi 3 entitas utama di mana perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RouteComposer beroperasi</a> - <code>Factory</code> , <code>Finder</code> , <code>Action</code> .  Selain itu, pustaka berisi 3 entitas bantu yang bertanggung jawab atas penyetelan kecil yang mungkin diperlukan selama proses navigasi - <code>RoutingInterceptor</code> , <code>ContextTask</code> , <code>PostRoutingTask</code> .  Semua entitas ini harus dikonfigurasi dalam rantai dependensi dan ditransfer ke <code>Router</code> y, objek yang akan membangun tumpukan pengontrol Anda. </p><br><p>  Tapi, tentang masing-masing dari mereka dalam urutan: </p><br><h4 id="factory">  Pabrik </h4><br><p>  Seperti namanya, <code>Factory</code> bertanggung jawab untuk membuat pengontrol tampilan. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Factory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">ViewController</span></span>: <span class="hljs-type"><span class="hljs-type">UIViewController</span></span> <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">Context</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with context: Context)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ViewController</span></span> }</code> </pre> <br><p>  Di sini penting untuk membuat reservasi tentang konsep <strong>konteks</strong> .  Konteks dalam pustaka, kami menyebut semua yang diperlukan oleh pemirsa agar dapat dibuat.  Misalnya, untuk memperlihatkan pengontrol tampilan yang menampilkan detail produk, Anda harus memasukkan productID tertentu ke dalamnya, misalnya, dalam bentuk <code>String</code> .  Inti dari konteks dapat berupa apa saja: objek, struktur, blok, atau tupel.  Jika pengontrol Anda tidak memerlukan apa pun untuk dibuat - dapatkah konteksnya ditentukan sebagai <code>Any?</code>  dan instal dalam <code>nil</code> . </p><br><p>  Sebagai contoh: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductViewControllerFactory</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Factory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with productID: UUID)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ProductViewController</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> productViewController = <span class="hljs-type"><span class="hljs-type">ProductViewController</span></span>(nibName: <span class="hljs-string"><span class="hljs-string">"ProductViewController"</span></span>, bundle: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) productViewController.productID = productID <span class="hljs-comment"><span class="hljs-comment">//  ,      `ContextAction`,     return productViewController } }</span></span></code> </pre> <br><p>  Dari implementasi di atas menjadi jelas bahwa pabrik ini akan memuat gambar pengontrol dari file XIB dan menginstal productID yang ditransfer ke dalamnya.  Selain protokol <code>Factory</code> standar, perpustakaan menyediakan beberapa implementasi standar protokol ini untuk menyelamatkan Anda dari penulisan kode banal (khususnya, contoh di atas). </p><br><p>  Lebih lanjut, saya akan menahan diri untuk tidak memberikan deskripsi protokol dan contoh implementasi mereka, karena Anda dapat membiasakan diri dengan mereka secara detail dengan mengunduh contoh yang datang dengan perpustakaan.  Ada berbagai implementasi pabrik untuk pengontrol tampilan dan wadah konvensional, serta cara untuk mengonfigurasinya. </p><br><h4 id="action">  Aksi </h4><br><p>  Entitas <code>Action</code> adalah deskripsi tentang cara mengintegrasikan pengontrol tampilan, yang akan dibangun oleh pabrik, ke dalam tumpukan.  Pengontrol tampilan setelah pembuatan tidak dapat hanya menggantung di udara dan, oleh karena itu, setiap pabrik harus berisi <code>Action</code> seperti yang dapat dilihat dari contoh di atas. </p><br><p>  Implementasi <code>Action</code> paling umum adalah presentasi modal dari controller: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PresentModally</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Action</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(viewController: UIViewController, on existingController: UIViewController, animated: Bool, completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">: ActionResult)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> existingController.presentedViewController == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { completion(.failure(<span class="hljs-string"><span class="hljs-string">"\(existingController) is already presenting a view controller."</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } existingController.present(viewController, animated: animated, completion: { completion(.continueRouting) }) } }</code> </pre> <br><p>  Pustaka berisi penerapan sebagian besar cara standar untuk mengintegrasikan pengontrol tampilan ke stack, dan Anda mungkin tidak perlu membuatnya sendiri sampai Anda menggunakan beberapa jenis pengontrol tampilan wadah kustom atau metode presentasi.  Tetapi membuat Tindakan kustom seharusnya tidak menimbulkan masalah jika Anda membaca contoh. </p><br><h4 id="finder">  Finder </h4><br><p>  Inti dari <code>Finder</code> menjawab perute ke pertanyaan <em>- Apakah sudah ada controller yang dibuat dan sudah ada di stack?</em>  <em>Mungkin tidak ada yang diperlukan untuk dibuat dan cukup untuk menunjukkan apa yang sudah ada?</em>  . </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Finder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">ViewController</span></span>: <span class="hljs-type"><span class="hljs-type">UIViewController</span></span> <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">Context</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findViewController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with context: Context)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ViewController?</span></span> }</code> </pre> <br><p>  Jika Anda menyimpan tautan ke semua pengontrol tampilan yang Anda buat, maka dalam implementasi <code>Finder</code> Anda, Anda bisa mengembalikan tautan ke pengontrol tampilan yang diinginkan.  Tetapi paling sering hal ini tidak terjadi, karena tumpukan aplikasi, terutama jika itu besar, perubahannya cukup dinamis.  Selain itu, Anda dapat memiliki beberapa pengontrol tampilan yang identik pada tumpukan yang menunjukkan entitas yang berbeda (misalnya, beberapa ProductViewControllers yang menunjukkan produk yang berbeda dengan productID yang berbeda), sehingga penerapan <code>Finder</code> mungkin memerlukan implementasi khusus dan mencari pengontrol tampilan yang sesuai pada tumpukan.  Pustaka memfasilitasi tugas ini dengan menyediakan <code>StackIteratingFinder</code> sebagai ekstensi ke <code>Finder</code> , sebuah protokol dengan pengaturan yang sesuai untuk menyederhanakan tugas ini.  Dalam implementasi <code>StackIteratingFinder</code> Anda hanya perlu menjawab pertanyaan - apakah view controller ini yang dicari oleh router atas permintaan Anda. </p><br><p>  Contoh implementasi seperti itu: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductViewControllerFinder</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StackIteratingFinder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> options: <span class="hljs-type"><span class="hljs-type">SearchOptions</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(options: <span class="hljs-type"><span class="hljs-type">SearchOptions</span></span> = .currentAndUp) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.options = options } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isTarget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> productViewController: ProductViewController, with productID: UUID)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productViewController.productID == productID } }</code> </pre> <br><h3 id="vspomogatelnye-suschnosti">  Entitas Pembantu </h3><br><h4 id="routinginterceptor"> <code>RoutingInterceptor</code> </h4> <br><p>  <code>RoutingInterceptor</code> memungkinkan Anda untuk melakukan beberapa tindakan sebelum memulai komposisi pengontrol tampilan dan memberi tahu router apakah mungkin untuk mengintegrasikan pengontrol tampilan pada stack.  Contoh paling umum dari tugas semacam itu adalah otentikasi (tetapi sama sekali tidak biasa dalam implementasi).  Misalnya, Anda ingin memperlihatkan pengontrol tampilan dengan detail akun pengguna, tetapi, untuk ini, pengguna harus masuk ke sistem.  Anda dapat mengimplementasikan <code>RoutingInterceptor</code> dan menambahkannya ke konfigurasi tampilan pengontrol rincian pengguna dan cek dalam: jika pengguna masuk, izinkan router melanjutkan navigasi, jika tidak, tunjukkan pengontrol tampilan yang meminta pengguna untuk masuk dan jika tindakan ini berhasil, izinkan router untuk melanjutkan navigasi atau membatalkan padanya jika pengguna menolak untuk masuk. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoginInterceptor</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RoutingInterceptor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> destination: AppDestination, completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">: InterceptorResult)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> !<span class="hljs-type"><span class="hljs-type">LoginManager</span></span>.sharedInstance.isUserLoggedIn <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... //  LoginViewController       completion(.success)  completion(.failure("User has not been logged in.")) // ... return } completion(.success) } }</span></span></code> </pre><br><p>  Implementasi dari <code>RoutingInterceptor</code> dengan komentar terkandung dalam contoh yang disertakan dengan perpustakaan. </p><br><h4 id="contexttask"> <code>ContextTask</code> </h4> <br><p>  Entitas <code>ContextTask</code> , jika Anda menyediakannya, dapat diterapkan secara terpisah untuk setiap pengontrol tampilan dalam konfigurasi, terlepas dari apakah itu baru saja dibuat oleh router atau ditemukan di stack, dan Anda hanya ingin memperbarui data di dalamnya dan atau menetapkan beberapa yang default parameter (misalnya, tampilkan tombol tutup atau tidak ditampilkan). </p><br><h4 id="postroutingtask"> <code>PostRoutingTask</code> </h4> <br><p>  Implementasi <code>PostRoutingTask</code> akan dipanggil oleh router setelah berhasil menyelesaikan integrasi controller tampilan yang diminta ke stack.  Dalam implementasinya, mudah untuk menambahkan berbagai analitik atau menarik berbagai layanan. </p><br><p>  <strong>Secara lebih rinci dengan implementasi semua entitas yang dijelaskan dapat ditemukan dalam dokumentasi untuk perpustakaan serta dalam contoh terlampir.</strong> </p><br><p>  PS: Jumlah entitas pelengkap yang dapat ditambahkan ke konfigurasi tidak terbatas. </p><br><h3 id="konfiguraciya">  Konfigurasi </h3><br><p>  Semua entitas yang dijelaskan adalah baik karena mereka memecah proses komposisi menjadi blok kecil, dapat dipertukarkan, dan dipercaya. </p><br><p>  Sekarang mari kita beralih ke hal yang paling penting - ke konfigurasi, yaitu koneksi dari blok-blok ini satu sama lain.  Untuk mengumpulkan blok-blok ini di antara mereka sendiri dan menggabungkan mereka ke dalam rantai langkah-langkah, perpustakaan menyediakan kelas pembangun <code>StepAssembly</code> (untuk wadah - <code>ContainerStepAssembly</code> ).  Implementasinya memungkinkan Anda untuk merangkai blok komposisi menjadi objek konfigurasi tunggal seperti manik-manik pada string, dan juga menunjukkan ketergantungan pada konfigurasi pengontrol tampilan lainnya.  Apa yang harus dilakukan dengan konfigurasi di masa depan terserah Anda.  Anda dapat memasukkannya ke router dengan parameter yang diperlukan dan itu akan membangun setumpuk pengontrol untuk Anda, Anda dapat menyimpannya ke kamus dan menggunakannya nanti dengan kunci - itu tergantung pada tugas spesifik Anda. </p><br><p>  Pertimbangkan contoh sepele: Misalkan, dengan mengklik sel dalam daftar atau ketika aplikasi menerima tautan universal dari safari atau klien email, kita perlu memperlihatkan secara moderat pengontrol produk dengan productID tertentu.  Dalam hal ini, pengontrol produk harus dibuat di dalam <code>UINavigationController</code> sehingga dapat menampilkan nama dan tombol tutup pada panel kontrolnya.  Selain itu, produk ini hanya dapat ditampilkan kepada pengguna yang masuk, jika tidak, undang mereka untuk masuk. </p><br><p>  Jika Anda menguraikan contoh ini tanpa menggunakan pustaka, itu akan terlihat seperti ini: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductArrayViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITableViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> products: [<span class="hljs-type"><span class="hljs-type">UUID</span></span>]? <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> analyticsManager = <span class="hljs-type"><span class="hljs-type">AnalyticsManager</span></span>.sharedInstance <span class="hljs-comment"><span class="hljs-comment">//  UITableViewControllerDelegate override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) { guard let productID = products[indexPath.row] else { return } //   LoginInterceptor guard !LoginManager.sharedInstance.isUserLoggedIn else { //    LoginViewController         `showProduct(with: productID)` return } showProduct(with: productID) } func showProduct(with productID: String) { //   ProductViewControllerFactory let productViewController = ProductViewController(nibName: "ProductViewController", bundle: nil) //   ProductViewControllerContextTask productViewController.productID = productID //   NavigationControllerStep  PushToNavigationAction let navigationController = UINavigationController(rootViewController: productViewController) //   GenericActions.PresentModally present(alertController, animated: navigationController) { [weak self]   . ProductViewControllerPostTask self?.analyticsManager.trackProductView(productID: productID) } } }</span></span></code> </pre> <br><p>  Contoh ini tidak termasuk penerapan tautan universal, yang akan memerlukan isolasi kode otorisasi dan mempertahankan konteks di mana pengguna harus diarahkan setelah, serta mencari, tiba-tiba pengguna mengklik tautan, dan produk ini sudah ditunjukkan kepadanya, yang pada akhirnya akan membuat kode sangat sulit dibaca. </p><br><p>  <strong>Pertimbangkan konfigurasi contoh ini menggunakan perpustakaan:</strong> </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> productScreen = <span class="hljs-type"><span class="hljs-type">StepAssembly</span></span>(finder: <span class="hljs-type"><span class="hljs-type">ProductViewControllerFinder</span></span>(), factory: <span class="hljs-type"><span class="hljs-type">ProductViewControllerFactory</span></span>()) <span class="hljs-comment"><span class="hljs-comment">//  : .adding(LoginInterceptor()) .adding(ProductViewControllerContextTask()) .adding(ProductViewControllerPostTask(analyticsManager: AnalyticsManager.sharedInstance)) //  : .using(PushToNavigationAction()) .from(NavigationControllerStep()) // NavigationControllerStep -&gt; StepAssembly(finder: NilFinder(), factory: NavigationControllerFactory()) .using(GeneralAction.presentModally()) .from(GeneralStep.current()) .assemble()</span></span></code> </pre> <br><p>  Jika Anda menerjemahkannya ke bahasa manusia: </p><br><ul><li>  Periksa apakah pengguna sudah masuk, dan jika tidak menawarkan input kepadanya </li><li>  Jika pengguna telah berhasil masuk, lanjutkan </li><li>  Cari pengontrol tampilan produk yang disediakan oleh <code>Finder</code> </li><li>  Jika ditemukan - buat terlihat dan selesai </li><li>  Jika tidak ditemukan - buat <code>UINavigationController</code> , integrasikan ke dalamnya view controller yang dibuat oleh <code>ProductViewControllerFactory</code> menggunakan <code>PushToNavigationAction</code> </li><li>  <code>GenericActions.PresentModally</code> <code>UINavigationController</code> <code>GenericActions.PresentModally</code> menggunakan <code>GenericActions.PresentModally</code> dari pengontrol tampilan saat ini </li></ul><br><p>  Konfigurasi memerlukan beberapa penelitian, seperti banyak solusi kompleks, misalnya, konsep <code>AutoLayout</code> dan, pada pandangan pertama, mungkin tampak rumit dan berlebihan.  Namun, sejumlah tugas yang harus diselesaikan dengan fragmen kode yang diberikan mencakup semua aspek mulai dari otorisasi hingga tautan dalam, dan membobol urutan tindakan memungkinkan untuk dengan mudah mengubah konfigurasi tanpa perlu membuat perubahan pada kode.  Selain itu, penerapan <code>StepAssembly</code> akan membantu Anda menghindari masalah dengan rantai langkah yang tidak lengkap, dan ketik kontrol - masalah dengan ketidakcocokan parameter input untuk pengontrol tampilan yang berbeda. </p><br><p>  Pertimbangkan kode pseudo aplikasi lengkap di mana <code>ProductArrayViewController</code> menampilkan daftar produk dan, jika pengguna memilih produk ini, menampilkannya tergantung pada apakah pengguna masuk atau tidak, atau menawarkan untuk masuk dan menampilkan setelah login berhasil: </p><br><p>  <strong>Objek konfigurasi</strong> </p><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// `RoutingDestination`    .          . struct AppDestination: RoutingDestination { let finalStep: RoutingStep let context: Any? } struct Configuration { //     ,             static func productDestination(with productID: UUID) -&gt; AppDestination { let productScreen = StepAssembly(finder: ProductViewControllerFinder(), factory: ProductViewControllerFactory()) .add(LoginInterceptor()) .add(ProductViewControllerContextTask()) .add(ProductViewControllerPostTask(analyticsManager: AnalyticsManager.sharedInstance)) .using(PushToNavigationAction()) .from(NavigationControllerStep()) .using(GenericActions.PresentModally()) .from(CurrentControllerStep()) .assemble() return AppDestination(finalStep: productScreen, context: productID) } }</span></span></code> </pre> <br><p> <strong>  </strong> </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductArrayViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITableViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> products: [<span class="hljs-type"><span class="hljs-type">UUID</span></span>]? <span class="hljs-comment"><span class="hljs-comment">//... // DefaultRouter -  Router   ,   UIViewController   let router = DefaultRouter() override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) { guard let productID = products[indexPath.row] else { return } router.navigate(to: Configuration.productDestination(with: productID)) } }</span></span></code> </pre> <br><p> <strong>  </strong> </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@UIApplicationMain</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppDelegate</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIResponder</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIApplicationDelegate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... func application(_ application: UIApplication, open url: URL, sourceApplication: String?, annotation: Any) -&gt; Bool { guard let productID = UniversalLinksManager.parse(url: url) else { return false } return DefaultRouter().navigate(to: Configuration.productDestination(with: productID)) == .handled } }</span></span></code> </pre><br><p>              . </p><br><p>             . ,          , ,           ‚Äî       ProductArrayViewController,      UINavigationController   HomeViewController ‚Äî         <code>StepAssembly</code>  <code>from()</code> .     <code>RouteComposer</code> ,      (     ).  ,      <code>Configuration</code>               .     ,      A/B ,         . </p><br><h3 id="vmesto-zaklyucheniya">  Alih-alih sebuah kesimpulan </h3><br><p>   ,      3       .     ,  ,       .   <code>Fabric</code> , <code>Finder</code>  <code>Action</code>            .   ,     ‚Äî              ,    ,       .          ,      . </p><br><p> ,      ,      objective c       Cocoa Touch,             .     iOS  9  12. </p><br><p>            <code>UIViewController</code>  (MVC, MVVM, VIP, RIB, VIPER  ..) </p><br><p>      ,   ,     ,   .         .            . </p><br><p>      . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id421097/">https://habr.com/ru/post/id421097/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id421087/index.html">Cara mengatur penerapan aplikasi web di Go for Gitlab di VDS</a></li>
<li><a href="../id421089/index.html">Penyedia Rusia telah menemukan cara untuk mentransfer ke Google bagian dari biaya "Paket Musim Semi"</a></li>
<li><a href="../id421091/index.html">Bagaimana kami mengurangi waktu untuk mengembangkan model penilaian lima kali dengan beralih ke Python</a></li>
<li><a href="../id421093/index.html">Bagaimana saya belajar kerangka Spring - bagian 2 (bantuan untuk pemula - karya pemula sendiri)</a></li>
<li><a href="../id421095/index.html">Di bawah undang-undang baru tentang pemblokiran pra-sidang dapat jatuh 19 juta situs</a></li>
<li><a href="../id421099/index.html">Apakah sulit berkonsentrasi? Mungkin itu bukan salahmu</a></li>
<li><a href="../id421101/index.html">"Kalender Tester" untuk bulan Agustus. Baca buku</a></li>
<li><a href="../id421103/index.html">Pandangan pertama pada Mavic 2: terbang lebih lama, lebih tenang, lebih cepat</a></li>
<li><a href="../id421105/index.html">Situasi: Spotify membuat kesepakatan langsung dengan musisi - label tidak senang</a></li>
<li><a href="../id421107/index.html">Kami membongkar dan melihat sertifikat yang memenuhi syarat menggunakan Python / Tkinter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>