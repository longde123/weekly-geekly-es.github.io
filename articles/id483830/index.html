<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😞 🧝🏽 💉 Routing untuk iOS: navigasi universal tanpa menulis ulang aplikasi 🔥 🕝 🍀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam aplikasi apa pun yang terdiri lebih dari satu layar, ada kebutuhan untuk mengimplementasikan navigasi di antara komponen-komponennya. Tampaknya ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Routing untuk iOS: navigasi universal tanpa menulis ulang aplikasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/483830/">  Dalam aplikasi apa pun yang terdiri lebih dari satu layar, ada kebutuhan untuk mengimplementasikan navigasi di antara komponen-komponennya.  Tampaknya ini seharusnya tidak menjadi masalah, karena di UIKit ada komponen kontainer yang cukup nyaman seperti UINavigationController dan UITabBarController, serta metode tampilan modal yang fleksibel: cukup gunakan navigasi yang tepat pada waktu yang tepat. <br><img src="https://habrastorage.org/webt/h0/r3/vf/h0r3vfqvn3tlkotbyelqpy5jqjo.png"><br>  Namun, segera setelah aplikasi beralih ke layar menggunakan push notification atau tautan, semuanya menjadi sedikit lebih rumit.  Segera ada banyak pertanyaan: <br><br><ul><li>  Apa yang harus dilakukan dengan pengontrol tampilan, yang sekarang ada di layar? </li><li>  cara beralih konteks (mis. tab aktif di UITabBarController)? </li><li>  Apakah tumpukan navigasi saat ini memiliki layar yang tepat? </li><li>  kapan navigasi harus diabaikan? </li></ul><br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/rb/dr/zb/rbdrzb1qpjkgxw6zfclqjqtdstq.gif" width="300"><br><br>  Dalam pengembangan iOS, kami di Badoo menemukan semua masalah ini.  Sebagai hasilnya, kami memformalkan metode solusi kami menjadi pustaka komponen untuk navigasi, yang kami gunakan di semua produk baru.  Pada artikel ini saya akan berbicara tentang pendekatan kami secara lebih rinci.  Contoh penerapan praktik yang dijelaskan dapat dilihat dalam <a href="https://github.com/azatZul/NavigationDemo">proyek demo</a> kecil. <br><br><h2>  Masalah kita </h2><br>  Seringkali masalah navigasi diselesaikan dengan menambahkan komponen global yang mengetahui struktur layar dalam aplikasi dan memutuskan apa yang harus dilakukan dalam kasus tertentu.  Struktur layar berarti informasi tentang keberadaan wadah dalam hierarki pengendali dan bagian aplikasi saat ini. <br><br>  Badoo memiliki komponen yang serupa.  Ini bekerja dengan cara yang mirip dengan perpustakaan yang agak lama dari Facebook, yang sekarang tidak lagi dapat ditemukan di repositori publiknya.  Navigasi didasarkan pada URL yang terkait dengan layar aplikasi.  Pada dasarnya, semua logika terkandung dalam satu kelas, yang terkait dengan keberadaan bilah tab dan beberapa fungsi khusus untuk Badoo.  Kompleksitas dan konektivitas komponen ini sangat tinggi sehingga penyelesaian tugas yang membutuhkan perubahan dalam logika navigasi bisa memakan waktu beberapa kali lebih lama dari yang direncanakan.  Testabilitas kelas ini juga menimbulkan pertanyaan besar. <br><br>  Komponen ini dibuat ketika kami hanya memiliki satu aplikasi.  Kita tidak dapat membayangkan bahwa di masa depan kita akan mengembangkan beberapa produk yang sangat berbeda satu sama lain ( <a href="https://bumble.com/">Bumble</a> , <a href="https://lumenapp.com/">Lumen</a> dan lain-lain).  Karena alasan ini, navigator dari aplikasi kami yang paling dewasa - Badoo - tidak mungkin digunakan dalam produk lain dan setiap tim harus membuat sesuatu yang baru. <br><br>  Sayangnya, pendekatan baru juga dipertajam untuk aplikasi tertentu.  Dengan meningkatnya jumlah proyek, masalahnya menjadi jelas dan muncul ide untuk membuat perpustakaan yang akan menyediakan serangkaian komponen tertentu, termasuk logika navigasi universal.  Ini akan membantu meminimalkan waktu implementasi fungsionalitas serupa di produk baru. <br><br><h2>  Kami menerapkan router universal </h2><br>  Tugas utama yang diselesaikan oleh navigator global tidak begitu banyak: <br><br><ol><li>  Temukan layar aktif saat ini. </li><li>  Entah bagaimana membandingkan jenis layar aktif dan isinya dengan apa yang perlu ditampilkan. </li><li>  Lakukan transisi seperlunya (urutan transisi). </li></ol><br>  Mungkin perumusan tugas terlihat agak abstrak, tetapi abstraksi inilah yang memungkinkan untuk melakukan universalisasi logika. <br><br><h3>  1. Pencarian layar aktif </h3><br>  Tugas pertama tampaknya cukup sederhana: Anda hanya harus melalui seluruh hierarki layar dan menemukan <i>UIViewController</i> teratas. <br><br><img src="https://habrastorage.org/webt/vw/dj/er/vwdjerugihaukbnwqjri1cd4wu0.png"><br><br>  Antarmuka objek kita mungkin terlihat seperti ini: <br><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopViewControllerProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> topViewController: <span class="hljs-type"><span class="hljs-type">UIViewController?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } }</code> </pre> <br>  Namun, tidak jelas bagaimana menentukan elemen root dari hierarki dan apa yang harus dilakukan dengan layar kontainer seperti UIPageViewController dan wadah khusus aplikasi. <br><br>  Opsi termudah untuk menentukan elemen root adalah dengan mengambil pengontrol root dari layar aktif: <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.windows.first { $<span class="hljs-number"><span class="hljs-number">0</span></span>.isKeyWindow }?.rootViewController</code> </pre> <br>  Pendekatan ini mungkin tidak selalu berfungsi dengan aplikasi di mana ada banyak jendela.  Tetapi ini adalah kasus yang agak jarang, dan masalahnya dapat diselesaikan dengan secara eksplisit melewatkan jendela yang diinginkan sebagai parameter. <br><br>  Masalah dengan layar kontainer dapat diselesaikan dengan membuat protokol khusus untuk mereka, yang akan berisi metode untuk mendapatkan layar aktif, atau Anda dapat menggunakan protokol yang diumumkan di atas.  Semua pengontrol wadah yang digunakan dalam aplikasi harus mengimplementasikan protokol ini.  Misalnya, untuk <i>UITabBarController,</i> implementasi mungkin terlihat seperti ini: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITabBarController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopViewControllerProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> topViewController: <span class="hljs-type"><span class="hljs-type">UIViewController?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.selectedViewController } }</code> </pre> <br>  Tetap hanya melalui seluruh hierarki dan mendapatkan layar teratas.  Jika pengontrol berikutnya mengimplementasikan TopViewControllerProvider, kita akan mendapatkan layar yang ditunjukkan padanya melalui metode yang dideklarasikan.  Jika tidak, pengontrol yang ditunjukkan padanya akan diperiksa secara moderat (jika ada). <br><br><h3>  2. Konteks saat ini </h3><br>  Tugas menentukan konteks saat ini terlihat jauh lebih rumit.  Kami ingin menentukan jenis layar dan, mungkin, informasi yang ditampilkan di sana.  Tampaknya logis untuk membuat struktur yang mengandung informasi ini. <br><br>  Tetapi tipe apa yang harus memiliki properti objek?  Tujuan utama kami adalah membandingkan konteks dengan apa yang perlu ditampilkan, sehingga mereka harus mengimplementasikan protokol yang <i>setara</i> .  Ini dapat diimplementasikan melalui tipe generik: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerContext</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScreenType</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Equatable</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InfoType</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Equatable</span></span></span><span class="hljs-class">&gt;: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Equatable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> screenType: <span class="hljs-type"><span class="hljs-type">ScreenType</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> info: <span class="hljs-type"><span class="hljs-type">InfoType?</span></span> }</code> </pre> <br>  Namun, karena spesifikasi Swift, ini memberlakukan batasan tertentu pada penggunaan jenis ini.  Untuk menghindari masalah, struktur ini dalam aplikasi kami memiliki tampilan yang sedikit berbeda: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerContextInfo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEqual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to info: ViewControllerContextInfo?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerContext</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Equatable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> screenType: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> info: <span class="hljs-type"><span class="hljs-type">ViewControllerContextInfo?</span></span> }</code> </pre> <br>  Opsi lain adalah memanfaatkan fitur Swift baru, <a href="https://docs.swift.org/swift-book/LanguageGuide/OpaqueTypes.html">Tipe Buram</a> , tetapi hanya tersedia mulai dengan iOS 13, yang masih tidak dapat diterima untuk banyak produk. <br><br>  Implementasi perbandingan konteks cukup jelas.  Agar tidak menulis fungsi isEqual untuk tipe yang sudah menerapkan Equatable, Anda bisa melakukan trik sederhana, kali ini menggunakan keunggulan Swift: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerContextInfo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Self</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Equatable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEqual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to info: ViewControllerContextInfo?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> info = info <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">Self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> == info } }</code> </pre> <br>  Hebat, kami memiliki objek untuk dibandingkan.  Tetapi bagaimana Anda bisa menghubungkannya dengan <i>UIViewController</i> ?  Salah satu caranya adalah dengan menggunakan <a href="https://developer.apple.com/documentation/objectivec/1418509-objc_setassociatedobject%3Flanguage%3Dobjc">objek terkait</a> , fitur yang berguna dari bahasa Objective C. dalam beberapa kasus, tetapi pertama, itu tidak terlalu eksplisit, dan kedua, kami biasanya ingin membandingkan konteks hanya beberapa layar aplikasi.  Karena itu, membuat protokol tampak ide yang bagus: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerContextHolder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentContext: <span class="hljs-type"><span class="hljs-type">ViewControllerContext?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } }</code> </pre> <br><br>  dan implementasinya hanya di layar yang diperlukan.  Jika layar aktif tidak menerapkan protokol ini, maka isinya dapat dianggap tidak signifikan dan tidak diperhitungkan saat menampilkan yang baru. <br><br><h3>  3. Eksekusi transisi </h3><br>  Mari kita lihat apa yang sudah kita miliki.  Kemampuan setiap saat untuk mendapatkan informasi tentang layar aktif dalam bentuk struktur data tertentu.  Informasi yang diterima secara eksternal melalui URL terbuka, pemberitahuan push, atau cara lain untuk memulai navigasi, yang dapat dikonversi menjadi struktur dengan tipe yang sama dan berfungsi sebagai maksud navigasi.  Jika layar atas sudah menunjukkan informasi yang diperlukan, maka Anda dapat mengabaikan navigasi atau memperbarui konten layar. <br><br><img src="https://habrastorage.org/webt/wl/wq/lx/wlwqlxy8knlnfjgy6sg-gmnycm4.png"><br><br>  Tetapi bagaimana dengan transisi itu sendiri? <br><br>  Adalah logis untuk membuat komponen (sebut saja <b>router</b> ) yang akan mengambil apa yang Anda perlu tunjukkan pada input, membandingkannya dengan apa yang telah ditampilkan, dan melakukan transisi atau urutan transisi.  Selain itu, router mungkin berisi logika umum untuk memproses dan memvalidasi informasi dan status aplikasi.  Yang utama adalah Anda tidak harus memasukkan logika khusus untuk fungsi domain atau aplikasi dalam komponen ini.  Jika Anda mematuhi aturan ini, itu akan tetap dapat digunakan kembali untuk berbagai aplikasi dan mudah dipelihara. <br><br>  Deklarasi antarmuka dasar protokol semacam itu terlihat seperti ini: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerContextRouterProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">navigateToContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> context: ViewControllerContext, animated: Bool)</span></span></span></span> }</code> </pre> <br>  Anda dapat menggeneralisasi fungsi di atas dengan melewati urutan konteks.  Ini tidak akan berdampak signifikan pada implementasi. <br><br>  Cukup jelas bahwa router akan memerlukan pabrik pengontrol, karena hanya data navigasi yang diterima pada inputnya.  Penting untuk membuat layar terpisah di dalam pabrik, dan mungkin bahkan seluruh modul berdasarkan konteks yang ditransfer.  Dari bidang <i>screenType</i> , <i>Anda</i> dapat menentukan layar mana yang ingin Anda buat, dari bidang <i>info</i> - dengan data apa yang perlu Anda isi sebelumnya: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllersByContextFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> context: ViewControllerContext)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIViewController?</span></span> }</code> </pre> <br>  Jika aplikasi ini bukan klon Snapchat, maka kemungkinan besar metode yang digunakan untuk menampilkan pengontrol baru akan kecil.  Oleh karena itu, untuk sebagian besar aplikasi, memperbarui tumpukan <i>UINavigationController</i> dan menampilkan layar modal sudah cukup.  Dalam hal ini, Anda dapat menentukan enum dengan tipe yang mungkin, misalnya: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NavigationType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> modal <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> navigationStack <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> rootScreen }</code> </pre> <br>  Jenis layar tergantung pada bagaimana itu ditampilkan.  Jika ini adalah notifikasi pemblokiran, maka itu perlu ditampilkan secara moderen.  Layar lain mungkin perlu ditambahkan ke tumpukan navigasi yang ada melalui <i>UINavigationController</i> . <br><br>  Memutuskan cara menampilkan layar tertentu lebih baik tidak di router itu sendiri.  Jika kita menambahkan ketergantungan router di bawah protokol <i>ViewControllerNavigationTypeProvider</i> dan mengimplementasikan seperangkat metode yang diinginkan khusus untuk setiap aplikasi, maka kita akan mencapai tujuan ini: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerNavigationTypeProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">navigationType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> context: ViewControllerContext)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">NavigationType</span></span> }</code> </pre> <br>  Tetapi bagaimana jika kita ingin memperkenalkan jenis navigasi baru di salah satu aplikasi?  Perlu menambahkan opsi baru ke enum, dan semua aplikasi lain akan mengetahuinya?  Mungkin, dalam beberapa kasus inilah yang kami perjuangkan, tetapi jika Anda berpegang pada prinsip <a href="https://en.wikipedia.org/wiki/Open%25E2%2580%2593closed_principle">terbuka-tertutup</a> , maka untuk fleksibilitas yang lebih besar Anda dapat memasukkan protokol objek yang dapat melakukan transisi: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerContextTransition</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">navigate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(from source: UIViewController?, to destination: UIViewController, animated: Bool)</span></span></span></span> }</code> </pre> <br>  Kemudian <i>ViewControllerNavigationTypeProvider</i> akan berubah menjadi ini: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerContextTransitionProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> context: ViewControllerContext)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ViewControllerContextTransition</span></span> }</code> </pre> <br>  Sekarang kita tidak terbatas pada set tipe tampilan layar yang tetap dan kita dapat memperluas kemampuan navigasi tanpa perubahan pada router itu sendiri. <br><br>  Terkadang Anda tidak perlu membuat <i>UIViewController</i> baru untuk beralih ke beberapa layar - cukup beralih ke yang sudah ada.  Contoh yang paling jelas adalah berpindah tab di <i>UITabBarController</i> .  Contoh lain adalah transisi ke elemen yang ada di tumpukan pengontrol yang ditampilkan alih-alih membuat layar baru dengan konten yang sama.  Untuk melakukan ini, di router, sebelum membuat <i>UIViewController</i> baru <i>,</i> Anda dapat terlebih dahulu memeriksa apakah konteksnya dapat diaktifkan. <br><br>  Bagaimana cara mengatasi masalah ini?  Lebih banyak abstraksi! <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerContextSwitcher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canSwitch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to context: ViewControllerContext)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">switchContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to context: ViewControllerContext, animated: Bool)</span></span></span></span> }</code> </pre> <br>  Dalam hal tab, protokol ini dapat diimplementasikan oleh komponen yang tahu apa yang terkandung dalam <i>UITabBarViewController</i> dan dapat memetakan <i>ViewControllerContext</i> ke tab tertentu dan beralih tab. <br><br><img src="https://habrastorage.org/webt/r_/do/yv/r_doyvigb9gfjp-i8afhu-btglk.gif" width="300"><br><br>  Seperangkat objek tersebut dapat diteruskan ke router sebagai ketergantungan. <br><br>  Untuk meringkas, algoritma pemrosesan konteks akan terlihat seperti ini: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">navigateToContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> context: ViewControllerContext, animated: Bool)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> topViewController = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.topViewControllerProvider.topViewController <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contextHolder = topViewController <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">ViewControllerContextHolder</span></span>, contextHolder.currentContext == context { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> switcher = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.contextSwitchers.first(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: { $<span class="hljs-number"><span class="hljs-number">0</span></span>.canSwitch(to: context) }) { switcher.switchContext(to: context, animated: animated) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> viewController = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.viewControllersFactory.viewController(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: context) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> navigation = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.transitionProvider.navigation(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: context) navigation.navigate(from: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.topViewControllerProvider.topViewController, to: viewController, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) }</code> </pre> <br><br>  Lebih mudah untuk menampilkan diagram ketergantungan router dalam bentuk diagram UML: <br><br><img src="https://habrastorage.org/webt/jt/ic/gk/jticgkvmsmm5own334ql_uvq6mg.png"><br><br>  Router yang dihasilkan dapat digunakan untuk transisi yang dimulai secara otomatis atau melalui tindakan pengguna.  Dalam produk kami, jika navigasi tidak terjadi secara otomatis, fungsi sistem standar digunakan, dan sebagian besar modul tidak menyadari keberadaan router global.  Penting untuk diingat tentang implementasi protokol <i>ViewControllerContextHolder</i> jika diperlukan agar router selalu dapat mengetahui informasi yang dilihat pengguna pada waktu saat ini. <br><br><h2>  Keuntungan dan kerugian </h2><br>  Baru-baru ini, kami mulai memperkenalkan metode manajemen navigasi yang dijelaskan ke dalam produk Badoo.  Terlepas dari kenyataan bahwa implementasinya ternyata sedikit lebih rumit daripada opsi yang disajikan dalam <a href="https://github.com/azatZul/NavigationDemo">proyek demo</a> , kami senang dengan hasilnya.  Mari kita mengevaluasi kelebihan dan kekurangan dari pendekatan yang dijelaskan. <br><br>  Dari manfaatnya antara lain: <br><br><ul><li>  universalitas </li><li>  relatif mudahnya implementasi, bila dibandingkan dengan opsi yang disajikan di bagian alternatif, </li><li>  kurangnya batasan pada arsitektur aplikasi dan implementasi navigasi konvensional antar layar. </li></ul><br>  Kerugiannya sebagian merupakan konsekuensi dari keuntungan. <br><br><ul><li>  Pengendali perlu mengetahui informasi apa yang ditampilkan.  Jika kita mempertimbangkan arsitektur aplikasi, UIViewController harus ditugaskan ke lapisan tampilan, dan logika bisnis tidak boleh disimpan di lapisan ini.  Struktur data yang mengandung konteks navigasi harus diimplementasikan di sana dari lapisan logika bisnis, tetapi tetap saja pengendali akan menyimpan informasi ini, yang tidak terlalu benar. </li><li>  Sumber kebenaran tentang keadaan aplikasi adalah hierarki layar yang ditampilkan, yang dalam beberapa kasus mungkin menjadi batasan. </li></ul><br><br><h2>  Alternatif </h2><br>  Alternatif untuk pendekatan ini bisa dengan membangun hierarki modul aktif secara manual.  Contoh dari solusi semacam itu adalah <a href="https://github.com/AndreyPanov/ApplicationCoordinator">penerapan</a> pola Koordinator, di mana koordinator membentuk struktur pohon yang berfungsi sebagai sumber kebenaran untuk menentukan layar aktif, dan logika keputusan untuk menunjukkan layar ini atau itu atau tidak itu terdapat di dalam koordinator itu sendiri. <br><br>  Gagasan serupa dapat ditemukan dalam arsitektur <a href="https://github.com/uber/RIBs">RIB</a> , yang <a href="https://badootech.badoo.com/the-immense-benefits-of-not-thinking-in-screens-6c311e3344a0">digunakan oleh</a> tim Android kami. <br><br>  Alternatif semacam itu memberikan abstraksi yang lebih fleksibel, tetapi membutuhkan keseragaman dalam arsitektur dan bisa terlalu rumit untuk banyak aplikasi. <br><br>  Jika Anda mengambil pendekatan berbeda untuk menyelesaikan masalah seperti itu, jangan ragu untuk membicarakannya di komentar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id483830/">https://habr.com/ru/post/id483830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id483818/index.html">Engine, bahasa scripting, dan novel visual - dalam 45 jam</a></li>
<li><a href="../id483820/index.html">Apa yang mempengaruhi penerbitan kredit. Ikhtisar Kompetisi Risiko Default Kredit Rumah</a></li>
<li><a href="../id483822/index.html">5 fitur JavaScript yang tanpanya saya tidak bisa menulis kode</a></li>
<li><a href="../id483826/index.html">Menghubungkan Model Sensor CO2 MH-Z19B Menggunakan Output Analog Vo</a></li>
<li><a href="../id483828/index.html">Pertukaran atom yang bersinar dan kemiskinan</a></li>
<li><a href="../id483832/index.html">RxJava to Coroutines: migrasi fitur ujung ke ujung</a></li>
<li><a href="../id483834/index.html">Debian: cukup mengubah i386 menjadi amd64</a></li>
<li><a href="../id483842/index.html">Sejarah menciptakan cloud rumah. Bagian 5. Memperbarui 2019 - PHP 7.2, MariaDB 10.4 dan Nextcloud 17</a></li>
<li><a href="../id483844/index.html">Analisis dokumen peraturan tentang perlindungan informasi di sektor kredit dan keuangan Rusia</a></li>
<li><a href="../id483846/index.html">Manajemen jendela alternatif di Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>