<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨â€ğŸ‘§â€ğŸ‘¦ ğŸ¥› ğŸ˜‹ Apa maksud tidak aman di Rust? ğŸ ğŸ¤¸ğŸ¿ ğŸ—³ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya mempersembahkan kepada Anda terjemahan artikel "Apa itu Rust tidak aman?" penulis Kode Nora. 


 Saya telah melihat banyak kesalahpah...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa maksud tidak aman di Rust?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460295/"><p> Halo, Habr!  Saya mempersembahkan kepada Anda terjemahan artikel "Apa itu Rust tidak aman?"  penulis Kode Nora. </p><br><p>  Saya telah melihat banyak kesalahpahaman tentang arti kata kunci tidak aman untuk kegunaan dan kebenaran bahasa Rust dan promosinya sebagai "bahasa pemrograman sistem yang aman".  Sayangnya, kebenarannya jauh lebih rumit daripada yang bisa dijelaskan dalam tweet pendek.  Ini adalah bagaimana saya melihatnya. </p><br><p>  Secara umum, <strong>kata kunci tidak aman tidak mematikan sistem tipe yang membuat kode Rust tetap benar</strong> .  Itu hanya memungkinkan untuk menggunakan beberapa "kekuatan super," seperti pointer dereferencing.  unsafe digunakan untuk mengimplementasikan abstraksi yang aman berdasarkan dunia yang pada dasarnya tidak aman sehingga sebagian besar kode Rust dapat menggunakan abstraksi ini dan menghindari akses memori yang tidak aman. <a name="habracut"></a></p><br><h1 id="garantiya-bezopasnosti">  Jaminan keamanan </h1><br><p>  Rust menjamin keamanan sebagai salah satu prinsip intinya.  Kita dapat mengatakan bahwa ini adalah <em>arti dari keberadaan</em> bahasa.  Namun, itu tidak memberikan keamanan dalam arti tradisional, selama pelaksanaan program dan menggunakan pemulung.  Sebaliknya, Rust menggunakan sistem tipe yang sangat canggih untuk melacak kapan dan nilai apa yang dapat diakses.  Compiler kemudian secara statis menganalisis setiap program Rust untuk memastikan bahwa selalu dalam keadaan yang benar. </p><br><h2 id="bezopasnost-v-python">  Keamanan Python </h2><br><p>  Mari kita ambil Python sebagai contoh.  Kode Python murni tidak dapat merusak memori.  Akses ke item daftar memiliki cek untuk melampaui batas;  tautan yang dikembalikan oleh fungsi dihitung untuk menghindari munculnya tautan yang menggantung;  Tidak ada cara untuk melakukan aritmatika arbitrer dengan pointer. </p><br><p>  Ini memiliki dua konsekuensi.  Pertama, banyak jenis harus "istimewa."  Misalnya, tidak mungkin untuk mengimplementasikan daftar atau kamus yang efektif dengan Python murni.  Sebaliknya, juru bahasa CPython memiliki implementasi internal mereka.  Kedua, akses ke fungsi eksternal (fungsi tidak diimplementasikan dengan Python), yang disebut antarmuka fungsi eksternal, memerlukan penggunaan modul ctypes khusus dan melanggar jaminan keamanan bahasa. </p><br><p>  Dalam arti tertentu, ini berarti bahwa semua yang ditulis dengan Python tidak menjamin akses yang aman ke memori. </p><br><h2 id="bezopasnost-v-rust">  Keamanan di Rust </h2><br><p>  Rust juga menyediakan keamanan, tetapi alih-alih menerapkan struktur yang tidak aman di C, ia menyediakan trik: kata kunci tidak aman.  Ini berarti bahwa struktur data mendasar di Rust, seperti Vec, VecDeque, BTreeMap, dan String, diimplementasikan di Rust. </p><br><p>  Anda mungkin bertanya: "Tetapi, jika Rust memberikan tipuan terhadap jaminan keamanan kode, dan pustaka standar diimplementasikan menggunakan trik ini, bukankah segala sesuatu di Rust akan dianggap tidak aman?" </p><br><p>  Singkatnya, pembaca yang budiman, <strong>ya</strong> , persis seperti di Python.  Mari kita lihat lebih detail. </p><br><h1 id="chto-zaprescheno-v-bezopasnom-rust">  Apa yang dilarang di Rust yang aman? </h1><br><p>  Keamanan di Rust didefinisikan dengan baik: kami banyak memikirkannya.  Singkatnya, program Rust yang aman tidak bisa: </p><br><ul><li>  <strong>Mendereferensi pointer yang menunjuk ke tipe yang berbeda dari yang diketahui kompiler</strong> .  Ini berarti bahwa tidak ada pointer ke nol (karena mereka tidak menunjuk ke mana pun), tidak ada kesalahan keluar dari batas dan / atau kesalahan segmentasi (kesalahan segmentasi), tidak ada buffer overflow.  Tetapi itu juga berarti bahwa tidak ada kegunaan setelah membebaskan memori atau membebaskan kembali memori (karena membebaskan memori dianggap sebagai penereferensi pointer) dan tidak ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pun kata yang dimaksudkan untuk mengetik</a> . </li><li>  <strong>Memiliki beberapa referensi yang dapat berubah ke suatu objek atau secara bersamaan referensi yang dapat berubah dan tidak dapat diubah ke suatu objek</strong> .  Yaitu, jika Anda memiliki referensi yang dapat diubah ke suatu objek, Anda hanya dapat memilikinya, dan jika Anda memiliki referensi yang tidak dapat diubah ke objek, itu tidak akan berubah sampai Anda menyimpannya.  Ini berarti bahwa Anda tidak dapat memaksa perlombaan data di Safe Rust, yang merupakan jaminan bahwa sebagian besar bahasa aman lainnya tidak dapat menyediakan. </li></ul><br><p>  Karat mengkodekan informasi ini dalam sistem tipe atau menggunakan <strong>tipe data aljabar</strong> , seperti Opsi untuk menunjukkan ada / tidaknya nilai dan Hasil &lt;T, E&gt; untuk menunjukkan kesalahan / keberhasilan, atau <strong>referensi dan masa pakainya</strong> , misalnya, &amp; T vs &amp; mut T untuk menunjukkan tautan umum (tidak dapat diubah) dan tautan eksklusif (dapat diubah) dan &amp; a T vs &amp; 'b T untuk membedakan tautan yang benar dalam konteks yang berbeda (ini biasanya dihilangkan karena kompiler cukup pintar untuk mengetahuinya sendiri) . <br></p><br><h2 id="primery">  Contohnya </h2><br><p>  Misalnya, kode berikut ini tidak akan dikompilasi karena mengandung tautan menggantung.  Lebih khusus, <em>my_struct tidak cukup hidup</em> .  Dengan kata lain, fungsi akan mengembalikan tautan ke sesuatu yang tidak ada lagi, dan oleh karena itu kompiler tidak dapat (dan, pada kenyataannya, bahkan tidak tahu bagaimana) mengkompilasi ini. </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dangling_reference</span></span></span></span>(v: &amp;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; &amp;MyStruct { <span class="hljs-comment"><span class="hljs-comment">//     MyStruct   ,  v,   . let my_struct = MyStruct { value: v }; //      my_struct. return &amp;my_struct; //  - my_struct  (  ). }</span></span></code> </pre> <br><p>  Kode ini melakukan hal yang sama, tetapi mencoba untuk mengatasi masalah ini dengan menempatkan nilai pada heap (Box adalah nama dari smart pointer dasar di Rust). </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dangling_heap_reference</span></span></span></span>(v: &amp;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;MyStruct&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_struct = MyStruct { value: v }; <span class="hljs-comment"><span class="hljs-comment">//    Box         . let my_box = Box::new(my_struct); //      my_box. return &amp;my_box; // my_box   .   "" my_struct       - , //    - MyStruct  . }</span></span></code> </pre> <br><p>  Kode yang benar dikembalikan oleh Box itu sendiri dan bukan referensi untuk itu.  Ini mengkodekan transfer kepemilikan - tanggung jawab untuk membebaskan memori - dalam tanda tangan fungsi.  Ketika melihat tanda tangan, menjadi jelas bahwa kode panggilan bertanggung jawab atas apa yang terjadi dengan Box, dan, memang, kompiler memprosesnya secara otomatis. <br></p><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">no_dangling_reference</span></span></span></span>(v: &amp;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;MyStruct&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_struct = MyStruct { value: v }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_box = <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(my_struct); <span class="hljs-comment"><span class="hljs-comment">//    my_box  . return my_box; //    .         , //    ;       //  Box&lt;MyStruct&gt;       ,      . }</span></span></code> </pre> <br><blockquote>  Beberapa hal buruk tidak dilarang di Rust yang aman.  Sebagai contoh, itu diizinkan dari sudut pandang kompiler: <br><ul><li>  menyebabkan kebuntuan dalam program </li><li>  kebocoran sejumlah besar memori yang sewenang-wenang </li><li>  gagal menutup pegangan file, koneksi basis data, atau penutup poros rudal </li></ul><br><br>  Kekuatan ekosistem Rust adalah bahwa banyak proyek memilih untuk menggunakan sistem tipe untuk memastikan bahwa kode seakurat mungkin, tetapi kompiler tidak memerlukan paksaan seperti itu, kecuali dalam kasus di mana akses memori yang aman disediakan. </blockquote><br><h1 id="chto-razresheno-v-nebezopasnom-rust">  Apa yang diizinkan di Rust yang tidak aman? </h1><br><p>  Kode Karat Tidak Aman adalah kode Karat dengan kata kunci tidak aman.  tidak aman dapat diterapkan ke fungsi atau blok kode.  Ketika diterapkan pada suatu fungsi, itu berarti "fungsi ini mensyaratkan bahwa kode yang dipanggil secara manual menyediakan invarian yang biasanya disediakan oleh kompiler."  Ketika diterapkan pada blok kode, itu berarti "blok kode ini secara manual menyediakan invarian yang diperlukan untuk mencegah akses yang tidak aman ke memori, dan oleh karena itu diperbolehkan untuk melakukan hal-hal yang tidak aman." </p><br><p>  <strong>Dengan kata lain, tidak aman untuk fungsi berarti "Anda perlu memeriksa semuanya", dan pada blok kode - "Saya sudah memeriksa semuanya."</strong> </p><br><p>  Seperti dicatat dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bahasa Pemrograman Karat</a> , kode dalam blok yang ditandai dengan kata kunci tidak aman dapat: </p><br><ul><li>  <strong>Dereferensi penunjuk.</strong>  Ini adalah "kekuatan super" utama yang memungkinkan Anda untuk mengimplementasikan daftar yang ditautkan ganda, peta hash, dan struktur data mendasar lainnya. </li><li>  <strong>Panggil fungsi atau metode yang tidak aman.</strong>  Lebih lanjut tentang ini di bawah ini. </li><li>  <strong>Akses atau ubah variabel statis yang dapat berubah.</strong>  Variabel statis yang ruang lingkupnya tidak dikontrol tidak dapat diperiksa secara statis, oleh karena itu penggunaannya tidak aman. </li><li>  <strong>Terapkan sifat tidak aman.</strong>  Sifat tidak aman digunakan untuk menandai apakah tipe tertentu menjamin invarian tertentu.  Misalnya, Kirim dan Sinkronisasi menentukan apakah suatu jenis dapat dikirim di antara batas utas atau dapat digunakan oleh beberapa utas secara bersamaan. </li></ul><br><p>  Ingat pointer menggantung di atas?  Tambahkan kata tidak aman, dan kompiler akan bersumpah dua kali lebih banyak karena dia tidak suka menggunakan tidak aman di tempat yang tidak diperlukan. </p><br><p>  Alih-alih, kata kunci yang tidak aman digunakan untuk mengimplementasikan abstraksi yang aman berdasarkan operasi penunjuk sewenang-wenang.  Misalnya, tipe Vec diimplementasikan menggunakan tidak aman, tetapi aman untuk menggunakannya, karena memeriksa upaya untuk mengakses elemen dan tidak memungkinkan meluap.  Meskipun ia menyediakan operasi seperti set_len, yang <em>dapat</em> menyebabkan akses memori tidak aman, mereka ditandai sebagai tidak aman. </p><br><p>  Misalnya, kita bisa melakukan hal yang sama seperti pada contoh no_dangling_reference, tetapi dengan penggunaan tidak aman yang tidak masuk akal: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">manual_heap_reference</span></span></span></span>(v: <span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> MyStruct { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_struct = MyStruct { value: v }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_box = <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(my_struct); <span class="hljs-comment"><span class="hljs-comment">//  Box    . let struct_pointer = Box::into_raw(my_box); return struct_pointer; //   ;     . // MyStruct     . }</span></span></code> </pre> <br><p>  Perhatikan kurangnya kata yang tidak aman.  Membuat pointer benar-benar aman.  Seperti yang ditulis, ini adalah risiko kebocoran memori, tetapi tidak lebih, dan kebocoran memori aman.  Memanggil fungsi ini juga aman.  tidak aman hanya diperlukan ketika ada sesuatu yang mencoba <strong>mengubah</strong> pointer.  Sebagai bonus tambahan, dereferencing akan secara otomatis melepaskan memori yang dialokasikan. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_pointer = manual_heap_reference(<span class="hljs-number"><span class="hljs-number">1337</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_boxed_struct = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::from_raw(my_pointer) }; <span class="hljs-comment"><span class="hljs-comment">//  "Value: 1337" println!("Value: {}", my_boxed_struct.value); // my_boxed_struct    .       ,  //    - MyStruct }</span></span></code> </pre> <br><p>  Setelah optimasi, kode ini setara dengan hanya mengembalikan Kotak.  Box adalah abstraksi berbasis pointer yang aman karena mencegah distribusi pointer di mana-mana.  Misalnya, versi utama berikutnya <strong>akan mengarah</strong> ke memori bebas ganda (double-free). </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_pointer = manual_heap_reference(<span class="hljs-number"><span class="hljs-number">1337</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_boxed_struct_1 = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::from_raw(my_pointer) }; <span class="hljs-comment"><span class="hljs-comment">// DOUBLE FREE BUG! let my_boxed_struct_2 = unsafe { Box::from_raw(my_pointer) }; //  "Value: 1337" . println!("Value: {}", my_boxed_struct_1.value); println!("Value: {}", my_boxed_struct_2.value); // my_boxed_struct_2    .     ,  //    - MyStruct. //  my_boxed_struct_1    .      , //      - MyStruct.  double-free bug. }</span></span></code> </pre> <br><h2 id="tak-chto-takoe-bezopasnaya-abstrakciya">  Jadi apa abstraksi yang aman? </h2><br><p>  Abstraksi yang aman adalah abstraksi yang menggunakan sistem tipe untuk menyediakan API yang tidak dapat digunakan untuk melanggar jaminan keamanan yang disebutkan di atas.  Kotak lebih aman * mut T, karena tidak dapat menyebabkan alokasi memori ganda, seperti yang diilustrasikan di atas. </p><br><p>  Contoh lain adalah tipe Rc di Rust.  Ini adalah penghitung penghitung referensi - referensi yang tidak dapat diubah ke data pada heap.  Karena memungkinkan beberapa akses simultan ke satu area memori, itu <em>harus</em> mencegah perubahan agar dianggap aman. </p><br><p>  Selain itu, ini bukan thread yang aman.  Jika Anda membutuhkan keamanan utas, Anda harus menggunakan tipe Arc (Penghitungan Referensi Atom), yang memiliki penalti kinerja karena penggunaan nilai atom untuk menghitung tautan dan mencegah kemungkinan balapan data di lingkungan multi-utas. </p><br><p>  Kompiler tidak akan memungkinkan Anda untuk menggunakan Rc di mana Anda harus menggunakan Arc, karena pembuat seperti Rc tidak menandainya sebagai thread aman.  Jika mereka melakukan ini, itu tidak masuk akal: janji keamanan yang salah. </p><br><h2 id="kogda-neobhodim-nebezopasnyy-rust">  Kapan Rust tidak aman dibutuhkan? </h2><br><p>  Rust yang Tidak Aman selalu diperlukan ketika perlu untuk melakukan operasi yang melanggar salah satu dari dua aturan yang dijelaskan di atas.  Misalnya, dalam daftar yang ditautkan dua kali lipat, tidak adanya tautan yang dapat berubah ke data yang sama (untuk elemen berikutnya dan elemen sebelumnya) sepenuhnya menghilangkan manfaatnya.  Dengan tidak aman, pelaksana daftar tertaut ganda dapat menulis kode menggunakan * mut Node pointer dan kemudian merangkumnya dalam abstraksi yang aman. <br></p><p>  Contoh lain adalah bekerja dengan sistem tertanam.  Seringkali mikrokontroler menggunakan satu set register yang nilainya ditentukan oleh keadaan fisik perangkat.  Dunia tidak dapat berhenti saat Anda mengambil &amp; memutus u dari register semacam itu, oleh karena itu tidak aman diperlukan untuk bekerja dengan peti dukungan perangkat.  Biasanya, peti ini merangkum keadaan dalam pembungkus yang transparan dan aman yang menyalin data bila memungkinkan, atau menggunakan teknik lain yang memberikan jaminan kompiler. </p><br><p>  Kadang-kadang perlu untuk melakukan operasi yang dapat menyebabkan membaca dan menulis secara bersamaan, atau akses tidak aman ke memori, dan ini adalah di mana tidak aman diperlukan.  Tetapi selama ada kesempatan untuk memastikan bahwa invarian aman dipertahankan sebelum pengguna menyentuh sesuatu (yaitu, tidak ditandai tidak aman), semuanya baik-baik saja. </p><br><h1 id="na-chih-plechah-lezhit-eta-otvetstvennost">  Di pundak siapa terletak tanggung jawab ini? </h1><br><p>  Kami sampai pada pernyataan yang dibuat sebelumnya - <strong>ya</strong> , kegunaan kode Rust didasarkan pada kode yang tidak aman.  Terlepas dari kenyataan bahwa ini dilakukan dengan cara yang sedikit berbeda dari implementasi struktur data dasar yang tidak aman di Python, implementasi Vec, Hashmap, dll., <strong>Harus</strong> menggunakan manipulasi pointer sampai batas tertentu. </p><br><p>  Kami mengatakan bahwa Rust aman, dengan asumsi mendasar bahwa kode tidak aman yang kami gunakan melalui dependensi kami pada pustaka standar atau kode pustaka lain ditulis dengan benar dan dienkapsulasi.  Keuntungan mendasar dari Rust adalah bahwa kode tidak aman didorong ke blok tidak aman yang harus diperiksa dengan cermat oleh penulisnya. </p><br><p>  Dalam Python, beban memeriksa keamanan manipulasi memori hanya terletak pada pengembang interpreter dan pengguna antarmuka fungsi eksternal.  Di C, beban ini ada di tangan setiap programmer. </p><br><p>  Di Rust, itu terletak pada pengguna kata kunci yang tidak aman.  Ini jelas, karena invarian harus dipelihara secara manual di dalam kode tersebut, dan oleh karena itu perlu untuk berjuang untuk jumlah terkecil dari kode tersebut di perpustakaan atau kode aplikasi.  Ketidakamanan terdeteksi, disorot, dan ditunjukkan.  Oleh karena itu, jika segfault terjadi dalam kode Rust Anda, maka Anda menemukan kesalahan dalam kompiler atau kesalahan di beberapa baris kode tidak aman Anda. </p><br><p>  Ini bukan sistem yang sempurna, tetapi jika Anda membutuhkan kecepatan, keamanan dan multithreading pada saat yang sama, maka ini adalah satu-satunya pilihan. </p><p></p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460295/">https://habr.com/ru/post/id460295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460281/index.html">Bagaimana UX Writer Membantu Meningkatkan Produk</a></li>
<li><a href="../id460283/index.html">Bahasa pemrograman do-it-yourself baru</a></li>
<li><a href="../id460285/index.html">Kami sedang menyiapkan PHP. Bagaimana sementara, foreach, array_walk dan beberapa kata menakutkan lainnya</a></li>
<li><a href="../id460287/index.html">Visualisasi berita runet</a></li>
<li><a href="../id460291/index.html">Masalah pemrosesan batch permintaan dan solusinya (bagian 1)</a></li>
<li><a href="../id460297/index.html">WeakRef - proposal untuk menambah standar skrip ECMAS</a></li>
<li><a href="../id460301/index.html">Lampu LED daya tinggi generasi baru</a></li>
<li><a href="../id460305/index.html">AERODISK Engine: Catastrophic. Bagian 2. Metrocluster</a></li>
<li><a href="../id460307/index.html">Pengalaman modeling dari tim Computer Vision Mail.ru</a></li>
<li><a href="../id460311/index.html">Saatnya teori uang baru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>