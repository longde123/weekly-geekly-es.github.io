<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñïüèº üë©üèª üßëüèø‚Äçü§ù‚Äçüßëüèº A arquitetura de uma situa√ß√£o excepcional: parte 2 de 4 üí≤ üë®üèº‚Äçüî¨ üïã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eu acho que um dos problemas mais importantes neste t√≥pico √© criar uma arquitetura de tratamento de exce√ß√µes em seu aplicativo. Isso √© interessante po...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>A arquitetura de uma situa√ß√£o excepcional: parte 2 de 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/454882/"><p><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img width="350" align="left" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png"></a>  Eu acho que um dos problemas mais importantes neste t√≥pico √© criar uma arquitetura de tratamento de exce√ß√µes em seu aplicativo.  Isso √© interessante por v√°rias raz√µes.  E a principal raz√£o, eu acho, √© uma aparente simplicidade, com a qual voc√™ nem sempre sabe o que fazer.  Todas as constru√ß√µes b√°sicas, como <code>IEnumerable</code> , <code>IDisposable</code> , <code>IObservable</code> , etc.  tenha essa propriedade e use-a em qualquer lugar.  Por um lado, sua simplicidade tenta usar essas constru√ß√µes em diferentes situa√ß√µes.  Por outro lado, eles est√£o cheios de armadilhas que voc√™ pode n√£o conseguir.  √â poss√≠vel que, olhando a quantidade de informa√ß√µes que abordaremos, voc√™ tenha uma pergunta: o que h√° de t√£o especial em situa√ß√µes excepcionais? </p><br><p>  No entanto, para tirar conclus√µes sobre a constru√ß√£o da arquitetura de classes de exce√ß√£o, devemos aprender alguns detalhes sobre sua classifica√ß√£o.  Como antes de criar um sistema de tipos que seria claro para o usu√°rio do c√≥digo, um programador deve determinar quando escolher o tipo de erro e quando capturar ou ignorar exce√ß√µes.  Ent√£o, vamos classificar as situa√ß√µes excepcionais (n√£o os tipos de exce√ß√µes) com base em v√°rios recursos. </p><a name="habracut"></a><br><h3 id="based-on-a-theoretical-possibility-to-catch-a-future-exception">  Com base em uma possibilidade te√≥rica de capturar uma exce√ß√£o futura. </h3><br><p>  Com base nesse recurso, podemos dividir as exce√ß√µes entre aquelas que ser√£o definitivamente capturadas e as que provavelmente n√£o ser√£o capturadas.  Por que digo <em>altamente prov√°vel</em> ?  Porque sempre h√° algu√©m que tentar√° capturar uma exce√ß√£o enquanto isso √© desnecess√°rio. </p><br><p>  Primeiro, vamos descrever o primeiro grupo de exce√ß√µes - aquelas que devem ser capturadas. </p><br><p>  No caso de tais exce√ß√µes, por um lado, dizemos ao nosso subsistema que chegamos a um estado em que n√£o h√° sentido em outras a√ß√µes com nossos dados.  Por outro lado, queremos dizer que nada de desastroso aconteceu e podemos encontrar a sa√≠da da situa√ß√£o simplesmente capturando a exce√ß√£o.  Essa propriedade √© muito importante, pois define a criticidade de um erro e garante que, se capturarmos uma exce√ß√£o e limparmos os recursos, podemos simplesmente prosseguir com o c√≥digo. </p><br><p>  O segundo grupo lida com exce√ß√µes que, embora possam parecer estranhas, n√£o precisam ser capturadas.  Eles podem ser usados ‚Äã‚Äãapenas para registro de erros, mas n√£o para corrigir uma situa√ß√£o.  O exemplo mais simples √© <code>ArgumentException</code> e <code>NullReferenceException</code> .  De fato, em uma situa√ß√£o comum, voc√™ n√£o precisa capturar, por exemplo, <code>ArgumentNullException</code> porque, nesse caso, a origem de um erro √© exatamente voc√™.  Se voc√™ capturar essa exce√ß√£o, admite que cometeu um erro e passou algo inaceit√°vel para um m√©todo: </p><br><pre> <code class="plaintext hljs">void SomeMethod(object argument) { try { AnotherMethod(argument); } catch (ArgumentNullException exception) { // Log it } }</code> </pre> <br><p>  Neste m√©todo, tentamos capturar <code>ArgumentNullException</code> .  Mas acho isso estranho, pois passar argumentos corretos para um m√©todo √© inteiramente nossa preocupa√ß√£o.  Reagir ap√≥s o evento seria incorreto: a melhor coisa que voc√™ pode fazer em tal situa√ß√£o √© verificar os dados passados ‚Äã‚Äãantes de chamar um m√©todo ou at√© mesmo construir esse c√≥digo onde √© imposs√≠vel obter par√¢metros errados. </p><br><p>  Outro grupo de situa√ß√µes excepcionais s√£o erros fatais.  Se algum cache estiver com defeito e o trabalho de um subsistema estiver incorreto, ser√° um erro fatal e o c√≥digo mais pr√≥ximo da pilha n√£o o capturar√° com certeza: </p><br><pre> <code class="plaintext hljs">T GetFromCacheOrCalculate() { try { if(_cache.TryGetValue(Key, out var result)) { return result; } else { T res = Strategy(Key); _cache[Key] = res; return res; } } cache (CacheCorruptedException exception) { RecreateCache(); return GetFromCacheOrCalculate(); } }</code> </pre> <br><p>  <code>CacheCorruptedException</code> √© uma exce√ß√£o, significando que "o cache do disco r√≠gido √© inconsistente".  Em seguida, se a causa de um erro desse tipo for fatal para o subsistema de cache (por exemplo, n√£o h√° direitos de acesso ao arquivo de cache), o c√≥digo a seguir n√£o poder√° recriar o cache usando a instru√ß√£o <code>RecreateCache</code> e, portanto, capturar essa exce√ß√£o ser√° um erro. </p><br><h3 id="based-on-the-area-where-an-exceptional-situation-is-actually-catched">  Com base na √°rea em que uma situa√ß√£o excepcional √© realmente capturada </h3><br><p>  Outra quest√£o √© se devemos pegar algumas exce√ß√µes ou pass√°-las para algu√©m que entende melhor a situa√ß√£o.  Em outras palavras, devemos estabelecer √°reas de responsabilidade.  Vamos examinar o seguinte c√≥digo: </p><br><pre> <code class="plaintext hljs">namespace JetFinance.Strategies { public class WildStrategy : StrategyBase { private Random random = new Random(); public void PlayRussianRoulette() { if(DateTime.Now.Second == (random.Next() % 60)) { throw new StrategyException(); } } } public class StrategyException : Exception { /* .. */ } } namespace JetFinance.Investments { public class WildInvestment { WildStrategy _strategy; public WildInvestment(WildStrategy strategy) { _strategy = strategy; } public void DoSomethingWild() { ?try? { _strategy.PlayRussianRoulette(); } catch(StrategyException exception) { } } } } using JetFinance.Strategies; using JetFinance.Investments; void Main() { var foo = new WildStrategy(); var boo = new WildInvestment(foo); ?try? { boo.DoSomethingWild(); } catch(StrategyException exception) { } }</code> </pre><br><p>  Qual das duas estrat√©gias √© mais apropriada?  A √°rea de responsabilidade √© muito importante.  Inicialmente, pode parecer que o trabalho e a consist√™ncia do <code>WildInvestment</code> dependam totalmente do <code>WildStrategy</code> .  Portanto, se o <code>WildInvestment</code> simplesmente ignorar essa exce√ß√£o, ela ir√° para o n√≠vel superior e n√£o devemos fazer nada.  No entanto, observe que, em termos de arquitetura, o m√©todo <code>Main</code> captura uma exce√ß√£o de um n√≠vel ao chamar o m√©todo de outro.  Como fica em termos de uso?  Bem, √© assim que parece: </p><br><ul><li>  a responsabilidade por essa exce√ß√£o foi entregue a n√≥s; </li><li>  o usu√°rio desta classe n√£o tem certeza de que essa exce√ß√£o foi passada anteriormente por um conjunto de m√©todos de prop√≥sito; </li><li>  come√ßamos a criar novas depend√™ncias das quais nos livramos chamando uma camada intermedi√°ria. </li></ul><br><p>  No entanto, h√° outra conclus√£o resultante desta: devemos usar <code>catch</code> no m√©todo <code>DoSomethingWild</code> .  E isso √© um pouco estranho para n√≥s: o <code>WildInvestment</code> quase n√£o depende de algo.  Quero dizer, se o <code>PlayRussianRoulette</code> n√£o funcionou, o mesmo acontecer√° com o <code>DoSomethingWild</code> : ele n√£o tem c√≥digos de retorno, mas precisa jogar a roleta.  Ent√£o, o que podemos fazer em uma situa√ß√£o aparentemente sem esperan√ßa?  A resposta √© realmente simples: estar em outro n√≠vel <code>DoSomethingWild</code> deve lan√ßar sua pr√≥pria exce√ß√£o que pertence a esse n√≠vel e agrup√°-lo no <code>InnerException</code> como a fonte original de um problema: </p><br><pre> <code class="plaintext hljs">namespace JetFinance.Strategies { pubilc class WildStrategy { private Random random = new Random(); public void PlayRussianRoulette() { if(DateTime.Now.Second == (random.Next() % 60)) { throw new StrategyException(); } } } public class StrategyException : Exception { /* .. */ } } namespace JetFinance.Investments { public class WildInvestment { WildStrategy _strategy; public WildInvestment(WildStrategy strategy) { _strategy = strategy; } public void DoSomethingWild() { try { _strategy.PlayRussianRoulette(); } catch(StrategyException exception) { throw new FailedInvestmentException("Oops", exception); } } } public class InvestmentException : Exception { /* .. */ } public class FailedInvestmentException : Exception { /* .. */ } } using JetFinance.Investments; void Main() { var foo = new WildStrategy(); var boo = new WildInvestment(foo); try { boo.DoSomethingWild(); } catch(FailedInvestmentException exception) { } }</code> </pre> <br><p>  Ao agrupar uma exce√ß√£o em outra, transferimos o problema de um n√≠vel de aplicativo para outro e tornamos seu trabalho mais previs√≠vel em termos de consumidor dessa classe: o m√©todo <code>Main</code> . </p><br><h3 id="based-on-reuse-issues">  Com base em problemas de reutiliza√ß√£o </h3><br><p>  Frequentemente, sentimos pregui√ßa de criar um novo tipo de exce√ß√£o, mas quando decidimos fazer isso, nem sempre √© claro em que tipo basear-se.  Mas s√£o precisamente essas decis√µes que definem toda a arquitetura de situa√ß√µes excepcionais.  Vamos dar uma olhada em algumas solu√ß√µes populares e tirar algumas conclus√µes. </p><br><p>  Ao escolher o tipo de exce√ß√£o, podemos usar uma solu√ß√£o criada anteriormente, ou seja, para encontrar uma exce√ß√£o com o nome que tenha sentido semelhante e us√°-la.  Por exemplo, se obtivemos uma entidade por meio de um par√¢metro e n√£o gostamos dessa entidade, podemos lan√ßar <code>InvalidArgumentException</code> , indicando a causa de um erro em Message.  Esse cen√°rio parece bom, especialmente porque <code>InvalidArgumentException</code> est√° no grupo de exce√ß√µes que podem n√£o ser capturadas.  No entanto, a escolha de <code>InvalidDataException</code> estar√° errada se voc√™ trabalhar com alguns tipos de dados.  √â porque esse tipo est√° na √°rea <code>System.IO</code> , o que provavelmente n√£o √© o que voc√™ lida.  Assim, quase sempre ser√° errado procurar um tipo existente em vez de desenvolver um por si mesmo.  Quase n√£o h√° exce√ß√µes para uma gama geral de tarefas.  Praticamente todos eles s√£o para situa√ß√µes espec√≠ficas e se voc√™ os reutilizar em outros casos, isso violar√° gravemente a arquitetura de situa√ß√µes excepcionais.  Al√©m disso, uma exce√ß√£o de um tipo espec√≠fico (por exemplo, <code>System.IO.InvalidDataException</code> ) pode confundir um usu√°rio: por um lado, ele ver√° que a exce√ß√£o pertence ao espa√ßo para nome <code>System.IO</code> , enquanto, por outro lado, √© lan√ßada de um espa√ßo para nome completamente diferente.  Se esse usu√°rio come√ßar a pensar nas regras de lan√ßamento dessa exce√ß√£o, ele poder√° ir para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sourcesource.microsoft.com</a> e encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">todos os locais onde √© lan√ßada</a> : </p><br><ul><li> <code>internal class System.IO.Compression.Inflater</code> </li> </ul><br><p>  O usu√°rio entender√° que <del>  algu√©m √© todo polegar </del>  esse tipo de exce√ß√£o o confundiu, pois o m√©todo que lan√ßou essa exce√ß√£o n√£o lidava com a compacta√ß√£o. </p><br><p>  Al√©m disso, em termos de reutiliza√ß√£o, voc√™ pode simplesmente criar uma exce√ß√£o e declarar o campo <code>ErrorCode</code> nela.  Parece uma boa ideia.  Voc√™ apenas lan√ßa a mesma exce√ß√£o, definindo o c√≥digo e usa apenas uma <code>catch</code> para lidar com exce√ß√µes, aumentando a estabilidade de um aplicativo e nada mais.  No entanto, acredito que voc√™ deve repensar essa posi√ß√£o.  Obviamente, essa abordagem facilita a vida, por um lado.  No entanto, por outro lado, voc√™ descarta a possibilidade de capturar um subgrupo de exce√ß√µes que possuem algum recurso em comum.  Por exemplo, <code>ArgumentException</code> que une v√°rias exce√ß√µes por heran√ßa.  Outra s√©ria desvantagem √© um c√≥digo excessivamente grande e ileg√≠vel que deve organizar a filtragem baseada em c√≥digo de erro.  No entanto, a introdu√ß√£o de um tipo abrangente com um c√≥digo de erro ser√° mais apropriada quando um usu√°rio n√£o precisar se preocupar em especificar um erro. </p><br><pre> <code class="plaintext hljs">public class ParserException { public ParserError ErrorCode { get; } public ParserException(ParserError errorCode) { ErrorCode = errorCode; } public override string Message { get { return Resources.GetResource($"{nameof(ParserException)}{Enum.GetName(typeof(ParserError), ErrorCode)}"); } } } public enum ParserError { MissingModifier, MissingBracket, // ... } // Usage throw new ParserException(ParserError.MissingModifier);</code> </pre> <br><p>  O c√≥digo que protege a chamada do analisador n√£o se importa por que a an√°lise falhou: est√° interessado no erro como tal.  No entanto, se a causa da falha se tornar importante, o usu√°rio sempre poder√° obter o c√≥digo de erro da propriedade <code>ErrorCode</code> .  E voc√™ realmente n√£o precisa procurar as palavras necess√°rias em uma subcadeia de <code>Message</code> . </p><br><p>  Se n√£o optarmos por reutilizar, podemos criar um tipo de exce√ß√£o para todas as situa√ß√µes.  Por um lado, parece l√≥gico: um tipo de erro - um tipo de exce√ß√£o.  No entanto, n√£o exagere: ter muitos tipos de exce√ß√µes causar√° o problema de captur√°-las, pois o c√≥digo de um m√©todo de chamada ser√° sobrecarregado com blocos de <code>catch</code> .  Porque ele precisa processar todos os tipos de exce√ß√µes que voc√™ deseja passar para ele.  Outra desvantagem √© puramente arquitet√¥nica.  Se voc√™ n√£o usa exce√ß√µes, confunde quem as usar√°: elas podem ter muitas coisas em comum, mas ser√£o capturadas separadamente. </p><br><p>  No entanto, existem √≥timos cen√°rios para introduzir tipos separados para situa√ß√µes espec√≠ficas.  Por exemplo, quando o erro afeta n√£o uma entidade inteira, mas um m√©todo espec√≠fico.  Ent√£o esse tipo de erro deve ocupar um lugar na hierarquia da heran√ßa que ningu√©m jamais pensaria em juntar-se a outra coisa: por exemplo, atrav√©s de um ramo separado da heran√ßa. </p><br><p>  Al√©m disso, se voc√™ combinar essas duas abordagens, poder√° obter um poderoso conjunto de instrumentos para trabalhar com um grupo de erros: voc√™ pode introduzir um tipo abstrato comum e herdar casos espec√≠ficos dele.  A classe base (nosso tipo comum) deve obter uma propriedade abstrata, projetada para armazenar um c√≥digo de erro, enquanto os herdeiros especificar√£o esse c√≥digo substituindo essa propriedade. </p><br><pre> <code class="plaintext hljs">public abstract class ParserException { public abstract ParserError ErrorCode { get; } public override string Message { get { return Resources.GetResource($"{nameof(ParserException)}{Enum.GetName(typeof(ParserError), ErrorCode)}"); } } } public enum ParserError { MissingModifier, MissingBracket } public class MissingModifierParserException : ParserException { public override ParserError ErrorCode { get; } =&gt; ParserError.MissingModifier; } public class MissingBracketParserException : ParserException { public override ParserError ErrorCode { get; } =&gt; ParserError.MissingBracket; } // Usage throw new MissingModifierParserException(ParserError.MissingModifier);</code> </pre> <br><p>  Usando esta abordagem, obtemos algumas propriedades maravilhosas: </p><br><ul><li>  por um lado, continuamos capturando exce√ß√µes usando um tipo base (comum); </li><li>  por outro lado, mesmo capturando exce√ß√µes com esse tipo de base, ainda somos capazes de identificar uma situa√ß√£o espec√≠fica; </li><li>  al√©m disso, podemos capturar exce√ß√µes por meio de um tipo espec√≠fico, em vez de um tipo base, sem usar a estrutura plana das classes. </li></ul><br><p>  Eu acho que √© muito conveniente. </p><br><h3 id="based-on-belonging-to-a-specific-group-of-behavioral-situations">  Baseado em pertencer a um grupo espec√≠fico de situa√ß√µes comportamentais </h3><br><p>  Que conclus√µes podemos tirar com base no racioc√≠nio anterior?  Vamos tentar defini-los. </p><br><p>  Primeiro de tudo, vamos decidir o que significa uma situa√ß√£o?  Geralmente, falamos sobre classes e objetos em termos de entidades com algum estado interno e podemos executar a√ß√µes nessas entidades.  Assim, o primeiro tipo de situa√ß√£o comportamental inclui a√ß√µes em alguma entidade.  A seguir, se observarmos um gr√°fico de objeto de fora, veremos que ele √© logicamente representado como uma combina√ß√£o de grupos funcionais: o primeiro grupo lida com cache, o segundo trabalha com bancos de dados e o terceiro realiza c√°lculos matem√°ticos.  Camadas diferentes podem passar por todos esses grupos, por exemplo, camadas de registro de estados internos, registro de processos e rastreamento de chamadas de m√©todo.  Camadas podem abranger v√°rios grupos funcionais.  Por exemplo, pode haver uma camada de um modelo, uma camada de controladores e uma camada de apresenta√ß√£o.  Esses grupos podem estar em uma montagem ou em grupos diferentes, mas cada grupo pode criar suas pr√≥prias situa√ß√µes excepcionais. </p><br><p>  Portanto, podemos construir uma hierarquia para os tipos de situa√ß√µes excepcionais com base na perten√ßa a esses tipos em um ou outro grupo ou camada.  Assim, permitimos que um c√≥digo de captura navegue facilmente entre esses tipos na hierarquia. </p><br><p>  Vamos examinar o seguinte c√≥digo: </p><br><pre> <code class="plaintext hljs">namespace JetFinance { namespace FinancialPipe { namespace Services { namespace XmlParserService { } namespace JsonCompilerService { } namespace TransactionalPostman { } } } namespace Accounting { /* ... */ } }</code> </pre><br><p>  Como √© isso?  Eu acho que o espa√ßo para nome √© uma maneira perfeita de agrupar naturalmente os tipos de exce√ß√µes com base nas situa√ß√µes comportamentais: tudo o que pertence a grupos espec√≠ficos deve permanecer l√°, incluindo exce√ß√µes.  Al√©m disso, quando voc√™ obt√©m uma exce√ß√£o espec√≠fica, ver√° o nome do seu tipo e tamb√©m o espa√ßo para nome que especificar√° um grupo ao qual ele pertence.  Voc√™ se lembra da reutiliza√ß√£o incorreta de <code>InvalidDataException</code> que √© realmente definida no espa√ßo para nome <code>System.IO</code> ?  O fato de pertencer a esse espa√ßo para nome significa que esse tipo de exce√ß√£o pode ser lan√ßado a partir de classes que est√£o no espa√ßo para nome <code>System.IO</code> ou em uma mais aninhada.  Mas a exce√ß√£o real foi lan√ßada de um espa√ßo completamente diferente, confundindo uma pessoa que lida com o problema.  No entanto, se voc√™ colocar os tipos de exce√ß√µes e os tipos que as lan√ßam nos mesmos namespaces, manter√° a arquitetura dos tipos consistente e facilitar√° aos desenvolvedores o entendimento dos motivos do que acontece. </p><br><p>  Qual √© a segunda maneira de agrupar no n√≠vel do c√≥digo?  Heran√ßa: </p><br><pre> <code class="plaintext hljs">public abstract class LoggerExceptionBase : Exception { protected LoggerException(..); } public class IOLoggerException : LoggerExceptionBase { internal IOLoggerException(..); } public class ConfigLoggerException : LoggerExceptionBase { internal ConfigLoggerException(..); }</code> </pre><br><p>  Observe que, para entidades de aplicativos comuns, elas herdam comportamentos e tipos de dados e grupos que pertencem a um <em>√∫nico grupo de entidades</em> .  No entanto, para exce√ß√µes, eles herdam e s√£o agrupados com base em um <em>√∫nico grupo de situa√ß√µes</em> , porque a ess√™ncia de uma exce√ß√£o n√£o √© uma entidade, mas um problema. </p><br><p>  Combinando esses dois m√©todos de agrupamento, podemos tirar as seguintes conclus√µes: </p><br><ul><li>  deve haver um tipo b√°sico de exce√ß√µes dentro do <code>Assembly</code> que ser√° lan√ßado por esse assembly.  Esse tipo de exce√ß√£o deve estar em um espa√ßo para nome raiz do assembly.  Essa ser√° a primeira camada de agrupamento. </li><li>  Al√©m disso, pode haver um ou v√°rios namespaces dentro de um assembly.  Cada um deles divide a montagem em zonas funcionais, definindo os grupos de situa√ß√µes que aparecem nessa montagem.  Podem ser zonas de controladores, entidades de banco de dados, algoritmos de processamento de dados etc.  Para n√≥s, esses namespaces significam tipos de agrupamento com base em suas fun√ß√µes.  No entanto, em termos de exce√ß√µes, eles s√£o agrupados com base em problemas dentro do mesmo assembly; </li><li>  as exce√ß√µes devem ser herdadas dos tipos no mesmo espa√ßo para nome de n√≠vel superior.  Isso garante que o usu√°rio final compreenda de forma inequ√≠voca as situa√ß√µes e n√£o capture exce√ß√µes baseadas em tipos <em>errados</em> .  Admita, seria estranho capturar <code>global::Finiki.Logistics.OhMyException</code> por <code>catch(global::Legacy.LoggerExeption exception)</code> , enquanto o c√≥digo a seguir parece absolutamente apropriado: </li></ul><br><pre> <code class="plaintext hljs">namespace JetFinance.FinancialPipe { namespace Services.XmlParserService { public class XmlParserServiceException : FinancialPipeExceptionBase { // .. } public class Parser { public void Parse(string input) { // .. } } } public abstract class FinancialPipeExceptionBase : Exception { } } using JetFinance.FinancialPipe; using JetFinance.FinancialPipe.Services.XmlParserService; var parser = new Parser(); try { parser.Parse(); } catch (XmlParserServiceException exception) { // Something is wrong in the parser } catch (FinancialPipeExceptionBase exception) { // Something else is wrong. Looks critical because we don't know the real reason }</code> </pre><br><p>  Aqui, o c√≥digo do usu√°rio chama um m√©todo de biblioteca que, como sabemos, pode <code>XmlParserServiceException</code> em alguma situa√ß√£o.  E, como sabemos, essa exce√ß√£o refere-se ao espa√ßo de nomes herdado <code>JetFinance.FinancialPipe.FinancialPipeExceptionBase</code> , o que significa que pode haver outras exce√ß√µes - desta vez o microsservi√ßo <code>XmlParserService</code> cria apenas uma exce√ß√£o, mas outras exce√ß√µes podem aparecer no futuro.  Como temos uma conven√ß√£o para criar tipos de exce√ß√µes, sabemos de que entidade essa nova exce√ß√£o ser√° herdada e colocamos uma <code>catch</code> abrangente com anteced√™ncia.  Isso nos permite pular todas as coisas irrelevantes para n√≥s. </p><br><p>  Como construir uma hierarquia de tipos? </p><br><ul><li>  Primeiro de tudo, devemos criar uma classe base para um dom√≠nio.  Vamos cham√°-lo de uma classe base de dom√≠nio.  Nesse caso, um dom√≠nio √© uma palavra que abrange v√°rios conjuntos, combinando-os com base em algum recurso: log, l√≥gica de neg√≥cios, interface do usu√°rio.  Quero dizer zonas funcionais de um aplicativo que s√£o t√£o grandes quanto poss√≠vel. </li><li>  Em seguida, devemos introduzir uma classe base adicional para exce√ß√µes que devem ser capturadas: todas as exce√ß√µes que ser√£o capturadas usando a palavra-chave <code>catch</code> ser√£o herdadas dessa classe base; </li><li>  Todas as exce√ß√µes que indicam erros fatais devem ser herdadas diretamente de uma classe base do dom√≠nio.  Assim, n√≥s os separaremos daqueles capturados no n√≠vel da arquitetura; <br>  - Divida o dom√≠nio em √°reas funcionais com base em namespaces e declare o tipo b√°sico de exce√ß√µes que ser√£o lan√ßadas em cada √°rea.  Aqui √© necess√°rio usar o bom senso: se um aplicativo tiver um alto grau de aninhamento de namespace, voc√™ n√£o deve fazer um tipo de base para cada n√≠vel de aninhamento.  No entanto, se houver ramifica√ß√£o em um n√≠vel de aninhamento quando um grupo de exce√ß√µes for para um espa√ßo para nome e outro grupo for para outro espa√ßo para nome, ser√° necess√°rio usar dois tipos de base para cada subgrupo; </li><li>  Exce√ß√µes especiais devem ser herdadas dos tipos de exce√ß√µes pertencentes a √°reas funcionais </li><li>  Se um grupo de exce√ß√µes especiais puder ser combinado, √© necess√°rio faz√™-lo em mais um tipo de base: assim, voc√™ poder√° identific√°-las com mais facilidade; </li><li>  Se voc√™ sup√µe que o grupo ser√° capturado com mais frequ√™ncia usando uma classe base, introduza o Modo misto com o ErrorCode. </li></ul><br><h3 id="based-on-the-source-of-an-error">  Com base na fonte de um erro </h3><br><p>  A fonte de um erro pode ser outra base para combinar exce√ß√µes em um grupo.  Por exemplo, se voc√™ criar uma biblioteca de classes, o seguinte poder√° formar grupos de fontes: </p><br><ul><li>  chamada de c√≥digo insegura com erro.  Essa situa√ß√£o pode ser resolvida agrupando uma exce√ß√£o ou um c√≥digo de erro em seu pr√≥prio tipo de exce√ß√£o e salvando os dados retornados (por exemplo, o c√≥digo de erro original) em uma propriedade p√∫blica da exce√ß√£o; </li><li>  uma chamada de c√≥digo por depend√™ncias externas, que lan√ßou exce√ß√µes que n√£o podem ser capturadas por nossa biblioteca, pois est√£o al√©m de sua √°rea de responsabilidade.  Esse grupo pode incluir exce√ß√µes dos m√©todos daquelas entidades que foram aceitas como par√¢metros de um m√©todo atual ou exce√ß√µes do construtor de uma classe cujo m√©todo chamou de depend√™ncia externa.  Por exemplo, um m√©todo de nossa classe chamou um m√©todo de outra classe, cuja inst√¢ncia foi retornada por meio de par√¢metros de outro m√©todo.  Se uma exce√ß√£o indicar que somos a fonte de um problema, devemos gerar nossa pr√≥pria exce√ß√£o, mantendo a original no <code>InnerExcepton</code> .  No entanto, se entendermos que o problema foi causado por uma depend√™ncia externa, ignoraremos essa exce√ß√£o como pertencendo a um grupo de depend√™ncias externas al√©m do nosso controle; </li><li>  nosso pr√≥prio c√≥digo que foi acidentalmente colocado em um estado inconsistente.  Um bom exemplo √© a an√°lise de texto - sem depend√™ncias externas, sem transfer√™ncia para um mundo <code>unsafe</code> , mas ocorre um problema de an√°lise. </li></ul><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Este cap√≠tulo foi traduzido do russo em conjunto pelo autor e por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tradutores profissionais</a> .  Voc√™ pode nos ajudar com a tradu√ß√£o do russo ou do ingl√™s para qualquer outro idioma, principalmente para chin√™s ou alem√£o. <br><br>  Al√©m disso, se voc√™ quiser nos agradecer, a melhor maneira de fazer isso √© nos dar uma estrela no github ou no fork do reposit√≥rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt454882/">https://habr.com/ru/post/pt454882/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt454872/index.html">Invasores do espa√ßo: agora em 512 bytes (Assembler x86)</a></li>
<li><a href="../pt454874/index.html">Um pouco sobre multitarefa em microcontroladores</a></li>
<li><a href="../pt454876/index.html">Sobre como projetar um sistema flex√≠vel de habilidades de personagem em jogos</a></li>
<li><a href="../pt454878/index.html">Estudamos MITRE ATT & CK. Matrizes m√≥veis: acesso ao dispositivo. Parte 3</a></li>
<li><a href="../pt454880/index.html">"Fora da esta√ß√£o" na vida de um freelancer: como sobreviver e sobreviver?</a></li>
<li><a href="../pt454886/index.html">Sentado no f√≠gado. Por que a remo√ß√£o de tumores hep√°ticos √© um indicador da habilidade superior do cirurgi√£o</a></li>
<li><a href="../pt454892/index.html">Moto. Mock aws</a></li>
<li><a href="../pt454894/index.html">WWDC 2019 :: o que ver</a></li>
<li><a href="../pt454896/index.html">Por que mudei freelancer para uma equipe remota</a></li>
<li><a href="../pt454898/index.html">Programar √© mais do que codificar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>