<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕘 👲🏼 🏮 Silence of Ruby Executions: Transactional Rails / PostgreSQL Thriller 🔇 🚸 🖐🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C'est une histoire sur la raison pour laquelle vous ne devez jamais ignorer les erreurs lorsque vous êtes dans une transaction dans une base de donnée...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Silence of Ruby Executions: Transactional Rails / PostgreSQL Thriller</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418147/"><p>  <em>C'est une histoire sur la raison pour laquelle vous <strong>ne</strong> devez <strong>jamais</strong> ignorer les erreurs lorsque vous êtes dans une transaction dans une base de données.</em>  <em>Découvrir comment utiliser correctement les transactions et quoi faire lors de leur utilisation n'est pas une option.</em>  <em>Spoiler: il s'agira de verrous consultatifs dans PostgreSQL!</em> </p><br><p> J'ai travaillé sur un projet dans lequel les utilisateurs peuvent importer un grand nombre d'entités lourdes (appelons-les produits) d'un service externe dans notre application.  Pour chaque produit, des données encore plus diverses qui lui sont associées sont chargées à partir d'API externes.  Il n'est pas rare qu'un utilisateur charge des centaines de produits avec toutes les dépendances, par conséquent, l'importation d'un produit prend un temps tangible (30 à 60 secondes), et l'ensemble du processus peut prendre beaucoup de temps.  L'utilisateur peut être fatigué d'attendre le résultat et il a le droit de cliquer sur le bouton "Annuler" à tout moment et l'application devrait être utile avec le nombre de produits qui ont pu être téléchargés à ce moment. </p><a name="habracut"></a><br><p>  L '«importation interrompue» est implémentée comme suit: au début, pour chaque produit, un enregistrement de tâche temporaire est créé dans la plaque signalétique de la base de données.  Pour chaque produit, une tâche d'importation en arrière-plan est lancée, qui télécharge le produit, l'enregistre dans la base de données avec toutes les dépendances (fait tout en général) et à la toute fin supprime son enregistrement de tâche.  Si au moment où la tâche d'arrière-plan démarre, il n'y aura aucun enregistrement dans la base de données - la tâche se termine simplement en silence.  Ainsi, pour annuler l'importation, il suffit de supprimer simplement toutes les tâches et c'est tout. </p><br><p>  Peu importe si l'importation a été annulée par l'utilisateur ou complètement terminée par lui-même - en tout cas, l'absence de tâches signifie que tout est terminé et que l'utilisateur peut commencer à utiliser l'application. </p><br><p>  Le design est simple et fiable, mais il y avait un petit bug.  Un rapport de bogue typique à son sujet était: «Une fois l'importation annulée, l'utilisateur affiche une liste de ses produits.  Cependant, si vous actualisez la page, la liste des produits est complétée par plusieurs entrées. "  La raison de ce comportement est simple: lorsque l'utilisateur clique sur le bouton «Annuler», il est immédiatement transféré dans la liste de tous les produits.  Mais à l'heure actuelle, les importations déjà commencées de certains biens «continuent» de fonctionner. </p><br><p>  Bien sûr, c'est une bagatelle, mais les utilisateurs ont été intrigués par la commande, donc ce serait bien de le réparer.  J'avais deux façons: identifier et «tuer» les tâches en cours d'exécution ou, lorsque j'appuie sur le bouton Annuler, attendre qu'elles soient terminées et «mourir de leur propre chef» avant de transférer l'utilisateur.  J'ai choisi la deuxième façon - d'attendre. </p><br><h2 id="tranzakcionnye-blokirovki-speshat-na-pomosch">  Les verrous transactionnels se précipitent à la rescousse </h2><br><p>  Pour tous ceux qui travaillent avec des bases de données (relationnelles), la réponse est évidente: utilisez les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">transactions</a> ! </p><br><p> Il est important de se rappeler que dans la plupart des SGBDR, les enregistrements mis à jour dans une transaction seront <em>bloqués</em> et inaccessibles aux modifications par d'autres processus jusqu'à ce que cette transaction soit terminée.  Les enregistrements sélectionnés à l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>SELECT FOR UPDATE</code></a> seront également verrouillés. </p><br><p>  Exactement notre cas!  J'ai bouclé la tâche d'importer des marchandises individuelles dans une transaction et j'ai bloqué l'enregistrement de tâche au tout début: </p><br><pre> <code class="ruby hljs">ActiveRecord::Base.transaction <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> task = Import::Task.lock.find_by(<span class="hljs-symbol"><span class="hljs-symbol">id:</span></span> id) <span class="hljs-comment"><span class="hljs-comment"># SELECT … FOR UPDATE  «    » return unless task #  - ? ,    ! #     task.destroy end</span></span></code> </pre> <br><p>  Désormais, lorsque l'utilisateur souhaite annuler l'importation, l'opération d'arrêt d'importation supprimera les tâches pour les importations qui n'ont pas encore commencé et sera obligé d'attendre la fin de celles déjà existantes: </p><br><pre> <code class="ruby hljs">user.import_tasks.delete_all <span class="hljs-comment"><span class="hljs-comment">#       </span></span></code> </pre> <br><p>  Simple et élégant!  J'ai exécuté les tests, vérifié l'importation localement et au niveau de la mise en scène et déployé "au combat". </p><br><h2 id="ne-tak-bystro">  Pas si vite ... </h2><br><p>  Satisfait de mon travail, j'ai été très surpris de trouver bientôt des rapports de bugs et des tonnes d'erreurs dans les logs.  De nombreux produits n'étaient pas du tout importés.  Dans certains cas, un seul produit pourrait rester après l'achèvement de toutes les importations. </p><br><p>  Les erreurs dans les journaux n'étaient pas encourageantes non plus: <code>PG::InFailedSqlTransaction</code> avec une backtrack menant au code qui exécutait les <code>SELECT</code> innocents.  Que se passe-t-il du tout? </p><br><p>  Après une journée de débogage épuisante, j'ai identifié trois causes principales des problèmes: </p><br><ol><li>  Insertion compétitive d'enregistrements conflictuels dans la base de données. </li><li>  Annulation automatique des transactions dans PostgreSQL après des erreurs. </li><li>  Silence des problèmes (exceptions Ruby) dans le code d'application. </li></ol><br><p>  <strong>Problème 1: insertion compétitive d'entrées conflictuelles</strong> </p><br><p>  Étant donné que chaque opération d'importation prend jusqu'à une minute et qu'il existe un grand nombre de ces tâches, nous les effectuons en parallèle pour gagner du temps.  Les enregistrements de marchandises dépendants peuvent se recouper, dans la mesure où tous les produits de l'utilisateur peuvent se référer à un seul enregistrement, créé une fois puis réutilisé. </p><br><p>  Il existe des vérifications pour trouver et réutiliser les mêmes dépendances dans le code d'application, mais <em>maintenant, lorsque nous utilisons des transactions, ces vérifications sont devenues inutiles</em> : si la transaction A a créé un enregistrement dépendant mais n'est pas encore terminée, la transaction B ne pourra pas découvrir son existence et essaiera de créer un doublon record. </p><br><p>  <strong>Problème 2: Annulation automatique des transactions PostgreSQL après des erreurs</strong> </p><br><p>  Bien sûr, nous avons empêché la création de tâches en double au niveau de la base de données à l'aide du DDL suivant: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> product_deps <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span> (user_id, characteristics);</code> </pre> <br><p>  Si une transaction en cours A a inséré un nouvel enregistrement et que la transaction B essaie d'insérer un enregistrement avec les mêmes valeurs des champs <code>user_id</code> et <code>characteristics</code> , la transaction B recevra une erreur: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> product_deps (user_id, characteristics) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'{"same": "value"}'</span></span>); <span class="hljs-comment"><span class="hljs-comment">-- Now it will block until first transaction will be finished ERROR: duplicate key value violates unique constraint "product_deps_user_id_characteristics_key" DETAIL: Key (user_id, characteristics)=(1, {"same": "value"}) already exists. -- And will throw an error when first transaction have commited and it is become clear that we have a conflict</span></span></code> </pre> <br><p>  Mais il y a une caractéristique qui ne doit pas être oubliée - la transaction B, après avoir détecté une erreur, sera automatiquement annulée et tout le travail qui y sera effectué ira à l'égout.  Cependant, cette transaction <strong>est toujours ouverte</strong> dans un état «erroné», mais avec toute tentative d'exécution d'une demande, même la plus inoffensive, seules les erreurs seront renvoyées en réponse: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> products; ERROR: current transaction is aborted, commands ignored until <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">transaction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">block</span></span></code> </pre> <br><p>  Eh bien, il est complètement inutile de dire que tout ce qui a été entré dans la base de données dans cette transaction ne sera pas enregistré: </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; <span class="hljs-comment"><span class="hljs-comment">--      ,   ROLLBACK --          </span></span></code> </pre> <br><p>  <strong>Troisième problème: le silence</strong> </p><br><p>  À ce stade, il était déjà clair que le simple fait d'ajouter des transactions à l'application l'a brisée.  Il n'y avait pas d'autre choix: je devais plonger dans le code d'importation.  Dans le code, les motifs suivants ont souvent attiré mon attention: </p><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_stuff</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment"># ,   rescue StandardError nil #  ,  end</span></span></code> </pre> <br><p>  L'auteur du code ici nous dit: "Nous avons essayé, nous n'avons pas réussi, mais ça va, nous continuons sans."  Et bien que les raisons de ce choix puissent être tout à fait explicables (tout ne peut pas être traité au niveau de l'application), c'est ce qui rend impossible toute logique basée sur des transactions: une exécution rejetée ne pourra pas flotter jusqu'au bloc de <code>transaction</code> , et ne provoquera pas une restauration correcte transactions (ActiveRecord intercepte toutes les erreurs dans ce bloc, annule la transaction et les relance). </p><br><h2 id="idealnyy-shtorm">  Tempête parfaite </h2><br><p>  Et voici comment ces trois facteurs se sont réunis pour créer le parfait <del>  la tempête </del>  bug: </p><br><ul><li>  Une application dans une transaction essaie d'insérer un enregistrement en conflit dans la base de données et provoque une erreur de "clé en double" de PostgreSQL.  Toutefois, cette erreur n'entraîne pas l'annulation de la transaction dans l'application, car elle est "étouffée" dans l'une des parties de l'application. </li><li>  La transaction devient invalide, mais l'application n'en a pas connaissance et continue de fonctionner.  Dans toute tentative d'accès à la base de données, l'application reçoit à nouveau une erreur, cette fois "la transaction en cours est abandonnée", mais cette erreur peut également être supprimée ... </li><li>  Vous avez probablement déjà compris que quelque chose dans l'application continue de se casser, mais personne ne le saura jusqu'à ce que l'exécution atteigne le premier endroit, où il n'y a pas de <code>rescue</code> trop gourmand et où l'erreur peut finalement apparaître, être enregistrée, enregistré dans le tracker d'erreur - quoi que ce soit.  Mais cet endroit sera déjà très loin de l'endroit qui est devenu la cause première de l'erreur, et cela seul transformera le débogage en cauchemar. </li></ul><br><h2 id="alternativa-tranzakcionnym-blokirovkam-v-postgresql">  Alternative aux verrous transactionnels dans PostgreSQL </h2><br><p>  La recherche de <code>rescue</code> dans le code d'application et la réécriture de toute la logique d'importation ne sont pas une option.  Un long moment.  J'avais besoin d'une solution rapide et je l'ai trouvée chez les postgres!  Il a une solution intégrée pour les verrous, une alternative au verrouillage des enregistrements dans les transactions, des verrous de conseil de session.  Je les ai utilisés comme suit: </p><br><p>  Tout d'abord, j'ai d'abord supprimé la transaction d'emballage.  Dans tous les cas, interagir avec des API externes (ou tout autre «effet secondaire») du code d'application avec une transaction ouverte est une mauvaise idée, car même si vous annulez la transaction avec toutes les modifications de notre base de données, les modifications des systèmes externes resteront et l'application dans son ensemble peut se trouver dans un état étrange et indésirable.  Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">joyau de l'isolateur</a> peut vous aider à vous assurer que les effets secondaires sont correctement <em>isolés</em> des transactions. </p><br><p>  Ensuite, dans chaque opération d'importation, je prends un verrou <em>partagé</em> sur une clé unique pour l'importation entière (par exemple, créée à partir de l'ID utilisateur et du hachage à partir du nom de la classe d'opération): </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_advisory_lock_shared(<span class="hljs-number"><span class="hljs-number">42</span></span>, user.id);</code> </pre> <br><p>  Des verrous partagés sur la même clé peuvent être pris simultanément par n'importe quel nombre de sessions. </p><br><p>  L'annulation de l'opération d'importation supprime simultanément toutes les entrées de tâche de la base de données et essaie de prendre <em>un</em> verrou <em>exclusif</em> sur la même clé.  Dans ce cas, elle devra attendre que tous les verrous partagés soient libérés: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_advisory_lock(<span class="hljs-number"><span class="hljs-number">42</span></span>, user.id)</code> </pre> <br><p>  Et c'est tout!  Maintenant, l '«annulation» attendra que toutes les importations «en cours» de biens individuels soient terminées. </p><br><p>  De plus, maintenant que nous ne sommes pas connectés par une transaction, nous pouvons utiliser un petit hack pour limiter le temps d'attente pour l'annulation de l'importation (dans le cas où certains «sticks» d'importation), car il n'est pas bon de bloquer le flux du serveur Web pendant une longue période (et forcer attendre l'utilisateur): </p><br><pre> <code class="ruby hljs">transaction <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> execute(<span class="hljs-string"><span class="hljs-string">"SET LOCAL lock_timeout = '30s'"</span></span>) execute(<span class="hljs-string"><span class="hljs-string">"SELECT pg_advisory_lock(42, user.id)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">rescue</span></span> ActiveRecord::LockWaitTimeout <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-comment"><span class="hljs-comment">#    (     ) end</span></span></code> </pre> <br><p>  Il est sûr d'attraper une erreur en <em>dehors</em> du bloc de <code>transaction</code> , car <a href="">ActiveRecord annulera déjà la transaction</a> . </p><br><h2 id="no-chto-delat-s-konkurentnoy-vstavkoy-odinakovyh-zapisey">  Mais que faire de l'insertion compétitive d'enregistrements identiques? </h2><br><p>  Malheureusement, je ne connais pas de solution qui fonctionnerait bien avec <em>des</em> inserts <em>compétitifs</em> .  Il existe les approches suivantes, mais elles bloqueront toutes les insertions simultanées jusqu'à la fin de la première des transactions: </p><br><ul><li>  <code>INSERT … ON CONFLICT UPDATE</code> (disponible depuis PostgreSQL 9.5) dans la deuxième transaction sera verrouillé jusqu'à ce que la première transaction soit terminée, puis il renverra l'enregistrement qui a été inséré par la première transaction. </li><li>  Verrouillez un enregistrement général dans une transaction avant d'exécuter des validations pour insérer un nouvel enregistrement.  Ici, nous attendrons que l'enregistrement inséré dans une autre transaction soit visible et que les validations ne puissent pas fonctionner correctement. </li><li>  Prenez une sorte de verrouillage de recommandation générale - l'effet est le même que pour le blocage d'un enregistrement général. </li></ul><br><p>  Eh bien, si vous n'avez pas peur de travailler avec des erreurs de niveau de base, vous pouvez simplement attraper l'erreur d'unicité: </p><br><pre> <code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">import_all_the_things</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">#   ,   Dep.create(user_id, chars) rescue ActiveRecord::RecordNotUnique retry end</span></span></span></span></code> </pre> <br><p>  Assurez-vous simplement que ce code n'est plus inclus dans une transaction. </p><br><blockquote>  Pourquoi sont-ils bloqués? <br><br>  Les contraintes UNIQUE et EXCLUDE bloquent <em>les conflits potentiels en</em> empêchant leur enregistrement en même temps.  Par exemple, si vous avez une contrainte unique sur une colonne entière et qu'une transaction insère une ligne avec une valeur de 5, les autres transactions qui tentent également d'insérer 5 seront bloquées, mais les transactions qui tentent d'insérer 6 ou 4 réussiront immédiatement, sans blocage.  Étant donné que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le niveau minimum d'isolation des transactions de PostgreSQL</a> est <code>READ COMMITED</code> , une transaction n'est pas autorisée à voir les modifications non validées des autres transactions.  Par conséquent, un <code>INSERT</code> avec une valeur en conflit ne peut pas être accepté ou rejeté jusqu'à ce que la première transaction valide ses modifications (puis le second reçoit une erreur d'unicité) ou annule (puis l'insertion dans la deuxième transaction réussira).  En savoir plus à ce sujet dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article de l'auteur des restrictions EXCLUDE</a> . </blockquote><br><h2 id="predotvraschaem-katastrofu-v-buduschem">  Prévenir une catastrophe future </h2><br><p>  Vous savez <em>maintenant</em> que tout le code ne peut pas être encapsulé dans une transaction.  Ce serait bien de s'assurer que personne d'autre n'emballe un tel code dans une transaction à l'avenir, répétant mon erreur. </p><br><p>  Pour ce faire, vous pouvez encapsuler toutes vos opérations dans un petit module auxiliaire qui vérifiera si la transaction est ouverte avant d'exécuter le code d'opération encapsulé (ici, il est supposé que toutes vos opérations ont la même interface - la méthode d' <code>call</code> ). </p><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#     module NoTransactionAllowed class InTransactionError &lt; RuntimeError; end def call(*) return super unless in_transaction? raise InTransactionError, "#{self.class.name} doesn't work reliably within a DB transaction" end def in_transaction? connection = ApplicationRecord.connection # service transactions (tests and database_cleaner) are not joinable connection.transaction_open? &amp;&amp; connection.current_transaction.joinable? end end #    class Deps::Import &lt; BaseService prepend NoTransactionAllowed def call do_import rescue ActiveRecord::RecordNotUnique retry end end</span></span></code> </pre> <br><p>  Maintenant, si quelqu'un essaie de boucler un service <em>dangereux</em> dans une transaction, il recevra immédiatement une erreur (à moins, bien sûr, de le garder silencieux). </p><br><h2 id="itogi">  Résumé </h2><br><p>  La principale leçon à tirer: faites attention aux exceptions.  Ne gérez pas tout de suite, ne récupérez que les exceptions que vous savez comment gérer et laissez le reste accéder aux journaux.  N'ignorez jamais les exceptions (uniquement si vous n'êtes pas sûr à 100% pourquoi vous faites cela).  Plus tôt une erreur est constatée, plus il sera facile de déboguer. </p><br><p>  Et n'en faites pas trop avec les transactions dans la base de données.  Ce n'est pas une panacée.  Utilisez notre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">isolateur de</a> gemmes et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">after_commit_everywhere</a> - ils aideront vos transactions à devenir complètement infaillibles. </p><br><h2 id="chto-pochitat">  Que lire </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Ruby exceptionnel</em></a> <em>par Avdi Grimm</em> .  Ce petit livre vous apprendra comment gérer les exceptions existantes dans Ruby et comment concevoir correctement un système d'exceptions pour votre application. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://brandur.org/"><em>Utilisation de transactions atomiques pour</em></a> alimenter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://brandur.org/"><em>une API idempotente</em></a> par @Brandur.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Son blog contient de</a> nombreux articles utiles sur la fiabilité des applications, Ruby et PostgreSQL. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr418147/">https://habr.com/ru/post/fr418147/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418137/index.html">Bloodlust: Entretien avec le fondateur de DonorSearch</a></li>
<li><a href="../fr418139/index.html">Solution numérique de modèles mathématiques d'objets donnés par des systèmes d'équations différentielles</a></li>
<li><a href="../fr418141/index.html">RE: Ghat / AFR Débutant Skipper Race</a></li>
<li><a href="../fr418143/index.html">PVS-Studio comme solution SAST</a></li>
<li><a href="../fr418145/index.html">Le premier procès contre Roskomnadzor d'une entreprise qui a souffert lorsque Telegram a été bloqué</a></li>
<li><a href="../fr418149/index.html">Phishing avec balise de titre</a></li>
<li><a href="../fr418153/index.html">Vidéo Meetup Kolesa Android: à propos de MVVM, des antipatterns et du développement modulaire</a></li>
<li><a href="../fr418155/index.html">Diode LED Diode Zener</a></li>
<li><a href="../fr418157/index.html">Le livre "Objets élégants. Édition Java »</a></li>
<li><a href="../fr418159/index.html">Où aller chez le designer: prestigieux prix de la Russie, de l'Europe de l'Est et des pays de la CEI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>