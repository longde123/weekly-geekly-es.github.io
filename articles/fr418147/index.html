<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ•˜ ğŸ‘²ğŸ¼ ğŸ® Silence of Ruby Executions: Transactional Rails / PostgreSQL Thriller ğŸ”‡ ğŸš¸ ğŸ–ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C'est une histoire sur la raison pour laquelle vous ne devez jamais ignorer les erreurs lorsque vous Ãªtes dans une transaction dans une base de donnÃ©e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Silence of Ruby Executions: Transactional Rails / PostgreSQL Thriller</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418147/"><p>  <em>C'est une histoire sur la raison pour laquelle vous <strong>ne</strong> devez <strong>jamais</strong> ignorer les erreurs lorsque vous Ãªtes dans une transaction dans une base de donnÃ©es.</em>  <em>DÃ©couvrir comment utiliser correctement les transactions et quoi faire lors de leur utilisation n'est pas une option.</em>  <em>Spoiler: il s'agira de verrous consultatifs dans PostgreSQL!</em> </p><br><p> J'ai travaillÃ© sur un projet dans lequel les utilisateurs peuvent importer un grand nombre d'entitÃ©s lourdes (appelons-les produits) d'un service externe dans notre application.  Pour chaque produit, des donnÃ©es encore plus diverses qui lui sont associÃ©es sont chargÃ©es Ã  partir d'API externes.  Il n'est pas rare qu'un utilisateur charge des centaines de produits avec toutes les dÃ©pendances, par consÃ©quent, l'importation d'un produit prend un temps tangible (30 Ã  60 secondes), et l'ensemble du processus peut prendre beaucoup de temps.  L'utilisateur peut Ãªtre fatiguÃ© d'attendre le rÃ©sultat et il a le droit de cliquer sur le bouton "Annuler" Ã  tout moment et l'application devrait Ãªtre utile avec le nombre de produits qui ont pu Ãªtre tÃ©lÃ©chargÃ©s Ã  ce moment. </p><a name="habracut"></a><br><p>  L 'Â«importation interrompueÂ» est implÃ©mentÃ©e comme suit: au dÃ©but, pour chaque produit, un enregistrement de tÃ¢che temporaire est crÃ©Ã© dans la plaque signalÃ©tique de la base de donnÃ©es.  Pour chaque produit, une tÃ¢che d'importation en arriÃ¨re-plan est lancÃ©e, qui tÃ©lÃ©charge le produit, l'enregistre dans la base de donnÃ©es avec toutes les dÃ©pendances (fait tout en gÃ©nÃ©ral) et Ã  la toute fin supprime son enregistrement de tÃ¢che.  Si au moment oÃ¹ la tÃ¢che d'arriÃ¨re-plan dÃ©marre, il n'y aura aucun enregistrement dans la base de donnÃ©es - la tÃ¢che se termine simplement en silence.  Ainsi, pour annuler l'importation, il suffit de supprimer simplement toutes les tÃ¢ches et c'est tout. </p><br><p>  Peu importe si l'importation a Ã©tÃ© annulÃ©e par l'utilisateur ou complÃ¨tement terminÃ©e par lui-mÃªme - en tout cas, l'absence de tÃ¢ches signifie que tout est terminÃ© et que l'utilisateur peut commencer Ã  utiliser l'application. </p><br><p>  Le design est simple et fiable, mais il y avait un petit bug.  Un rapport de bogue typique Ã  son sujet Ã©tait: Â«Une fois l'importation annulÃ©e, l'utilisateur affiche une liste de ses produits.  Cependant, si vous actualisez la page, la liste des produits est complÃ©tÃ©e par plusieurs entrÃ©es. "  La raison de ce comportement est simple: lorsque l'utilisateur clique sur le bouton Â«AnnulerÂ», il est immÃ©diatement transfÃ©rÃ© dans la liste de tous les produits.  Mais Ã  l'heure actuelle, les importations dÃ©jÃ  commencÃ©es de certains biens Â«continuentÂ» de fonctionner. </p><br><p>  Bien sÃ»r, c'est une bagatelle, mais les utilisateurs ont Ã©tÃ© intriguÃ©s par la commande, donc ce serait bien de le rÃ©parer.  J'avais deux faÃ§ons: identifier et Â«tuerÂ» les tÃ¢ches en cours d'exÃ©cution ou, lorsque j'appuie sur le bouton Annuler, attendre qu'elles soient terminÃ©es et Â«mourir de leur propre chefÂ» avant de transfÃ©rer l'utilisateur.  J'ai choisi la deuxiÃ¨me faÃ§on - d'attendre. </p><br><h2 id="tranzakcionnye-blokirovki-speshat-na-pomosch">  Les verrous transactionnels se prÃ©cipitent Ã  la rescousse </h2><br><p>  Pour tous ceux qui travaillent avec des bases de donnÃ©es (relationnelles), la rÃ©ponse est Ã©vidente: utilisez les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">transactions</a> ! </p><br><p> Il est important de se rappeler que dans la plupart des SGBDR, les enregistrements mis Ã  jour dans une transaction seront <em>bloquÃ©s</em> et inaccessibles aux modifications par d'autres processus jusqu'Ã  ce que cette transaction soit terminÃ©e.  Les enregistrements sÃ©lectionnÃ©s Ã  l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>SELECT FOR UPDATE</code></a> seront Ã©galement verrouillÃ©s. </p><br><p>  Exactement notre cas!  J'ai bouclÃ© la tÃ¢che d'importer des marchandises individuelles dans une transaction et j'ai bloquÃ© l'enregistrement de tÃ¢che au tout dÃ©but: </p><br><pre> <code class="ruby hljs">ActiveRecord::Base.transaction <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> task = Import::Task.lock.find_by(<span class="hljs-symbol"><span class="hljs-symbol">id:</span></span> id) <span class="hljs-comment"><span class="hljs-comment"># SELECT â€¦ FOR UPDATE  Â«    Â» return unless task #  - ? ,    ! #     task.destroy end</span></span></code> </pre> <br><p>  DÃ©sormais, lorsque l'utilisateur souhaite annuler l'importation, l'opÃ©ration d'arrÃªt d'importation supprimera les tÃ¢ches pour les importations qui n'ont pas encore commencÃ© et sera obligÃ© d'attendre la fin de celles dÃ©jÃ  existantes: </p><br><pre> <code class="ruby hljs">user.import_tasks.delete_all <span class="hljs-comment"><span class="hljs-comment">#       </span></span></code> </pre> <br><p>  Simple et Ã©lÃ©gant!  J'ai exÃ©cutÃ© les tests, vÃ©rifiÃ© l'importation localement et au niveau de la mise en scÃ¨ne et dÃ©ployÃ© "au combat". </p><br><h2 id="ne-tak-bystro">  Pas si vite ... </h2><br><p>  Satisfait de mon travail, j'ai Ã©tÃ© trÃ¨s surpris de trouver bientÃ´t des rapports de bugs et des tonnes d'erreurs dans les logs.  De nombreux produits n'Ã©taient pas du tout importÃ©s.  Dans certains cas, un seul produit pourrait rester aprÃ¨s l'achÃ¨vement de toutes les importations. </p><br><p>  Les erreurs dans les journaux n'Ã©taient pas encourageantes non plus: <code>PG::InFailedSqlTransaction</code> avec une backtrack menant au code qui exÃ©cutait les <code>SELECT</code> innocents.  Que se passe-t-il du tout? </p><br><p>  AprÃ¨s une journÃ©e de dÃ©bogage Ã©puisante, j'ai identifiÃ© trois causes principales des problÃ¨mes: </p><br><ol><li>  Insertion compÃ©titive d'enregistrements conflictuels dans la base de donnÃ©es. </li><li>  Annulation automatique des transactions dans PostgreSQL aprÃ¨s des erreurs. </li><li>  Silence des problÃ¨mes (exceptions Ruby) dans le code d'application. </li></ol><br><p>  <strong>ProblÃ¨me 1: insertion compÃ©titive d'entrÃ©es conflictuelles</strong> </p><br><p>  Ã‰tant donnÃ© que chaque opÃ©ration d'importation prend jusqu'Ã  une minute et qu'il existe un grand nombre de ces tÃ¢ches, nous les effectuons en parallÃ¨le pour gagner du temps.  Les enregistrements de marchandises dÃ©pendants peuvent se recouper, dans la mesure oÃ¹ tous les produits de l'utilisateur peuvent se rÃ©fÃ©rer Ã  un seul enregistrement, crÃ©Ã© une fois puis rÃ©utilisÃ©. </p><br><p>  Il existe des vÃ©rifications pour trouver et rÃ©utiliser les mÃªmes dÃ©pendances dans le code d'application, mais <em>maintenant, lorsque nous utilisons des transactions, ces vÃ©rifications sont devenues inutiles</em> : si la transaction A a crÃ©Ã© un enregistrement dÃ©pendant mais n'est pas encore terminÃ©e, la transaction B ne pourra pas dÃ©couvrir son existence et essaiera de crÃ©er un doublon record. </p><br><p>  <strong>ProblÃ¨me 2: Annulation automatique des transactions PostgreSQL aprÃ¨s des erreurs</strong> </p><br><p>  Bien sÃ»r, nous avons empÃªchÃ© la crÃ©ation de tÃ¢ches en double au niveau de la base de donnÃ©es Ã  l'aide du DDL suivant: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> product_deps <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span> (user_id, characteristics);</code> </pre> <br><p>  Si une transaction en cours A a insÃ©rÃ© un nouvel enregistrement et que la transaction B essaie d'insÃ©rer un enregistrement avec les mÃªmes valeurs des champs <code>user_id</code> et <code>characteristics</code> , la transaction B recevra une erreur: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> product_deps (user_id, characteristics) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'{"same": "value"}'</span></span>); <span class="hljs-comment"><span class="hljs-comment">-- Now it will block until first transaction will be finished ERROR: duplicate key value violates unique constraint "product_deps_user_id_characteristics_key" DETAIL: Key (user_id, characteristics)=(1, {"same": "value"}) already exists. -- And will throw an error when first transaction have commited and it is become clear that we have a conflict</span></span></code> </pre> <br><p>  Mais il y a une caractÃ©ristique qui ne doit pas Ãªtre oubliÃ©e - la transaction B, aprÃ¨s avoir dÃ©tectÃ© une erreur, sera automatiquement annulÃ©e et tout le travail qui y sera effectuÃ© ira Ã  l'Ã©gout.  Cependant, cette transaction <strong>est toujours ouverte</strong> dans un Ã©tat Â«erronÃ©Â», mais avec toute tentative d'exÃ©cution d'une demande, mÃªme la plus inoffensive, seules les erreurs seront renvoyÃ©es en rÃ©ponse: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> products; ERROR: current transaction is aborted, commands ignored until <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">transaction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">block</span></span></code> </pre> <br><p>  Eh bien, il est complÃ¨tement inutile de dire que tout ce qui a Ã©tÃ© entrÃ© dans la base de donnÃ©es dans cette transaction ne sera pas enregistrÃ©: </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; <span class="hljs-comment"><span class="hljs-comment">--      ,   ROLLBACK --          </span></span></code> </pre> <br><p>  <strong>TroisiÃ¨me problÃ¨me: le silence</strong> </p><br><p>  Ã€ ce stade, il Ã©tait dÃ©jÃ  clair que le simple fait d'ajouter des transactions Ã  l'application l'a brisÃ©e.  Il n'y avait pas d'autre choix: je devais plonger dans le code d'importation.  Dans le code, les motifs suivants ont souvent attirÃ© mon attention: </p><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_stuff</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment"># ,   rescue StandardError nil #  ,  end</span></span></code> </pre> <br><p>  L'auteur du code ici nous dit: "Nous avons essayÃ©, nous n'avons pas rÃ©ussi, mais Ã§a va, nous continuons sans."  Et bien que les raisons de ce choix puissent Ãªtre tout Ã  fait explicables (tout ne peut pas Ãªtre traitÃ© au niveau de l'application), c'est ce qui rend impossible toute logique basÃ©e sur des transactions: une exÃ©cution rejetÃ©e ne pourra pas flotter jusqu'au bloc de <code>transaction</code> , et ne provoquera pas une restauration correcte transactions (ActiveRecord intercepte toutes les erreurs dans ce bloc, annule la transaction et les relance). </p><br><h2 id="idealnyy-shtorm">  TempÃªte parfaite </h2><br><p>  Et voici comment ces trois facteurs se sont rÃ©unis pour crÃ©er le parfait <del>  la tempÃªte </del>  bug: </p><br><ul><li>  Une application dans une transaction essaie d'insÃ©rer un enregistrement en conflit dans la base de donnÃ©es et provoque une erreur de "clÃ© en double" de PostgreSQL.  Toutefois, cette erreur n'entraÃ®ne pas l'annulation de la transaction dans l'application, car elle est "Ã©touffÃ©e" dans l'une des parties de l'application. </li><li>  La transaction devient invalide, mais l'application n'en a pas connaissance et continue de fonctionner.  Dans toute tentative d'accÃ¨s Ã  la base de donnÃ©es, l'application reÃ§oit Ã  nouveau une erreur, cette fois "la transaction en cours est abandonnÃ©e", mais cette erreur peut Ã©galement Ãªtre supprimÃ©e ... </li><li>  Vous avez probablement dÃ©jÃ  compris que quelque chose dans l'application continue de se casser, mais personne ne le saura jusqu'Ã  ce que l'exÃ©cution atteigne le premier endroit, oÃ¹ il n'y a pas de <code>rescue</code> trop gourmand et oÃ¹ l'erreur peut finalement apparaÃ®tre, Ãªtre enregistrÃ©e, enregistrÃ© dans le tracker d'erreur - quoi que ce soit.  Mais cet endroit sera dÃ©jÃ  trÃ¨s loin de l'endroit qui est devenu la cause premiÃ¨re de l'erreur, et cela seul transformera le dÃ©bogage en cauchemar. </li></ul><br><h2 id="alternativa-tranzakcionnym-blokirovkam-v-postgresql">  Alternative aux verrous transactionnels dans PostgreSQL </h2><br><p>  La recherche de <code>rescue</code> dans le code d'application et la rÃ©Ã©criture de toute la logique d'importation ne sont pas une option.  Un long moment.  J'avais besoin d'une solution rapide et je l'ai trouvÃ©e chez les postgres!  Il a une solution intÃ©grÃ©e pour les verrous, une alternative au verrouillage des enregistrements dans les transactions, des verrous de conseil de session.  Je les ai utilisÃ©s comme suit: </p><br><p>  Tout d'abord, j'ai d'abord supprimÃ© la transaction d'emballage.  Dans tous les cas, interagir avec des API externes (ou tout autre Â«effet secondaireÂ») du code d'application avec une transaction ouverte est une mauvaise idÃ©e, car mÃªme si vous annulez la transaction avec toutes les modifications de notre base de donnÃ©es, les modifications des systÃ¨mes externes resteront et l'application dans son ensemble peut se trouver dans un Ã©tat Ã©trange et indÃ©sirable.  Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">joyau de l'isolateur</a> peut vous aider Ã  vous assurer que les effets secondaires sont correctement <em>isolÃ©s</em> des transactions. </p><br><p>  Ensuite, dans chaque opÃ©ration d'importation, je prends un verrou <em>partagÃ©</em> sur une clÃ© unique pour l'importation entiÃ¨re (par exemple, crÃ©Ã©e Ã  partir de l'ID utilisateur et du hachage Ã  partir du nom de la classe d'opÃ©ration): </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_advisory_lock_shared(<span class="hljs-number"><span class="hljs-number">42</span></span>, user.id);</code> </pre> <br><p>  Des verrous partagÃ©s sur la mÃªme clÃ© peuvent Ãªtre pris simultanÃ©ment par n'importe quel nombre de sessions. </p><br><p>  L'annulation de l'opÃ©ration d'importation supprime simultanÃ©ment toutes les entrÃ©es de tÃ¢che de la base de donnÃ©es et essaie de prendre <em>un</em> verrou <em>exclusif</em> sur la mÃªme clÃ©.  Dans ce cas, elle devra attendre que tous les verrous partagÃ©s soient libÃ©rÃ©s: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_advisory_lock(<span class="hljs-number"><span class="hljs-number">42</span></span>, user.id)</code> </pre> <br><p>  Et c'est tout!  Maintenant, l 'Â«annulationÂ» attendra que toutes les importations Â«en coursÂ» de biens individuels soient terminÃ©es. </p><br><p>  De plus, maintenant que nous ne sommes pas connectÃ©s par une transaction, nous pouvons utiliser un petit hack pour limiter le temps d'attente pour l'annulation de l'importation (dans le cas oÃ¹ certains Â«sticksÂ» d'importation), car il n'est pas bon de bloquer le flux du serveur Web pendant une longue pÃ©riode (et forcer attendre l'utilisateur): </p><br><pre> <code class="ruby hljs">transaction <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> execute(<span class="hljs-string"><span class="hljs-string">"SET LOCAL lock_timeout = '30s'"</span></span>) execute(<span class="hljs-string"><span class="hljs-string">"SELECT pg_advisory_lock(42, user.id)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">rescue</span></span> ActiveRecord::LockWaitTimeout <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-comment"><span class="hljs-comment">#    (     ) end</span></span></code> </pre> <br><p>  Il est sÃ»r d'attraper une erreur en <em>dehors</em> du bloc de <code>transaction</code> , car <a href="">ActiveRecord annulera dÃ©jÃ  la transaction</a> . </p><br><h2 id="no-chto-delat-s-konkurentnoy-vstavkoy-odinakovyh-zapisey">  Mais que faire de l'insertion compÃ©titive d'enregistrements identiques? </h2><br><p>  Malheureusement, je ne connais pas de solution qui fonctionnerait bien avec <em>des</em> inserts <em>compÃ©titifs</em> .  Il existe les approches suivantes, mais elles bloqueront toutes les insertions simultanÃ©es jusqu'Ã  la fin de la premiÃ¨re des transactions: </p><br><ul><li>  <code>INSERT â€¦ ON CONFLICT UPDATE</code> (disponible depuis PostgreSQL 9.5) dans la deuxiÃ¨me transaction sera verrouillÃ© jusqu'Ã  ce que la premiÃ¨re transaction soit terminÃ©e, puis il renverra l'enregistrement qui a Ã©tÃ© insÃ©rÃ© par la premiÃ¨re transaction. </li><li>  Verrouillez un enregistrement gÃ©nÃ©ral dans une transaction avant d'exÃ©cuter des validations pour insÃ©rer un nouvel enregistrement.  Ici, nous attendrons que l'enregistrement insÃ©rÃ© dans une autre transaction soit visible et que les validations ne puissent pas fonctionner correctement. </li><li>  Prenez une sorte de verrouillage de recommandation gÃ©nÃ©rale - l'effet est le mÃªme que pour le blocage d'un enregistrement gÃ©nÃ©ral. </li></ul><br><p>  Eh bien, si vous n'avez pas peur de travailler avec des erreurs de niveau de base, vous pouvez simplement attraper l'erreur d'unicitÃ©: </p><br><pre> <code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">import_all_the_things</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">#   ,   Dep.create(user_id, chars) rescue ActiveRecord::RecordNotUnique retry end</span></span></span></span></code> </pre> <br><p>  Assurez-vous simplement que ce code n'est plus inclus dans une transaction. </p><br><blockquote>  Pourquoi sont-ils bloquÃ©s? <br><br>  Les contraintes UNIQUE et EXCLUDE bloquent <em>les conflits potentiels en</em> empÃªchant leur enregistrement en mÃªme temps.  Par exemple, si vous avez une contrainte unique sur une colonne entiÃ¨re et qu'une transaction insÃ¨re une ligne avec une valeur de 5, les autres transactions qui tentent Ã©galement d'insÃ©rer 5 seront bloquÃ©es, mais les transactions qui tentent d'insÃ©rer 6 ou 4 rÃ©ussiront immÃ©diatement, sans blocage.  Ã‰tant donnÃ© que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le niveau minimum d'isolation des transactions de PostgreSQL</a> est <code>READ COMMITED</code> , une transaction n'est pas autorisÃ©e Ã  voir les modifications non validÃ©es des autres transactions.  Par consÃ©quent, un <code>INSERT</code> avec une valeur en conflit ne peut pas Ãªtre acceptÃ© ou rejetÃ© jusqu'Ã  ce que la premiÃ¨re transaction valide ses modifications (puis le second reÃ§oit une erreur d'unicitÃ©) ou annule (puis l'insertion dans la deuxiÃ¨me transaction rÃ©ussira).  En savoir plus Ã  ce sujet dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article de l'auteur des restrictions EXCLUDE</a> . </blockquote><br><h2 id="predotvraschaem-katastrofu-v-buduschem">  PrÃ©venir une catastrophe future </h2><br><p>  Vous savez <em>maintenant</em> que tout le code ne peut pas Ãªtre encapsulÃ© dans une transaction.  Ce serait bien de s'assurer que personne d'autre n'emballe un tel code dans une transaction Ã  l'avenir, rÃ©pÃ©tant mon erreur. </p><br><p>  Pour ce faire, vous pouvez encapsuler toutes vos opÃ©rations dans un petit module auxiliaire qui vÃ©rifiera si la transaction est ouverte avant d'exÃ©cuter le code d'opÃ©ration encapsulÃ© (ici, il est supposÃ© que toutes vos opÃ©rations ont la mÃªme interface - la mÃ©thode d' <code>call</code> ). </p><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#     module NoTransactionAllowed class InTransactionError &lt; RuntimeError; end def call(*) return super unless in_transaction? raise InTransactionError, "#{self.class.name} doesn't work reliably within a DB transaction" end def in_transaction? connection = ApplicationRecord.connection # service transactions (tests and database_cleaner) are not joinable connection.transaction_open? &amp;&amp; connection.current_transaction.joinable? end end #    class Deps::Import &lt; BaseService prepend NoTransactionAllowed def call do_import rescue ActiveRecord::RecordNotUnique retry end end</span></span></code> </pre> <br><p>  Maintenant, si quelqu'un essaie de boucler un service <em>dangereux</em> dans une transaction, il recevra immÃ©diatement une erreur (Ã  moins, bien sÃ»r, de le garder silencieux). </p><br><h2 id="itogi">  RÃ©sumÃ© </h2><br><p>  La principale leÃ§on Ã  tirer: faites attention aux exceptions.  Ne gÃ©rez pas tout de suite, ne rÃ©cupÃ©rez que les exceptions que vous savez comment gÃ©rer et laissez le reste accÃ©der aux journaux.  N'ignorez jamais les exceptions (uniquement si vous n'Ãªtes pas sÃ»r Ã  100% pourquoi vous faites cela).  Plus tÃ´t une erreur est constatÃ©e, plus il sera facile de dÃ©boguer. </p><br><p>  Et n'en faites pas trop avec les transactions dans la base de donnÃ©es.  Ce n'est pas une panacÃ©e.  Utilisez notre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">isolateur de</a> gemmes et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">after_commit_everywhere</a> - ils aideront vos transactions Ã  devenir complÃ¨tement infaillibles. </p><br><h2 id="chto-pochitat">  Que lire </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Ruby exceptionnel</em></a> <em>par Avdi Grimm</em> .  Ce petit livre vous apprendra comment gÃ©rer les exceptions existantes dans Ruby et comment concevoir correctement un systÃ¨me d'exceptions pour votre application. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://brandur.org/"><em>Utilisation de transactions atomiques pour</em></a> alimenter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://brandur.org/"><em>une API idempotente</em></a> par @Brandur.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Son blog contient de</a> nombreux articles utiles sur la fiabilitÃ© des applications, Ruby et PostgreSQL. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr418147/">https://habr.com/ru/post/fr418147/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418137/index.html">Bloodlust: Entretien avec le fondateur de DonorSearch</a></li>
<li><a href="../fr418139/index.html">Solution numÃ©rique de modÃ¨les mathÃ©matiques d'objets donnÃ©s par des systÃ¨mes d'Ã©quations diffÃ©rentielles</a></li>
<li><a href="../fr418141/index.html">RE: Ghat / AFR DÃ©butant Skipper Race</a></li>
<li><a href="../fr418143/index.html">PVS-Studio comme solution SAST</a></li>
<li><a href="../fr418145/index.html">Le premier procÃ¨s contre Roskomnadzor d'une entreprise qui a souffert lorsque Telegram a Ã©tÃ© bloquÃ©</a></li>
<li><a href="../fr418149/index.html">Phishing avec balise de titre</a></li>
<li><a href="../fr418153/index.html">VidÃ©o Meetup Kolesa Android: Ã  propos de MVVM, des antipatterns et du dÃ©veloppement modulaire</a></li>
<li><a href="../fr418155/index.html">Diode LED Diode Zener</a></li>
<li><a href="../fr418157/index.html">Le livre "Objets Ã©lÃ©gants. Ã‰dition Java Â»</a></li>
<li><a href="../fr418159/index.html">OÃ¹ aller chez le designer: prestigieux prix de la Russie, de l'Europe de l'Est et des pays de la CEI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>