<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💆🏼 🤯 🤠 في الوقت الحقيقي معالجة البيانات التنافسية غير المتجانسة بدقة 👨🏼‍🚀 〰️ ♐️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="شرح 


 تعتبر معالجة البيانات في الوقت الفعلي بالضبط مرة واحدة (مرة واحدة بالضبط ) مهمة غير تافهة للغاية وتتطلب نهجًا جادًا ومدروسًا طوال سلسلة الحساب...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>في الوقت الحقيقي معالجة البيانات التنافسية غير المتجانسة بدقة</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413817/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/uf/mh/m-/ufmhm-q0wjfbdgbv4jn4ece8duw.jpeg" alt="سجق تنافسي"></p><br><h2 id="annotaciya" style=";text-align:right;direction:rtl">  شرح </h2><br><p style=";text-align:right;direction:rtl">  تعتبر معالجة البيانات في الوقت الفعلي بالضبط مرة واحدة (مرة واحدة <em>بالضبط</em> ) مهمة غير تافهة للغاية وتتطلب نهجًا جادًا ومدروسًا طوال سلسلة الحسابات بأكملها.  يعتقد البعض أن <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مثل هذه المهمة مستحيلة</a> .  في الواقع ، أريد أن يكون لدي نهج يوفر معالجة متسامحة مع الأخطاء دون أي تأخير على الإطلاق واستخدام تخزين مختلف للبيانات ، والذي يطرح متطلبات جديدة أكثر صرامة للنظام: <em>متزامن مرة واحدة بالضبط</em> وعدم تجانس الطبقة الثابتة.  حتى الآن ، لا يدعم هذا المطلب أيًا من الأنظمة الموجودة. </p><br><p style=";text-align:right;direction:rtl">  سيكشف النهج المقترح باستمرار عن المكونات السرية والمفاهيم الضرورية التي تجعل من السهل نسبيًا تنفيذ <em>المتزامنة</em> غير المتجانسة <em>بالضبط مرة واحدة بالضبط</em> من مكونين حرفيا. </p><br><h2 id="vvedenie" style=";text-align:right;direction:rtl">  مقدمة </h2><br><p style=";text-align:right;direction:rtl">  يمر مطور الأنظمة الموزعة بعدة مراحل: </p><br><p style=";text-align:right;direction:rtl">  <em>المرحلة 1: الخوارزميات</em> .  هنا دراسة الخوارزميات الأساسية وهياكل البيانات ونهج البرمجة مثل OOP وما إلى ذلك.  الكود مترابط بشكل حصري.  المرحلة الأولى من دخول المهنة.  ومع ذلك ، فهي معقدة للغاية ويمكن أن تستمر لسنوات. </p><br><p style=";text-align:right;direction:rtl">  <em>المرحلة 2: multithreading</em> .  بعد ذلك ، تطرح أسئلة حول استخراج أقصى قدر من الكفاءة من الحديد ، وهناك تعدد مؤشرات ، وعدم التزامن ، والسباق ، وتصحيح الأخطاء ، والركود ، وليالي بلا نوم ... يتعثر الكثير في هذه المرحلة وحتى يبدأ في التقاط إثارة لا يمكن تفسيرها في مرحلة ما.  لكن قلة قليلة فقط فهمت بنية الذاكرة الافتراضية ونماذج الذاكرة ، والخوارزميات الخالية من القفل / الانتظار ، والنماذج المختلفة غير المتزامنة.  وتقريبا لا أحد على الإطلاق - التحقق من التعليمات البرمجية متعددة الخيوط. </p><br><p style=";text-align:right;direction:rtl">  <em>المرحلة 3: التوزيع</em> .  هنا يحدث مثل هذه القمامة لا في حكاية خرافية ولا قلم لوصف. </p><a name="habracut"></a><br><p style=";text-align:right;direction:rtl">  يبدو أن شيئًا معقدًا.  نقوم بالتحويل: العديد من الخيوط -&gt; العديد من العمليات -&gt; العديد من الخوادم.  لكن كل خطوة من خطوات التحول تحدث تغييرات نوعية ، وكلها تقع على النظام ، وتسحقه وتحوله إلى غبار. </p><br><p style=";text-align:right;direction:rtl">  والنقطة هنا هي تغيير مجال معالجة الخطأ وتوافر الذاكرة المشتركة.  إذا كان هناك دائمًا جزء من الذاكرة كان متاحًا في كل خيط ، وإذا رغبت في ذلك ، في كل عملية ، الآن لا توجد مثل هذه القطعة ولا يمكن أن تكون.  كل لنفسه ومستقل وفخور. </p><br><p style=";text-align:right;direction:rtl">  إذا كان الفشل في الدفق في وقت سابق قد دفن الدفق والعملية في نفس الوقت ، وكان هذا جيدًا ، لأنه  لم يؤد إلى فشل جزئي ، والآن أصبح الفشل الجزئي هو القاعدة وفي كل مرة قبل كل عمل تفكر فيه: "ماذا لو؟".  هذا مزعج للغاية ويشتت الانتباه عن الكتابة ، في الواقع ، الإجراءات نفسها التي ينمو بها الرمز بسبب هذا ليس في بعض الأحيان ، ولكن بأوامر من الحجم.  كل شيء يتحول إلى شعيرية معالجة الأخطاء ، وتبديل الحالة والحفاظ على السياق ، والترميم بسبب فشل أحد المكونات ، ومكون آخر ، وعدم إمكانية الوصول إلى بعض الخدمات ، إلخ.  الخ.  بعد أن أخطأت مراقبة كل هذه الأشياء ، يمكنك الحصول على نوم هنيئ على جهاز الكمبيوتر المحمول المفضل لديك. </p><br><p style=";text-align:right;direction:rtl">  سواء كانت مسألة تعدد المواضيع: لقد أخذت كائن المزامنة وذهبت لتمزيق الذاكرة المشتركة من أجل المتعة.  جمال! </p><br><p style=";text-align:right;direction:rtl">  ونتيجة لذلك ، لدينا أن الأنماط الرئيسية واختبار المعارك قد تم سحبها ، وأن الأنماط الجديدة ، لتحل محلها ، لسبب ما لم يتم تسليمها ، واتضح الأمر كما لو كان نكتة حول كيف تلوح الجنية بعصاها وسقط البرج من الدبابة. </p><br><p style=";text-align:right;direction:rtl">  ومع ذلك ، فإن الأنظمة الموزعة لديها مجموعة من الممارسات المثبتة والخوارزميات المثبتة.  ومع ذلك ، يعتبر كل مبرمج يحترم نفسه أنه من واجبه رفض الإنجازات المعروفة ودراجة مصلحته ، على الرغم من الخبرة المكتسبة ، عدد كبير من المقالات العلمية والبحث الأكاديمي.  بعد كل شيء ، إذا استطعت الدخول إلى الخوارزميات والتعددية ، كيف يمكنك الدخول في فوضى مع التوزيع؟  لا يمكن أن يكون هناك رأيين هنا! </p><br><p style=";text-align:right;direction:rtl">  نتيجة لذلك ، الأنظمة هي عربات التي تجرها الدواب ، تتباعد البيانات وتتدهور ، تصبح الخدمات غير متوفرة بشكل دوري للكتابة ، أو حتى غير متاحة تمامًا ، لأنه فجأة تعطلت العقدة ، تعطلت الشبكة ، استهلكت Java الكثير من الذاكرة و GC مملة ، وهناك العديد من الأسباب الأخرى التي يمكن أن تؤخر نهايتها للسلطات. </p><br><p style=";text-align:right;direction:rtl">  ومع ذلك ، حتى مع النهج المعروفة والمثبتة ، لا تصبح الحياة أسهل ، لأن  البدائية الموثوقة الموزعة هي الوزن الثقيل مع متطلبات خطيرة لمنطق التعليمات البرمجية القابلة للتنفيذ.  لذلك ، يتم قطع الزوايا كلما أمكن ذلك.  وكما يحدث في كثير من الأحيان ، مع قطع الزوايا على عجل ، تظهر البساطة وقابلية التوسع النسبية ، ولكن موثوقية وتوافر واتساق النظام الموزع يختفي. </p><br><p style=";text-align:right;direction:rtl">  من الناحية المثالية ، لا أود أن أفكر على الإطلاق في أن نظامنا موزع ومتعدد المواضيع ، أي  العمل في المرحلة الأولى (الخوارزميات) ، دون التفكير في المرحلة الثانية (تزامن متعدد + التزامن) والثالثة (التوزيع).  هذه الطريقة لعزل التجريد من شأنها أن تزيد بشكل كبير من البساطة والموثوقية وسرعة كتابة التعليمات البرمجية.  لسوء الحظ ، في الوقت الحالي هذا ممكن فقط في الأحلام. </p><br><p style=";text-align:right;direction:rtl">  ومع ذلك ، فإن التجريد الفردي يسمح بالعزلة النسبية.  أحد الأمثلة النموذجية هو <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">استخدام coroutines</a> ، حيث بدلاً من الرمز غير المتزامن نحصل على متزامن ، أي  ننتقل من المرحلة الثانية إلى المرحلة الأولى ، مما يسمح لنا بتبسيط كتابة الرمز والحفاظ عليه بشكل كبير. </p><br><p style=";text-align:right;direction:rtl">  تكشف المقالة على التوالي عن استخدام خوارزميات خالية من القفل لإنشاء نظام في الوقت الحقيقي قابل للتوزيع وموزع موثوق به ومتناسق ، أي  كيف تساعد الإنجازات بدون قفل للمرحلة الثانية في تنفيذ المرحلة الثالثة ، مما يقلل من المهمة إلى خوارزميات مفردة الخيوط للمرحلة الأولى. </p><br><h2 id="postanovka-zadachi" style=";text-align:right;direction:rtl">  بيان المشكلة </h2><br><p style=";text-align:right;direction:rtl">  توضح هذه المهمة فقط بعض الأساليب الهامة ويتم تقديمها كمثال لإدخال المشكلات في السياق.  يمكن تعميمه بسهولة على الحالات الأكثر تعقيدًا ، والتي سيتم إجراؤها في المستقبل. </p><br><p style=";text-align:right;direction:rtl">  <strong>المهمة: معالجة البيانات المتدفقة في الوقت الفعلي</strong> . </p><br><p style=";text-align:right;direction:rtl">  هناك نوعان من تيارات الأرقام.  يقرأ المعالج بيانات تدفقات الإدخال هذه ويحدد الأرقام الأخيرة لفترة معينة.  يتم حساب متوسط ​​هذه الأرقام خلال هذه الفترة الزمنية ، أي  في نافذة بيانات منزلقة لوقت معين.  يجب كتابة متوسط ​​القيمة التي تم الحصول عليها إلى قائمة انتظار الإخراج للمعالجة اللاحقة.  بالإضافة إلى ذلك ، إذا تجاوز عدد الأرقام في النافذة عتبة معينة ، فقم بزيادة العداد في قاعدة بيانات المعاملات الخارجية بمقدار واحد. </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/nf/9d/jh/nf9djhbhsjmrumrg5eckb1h6u_c.png" alt="الأولي"></p><br><p style=";text-align:right;direction:rtl">  نلاحظ بعض ميزات هذه المشكلة. </p><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <em>اللا حتمية</em> .  هناك مصدران للسلوك غير القطعي: هذه قراءة من تيارين ، بالإضافة إلى نافذة زمنية.  من الواضح أنه يمكن إجراء القراءة بطرق مختلفة ، وستعتمد النتيجة النهائية على تسلسل البيانات التي سيتم استخراجها.  تغير النافذة الزمنية النتيجة أيضًا من البداية إلى البداية ، مثل  كمية البيانات في النافذة تعتمد على سرعة العمل. </li><li style=";text-align:right;direction:rtl">  <em>حالة المعالج</em> .  توجد حالة المعالج في شكل مجموعة من الأرقام في النافذة ، والتي تعتمد عليها نتائج العمل الحالية واللاحقة.  على سبيل المثال  لدينا معالج رسمي. </li><li style=";text-align:right;direction:rtl">  <em>التفاعل مع التخزين الخارجي</em> .  من الضروري تحديث قيمة العداد في قاعدة البيانات الخارجية.  النقطة الحاسمة هي أن نوع التخزين الخارجي يختلف عن تخزين حالة المعالج والخيوط. </li></ol><br><p style=";text-align:right;direction:rtl">  كل هذا ، كما هو موضح أدناه ، يؤثر بشكل خطير على الأدوات المستخدمة وطرق التنفيذ الممكنة. </p><br><p style=";text-align:right;direction:rtl">  يبقى إضافة لمسة صغيرة إلى المهمة ، التي تنقل المهمة على الفور من منطقة تتجاوز التعقيد إلى مستحيل: هناك حاجة إلى ضمان <em>متزامن لمرة واحدة بالضبط</em> . </p><br><h2 id="exactly-once" style=";text-align:right;direction:rtl">  مرة واحدة بالضبط </h2><br><p style=";text-align:right;direction:rtl">  غالبًا ما <em>يتم</em> تفسيره <em>مرة واحدة على</em> نطاق واسع جدًا ، مما يعوق المصطلح نفسه ، ويتوقف عن تلبية المتطلبات الأصلية للمهمة.  إذا كنا نتحدث عن نظام يعمل محليًا على جهاز كمبيوتر واحد - فإن كل شيء بسيط: خذ المزيد ، ورمي أبعد.  لكن في هذه الحالة نتحدث عن نظام موزع: </p><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يمكن أن يكون عدد المعالجات كبيرًا: يعمل كل معالج مع قطعة البيانات الخاصة به.  علاوة على ذلك ، يمكن إضافة النتائج إلى أماكن مختلفة ، على سبيل المثال ، قاعدة بيانات خارجية ، ربما حتى يتم تبديلها. </li><li style=";text-align:right;direction:rtl">  يمكن لكل معالج إيقاف المعالجة فجأة.  يشير النظام المتسامح مع الخطأ إلى استمرار التشغيل حتى في حالة فشل الأجزاء الفردية من النظام. </li></ol><br><p style=";text-align:right;direction:rtl">  وبالتالي ، يجب أن نكون مستعدين لحقيقة أن المعالج قد يقع ، ويجب أن يلتقط معالج آخر العمل المنجز بالفعل ومواصلة المعالجة. </p><br><p style=";text-align:right;direction:rtl">  يطرح السؤال على الفور: ما <em>الذي</em> سيعني <em>بالضبط مرة واحدة</em> إذا كان المعالج غير القطعي يعمل؟  بعد كل شيء ، في كل مرة نعيد فيها العمل ، سوف نتلقى ، بشكل عام ، حالات مختلفة مختلفة.  الجواب هنا بسيط: مع <em>مرة واحدة بالضبط ،</em> هناك تنفيذ للنظام يتم فيه معالجة كل قيمة إدخال مرة واحدة بالضبط ، مما يعطي نتيجة الإخراج المقابلة.  علاوة على ذلك ، لا يجب أن يكون هذا التنفيذ جسديًا على نفس العقدة.  ولكن يجب أن تكون النتيجة كما لو تم معالجة كل شيء على عقدة منطقية واحدة <em>بدون أعطال</em> . </p><br><h2 id="concurrent-exactly-once" style=";text-align:right;direction:rtl">  متزامن مرة واحدة بالضبط </h2><br><p style=";text-align:right;direction:rtl">  لتفاقم المتطلبات ، نقدم مفهومًا جديدًا: <em>متزامن مرة واحدة بالضبط</em> .  الاختلاف الأساسي عن البسيط <em>لمرة واحدة</em> هو عدم وجود فترات توقف مؤقت أثناء المعالجة ، كما لو تم معالجة كل شيء على نفس العقدة <strong>بدون قطرات</strong> <strong>وبدون توقفات</strong> .  في مهمتنا ، سنطلب <em>متزامنة تمامًا مرة واحدة بالضبط</em> ، من أجل بساطة العرض ، حتى لا نفكر في مقارنة مع الأنظمة الحالية غير المتوفرة اليوم. </p><br><p style=";text-align:right;direction:rtl">  ستتم مناقشة نتائج مثل هذا الشرط أدناه. </p><br><h2 id="tranzakcionnost" style=";text-align:right;direction:rtl">  المعاملات </h2><br><p style=";text-align:right;direction:rtl">  حتى يكون القارئ مشبعًا بعمق أكبر بالتعقيد الذي نشأ ، فلنلقِ نظرة على سيناريوهات سيئة مختلفة يجب أخذها في الاعتبار عند تطوير مثل هذا النظام.  سنحاول أيضًا استخدام نهج عام يسمح لنا بحل المشكلة المذكورة أعلاه مع مراعاة متطلباتنا. </p><br><p style=";text-align:right;direction:rtl">  أول ما يتبادر إلى الذهن هو الحاجة إلى تسجيل حالة المعالج وتدفق الإدخال والإخراج.  يتم وصف حالة تدفقات الإخراج بقائمة انتظار بسيطة من الأرقام ، وحالة تدفقات الإدخال حسب الموضع الموجود فيها.  في جوهره ، يعد الدفق قائمة انتظار غير محدودة ، ويعين الموضع في قائمة الانتظار موقعًا فريدًا. </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/iu/h0/pf/iuh0pfzcezje80kdbsv3idyeu9a.jpeg" alt="فكرة"></p><br><p style=";text-align:right;direction:rtl">  ينشأ التنفيذ الساذج التالي للمعالج باستخدام نوع من مستودع البيانات.  في هذه المرحلة ، لن تكون الخصائص المحددة للمستودع مهمة بالنسبة لنا.  سنستخدم لغة Pseco لتوضيح الفكرة (Pseco: = pseudo code): </p><br><pre style=";text-align:right;direction:rtl"><code class="hljs pgsql">handle(input_queues, output_queues, state): #    input_indexes = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.get_input_indexes() #      <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #         items, new_input_indexes = input_queues.get_from(input_indexes) #    state.queue.push(items) #     duration state.queue.trim_time_window(duration) avg = state.queue.avg() need_update_counter = state.queue.size() &gt; size_boundary # (A)      output_queues[<span class="hljs-number"><span class="hljs-number">0</span></span>].push(avg) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> need_update_counter: # (B)      db.increment_counter() # (C)     <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.save_state(state) # (D)    <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.save_queue_indexes(new_input_indexes) # (E)    input_indexes = new_input_indexes</code> </pre> <br><p style=";text-align:right;direction:rtl">  فيما يلي خوارزمية بسيطة مفردة الخيوط تقرأ البيانات من تدفقات الإدخال وتكتب القيم المطلوبة وفقًا للمهمة الموضحة أعلاه. </p><br><p style=";text-align:right;direction:rtl">  دعونا نرى ما يحدث في حالة سقوط العقدة في نقاط عشوائية في الوقت المناسب ، وكذلك بعد استئناف العمل.  من الواضح أنه في حالة السقوط في النقطتين <code>(A)</code> و <code>(E)</code> سيكون كل شيء على ما يرام: إما أن البيانات لم يتم تسجيلها في أي مكان حتى الآن ونستعيد الحالة ببساطة ونستمر في العقدة الأخرى ، أو تم تسجيل جميع البيانات الضرورية بالفعل ونستمر في الخطوة التالية فقط. </p><br><p style=";text-align:right;direction:rtl">  ومع ذلك ، في حالة السقوط في جميع النقاط الأخرى ، تنتظرنا مشاكل غير متوقعة.  إذا حدث انخفاض عند النقطة <code>(B)</code> ، فعند إعادة تشغيل المعالج ، سنستعيد الحالة ونعيد تسجيل متوسط ​​القيمة في نفس نطاق الأرقام تقريبًا.  في حالة السقوط عند النقطة <code>(C)</code> بالإضافة إلى متوسط ​​التكرار ، سيحدث تكرار في زيادة القيمة.  وفي حالة حدوث انخفاض في <code>(D)</code> سنحصل على حالة غير متناسقة للمعالج: تتوافق الحالة مع لحظة جديدة في الوقت المناسب ، وسنقرأ القيم من تدفقات الإدخال القديمة. </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/fn/8z/6f/fn8z6f9t3y-fe2hzlepgnie7qps.jpeg" alt="مفاجآت"></p><br><p style=";text-align:right;direction:rtl">  في الوقت نفسه ، لن يتغير شيء جوهريًا عند إعادة ترتيب عمليات التسجيل: سيبقى عدم الاتساق والتكرار كذلك.  وبالتالي ، نصل إلى استنتاج مفاده أن جميع الإجراءات لتغيير حالة المعالج في المستودع وقائمة انتظار الإخراج وقاعدة البيانات يجب أن يتم تنفيذها بالمعاملة ، أي  كل شيء ذري في نفس الوقت. </p><br><p style=";text-align:right;direction:rtl">  وبناءً على ذلك ، من الضروري تطوير آلية حتى تتمكن المخازن المختلفة من تغيير حالتها ، وليس داخل كل منها بشكل مستقل ، ولكن معاملات بين جميع المخازن في وقت واحد.  بالطبع ، يمكنك وضع التخزين داخل قاعدة بيانات خارجية ، ومع ذلك ، افترضت المهمة أن محرك قاعدة البيانات ومحرك إطار معالجة البيانات المتدفقة منفصلان ويعملان بشكل مستقل عن بعضهما البعض.  هنا أريد أن أعتبر الحالة الأكثر صعوبة ، لأن  الحالات البسيطة ليست مثيرة للاهتمام للنظر فيها. </p><br><h2 id="konkurentnaya-otzyvchivost" style=";text-align:right;direction:rtl">  الاستجابة التنافسية </h2><br><p style=";text-align:right;direction:rtl">  فكر في التنفيذ التنافسي مرة واحدة بالضبط بمزيد من التفاصيل.  في حالة وجود نظام يتحمل الأخطاء ، نحتاج إلى استمرار العمل من نقطة ما.  من الواضح أن هذه النقطة ستكون نقطة في الماضي ، لأنه  للحفاظ على الأداء ، من المستحيل تخزين جميع لحظات تغييرات الحالة في الحاضر والمستقبل: إما أن يتم حفظ النتيجة الأخيرة للعمليات أو مجموعة من القيم لزيادة الإنتاجية.  يقودنا هذا السلوك على الفور إلى حقيقة أنه بعد استعادة حالة المعالج ، سيكون هناك بعض التأخير في النتائج ، وسوف تزداد مع زيادة حجم مجموعة القيم وحجم الحالة. </p><br><p style=";text-align:right;direction:rtl">  بالإضافة إلى هذا التأخير ، هناك أيضًا تأخيرات في النظام مرتبطة بتحميل الحالة إلى عقدة أخرى.  بالإضافة إلى ذلك ، فإن اكتشاف عقدة مشكلة يستغرق أيضًا بعض الوقت ، وغالبًا ما يكون كثيرًا.  هذا يرجع ، أولاً وقبل كل شيء ، إلى حقيقة أنه إذا حددنا وقتًا قصيرًا للكشف ، فإن الإنذارات الكاذبة المتكررة ممكنة ، مما سيؤدي إلى جميع أنواع التأثيرات الخاصة غير السارة. </p><br><p style=";text-align:right;direction:rtl">  بالإضافة إلى ذلك ، مع الزيادة في عدد المعالجات المتوازية ، اتضح فجأة أنه ليس كلهم ​​يعملون بشكل جيد على قدم المساواة حتى في غياب الفشل.  في بعض الأحيان تحدث التواءات ، مما يؤدي أيضًا إلى تأخيرات في المعالجة.  يمكن أن يتنوع سبب هذه التباعد: </p><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <em>البرنامج</em> : توقف GC مؤقتًا ، وتجزئة الذاكرة ، وإيقاف مؤقت للمخصص ، وانقطاع kernel ، وجدولة المهام ، ومشكلات في برامج تشغيل الجهاز تتسبب في حدوث بطء. </li><li style=";text-align:right;direction:rtl">  <em>الأجهزة</em> : تحميل عالي للقرص أو الشبكة ، اختناق وحدة المعالجة المركزية بسبب مشاكل التبريد ، التحميل الزائد ، إلخ ، تباطؤ القرص بسبب المشاكل التقنية. </li></ol><br><p style=";text-align:right;direction:rtl">  وهذه ليست بأي حال قائمة حصرية بالمشكلات التي يمكن أن تبطئ المعالجات. </p><br><p style=";text-align:right;direction:rtl">  وبناء على ذلك ، فإن التباطؤ هو أمر يجب على المرء أن يعيش معه.  في بعض الأحيان لا تكون هذه مشكلة خطيرة ، وأحيانًا يكون من المهم للغاية الحفاظ على سرعة معالجة عالية على الرغم من الفشل أو التباطؤ. </p><br><p style=";text-align:right;direction:rtl">  على الفور تنشأ فكرة ازدواجية الأنظمة: فلنركض لدفق واحد ونفس البيانات ليس معالجًا واحدًا بل معالجين في وقت واحد ، أو حتى ثلاثة.  المشكلة هنا هي أنه في هذه الحالة ، يمكن أن يحدث سلوك النظام المكرر وغير المتناسق بسهولة.  عادةً ، لم يتم تصميم أطر العمل لهذا السلوك وتشير إلى أن عدد المعالجات في أي وقت معين لا يتجاوز واحد.  الأنظمة التي تسمح بالازدواجية الموصوفة للتنفيذ تسمى <em>متزامنة مرة واحدة بالضبط</em> . </p><br><p style=";text-align:right;direction:rtl">  تتيح لك هذه البنية حل العديد من المشاكل في وقت واحد: </p><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  السلوك غير الآمن: إذا سقطت إحدى العقد ، تستمر الأخرى ببساطة في العمل كما لو لم يحدث شيء.  ليست هناك حاجة لتنسيق إضافي ، مثل  يتم تنفيذ المعالج الثاني بغض النظر عن حالة الأول. </li><li style=";text-align:right;direction:rtl">  إزالة الصدمات: كل من قدم النتيجة جيدًا بالنسبة له.  والآخر سيكون عليه فقط اختيار دولة جديدة والاستمرار من هذه اللحظة. </li></ol><br><p style=";text-align:right;direction:rtl">  هذا النهج ، على وجه الخصوص ، يسمح لك بإكمال عملية حسابية صعبة وصعبة لفترة أطول يمكن التنبؤ بها ، لأنه  احتمالية أن يصبح كلاهما غبيًا وسقوطًا أقل بشكل ملحوظ. </p><br><h3 id="veroyatnostnaya-ocenka" style=";text-align:right;direction:rtl">  تقييم الاحتمالات </h3><br><p style=";text-align:right;direction:rtl">  دعونا نحاول تقييم فوائد ازدواجية الأداء.  افترض أن شيئًا ما يحدث في المتوسط ​​كل يوم مع المعالج: إما أن يكون GC قد تضاءل ، أو أن العقدة تكذب ، أو أن الحاويات أصبحت سرطانية.  افترض أيضًا أننا نقوم بإعداد حزم البيانات في 10 ثوانٍ. </p><br><p style=";text-align:right;direction:rtl">  ثم يكون احتمال حدوث شيء ما أثناء إنشاء العبوة هو <code>10 / (24 · 3600) ≃ 1e-4</code> . </p><br><p style=";text-align:right;direction:rtl">  إذا قمت بتشغيل معالجين بالتوازي ، فإن احتمال أن كلا <code>≃ 1e-8</code> هو <code>≃ 1e-8</code> .  لذا سيأتي هذا الحدث في غضون 23 عامًا!  نعم ، الأنظمة لا تعيش كثيرًا ، مما يعني أن هذا لن يحدث أبدًا! </p><br><p style=";text-align:right;direction:rtl">  علاوة على ذلك ، إذا كان وقت تحضير العبوة أقصر و / أو سيحدث انخفاض أقل في كثير من الأحيان ، فإن هذا الرقم سيزداد فقط. </p><br><p style=";text-align:right;direction:rtl">  وبالتالي ، نستنتج أن النهج قيد النظر يزيد بشكل كبير من موثوقية نظامنا بأكمله.  يبقى فقط لحل سؤال صغير مثل هذا: أين تقرأ حول كيفية إنشاء نظام <em>متزامن مرة واحدة بالضبط</em> .  والجواب بسيط: عليك أن تقرأ هنا. </p><br><h2 id="polutranzakcii" style=";text-align:right;direction:rtl">  نصف معاملة </h2><br><p style=";text-align:right;direction:rtl">  لمزيد من المناقشة ، نحن بحاجة إلى مفهوم <em>نصف الصفقة</em> .  أسهل طريقة لتفسير ذلك هي من خلال مثال. </p><br><p style=";text-align:right;direction:rtl">  فكر في تحويل الأموال من حساب مصرفي إلى آخر.  يمكن وصف النهج التقليدي باستخدام المعاملات بلغة Pseco كما يلي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="hljs pgsql">transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): tx = db.begin_transaction() amount_from = tx.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.insufficient_funds tx.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount_from - amount) tx.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, tx.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) + amount) tx.<span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok</code> </pre> <br><p style=";text-align:right;direction:rtl">  ولكن ماذا لو لم تكن هذه المعاملات متاحة لنا؟  باستخدام الأقفال ، يمكن القيام بذلك على النحو التالي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="hljs pgsql">transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): #         lock_from = db.<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) lock_to = db.<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) amount_from = db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.insufficient_funds db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount_from - amount) db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) + amount) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok</code> </pre> <br><p style=";text-align:right;direction:rtl">  هذا النهج يمكن أن يؤدي إلى طريق مسدود ، كما  يمكن أخذ الأقفال بتسلسل مختلف بالتوازي.  لتصحيح هذا السلوك ، يكفي تقديم وظيفة تأخذ في الوقت نفسه عدة أقفال في تسلسل حاسم (على سبيل المثال ، فرز حسب المفاتيح) ، مما يلغي تمامًا الجمود المحتمل. </p><br><p style=";text-align:right;direction:rtl">  ومع ذلك ، يمكن تبسيط التنفيذ إلى حد ما: </p><br><pre style=";text-align:right;direction:rtl"> <code class="hljs vbscript">transfer(from, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): lock_from = db.lock(from) amount_from = db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(from) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: return <span class="hljs-keyword"><span class="hljs-keyword">error</span></span>.insufficient_funds db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(from, amount_from - amount) lock_from.release() #   , # .. db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>...)     lock_to = db.lock(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) + amount) return ok</code> </pre> <br><p style=";text-align:right;direction:rtl">  هذا النهج يجعل أيضًا الحالة النهائية متسقة ، مع الحفاظ على الثوابت بنوع منع الإنفاق المفرط للأموال.  الفرق الرئيسي عن النهج السابق هو أنه في مثل هذا التنفيذ لدينا فترة زمنية معينة تكون فيها الحسابات في حالة غير متناسقة.  وهي مثل هذه العملية تعني أن الحالة الإجمالية للأموال في الحسابات لا تتغير.  في هذه الحالة ، هناك فجوة زمنية بين <code>lock_from.release()</code> و <code>db.lock(to)</code> ، قد تعطي قاعدة البيانات خلالها قيمة غير متناسقة: قد يختلف المبلغ الإجمالي عن المبلغ الصحيح إلى الأسفل. </p><br><p style=";text-align:right;direction:rtl">  في الواقع ، قمنا بتقسيم معاملة واحدة لتحويل الأموال إلى نصفين من المعاملات: </p><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  تقوم النصف الأول من المعاملة بعمل شيك وخصم المبلغ الضروري من الحساب. </li><li style=";text-align:right;direction:rtl">  النصف الثاني من المعاملة يكتب المبلغ المسحوب إلى حساب آخر. </li></ol><br><p style=";text-align:right;direction:rtl">  من الواضح أن تقسيم المعاملة إلى معاملات أصغر ، بشكل عام ، ينتهك سلوك المعاملات.  والمثال أعلاه ليس استثناء.  ومع ذلك ، إذا تم تحقيق جميع المعاملات النصف في السلسلة بالكامل ، فستكون النتيجة متسقة مع جميع الثوابت المحفوظة.  هذا هو بالضبط ما هو خاصية مهمة لسلسلة نصف المعاملات. </p><br><p style=";text-align:right;direction:rtl">  نفقد بعض الاتساق مؤقتًا ، ومع ذلك نكتسب ميزة أخرى مفيدة: استقلالية العمليات ، ونتيجة لذلك ، قابلية التوسع الأفضل.  يتجلى الاستقلال في حقيقة أن نصف المعاملة في كل مرة تعمل مع سطر واحد فقط ، وهي قراءة بياناتها والتحقق منها وتغييرها ، دون الاتصال ببيانات أخرى.  وبالتالي ، يمكنك خلط قاعدة بيانات تعمل مع جزء واحد فقط.  علاوة على ذلك ، يمكن استخدام هذا النهج في حالة المستودعات غير المتجانسة ، أي  يمكن أن تبدأ نصف المعاملات على نوع واحد من التخزين ، وتنتهي على نوع آخر.  إنها خصائص مفيدة سيتم استخدامها في المستقبل. </p><br><p style=";text-align:right;direction:rtl">  يطرح سؤال شرعي: كيفية تطبيق نصف الغيبوبة في الأنظمة الموزعة وليس أشعل النار؟  لحل هذه المشكلة ، تحتاج إلى النظر في نهج عدم القفل. </p><br><h2 id="lock-free" style=";text-align:right;direction:rtl">  بدون قفل </h2><br><p style=";text-align:right;direction:rtl">  كما تعلم ، تعمل المناهج الخالية من القفل أحيانًا على تحسين أداء الأنظمة متعددة الخيوط ، خاصة في حالة الوصول التنافسي إلى المورد.  ومع ذلك ، ليس من الواضح تمامًا أن مثل هذا النهج يمكن استخدامه في الأنظمة الموزعة.  دعونا نتعمق بعمق وننظر في ما هو بدون قفل ولماذا ستكون هذه الخاصية مفيدة في حل مشكلتنا. </p><br><p style=";text-align:right;direction:rtl">  في بعض الأحيان لا يفهم بعض المطورين تمامًا ما هو قفل مجاني.  تشير النظرة الضيقة إلى أن هذا أمر يتعلق بتعليمات المعالج الذري.  من المهم أن نفهم هنا أن القفل الحر يعني استخدام "الذرات" ، والعكس غير صحيح ، أي  ليس كل "الذرات" تعطي سلوكًا بدون قفل. </p><br><p style=";text-align:right;direction:rtl">  من الخصائص المهمة للخوارزمية الخالية من القفل هي أن مؤشر ترابط واحد على الأقل يحقق تقدمًا في النظام.  ولكن لسبب ما ، يعزو الكثيرون هذه الخاصية إلى تعريف (هذا تعريف صريح يمكن العثور عليه ، على سبيل المثال ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">على ويكيبيديا</a> ).  هنا من الضروري إضافة فارق بسيط واحد مهم: يتم إحراز تقدم حتى في حالة هشاشة موضوع واحد أو أكثر.  هذه نقطة حرجة للغاية يتم تجاهلها غالبًا ولها آثار خطيرة على النظام الموزع. </p><br><p style=";text-align:right;direction:rtl">  لماذا ينفي غياب شرط التقدم لخيوط واحد على الأقل مفهوم الخوارزمية الخالية من القفل؟  والحقيقة هي أنه في هذه الحالة سيكون spinlock المعتاد أيضًا بدون قفل.  في الواقع ، الشخص الذي أخذ القفل سيحرز تقدمًا.  هل هناك خيط مع التقدم =&gt; بدون قفل؟ </p><br><p style=";text-align:right;direction:rtl">  من الواضح أن الإقفال يعني بدون أقفال ، بينما يشير spinlock باسمه إلى أن هذا قفل حقيقي.  هذا هو السبب في أنه من المهم إضافة شرط على التقدم حتى في حالة التصدعات.  بعد كل شيء ، يمكن أن تستمر هذه التأخيرات إلى أجل غير مسمى ، لأنه  لا يقول التعريف شيئًا عن الحد الزمني العلوي.  وإذا كان الأمر كذلك ، فإن مثل هذه التأخيرات ستكون معادلة إلى حد ما لإيقاف التدفقات.  في هذه الحالة ، ستنتج الخوارزميات الخالية من القفل تقدمًا في هذه الحالة. </p><br><p style=";text-align:right;direction:rtl">  ولكن من قال إن المقاربات الخالية من القفل تنطبق حصريًا على الأنظمة متعددة الخيوط؟  استبدال خيوط في نفس العملية على نفس العقدة مع العمليات على العقد المختلفة ، والذاكرة المشتركة للخيوط مع التخزين الموزع المشترك ، نحصل على خوارزمية موزعة بدون قفل. </p><br><p style=";text-align:right;direction:rtl">  انخفاض العقدة في مثل هذا النظام يعادل التأخير في تنفيذ مؤشر ترابط لبعض الوقت ، لأنه  حان الوقت لاستعادة العمل.  في الوقت نفسه ، يسمح نهج عدم القفل للمشاركين الآخرين في النظام الموزع بمواصلة العمل.  علاوة على ذلك ، يمكن تشغيل خوارزميات خاصة خالية من القفل بالتوازي مع بعضها البعض ، للكشف عن تغيير تنافسي واستبعاد التكرارات. </p><br><p style=";text-align:right;direction:rtl">  يشير النهج الذي <em>يتم استخدامه مرة واحدة بالضبط</em> إلى وجود تخزين موزع متناسق.  مثل هذه المخازن كقاعدة تمثل جدول قيمة رئيسية ثابتًا ضخمًا.  العمليات المحتملة: <code>set</code> ، <code>get</code> ، <code>del</code> .  ومع ذلك ، يلزم إجراء عملية أكثر تعقيدًا للنهج بدون قفل: CAS أو مقارنة ومبادلة.  دعونا نفكر بمزيد من التفصيل في هذه العملية ، وإمكانيات استخدامها ، وكذلك النتائج التي تعطيها. </p><br><h3 id="cas" style=";text-align:right;direction:rtl">  كاس </h3><br><p style=";text-align:right;direction:rtl">  CAS أو مقارنة ومبادلة هي بدائية المزامنة الرئيسية والمهمة لخوارزميات بدون قفل وخالية من الانتظار.  يمكن توضيح جوهره من خلال Pseco التالي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="hljs kotlin">CAS(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected, new): # ,   atomic,   atomic: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() != expected: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(new) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  في بعض الأحيان ، من أجل التحسين ، لا يعودون <code>true</code> أو <code>false</code> ، ولكن القيمة السابقة ، لأن  في كثير من الأحيان يتم تنفيذ هذه العمليات في حلقة ، وللحصول على القيمة <code>expected</code> ، يجب عليك أولاً قراءتها: </p><br><pre style=";text-align:right;direction:rtl"> <code class="hljs vala">CAS_optimized(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>): # ,   atomic,   atomic: current = <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current == expected: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current #  CAS   CAS_optimized CAS(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.CAS_optimized(expected, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>) == expected</code> </pre> <br><p style=";text-align:right;direction:rtl">  يمكن أن يوفر هذا النهج قراءة واحدة.  كجزء من مراجعتنا ، سنستخدم شكلًا بسيطًا من <code>CAS</code> ، لأنه  إذا رغبت في ذلك ، يمكن إجراء هذا التحسين بشكل مستقل. </p><br><p style=";text-align:right;direction:rtl">  في حالة الأنظمة الموزعة ، يتم إصدار كل تغيير.  على سبيل المثال  أولاً نقرأ القيمة من المتجر ، نحصل على الإصدار الحالي من البيانات.  ثم نحاول الكتابة ، متوقعين أن إصدار البيانات لم يتغير.  في هذه الحالة ، تزداد النسخة في كل مرة يتم فيها تحديث البيانات: </p><br><pre style=";text-align:right;direction:rtl"> <code class="hljs cs">CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected_version, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>): atomic: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.get_version() != expected_version: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>, expected_version + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  يسمح لك هذا النهج بالتحكم بشكل أكثر دقة في تحديث القيم ، وتجنب <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مشكلة ABA</a> .  على وجه الخصوص ، يدعم الإصدار Etcd و Zookeeper. </p><br><p style=";text-align:right;direction:rtl">  لاحظ الخاصية الهامة التي <code>CAS_versioned</code> استخدام عمليات <code>CAS_versioned</code> .  والحقيقة هي أنه يمكن تكرار مثل هذه العملية دون المساس بالمنطق المتفوق.  في البرمجة متعددة الخيوط ، هذه الخاصية ليس لها قيمة خاصة ، لأن  هناك ، إذا فشلت العملية ، فنحن على يقين من أنها لم تنطبق.  في حالة النظم الموزعة ، تم انتهاك هذا الثابت ، لأنه  قد يصل الطلب إلى المستلم ، ولكن الاستجابة الناجحة لم تعد موجودة.  لذلك ، من المهم أن تكون قادرًا على إعادة إرسال الطلبات دون خوف من كسر ثوابت المنطق رفيع المستوى. </p><br><p style=";text-align:right;direction:rtl">  هذه هي الخاصية التي <code>CAS_versioned</code> عملية <code>CAS_versioned</code> .  في الواقع ، يمكن تكرار هذه العملية إلى ما لا نهاية حتى يتم إرجاع الاستجابة الحقيقية من المستلم.  وهو بدوره يلقي فئة كاملة من الأخطاء المتعلقة بتفاعل الشبكة. </p><br><h3 id="primer" style=";text-align:right;direction:rtl">  مثال </h3><br><p style=";text-align:right;direction:rtl">  دعونا نلقي نظرة على كيفية <code>CAS_versioned</code> ونصف المعاملات ، من حساب إلى آخر ، والتي تنتمي ، على سبيل المثال ، إلى نسخ مختلفة من Etcd.  هنا ، أفترض أن الدالة <code>CAS_versioned</code> قد تم تنفيذها وفقًا لذلك بناءً على واجهة برمجة التطبيقات المقدمة. </p><br><pre style=";text-align:right;direction:rtl"> <code class="hljs pgsql">withdraw(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount): # CAS- <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #     version_from, amount_from = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.insufficient_funds <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.CAS_versioned(version_from, amount_from - amount): break <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok deposit(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): # CAS- <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: version_to, amount_to = <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.CAS_versioned(version_to, amount_to + amount): break <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): #   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> withdraw(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ok: #     , #    deposit(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount)</code> </pre> <br><p style=";text-align:right;direction:rtl">  قمنا هنا بتقسيم عمليتنا إلى نصف المعاملات ، وننفذ كل معاملة نصف من خلال عملية <code>CAS_versioned</code> .  يسمح لك هذا النهج بالعمل بشكل مستقل مع كل حساب ، مما يسمح باستخدام التخزين غير المتجانسة غير المرتبط ببعضه البعض.  المشكلة الوحيدة التي تنتظرنا هنا هي خسارة المال في حالة حدوث انخفاض في العملية الحالية في الفترة الفاصلة بين نصف المعاملات. </p><br><h2 id="ochered" style=";text-align:right;direction:rtl">  قائمة الانتظار </h2><br><p style=";text-align:right;direction:rtl">  للمضي قدمًا ، تحتاج إلى تنفيذ قائمة انتظار الأحداث.  تكمن الفكرة في أنه بالنسبة للمعالجين للتواصل مع بعضهم البعض ، يجب أن يكون لديك قائمة انتظار رسائل مرتبة لا يتم فيها فقد البيانات أو تكرارها.  وبناءً على ذلك ، سيتم بناء جميع التفاعلات في سلسلة المعالجات على هذا البدائي.  كما أنها أداة مفيدة لتحليل وتدقيق تدفقات البيانات الواردة والصادرة.  بالإضافة إلى ذلك ، يمكن أيضًا إجراء طفرات في حالة المعالجات من خلال قائمة الانتظار. </p><br><p style=";text-align:right;direction:rtl">  ستتألف قائمة الانتظار من زوج من العمليات: </p><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  أضف رسالة إلى نهاية قائمة الانتظار. </li><li style=";text-align:right;direction:rtl">  استقبال رسالة من الصف في الفهرس المحدد. </li></ol><br><p style=";text-align:right;direction:rtl">  في هذا السياق ، لا أفكر في إزالة الرسائل من قائمة الانتظار لعدة أسباب: </p><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يمكن لعدة معالجات القراءة من قائمة الانتظار نفسها.  ستكون إزالة التزامن مهمة غير تافهة ، على الرغم من أنها ليست مستحيلة. </li><li style=";text-align:right;direction:rtl">  من المفيد الاحتفاظ بقائمة انتظار لفترة طويلة نسبيًا (يوم أو أسبوع) لتصحيح الأخطاء والتدقيق.  من الصعب المبالغة في فائدة هذه الخاصية. </li><li style=";text-align:right;direction:rtl">  يمكنك حذف العناصر القديمة إما في الموعد المحدد أو عن طريق تعيين TTL على عناصر قائمة الانتظار.  من المهم التأكد من أن المعالجات تمكنت من معالجة البيانات قبل وصول المكنسة وتنظيف كل شيء.  إذا كان وقت المعالجة بترتيب الثواني ، و TTL لترتيب الأيام ، فيجب ألا يحدث أي شيء من هذا. </li></ol><br><p style=";text-align:right;direction:rtl">  لتخزين العناصر وتنفيذ الإضافة بشكل فعال ، نحتاج إلى: </p><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  القيمة مع الفهرس الحالي.  يشير هذا الفهرس إلى نهاية قائمة الانتظار لإضافة عناصر. </li><li style=";text-align:right;direction:rtl">  ,    . </li></ol><br><h3 id="kak-by-lock-free-ochered" style=";text-align:right;direction:rtl">   lock-free  </h3><br><p style=";text-align:right;direction:rtl">          :        .        : </p><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">    CAS     . </li><li style=";text-align:right;direction:rtl">       . </li></ol><br><p style=";text-align:right;direction:rtl">    ,    ,     . </p><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> <strong>    lock-free</strong> .  ,      ,          . Lock-free? !   ,    2 :   .         lock-free,     — !    ,  ,        ,   .              .         , ..            ,     . </li><li style=";text-align:right;direction:rtl"> <strong>    </strong> .         ,               .    . </li></ol><br><p style=";text-align:right;direction:rtl">  ,    lock-free         . </p><br><h3 id="lock-free-realizaciya-dobavleniya" style=";text-align:right;direction:rtl"> Lock-free   </h3><br><p style=";text-align:right;direction:rtl"> ,  ,     :   , ..      ,    : </p><br><pre style=";text-align:right;direction:rtl"> <code class="hljs pgsql">push(queue, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): #      <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = queue.get_current_index() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #  ,    #    var = queue.at(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) #  = <span class="hljs-number"><span class="hljs-number">0</span></span>   , ..   # ,         <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> var.CAS_versioned(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): #   ,    queue.update_index(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) break #   , .   <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = max(queue.get_current_index(), <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) update_index(queue, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #     cur_index, version = queue.get_current_index_versioned() #      , #  , .   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cur_index &gt;= <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>: # -     , #        break <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> queue.current_index_var().CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): #      ,   break # -  . # ,      ,  </code> </pre> <br><p style=";text-align:right;direction:rtl">      .   ,            (     — ,  ,     ).       lock-free   .    ? </p><br><p style=";text-align:right;direction:rtl">   ,   <code>push</code>     ,      ! ,             ,      . </p><br><p style=";text-align:right;direction:rtl">        .       :         .   ,      -   ,  -               .  ,      , ..      .          .        ?       , ..     ,    ,        . </p><br><p style=";text-align:right;direction:rtl">  ,       ,          . ..    .        ,    ,     .          ,       . </p><br><p style=";text-align:right;direction:rtl">  ,       .               ,   .    ,   ,     .       ,    . </p><br><h2 id="vzaimodeystvie-ocheredey" style=";text-align:right;direction:rtl">   </h2><br><p style=";text-align:right;direction:rtl">  ,  ,   ,      . </p><br><p style=";text-align:right;direction:rtl"> <em></em> .       . </p><br><p style=";text-align:right;direction:rtl">    ,      : </p><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  , ..  stateless. </li><li style=";text-align:right;direction:rtl">  ,     — . </li></ol><br><p style=";text-align:right;direction:rtl"> ,    ,        <em>concurrent exactly-once</em> . </p><br><p style=";text-align:right;direction:rtl">        : </p><br><pre style=";text-align:right;direction:rtl"> <code class="hljs pgsql">handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output): <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) output.push(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">   .        : </p><br><pre style=";text-align:right;direction:rtl"> <code class="hljs pgsql">handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output, state): #   <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = state.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) output.push(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span> #   state.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>)</code> </pre> <br><p style=";text-align:right;direction:rtl">     <em>exactly-once</em> .   ,           ,    ,    . </p><br><p style=";text-align:right;direction:rtl">    <em>exactly-once</em> ,     ,    . ..,  ,       ,       ,   ,    —      : </p><br><pre style=";text-align:right;direction:rtl"> <code class="hljs pgsql">#       get_next_index(queue): <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = queue.get_index() #     <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> queue.has(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): #    queue.push <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = max(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>, queue.get_index()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> #      . #  <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>    push_at(queue, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): var = queue.at(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> var.CAS_versioned(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): #   queue.update_index(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output, state): #   #    {PREPARING, <span class="hljs-number"><span class="hljs-number">0</span></span>} fsm_state = state.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: switch fsm_state: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {PREPARING, input_index}: #   :   , #        output_index = output.get_next_index() fsm_state = {WRITING, input_index, output_index} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {WRITING, input_index, output_index}: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(input_index) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output.push_at(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, output_index): #  ,     input_index += <span class="hljs-number"><span class="hljs-number">1</span></span> #    ,  push_at  <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, #        fsm_state = {PREPARING, input_index} state.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(fsm_state)</code> </pre> <br><p style=";text-align:right;direction:rtl">        <code>push_at</code> ?      ,   .   ,    ,  ,    .   ,               .             .          -  ,     lock-free . </p><br><p style=";text-align:right;direction:rtl">  ,      : </p><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">   :       . </li><li style=";text-align:right;direction:rtl"> ,  :      . </li></ol><br><p style=";text-align:right;direction:rtl">   :   <em>concurrent</em>  <em>exactly-once</em> . </p><br><p style=";text-align:right;direction:rtl">      ?   : </p><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">       ,         ,   <code>push_at</code>     false.            . </li><li style=";text-align:right;direction:rtl">       ,      . ,   ,       . </li></ol><br><p style=";text-align:right;direction:rtl">     <em>concurrent exactly-once</em>   ?   ,     ,            .    ,           .            . </p><br><p style=";text-align:right;direction:rtl">          : </p><br><pre style=";text-align:right;direction:rtl"> <code class="hljs pgsql">#     ,  ,     # ..       <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, #      <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>. #       <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> push_at_idempotent(queue, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> queue.push_at(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> queue.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output, state): <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: switch fsm_state: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {PREPARING, input_index}: #   ,   , #        output_index = output.get_next_index() fsm_state = {WRITING, input_index, output_index} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {WRITING, input_index, output_index}: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(input_index) #   , #       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output.push_at_idempotent(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, output_index): input_index += <span class="hljs-number"><span class="hljs-number">1</span></span> fsm_state = {PREPARING, input_index} #     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state.CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state): <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: #   ,    <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned()</code> </pre> <br><p style=";text-align:right;direction:rtl">  : </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/rx/qi/ub/rxqiubplbrrdlokp_sniqhktmvu.png" alt="بسيط"></p><br><p style=";text-align:right;direction:rtl">     ,     .     ,           . </p><br><p style=";text-align:right;direction:rtl">             kernel panic,   ,    ..              .              .       :      ,    .  ,        . </p><br><p style=";text-align:right;direction:rtl">  ,    <strong> </strong>    ,    . </p><br><h2 id="reshenie-nachalnoy-zadachi" style=";text-align:right;direction:rtl">    </h2><br><p style=";text-align:right;direction:rtl">        :    . </p><br><p style=";text-align:right;direction:rtl">       :  ,     ,    ,      ,      : </p><br><pre style=";text-align:right;direction:rtl"> <code class="hljs pgsql">#  : # - input_queues -   # - output_queues -   # - state -    # - <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span> -    : state, inputs -&gt; state, outputs handle(input_queues, output_queues, state, <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>): #        <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: switch fsm_state: # input_indexes       <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {HANDLING, user_state, input_indexes}: #       inputs = [queue.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> queue, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> zip(input_queues, input_indexes)] #   ,    next_indexes = next(inputs, input_indexes) #    #     user_state, outputs = <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>(user_state, inputs) #      , #     fsm_state = {PREPARING, user_state, next_indexes, outputs, <span class="hljs-number"><span class="hljs-number">0</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {PREPARING, user_state, input_indexes, outputs, output_pos}: #  ,      #    output_index = output_queues[output_pos].get_next_index() #     fsm_state = { WRITING, user_state, input_indexes, outputs, output_pos, output_index } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> { WRITING, user_state, input_indexes, outputs, output_pos, output_index }: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = outputs[output_pos] #       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output_queues[output_pos].push_at_idempotent( <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, output_index ): #  ,      output_pos += <span class="hljs-number"><span class="hljs-number">1</span></span> #    ,      PREPARING. #     #     fsm_state = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output_pos == len(outputs): #   , #       {HANDLING, user_state, input_indexes} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: #       #   , #         {PREPARING, user_state, input_indexes, outputs, output_pos} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state.CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state): <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: #   ,    <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned()</code> </pre> <br><p style=";text-align:right;direction:rtl">     : </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/fe/mk/bg/femkbgvjaxyy2gi9ye5wkaufqf4.png" alt="نهائي"></p><br><p style=";text-align:right;direction:rtl">      : <code>HANDLING</code> .        , ..,  ,     .  ,      .    ,   <code>PREPARING</code>  <code>WRITING</code>   ,         .     ,      <code>HANDLING</code> . </p><br><p style=";text-align:right;direction:rtl">  ,      ,       ,          .   ,           .  ,            . </p><br><p style=";text-align:right;direction:rtl">      .         .               . </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/or/qk/tg/orqktgqgrdw-9tv0_wkl2wt_rye.png" alt="نهائي"></p><br><p style=";text-align:right;direction:rtl">   : </p><br><pre style=";text-align:right;direction:rtl"> <code class="hljs cpp">my_handler(state, inputs): #      state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.push(inputs) #    duration state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.trim_time_window(duration) #   avg = state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.avg() need_update_counter = state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.size() &gt; size_boundary <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state, [ avg, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> need_update_counter: <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: # none      none ]</code> </pre> <br><p style=";text-align:right;direction:rtl">  ,      ,           <em>concurrent exactly-once</em>     <code>handle</code> . </p><br><p style=";text-align:right;direction:rtl">        : </p><br><pre style=";text-align:right;direction:rtl"> <code class="hljs pgsql">handle_db(input_queue, db): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #      tx = db.begin_transaction() #     . #      , #      <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = tx.get_current_index() #    tx.write_current_index(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) #      <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = intput_queue.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: #    tx.increment_counter() tx.<span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>() #   ,      , #          </code> </pre> <br><p style=";text-align:right;direction:rtl">    .  لأن       ,         , , ,    <em>concurrent exactly-once</em> .       . </p><br><h2 id="za-bortom" style=";text-align:right;direction:rtl">   </h2><br><p style=";text-align:right;direction:rtl">   —            .        ,      ,     . </p><br><h3 id="optimizacii-dlya-konkretnogo-hranilischa" style=";text-align:right;direction:rtl">     </h3><br><p style=";text-align:right;direction:rtl">      ,      ,       .           ,  ,          . </p><br><h3 id="asinhronnaya-publikaciya" style=";text-align:right;direction:rtl">   </h3><br><p style=";text-align:right;direction:rtl">           .    ,     .  لأن        ,      .              .        . </p><br><h3 id="gruppirovka-znacheniy" style=";text-align:right;direction:rtl">   </h3><br><p style=";text-align:right;direction:rtl">        —   . ,       ,     .    ,     -  ,   ,    .        , .. ,    ,        . </p><br><h3 id="dvoynoe-shardirovanie" style=";text-align:right;direction:rtl">   </h3><br><p style=";text-align:right;direction:rtl">       .   ,     ,           .            ,    ,    . </p><br><h2 id="fundamentalnost-podhoda" style=";text-align:right;direction:rtl">   </h2><br><p style=";text-align:right;direction:rtl">     . ,         .  :          ,      .     ,       . </p><br><p style=";text-align:right;direction:rtl">      ,   ,      : </p><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">    ,   .          . </li><li style=";text-align:right;direction:rtl">     .      ,        . </li><li style=";text-align:right;direction:rtl">          .    ,       .      ,   ,        . ..          .     :    . </li></ol><br><p style=";text-align:right;direction:rtl">     , , -,     ,  -,     . </p><br><p style=";text-align:right;direction:rtl">     ,     .     : </p><br><pre style=";text-align:right;direction:rtl"> <code class="hljs pgsql">transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): #   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> withdraw(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ok: #     , #    deposit(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount)</code> </pre> <br><p style=";text-align:right;direction:rtl">  <code>withdraw</code>     ,   ,  <code>deposit</code>    :      ?    <code>deposit</code>  -     (,   ,       ),    .  ,    ,    ,   ,        ?    ,   ,      - ,     . </p><br><p style=";text-align:right;direction:rtl">     ,   ,   ,     . ,     ,   ,   .   ,     .   ,       ,       .  لأن     ,       ,        .      ,        :     ,     —  . </p><br><h3 id="dvuhfaznost-bez-blokirovok" style=";text-align:right;direction:rtl">    </h3><br><p style=";text-align:right;direction:rtl">      ,       . </p><br><p style=";text-align:right;direction:rtl">      :        ,  ,     ,   ,   .   ,        -  : </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> <em></em> .            ,   , ,     ,     . </li><li style=";text-align:right;direction:rtl"> <em></em> .        . </li></ul><br><p style=";text-align:right;direction:rtl">     , , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="></a> . </p><br><p style=";text-align:right;direction:rtl"> ,        , ..       ,      ,  .        ,       . </p><br><p style=";text-align:right;direction:rtl">          :     lock-free   ,           .            , ..      ,  . </p><br><p style=";text-align:right;direction:rtl">      CAS       . ,      : </p><br><pre style=";text-align:right;direction:rtl"> <code class="hljs swift">#     ,    handle(input, output, state): # ... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> fsm_state: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {<span class="hljs-type"><span class="hljs-type">HANDLING</span></span>, ...}: #      fsm_state = {<span class="hljs-type"><span class="hljs-type">PREPARING</span></span>, ...} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {<span class="hljs-type"><span class="hljs-type">PREPARING</span></span>, input_index}: #   ... output_index = ...get_next_index() fsm_state = {<span class="hljs-type"><span class="hljs-type">WRITING</span></span>, output_index, ...} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {<span class="hljs-type"><span class="hljs-type">WRITING</span></span>, output_index, ...}: #  ,  output_index</code> </pre> <br><p style=";text-align:right;direction:rtl">  ,     .          .      : </p><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> <strong>PREPARING</strong> .     ,        . </li><li style=";text-align:right;direction:rtl"> <strong>WRITING</strong> .     .       ,       <strong>PREPARING</strong> . </li></ol><br><p style=";text-align:right;direction:rtl">     ,      . ,          ,     —    .     : </p><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">         .  ,    , ..     ,      . </li><li style=";text-align:right;direction:rtl">            , ..       .         ,     . </li></ol><br><p style=";text-align:right;direction:rtl">  ,  lock-free        ,        ,     . </p><br><h2 id="trebovaniya-k-konsistentnosti" style=";text-align:right;direction:rtl">    </h2><br><p style=";text-align:right;direction:rtl">  ,     .     ,      <em>Stale Read</em> ,       .   —       CAS:              .       : </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> <em>Distributed single register</em> —       (, etcd  Zookeeper): <br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> Linearizability </li><li style=";text-align:right;direction:rtl"> Sequential consistency </li></ol></li><li style=";text-align:right;direction:rtl"> <em>Transactional</em> —     (, MySQL, PostgreSQL  ..): <br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> Serializability </li><li style=";text-align:right;direction:rtl"> Snapshot Isolation </li><li style=";text-align:right;direction:rtl"> Repeatable Read </li><li style=";text-align:right;direction:rtl"> Read Committed </li></ol></li><li style=";text-align:right;direction:rtl"> <em>Distributed Transactional</em> — NewSQL : <br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> Strict Consistency </li><li style=";text-align:right;direction:rtl">    </li></ol></li></ul><br><p style=";text-align:right;direction:rtl">   :             ?   ,  ,   .         ,    ,     CAS                .        , ,   <em>Read My Writes</em> . </p><br><h2 id="zaklyuchenie" style=";text-align:right;direction:rtl">  الخلاصة </h2><br><p style=";text-align:right;direction:rtl">        <em>exactly-once</em> .     , ..  ,  ,    ,    .       ,      ,  , , ..        ,     . </p><br><p style=";text-align:right;direction:rtl">       lock-free       . </p><br><p style=";text-align:right;direction:rtl">    : </p><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> <strong></strong> :      . </li><li style=";text-align:right;direction:rtl"> <strong></strong> :       . </li><li style=";text-align:right;direction:rtl"> <strong></strong> :        : <em>exactly-once</em> . </li><li style=";text-align:right;direction:rtl"> <strong>Concurrent</strong> :       . </li><li style=";text-align:right;direction:rtl"> <strong>Real-time</strong> :     . </li><li style=";text-align:right;direction:rtl"> <strong>Lock-free</strong> :      ,     . </li><li style=";text-align:right;direction:rtl"> <strong>Deadlock free</strong> :      ,      . </li><li style=";text-align:right;direction:rtl"> <strong>Race condition free</strong> :     . </li><li style=";text-align:right;direction:rtl"> <strong>Hot-hot</strong> :        . </li><li style=";text-align:right;direction:rtl"> <strong>Hard stop</strong> :       . </li><li style=";text-align:right;direction:rtl"> <strong>No failover</strong> :                  . </li><li style=";text-align:right;direction:rtl"> <strong>No downtime</strong> :    . </li><li style=";text-align:right;direction:rtl"> <strong> </strong> :   ,    . </li><li style=";text-align:right;direction:rtl"> <strong></strong> :         . </li><li style=";text-align:right;direction:rtl"> <strong></strong> :         . </li><li style=";text-align:right;direction:rtl"> <strong></strong> :        . </li></ol><br><p style=";text-align:right;direction:rtl">  ,        .  لكن هذه قصة أخرى. </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/ku/4j/nf/ku4jnf9-1pkdjfh_peshj0xd73w.jpeg" alt="خفيف"></p><br><h2 id="novye-terminy" style=";text-align:right;direction:rtl">   </h2><br><p style=";text-align:right;direction:rtl">       : </p><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> Concurrent exactly-once. </li><li style=";text-align:right;direction:rtl"> Semi-transactions  . </li><li style=";text-align:right;direction:rtl"> Lock-free two-phase commit,       . </li></ol><br><h2 id="zadachi-dlya-samoistyazaniya" style=";text-align:right;direction:rtl">    </h2><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">     . </li><li style=";text-align:right;direction:rtl">  lock-free       . </li><li style=";text-align:right;direction:rtl">    . </li></ol><br><h2 id="literatura" style=";text-align:right;direction:rtl">  الأدب </h2><br><p style=";text-align:right;direction:rtl"> [1] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">:  ABA.</a> <br> [2] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Blog: You Cannot Have Exactly-Once Delivery</a> <br> [3] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">:         .</a> <br> [4] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">:  3:  .</a> <br> [5] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">:  .</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar413817/">https://habr.com/ru/post/ar413817/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar413807/index.html">تحديد الخصائص الباليستية الزمنية لحركة مركز كتلة الهبوط المظلي من طائرة</a></li>
<li><a href="../ar413809/index.html">جهاز فك التشفير والتجارب مع Android في حاوية LXC</a></li>
<li><a href="../ar413811/index.html">ملخص المواد الطازجة من عالم الواجهة الأمامية للأسبوع الماضي رقم 318 (4-10 يونيو 2018)</a></li>
<li><a href="../ar413813/index.html">ملخص PHP رقم 132 (27 مايو - 10 يونيو 2018)</a></li>
<li><a href="../ar413815/index.html">اذهب ورشة عمل المساهمة في روسيا</a></li>
<li><a href="../ar413819/index.html">بصراحة عن سوق تكنولوجيا المعلومات في روسيا</a></li>
<li><a href="../ar413823/index.html">ازدهار العمالة التي لا معنى لها</a></li>
<li><a href="../ar413827/index.html">يبلغ عمر مشروع Kubernetes 4 سنوات</a></li>
<li><a href="../ar413831/index.html">سيتم إطلاق النسخة الجديدة من Tesla Autopilot في أغسطس ، لأول مرة مع "ميزات القيادة الذاتية بالكامل"</a></li>
<li><a href="../ar413837/index.html">جعل برج الدفاع لعبة وحدة - الجزء 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>