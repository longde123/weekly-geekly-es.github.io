<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌉 🧚🏿 ☪️ Docker pour Symfony 4 - du LAN à la production 🙅🏾 👨‍👨‍👧‍👦 🧖🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Préhistoire 
 Un beau jour, j'ai eu besoin de déployer un environnement de développement pour mon projet. Vagrant en avait déjà assez et voulait avoir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docker pour Symfony 4 - du LAN à la production</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420673/"><h2>  Préhistoire </h2><br>  Un beau jour, j'ai eu besoin de déployer un environnement de développement pour mon projet.  Vagrant en avait déjà assez et voulait avoir un environnement de développement unique pour tous les participants au projet qui serait identique au serveur de production.  En conséquence, après avoir écouté des informations sur le docker hipster, j'ai décidé de commencer à y faire face.  Ensuite, j'essaierai de décrire le plus en détail possible toutes les étapes de l'installation d'un docker sur un LAN jusqu'au déploiement d'un produit sur KVM. <br><br>  <b>Pile de technologie d'origine:</b> <br><br>  - docker <br>  - symfony 4 <br>  - nginx <br>  - php-fpm <br>  - postgresql <br>  - elasticsearch <br>  - rabbitmq <br>  - jenkins <br><br>  <b>Fer:</b> <br><br>  - ordinateur portable sous OS Ubuntu 16.04 <br>  - serveur de production sur hébergement KVM <br><br>  <i>Pourquoi, en plus de la pile technologique, j'ai également répertorié la pile de fer?</i> <br><br>  Si vous n'avez jamais travaillé avec un docker, vous pouvez rencontrer un certain nombre de problèmes liés spécifiquement au matériel, au système d'exploitation de votre ordinateur portable ou au type de virtualisation d'hébergement. <br><br>  Le premier et probablement le plus important aspect lorsque vous commencez à travailler avec le docker est le système d'exploitation de votre ordinateur portable.  La façon la plus simple de travailler avec Docker est sur les systèmes Linux.  Si vous travaillez sur Windows ou Mac, vous aurez 100% de difficultés, mais ces difficultés ne seront pas critiques et si vous voulez "google" comment cela est résolu, il n'y aura pas de problèmes. <br><br>  La deuxième question est l'hébergement.  Pourquoi l'hébergement est-il nécessaire avec le type de virtualisation KVM?  La raison en est que la virtualisation VPS est très différente de KVM et que vous ne pourrez tout simplement pas installer Docker sur VPS, car VPS alloue dynamiquement les ressources du serveur. <br><br>  Sous-total: pour le démarrage le plus rapide du docker, il est plus raisonnable de choisir Ubuntu en tant qu'OS local et hébergement KVM (ou votre propre serveur).  De plus, l'histoire s'appuiera précisément sur ces deux éléments. <br><a name="habracut"></a><br><h2>  Docker-compose pour LAN </h2><br><h3>  L'installation </h3><br>  Vous devez d'abord installer le docker lui-même localement.  Vous pouvez voir les instructions d'installation sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien</a> du site officiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vers la documentation officielle d'ubuntu</a> (vous devez installer docker et docker-compose), ou en exécutant la commande dans la console: <br><br><pre><code class="bash hljs">curl -sSl https://get.docker.com/ | sh</code> </pre> <br>  Cette commande installera à la fois docker et docker-compose.  Après cela, vérifiez la version du docker avec la commande: <br><br><pre> <code class="bash hljs">docker --version</code> </pre> <br>  Je commence tout ça sur la version docker 18.06.0-ce. <br><br>  L'installation est terminée! <br><br><h3>  Sensibilisation </h3><br>  Pour travailler avec quelque chose de moins efficace, vous devez avoir une idée de son fonctionnement.  Si vous ne travailliez auparavant qu'avec Vagrant ou quelque chose de similaire, cela sera extrêmement inhabituel et incompréhensible au début, mais ce n'est qu'au début. <br><br>  Je vais essayer de faire une analogie pour Vagrant.  Maintenant, beaucoup peuvent dire que comparer Vagrant et Docker est fondamentalement faux.  Oui, je suis d'accord avec cela, mais je ne vais pas les comparer, je vais juste essayer de transmettre aux nouveaux arrivants qui ne travaillent qu'avec le système de travail Vagrant the Docker, en faisant appel à ce que les nouveaux arrivants savent. <br><br>  Ma vision du conteneur «sur les doigts» est la suivante: chaque conteneur est un petit monde isolé.  Chaque conteneur peut être imaginé comme s'il s'agissait d'un minuscule Vagrant sur lequel un seul outil est installé, par exemple nginx ou php.  Initialement, les conteneurs sont généralement isolés de tout ce qui l'entoure, mais par des manipulations délicates, vous pouvez tout configurer pour qu'ils communiquent entre eux et fonctionnent ensemble.  Cela ne signifie pas que chacun des conteneurs est une machine virtuelle distincte, pas du tout.  Mais c'est plus facile pour la compréhension initiale, comme il me semble. <br><br>  Vagrant mord simplement une partie des ressources de votre ordinateur, crée une machine virtuelle, y installe un système d'exploitation, installe des bibliothèques, installe tout ce que vous avez écrit dans le script après avoir vagabondé.  En fin de compte, cela ressemble à ceci: <br><br>  → <a href="">Voir le schéma</a> <br><br>  Docker, à son tour, fonctionne radicalement différent.  Il ne crée pas de machines virtuelles.  Docker crée des conteneurs (pour l'instant, vous pouvez les considérer comme des machines micro-virtuelles) avec son système d'exploitation Alpine et 1 à 3 bibliothèques nécessaires au fonctionnement de l'application, par exemple php ou nginx.  Dans le même temps, Docker ne bloque pas les ressources de votre système pour lui-même, mais les utilise simplement si nécessaire.  En fin de compte, pour illustrer, cela ressemblera à quelque chose comme ceci: <br><br>  → <a href="">Voir le schéma</a> <br><br>  Chacun des conteneurs a une image à partir de laquelle il est créé.  La grande majorité des images est une extension d'une autre image, par exemple Ubuntu xenial ou Alpine ou Debian, sur laquelle des pilotes supplémentaires et d'autres composants sont roulés sur le dessus. <br><br>  Ma première image était pour php-fpm.  Mon image étend l'image php officielle: 7.2-fpm-alpine3.6.  Autrement dit, il prend l'image officielle et fournit les composants dont j'ai besoin, par exemple, pdo_pgsql, imagick, zip, etc.  Ainsi, vous pouvez créer l'image dont vous avez besoin.  Si vous le souhaitez, vous pouvez l'utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Avec la création d'images, tout est assez simple à mon avis si elles sont faites à base de xénial par exemple, mais elles délivrent un peu d'hémorroïdes si elles sont faites à base d'alpine.  Avant de commencer à travailler avec le docker, je n'ai pas entendu parler d'Alpine, car Vagrant a toujours travaillé pour moi sous Ubuntu xenial.  Alpine est un système d'exploitation Linux vide, dans lequel il n'y a pratiquement rien du tout (minimum extrême).  Par conséquent, au début, il est extrêmement gênant de travailler avec, car il y a par exemple la même installation apt-get (à laquelle vous êtes habitué), mais il n'y a que apk add et un ensemble de packages pas tout à fait sain d'esprit.  Un gros plus d'Alpine est son poids, par exemple, si Xenial pèse (abstraitement) 500 sacs, alors Alpine (abstraitement) est d'environ 78 sacs.  Qu'est-ce que cela affecte même?  Et cela affecte la vitesse de construction et le poids final de toutes les images qui seront finalement stockées sur votre serveur.  Disons que vous avez 5 conteneurs différents et que tout basé sur le xénial, leur poids total sera supérieur à 2,5 concerts et alpin - environ 500 sacs seulement.  Par conséquent, idéalement, nous devons nous efforcer de veiller à ce que les conteneurs soient aussi minces que possible.  (Lien utile pour installer des packages dans Alpine - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Packages Alpine</a> ). <br><br>  Partout sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">hub docker, ils</a> écrivent comment lancer le conteneur à l'aide de la <code>docker run</code> , et pour une raison quelconque, ils n'écrivent pas comment il peut être lancé via docker-compose, et c'est via docker-compose qu'il démarrera la plupart du temps, car il y a très peu de chasse démarrer manuellement tous les conteneurs, réseaux, ports ouverts et plus encore.  Docker-compose au nom de l'utilisateur ressemble à un fichier yaml avec des paramètres.  Il comprend une description de chacun des services qui doivent être démarrés.  Ma construction pour l'environnement local est la suivante: <br><br><pre> <code class="hljs powershell">version: <span class="hljs-string"><span class="hljs-string">'3.1'</span></span> services: php<span class="hljs-literal"><span class="hljs-literal">-fpm</span></span>: image: otezvikentiy/php7.<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-literal"><span class="hljs-literal">-fpm</span></span>:<span class="hljs-number"><span class="hljs-number">0.0</span></span>.<span class="hljs-number"><span class="hljs-number">11</span></span> ports: - <span class="hljs-string"><span class="hljs-string">'9000:9000'</span></span> volumes: - ../:/app working_dir: /app container_name: <span class="hljs-string"><span class="hljs-string">'php-fpm'</span></span> nginx: image: nginx:<span class="hljs-number"><span class="hljs-number">1.15</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> container_name: <span class="hljs-string"><span class="hljs-string">'nginx'</span></span> working_dir: /app ports: - <span class="hljs-string"><span class="hljs-string">'7777:80'</span></span> volumes: - ../:/app - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf postgres: image: postgres:<span class="hljs-number"><span class="hljs-number">9.6</span></span> ports: - <span class="hljs-string"><span class="hljs-string">'5432:5432'</span></span> container_name: <span class="hljs-string"><span class="hljs-string">'postgresql'</span></span> working_dir: /app restart: always environment: POSTGRES_DB: <span class="hljs-string"><span class="hljs-string">'db_name'</span></span> POSTGRES_USER: <span class="hljs-string"><span class="hljs-string">'db_user'</span></span> POSTGRES_PASSWORD: <span class="hljs-string"><span class="hljs-string">'db_pass'</span></span> volumes: - ./<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/dump:/app/dump - ./<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/postgresql:/var/lib/postgresql/<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> rabbitmq: image: rabbitmq:<span class="hljs-number"><span class="hljs-number">3.7</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-literal"><span class="hljs-literal">-management</span></span> working_dir: /app hostname: rabbit<span class="hljs-literal"><span class="hljs-literal">-mq</span></span> container_name: <span class="hljs-string"><span class="hljs-string">'rabbit-mq'</span></span> ports: - <span class="hljs-string"><span class="hljs-string">'15672:15672'</span></span> - <span class="hljs-string"><span class="hljs-string">'5672:5672'</span></span> environment: RABBITMQ_DEFAULT_USER: user RABBITMQ_DEFAULT_PASS: password RABBITMQ_DEFAULT_VHOST: my_vhost elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:<span class="hljs-number"><span class="hljs-number">6.3</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> container_name: <span class="hljs-string"><span class="hljs-string">'elastic-search'</span></span> environment: - discovery.type=single<span class="hljs-literal"><span class="hljs-literal">-node</span></span> - <span class="hljs-string"><span class="hljs-string">"discovery.zen.ping.unicast.hosts=elasticsearch"</span></span> - bootstrap.memory_lock=true - <span class="hljs-string"><span class="hljs-string">"ES_JAVA_OPTS=-Xms512m -Xmx512m"</span></span> ports: - <span class="hljs-number"><span class="hljs-number">9200</span></span>:<span class="hljs-number"><span class="hljs-number">9200</span></span> - <span class="hljs-number"><span class="hljs-number">9300</span></span>:<span class="hljs-number"><span class="hljs-number">9300</span></span> working_dir: /app volumes: - ../:/app - ./<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/elasticsearch:/usr/share/elasticsearch/<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> volumes: elasticsearch: postgresql:</code> </pre><br>  docker-compose.yaml pour SF4 est un certain ensemble de services: nginx, php-fpm, postgresql, rabbitmq (si vous en avez besoin), elasticsearch (si vous en avez besoin).  Pour l'environnement local, cela suffit.  Pour que tout fonctionne, il existe un ensemble minimal de paramètres sans lesquels rien ne fonctionnera.  Il s'agit le plus souvent d'images, de volumes, de ports, d'environnement, de rép_travail et de nom_conteneur.  Tout pour lancer telle ou telle image est décrit dans sa documentation sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">hub.docker.com</a> .  Il n'y a pas toujours de description pour docker-compose, mais cela ne signifie pas qu'il ne fonctionne pas avec.  Il est juste nécessaire de transférer toutes les données entrantes de la commande docker run vers docker-compose et tout fonctionnera. <br><br>  Par exemple, il y a une image pour RabbitMQ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Lorsque vous voyez cela pour la première fois, cela provoque des sentiments et des émotions mitigés, mais tout n'est pas si effrayant.  Les balises sont indiquées dans cette image.  Généralement, les balises - représentent différentes images, différentes versions de l'application avec différentes images extensibles.  Par exemple, la balise 3.7.7-alpine signifie que cette image est plus mince que, par exemple, 3.7.7, car elle est basée sur Alpine.  Eh bien et aussi dans les balises le plus souvent, les versions de l'application sont indiquées.  Je choisis généralement la dernière version et la version stable de l'application elle-même et de l'image alpine. <br><br>  Après avoir étudié et sélectionné une balise, vous voyez souvent quelque chose de ce genre: <br><br><pre> <code class="bash hljs">docker run -d --hostname my-rabbit --name some-rabbit -e RABBITMQ_DEFAULT_USER=user -e RABBITMQ_DEFAULT_PASS=password rabbitmq:3-management</code> </pre> <br>  Et la première pensée est WTF?  Comment transférer cela vers docker-compose? <br><br>  Tout est assez simple.  En fait, cette ligne indique tous les mêmes paramètres que dans le fichier yaml, uniquement abrégés.  Par exemple, -e est un environnement dans lequel divers paramètres sont passés, il peut également y avoir des entrées comme -p - ce sont des ports appelés ports dans yaml.  En conséquence, afin d'utiliser une image inconnue de manière qualitative, il vous suffit de "google" les abréviations de docker run et d'appliquer les noms complets dans le fichier yaml. <br><br>  Revenons maintenant à docker-compose.yml, que j'ai cité comme exemple ci-dessus. <br><br>  Cet exemple utilise mon image php7.2 faite comme une extension pour l'image officielle php7.2-fpm-alpine, mais si vous n'avez pas besoin d'autant de bibliothèques supplémentaires, vous pouvez créer votre extension pour l'image officielle et l'utiliser.  Les autres images pour LAN sont complètement originales et officielles. <br><br>  <b>image</b> - indiquez l'image à télécharger.  Par exemple (rabbitmq: 3.7.7-management-alpine). <br><br>  <b>ports</b> - spécifiez les ports que le conteneur utilisera (voir la documentation de l'image).  Par exemple, le port nginx est 80.  Par conséquent, si vous souhaitez utiliser le port 80, vous devez spécifier 80:80 ici et votre site sera disponible sur localhost.  Ou vous pouvez spécifier 7777: 80, puis votre site sera à l'URL localhost: 7777.  Cela est nécessaire pour que plusieurs projets puissent être déployés sur le même hôte. <br><br>  <b>volumes</b> - les répertoires partagés sont indiqués ici.  Par exemple, votre projet se trouve dans le répertoire ~ / projects / my-sf4-app, et le conteneur php est configuré pour fonctionner avec le répertoire / app (le même que dans / var / www / my-sf4-app).  En conséquence, il serait pratique que le conteneur ait accès au projet.  En conséquence, dans les volumes, nous écrivons <code>~/projects/my-sf4-app:/app</code> (voir cet exemple dans docker-compose.yml ci-dessus (je l'ai indiqué de manière relative ../:/app)). <br><br>  Ainsi, le dossier sera partagé pour le conteneur et il pourra y effectuer diverses actions comme <code>php bin/console doctrine:migrations:migrate</code> .  Il est également pratique d'utiliser ces répertoires pour enregistrer les données d'application.  Par exemple, postgresql, vous pouvez spécifier un répertoire pour stocker les données de la base de données, puis lorsque vous recréez le conteneur, vous n'aurez pas besoin de faire un vidage ou des appareils. <br><br>  <b>working_dir</b> - indique le répertoire de travail du conteneur.  Dans ce cas, / app (ou par analogie avec le vagrant / var / www / my-sf4-app). <br><br>  <b>environnement</b> - toutes les variables du conteneur sont passées ici.  Par exemple, pour rabbitmq, le nom d'utilisateur et le mot de passe sont transmis, pour postgresql, le nom de base, le nom d'utilisateur et le mot de passe sont transmis. <br><br>  <b>nom_conteneur</b> est un champ facultatif, mais je préfère spécifier, pour la commodité de la connexion aux conteneurs.  S'il n'est pas spécifié, des noms par défaut avec des hachages seront attribués. <br><br>  Ce sont les principaux paramètres qui doivent être spécifiés.  Le reste peut être facultatif pour des paramètres supplémentaires, ou selon la documentation du conteneur. <br><br>  Maintenant, pour démarrer tout cela, vous devez exécuter la commande <code>docker-compose up -d</code> dans le répertoire où se trouve le fichier docker-compose. <br><br><h3>  Comment et où stocker tout cela pour le LAN? </h3><br>  Pour le LAN, j'utilise le dossier docker à la racine du projet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pv/rg/a8/pvrga87xk7vcujz2-qwbjnqmtjk.png"></div><br>  Il contient le dossier de données dans lequel je stocke toutes les informations postgresql et elasticsearch, de sorte que lorsque vous recréez le projet, vous n'avez pas à faire rouler les appareils à partir de zéro.  Il y a aussi un papa nginx dans lequel je stocke la configuration du conteneur nginx local.  Je synchronise ces dossiers dans docker-compose.yml avec les fichiers et dossiers correspondants dans les conteneurs.  De plus, à mon avis, il est très pratique d'écrire des scripts bash pour travailler avec docker.  Par exemple, le script start.sh lance les conteneurs, puis le compositeur installe, nettoie le cache et migre.  C'est aussi pratique pour les collègues du projet, ils n'ont rien à faire, ils exécutent simplement le script et tout fonctionne. <br><br>  Exemple de script Start.sh <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash green=$(tput setf 2) toend=$(tput hpa $(tput cols))$(tput cub 6) echo -n '   ?: ' read name echo "  $name!       tutmesto.ru" echo -n "$name,      ? (y/n): " read use_dump echo '    !' docker-compose up -d || exit echo -en '\n' echo -n "  ! ${green}${toend}[OK]" echo -en '\n' echo '    .' ./composer-install.sh echo -en '\n' echo -n "   ${green}${toend}[OK]" echo -en '\n' echo '     40 ,    postgres-' sleep 5 echo '  35 ...' sleep 5 echo '  30 ...' sleep 5 echo '  25 ...' sleep 5 echo '  20 ...' sleep 5 echo '  15 ...' sleep 5 echo '  10 ...' sleep 5 echo '  5 ...' sleep 5 echo ' .   postgres-        !' case "$use_dump" in y|Y) ./dump.sh echo -en '\n' echo -n "  ! ${green}${toend}[OK]" echo -en '\n' ;; *) echo "$name, ,   ! =)" ;; esac echo '    !' ./migrations-migrate.sh echo -en '\n' echo -n "  ! ${green}${toend}[OK]" echo -en '\n' echo '  !' ./php-fpm-command.sh rm -rf var/cache/* ./php-fpm-command.sh chmod 777 var/ -R ./cache-clear.sh echo -en '\n' echo -n "  ! ${green}${toend}[OK]" echo -en '\n' echo '    !' ./env.sh echo -en '\n' echo -n "   ! ${green}${toend}[OK]" echo -en '\n' echo ", $name,    !    localhost:7777  !" echo -en '\n' echo "------------------------------------------------------------------------------" echo -en '\n' echo "    :" echo "./cache-clear.sh |  symfony 4" echo "./composer.sh [command(ex. install)] |  " echo "./composer-install.sh | composer install" echo "./connect-to-php-fpm.sh |   php" echo "./console.sh [command(ex. cache:clear)] |  php bin/console" echo "./destroy.sh |  .    ." echo "./dump.sh | ,     (dump.sql)" echo "./env.sh |   " echo "./migrations-migrate.sh | " echo "./php-fpm-command.sh [command(ex. php -m)] |   php-fpm " echo "./start.sh |  ( )" echo "./stop.sh |Gracefull shutdown " echo -en '\n' echo "        :" echo "client@c.cc | QWEasd123" echo "admin@a.aa | QWEasd123" echo "moderator@m.mm | QWEasd123" echo -en '\n' echo "------------------------------------------------------------------------------" echo -en '\n' echo -en '\n' echo 'OtezVikentiy brain corporation!' echo -en '\n' echo -en '\n'</span></span></code> </pre><br>  <i>Exemple de</i> script <i>Php-fpm-command.sh</i> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash cd "`dirname \"$0\"`" &amp;&amp; \ docker-compose exec -T "php-fpm" sh -c "cd /app &amp;&amp; $*"</span></span></code> </pre><br>  <i>Exemple de</i> script <i>connect-to-php-fpm.sh</i> <br><br><pre> <code class="bash hljs"><span class="hljs-meta"><span class="hljs-meta">#!/usr/bin/env bash docker exec -i -t --privileged php-fpm bash</span></span></code> </pre><br>  L'environnement de développement local s'arrête ici.  Félicitations, vous pouvez partager le résultat final avec vos collègues!  ) <br><br><h2>  Productif </h2><br><h3>  La préparation </h3><br>  Supposons que vous ayez déjà écrit quelque chose sur un LAN et que vous souhaitiez le mettre sur un serveur de production ou sur un serveur de test.  Vous avez l'hébergement sur virtualisation KVM ou votre serveur dans la pièce voisine avec climatisation. <br><br>  Pour déployer un produit ou une version bêta - le serveur doit avoir un système d'exploitation (idéalement linux) et un docker installé.  Docker peut être installé de la même manière que sur LAN, il n'y a aucune différence. <br><br>  Docker en termes de productivité est légèrement différent du LAN.  Premièrement, vous ne pouvez pas simplement prendre et spécifier des mots de passe et d'autres informations et composer-docker.  Deuxièmement, vous ne pouvez pas utiliser directement Docker-compose. <br><br>  Docker utilise l'essaim de docker et la pile de docker pour la productivité.  S'il est juste sur les doigts, alors ce système ne diffère que par d'autres commandes et en ce que l'essaim docker est un équilibreur de charge pour le cluster (encore un peu abstrait, mais il sera plus facile à comprendre). <br><br>  PS: Je vous conseille de vous entraîner à mettre en place un essaim de docker sur Vagrant (aussi paradoxal que cela puisse paraître).  Une recette simple pour la formation - prenez un Vagrant vide avec le même système d'exploitation que dans le produit et configurez-le pour démarrer. <br><br>  Pour configurer l'essaim de docker, il vous suffit d'exécuter quelques commandes: <br><br><pre> <code class="bash hljs">docker swarm init --advertise-addr 192.168.***.** (ip-  ) mkdir /app (          app) chown docker /app (     ) docker stack deploy -c docker-compose.yml my-first-sf4-docker-app</code> </pre><br>  Nous considérons maintenant tout cela un peu plus en détail. <br><br>  <b>docker swarm init --advertise-addr</b> - il lance directement docker swarm et tâtonne un lien afin que vous puissiez connecter un autre serveur à cet "essaim" afin qu'ils fonctionnent dans le cluster. <br>  <b>mkdir / app &amp;&amp; chown ..</b> - vous devez créer tous les répertoires nécessaires pour que le docker fonctionne à l'avance afin que pendant la construction, il ne se plaigne pas du manque de répertoires. <br>  <b>docker stack deploy -c docker-compose.yml my-first-sf4-docker-app</b> - cette commande démarre l'assemblage de votre application elle-même, un analogue de docker-compose up -d uniquement pour l'essaim de dockers. <br><br>  Pour démarrer un assemblage, vous avez besoin du même docker-compose.yaml, mais il est déjà légèrement modifié spécifiquement pour productif / beta. <br><br><pre> <code class="hljs powershell">version: <span class="hljs-string"><span class="hljs-string">'3.1'</span></span> services: php<span class="hljs-literal"><span class="hljs-literal">-fpm</span></span>: image: otezvikentiy/php7.<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-literal"><span class="hljs-literal">-fpm</span></span>:<span class="hljs-number"><span class="hljs-number">0.0</span></span>.<span class="hljs-number"><span class="hljs-number">11</span></span> ports: - <span class="hljs-string"><span class="hljs-string">'9000:9000'</span></span> networks: - my<span class="hljs-literal"><span class="hljs-literal">-test</span></span><span class="hljs-literal"><span class="hljs-literal">-network</span></span> depends_on: - postgres - rabbitmq volumes: - /app:/app working_dir: /app deploy: replicas: <span class="hljs-number"><span class="hljs-number">1</span></span> restart_policy: condition: on<span class="hljs-literal"><span class="hljs-literal">-failure</span></span> placement: constraints: [<span class="hljs-type"><span class="hljs-type">node.role</span></span> == <span class="hljs-type"><span class="hljs-type">manager</span></span>] nginx: image: nginx:<span class="hljs-number"><span class="hljs-number">1.15</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> networks: - my<span class="hljs-literal"><span class="hljs-literal">-test</span></span><span class="hljs-literal"><span class="hljs-literal">-network</span></span> working_dir: /app ports: - <span class="hljs-string"><span class="hljs-string">'80:80'</span></span> depends_on: - php<span class="hljs-literal"><span class="hljs-literal">-fpm</span></span> volumes: - /app:/app - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf deploy: replicas: <span class="hljs-number"><span class="hljs-number">1</span></span> restart_policy: condition: on<span class="hljs-literal"><span class="hljs-literal">-failure</span></span> placement: constraints: [<span class="hljs-type"><span class="hljs-type">node.role</span></span> == <span class="hljs-type"><span class="hljs-type">manager</span></span>] postgres: image: postgres:<span class="hljs-number"><span class="hljs-number">9.6</span></span> ports: - <span class="hljs-string"><span class="hljs-string">'5432:5432'</span></span> working_dir: /app networks: - my<span class="hljs-literal"><span class="hljs-literal">-test</span></span><span class="hljs-literal"><span class="hljs-literal">-network</span></span> secrets: - postgres_db - postgres_user - postgres_pass environment: POSTGRES_DB_FILE: /run/secrets/postgres_db POSTGRES_USER_FILE: /run/secrets/postgres_user POSTGRES_PASSWORD_FILE: /run/secrets/postgres_pass volumes: - ./<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/dump:/app/dump - ./<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/postgresql:/var/lib/postgresql/<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> deploy: replicas: <span class="hljs-number"><span class="hljs-number">1</span></span> restart_policy: condition: on<span class="hljs-literal"><span class="hljs-literal">-failure</span></span> placement: constraints: [<span class="hljs-type"><span class="hljs-type">node.role</span></span> == <span class="hljs-type"><span class="hljs-type">manager</span></span>] rabbitmq: image: rabbitmq:<span class="hljs-number"><span class="hljs-number">3.7</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-literal"><span class="hljs-literal">-management</span></span> networks: - my<span class="hljs-literal"><span class="hljs-literal">-test</span></span><span class="hljs-literal"><span class="hljs-literal">-network</span></span> working_dir: /app hostname: my<span class="hljs-literal"><span class="hljs-literal">-test</span></span><span class="hljs-literal"><span class="hljs-literal">-sf4</span></span><span class="hljs-literal"><span class="hljs-literal">-app</span></span><span class="hljs-literal"><span class="hljs-literal">-rabbit</span></span><span class="hljs-literal"><span class="hljs-literal">-mq</span></span> volumes: - /app:/app ports: - <span class="hljs-string"><span class="hljs-string">'5672:5672'</span></span> - <span class="hljs-string"><span class="hljs-string">'15672:15672'</span></span> secrets: - rabbitmq_default_user - rabbitmq_default_pass - rabbitmq_default_vhost environment: RABBITMQ_DEFAULT_USER_FILE: /run/secrets/rabbitmq_default_user RABBITMQ_DEFAULT_PASS_FILE: /run/secrets/rabbitmq_default_pass RABBITMQ_DEFAULT_VHOST_FILE: /run/secrets/rabbitmq_default_vhost deploy: replicas: <span class="hljs-number"><span class="hljs-number">1</span></span> restart_policy: condition: on<span class="hljs-literal"><span class="hljs-literal">-failure</span></span> placement: constraints: [<span class="hljs-type"><span class="hljs-type">node.role</span></span> == <span class="hljs-type"><span class="hljs-type">manager</span></span>] elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:<span class="hljs-number"><span class="hljs-number">6.3</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> networks: - my<span class="hljs-literal"><span class="hljs-literal">-test</span></span><span class="hljs-literal"><span class="hljs-literal">-network</span></span> depends_on: - postgres environment: - discovery.type=single<span class="hljs-literal"><span class="hljs-literal">-node</span></span> - discovery.zen.ping.unicast.hosts=elasticsearch - bootstrap.memory_lock=true - ES_JAVA_OPTS=<span class="hljs-literal"><span class="hljs-literal">-Xms512m</span></span> <span class="hljs-literal"><span class="hljs-literal">-Xmx512m</span></span> ports: - <span class="hljs-number"><span class="hljs-number">9200</span></span>:<span class="hljs-number"><span class="hljs-number">9200</span></span> - <span class="hljs-number"><span class="hljs-number">9300</span></span>:<span class="hljs-number"><span class="hljs-number">9300</span></span> working_dir: /app volumes: - /app:/app - ./<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/elasticsearch:/usr/share/elasticsearch/<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> deploy: replicas: <span class="hljs-number"><span class="hljs-number">1</span></span> restart_policy: condition: on<span class="hljs-literal"><span class="hljs-literal">-failure</span></span> placement: constraints: [<span class="hljs-type"><span class="hljs-type">node.role</span></span> == <span class="hljs-type"><span class="hljs-type">manager</span></span>] jenkins: image: otezvikentiy/jenkins:<span class="hljs-number"><span class="hljs-number">0.0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span> networks: - my<span class="hljs-literal"><span class="hljs-literal">-test</span></span><span class="hljs-literal"><span class="hljs-literal">-network</span></span> ports: - <span class="hljs-string"><span class="hljs-string">'8080:8080'</span></span> - <span class="hljs-string"><span class="hljs-string">'50000:50000'</span></span> volumes: - /app:/app - ./<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/jenkins:/var/jenkins_home - /var/run/docker.sock:/var/run/docker.sock - /usr/bin/docker:/usr/bin/docker deploy: replicas: <span class="hljs-number"><span class="hljs-number">1</span></span> restart_policy: condition: on<span class="hljs-literal"><span class="hljs-literal">-failure</span></span> placement: constraints: [<span class="hljs-type"><span class="hljs-type">node.role</span></span> == <span class="hljs-type"><span class="hljs-type">manager</span></span>] volumes: elasticsearch: postgresql: jenkins: networks: my<span class="hljs-literal"><span class="hljs-literal">-test</span></span><span class="hljs-literal"><span class="hljs-literal">-network</span></span>: secrets: rabbitmq_default_user: file: ./secrets/rabbitmq_default_user rabbitmq_default_pass: file: ./secrets/rabbitmq_default_pass rabbitmq_default_vhost: file: ./secrets/rabbitmq_default_vhost postgres_db: file: ./secrets/postgres_db postgres_user: file: ./secrets/postgres_user postgres_pass: file: ./secrets/postgres_pass</code> </pre><br>  Comme vous pouvez le voir, le fichier de paramètres du produit est légèrement différent du fichier LAN.  Il a ajouté des secrets, déployer et réseaux. <br><br>  <b>secrets</b> - fichiers pour stocker les clés.  Les clés sont créées tout simplement.  Vous créez un fichier avec le nom de la clé - écrivez la valeur à l'intérieur.  Après cela, dans docker-compose.yml, vous spécifiez la section secrets et transférez la liste complète des fichiers avec les clés.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Plus de détails</a> . <br>  <b>réseaux</b> - cela crée une certaine grille interne à travers laquelle les conteneurs communiquent entre eux.  Sur LAN - cela se fait automatiquement, mais sur le productif - cela doit être fait un peu manuellement.  De plus, vous pouvez spécifier des paramètres supplémentaires, à l'exception de ceux par défaut.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Plus de détails</a> . <br>  <b>le déploiement</b> est la principale différence entre le LAN et le produit / bêta. <br><br><pre> <code class="hljs powershell"> deploy: replicas: <span class="hljs-number"><span class="hljs-number">1</span></span> restart_policy: condition: on<span class="hljs-literal"><span class="hljs-literal">-failure</span></span> placement: constraints: [<span class="hljs-type"><span class="hljs-type">node.role</span></span> == <span class="hljs-type"><span class="hljs-type">manager</span></span>]</code> </pre><br>  Ensemble de chasse minimum: <br><br>  <b>répliques</b> - indiquez le nombre de répliques que vous devez exécuter (en fait, cela est utilisé si vous avez un cluster et que vous utilisez l'équilibreur de charge du docker).  Par exemple, vous avez deux serveurs et vous les avez connectés via swarm docker.  En spécifiant le numéro 2 ici, par exemple, 1 instance sera créée sur 1 serveur et la seconde sur le deuxième serveur.  Ainsi, la charge sur le serveur sera divisée en deux. <br>  <b>restart_policy</b> - la politique de «ré-élévation» automatique du conteneur au cas où il tomberait pour une raison quelconque. <br>  <b>placement</b> - l'emplacement de l'instance de conteneur.  Par exemple, il arrive que vous souhaitiez que toutes les instances d'un conteneur tournent sur 1 seul des 5 serveurs et ne soient pas réparties entre eux. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Je veux lire la documentation!</a> <br><br>  Nous avons donc un peu mieux compris ce qui distingue docker-compose.yaml pour LAN de la version produit / bêta.  Essayons maintenant de gérer cette entreprise. <br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supposons que vous vous entraînez sur Vagrant et qu'à la racine du serveur vous disposez déjà du fichier configuré pour le produit docker-compose.yml</font></font></i> <br><br><pre> <code class="bash hljs">sudo apt-get update sudo apt-get -y upgrade sudo apt-get install -y language-pack-en-base <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> LC_ALL=en_US.UTF-8 <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> LANGUAGE=en_US.UTF-8 <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> LANG=en_US.UTF-8 curl -sSl https://get.docker.com/ | sh sudo usermod -aG docker ubuntu sudo apt-get install git sudo docker swarm init --advertise-addr 192.168.128.77 sudo mkdir /app sudo chmod 777 /app -R docker stack deploy -c /docker-compose.yml my-app git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> git@bitbucket.org:JohnDoe/my-app.git /app docker stack ps my-app docker stack ls docker stack services my-app</code> </pre><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ne lancez pas pour sudo et 777, bien sûr, cela ne vaut pas la peine de le faire sur le productif. </font><font style="vertical-align: inherit;">C'est juste pour apprendre la vitesse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Donc, nous sommes plus intéressés par les lignes associées au docker. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D'abord, nous initialisons le «swarm» (docker swarm). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous créons les répertoires nécessaires au travail. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Téléchargez le navet avec notre code SF4 dans le répertoire / app. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après cela, il y a trois commandes: ps, ls et services. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chacun d'eux est utile à sa manière. </font><font style="vertical-align: inherit;">J'utilise ps le plus souvent, car il affiche l'état des conteneurs et une partie de l'erreur, le cas échéant.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disons que les conteneurs ont augmenté, mais certains d'entre eux se bloquent constamment avec une erreur et dans docker stack ps my-app, vous voyez un tas de redémarrages. </font><font style="vertical-align: inherit;">Pour voir la raison de la chute, vous devez exécuter le docker container ps -a - et là un conteneur apparaîtra qui tombe constamment. </font><font style="vertical-align: inherit;">Il y aura de nombreuses instances du même conteneur, par exemple my-app_php-fpm.1. * Un hachage féroce *. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En conséquence, maintenant, connaissant le nom du conteneur, exécutez les journaux docker my-app_php-fpm.1. * Un hachage féroce * et parcourez les journaux. </font><font style="vertical-align: inherit;">Corrigez l'erreur et redémarrez TOUT. </font><font style="vertical-align: inherit;">Pour frapper tous les conteneurs, vous pouvez procéder comme suit:</font></font><br><br><pre> <code class="bash hljs">docker stack rm my-app</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après cela, vous aurez un essaim propre sans aucun conteneur. </font><font style="vertical-align: inherit;">Corrigez l'erreur - et encore une fois docker stack deploy -c docker-compose.yml my-app.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420673/">https://habr.com/ru/post/fr420673/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420663/index.html">Des mesures simples et un moyen de gagner du temps lors de la recherche de problèmes dans l'infrastructure</a></li>
<li><a href="../fr420665/index.html">Création d'une application sur .NET Core et Kubernetes: notre expérience</a></li>
<li><a href="../fr420667/index.html">Principes de fonctionnement du protocole EIGRP</a></li>
<li><a href="../fr420669/index.html">Aperçu du marché de l'automatisation d'entreprise: solutions pour les sociétés de construction et de gestion de logements et de services publics</a></li>
<li><a href="../fr420671/index.html">[Ekaterinbourg, annonce] UralJS # 9 - trois rapports sur les microservices, les tests et la journalisation des erreurs à l'avant</a></li>
<li><a href="../fr420675/index.html">Les SOC sont des personnes. «Bonjour, nous recherchons des talents» ou d'où viennent les analystes du centre de surveillance et de réponse aux cyberattaques</a></li>
<li><a href="../fr420677/index.html">L'histoire de la façon dont Epson a fourni à la planète 30 millions d '"usines"</a></li>
<li><a href="../fr420679/index.html">Nouveaux cours Python de Mail.Ru Group</a></li>
<li><a href="../fr420681/index.html">AMD ThreadRipper 2: première introduction</a></li>
<li><a href="../fr420685/index.html">Fixer et neutraliser: comment nous avons apprivoisé l'argent. Un mot sur les bactéricides pour l'eau</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>