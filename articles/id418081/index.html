<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§™ğŸ» ğŸ‘¨ğŸ¾â€âš–ï¸ ğŸ—œï¸ Organisasi pengujian yang aman dalam produksi. Bagian 1 ğŸ”’ ğŸ†– ğŸ˜œ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini membahas berbagai jenis pengujian dalam produksi dan kondisi di mana masing-masing paling berguna, dan juga menjelaskan cara mengatur peng...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Organisasi pengujian yang aman dalam produksi. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/418081/"><img src="https://habrastorage.org/webt/0q/az/yt/0qazyteu8a-cel_dnpcbmyckzsk.jpeg"><br><br>  Artikel ini membahas berbagai jenis pengujian dalam produksi dan kondisi di mana masing-masing paling berguna, dan juga menjelaskan cara mengatur pengujian aman berbagai layanan dalam produksi. <a name="habracut"></a><br><br>  Perlu dicatat bahwa konten artikel ini hanya berlaku untuk <b>layanan tersebut</b> , yang penyebarannya dikendalikan oleh pengembang.  Selain itu, Anda harus segera memperingatkan bahwa penggunaan salah satu dari jenis pengujian yang dijelaskan di sini bukanlah tugas yang mudah, yang seringkali membutuhkan perubahan serius pada desain, pengembangan, dan pengujian sistem.  Dan, terlepas dari judul artikel, saya tidak berpikir bahwa salah satu dari jenis pengujian dalam produksi benar-benar dapat diandalkan.  Hanya ada pendapat bahwa pengujian semacam itu dapat secara signifikan mengurangi tingkat risiko di masa depan, dan biaya investasi akan dibenarkan. <br><br>  <i><b>(Catatan: karena artikel aslinya adalah Longrid, untuk kenyamanan pembaca, artikel ini dibagi menjadi dua bagian).</b></i> <br><br><h2>  Mengapa pengujian dalam produksi diperlukan jika dapat dilakukan dalam pementasan? </h2><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="974530841190608897"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  Signifikansi cluster pementasan (atau lingkungan pementasan) oleh orang yang berbeda dirasakan secara berbeda.  Bagi banyak perusahaan, penyebaran dan pengujian suatu produk dalam pementasan adalah tahap integral sebelum rilis finalnya. <br><br>  Banyak organisasi terkenal menganggap pementasan sebagai salinan miniatur dari lingkungan kerja.  Dalam kasus seperti itu, ada kebutuhan untuk memastikan sinkronisasi maksimumnya.  Dalam hal ini, biasanya diperlukan untuk memastikan pengoperasian berbagai sistem stateful yang berbeda, seperti database, dan secara berkala menyinkronkan data dari lingkungan produksi dengan pementasan.  Pengecualian hanya informasi rahasia yang memungkinkan Anda untuk menetapkan identitas pengguna (ini diperlukan untuk mematuhi persyaratan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GDPR</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PCI</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HIPAA</a> dan peraturan lainnya). <br><br>  Masalah dengan pendekatan ini (dalam pengalaman saya) adalah bahwa perbedaannya tidak hanya dalam penggunaan contoh terpisah dari database yang berisi data lingkungan produksi aktual.  Seringkali perbedaan meluas ke aspek-aspek berikut: <br><br><ul><li>  Ukuran cluster pementasan (jika Anda dapat menyebutnya "cluster" - terkadang hanya satu server yang menyamar sebagai cluster); </li><li>  Fakta bahwa pementasan biasanya menggunakan kluster yang jauh lebih kecil juga berarti bahwa pengaturan konfigurasi untuk hampir <i>setiap</i> layanan akan bervariasi.  Ini berlaku untuk konfigurasi load balancers, database, dan antrian, misalnya, jumlah deskriptor file terbuka, jumlah koneksi database terbuka, ukuran kumpulan thread, dll. Jika konfigurasi disimpan dalam database atau penyimpanan data bernilai kunci (misalnya, Zookeeper atau Konsul), sistem tambahan ini juga harus ada dalam lingkungan pementasan; </li><li>  Jumlah koneksi online yang diproses oleh layanan stateless, atau metode penggunaan kembali koneksi TCP oleh server proxy (jika prosedur ini dilakukan sama sekali); </li><li>  Kurangnya pemantauan dalam pementasan.  Tetapi bahkan jika pemantauan dilakukan, beberapa sinyal mungkin berubah menjadi benar-benar tidak akurat, karena lingkungan selain yang berfungsi dimonitor.  Misalnya, bahkan jika Anda memantau latensi kueri MySQL atau waktu respons, sulit untuk menentukan apakah kode baru berisi kueri yang dapat memulai pemindaian tabel penuh di MySQL, karena <i>jauh</i> lebih cepat (dan kadang-kadang bahkan lebih disukai) untuk melakukan pemindaian penuh dari tabel kecil yang digunakan dalam pengujian. database daripada database produksi, di mana kueri dapat memiliki profil kinerja yang sama sekali berbeda. </li></ul><br>  Meskipun adil untuk mengasumsikan bahwa semua perbedaan di atas bukanlah argumen serius terhadap penggunaan pementasan seperti itu, tidak seperti antipattern yang harus dihindari.  Pada saat yang sama, keinginan untuk melakukan segala sesuatunya dengan benar seringkali membutuhkan biaya tenaga kerja insinyur yang sangat besar dalam upaya untuk memastikan lingkungan yang konsisten.  Produksi terus berubah dan dipengaruhi oleh berbagai faktor, jadi berusaha mencapai kecocokan ini seperti pergi ke mana-mana. <br><br>  Selain itu, bahkan jika kondisi pada pementasan akan sama mungkin dengan lingkungan kerja, ada jenis pengujian lain yang lebih baik untuk digunakan berdasarkan informasi produksi nyata.  Contoh yang baik adalah pengujian rendam, di mana keandalan dan stabilitas layanan diuji selama periode waktu yang lama pada tingkat multitasking dan beban nyata.  Ini digunakan untuk mendeteksi kebocoran memori, menentukan durasi jeda dalam GC, level beban prosesor dan indikator lainnya untuk periode waktu tertentu. <br><br>  Tak satu pun dari yang di atas menunjukkan bahwa pementasan sama <i>sekali</i> tidak berguna (ini akan menjadi jelas setelah membaca bagian tentang duplikasi bayangan data saat menguji layanan).  Ini hanya menunjukkan bahwa mereka cukup sering mengandalkan pementasan ke tingkat yang lebih besar dari yang diperlukan, dan di banyak organisasi itu tetap <i>satu</i> - <i>satunya</i> jenis pengujian yang dilakukan sebelum rilis penuh produk. <br><br><h2>  Seni pengujian dalam produksi </h2><br>  Itu terjadi secara historis bahwa konsep "pengujian dalam produksi" dikaitkan dengan stereotip tertentu dan konotasi negatif ("pemrograman gerilya", kurangnya atau tidak adanya pengujian unit dan integrasi, kelalaian atau ketidakpedulian terhadap persepsi produk oleh pengguna akhir). <br><br>  Pengujian dalam produksi tentu akan pantas mendapatkan reputasi seperti itu jika dilakukan dengan sembarangan dan buruk.  Itu <i>tidak</i> dengan cara apa pun <i>menggantikan</i> pengujian pada tahap pra-produksi dan dalam keadaan apa pun itu bukan <i>tugas yang mudah</i> .  Selain itu, saya berpendapat bahwa pengujian yang <i>berhasil</i> dan <i>aman</i> dalam produksi memerlukan tingkat otomatisasi yang signifikan, pemahaman yang baik tentang praktik yang telah mapan, dan desain sistem dengan orientasi awal untuk jenis pengujian ini. <br><br>  Untuk mengatur proses komprehensif dan aman dari pengujian layanan yang efektif dalam produksi, penting untuk tidak menganggapnya sebagai istilah generalisasi yang menunjukkan seperangkat alat dan teknik yang berbeda.  Sayangnya, kesalahan ini juga saya buat - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam artikel saya sebelumnya</a> tidak disajikan klasifikasi ilmiah tentang metode pengujian, dan di bagian "Pengujian dalam produksi" berbagai metodologi dan alat dikelompokkan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2h/bo/od/2hboodum_vrej99d2xm911ifecw.png"></div><br>  <i>Dari catatan Testing Microservices, cara yang waras ("Pendekatan cerdas untuk menguji microservices")</i> <br><br>  Sejak penerbitan catatan pada akhir Desember 2017, saya telah membahas isinya dan umumnya topik pengujian dalam produksi dengan beberapa orang. <br><br>  Dalam perjalanan diskusi ini, dan juga setelah serangkaian percakapan terpisah, menjadi jelas bagi saya bahwa topik pengujian dalam produksi tidak dapat direduksi menjadi beberapa poin yang tercantum di atas. <br><br>  Konsep "pengujian dalam produksi" mencakup berbagai teknik yang diterapkan <i>pada tiga tahap yang berbeda</i> .  Yang mana - mari kita mengerti. <br><br><img src="https://habrastorage.org/webt/6a/wc/5-/6awc5-yiregc_-2pzrk4i7gjxx0.jpeg"><br><br><h2>  Tiga tahap produksi </h2><br>  Biasanya diskusi tentang produksi dilakukan hanya dalam konteks penerapan kode dalam produksi, pemantauan, atau dalam situasi darurat ketika terjadi kesalahan. <br><br>  Saya sendiri sejauh ini menggunakan istilah-istilah seperti "penyebaran", "rilis", "pengiriman", dll., Sebagai sinonim, dengan sedikit pemikiran tentang artinya.  Beberapa bulan yang lalu, semua upaya untuk membedakan istilah-istilah ini akan ditolak oleh saya sebagai sesuatu yang tidak penting. <br>  Setelah memikirkan hal ini, saya sampai pada ide bahwa <i>ada</i> kebutuhan nyata untuk membedakan berbagai tahapan produksi. <br><br><h3>  Tahap 1. Penerapan </h3><br>  Ketika pengujian (bahkan dalam produksi) adalah pemeriksaan pencapaian <i>indikator terbaik</i> , keakuratan pengujian (dan memang dari setiap cek) dipastikan hanya dengan syarat bahwa metode melakukan pengujian sedekat mungkin dengan cara layanan sebenarnya digunakan dalam produksi. <br><br>  Dengan kata lain, tes harus dijalankan di lingkungan yang <i>paling baik mensimulasikan lingkungan kerja</i> . <br><br>  Dan <i>tiruan terbaik dari</i> lingkungan kerja adalah ... lingkungan kerja itu sendiri.  Untuk melakukan jumlah tes maksimum yang dimungkinkan dalam lingkungan produksi, perlu bahwa hasil dari salah satu dari mereka tidak mempengaruhi pengguna akhir. <br><br>  Ini, pada gilirannya, hanya mungkin jika, <b>ketika menggunakan layanan dalam lingkungan produksi, pengguna tidak mendapatkan akses langsung ke layanan ini</b> . <br><br>  Dalam artikel ini, saya memutuskan untuk menggunakan terminologi dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Deploy! = Rilis</a> artikel yang ditulis oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Turbine Labs</a> .  Ini mendefinisikan istilah "penyebaran" sebagai berikut: <br><br>  â€œDeployment adalah instalasi oleh kelompok kerja dari versi baru dari kode program layanan dalam infrastruktur produksi.  Ketika kami mengatakan bahwa versi baru dari perangkat lunak telah <b>digunakan</b> , kami bermaksud bahwa itu berjalan di suatu tempat dalam kerangka kerja infrastruktur.  Ini bisa menjadi contoh EC2 baru di AWS atau wadah Docker yang berjalan di perapian cluster Kubernetes.  Layanan mulai berhasil, lulus pemeriksaan kesehatan dan siap (Anda harap!) Untuk memproses data lingkungan produksi, tetapi mungkin tidak benar-benar menerima data.  Ini adalah poin penting, saya tekankan lagi: <b>untuk penyebaran tidak perlu bagi pengguna untuk mendapatkan akses ke versi baru layanan Anda</b> .  Dengan definisi ini, penyebaran bisa disebut proses dengan risiko hampir nol. â€ <br><br>  Kata-kata "proses tanpa risiko" hanyalah balsem bagi jiwa banyak orang yang telah menderita karena penyebaran yang tidak berhasil.  Kemampuan untuk menginstal perangkat lunak <i>dalam lingkungan nyata</i> tanpa mengizinkan pengguna untuk itu memiliki sejumlah keunggulan ketika datang ke pengujian. <br>  Pertama, kebutuhan untuk mempertahankan lingkungan yang terpisah untuk pengembangan, pengujian dan pementasan, yang pasti harus disinkronkan dengan produksi, diminimalkan (dan bahkan mungkin hilang sama sekali). <br><br>  Selain itu, pada tahap mendesain layanan, menjadi perlu untuk mengisolasi mereka satu sama lain sehingga kegagalan untuk menguji contoh spesifik dari layanan dalam produksi <i>tidak</i> mengarah ke kaskade atau mempengaruhi pengguna dari kegagalan layanan lainnya.  Salah satu solusi untuk ini dapat desain model data dan skema database di mana permintaan non-idempoten (terutama <i>operasi tulis</i> ) dapat: <br><br><ul><li>  Untuk dilakukan dalam kaitannya dengan basis data lingkungan produksi selama setiap uji peluncuran layanan dalam produksi (Saya lebih suka pendekatan ini); </li><li>  Ditolak dengan aman di tingkat aplikasi hingga mencapai tingkat penulisan atau penyimpanan; </li><li>  Dialokasikan atau diisolasi pada catatan atau tingkat penyimpanan dengan cara tertentu (misalnya, dengan menyimpan metadata tambahan). </li></ul><br><h3>  Tahap 2. Rilis </h3><br>  Note <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Deploy! = Rilis</a> mendefinisikan istilah rilis sebagai berikut: <br><br>  â€œKetika kami mengatakan bahwa <b>rilis</b> versi layanan telah terjadi, kami bermaksud bahwa itu menyediakan pemrosesan data di lingkungan produksi.  Dengan kata lain, <b>rilis</b> adalah proses yang mengarahkan data lingkungan produksi ke versi perangkat lunak baru.  Dengan definisi ini dalam pikiran, semua risiko yang kami asosiasikan dengan mengirim aliran data baru (gangguan, ketidakpuasan pelanggan, catatan beracun dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The Register</a> ) berhubungan dengan <b>rilis</b> perangkat lunak baru, dan bukan penyebarannya (di beberapa perusahaan tahap ini juga disebut <b>rilis</b> . Dalam artikel ini kami akan menggunakan istilah <b>rilis</b> ). " <br><br>  Dalam buku Google tentang SRE, istilah "rilis" digunakan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bab tentang mengatur rilis perangkat lunak untuk menggambarkannya</a> . <br><br>  â€œSuatu <b>masalah adalah elemen logis dari pekerjaan yang terdiri dari satu atau lebih tugas terpisah.</b>  <b>Tujuan kami adalah untuk mengoordinasikan proses penyebaran dengan profil risiko dari layanan ini</b> . <br><br>  Dalam lingkungan pengembangan atau pra-produksi, kami dapat membangun setiap jam dan secara otomatis mendistribusikan rilis setelah melewati semua pengujian.  Untuk layanan berorientasi pengguna yang besar, kami dapat memulai rilis dengan satu cluster, dan kemudian meningkatkan skalanya hingga kami memperbarui semua cluster.  <b>Untuk elemen infrastruktur penting, kami dapat memperpanjang periode implementasi hingga beberapa hari dan menjalankannya secara bergantian di wilayah geografis yang berbeda. â€</b> <br><br>  Dalam terminologi ini, kata-kata "rilis" dan "rilis" berarti apa yang disebut kosa kata umum sebagai "penyebaran", dan istilah yang sering digunakan untuk menggambarkan berbagai strategi <i>penempatan</i> (misalnya, penyebaran biru-hijau atau penyebaran kenari) mengacu pada <i>rilis yang</i> baru perangkat lunak. <br><br>  Selain itu, <i>pelepasan</i> aplikasi yang tidak berhasil dapat menyebabkan gangguan parsial atau signifikan dalam pekerjaan.  Pada tahap ini, <i>kembalikan</i> atau <i>perbaikan terbaru</i> juga dilakukan jika ternyata versi layanan yang baru <i>dirilis</i> tidak stabil. <br><br>  Proses <i>rilis</i> bekerja paling baik ketika itu otomatis dan berjalan <i>secara bertahap</i> .  Demikian juga, <i>kembalikan</i> atau <i>perbaikan terbaru</i> layanan lebih berguna ketika tingkat kesalahan dan frekuensi permintaan secara otomatis berkorelasi dengan baseline. <br><br><h3>  Tahap 3. Setelah rilis </h3><br>  Jika rilis <i>berjalan dengan lancar</i> dan versi baru dari layanan memproses data lingkungan produksi tanpa masalah yang jelas, kami dapat menganggapnya berhasil.  Rilis yang sukses diikuti oleh tahap yang bisa disebut "setelah rilis". <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-1" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="961811607759159296"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  Setiap sistem yang cukup kompleks akan <i>selalu</i> berada dalam kondisi kehilangan kinerja secara bertahap.  Ini tidak berarti bahwa <i>kembalikan</i> atau <i>perbaikan terbaru diperlukan</i> .  Sebagai gantinya, perlu untuk memantau penurunan tersebut (untuk berbagai keperluan operasional dan operasional) dan debug jika perlu.  Untuk alasan ini, pengujian setelah rilis tidak lagi seperti rutinitas, tetapi <i>debugging</i> atau pengumpulan data analitik. <br><br>  Secara umum, saya percaya bahwa setiap komponen sistem harus dibuat dengan mempertimbangkan fakta bahwa tidak satu pun sistem besar bekerja dengan sempurna 100% dan bahwa kerusakan harus diakui dan diperhitungkan pada tahap desain, pengembangan, pengujian, penyebaran, dan pemantauan perangkat lunak. menyediakan. <br><br><hr><br>  Sekarang kami telah mengidentifikasi tiga tahap produksi, mari kita lihat berbagai mekanisme pengujian yang tersedia pada masing-masing dari mereka.  Tidak semua orang memiliki kesempatan untuk mengerjakan proyek baru atau menulis ulang kode dari awal.  Dalam artikel ini, saya mencoba mengidentifikasi dengan jelas metode yang akan bekerja paling baik ketika mengembangkan proyek baru, serta berbicara tentang apa lagi yang bisa kita lakukan untuk mengambil keuntungan dari metode yang diusulkan tanpa membuat perubahan signifikan pada proyek yang bekerja. <br><br><h2>  Pengujian Penempatan </h2><br>  Kami memisahkan tahap penyebaran dan rilis dari satu sama lain, dan sekarang kami akan mempertimbangkan beberapa jenis pengujian yang dapat diterapkan setelah menerapkan kode di lingkungan produksi. <br><br><h3>  Pengujian integrasi </h3><br>  Biasanya, pengujian integrasi dilakukan oleh server integrasi berkelanjutan dalam lingkungan pengujian terisolasi untuk setiap cabang Git.  Salinan <i>seluruh</i> topologi layanan (termasuk basis data, antrian, proksi, dll.) Digunakan untuk ruang uji <i>semua</i> layanan yang akan bekerja sama. <br><br>  Saya percaya ini tidak terlalu efektif karena beberapa alasan.  Pertama-tama, lingkungan pengujian, seperti lingkungan pementasan, tidak dapat digunakan sedemikian rupa sehingga <i>identik dengan</i> lingkungan produksi nyata, <i>bahkan jika</i> pengujian dijalankan dalam wadah Docker yang sama yang akan digunakan dalam produksi.  Ini terutama benar ketika <i>satu</i> - <i>satunya hal</i> yang berjalan di lingkungan pengujian adalah tes itu sendiri. <br><br>  Terlepas dari apakah tes dijalankan sebagai wadah Docker atau proses POSIX, kemungkinan besar membuat <i>satu</i> atau lebih koneksi ke layanan, database, atau cache yang lebih unggul, yang jarang terjadi jika layanan berada dalam lingkungan produksi di mana ia dapat secara bersamaan proses beberapa koneksi konkuren, sering menggunakan kembali koneksi TCP yang tidak aktif (ini disebut reusing koneksi HTTP). <br><br>  Juga, masalah ini disebabkan oleh kenyataan bahwa sebagian besar tes di setiap mulai membuat tabel database baru atau ruang cache kunci pada <i>node yang sama di</i> mana tes ini dilakukan (dengan cara ini tes diisolasi dari kegagalan jaringan).  Jenis pengujian terbaik ini dapat menunjukkan bahwa sistem bekerja dengan benar dengan permintaan yang sangat spesifik.  Ini jarang efektif dalam mensimulasikan jenis kegagalan serius yang terdistribusi dengan baik, belum lagi berbagai jenis kegagalan parsial.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=http://">Ada</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">studi</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=http://">komprehensif</a> yang mengkonfirmasi bahwa sistem terdistribusi sering menunjukkan <i>perilaku tak terduga</i> yang tidak dapat diramalkan dengan analisis yang dilakukan secara berbeda dari seluruh sistem. <br><br>  Tetapi ini tidak berarti bahwa pengujian integrasi <i>pada prinsipnya</i> tidak berguna.  Kami hanya dapat mengatakan bahwa implementasi tes integrasi dalam lingkungan <i>buatan yang sepenuhnya terisolasi</i> , sebagai suatu peraturan, tidak masuk akal.  Pengujian integrasi masih harus dilakukan untuk memverifikasi bahwa versi layanan yang baru: <br><br><ul><li>  Tidak mengganggu interaksi dengan layanan hulu atau hilir; </li><li>  Tidak memengaruhi tujuan dan sasaran layanan yang lebih tinggi atau lebih rendah. </li></ul><br>  Yang pertama dapat diberikan sampai batas tertentu melalui pengujian kontrak.  <i>Karena</i> kenyataan bahwa <i>antarmuka</i> antara layanan bekerja dengan benar, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengujian kontrak</a> merupakan metode yang efektif untuk mengembangkan dan menguji layanan individual pada <i>tahap pra-produksi</i> , yang tidak memerlukan penyebaran seluruh topologi layanan. <br><br>  Platform pengujian kontrak yang berorientasi klien, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pact</a> , saat ini hanya mendukung interoperabilitas antar layanan melalui RESTful JSON RPC, meskipun kemungkinan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sedang dilakukan pekerjaan untuk mendukung interaksi asinkron melalui soket web, aplikasi non-server, dan antrian pesan</a> .  Dukungan untuk protokol gRPC dan GraphQL kemungkinan akan ditambahkan di masa depan, tetapi sekarang belum tersedia. <br><br>  Namun, sebelum <i>rilis</i> versi baru, mungkin perlu memeriksa tidak hanya operasi <i>antarmuka yang benar</i> . , , ,   RPC-            .    ,       , ,       . <br><br>  ,     <i></i> ,   â€” ,       <i>,  </i>    (  ,    ). <br>      :  <i></i>     ? <br><br>     .    â€“ ,       :    -   - ( C)   MySQL ( D)       memcache ( B). <br><br>   ,      (    ),  stateful-  stateless-        . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xl/nc/4e/xlnc4eni3elyx3huaw3trxs5uyc.jpeg"></div><br>  <i></i>  <i></i> ,     <i></i>      . <br><br>  service discovery        <i></i> ( ),      <i></i>  <i></i>        .         <i></i>   . <br><br> ,   <i></i>    C  . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ze/8y/yp/ze8yypuxevqszd_krd3cls4hrqc.jpeg"></div><br>  ,  <i></i>   ,        ,       .      ,       ,       .  ,     <i></i> ,        . <br><br>   Google     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Just Say No to More End-to-End Tests</a> (Â«      Â»),      : <br><br> Â« <i>       ( )      .       ,    ?           ,      </i> . <b>     ,     ,      ,     Â».</b> <br><br>    ,          :       <i></i>       .               ,       A        . <br><br>     ,     <i></i>   C     MySQL,     . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/c4/bu/qc/c4buqc8zz2dt4e3pyr6svjnyguc.jpeg"></div><br>  <i> </i>       (   ,   ,         Â«Â» ,  <i></i> ).     <i></i>   MySQL   ,    ,      . <br><br>   â€”        -.      ,      .              -,          . <br><br>    ,   -     <i></i>     ,   /: <br><br><ul><li>       C     /   ; </li><li>         ,   Â«Â»   . </li></ul><br>       <i>  </i>    ,             (,   ). <br><br>           ,    ,   <i></i>  .      IP- ,   ,    ,    ,       , ,  ,    ,    . <br><br> ,   ,     ,    ,       .      .     Facebook,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kraken</a> ,  : <br><br> Â« <i>   â€”     ,         .   -      ,    .        ,        .</i> <b>           -     ,     ,     ,       Â».</b> <br><br>   ,      ,       ,     ,         ,  . <br><br>     -     .    service mesh             .        -.        -,  ,  ,    : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uk/kv/cj/ukkvcjxlzn3hdcpt-mxsep3pojm.jpeg"></div><br>  Jika kami menguji layanan B, server proxy keluarnya dapat dikonfigurasi untuk menambahkan header <code>X-ServiceB-Test</code> untuk setiap permintaan pengujian.  Dalam hal ini, server proxy yang masuk dari layanan superior C akan dapat: <br><br><ul><li>  Deteksi tajuk ini dan kirim respons standar ke layanan B; </li><li>  Beri tahu Layanan C bahwa permintaan itu adalah <i>ujian</i> . </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3s/mr/-n/3smr-n7k-_87j3jjpirb02hkaja.jpeg"></div><br>  <i>Pengujian integrasi interaksi versi layanan B yang dikerahkan dengan versi layanan C yang dirilis, di mana operasi penulisan tidak pernah mencapai basis data</i> <br><br>  Melakukan pengujian integrasi dengan cara ini juga memungkinkan pengujian interaksi layanan B dengan layanan yang lebih tinggi <i>ketika mereka memproses data lingkungan produksi normal</i> - ini mungkin merupakan tiruan yang lebih dekat tentang bagaimana layanan B akan berperilaku ketika <i>dilepaskan</i> ke dalam produksi. <br><br>  Akan lebih baik jika setiap layanan dalam arsitektur ini mendukung panggilan API nyata dalam mode uji atau tiruan, memungkinkan Anda menguji pelaksanaan kontrak layanan dengan layanan hilir tanpa mengubah data nyata.  Ini sama dengan pengujian kontrak, tetapi pada tingkat jaringan. <br><br><h3>  Duplikasi data bayangan (menguji aliran data gelap atau mirroring) </h3><br>  Duplikasi bayangan (dalam artikel di blog Google itu disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">peluncuran gelap</a> , dan istilah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mirroring</a> digunakan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Istio</a> ) dalam banyak kasus memiliki kelebihan lebih dari pengujian integrasi. <br><br>  <a href="http://">Prinsip</a> - <a href="http://">prinsip Rekayasa Kekacauan</a> menyatakan sebagai berikut: <br><br>  â€œ <i>Sistem berperilaku berbeda tergantung pada lingkungan dan skema transfer data.</i>  <i>Karena mode penggunaan dapat berubah kapan saja</i> , <b>pengambilan sampel data nyata adalah satu-satunya cara yang dapat diandalkan untuk memperbaiki jalur permintaan. "</b> <br><br>  Duplikasi data bayangan adalah metode di mana aliran data lingkungan produksi yang memasuki layanan yang diberikan ditangkap dan direproduksi dalam versi layanan yang baru <i>digunakan</i> .  Proses ini dapat dilakukan baik secara waktu nyata, ketika aliran data yang masuk dipisah dan dikirim ke versi layanan yang <i>dirilis</i> dan <i>disebarkan</i> , atau secara asinkron, ketika salinan data yang sebelumnya diambil diputar kembali di layanan yang <i>digunakan</i> . <br><br>  Ketika saya bekerja di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">imgix</a> (startup dengan staf 7 insinyur, yang hanya empat adalah insinyur sistem), aliran data gelap secara aktif digunakan untuk menguji perubahan dalam infrastruktur visualisasi gambar kami.  Kami mendaftarkan persentase tertentu dari semua permintaan masuk dan mengirimkannya ke kluster Kafka - kami melewati log akses HAProxy ke pipa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">heka</a> , yang kemudian meneruskan aliran permintaan yang dianalisis ke kluster Kafka.  Sebelum tahap <i>rilis,</i> versi baru aplikasi pemrosesan gambar kami diuji pada aliran data gelap yang ditangkap - ini memungkinkan untuk memverifikasi bahwa permintaan diproses dengan benar.  Namun, sistem visualisasi gambar kami pada umumnya adalah layanan tanpa kewarganegaraan yang sangat cocok untuk jenis pengujian ini. <br><br>  Beberapa perusahaan lebih suka menangkap bukan bagian dari aliran data, tetapi mengirimkan <i>salinan lengkap</i> aliran ini ke versi aplikasi yang baru.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">McRouter Facebook</a> (proksi memcached) mendukung jenis duplikasi bayangan aliran data memcache. <br><br>  â€œ <i>Saat menguji instalasi baru untuk cache, kami merasa sangat nyaman untuk dapat mengalihkan salinan lengkap dari aliran data dari klien.</i>  <i>McRouter mendukung pengaturan duplikasi bayangan yang fleksibel.</i>  <i>Dimungkinkan untuk melakukan duplikasi bayangan dari kumpulan berbagai ukuran (dengan melakukan caching ulang ruang kunci), menyalin hanya bagian dari ruang kunci, atau secara dinamis mengubah parameter selama operasi</i> . " <br><br>  Aspek negatif dari duplikasi bayangan dari seluruh aliran data untuk layanan yang <i>digunakan</i> dalam lingkungan produksi adalah bahwa jika dijalankan pada saat intensitas transfer data maksimum, maka mungkin memerlukan daya dua kali lebih banyak. <br>  Proxy seperti Utusan mendukung duplikasi bayangan aliran data ke cluster lain dalam mode api-dan-lupa.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasinya</a> mengatakan: <br><br>  â€œ <i>Router dapat melakukan duplikasi bayangan aliran data dari satu cluster ke yang lain.</i>  <i>Saat ini, mode api-dan-lupa diimplementasikan, di mana server proxy Utusan tidak menunggu respons dari cluster bayangan sebelum mengembalikan respons dari cluster utama.</i>  <i>Untuk kelompok bayangan, semua statistik biasa dikumpulkan, yang berguna untuk tujuan pengujian.</i>  <i>Dengan duplikasi bayangan, opsi <code>-shadow</code> ditambahkan ke <code>-shadow</code> host / otoritas.</i>  <i>Ini berguna untuk masuk.</i>  <i>Sebagai contoh, <code>cluster1</code> berubah menjadi <code>cluster1-shadow</code></i> . " <br><br>  Namun, seringkali tidak praktis atau tidak mungkin untuk membuat replika kluster yang disinkronkan dengan produksi untuk pengujian (untuk alasan yang sama bahwa itu bermasalah untuk mengatur klaster pementasan yang disinkronkan).  Jika duplikasi bayangan digunakan untuk menguji layanan yang <i>digunakan</i> baru yang memiliki banyak dependensi, itu dapat memulai perubahan tak terduga dalam keadaan layanan tingkat yang lebih tinggi sehubungan dengan yang diuji.  Duplikasi bayangan dari volume harian pendaftaran pengguna dalam versi layanan yang digunakan dengan rekaman dalam basis data produksi dapat menyebabkan peningkatan tingkat kesalahan hingga 100% karena fakta bahwa aliran data bayangan akan dianggap sebagai upaya pendaftaran berulang dan ditolak. <br><br>  Pengalaman pribadi saya menunjukkan bahwa duplikasi bayangan paling cocok untuk menguji permintaan non-idempoten atau layanan stateless dengan bertopik sisi server.  Dalam hal ini, duplikasi bayangan data lebih sering digunakan untuk menguji beban, stabilitas, dan konfigurasi.  Pada saat yang sama, dengan bantuan pengujian atau pementasan integrasi, Anda dapat menguji bagaimana layanan berinteraksi dengan server stateful saat bekerja dengan permintaan non-idempoten. <br><br><h3>  Perbandingan TAP </h3><br>  Satu-satunya penyebutan istilah ini adalah dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> dari blog Twitter yang ditujukan untuk peluncuran layanan dengan kualitas layanan tingkat tinggi. <br><br>  <i>â€œUntuk memverifikasi kebenaran implementasi baru dari sistem yang ada, kami menggunakan metode yang disebut <b>perbandingan-tap</b> .</i>  <i>Alat perbandingan keran kami mereproduksi data produksi sampel dalam sistem baru dan membandingkan jawaban yang diterima dengan hasil yang lama.</i>  <i>Hasil yang diperoleh membantu kami menemukan dan memperbaiki kesalahan dalam sistem bahkan sebelum pengguna akhir menemukannya. "</i> <br><br>  Posting blog Twitter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lain</a> mendefinisikan perbandingan keran sebagai berikut: <br><br>  <i>"Mengirim permintaan ke layanan contoh dalam produksi dan dalam lingkungan pementasan dengan <b>memeriksa hasil</b> dan mengevaluasi karakteristik kinerja."</i> <br><br>  Perbedaan antara perbandingan keran dan duplikasi bayangan adalah bahwa dalam kasus pertama, respons yang dikembalikan oleh versi yang <i>dirilis</i> dibandingkan dengan respons yang dikembalikan oleh versi yang <i>digunakan</i> , dan pada yang kedua, permintaan tersebut digandakan ke versi yang <i>digunakan</i> dalam mode offline seperti api-dan-lupa. <br><br>  Alat lain untuk bekerja di area ini adalah perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ilmuwan</a> , tersedia di GitHub.  Alat ini dikembangkan untuk menguji kode Ruby, tetapi kemudian dipindahkan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa bahasa lain</a> .  Ini berguna untuk beberapa jenis pengujian, tetapi memiliki sejumlah masalah yang belum terpecahkan.  Inilah yang ditulis pengembang GitHub dalam satu komunitas Slack profesional: <br><br>  <i>â€œAlat ini hanya menjalankan dua cabang kode dan membandingkan hasilnya.</i>  <i>Anda harus berhati-hati dengan kode cabang-cabang ini.</i>  <i>Penting untuk memastikan bahwa permintaan basis data tidak digandakan jika ini menyebabkan masalah.</i>  <i>Saya pikir ini berlaku tidak hanya untuk seorang ilmuwan, tetapi juga untuk setiap situasi di mana Anda melakukan sesuatu dua kali, dan kemudian membandingkan hasilnya.</i>  <i>Alat ilmuwan diciptakan untuk memverifikasi bahwa sistem izin yang baru berfungsi sama dengan yang lama, dan pada waktu tertentu digunakan untuk membandingkan data yang khas untuk hampir setiap permintaan Rails.</i>  <i>Saya pikir prosesnya akan memakan waktu lebih lama, karena pemrosesan dilakukan berurutan, tetapi ini adalah masalah Ruby di mana utas tidak digunakan.</i> <i><br><br></i>  <i>Dalam kebanyakan kasus yang saya kenal, alat ilmuwan digunakan untuk bekerja dengan operasi baca daripada menulis, misalnya, untuk mengetahui apakah kueri baru yang ditingkatkan dan skema izin menerima jawaban yang sama seperti yang lama.</i>  <i>Kedua opsi dijalankan dalam lingkungan produksi (pada replika).</i>  <i>Jika sumber daya yang diuji memiliki efek samping, saya pikir pengujian harus dilakukan pada tingkat aplikasi. "</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Diffy</a> adalah alat open source tertulis Scala yang diperkenalkan oleh Twitter pada tahun 2015.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel</a> dari blog Twitter berjudul <b>Pengujian tanpa Menulis Tes</b> mungkin merupakan sumber terbaik untuk memahami bagaimana perbandingan kerja tap dalam praktik. <br><br>  <i>â€œDiffy mendeteksi kesalahan potensial dalam layanan dengan meluncurkan kode yang baru dan lama secara bersamaan.</i>  <i>Alat ini berfungsi sebagai server proxy dan mengirimkan semua permintaan yang diterima ke setiap instance yang berjalan.</i>  <i>Dia kemudian membandingkan respons dari instance dan melaporkan semua penyimpangan yang ditemukan selama perbandingan.</i>  <i>Diffy didasarkan pada gagasan berikut:</i> <b>jika dua implementasi suatu layanan mengembalikan jawaban yang sama dengan sejumlah permintaan yang cukup besar dan beragam, maka kedua implementasi ini dapat dianggap setara, dan yang lebih baru dari keduanya tanpa penurunan kinerja.</b>  <i>Teknik pengurangan noise inovatif Diffy membedakannya dari alat analisis regresi komparatif lainnya. "</i> <br><br>  Perbandingan keran sangat bagus ketika Anda perlu memeriksa apakah dua versi memberikan hasil yang sama.  Menurut Mark McBride, <br><br>  <i>â€œAlat Diffy sering digunakan dalam mendesain ulang sistem.</i>  <i>Dalam kasus kami, kami membagi basis kode sumber Rails menjadi beberapa layanan yang dibuat menggunakan Scala, dan sejumlah besar klien API menggunakan fungsi secara berbeda dari yang kami harapkan.</i>  <i>Fungsi seperti format tanggal sangat berbahaya. "</i> <br><br>  Perbandingan-tap bukanlah opsi terbaik untuk menguji aktivitas pengguna atau identitas perilaku dua versi layanan pada beban maksimum.  Seperti dengan duplikasi bayangan, efek samping tetap menjadi masalah yang belum terselesaikan, terutama ketika versi yang digunakan dan versi produksi menulis data ke database yang sama.  Seperti halnya pengujian integrasi, satu cara untuk mengatasi masalah ini adalah menggunakan tes perbandingan keran dengan hanya satu set akun yang terbatas. <br><br><h3>  Uji beban </h3><br>  Bagi mereka yang tidak terbiasa dengan stress testing, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> dapat berfungsi sebagai titik awal yang baik.  Tidak ada kekurangan alat dan platform untuk pengujian beban sumber terbuka.  Yang paling populer di antaranya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=http://">Apache Bench</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gatling</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wrk2</a> , <a href="http://">Tsung</a> , ditulis dalam bahasa Erlang, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Siege</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Iago</a> dari Twitter, ditulis dalam Scala (yang mereproduksi log dari server HTTP, server proxy atau penganalisa paket jaringan dalam contoh uji).  Beberapa ahli percaya bahwa alat terbaik untuk menghasilkan beban adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mzbench</a> , yang mendukung berbagai protokol, termasuk MySQL, Postgres, Cassandra, MongoDB, TCP, dll. Netflix's <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NDBench</a> adalah alat open source lain untuk memuat data gudang pengujian. , yang mendukung sebagian besar protokol yang dikenal. <br><br>  Blog Twitter resmi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Iago</a> menjelaskan secara lebih rinci fitur-fitur yang harus dimiliki generator beban yang baik: <br><br>  <i>â€œPermintaan non-pemblokiran dihasilkan pada frekuensi tertentu berdasarkan pada distribusi statistik khusus internal ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proses Poisson</a> dimodelkan secara default).</i>  <i>Frekuensi permintaan dapat diubah sesuai kebutuhan, misalnya, untuk menyiapkan cache sebelum bekerja dengan beban penuh.</i> <i><br><br></i>  <i>Secara umum, perhatian utama diberikan pada frekuensi permintaan sesuai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hukum Little</a> , dan bukan pada jumlah pengguna bersamaan, yang dapat bervariasi tergantung pada jumlah keterlambatan yang melekat dalam layanan ini.</i>  <i>Karena ini, peluang baru muncul untuk membandingkan hasil beberapa pengujian dan mencegah penurunan layanan, memperlambat pengoperasian generator beban.</i> <i><br><br></i>  <i>Dengan kata lain, alat Iago berupaya mensimulasikan sistem di mana permintaan diterima terlepas dari kemampuan layanan Anda untuk memprosesnya.</i>  <i>Dalam hal ini, ini berbeda dari generator beban yang mensimulasikan sistem tertutup di mana pengguna akan dengan sabar bekerja dengan penundaan yang ada.</i>  <i>Perbedaan ini memungkinkan kami untuk memodelkan mode kegagalan yang dapat ditemui dalam produksi dengan cukup akurat. "</i> <br><br>  Tipe lain dari pengujian beban adalah pengujian tegangan dengan mendistribusikan kembali aliran data.  Esensinya adalah sebagai berikut: seluruh aliran data dari lingkungan produksi diarahkan ke kluster yang lebih kecil daripada yang disiapkan untuk layanan;  jika ada masalah, aliran data ditransfer kembali ke kelompok yang lebih besar.  Teknik ini digunakan oleh Facebook, seperti yang dijelaskan dalam salah satu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel di blog resminya</a> : <br><br>  <i>â€œKami secara khusus mengarahkan aliran data yang lebih besar ke masing-masing cluster atau node, mengukur konsumsi sumber daya pada node-node ini dan menentukan batas-batas stabilitas layanan.</i>  <i>Jenis pengujian ini, khususnya, berguna untuk menentukan sumber daya CPU yang diperlukan untuk mendukung jumlah maksimum siaran simultan Facebook Live. "</i> <br><br>  Inilah yang ditulis oleh mantan insinyur LinkedIn di komunitas Slack profesional: <br><br>  <i>"LinkedIn juga menggunakan tes redline dalam produksi - server dihapus dari penyeimbang beban sampai beban mencapai nilai ambang batas atau kesalahan mulai terjadi."</i> <br><br>  Memang, pencarian Google menyediakan tautan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kertas putih penuh</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> blog LinkedIn tentang topik ini: <br><br>  <i>â€œSolusi Redliner untuk pengukuran menggunakan aliran data nyata dari lingkungan produksi, yang menghindari kesalahan yang mencegah pengukuran kinerja yang akurat di laboratorium.</i> <i><br><br></i>  <i>Redliner mengalihkan sebagian aliran data ke layanan yang diuji dan real-time menganalisis kinerjanya.</i>  <i>Solusi ini telah diterapkan di ratusan layanan LinkedIn internal dan digunakan setiap hari untuk berbagai jenis analisis kinerja.</i> <i><br><br></i>  <i>Redliner mendukung pelaksanaan uji paralel untuk mesin virtual kenari dan produksi.</i>  <b>Ini memungkinkan para insinyur untuk mentransfer jumlah data yang sama ke dua contoh layanan yang berbeda: 1) contoh layanan yang berisi inovasi, seperti konfigurasi baru, properti, atau kode baru;</b>  <b>2) contoh layanan dari versi kerja saat ini.</b> <br><br>  <i>"Hasil pengujian beban diperhitungkan saat membuat keputusan dan membantu mencegah penyebaran kode, yang dapat menyebabkan kinerja yang buruk."</i> <br><br>  Facebook mengambil pengujian beban menggunakan aliran data nyata ke tingkat yang sama sekali baru berkat sistem Kraken, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">deskripsinya</a> juga layak dibaca. <br>  Pengujian dilaksanakan dengan mendistribusikan kembali aliran data ketika mengubah nilai bobot (baca dari toko konfigurasi terdistribusi) untuk perangkat perbatasan dan kluster dalam konfigurasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proxygen</a> (penyeimbang beban Facebook).  Nilai-nilai ini menentukan volume data nyata yang dikirim, masing-masing, ke setiap cluster dan wilayah pada titik kehadiran tertentu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wk/0e/by/wk0ebyvdpznpgdgqcc_6zbu1g6g.png"></div><br>  <i>Data dari kertas putih Kraken</i> <br><br>  Sistem pemantauan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gorilla</a> ) menampilkan indikator berbagai layanan (seperti yang ditunjukkan pada tabel di atas).  Berdasarkan data pemantauan dan ambang batas, keputusan dibuat apakah akan mengirim data lebih lanjut sesuai dengan nilai bobot, atau apakah perlu untuk mengurangi atau bahkan sepenuhnya menghentikan transfer data ke cluster tertentu. <br><br><h2>  Tes konfigurasi </h2><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-2" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="916383043933192192"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  Gelombang baru alat infrastruktur sumber terbuka telah membuat menangkap semua perubahan infrastruktur dalam bentuk kode tidak hanya mungkin, tetapi juga relatif <i>mudah</i> .  Juga dimungkinkan untuk berbagai derajat untuk <i>menguji</i> perubahan-perubahan ini, meskipun sebagian besar <i>tes</i> infrastruktur-sebagai-a-kode pada tahap pra-produksi hanya dapat mengkonfirmasi spesifikasi dan sintaksis yang benar. <br><br>  Selain itu, penolakan untuk menguji konfigurasi baru sebelum <i>rilis</i> kode menjadi penyebab <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sejumlah besar gangguan</a> . <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-3" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="963093541575581696"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  Untuk pengujian menyeluruh terhadap perubahan konfigurasi, penting untuk membedakan antara berbagai jenis konfigurasi.  Fred Hebert pernah menyarankan menggunakan kuadran berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yv/fi/4i/yvfi4ioub6pkvt1mtzxvz2xuvnk.png"></div><br>  Opsi ini, tentu saja, tidak universal, tetapi perbedaan ini memungkinkan Anda untuk memutuskan cara terbaik untuk menguji masing-masing konfigurasi dan pada tahap apa untuk melakukannya.  Konfigurasi waktu pembuatan masuk akal jika Anda dapat memastikan pengulangan rakitan yang sebenarnya.  Tidak semua konfigurasi statis, tetapi pada platform modern perubahan konfigurasi dinamis tidak dapat dihindari (bahkan jika kita berurusan dengan "infrastruktur permanen"). <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-4" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1005924617981005824"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>       ,   ,       blue-green ,        .   ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jamie Wilkinson</a> ),  Google  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> : <br><br> <i>Â«        ,   ,   ,  -     .    .</i> <b>    -  ,         â€”  ,       ,   .        .</b> <br><br> <i>            ,  .     ,    , â€”    Â».</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  Facebook</a>             : <br><br> <i>Â«           .    â€”  ,              .             .        ,      .</i> <br><br><ul><li> <b>   </b> <br><br>             .  Facebook ,          .             ,     . </li><li> <b>   </b> <br><br>         (,  JSON).           ,           .          . <br><br>   (,  Facebook  Thrift)      .   ,           . </li><li> <b> </b> <br><br>         ,     ,    - .       .   â€” A/B-,        1 % .     A/B-,        .      A/B-    . ,  ,                 ,       ,     .  , A/B-    .      ,    A/B-.     Facebook        . <br><br> ,     A/B-  1% ,   1%     ,          (   Â«  Â»).          ,         .               ,      . </li><li> <b>  </b> <br><br>   Facebook            .       ,        .    ,              ,     .   ,  ,           . </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pembatalan perubahan yang sederhana dan nyaman</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dalam beberapa kasus, terlepas dari semua tindakan pencegahan, penerapan konfigurasi yang tidak aktif dilakukan. </font><font style="vertical-align: inherit;">Menemukan dan mengembalikan perubahan dengan cepat sangat penting untuk mengatasi masalah seperti itu. </font><font style="vertical-align: inherit;">"Alat kontrol versi tersedia di sistem konfigurasi kami yang membuatnya lebih mudah untuk membatalkan perubahan."</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk dilanjutkan! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD: berlanjut di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418081/">https://habr.com/ru/post/id418081/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418069/index.html">Memecahkan teka-teki silang warna Jepang dengan kecepatan cahaya</a></li>
<li><a href="../id418071/index.html">Industri TI untuk masyarakat: Festival TechTrain di St. Petersburg</a></li>
<li><a href="../id418075/index.html">5 hal TOP yang dapat dicetak pada printer 3D [video]</a></li>
<li><a href="../id418077/index.html">Kecelakaan "jangan tonton": pembenaran statistik untuk mode operasi dukungan teknis 24/7</a></li>
<li><a href="../id418079/index.html">Bahasa pemrograman paling populer - 2018</a></li>
<li><a href="../id418083/index.html">Server sederhana dengan GraphQL bukan REST, implementasi di java</a></li>
<li><a href="../id418085/index.html">Menggunakan Janji dalam JavaScript</a></li>
<li><a href="../id418087/index.html">80% dari checkout mandiri memiliki risiko</a></li>
<li><a href="../id418089/index.html">Ikhtisar Mesin Penggilingan SolidCraft CNC</a></li>
<li><a href="../id418091/index.html">Daftar artikel dan literatur tentang NAS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>