<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👆🏾 👨🏻‍🏫 🎾 CortexM3 / M4 (ARM) bande de bits matérielle, architecture du noyau, assembleur, C / C ++ 14 et une goutte de métaprogrammation 🌆 🐯 🙌🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Présentation 
 Attention, ce n'est pas un autre article «Hello world» sur la façon de faire clignoter une LED ou d'entrer dans sa première interruptio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CortexM3 / M4 (ARM) bande de bits matérielle, architecture du noyau, assembleur, C / C ++ 14 et une goutte de métaprogrammation</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454408/"><h2>  Présentation </h2><br>  Attention, ce n'est pas un autre article «Hello world» sur la façon de faire clignoter une LED ou d'entrer dans sa première interruption sur STM32.  Cependant, j'ai essayé de donner des explications complètes sur toutes les questions soulevées, donc l'article sera utile non seulement à de nombreux professionnels et rêvant de devenir de tels développeurs (comme j'espère), mais aussi aux programmeurs de microcontrôleurs débutants, car ce sujet pour une raison quelconque se déplace sur d'innombrables sites / blogs "Enseignants de programmation MK." <br><br><img src="https://habrastorage.org/webt/e5/rs/75/e5rs75rpejygxwippglfvpftzci.png" alt="image"><br><a name="habracut"></a><br><h2>  Pourquoi ai-je décidé d'écrire ceci? </h2><br>  Bien que j'aie exagéré, ayant dit plus tôt que le regroupement des bits matériels de la famille Cortex-M n'est pas décrit dans les ressources spécialisées, il existe encore des endroits où cette fonctionnalité est couverte (et a même rencontré un article ici), mais ce sujet doit clairement être complété et modernisé.  Je note que cela s'applique également aux ressources de langue anglaise.  Dans la section suivante, je vais expliquer pourquoi cette fonctionnalité du noyau peut être extrêmement importante. <br><br><h2>  Théorie </h2><br>  <i>(et ceux qui la connaissent peuvent se mettre immédiatement à la pratique)</i> <br>  La bande de bits matérielle est une caractéristique du cœur lui-même, et ne dépend donc pas de la famille et de la société du fabricant de microcontrôleurs, l'essentiel est que le cœur soit adapté.  Dans notre cas, que ce soit Cortex-M3.  Par conséquent, des informations sur cette question doivent être recherchées dans un document officiel sur le noyau lui-même, et il existe un tel document, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voici</a> , la section 4.2 décrit en détail comment utiliser cet outil. <br><br>  Ici, je voudrais faire une petite digression technique pour les programmeurs qui ne sont pas familiers avec l'assembleur, dont la majorité est maintenant, en raison de la complexité propagée et de l'inutilité de l'assembleur pour des microcontrôleurs 32 bits "sérieux" comme STM32, LPC, etc. De plus, on peut souvent rencontrer des tentatives censure pour l'utilisation d'assembleur dans ce domaine, même sur le Habr.  Dans cette section, je veux décrire brièvement le mécanisme d'écriture dans la mémoire MK, qui devrait clarifier les avantages de la bande de bits. <br><br>  Je vais expliquer un exemple simple et spécifique pour la plupart des STM32.  Supposons que je doive transformer PB0 en une sortie à usage général.  Une solution typique ressemblerait à ceci: <br><br><pre><code class="cpp hljs">GPIOB-&gt;MODER |= GPIO_MODER_MODER0_0;</code> </pre> <br>  Évidemment, nous utilisons le «OU» au niveau du bit afin de ne pas écraser les bits restants du registre. <br><br>  Pour le compilateur, cela se traduit par l'ensemble suivant de 4 instructions: <br><br><ol><li>  Téléchargez GPIOB-&gt; MODER dans le registre à usage général (RON) </li><li>  Téléchargez les valeurs dans l'autre RON à l'adresse indiquée dans le RON de l'élément 1 </li><li>  Effectuez un OU au niveau du bit de cette valeur avec GPIO_MODER_MODER0_0. </li><li>  Téléchargez le résultat dans GPIOB-&gt; MODER. </li></ol><br>  De plus, il ne faut pas oublier que ce noyau utilise le jeu d'instructions thumb2, ce qui signifie qu'ils peuvent être différents en volume.  Je note également que partout nous parlons du niveau d'optimisation O3. <br><br>  En langage d'assemblage, cela ressemble à ceci: <br><br><img src="https://habrastorage.org/webt/kt/px/tf/ktpxtfc4bapih79fj96yf7poi64.png" alt="image"><br><br>  On peut voir que la toute première instruction n'est rien de plus qu'une pseudo-instruction avec un décalage, on retrouve l'adresse du registre à l'adresse PC (compte tenu de la bande transporteuse) + 0x58. <br><br><img src="https://habrastorage.org/webt/wf/ar/ea/wfareavtgdjjmqckiemg0jfbygs.png" alt="image"><br><br>  Il s'avère que nous avons 4 étapes (et plus de cycles d'horloge) et 14 octets de mémoire occupée par opération. <br>  Si vous voulez en savoir plus à ce sujet, je recommande le livre [2], soit dit en passant, il y en a aussi en russe. <br><br><h3>  Nous passons à la méthode bit_banding. </h3><br>  L'essentiel, selon le paysan, est que le processeur dispose d'une zone mémoire spécialement allouée, écrivant les valeurs dans lesquelles nous ne modifions pas les autres bits du registre périphérique ou de la RAM.  Autrement dit, nous n'avons pas besoin de remplir les points 2) et 3) décrits ci-dessus, et pour cela il suffit de recompter l'adresse selon les formules de [1]. <br><br><img src="https://habrastorage.org/webt/t1/fo/yu/t1foyujiyauoiecjczide1myroi.png" alt="image"><br><br>  Nous essayons de faire une opération similaire, son assembleur: <br><br><img src="https://habrastorage.org/webt/j_/g-/6d/j_g-6dq9yi1cjt0yxbo7rzqbmrw.png" alt="image"><br><br>  Adresse recalculée: <br><br><img src="https://habrastorage.org/webt/du/1k/qp/du1kqpsrhjinmp6y4i2hkuqeut4.png" alt="image"><br><br>  Ici, nous avons ajouté une instruction d'écriture n ° 1 dans le RON, mais de toute façon, le résultat est de 10 octets, au lieu de 14, et quelques cycles d'horloge de moins. <br><br><h2>  Mais que faire si la différence est ridicule? </h2><br>  D'une part, les économies ne sont pas importantes, en particulier dans les cycles où il est déjà habituel d'overclocker le contrôleur à 168 MHz.  Dans un projet moyen, les moments où vous pouvez appliquer cette méthode seront respectivement de 40 à 80 octets, les économies pouvant atteindre 250 octets si les adresses diffèrent.  Et si nous considérons que la programmation de MK directement sur les registres est maintenant considérée comme «zashkvar», et qu'il est «cool» d'utiliser toutes sortes de dés, alors les économies peuvent être bien plus importantes. <br><br>  En outre, le chiffre de 250 octets est déformé par le fait que les bibliothèques de haut niveau sont activement utilisées dans la communauté, le micrologiciel se gonflant à des tailles indécentes.  Lors d'une programmation à bas niveau, cela représente au moins 2 à 5% du volume logiciel pour un projet moyen, avec une architecture compétente et une optimisation O3. <br><br>  <i>Encore une fois, je ne veux pas dire que c'est une sorte d'outil super super-duper-méga que tout programmeur MK qui se respecte devrait utiliser.</i>  <i>Mais si je peux réduire les coûts même avec une si petite pièce, alors pourquoi pas?</i> <br><br><h2>  Implémentation </h2><br>  Toutes les options ne seront données que pour configurer les périphériques, car je ne suis pas tombé sur une situation où cela serait nécessaire pour la RAM.  À strictement parler, pour la RAM, la formule est similaire, il suffit de changer les adresses de base pour le calcul.  Alors, comment implémentez-vous cela? <br><br><h4>  Assembleur </h4><br>  Allons du bas, de mon bien-aimé assembleur. <br><br>  Sur les projets d'assembleur, j'alloue généralement quelques RON de 2 octets (selon les instructions qui fonctionnent avec eux) sous # 0 et # 1 pour l'ensemble du projet, et les utilise également dans les macros, ce qui me réduit encore 2 octets sur une base continue.  Remarque, je n'ai pas trouvé CMSIS dans Assembler for STM, car j'ai tout de suite mis le numéro de bit dans la macro, et non sa valeur de registre. <br><br><div class="spoiler">  <b class="spoiler_title">Implémentation pour GNU Assembler</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">@  . MOVW R0, 0x0000 MOVW R1, 0x0001 @   .macro PeriphBitSet PerReg, BitNum LDR R3, =(BIT_BAND_ALIAS+(((\PerReg) - BIT_BAND_REGION) * 32) + ((\BitNum) * 4)) STR R1, [R3] .endm @   .macro PeriphBitReset PerReg, BitNum LDR R3, =(BIT_BAND_ALIAS+((\PerReg - BIT_BAND_REGION) * 32) + (\BitNum * 4)) STR R0, [R3] .endm</code> </pre> <br></div></div><br>  Exemples: <br><br><div class="spoiler">  <b class="spoiler_title">Exemples d'assembleurs</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">PeriphSet TIM2_CCR2, 0 PeriphBitReset USART1_SR, 5</code> </pre><br></div></div><br>  L'avantage incontestable de cette option est que nous avons un contrôle total, ce qui ne peut pas être dit sur d'autres options.  Et comme le montre la dernière section de l'article, en plus celle-ci est <b>très</b> importante. <br><br>  Cependant, personne n'a besoin de projets pour MK dans Assembler, à partir de la fin du zéro, ce qui signifie que vous devez passer en SI. <br><br><h4>  Plaine c </h4><br>  Honnêtement, une simple option Sishny a été trouvée par moi au début du chemin, quelque part dans le vaste réseau.  À cette époque, j'avais déjà implémenté le regroupement de bits dans Assembler, et suis tombé accidentellement sur un fichier C, cela a immédiatement fonctionné et j'ai décidé de ne rien inventer. <br><br><div class="spoiler">  <b class="spoiler_title">Implémentation pour plain C</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*!&lt;=================PLAIN C SECTION========================&gt;!*/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT31(A) (A==0x80000000)? 31 : 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT30(A) (A==0x40000000)? 30 : MASK_TO_BIT31(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT29(A) (A==0x20000000)? 29 : MASK_TO_BIT30(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT28(A) (A==0x10000000)? 28 : MASK_TO_BIT29(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT27(A) (A==0x08000000)? 27 : MASK_TO_BIT28(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT26(A) (A==0x04000000)? 26 : MASK_TO_BIT27(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT25(A) (A==0x02000000)? 25 : MASK_TO_BIT26(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT24(A) (A==0x01000000)? 24 : MASK_TO_BIT25(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT23(A) (A==0x00800000)? 23 : MASK_TO_BIT24(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT22(A) (A==0x00400000)? 22 : MASK_TO_BIT23(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT21(A) (A==0x00200000)? 21 : MASK_TO_BIT22(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT20(A) (A==0x00100000)? 20 : MASK_TO_BIT21(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT19(A) (A==0x00080000)? 19 : MASK_TO_BIT20(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT18(A) (A==0x00040000)? 18 : MASK_TO_BIT19(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT17(A) (A==0x00020000)? 17 : MASK_TO_BIT18(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT16(A) (A==0x00010000)? 16 : MASK_TO_BIT17(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT15(A) (A==0x00008000)? 15 : MASK_TO_BIT16(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT14(A) (A==0x00004000)? 14 : MASK_TO_BIT15(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT13(A) (A==0x00002000)? 13 : MASK_TO_BIT14(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT12(A) (A==0x00001000)? 12 : MASK_TO_BIT13(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT11(A) (A==0x00000800)? 11 : MASK_TO_BIT12(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT10(A) (A==0x00000400)? 10 : MASK_TO_BIT11(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT09(A) (A==0x00000200)? 9 : MASK_TO_BIT10(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT08(A) (A==0x00000100)? 8 : MASK_TO_BIT09(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT07(A) (A==0x00000080)? 7 : MASK_TO_BIT08(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT06(A) (A==0x00000040)? 6 : MASK_TO_BIT07(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT05(A) (A==0x00000020)? 5 : MASK_TO_BIT06(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT04(A) (A==0x00000010)? 4 : MASK_TO_BIT05(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT03(A) (A==0x00000008)? 3 : MASK_TO_BIT04(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT02(A) (A==0x00000004)? 2 : MASK_TO_BIT03(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT01(A) (A==0x00000002)? 1 : MASK_TO_BIT02(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MASK_TO_BIT(A) (A==0x00000001)? 0 : MASK_TO_BIT01(A) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BIT_BAND_PER(reg, reg_val) (*(volatile uint32_t*)(PERIPH_BB_BASE+32*((uint32_t)(&amp;(reg))-PERIPH_BASE)+4*((uint32_t)(MASK_TO_BIT(reg_val)))))</span></span></code> </pre><br></div></div><br>  Comme vous pouvez le voir, un morceau de code très simple et direct écrit dans le langage du processeur.  Le travail principal ici est la traduction des valeurs CMSIS en un nombre de bits, qui n'était pas nécessaire pour une version d'assembleur. <br><br>  Oh oui, utilisez cette option comme ceci: <br><br><div class="spoiler">  <b class="spoiler_title">Exemples pour C simple</b> <div class="spoiler_text"><pre> <code class="cpp hljs">BIT_BAND_PER(GPIOB-&gt;MODER, GPIO_MODER_MODER0_0) = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// BIT_BAND_PER(GPIOB-&gt;MODER, GPIO_MODER_MODER0_0) = 1; // (!0)</span></span></code> </pre><br></div></div><br>  Cependant, les tendances modernes (massivement, selon mes observations, approximativement à partir de 2015) sont en faveur du remplacement de C par C ++ même pour MK.  Et les macros ne sont pas l'outil le plus fiable, donc la prochaine version était destinée à naître. <br><br><h4>  Cpp03 </h4><br>  Ici, un très intéressant et discuté, mais peu utilisé au vu de sa complexité, avec un exemple farfelu de factorielle, un outil - la métaprogrammation arrive. <br><br>  Après tout, la tâche de traduire la valeur d'une variable en un nombre de bits est idéale (il existe déjà des valeurs dans CMSIS), et dans ce cas, elle est pratique pour le temps de compilation. <br><br>  J'ai implémenté cela comme suit en utilisant des modèles: <br><br><div class="spoiler">  <b class="spoiler_title">Implémentation pour C ++ 03</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> val, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> comp_val, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> cur_bit_num&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bit_num_from_value</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { bit_num = (val == comp_val) ? cur_bit_num : bit_num_from_value&lt;val, <span class="hljs-number"><span class="hljs-number">2</span></span> * comp_val, cur_bit_num + <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;::bit_num }; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> val&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bit_num_from_value</span></span></span><span class="hljs-class">&lt;val, static_cast&lt;uint32_t&gt;(0x80000000), static_cast&lt;uint32_t&gt;(31)&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { bit_num = <span class="hljs-number"><span class="hljs-number">31</span></span> }; }; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BIT_BAND_PER(reg, reg_val) *(reinterpret_cast</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;volatile uint32_t *&gt;(PERIPH_BB_BASE + 32 * (reinterpret_cast&lt;uint32_t&gt;(&amp;(reg)) - PERIPH_BASE) + 4 * (bit_num_from_value&lt;static_cast&lt;uint32_t&gt;(reg_val), static_cast&lt;uint32_t&gt;(0x01), static_cast&lt;uint32_t&gt;(0)&gt;::bit_num)))</span></span></span></span></code> </pre><br></div></div><br>  Vous pouvez l'utiliser de la même manière: <br><br><div class="spoiler">  <b class="spoiler_title">Exemples pour C ++ 03</b> <div class="spoiler_text"><pre> <code class="cpp hljs">BIT_BAND_PER(GPIOB-&gt;MODER, GPIO_MODER_MODER0_0) = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">// BIT_BAND_PER(GPIOB-&gt;MODER, GPIO_MODER_MODER0_0) = true; //</span></span></code> </pre><br></div></div><br>  Et pourquoi la macro est-elle restée?  Le fait est que je ne connais pas d'autre moyen d'insérer cette opération sans passer par une autre zone du code du programme.  Je serais très heureux s'ils m'ont incité dans les commentaires.  Ni les modèles ni les fonctions en ligne n'offrent une telle garantie.  Oui, et la macro ici remplit parfaitement sa tâche, il ne sert à rien de la changer simplement parce que quelqu'un de <s>conformiste</s> considère cela comme «non sûr». <br><br>  Étonnamment, le temps ne s'est pas arrêté, les compilateurs ont de plus en plus pris en charge le C ++ 14 / C ++ 17, pourquoi ne pas profiter des innovations, rendant le code plus compréhensible. <br><br><h4>  Cpp14 / cpp17 </h4><br><div class="spoiler">  <b class="spoiler_title">Implémentation pour C ++ 14</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bit_num_from_value_cpp14</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> comp_val, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bit_num)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bit_num = (val == comp_val) ? bit_num : bit_num_from_value_cpp14(val, <span class="hljs-number"><span class="hljs-number">2</span></span> * comp_val, bit_num + <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BIT_BAND_PER(reg, reg_val) *(reinterpret_cast</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;volatile uint32_t *&gt;(PERIPH_BB_BASE + 32 * (reinterpret_cast&lt;uint32_t&gt;(&amp;(reg)) - PERIPH_BASE) + 4 * (bit_num_from_value_cpp14(static_cast&lt;uint32_t&gt;(reg_val), static_cast&lt;uint32_t&gt;(0x01), static_cast&lt;uint32_t&gt;(0)))))</span></span></span></span></code> </pre><br></div></div><br>  Comme vous pouvez le voir, je viens de remplacer les modèles par une fonction constexpr récursive, qui, à mon avis, est plus claire pour l'œil humain. <br><br>  Utilisez de la même manière.  À propos, en C ++ 17, en théorie, vous pouvez utiliser la fonction récursive lambda constexpr, mais je ne suis pas sûr que cela conduira à au moins quelques simplifications et ne compliquera pas non plus l'ordre des assembleurs. <br><br>  <b>En résumé, les trois implémentations C / Cpp donnent un ensemble d'instructions tout aussi correct, selon la section Théorie.</b>  <b>Je travaille avec toutes les implémentations sur IAR ARM 8.30 et gcc 7.2.0 depuis longtemps.</b> <br><br><h2>  La pratique est une chienne </h2><br>  C'est tout, semble-t-il, arrivé.  Les économies de mémoire ont été calculées, l'implémentation choisie, prête à améliorer les performances.  Pas ici, c'était juste un cas de divergence de théorie et de pratique.  Et quand était-ce différent? <br><br>  Je ne l'aurais jamais publié si je ne l'avais pas testé, mais de façon réaliste, le volume occupé est réduit sur les projets.  J'ai spécifiquement sur quelques anciens projets remplacé cette macro par une implémentation régulière sans masque, et regardé la différence.  Le résultat surprend désagréablement. <br><br>  Il s'est avéré que le volume reste pratiquement inchangé.  J'ai spécifiquement choisi des projets où exactement 40 à 50 de ces instructions ont été utilisées.  Selon la théorie, je devais bien économiser au moins 100 octets, et au plus 200. En pratique, la différence s'est avérée être de 24 à 32 octets.  Mais pourquoi? <br><br>  Habituellement, lorsque vous configurez des périphériques, vous configurez 5 à 10 registres presque d'affilée.  Et à un niveau élevé d'optimisation, le compilateur n'organise pas les instructions exactement dans l'ordre des registres, mais organise les instructions comme il semble correct, les interférant parfois dans des endroits apparemment inextricables. <br><br>  Je vois deux options (voici mes spéculations): <br><br><ol><li>  Ou le compilateur est si intelligent qu'il sait pour vous comment il sera préférable d'optimiser l'ensemble des instructions </li><li>  Ou le compilateur n'est toujours pas plus intelligent qu'une personne, et se confond quand il rencontre de telles constructions </li></ol><br>  Autrement dit, il s'avère que cette méthode dans les langages «de haut niveau» à un niveau élevé d'optimisation ne fonctionne correctement que s'il n'y a pas d'opérations similaires à proximité d'une telle opération. <br><br>  Soit dit en passant, au niveau O0, la théorie et la pratique convergent en tout cas, mais je ne suis pas intéressé par ce niveau d'optimisation. <br><br><h2>  Je résume </h2><br>  Un résultat négatif est également un résultat.  Je pense que chacun tirera des conclusions pour lui-même.  Personnellement, je continuerai à utiliser cette technique, elle n'en sera certainement pas pire. <br><br>  J'espère que c'était intéressant et je veux exprimer un immense respect à ceux qui ont lu jusqu'au bout. <br><br><h2>  Liste de littérature </h2><br><ol><li>  «Manuel de référence technique Cortex-M3», section 4.2, ARM 2005. </li><li>  Le guide définitif de l'ARM Cortex-M3, Joseph Yiu. </li></ol><br>  PS J'ai dans mon sac une petite couverture des sujets liés au développement de l'électronique embarquée.  Faites-moi savoir, si vous êtes intéressé, je vais les obtenir lentement. <br><br>  PPS D'une manière ou d'une autre, il s'est avéré de manière tordue d'insérer des sections du code, veuillez me dire comment améliorer, si possible.  En général, vous pouvez copier un morceau de code d'intérêt dans le bloc-notes et éviter les émotions désagréables dans l'analyse. <br><br><h2>  UPD: </h2>  À la demande des lecteurs, j'indique que l'opération de bande de bits elle-même est atomique, ce qui nous donne une certaine sécurité lorsque vous travaillez avec des registres.  C'est l'une des caractéristiques les plus importantes de cette méthode. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454408/">https://habr.com/ru/post/fr454408/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454398/index.html">Des critiques aux algorithmes: comment la démocratie et la technocratie sont venues dans l'industrie musicale</a></li>
<li><a href="../fr454400/index.html">Rapports quotidiens sur l'état des machines virtuelles avec R et PowerShell</a></li>
<li><a href="../fr454402/index.html">Architecture de la machine d'état Unity pour l'organisation des comportements d'unité</a></li>
<li><a href="../fr454404/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 6. Remplissez les blancs (DHCP, TCP, «handshake», numéros de port communs)</a></li>
<li><a href="../fr454406/index.html">Akihabara: site de nidification des otaku</a></li>
<li><a href="../fr454410/index.html">Nouveau dans PHP 7.4</a></li>
<li><a href="../fr454414/index.html">SDL 2 Lessons: Lesson 2 - Main Non-Rubber</a></li>
<li><a href="../fr454416/index.html">Importer la distribution de distribution Hadoop</a></li>
<li><a href="../fr454418/index.html">Trois exemples non évidents d'utilisation de moteurs de modèle dans le backend</a></li>
<li><a href="../fr454420/index.html">Sauvegarde, Partie 3: Présentation et test de la duplicité, duplicati</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>