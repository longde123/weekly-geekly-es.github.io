<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëêüèΩ ü•Ñ ü•ß Scala + MXNet = Microservice dengan neuron in prod üë©üèø‚Äçüöí ‚ÜôÔ∏è üõ°Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ada sejumlah besar manual dan contoh di Internet, yang menjadi dasar Anda, para pembaca yang budiman, akan dapat ‚Äútanpa banyak kesulitan‚Äù dan dengan b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Scala + MXNet = Microservice dengan neuron in prod</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/439226/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/jw/cg/y4/jwcgy4upeqzycu6p2kxth9ok9iy.jpeg" width="500"></div><br>  Ada sejumlah besar manual dan contoh di Internet, yang menjadi dasar Anda, para pembaca yang budiman, akan dapat ‚Äútanpa banyak kesulitan‚Äù dan dengan biaya waktu ‚Äúminimal‚Äù menulis kode yang dapat membedakan kucing dari anjing dalam sebuah foto.  Dan mengapa kemudian membuang waktu untuk artikel ini? <br><br>  Menurut saya, yang utama dari semua contoh ini adalah kemungkinan yang terbatas.  Anda mengambil contoh - bahkan dengan jaringan saraf dasar yang ditawarkan penulis - meluncurkannya, bahkan mungkin berhasil, dan apa selanjutnya?  Bagaimana membuat kode sederhana ini mulai bekerja di server produksi?  Bagaimana cara memperbarui dan memeliharanya?  Di sinilah kesenangan dimulai.  Saya tidak dapat menemukan deskripsi lengkap dari proses dari saat "Ya, insinyur ML melatih jaringan saraf" hingga "akhirnya kami meluncurkannya ke dalam produksi".  Dan saya memutuskan untuk menutup celah ini. <br><a name="habracut"></a><br>  Saya tidak akan berbicara tentang cara mengajar jaringan saraf hal-hal lucu baru yang akan menyenangkan Anda dan membantu Anda mendapatkan banyak uang kertas renyah.  Ini adalah topik yang bagus untuk artikel terpisah.  Sebagai contoh, saya akan menggunakan jaringan saraf yang dapat diunduh secara bebas.  Tugas utama yang saya tetapkan sendiri adalah untuk memberikan deskripsi lengkap tentang proses memperkenalkan jaringan saraf ke dalam operasi. <br><br>  Saya segera menjawab pertanyaan "Mengapa tidak dengan Python?": Kami menggunakan Scala untuk solusi produksi karena penulisan kode multi-utas yang lebih nyaman dan stabil. <br><br><h1>  Isi </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1. Pernyataan masalah</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2. Teknologi yang digunakan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3. Mempersiapkan wadah buruh pelabuhan dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4. Struktur proyek</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">5. Pemuatan jaringan saraf</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6. Implementasi REST API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">7. Pengujian</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">8. Merakit layanan microser berdasarkan gambar dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">9. Memulai layanan microser pada server produksi dengan GPU</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kesimpulan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Referensi</a> <br><br><a name="1"></a><h1>  1. Pernyataan masalah </h1><br>  Misalkan kita memiliki database besar foto dengan objek yang berbeda, dan kita perlu membuat layanan mikro yang akan menerima gambar dalam permintaan HTTP POST dan merespons dalam format JSON.  Jawabannya harus berisi jumlah objek yang ditemukan dan kelas mereka, tingkat probabilitas bahwa ini persis objek kelas yang dideklarasikan, dan koordinat persegi panjang yang mencakup batas-batas setiap objek. <br><br><a name="2"></a><h1>  2. Teknologi yang digunakan </h1><br><ul><li>  Scala 2.12.7 + set minimum perpustakaan tambahan, Sbt 1.2.6 dengan plugin Sbt-pack 0.12 untuk membangun kode sumber. </li><li>  MXNet 1.3.1 (versi stabil terbaru pada saat penulisan), dikompilasi untuk Scala 2.12. </li><li>  Server dengan kartu grafis Nvidia. </li><li>  Cuda 9.0 dan Cudnn 7 diinstal pada server. </li><li>  Java 8 untuk menjalankan kode yang dikompilasi. </li><li>  Docker untuk kemudahan perakitan, pengiriman dan peluncuran microservice di server. </li></ul><br><a name="3"></a><h1>  3. Mempersiapkan wadah buruh pelabuhan dasar </h1><br>  Untuk layanan Microsoft kami, Anda akan memerlukan gambar Docker dasar di mana jumlah minimum dependensi yang diperlukan untuk menjalankan akan diinstal.  Untuk perakitan, kami akan menggunakan gambar dengan Sbt yang diinstal tambahan.  Ya, kami akan membangun sumbernya sendiri bukan di lingkungan lokal, tetapi di wadah Docker.  Ini akan memfasilitasi transisi lebih lanjut ke perakitan melalui CI, misalnya, melalui gitlab CI. <br><br>  Struktur folder: <br><br><pre><code class="plaintext hljs">\ | ----- install | | ----- java8.sh | | ----- mxnet_2_12.sh | | ----- opencv.sh | | ----- sbt.sh | | ----- scala.sh | | ----- timeZone.sh | ----- scala-mxnet-cuda-cudnn | ----- Dockerfile.2.12-1.3.1-9-7-builder | ----- Dockerfile.2.12-1.3.1-9-7-runtime</code> </pre> <br><h4>  Dockerfile.2.12-1.3.1-9-7-runtime </h4><br>  Gambar ini akan digunakan untuk peluncuran microservice terakhir.  Ini didasarkan pada gambar resmi dari Nvidia dengan CUDA 9.0 dan CUDNN yang telah diinstal 7. Dokumentasi untuk MXNet 1.3.1 mengklaim bekerja dengan CUDA 8.0, tetapi, seperti yang telah ditunjukkan, semuanya berjalan baik dengan versi 9.0, dan bahkan sedikit lebih cepat. <br><br>  Selain itu, kami akan menginstal Java 8, MXNet 1.3.1 (kami akan membangunnya di bawah Scala 2.12), OpenCV 3.4.3, dan utilitas Linux untuk mengatur zona waktu pada gambar ini. <br><br><pre> <code class="plaintext hljs">#        Nvidia  cuda 9.0  cudnn 7 FROM nvidia/cuda:9.0-cudnn7-devel AS builder #    ENV MXNET_VERSION 1.3.1 ENV MXNET_BUILD_OPT "USE_OPENCV=1 USE_BLAS=openblas USE_CUDA=1 USE_CUDA_PATH=/usr/local/cuda USE_CUDNN=1" ENV CUDA_STUBS_DIR "/usr/local/cuda-9.0/targets/x86_64-linux/lib/stubs" ENV OPEN_CV_VERSION 3.4.3 ENV OPEN_CV_INSTALL_PREFIX /usr/local ENV JAVA_HOME /usr/lib/jvm/java-8-oracle/ ENV TIME_ZONE Europe/Moscow #     COPY install /install RUN chmod +x -R /install/* #   RUN apt-get update WORKDIR /install RUN ./timeZone.sh ${TIME_ZONE} RUN ./java8.sh RUN ./mxnet_2_12.sh ${MXNET_VERSION} "${MXNET_BUILD_OPT}" ${CUDA_STUBS_DIR} RUN ./opencv.sh ${OPEN_CV_VERSION} ${OPEN_CV_INSTALL_PREFIX} #     RUN apt-get autoclean -y &amp;&amp; \ rm -rf /var/cache/* /install #       FROM nvidia/cuda:9.0-cudnn7-devel COPY --from=builder --chown=root:root / /</code> </pre> <br>  Script timeZone.sh java8.sh dan opencv.sh cukup sepele, jadi saya tidak akan membahasnya secara rinci, mereka disajikan di bawah ini. <br><br><h4>  timeZone.sh </h4><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh #         TIME_ZONE=${1} #       apt-get install -y tzdata &amp;&amp; \ ln -sf /usr/share/zoneinfo/$TIME_ZONE /etc/localtime &amp;&amp; \ dpkg-reconfigure -f noninteractive tzdata</span></span></code> </pre> <br><h4>  java8.sh </h4><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh #  Java 8 apt-get install -y software-properties-common &amp;&amp; \ add-apt-repository ppa:webupd8team/java -y &amp;&amp; \ apt-get update &amp;&amp; \ echo "oracle-java8-installer shared/accepted-oracle-license-v1-1 select true" | debconf-set-selections &amp;&amp; \ apt-get install -y oracle-java8-installer</span></span></code> </pre> <br><h4>  opencv.sh </h4><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh #   OpenCV     OPEN_CV_VERSION=${1} #        OPEN_CV_INSTALL_PREFIX=${2} OPEN_CV_TAR="http://github.com/opencv/opencv/archive/${OPEN_CV_VERSION}.tar.gz" #  OpenCV apt-get install -y wget build-essential cmake &amp;&amp; \ wget -qO- ${OPEN_CV_TAR} | tar xzv -C /tmp &amp;&amp; \ mkdir /tmp/opencv-${OPEN_CV_VERSION}/build &amp;&amp; \ cd /tmp/opencv-${OPEN_CV_VERSION}/build &amp;&amp; \ cmake -DBUILD_JAVA=ON -DCMAKE_INSTALL_PREFIX:PATH=${OPEN_CV_INSTALL_PREFIX} .. &amp;&amp; \ make -j$((`nproc`+1)) &amp;&amp; \ make install &amp;&amp; \ rm -rf /tmp/opencv-${OPEN_CV_VERSION}</span></span></code> </pre> <br>  Menginstal MXNet tidak sesederhana itu.  Faktanya adalah bahwa semua rakitan perpustakaan ini untuk Scala dibuat berdasarkan versi kompilator 2.11, dan ini dibenarkan, karena perpustakaan menyertakan modul untuk bekerja dengan Spark, yang, pada gilirannya, ditulis dalam Scala 2.11.  Menimbang bahwa kami menggunakan Scala 2.12.7 dalam pengembangan, perpustakaan yang dikompilasi tidak cocok untuk kami, dan kami tidak dapat turun ke versi 2.11. * Kami tidak bisa, karena banyaknya kode yang sudah ditulis pada Scala versi baru.  Apa yang harus dilakukan  Dapatkan banyak kesenangan mengumpulkan MXNet dari sumber untuk versi Scala kami.  Di bawah ini saya akan memberikan skrip untuk membangun dan menginstal MXNet 1.3.1 untuk Scala 2.12. * Dan mengomentari poin utama. <br><br><h4>  mxnet_2_12.sh </h4><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh #   MXNet     MXNET_VERSION=${1} #     ++  MXNet     MXNET_BUILD_OPT=${2} #       CUDA     CUDA_STUBS_DIR=${3} LD_LIBRARY_PATH="${LD_LIBRARY_PATH}:${CUDA_STUBS_DIR}" #       MXNet   apt-get install -y git build-essential libopenblas-dev libopencv-dev maven cmake &amp;&amp; \ git clone -b ${MXNET_VERSION} --recursive https://github.com/dmlc/mxnet /tmp/mxnet &amp;&amp; \ cd /tmp/mxnet &amp;&amp; \ make -j $(nproc) ${MXNET_BUILD_OPT} &amp;&amp; \ ln -s ${CUDA_STUBS_DIR}/libcuda.so ${CUDA_STUBS_DIR}/libcuda.so.1 &amp;&amp; \ sed -rim 's/([a-zA-Z])_2.11/\1_2.12/g' $(find scala-package -name pom.xml) &amp;&amp; \ sed -im 's/SCALA_VERSION_PROFILE := scala-2.11/SCALA_VERSION_PROFILE := scala-2.12/g' Makefile &amp;&amp; \ sed -im 's/&lt;module&gt;spark&lt;\/module&gt;/&lt;\!--&lt;module&gt;spark&lt;\/module&gt;--&gt;/g' scala-package/pom.xml &amp;&amp; \ make scalapkg ${MXNET_BUILD_OPT} &amp;&amp; \ mkdir -p /usr/local/share/mxnet/scala/linux-x86_64-gpu &amp;&amp; \ mv /tmp/mxnet/scala-package/assembly/linux-x86_64-gpu/target/mxnet-full_2.12-linux-x86_64-gpu-${MXNET_VERSION}-SNAPSHOT.jar /usr/local/share/mxnet/scala/linux-x86_64-gpu/mxnet-full_2.12-linux-x86_64-gpu-${MXNET_VERSION}-SNAPSHOT.jar &amp;&amp; \ rm -rf /tmp/mxnet &amp;&amp; rm -rf /root/.m2</span></span></code> </pre> <br>  Bagian yang paling menarik dimulai dengan baris ini: <br><br><pre> <code class="bash hljs">ln -s <span class="hljs-variable"><span class="hljs-variable">${CUDA_STUBS_DIR}</span></span>/libcuda.so <span class="hljs-variable"><span class="hljs-variable">${CUDA_STUBS_DIR}</span></span>/libcuda.so.1 &amp;&amp; \</code> </pre> <br>  Jika Anda menjalankan perakitan MXNet seperti dalam instruksi, kami akan mendapatkan kesalahan.  Kompiler tidak dapat menemukan perpustakaan libcuda.so.1, jadi kami akan menautkan dari perpustakaan libcuda.so ke libcuda.so.1.  Ini mungkin tidak mengganggu Anda, ketika Anda memulainya di server produksi, kami akan mengganti perpustakaan ini dengan yang lokal.  Perhatikan juga bahwa jalur ke pustaka CUDA dari variabel lingkungan <code>CUDA_STUBS_DIR</code> telah ditambahkan ke <code>LD_LIBRARY_PATH</code> .  Jika ini tidak dilakukan, maka perakitan juga akan gagal. <br><br>  Pada baris ini, kami mengganti versi Scala 2.11 dengan 2.12 di semua file yang diperlukan menggunakan ekspresi reguler, yang dipilih secara eksperimental, karena tidak cukup hanya mengganti 2.11 di mana-mana dengan 2.12: <br><br><pre> <code class="bash hljs">sed -rim <span class="hljs-string"><span class="hljs-string">'s/([a-zA-Z])_2.11/\1_2.12/g'</span></span> $(find scala-package -name pom.xml) &amp;&amp; \ sed -im <span class="hljs-string"><span class="hljs-string">'s/SCALA_VERSION_PROFILE := scala-2.11/SCALA_VERSION_PROFILE := scala-2.12/g'</span></span> Makefile &amp;&amp; \ sed -im <span class="hljs-string"><span class="hljs-string">'s/&lt;module&gt;spark&lt;\/module&gt;/&lt;\!--&lt;module&gt;spark&lt;\/module&gt;--&gt;/g'</span></span> scala-package/pom.xml &amp;&amp; \ make scalapkg <span class="hljs-variable"><span class="hljs-variable">${MXNET_BUILD_OPT}</span></span> &amp;&amp; \</code> </pre> <br>  Dan kemudian ketergantungan pada modul untuk bekerja dengan Spark dikomentari.  Jika ini tidak dilakukan, perpustakaan tidak akan dirakit. <br><br>  Selanjutnya, jalankan perakitan, seperti yang ditunjukkan dalam instruksi, salin perpustakaan yang dirakit ke folder bersama dan hapus semua sampah yang dipompa Maven selama proses membangun (jika ini tidak dilakukan, gambar akhir akan tumbuh sekitar 3-4 GB, yang dapat menyebabkan DevOps Anda S gugup). <br><br>  Kami mengumpulkan gambar, berada di direktori root proyek (lihat. Struktur folder): <br><br><pre> <code class="bash hljs">your@pc$ docker build -f Dockerfile.2.12-1.3.1-9-7-runtime -t entony/scala-mxnet-cuda-cudnn:2.12-1.3.1-9-7-runtime .</code> </pre> <br>  Biarkan saya mengingatkan Anda untuk berjaga-jaga jika titik di bagian akhir mengatakan bahwa kami sedang melakukan perakitan dalam konteks direktori saat ini. <br><br>  Sekarang saatnya berbicara tentang build image. <br><br><h4>  Dockerfile.2.12-1.3.1-9-7-builder </h4><br><pre> <code class="plaintext hljs">#         runtime-,    FROM entony/scala-mxnet-cuda-cudnn:2.12-1.3.1-9-7-runtime #    ENV SCALA_VERSION 2.12.7 ENV SBT_VERSION 1.2.6 #     COPY install /install RUN chmod +x -R /install/* #       RUN apt-get update &amp;&amp; \ cd /install &amp;&amp; \ ./scala.sh ${SCALA_VERSION} &amp;&amp; \ ./sbt.sh ${SBT_VERSION} #   RUN rm -rf /install</code> </pre> <br>  Sederhana saja, kita tidak perlu Scala dan Sbt untuk memulai layanan microser kami, jadi tidak ada gunanya menyeret mereka ke gambar dasar untuk diluncurkan.  Oleh karena itu, kami akan membuat gambar terpisah yang hanya akan digunakan untuk perakitan.  Skrip scala.sh dan sbt.sh cukup sepele dan saya tidak akan membahasnya secara rinci. <br><br><h4>  scala.sh </h4><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh #   Scala     SCALA_VERSION=${1} SCALA_DEB="http://www.scala-lang.org/files/archive/scala-${SCALA_VERSION}.deb" #  Scala apt-get install -y wget &amp;&amp; \ wget -q ${SCALA_DEB} -O /tmp/scala.deb &amp;&amp; dpkg -i /tmp/scala.deb &amp;&amp; \ scala -version &amp;&amp; \ rm /tmp/scala.deb</span></span></code> </pre> <br><h4>  sbt.sh </h4><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh #   Sbt     SBT_VERSION=${1} SBT_DEB="http://dl.bintray.com/sbt/debian/sbt-${SBT_VERSION}.deb" #  Sbt apt-get install -y wget &amp;&amp; \ wget -q ${SBT_DEB} -O /tmp/sbt.deb &amp;&amp; dpkg -i /tmp/sbt.deb &amp;&amp; \ sbt sbtVersion &amp;&amp; \ rm /tmp/sbt.deb</span></span></code> </pre> <br>  Kami mengumpulkan gambar, berada di direktori root proyek (lihat. Struktur folder): <br><br><pre> <code class="bash hljs">your@pc$ docker build -f Dockerfile.2.12-1.3.1-9-7-builder -t entony/scala-mxnet-cuda-cudnn:2.12-1.3.1-9-7-builder .</code> </pre> <br>  Di akhir artikel ada tautan ke repositori dengan semua file ini. <br><br><a name="4"></a><h1>  4. Struktur proyek </h1><br>  Setelah selesai mempersiapkan untuk perakitan proyek, mari kita lakukan apa yang Anda putuskan untuk menghabiskan waktu untuk artikel ini. <br><br>  Proyek microservice kami akan memiliki struktur berikut: <br><br><pre> <code class="plaintext hljs">\ | ----- dependencies | | ----- mxnet-full_2.12-linux-x86_64-gpu-1.3.1-SNAPSHOT.jar | ----- models | | ----- resnet50_ssd_model-0000.params | | ----- resnet50_ssd_model-symbol.json | | ----- synset.txt | ----- project | | ----- build.properties | | ----- plugins.sbt | ----- src | | ----- main | | | ----- resources | | | | ----- cat_and_dog.jpg | | | ----- scala | | | | ----- simple.predictor | | | | ----- Config | | | | ----- Model | | | | ----- Server | | | | ----- Run | | ----- test | | | ----- scala | | | | ----- simple.predictor | | | | ----- ServerTest | ----- build.sbt | ----- Dockerfile</code> </pre> <br>  Ini adalah struktur standar proyek Scala, dengan pengecualian direktori dan dependensi direktori. <br>  Direktori dependensi berisi perpustakaan MXNet untuk Scala.  Itu dapat diperoleh dengan dua cara: <br><br><ul><li>  membangun MXNet di mesin tempat Anda akan mengembangkan (perhatikan bahwa perpustakaan tidak lintas platform; jika Anda membangunnya di Linux, itu tidak akan berfungsi pada Mac OS), </li><li>  atau tarik keluar dari gambar Docker yang kami buat sebelumnya.  Jika Anda memutuskan untuk membangun MXNet di lingkungan lokal, maka skrip mxnet_2.12.sh akan membantu Anda. </li></ul><br>  Anda dapat menarik pustaka dari gambar Docker seperti ini: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   your@pc$ mkdir dependencies #  Docker-    your@pc$ docker run -it --rm -v $(pwd)/dependencies:/tmp/dependencies entony/scala-mxnet-cuda-cudnn:2.12-1.3.1-9-7-runtime #          ab38e73d93@root$ cp /usr/local/share/mxnet/scala/linux-x86_64-gpu/mxnet-full_2.12-linux-x86_64-gpu-1.3.1-SNAPSHOT.jar /tmp/dependencies/mxnet-full_2.12-linux-x86_64-gpu-1.3.1-SNAPSHOT.jar ab38e73d93@root$ exit #  , ! your@pc$ ls dependencies/ mxnet-full_2.12-linux-x86_64-gpu-1.3.1-SNAPSHOT.jar</span></span></code> </pre> <br>  Direktori models berisi file-file dari jaringan saraf yang terlatih, Anda dapat mengunduhnya secara bebas sebagai berikut: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   your@pc$ mkdir models #     your@pc$ wget https://s3.amazonaws.com/model-server/models/resnet50_ssd/resnet50_ssd_model-symbol.json -P models your@pc$ wget https://s3.amazonaws.com/model-server/models/resnet50_ssd/resnet50_ssd_model-0000.params -P models your@pc$ wget https://s3.amazonaws.com/model-server/models/resnet50_ssd/synset.txt -P models</span></span></code> </pre> <br>  Selanjutnya secara singkat tentang file yang tidak menarik, tetapi berperan dalam proyek ini. <br><br><h4>  project / build.properties </h4><br><pre> <code class="scala hljs">#   <span class="hljs-type"><span class="hljs-type">Sbt</span></span>,   sbt.version = <span class="hljs-number"><span class="hljs-number">1.2</span></span><span class="hljs-number"><span class="hljs-number">.6</span></span></code> </pre> <br><h4>  project / plugins.sbt </h4><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//    sbt-pack addSbtPlugin("org.xerial.sbt" % "sbt-pack" % "0.12")</span></span></code> </pre> <br><h4>  src / main / resources / cat_and_dog.jpg </h4><br>  Gambaran yang begitu indah, di mana jaringan saraf kita akan mencari kucing dan anjing. <br><img src="https://habrastorage.org/getpro/habr/post_images/b6b/8ed/425/b6b8ed425ab6affb5cce1e83731b35a9.png"><br><br><h4>  build.sbt </h4><br><pre> <code class="scala hljs">enablePlugins(<span class="hljs-type"><span class="hljs-type">PackPlugin</span></span>) name := <span class="hljs-string"><span class="hljs-string">"simple-predictor"</span></span> version := <span class="hljs-string"><span class="hljs-string">"0.1"</span></span> scalaVersion := <span class="hljs-string"><span class="hljs-string">"2.12.7"</span></span> unmanagedBase := baseDirectory.value / <span class="hljs-string"><span class="hljs-string">"dependencies"</span></span> <span class="hljs-comment"><span class="hljs-comment">//  (   ) libraryDependencies ++= Seq( "org.json4s" %% "json4s-native" % "3.6.1", "org.scalatest" %% "scalatest" % "3.0.5" % Test, "org.scalaj" %% "scalaj-http" % "2.4.1" % Test ) //       packMain := Map("simple-predictor" -&gt; "simple.predictor.Runs") //    bat-,      ,   Linux packGenerateWindowsBatFile := false //    JVM packJvmOpts := Map("simple-predictor" -&gt; Seq( "-Xms3g", "-Xmx5g"))</span></span></code> </pre> <br><h4>  simple.predictor.Config </h4><br>  Objek ini menyimpan variabel global yang nilainya dibaca dari variabel lingkungan atau ditetapkan secara default. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> simple.predictor <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.mxnet.<span class="hljs-type"><span class="hljs-type">Context</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.util.<span class="hljs-type"><span class="hljs-type">Try</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    REST API val host: String = env("REST_HOST") getOrElse "0.0.0.0" //    REST API val port: Int = env("REST_PORT") flatMap (p =&gt; Try(p.toInt).toOption) getOrElse 8080 // URL,     POST-   val entryPoint: String = env("REST_ENTRY_POINT") getOrElse "/predict" //  ,       val threshold: Float = env("PROBABILITY_MORE") flatMap (p =&gt; Try(p.toFloat).toOption) getOrElse 0.5f //        val modelPrefix: String = env("MODEL_PREFIX") getOrElse "models/resnet50_ssd_model" //    (    ...-0000.params) val modemEpoch: Int = env("MODEL_EPOCH") flatMap (p =&gt; Try(p.toInt).toOption) getOrElse 0 //   ,     ,    512 val modemEdge: Int = env("MODEL_EDGE") flatMap (p =&gt; Try(p.toInt).toOption) getOrElse 512 //  ,   CPU ( ).  production  GPU val context: Context = env("MODEL_CONTEXT_GPU") flatMap { isGpu =&gt; Try(if (isGpu.toBoolean) Context.gpu() else Context.cpu()).toOption } getOrElse Context.cpu() private def env(name: String) = Option(System.getenv(name)) }</span></span></code> </pre> <br><h4>  simple.predictor.Run </h4><br>  Objek Run adalah titik masuk ke aplikasi. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> simple.predictor <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.<span class="hljs-type"><span class="hljs-type">InetSocketAddress</span></span> <span class="hljs-comment"><span class="hljs-comment">//     import simple.predictor.Config._ object Run extends App { //     REST- val model = new Model(modelPrefix, modemEpoch, modemEdge, threshold, context) val server = new Server(new InetSocketAddress(host, port), entryPoint, model) //   Ctrl + C    Runtime.getRuntime.addShutdownHook(new Thread(() =&gt; server.stop())) //      try server.start() catch { case ex: Exception =&gt; ex.printStackTrace() } }</span></span></code> </pre> <br><a name="5"></a><h1>  5. Pemuatan jaringan saraf </h1><br>  Jaringan saraf dimuat dalam konstruktor kelas <code>simple.predictor.Model</code> . <br><br><h4>  simple.predictor.Model </h4><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> simple.predictor <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.awt.image.<span class="hljs-type"><span class="hljs-type">BufferedImage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.mxnet._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.mxnet.infer.<span class="hljs-type"><span class="hljs-type">ObjectDetector</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> simple.predictor.<span class="hljs-type"><span class="hljs-type">Model</span></span>.<span class="hljs-type"><span class="hljs-type">Prediction</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">prefix: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, epoch: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, imageEdge: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, threshold: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-class"><span class="hljs-params">, context: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Context</span></span></span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       val initShape = Shape(1, 3, imageEdge, imageEdge) val initData = DataDesc(name = "data", initShape, DType.Float32, Layout.NCHW) //           val model = new ObjectDetector(prefix, IndexedSeq(initData), context, Option(epoch)) //         ,       JSON private def toPrediction(originWidth: Int, originHeight: Int)(predict: (String, Array[Float])): Prediction = { val (objectClass, Array(probability, kx, ky, kw, kh)) = predict //        val x = (originWidth * kx).toInt val y = (originHeight * ky).toInt val w = (originWidth * kw).toInt val h = (originHeight * kh).toInt val width = if ((x + w) &lt; originWidth) w else originWidth - x val height = if (y + h &lt; originHeight) h else originHeight - y Prediction(objectClass, probability, x, y, width, height) } //     ,         ,     threshold def predict(image: BufferedImage): Seq[Prediction] = model.imageObjectDetect(image).head map toPrediction(image.getWidth, image.getHeight) filter (_.probability &gt; threshold) } object Model { //   case class Prediction(objectClass: String, probability: Float, x: Int, y: Int, width: Int, height: Int) }</span></span></code> </pre> <br>  Di bagian <code>     </code> Anda mengatakan bahwa dalam jaringan saraf itu akan bekerja dengan <code>NDArray</code> dengan dimensi 1 x 3 x 512 x 512, di mana 1 adalah jumlah gambar yang akan terkandung dalam NDArray, 3 adalah jumlah warna, dan 512 x 512 - ukuran gambar (nilai <code>imageEdge = 12</code> diatur dalam objek <code>simple.predict.Config</code> , ini adalah ukuran sisi gambar yang digunakan untuk melatih jaringan saraf).  Semua deskripsi data ini diteruskan ke <code>ObjectDetector</code> . <br><br>  Bagian lain yang menarik adalah <code>      </code> . <br><br>  Setelah menjalankan gambar melalui jaringan saraf, hasilnya adalah dari tipe <code>Seq[Seq[(String, Array[Float])]]</code> .  Koleksi pertama hanya berisi satu hasil (format data ditentukan oleh jaringan saraf tertentu), maka setiap elemen koleksi berikutnya adalah tupel dari dua elemen: <br><br><ol><li>  nama kelas ("kucing", "anjing", ...), </li><li>  array dari lima angka floating point: yang pertama adalah probabilitas, yang kedua adalah koefisien untuk menghitung koordinat <code>x</code> , yang ketiga adalah koefisien untuk menghitung koordinat <code>y</code> , yang keempat adalah koefisien untuk menghitung lebar persegi panjang, dan yang kelima adalah koefisien untuk menghitung ketinggian persegi panjang. </li></ol><br>  Untuk mendapatkan koordinat aktual dan ukuran persegi panjang, Anda perlu mengalikan lebar asli dan tinggi gambar dengan koefisien yang sesuai. <br>  Saya membiarkan diri saya sedikit menyimpang tentang topik <code>NDArray</code> .  Ini adalah array multidimensi yang dibuat MXNet dalam konteks tertentu (CPU atau GPU).  Saat membuat NDArray, objek C ++ terbentuk, objek yang dengannya operasi dilakukan dengan sangat cepat (dan jika dibuat dalam konteks GPU, itu hampir seketika), tetapi Anda harus membayar untuk kecepatan tersebut.  Akibatnya (setidaknya dalam versi MXNet 1.3.1) Anda perlu mengelola memori yang dialokasikan secara <code>NDArray</code> untuk <code>NDArray</code> , dan jangan lupa untuk membongkar objek-objek ini dari memori setelah Anda selesai bekerja dengannya.  Jika tidak, akan ada kebocoran memori yang signifikan dan cukup cepat, yang sangat tidak nyaman untuk dipantau, karena program untuk profil JVM tidak melihatnya.  Masalah memori diperburuk jika Anda bekerja dalam konteks GPU, karena kartu video tidak memiliki banyak memori dan aplikasi macet dengan cepat kehabisan memori. <br><br>  Bagaimana mengatasi masalah kebocoran memori? <br><br>  Dalam contoh di atas, pada model <code>model.imageObjectDetect(image).head map toPrediction(image.getWidth, image.getHeight) filter (_.probability &gt; threshold)</code> , metode <code>imageObjectDetect</code> digunakan untuk menjalankan gambar melalui jaringan saraf, yang menerima input <code>BufferedImage</code> .  Semua konversi ke dan dari <code>NDArray</code> dilakukan di dalam metode, dan Anda tidak perlu memikirkan masalah alokasi memori.  Di sisi lain, sebelum mengubah <code>BufferedImage</code> ke <code>NDArray</code> dilakukan pada ukuran 512 x 512 dan gambar dinormalisasi menggunakan metode objek objek tipe <code>BufferedImage</code> .  Ini terjadi sedikit lebih lama daripada ketika menggunakan OpenCV, misalnya, tetapi ini memecahkan masalah membebaskan memori setelah menggunakan <code>NDArray</code> . <br><br>  Anda dapat, tentu saja, menggunakan OpenCV dan mengontrol memori sendiri, untuk ini Anda hanya perlu memanggil metode <code>NDArray</code> <code>dispose</code> , tetapi untuk beberapa alasan Anda lupa menyebutkan ini dalam dokumentasi MXNet resmi untuk Scala. <br><br>  MXNet juga memiliki cara yang tidak terlalu nyaman untuk mengontrol kebocoran memori yang terjadi karena <code>NDArray</code> .  Untuk melakukan ini, jalankan aplikasi dengan parameter JVM <code>Dmxnet.traceLeakedObjects=true</code> .  Jika MXNet memperhatikan <code>NDArray</code> yang tidak digunakan tetapi tergantung pada memori, Anda akan mendapatkan pengecualian yang menunjukkan baris kode mana <code>NDArray</code> naas <code>NDArray</code> . <br><br>  Saran saya: bekerja langsung dengan NDArray, hati-hati memonitor memori dan menulis normalisasi sendiri, setelah sebelumnya menentukan algoritma apa yang dilakukan insinyur ML ketika melatih jaringan saraf, jika tidak hasilnya akan sangat berbeda.  <code>ObjectDetector</code> memiliki metode <code>objectDetectWithNDArray</code> mana Anda dapat melewati <code>NDArray</code> .  Untuk menerapkan pendekatan yang lebih universal untuk memuat jaringan saraf, saya sarankan menggunakan objek <code>org.apache.mxnet.module.Module</code> .  Di bawah ini adalah contoh penggunaan. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.mxnet._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.mxnet.io.<span class="hljs-type"><span class="hljs-type">NDArrayIter</span></span> <span class="hljs-comment"><span class="hljs-comment">//      val model: Module = { val model = Module.loadCheckpoint(modelPrefix, modelEpoch, contexts = contexts) model.bind( forTraining = false, inputsNeedGrad = false, forceRebind = false, dataShape = DataDesc(name = "data", Shape(1, 3, 512, 512), DType.Float32, Layout.NCHW)) model.initParams() model } // NDArray  1  3  512  512 val image: NDArray = ??? //  dataBatch      val iterator = new NDArrayIter(IndexedSeq(image)) val dataBatch = iterator.next() image.dispose() //   val result: Seq[Array[Float]] = model.predict(dataBatch) map { ndArray =&gt; val array = ndArray.toArray ndArray.dispose() array } dataBatch.dispose()</span></span></code> </pre> <br><a name="6"></a><h1>  6. Implementasi REST API </h1><br>  Kelas <code>simple.predictor.Server</code> bertanggung jawab untuk mengimplementasikan REST API.  Server didasarkan pada server Java yang termasuk dalam Java. <br><br><h4>  simple.predictor.Server </h4><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> simple.predictor <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.<span class="hljs-type"><span class="hljs-type">InetSocketAddress</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.sun.net.httpserver.{<span class="hljs-type"><span class="hljs-type">HttpExchange</span></span>, <span class="hljs-type"><span class="hljs-type">HttpServer</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.imageio.<span class="hljs-type"><span class="hljs-type">ImageIO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.json4s.<span class="hljs-type"><span class="hljs-type">DefaultFormats</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.json4s.native.<span class="hljs-type"><span class="hljs-type">Serialization</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Server</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">address: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">InetSocketAddress</span></span></span></span><span class="hljs-class"><span class="hljs-params">, entryPoint: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, model: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Model</span></span></span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   HTTP-,     java private val server = HttpServer.create(address, 0) //      URL server.createContext(entryPoint, (http: HttpExchange) =&gt; { //   HTTP-     val header = http.getRequestHeaders val (httpCode, json) = if (header.containsKey("Content-Type") &amp;&amp; header.getFirst("Content-Type") == "image/jpeg") { //          ,      200 val image = ImageIO.read(http.getRequestBody) val predictionSeq = model.predict(image) (200, Map("prediction" -&gt; predictionSeq)) } else (400, Map("error" -&gt; "Invalid content")) //       400 //    JSON    val responseJson = Serialization.write(json)(DefaultFormats) val httpOs = http.getResponseBody http.getResponseHeaders.set("Content-Type", "application/json") http.sendResponseHeaders(httpCode, responseJson.length) httpOs.write(responseJson.getBytes) httpOs.close() }) def start(): Unit = server.start() def stop(): Unit = server.stop(0) }</span></span></code> </pre> <br><a name="7"></a><h1>  7. Pengujian </h1><br>  Untuk memeriksa, mulai server dan mengirim gambar uji src / main / resources / cat_and_dog.jpg.  Kami akan mengurai JSON yang diterima dari server, memeriksa berapa banyak dan objek apa yang ditemukan jaringan saraf dalam gambar, dan melingkari objek dalam gambar. <br><br><h4>  simple.predictor.ServerTest </h4><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> simple.predictor <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.awt.{<span class="hljs-type"><span class="hljs-type">BasicStroke</span></span>, <span class="hljs-type"><span class="hljs-type">Color</span></span>, <span class="hljs-type"><span class="hljs-type">Font</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.awt.image.<span class="hljs-type"><span class="hljs-type">BufferedImage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.{<span class="hljs-type"><span class="hljs-type">ByteArrayOutputStream</span></span>, <span class="hljs-type"><span class="hljs-type">File</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.<span class="hljs-type"><span class="hljs-type">InetSocketAddress</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.imageio.<span class="hljs-type"><span class="hljs-type">ImageIO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.scalatest.{<span class="hljs-type"><span class="hljs-type">FlatSpec</span></span>, <span class="hljs-type"><span class="hljs-type">Matchers</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scalaj.http.<span class="hljs-type"><span class="hljs-type">Http</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.json4s.{<span class="hljs-type"><span class="hljs-type">DefaultFormats</span></span>, <span class="hljs-type"><span class="hljs-type">Formats</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.json4s.native.<span class="hljs-type"><span class="hljs-type">JsonMethods</span></span>.parse <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> simple.predictor.<span class="hljs-type"><span class="hljs-type">Config</span></span>._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> simple.predictor.<span class="hljs-type"><span class="hljs-type">Model</span></span>.<span class="hljs-type"><span class="hljs-type">Prediction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.concurrent.<span class="hljs-type"><span class="hljs-type">Future</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.concurrent.<span class="hljs-type"><span class="hljs-type">ExecutionContext</span></span>.<span class="hljs-type"><span class="hljs-type">Implicits</span></span>.global <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServerTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FlatSpec</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Matchers</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> formats: <span class="hljs-type"><span class="hljs-type">Formats</span></span> = <span class="hljs-type"><span class="hljs-type">DefaultFormats</span></span> <span class="hljs-string"><span class="hljs-string">"Service"</span></span> should <span class="hljs-string"><span class="hljs-string">"find a cat and a dog on photo"</span></span> in { <span class="hljs-comment"><span class="hljs-comment">//      val model = new Model(modelPrefix, modemEpoch, modemEdge, threshold, context) val server = new Server(new InetSocketAddress(host, port), entryPoint, model) //      Future(server.start()) Thread.sleep(5000) //         val image = ImageIO.read(getClass.getResourceAsStream("/cat_and_dog.jpg")) val byteOS = new ByteArrayOutputStream() ImageIO.write(image, "jpg", byteOS) val data = byteOS.toByteArray //      ,     200 val response = Http(s"http://$host:$port$entryPoint").header("Content-Type", "image/jpeg").postData(data).asString response.code shouldEqual 200 //  JSON-, ,       val prediction = parse(response.body) \\ "prediction" prediction.children.size shouldEqual 2 //     , ,     ,    val objectClassList = (prediction \\ "objectClass").children map (_.extract[String]) objectClassList.head shouldEqual "cat" objectClassList.tail.head shouldEqual "dog" //   ,   val bBoxCoordinates = prediction.children.map(_.extract[Prediction]) //   ,     val imageWithBoundaryBoxes = new BufferedImage(image.getWidth, image.getHeight, image.getType) val graph = imageWithBoundaryBoxes.createGraphics() graph.drawImage(image, 0, 0, null) graph.setColor(Color.RED) graph.setStroke(new BasicStroke(5)) graph.setFont(new Font(Font.SANS_SERIF, Font.TRUETYPE_FONT, 30)) bBoxCoordinates foreach { case Prediction(obj, prob, x, y, width, height) =&gt; graph.drawRect(x, y, width, height) graph.drawString(s"$obj, prob: $prob", x + 15, y + 30) } graph.dispose() //         ImageIO.write(imageWithBoundaryBoxes, "jpg", new File("./test.jpg")) } }</span></span></code> </pre> <br>     ,       . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea2/454/57d/ea245457d175d072a8eb8c98ef4551ce.png"><br><br><a name="8"></a><h1> 8.       </h1><br>  ,      .     Docker   ,    . <br><br><h4> Dockerfile </h4><br><pre> <code class="plaintext hljs">#       Sbt FROM entony/scala-mxnet-cuda-cudnn:2.12-1.3.1-9-7-builder AS builder #       RUN mkdir /tmp/source /tmp/source/dependencies COPY project /tmp/source/project COPY src /tmp/source/src COPY build.sbt /tmp/source/build.sbt #     MXNet,       RUN ln -s /usr/local/share/mxnet/scala/linux-x86_64-gpu/mxnet-full_2.12-linux-x86_64-gpu-1.3.1-SNAPSHOT.jar /tmp/source/dependencies/mxnet-full_2.12-linux-x86_64-gpu-1.3.1-SNAPSHOT.jar &amp;&amp; \ cd /tmp/source/ &amp;&amp; sbt pack #      FROM entony/scala-mxnet-cuda-cudnn:2.12-1.3.1-9-7-runtime #   LD   Cuda   Java ENV LD_LIBRARY_PATH /usr/local/cuda-9.0/targets/x86_64-linux/lib/stubs:/usr/local/share/OpenCV/java #            /opt/app/models ENV MODEL_PREFIX "/opt/app/models/resnet50_ssd_model" #            RUN mkdir -p /opt/app COPY --from=builder --chown=root:root /tmp/source/target/pack /opt/app COPY models /opt/app/models #      ENTRYPOINT /opt/app/bin/simple-predictor</code> </pre> <br>         <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ,    ,   Dockerfile your@pc$ docker build -f Dockerfile -t entony/simple-predictor:1.0.0 . #   docker hub your@pc$ docker push entony/simple-predictor:1.0.0</span></span></code> </pre> <br><a name="9"></a><h1> 9.    production-  GPU </h1><br> ,      docker hub,      Nvidia,  8080    Docker, Cuda 9.0  Cudnn 7. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#     Docker hub your@server-with-gpu$ docker pull entony/simple-predictor:1.0.0 #     your@server-with-gpu$ docker run -d \ -p 8080:8080 \ -e MODEL_CONTEXT_GPU=true \ -e MXNET_CUDNN_AUTOTUNE_DEFAULT=0 \ --name 'simple_predictor' \ --device /dev/nvidia0:/dev/nvidia0 \ --device /dev/nvidiactl:/dev/nvidiactl \ --device /dev/nvidia-uvm:/dev/nvidia-uvm \ -v /usr/lib/x86_64-linux-gnu/libcuda.so.1:/usr/local/cuda-9.0/targets/x86_64-linux/lib/stubs/libcuda.so.1:ro \ -v /usr/lib/nvidia-396/libnvidia-fatbinaryloader.so.396.54:/usr/local/cuda-9.0/targets/x86_64-linux/lib/stubs/libnvidia-fatbinaryloader.so.396.54:ro \ entony/simple-predictor:1.0.0</span></span></code> </pre> <br>         Docker-   <code>--device</code>   Cuda-   <code>-v</code> . <br><br>   <code>MODEL_CONTEXT_GPU</code>     GPU-,  <code>MXNET_CUDNN_AUTOTUNE_DEFAULT</code>          (  ,      ,     ,  ). <br><br>      : <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  your@server-with-gpu$ curl -X POST -H 'Content-Type: image/jpeg' --data-binary '@src/main/resources/cat_and_dog.jpg' http://0.0.0.0:8080/predict #  { "prediction":[ { "objectClass":"cat", "probability":0.9959417, "x":72,"y":439, "width":950, "height":987 }, { "objectClass":"dog", "probability":0.81277525, "x":966, "y":100, "width":870, "height":1326 } ] }</span></span></code> </pre> <br><a name="10"></a><h1>  Kesimpulan </h1><br> MXNet   ,    -    .  ,    ,   ,     production. <br><br>   , ,   MXNet    ,      Python      production  Scala, Java  ++. <br><br>        ,                   . <br><br> ,        .          .  Terima kasih atas perhatian anda <br><br><a name="11"></a><h1>  Referensi </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Git   Docker-</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Git    </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">     MXNet</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439226/">https://habr.com/ru/post/id439226/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439216/index.html">pudge 500 row embeddable database di golang</a></li>
<li><a href="../id439218/index.html">VK bot berlutut, atau bagaimana menyenangkan orang pada 14 Februari</a></li>
<li><a href="../id439220/index.html">Kota besar untuk perangkat seluler di Unity. Pengalaman dalam pengembangan dan optimalisasi</a></li>
<li><a href="../id439222/index.html">Apa itu manajemen API?</a></li>
<li><a href="../id439224/index.html">Lagi tentang diagram Voronoi</a></li>
<li><a href="../id439232/index.html">JAMstack: Cara membuat blog Anda sendiri menggunakan Gatsby + Contentful + Netlify</a></li>
<li><a href="../id439234/index.html">Kehidupan pengembang Open Source di GIF</a></li>
<li><a href="../id439236/index.html">xenvman: Lingkungan pengujian microservice fleksibel (dan banyak lagi)</a></li>
<li><a href="../id439238/index.html">Play Store sekarang menerima aplikasi web progresif (PWA)</a></li>
<li><a href="../id439240/index.html">Joomla Digest untuk Januari 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>