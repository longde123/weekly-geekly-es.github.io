<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê± üë®üèº‚Äçüöí üßñüèª An√°lisis de entrevistas de trabajo de Google: b√∫squeda de relaciones ü§¶üèæ üîΩ ü§≥üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bienvenido al siguiente art√≠culo de una serie de acertijos que pregunt√© en las entrevistas de Google antes de que fueran prohibidos despu√©s de la filt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>An√°lisis de entrevistas de trabajo de Google: b√∫squeda de relaciones</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467371/"><img src="https://habrastorage.org/getpro/habr/post_images/915/39d/3b3/91539d3b3be71056861dc65e18921c88.png"><br><br>  Bienvenido al siguiente art√≠culo de una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">serie de</a> acertijos que pregunt√© en las entrevistas de Google antes de que fueran prohibidos despu√©s de la filtraci√≥n.  Desde entonces, dej√© de trabajar como ingeniero de software en Google y pas√© al puesto de gerente de desarrollo en Reddit, pero todav√≠a tengo algunos temas geniales.  Hasta la fecha, hemos examinado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la programaci√≥n din√°mica</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">elevando las matrices al poder</a> y la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sinonimia de las consultas</a> .  Esta vez una pregunta completamente nueva. <br><a name="habracut"></a><br>  Pero primero, dos puntos.  En primer lugar, el trabajo en Reddit fue incre√≠ble.  Durante los √∫ltimos ocho meses, he creado y dirigido el nuevo equipo de Relevancia de anuncios y he establecido una nueva oficina de desarrollo en Nueva York.  No importa cu√°n divertido pueda ser, desafortunadamente, descubr√≠ que hasta hace poco no me quedaba tiempo ni energ√≠a para un blog.  Me temo que abandon√© un poco esta serie.  Perd√≥n por el retraso. <br><br>  En segundo lugar, si sigui√≥ los art√≠culos, despu√©s del √∫ltimo n√∫mero, podr√≠a pensar que comenzar√≠a a investigar las opciones sin√≥nimas de las consultas.  Aunque me gustar√≠a volver a esto en alg√∫n momento, debo admitir que perd√≠ el debido inter√©s en este problema debido a un cambio de trabajo y hasta ahora decid√≠ posponerlo.  Sin embargo, ¬°mantente en contacto!  Me lo debo y tengo la intenci√≥n de devolverlo.  Solo, ya sabes, un poco m√°s tarde ... <br><br>  <i>Descargo de responsabilidad r√°pido: aunque entrevistar a los candidatos es una de mis tareas profesionales, este blog presenta mis observaciones personales, historias personales y opiniones personales.</i>  <i>No tome esto para ninguna declaraci√≥n oficial de Google, Alphabet, Reddit o cualquier otra persona u organizaci√≥n.</i> <br><br><h2>  Busca una nueva pregunta </h2><br>  En un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo anterior,</a> describ√≠ una de mis preguntas favoritas que us√© durante mucho tiempo, antes de la inevitable filtraci√≥n.  Las preguntas anteriores eran fascinantes desde un punto de vista te√≥rico, pero quer√≠a elegir un problema un poco m√°s relevante para Google como empresa.  Cuando se prohibi√≥ esta pregunta, quer√≠a encontrar un reemplazo, teniendo en cuenta la nueva restricci√≥n: simplificar la pregunta. <br><br>  Ahora, esto puede parecer un poco sorprendente dado el infame proceso de entrevistas en Google.  Pero en ese momento un problema m√°s simple ten√≠a sentido.  Mi razonamiento consisti√≥ en dos partes.  El primero es pragm√°tico: los candidatos generalmente no respond√≠an muy bien a las preguntas anteriores, a pesar de numerosas sugerencias y simplificaciones, y no siempre estaba completamente seguro de por qu√©.  El segundo te√≥rico: el proceso de la entrevista debe dividir a los candidatos en las categor√≠as "vale la pena contratar" y "no vale la pena contratar", y ten√≠a curiosidad por saber si esto podr√≠a hacerse un poco m√°s f√°cil con la pregunta. <br><br>  Antes de aclarar estos dos puntos, quiero se√±alar lo que <i>no</i> significan.  "No siempre estoy seguro de por qu√© una persona tiene problemas" no significa la inutilidad de las preguntas y que quer√≠a simplificar la entrevista por este motivo.  Incluso la pregunta m√°s dif√≠cil, muchos se las arreglaron bien.  Quiero decir, cuando los candidatos ten√≠an problemas, me costaba entender lo que se estaban perdiendo. <br><br>  Las buenas entrevistas dan una idea general de las fortalezas y debilidades del candidato.  No es suficiente que el comit√© de contrataci√≥n simplemente diga que "fall√≥": el comit√© determina si el candidato tiene las cualidades espec√≠ficas de la empresa que est√° buscando.  Del mismo modo, las palabras "√©l es genial" no ayudan al comit√© a decidir sobre un candidato que sea fuerte en algunas √°reas, pero dudoso en otras.  He descubierto que los problemas m√°s complejos a menudo separan a los candidatos en estas dos categor√≠as.  Desde este punto de vista, "No siempre estoy seguro de por qu√© una persona tiene problemas" significa "la incapacidad para avanzar en este tema no representa en s√≠ una imagen de las habilidades de este candidato". <br><br>  La clasificaci√≥n de los candidatos como "vale la pena contratar" y "no vale la pena contratar" <i>no</i> significa que el proceso de entrevista deba separar a los candidatos est√∫pidos de los inteligentes.  No puedo recordar a un solo candidato que no fuera inteligente, talentoso y motivado.  Muchos ven√≠an de excelentes universidades, y el resto estaba claramente extremadamente motivado.  Pasar por entrevistas telef√≥nicas ya es un buen tamiz, e incluso negarse en esta etapa no es una se√±al de falta de capacidad. <br><br>  Sin embargo, <i>puedo</i> recordar a muchos que no estaban lo suficientemente preparados para la entrevista o trabajaron muy lentamente, o requirieron demasiada supervisi√≥n para resolver el problema, o se comunicaron de una manera poco clara, o no pudieron traducir sus ideas al c√≥digo, o ocuparon una posici√≥n que simplemente no conducir√≠a su √©xito a largo plazo, etc. La definici√≥n de "vale la pena contratar" es vaga y var√≠a seg√∫n la empresa, y el proceso de entrevista es determinar si cada candidato cumple con los requisitos de una empresa en particular. <br><br>  Le√≠ muchos comentarios de reddit quej√°ndose de preguntas de entrevistas demasiado complejas.  Ten√≠a curiosidad si todav√≠a era posible hacer una recomendaci√≥n digna / indigna para una tarea m√°s simple.  Sospech√© que esto dar√≠a una se√±al √∫til sin gritar innecesariamente los nervios del candidato.  Te contar√© mis conclusiones al final del art√≠culo ... <br><br>  Con estos pensamientos, estaba buscando una nueva pregunta.  En un mundo ideal, esta es una pregunta lo suficientemente simple como para resolverla en 45 minutos, pero con preguntas adicionales para que los candidatos m√°s poderosos muestren sus habilidades.  Tambi√©n debe ser compacto en la implementaci√≥n, porque muchos candidatos todav√≠a escriben en la pizarra.  Una gran ventaja si el tema est√° relacionado de alguna manera con los productos de Google. <br><br>  Finalmente, resolv√≠ una pregunta que un maravilloso Google describi√≥ cuidadosamente e insert√≥ en nuestra base de datos de preguntas.  Ahora he consultado con antiguos colegas y me he asegurado de que la pregunta a√∫n est√© prohibida, por lo que definitivamente no se te preguntar√° en la entrevista.  Lo presento en la forma en que me parece m√°s efectivo, con una disculpa al autor original. <br><br><h2>  Pregunta </h2><br>  Habla sobre medir distancias.  <i>La mano</i> es una unidad de medida de cuatro pulgadas com√∫nmente utilizada en pa√≠ses de habla inglesa para medir la altura de los caballos.  <i>Un a√±o luz</i> es otra unidad de medida igual a la distancia que recorre una part√≠cula (¬øu onda?) De luz en un cierto n√∫mero de segundos, aproximadamente igual a un a√±o terrestre.  A primera vista, tienen poco en com√∫n entre s√≠, excepto que se usan para medir la distancia.  Pero resulta que Google puede convertirlos con bastante facilidad: <br><br><img src="https://habrastorage.org/webt/uu/8z/y-/uu8zy-po4rpuvr61dtewmyhjns0.png"><br><br>  Esto puede parecer obvio: al final, ambos miden la distancia, por lo que est√° claro que hay una transformaci√≥n.  Pero si lo piensas, es un poco extra√±o: ¬øc√≥mo calcularon esta tasa de conversi√≥n?  Claramente, nadie realmente cont√≥ el n√∫mero de manos en un a√±o luz.  En realidad, no necesitas tomar esto directamente.  Simplemente puede usar conversiones conocidas: <br><br><ul><li>  <i>1 mano</i> = <i>4 pulgadas</i> <br></li><li>  <i>4 pulgadas</i> = <i>0.33333 pies</i> <br></li><li>  <i>0.33333 pies</i> = <i>6.3125e - 5 millas</i> <br></li><li>  <i>6.3125e - 5 millas</i> = <i>1.0737e - 17 a√±os luz</i> </li></ul><br>  El objetivo de la tarea es desarrollar un sistema que realice esta transformaci√≥n.  En particular: <br><br><blockquote>  En la entrada tiene una lista de factores de conversi√≥n (formateados en el idioma elegido) en forma de un conjunto de unidades iniciales de medida, unidades finales y factores, por ejemplo: <br><br><pre>  ft 12
 yarda de pies 0.3333333
 etc. </pre><br>  De modo que ORIGEN * MULTIPLICADOR = DESTINO.  Desarrolle un algoritmo que tome dos valores unitarios arbitrarios y devuelva el factor de conversi√≥n entre ellos. </blockquote><br><h2>  La discusi√≥n </h2><br>  Me gusta este problema porque tiene una respuesta intuitiva y obvia: ¬°simplemente convierta de una unidad a otra, luego a la siguiente, hasta que encuentre el objetivo!  No recuerdo a un solo candidato que se encontr√≥ con este problema y estaba completamente desconcertado sobre c√≥mo resolverlo.  Esto encaja bien con el requisito de un problema "m√°s simple", ya que los anteriores generalmente requer√≠an un estudio y una reflexi√≥n largos antes de encontrar al menos un enfoque b√°sico de la soluci√≥n. <br><br>  Sin embargo, muchos candidatos no se dieron cuenta de su intuici√≥n como una soluci√≥n de trabajo sin pistas obvias.  Una de las ventajas de esta pregunta es que pone a prueba la capacidad del candidato para formular el problema (para enmarcar) para que se preste al an√°lisis y la codificaci√≥n.  Como veremos, aqu√≠ hay una extensi√≥n muy interesante que requiere un nuevo salto conceptual. <br><br>  Para el contexto, el encuadre es el acto de traducir un problema con una soluci√≥n no obvia en un problema equivalente, donde la soluci√≥n se deduce de forma natural.  Si esto suena completamente abstracto e inexpugnable, lo siento, pero lo es.  Explicar√© a qu√© me refiero cuando presente la soluci√≥n inicial a este problema.  La primera parte de la soluci√≥n ser√° un ejercicio para desarrollar y aplicar conocimiento algor√≠tmico.  La segunda parte ser√° un ejercicio de manipulaci√≥n de este conocimiento para llegar a una optimizaci√≥n nueva y no obvia. <br><br><h2>  Parte 0. Intuici√≥n </h2><br>  Antes de profundizar, exploremos completamente la soluci√≥n "obvia".  La mayor√≠a de las conversiones requeridas son simples y directas.  Cualquier estadounidense que haya viajado fuera de los Estados Unidos sabe que la mayor parte del mundo usa la misteriosa unidad "kil√≥metro" para medir distancias.  Para convertir, solo necesita multiplicar el n√∫mero de millas por aproximadamente 1.6. <br><br>  Nos hemos encontrado con tales cosas durante la mayor parte de nuestras vidas.  Para la mayor√≠a de las unidades, ya hay una conversi√≥n precalculada, por lo que solo debe verla en la tabla correspondiente.  Pero si no hay conversi√≥n directa (por ejemplo, de manos a a√±os luz), tiene sentido construir una ruta de conversi√≥n, como se indic√≥ anteriormente: <br><br><ul><li>  <i>1 mano</i> = <i>4 pulgadas</i> <br></li><li>  <i>4 pulgadas</i> = <i>0.33333 pies</i> <br></li><li>  <i>0.33333 pies</i> = <i>6.3125e - 5 millas</i> <br></li><li>  <i>6.3125e - 5 millas</i> = <i>1.0737e - 17 a√±os luz</i> </li></ul><br>  ¬°Fue muy simple, se me ocurri√≥ tal transformaci√≥n usando mi imaginaci√≥n y una tabla de transformaci√≥n est√°ndar!  Sin embargo, quedan algunas preguntas.  ¬øHay un camino m√°s corto?  ¬øQu√© tan preciso es el coeficiente?  ¬øLa conversi√≥n es siempre posible?  ¬øEs posible automatizarlo?  Desafortunadamente, aqu√≠ el enfoque ingenuo se rompe. <br><br><h2>  Parte 1. Decisi√≥n ingenua </h2><br>  Es bueno que el problema tenga una soluci√≥n intuitiva, pero de hecho, esta simplicidad es un obst√°culo para resolver el problema.  No hay nada m√°s dif√≠cil que tratar de entender de una manera nueva lo que ya entiendes, sobre todo porque a menudo sabes menos de lo que piensas.  Para ilustrar, imagine que vino a una entrevista y que tiene este m√©todo intuitivo en su cabeza.  Pero no permite resolver una serie de problemas importantes. <br><br>  Por ejemplo, ¬øqu√© <i>pasa</i> si <i>no hay conversi√≥n</i> ?  El enfoque obvio no dice nada, es realmente posible convertir de una unidad a otra.  Si me dan mil tasas de conversi√≥n, ser√° muy dif√≠cil para m√≠ determinar si es posible en principio.  Si se me pide que haga una conversi√≥n entre unidades desconocidas (o inventadas) de un <i>puntero</i> y un <i>jab</i> , entonces no tengo idea por d√≥nde empezar.  ¬øC√≥mo ayuda un enfoque intuitivo aqu√≠? <br><br>  Debo admitir que este es un tipo de escenario artificial, pero tambi√©n hay uno m√°s realista.  Usted ve que mi declaraci√≥n del problema incluye solo unidades de distancia.  Esto se hace a prop√≥sito.  ¬øQu√© sucede si le pido al sistema que convierta de pulgadas a kilogramos?  Tanto usted como yo sabemos que esto no es posible porque miden diferentes tipos, pero la entrada no dice nada sobre el "tipo" que mide cada unidad. <br><br>  Es aqu√≠ donde una formulaci√≥n cuidadosa de la pregunta permite a los candidatos fuertes demostrar su val√≠a.  <i>Antes de</i> desarrollar el algoritmo, piensan en los casos extremos del sistema.  Y tal declaraci√≥n del problema les da a prop√≥sito la oportunidad de preguntarme si traduciremos diferentes unidades.  Este no es un problema tan grande si ocurre en una etapa temprana, pero siempre es una buena se√±al cuando alguien me pregunta por adelantado: "¬øQu√© deber√≠a devolver el programa si la conversi√≥n no es posible?"  Hacer la pregunta de esta manera me da una idea de las habilidades del candidato antes de que escriba al menos una l√≠nea de c√≥digo. <br><br>  <i>Vista gr√°fica</i> <br><br>  Obviamente, el enfoque ingenuo no es adecuado, por lo que debemos pensar en c√≥mo hacer tal conversi√≥n.  La respuesta es considerar las unidades como un gr√°fico.  Este es el primer salto de comprensi√≥n necesario para resolver este problema. <br><br>  En particular, imagine que cada unidad es un nodo en un gr√°fico, y que hay un borde del nodo <code>A</code> al nodo <code>B</code> si <code>A</code> puede convertirse en <code>B</code> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc6/d25/89f/fc6d2589f8a9a411cec0d704e2ad644e.png"><br><br>  Los bordes est√°n etiquetados con una tasa de conversi√≥n por la cual debes multiplicar <code>A</code> para obtener <code>B</code> <br><br>  Casi siempre esperaba que el candidato presentara un marco as√≠, y rara vez le daba pistas serias.  Puedo perdonar al candidato que no se da cuenta de la soluci√≥n al problema de usar conjuntos disjuntos o que no est√° muy familiarizado con el √°lgebra lineal para darse cuenta de una soluci√≥n que se reduce a volver a elevar al poder de la matriz de adyacencia, pero los gr√°ficos se ense√±an en cualquier plan de estudios o curso de programaci√≥n.  Si el candidato no tiene el conocimiento apropiado, esta es una se√±al de "no contrataci√≥n". <br><br>  <i>Como sea</i> <br><br>  Una representaci√≥n gr√°fica reduce la soluci√≥n al problema cl√°sico de b√∫squeda de gr√°ficos.  En particular, dos algoritmos son √∫tiles aqu√≠: b√∫squeda amplia (BFS) y b√∫squeda profunda (DFS).  Al buscar en ancho, examinamos los nodos de acuerdo con su distancia desde el origen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d45/4cb/15b/d454cb15b85c4ea9ce32e87623ed4115.png"><br>  <i><font color="gray">El azul m√°s oscuro significa generaciones posteriores</font></i> <br><br>  Y cuando buscamos en profundidad, examinamos los nodos en el orden en que ocurren: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/40b/f4c/f1a/40bf4cf1ae3d89554505c031c4529559.png"><br><br>  <i><font color="gray">El azul m√°s oscuro tambi√©n significa generaciones posteriores.</font></i>  <i><font color="gray">Tenga en cuenta que en realidad no visitamos todos los sitios</font></i> <br><br>  Cualquiera de los algoritmos determina f√°cilmente si hay una conversi√≥n de una unidad a otra, es suficiente simplemente buscar en el gr√°fico.  Comenzamos desde la unidad fuente y buscamos hasta encontrar la unidad de destino.  Si no puede encontrar su destino (como si tratara de convertir pulgadas a kilogramos), sabemos que no hay manera. <br><br>  Pero espera, falta algo.  No queremos buscar una forma, ¬°queremos encontrar una tasa de conversi√≥n!  Aqu√≠ es donde el candidato debe dar el salto: resulta que puede modificar cualquier algoritmo de b√∫squeda para calcular la tasa de conversi√≥n simplemente guardando el estado adicional a medida que avanza.  Ah√≠ es donde las ilustraciones ya no tienen sentido, as√≠ que profundicemos en el c√≥digo. <br><br>  Primero, debe determinar la estructura de datos del gr√°fico, por lo que usamos esto: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RateGraph</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, rates)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Initialize the graph from an iterable of (start, end, rate) tuples.'</span></span> self.graph = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> orig, dest, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rates: self.add_conversion(orig, dest, rate) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_conversion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, orig, dest, rate)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Insert a conversion into the graph.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> orig <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph: self.graph[orig] = {} self.graph[orig][dest] = rate <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_neighbors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, node)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Returns an iterable of the nodes neighboring the given node.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.graph[node].items() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_nodes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Returns an iterable of all the nodes in the graph.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.graph.keys()</code> </pre> <br>  Entonces comencemos con DFS.  Hay muchas formas de implementarlo, pero, con mucho, la m√°s com√∫n es una soluci√≥n recursiva.  Comencemos con esto: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__dfs_helper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, node, end, rate_from_origin, visited)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == end: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rate_from_origin visited.add(node) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rate_graph.get_neighbors(node): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visited: rate = __dfs_helper(rate_graph, unit, end, rate_from_origin * rate, visited) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> rate <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rate <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, node, end)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __dfs_helper(rate_graph, node, end, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, set())</code> </pre> <br>  En pocas palabras, este algoritmo comienza con un nodo, itera sobre sus vecinos e inmediatamente visita cada uno, haciendo una llamada recursiva a la funci√≥n.  Cada llamada de funci√≥n en la pila guarda el estado de su propia iteraci√≥n, por lo que cuando se devuelve una visita recursiva, su padre contin√∫a inmediatamente la iteraci√≥n.  Evitamos visitar el mismo sitio nuevamente manteniendo un conjunto de sitios visitados en todas las llamadas.  Tambi√©n calculamos el coeficiente asignando un factor de conversi√≥n entre cada nodo y la fuente.  Por lo tanto, cuando nos encontramos con el nodo / bloque de destino, ya hemos creado el coeficiente de conversi√≥n del nodo de origen, y simplemente podemos devolverlo. <br><br>  Esta es una gran implementaci√≥n, pero adolece de dos fallas principales.  En primer lugar, es recursivo.  Si resulta que el camino deseado consiste en m√°s de mil saltos, saldremos volando con una falla.  Por supuesto, esto es poco probable, pero si hay algo inaceptable para un servicio a largo plazo, es un fracaso.  En segundo lugar, incluso si completamos con √©xito, la respuesta tiene algunas propiedades indeseables. <br><br>  De hecho, ya di una pista al comienzo de la publicaci√≥n.  ¬øHas notado c√≥mo Google muestra la tasa de conversi√≥n de <code>1.0739e-17</code> , pero mi c√°lculo manual da <code>1.0737e-17</code> ?  Resulta que todas estas multiplicaciones de coma flotante ya hacen pensar en difundir el error.  Hay demasiados matices para este art√≠culo, pero la conclusi√≥n es que debe minimizar la multiplicaci√≥n de coma flotante para evitar errores que se acumulan y causan problemas. <br><br>  DFS es un gran algoritmo de b√∫squeda.  Si existe una soluci√≥n, la encontrar√°.  Pero carece de una propiedad clave: no necesariamente encuentra el camino m√°s corto.  Esto es importante para nosotros porque una ruta m√°s corta significa menos saltos y menos errores debido a las multiplicaciones de coma flotante.  Para resolver el problema, recurrimos a BFS. <br><br><h2>  Parte 2. Soluci√≥n BFS </h2><br>  En esta etapa, si un candidato implementa con √©xito una soluci√≥n DFS recursiva y se detiene en ella, generalmente doy al menos una recomendaci√≥n d√©bil sobre la contrataci√≥n de este candidato.  Entendi√≥ el problema, eligi√≥ el marco apropiado e implement√≥ una soluci√≥n de trabajo.  Esta es una decisi√≥n ingenua, por lo que no insisto en contratarlo, pero si se las arregl√≥ bien con otras entrevistas, no recomendar√© negarse. <br><br>  Vale la pena repetir esto: si tiene dudas, ¬°escriba una soluci√≥n ingenua!  Incluso si no es completamente √≥ptimo, la presencia de c√≥digo en el tablero ya es un logro, y a menudo se puede encontrar la soluci√≥n correcta sobre la base.  Dir√© de manera diferente: nunca trabajes por nada.  Lo m√°s probable es que haya pensado en una soluci√≥n ingenua, pero no quer√≠a ofrecerla, porque sabe que no es √≥ptima.  Si est√° listo para dise√±ar la mejor soluci√≥n en este momento, est√° bien, pero si no, entonces registre el progreso realizado antes de pasar a cosas m√°s complejas. <br><br>  De ahora en adelante, hablemos sobre las mejoras al algoritmo.  Las principales desventajas de una soluci√≥n DFS recursiva son que es recursiva y no minimiza el n√∫mero de multiplicaciones.  Como veremos pronto, BFS minimiza el n√∫mero de multiplicaciones, y tambi√©n es muy dif√≠cil implementarlo de forma recursiva.  Desafortunadamente, tendremos que abandonar la soluci√≥n DFA recursiva, porque para mejorarla tendremos que reescribir completamente el c√≥digo. <br><br>  Sin m√°s pre√°mbulos, presento un enfoque iterativo basado en BFS: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, start, end)</span></span></span><span class="hljs-function">:</span></span> to_visit = deque() to_visit.appendleft( (start, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) ) visited = set() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_visit: node, rate_from_origin = to_visit.pop() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == end: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rate_from_origin visited.add(node) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rate_graph.get_neighbors(node): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visited: to_visit.appendleft((unit, rate_from_origin * rate)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Esta implementaci√≥n es funcionalmente muy diferente de la anterior, pero si se mira de cerca, hace m√°s o menos lo mismo, con un cambio significativo: mientras DFS recursivo guarda el estado de la ruta adicional en la pila de llamadas, implementando efectivamente la pila LIFO, la soluci√≥n iterativa la almacena en la cola FIFO <br><br>  Esto implica la propiedad "ruta m√°s corta / menor n√∫mero de multiplicaciones".  Visitamos los nodos en el orden en que ocurren, y de esta manera obtenemos generaciones de nodos.  El primer nodo inserta a sus vecinos, y luego los visitamos en orden, peg√°ndolos todo el tiempo y as√≠ sucesivamente.  La propiedad de ruta m√°s corta se deriva del hecho de que los nodos se visitan en el orden de su distancia desde la fuente.  Por lo tanto, cuando encontramos un destino, sabemos que no hay una generaci√≥n anterior que pueda conducir a √©l. <br><br>  En este momento, <i>casi</i> hemos terminado.  Primero debe responder algunas preguntas, y se ven obligados a volver a la formulaci√≥n original del problema. <br><br>  Primero, ¬ølo m√°s trivial si la unidad original no existe?  Es decir, no podemos encontrar el nodo con el nombre dado.  En la pr√°ctica, debe hacer algo de normalizaci√≥n de las cadenas para que la Libra, Libra y lb apunten al mismo nodo "libra" (o alguna otra representaci√≥n can√≥nica), pero esto est√° m√°s all√° del alcance de nuestra pregunta. <br><br>  En segundo lugar, ¬øqu√© pasa si no hay conversi√≥n entre las dos unidades?  Recuerde que en los datos iniciales solo hay conversiones entre unidades, y no da ninguna indicaci√≥n de si es posible obtener otro de una unidad en particular.  Esto se reduce al hecho de que las transformaciones y las rutas son directamente equivalentes, por lo que si no hay una ruta entre dos nodos, entonces no hay transformaci√≥n.  En la pr√°ctica, terminas con islas de unidades no relacionadas: una para distancias, otra para pesos, otra para monedas, etc. <br><br>  Finalmente, si observa de cerca el gr√°fico anterior, resulta que no puede convertir entre manos y a√±os luz con esta soluci√≥n.  La direcci√≥n de las conexiones entre los nodos significa que no hay forma de pasar de la mano a a√±os luz.  Sin embargo, esto es bastante f√°cil de solucionar, porque las transformaciones se pueden revertir.  Podemos cambiar nuestro c√≥digo de inicializaci√≥n del gr√°fico de la siguiente manera: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_conversion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, orig, dest, rate)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Insert a conversion into the graph. Note we insert its inverse also.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> orig <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph: self.graph[orig] = {} self.graph[orig][dest] = rate <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dest <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.graph: self.graph[dest] = {} self.graph[dest][orig] = <span class="hljs-number"><span class="hljs-number">1.0</span></span> / rate</code> </pre> <br><h2>  Parte 3. Evaluaci√≥n </h2><br>  Hecho  Si el candidato ha llegado a este punto, lo m√°s probable es que lo recomiende para contratarlo.  Si estudi√≥ ciencias de la computaci√≥n o tom√≥ un curso de algoritmos, puede preguntar: "¬øEs esto realmente suficiente para obtener una entrevista con este tipo?", A lo que responder√©: "Esencialmente, s√≠". <br><br>  Antes de decidir que la pregunta es demasiado simple, veamos qu√© debe hacer un candidato para llegar a este punto: <br><br><ul><li>  Comprende la pregunta <br></li><li>  Construya una red de transformaciones en forma de gr√°fico <br></li><li>  Comprenda que los coeficientes se pueden comparar con los bordes del gr√°fico <br></li><li>  Vea la posibilidad de usar algoritmos de b√∫squeda para lograr esto. <br></li><li>  Elija su algoritmo favorito y c√°mbielo para seguir las probabilidades <br></li><li>  Si implement√≥ DFS como una soluci√≥n ingenua, reconozca sus debilidades. <br></li><li>  Implementar BFS <br></li><li>  Para dar un paso atr√°s y estudiar casos extremos: <br><ul><li>  ¬øQu√© pasa si nos preguntan sobre un nodo que no existe? <br></li><li>  ¬øQu√© pasa si el factor de conversi√≥n no existe? </li></ul></li><li>  Reconocer que las transformaciones inversas son posibles y probablemente necesarias </li></ul><br>  Esta pregunta es m√°s f√°cil que las anteriores, pero tambi√©n es dif√≠cil.  Como en todas las preguntas anteriores, el candidato debe dar un salto mental de una pregunta formulada de manera abstracta a un algoritmo o estructura de datos que abre el camino a una soluci√≥n.  Lo √∫nico es que el algoritmo final est√° menos avanzado que en otros temas.  Fuera de este material algor√≠tmico, se aplican los mismos requisitos, especialmente con respecto a casos extremos y correcci√≥n. <br><br>  ‚Äú¬°Pero espera!‚Äù Puedes preguntar.  - ¬øNo est√° Google obsesionado con la complejidad del tiempo de ejecuci√≥n?  Ni siquiera pregunt√≥ sobre la complejidad temporal o espacial de este problema.  ¬°Oh bien!  Tambi√©n puede preguntar: "Espere un minuto, le dio la calificaci√≥n" muy recomendable para contratar "?  ¬øC√≥mo conseguirlo?  Muy buenas preguntas, ambas.  Esto nos lleva a nuestra ronda de bonificaci√≥n extra final ... <br><br><h2>  Parte 4. ¬øEs posible hacerlo mejor? </h2><br>  En este punto, me gustar√≠a felicitar al candidato con una buena respuesta y dejar en claro que todo lo dem√°s es solo una ventaja.  Cuando la presi√≥n desaparece, podemos comenzar a crear. <br><br>  Entonces, ¬øcu√°l es la dificultad de ejecutar BFS?  En el peor de los casos, debemos considerar cada nodo y borde individual, lo que da una complejidad lineal <code>O(N+E)</code> .  Esto se suma a la misma complejidad de la construcci√≥n del gr√°fico <code>O(N+E)</code> .  Para un motor de b√∫squeda, esto probablemente sea bueno: mil unidades de medida son suficientes para las aplicaciones m√°s razonables, y hacer una b√∫squeda de memoria para cada consulta no es una sobrecarga. <br><br>  Sin embargo, uno puede hacerlo mejor.  Para motivar, considere c√≥mo se inserta este c√≥digo en la cadena de b√∫squeda.  Las conversiones de algunas unidades no est√°ndar son un poco m√°s comunes, por lo que las calcularemos una y otra vez.  Cada vez que se realiza una b√∫squeda, se calculan los valores intermedios, etc. <br><br>  A menudo se sugiere simplemente almacenar en cach√© los resultados del c√°lculo.  Cada vez que se calcula una conversi√≥n de unidad, siempre podemos agregar una ventaja entre las dos conversiones.  Como beneficio adicional, obtenemos la transformaci√≥n inversa, ¬°y gratis!  ¬øYa terminaste? <br><br>  De hecho, esto nos dar√° un tiempo de b√∫squeda asint√≥ticamente constante, pero costar√° el almacenamiento de bordes adicionales.  En realidad, esto se vuelve bastante costoso: con el tiempo, buscaremos un gr√°fico completo, ya que todos los pares de transformaciones se calculan y almacenan gradualmente.  El n√∫mero de aristas posibles en el gr√°fico es la mitad del cuadrado del n√∫mero de nodos, por lo que para mil nodos necesitamos medio mill√≥n de aristas.  Por diez mil nodos, unos cincuenta millones, etc. <br><br>  Yendo m√°s all√° del alcance del motor de b√∫squeda, para un gr√°fico de un mill√≥n de nodos, nos esforzamos por medio bill√≥n de bordes.  Esta cantidad es simplemente irrazonable de almacenar, adem√°s pasamos tiempo insertando bordes en el gr√°fico.  Debemos hacerlo mejor. <br><br>  Afortunadamente, hay una manera de lograr un tiempo constante para buscar coeficientes, sin crecimiento de espacio cuadr√°tico.  De hecho, casi todo lo que necesitamos est√° justo debajo de nuestras narices. <br><br><h2>  Parte 4. Tiempo constante </h2><br>  Por lo tanto, el almacenamiento en cach√© total est√° realmente cerca de la soluci√≥n √≥ptima.  En este enfoque, (en √∫ltima instancia) obtenemos bordes entre todos los nodos, es decir, nuestra transformaci√≥n se reduce a encontrar un borde.  Pero, ¬øes realmente necesario almacenar las conversiones de cada nodo a cada nodo?  ¬øQu√© pasa si solo guardamos los factores de conversi√≥n de <i>un</i> nodo a todos los dem√°s? <br><br>  Eche otro vistazo a la soluci√≥n BFS: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, start, end)</span></span></span><span class="hljs-function">:</span></span> to_visit = deque() to_visit.appendleft( (start, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) ) visited = set() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_visit: node, rate_from_origin = to_visit.pop() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == end: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rate_from_origin visited.add(node) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rate_graph.get_neighbors(node): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visited: to_visit.appendleft((unit, rate_from_origin * rate)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Veamos qu√© sucede aqu√≠: comenzamos desde el nodo fuente, y para cada nodo que encontramos, calculamos el coeficiente de conversi√≥n desde la fuente a este nodo.  Luego, tan pronto como llegamos al destino, devolvemos el coeficiente entre los puntos inicial y final y descartamos los coeficientes intermedios. <br><br>  Estas relaciones intermedias son clave.  ¬øPero qu√© pasa si no los tiramos?  ¬øQu√© pasa si los escribimos en su lugar?  Todas las b√∫squedas m√°s complejas e incomprensibles se vuelven simples: para encontrar la relaci√≥n de A a B, primero encuentre la relaci√≥n de X a B, luego div√≠dala por la relaci√≥n de X a A, ¬°y listo!  Visualmente, se ve as√≠: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/284/a08/b6c/284a08b6cb6ef95af556422fa3c604f3.png"><br>  <i><font color="gray">Tenga en cuenta que entre dos nodos no m√°s de dos aristas</font></i> <br><br>  Resulta que para calcular esta tabla, casi no necesitamos cambiar la soluci√≥n BFS: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_conversions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(graph)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">conversions_bfs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rate_graph, start, conversions)</span></span></span><span class="hljs-function">:</span></span> to_visit = deque() to_visit.appendleft( (start, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_visit: node, rate_from_origin = to_visit.pop() conversions[node] = (start, rate_from_origin) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> unit, rate <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rate_graph.get_neighbors(node): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> unit <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> conversions: to_visit.append((unit, rate_from_origin * rate)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> conversions conversions = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> graph.get_nodes(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> conversions: conversions_bfs(graph, node, conversions) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> conversions</code> </pre> <br>  La estructura de transformaci√≥n est√° representada por un diccionario de la unidad A en dos valores: la ra√≠z del componente asociado de la unidad A y el coeficiente de conversi√≥n entre la unidad ra√≠z y la unidad A. Como insertamos una unidad en este diccionario en cada visita, podemos usar el espacio clave de este diccionario como un conjunto de visitas en lugar de usar Un conjunto dedicado de visitas.  Tenga en cuenta que no tenemos un nodo final, y en su lugar iteramos sobre los nodos hasta que hayamos terminado. <br><br>  Fuera de este BFS, hay una funci√≥n auxiliar que itera sobre los nodos en un gr√°fico.  Cada vez que encuentra un nodo fuera del diccionario de traducci√≥n, inicia BFS a partir de ese nodo.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, tenemos la garant√≠a de colapsar todos los nodos en sus componentes relacionados. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando necesite encontrar la relaci√≥n entre las unidades, simplemente usamos la estructura de transformaci√≥n que acabamos de calcular:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(conversions, start, end)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">'Given a conversion structure, performs a constant-time conversion'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: start_root, start_rate = conversions[start] end_root, end_rate = conversions[end] <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> start_root != end_root: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> end_rate / start_rate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La situaci√≥n "no existe tal unidad" se maneja escuchando una excepci√≥n al acceder a la estructura de las transformaciones. </font><font style="vertical-align: inherit;">La situaci√≥n "no hay tales transformaciones" se maneja comparando las ra√≠ces de dos cantidades: si tienen ra√≠ces diferentes, entonces se detectan a trav√©s de dos llamadas BFS diferentes, es decir, est√°n en dos componentes conectados diferentes y, por lo tanto, no hay manera entre ellos. </font><font style="vertical-align: inherit;">Finalmente, realizamos la conversi√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ah√≠ tienes! </font><font style="vertical-align: inherit;">La soluci√≥n actual tiene una complejidad de preprocesamiento</font></font><code>O(V+E)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(no peor que las soluciones anteriores), pero tambi√©n busca con tiempo constante. Te√≥ricamente, duplicamos los requisitos de espacio, pero la mayor√≠a de las veces ya no necesitamos el gr√°fico original, por lo que podemos eliminarlo y usar solo este. Adem√°s, la complejidad espacial es en realidad menor que el gr√°fico original: requiere </font></font><code>O(V+E)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">porque necesita almacenar todos los bordes y v√©rtices, y esta estructura requiere solo </font></font><code>O(V)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">porque ya no necesitamos bordes.</font></font><br><br><h2>  Resultados </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si ha ido tan lejos, puede recordar que una de las preguntas fue originalmente para verificar si un problema m√°s simple podr√≠a seguir siendo √∫til para elegir candidatos dignos y si podr√≠a dar una mejor idea de las habilidades. Me gustar√≠a dar una respuesta cient√≠fica definitiva, pero solo tengo historias de mi experiencia personal. Sin embargo, not√© algunos resultados positivos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si dividimos la soluci√≥n de este problema en cuatro obst√°culos (discusi√≥n del encuadre, elecci√≥n del algoritmo, implementaci√≥n, discusi√≥n de la ejecuci√≥n por un tiempo constante), al final de la entrevista casi todos los candidatos alcanzaron la "elecci√≥n del algoritmo". Como sospechaba, la discusi√≥n sobre el encuadre era un buen filtro: los candidatos mostraban inmediatamente un gr√°fico o no pod√≠an acceder a √©l de ninguna manera, a pesar de las sugerencias significativas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta es una se√±al √∫til de inmediato. Puedo entender cuando una persona no conoce estructuras de datos avanzadas u oscuras, porque seremos honestos, rara vez tiene que implementar conjuntos disjuntos. Pero los gr√°ficos son una estructura de datos fundamental y se ense√±an como parte de casi cualquier curso introductorio sobre este tema. Si el candidato tiene dificultades para comprenderlos o no puede aplicarlos f√°cilmente, probablemente sea dif√≠cil para √©l tener √©xito en Google (al menos en mi tiempo all√≠, no s√© c√≥mo hoy).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por otro lado, la elecci√≥n del algoritmo no fue una fuente de se√±al particularmente √∫til. Las personas que pasaron por la etapa de encuadre generalmente llegaron al algoritmo sin ning√∫n problema. Sospecho que esto se debe al hecho de que los algoritmos de b√∫squeda casi siempre se ense√±an junto con los propios gr√°ficos, por lo que si alguien est√° familiarizado con uno, entonces conoce el otro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La implementaci√≥n no fue f√°cil. Muchas personas no tuvieron problemas con la implementaci√≥n recursiva de DFS, pero, como mencion√© anteriormente, esta implementaci√≥n no es adecuada para la producci√≥n. Para mi sorpresa, las implementaciones iterativas de BFS y DFS no parecen ser muy familiares para las personas, e incluso despu√©s de pistas obvias, a menudo surgieron en el tema.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En mi opini√≥n, cualquiera que haya pasado por la fase de implementaci√≥n ya me ha ganado la recomendaci√≥n de "Contratar", y la discusi√≥n sobre el tiempo de entrega constante es simplemente una ventaja. </font><font style="vertical-align: inherit;">Aunque analizamos la soluci√≥n en detalle en el art√≠culo, en la pr√°ctica, una discusi√≥n oral en lugar de escribir c√≥digo suele ser m√°s productiva. </font><font style="vertical-align: inherit;">Muy pocos candidatos podr√≠an tomar una decisi√≥n de inmediato. </font><font style="vertical-align: inherit;">A menudo ten√≠a que dar pistas sustanciales, e incluso entonces muchas personas no pod√≠an encontrarlo. </font><font style="vertical-align: inherit;">Esto es normal: como se esperaba, una calificaci√≥n altamente recomendada es dif√≠cil de obtener.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬°Pero espera, eso no es todo! </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B√°sicamente, examinamos todo el problema, pero si est√° interesado en estudiarlo m√°s a fondo, hay varias extensiones en las que no profundizar√©. Dejo los siguientes ejercicios para el lector: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero, calentamiento: en la soluci√≥n por el tiempo constante que present√©, eleg√≠ arbitrariamente el nodo ra√≠z de cada componente conectado. En particular, uso el primer nodo componente que encontramos. Esto no es √≥ptimo, porque para todos los valores conocidos elegimos alg√∫n nodo, aunque alg√∫n otro nodo puede estar m√°s cerca del centro con rutas m√°s cortas a todos los dem√°s nodos. Su tarea es reemplazar esta elecci√≥n arbitraria con una que minimice el n√∫mero de multiplicaciones requeridas y minimice la propagaci√≥n del error de coma flotante.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En segundo lugar, en todos los argumentos se supuso que todas las rutas iguales a trav√©s del gr√°fico son iguales inicialmente, lo cual no siempre es el caso. Una de las opciones interesantes para este problema es la conversi√≥n de divisas: los nodos son divisas, y las aristas de A a B y viceversa son los precios de oferta / demanda de cada par de divisas. Podemos reformular el tema de la conversi√≥n de unidades como una cuesti√≥n de arbitraje de divisas: implementar un algoritmo que, dado el gr√°fico de conversi√≥n de divisas, calcule un ciclo a trav√©s del gr√°fico que le dar√° al comerciante m√°s dinero que la cantidad inicial. No incluya ninguna tarifa de transacci√≥n.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, una verdadera joya: algunas unidades se expresan como una combinaci√≥n de diferentes unidades base. Por ejemplo, un vatio se define en el sistema SI como kg ‚Ä¢ m¬≤ / s¬≥. La tarea final es expandir este sistema para admitir la conversi√≥n entre estas unidades, teniendo en cuenta solo las definiciones de las unidades SI b√°sicas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si tiene alguna pregunta, no dude </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en ponerse en contacto conmigo en reddit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2>  Conclusi√≥n </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando comenc√© a hacer esta tarea en las entrevistas, esperaba que fuera un poco m√°s f√°cil que las anteriores. El experimento fue en gran medida exitoso: si el candidato vio de inmediato la soluci√≥n, entonces usualmente hizo frente a la tarea r√°pidamente, por lo que tuvimos mucho tiempo para hablar sobre una soluci√≥n avanzada con tiempo constante. Las personas que experimentaron dificultades, por regla general, tropezaron en otros lugares adem√°s del salto conceptual algor√≠tmico: el candidato no pudo formular completamente el problema de una manera adecuada o esboz√≥ una buena soluci√≥n, pero no pudo traducirlo en un c√≥digo de trabajo. No importa d√≥nde o cu√°ndo tuvieron dificultades, descubr√≠ que pod√≠a obtener informaci√≥n significativa sobre las fortalezas y debilidades de los candidatos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espero que hayas encontrado √∫til este art√≠culo. </font><font style="vertical-align: inherit;">Entiendo que puede que no haya tantas aventuras con algoritmos como en algunos art√≠culos anteriores. </font><font style="vertical-align: inherit;">En las entrevistas a los desarrolladores, es costumbre discutir abundantemente los algoritmos. </font><font style="vertical-align: inherit;">Pero la verdad es que surgen dificultades significativas cuando se utiliza incluso un m√©todo simple y conocido. </font><font style="vertical-align: inherit;">Todo el c√≥digo est√° en el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repositorio de esta serie de art√≠culos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467371/">https://habr.com/ru/post/467371/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467359/index.html">PVS-Studio va a las nubes: Azure DevOps</a></li>
<li><a href="../467361/index.html">Nos olvidamos de la delegaci√≥n en JavaScript. Delegaci√≥n de eventos en reaccionar</a></li>
<li><a href="../467363/index.html">Uso de funciones de p√©rdida personalizadas y m√©tricas de calidad de aprendizaje en Keras</a></li>
<li><a href="../467365/index.html">Rel√©s de monitoreo de voltaje residencial</a></li>
<li><a href="../467369/index.html">RubyRussia 2019. Mikhail Pronyakin: ¬øes seguro Ruby?</a></li>
<li><a href="../467375/index.html">Gesti√≥n de la experiencia del cliente: ¬øqu√© es?</a></li>
<li><a href="../467377/index.html">Tres seguidos: los 10 mejores informes de Mobius 2019 Piter</a></li>
<li><a href="../467381/index.html">LED de varios pisos, luces inteligentes y bombillas por 18 rublos</a></li>
<li><a href="../467383/index.html">"El gerente necesita seguir codificando": entrevista con Stephen Chin</a></li>
<li><a href="../467385/index.html">Una selecci√≥n de preguntas t√©cnicas psicol√≥gicas y at√≠picas de entrevistas con desarrolladores de Java</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>