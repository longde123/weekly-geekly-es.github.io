<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö≤ üêÇ ‚úãüèΩ API Android Camera2 √† partir de la th√©i√®re, partie 3. Codec multim√©dia et streaming vid√©o sur UDP üèÄ üö¶ üë®‚Äçüë®‚Äçüëß‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Donc, nous avons en quelque sorte compris comment prendre des photos et enregistrer des vid√©os en utilisant l'API Camera2. Il ne reste plus qu'√† appre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>API Android Camera2 √† partir de la th√©i√®re, partie 3. Codec multim√©dia et streaming vid√©o sur UDP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473036/"> Donc, nous avons en quelque sorte compris comment prendre des photos et enregistrer des vid√©os en utilisant l'API Camera2.  Il ne reste plus qu'√† apprendre √† transf√©rer le flux vid√©o de l'appareil Android vers les destinataires souffrant de l'ext√©rieur.  Le but ultime, comme cela a √©t√© dit √† plusieurs reprises, est l'intellectualisation des robots - nous y mettons un smartphone et, pour ainsi dire, transformons un singe en une personne.  Media Codec nous y aidera.  Et bien s√ªr, la nouvelle API Camera2. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sa/tl/mf/satlmfdhbe-ow-gywoc5-tuxupe.jpeg"></div><br>  Peu importe, s'il vous pla√Æt, sous le chat. <br><a name="habracut"></a><br>  Les d√©tails sur le projet robotique peuvent √™tre trouv√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , mais pour l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instant</a> , nous allons directement diffuser la vid√©o depuis celui-ci (ou plut√¥t, depuis un smartphone Android connect√©) vers un ordinateur √©lectronique personnel. <br><br><h4>  De quoi avons-nous besoin pour cela? </h4><br>  Afin de transf√©rer un flux vid√©o de l'√©cran du smartphone vers un autre endroit, comme vous le savez, il (flux) doit d'abord √™tre converti en un format r√©duit appropri√© (il sera trop √©pais pour transmettre image par image), mettre des horodatages (horodatages) et envoyer sous forme binaire au destinataire .  Qui effectuera l'op√©ration de d√©codage inverse. <br><br>  Ce sont pr√©cis√©ment ces actes noirs de bas niveau que la classe Media Codec traite depuis 2013, √† partir de la date de sortie d'Android 4.3. <br><br><img src="https://habrastorage.org/webt/ci/oz/xq/ciozxqlqwq8hecadsrkn0-8me6m.png"><br><br>  Une autre chose est que l'approche du codage vid√©o ant√©rieure, contrairement √† aujourd'hui, n'√©tait pas si simple.  Pour obtenir une image de la cam√©ra, il a fallu utiliser des tonnes d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code myst√©rieux</a> dans lequel, comme dans les sorts des chamans Yakut, la seule inexactitude pouvait conduire √† un crash complet de l'application.  Ajoutez √† cela l'API Camera pr√©c√©dente, o√π au lieu de rappels pr√™ts √† l'emploi, vous deviez √©crire vous-m√™me diff√©rents stylets synchronis√©s, et cette activit√©, disons, n'est pas pour les √¢mes sensibles. <br><br>  Et surtout, vous regardez le <a href="">code</a> de travail de loin, tout semble clair en termes g√©n√©raux.  Vous commencez √† transf√©rer en parties √† votre projet - il n'est pas clair pourquoi il coule.  Mais il est impossible de corriger, car il est difficile de comprendre les d√©tails. <br><br>  Oui, et de solide <s>obsol√®te en</s> quelque sorte √† l'aise.  En bref, le d√©sordre <br><br>  Heureusement, pour les esprits lents, les constructeurs de Google ont introduit le concept magique de <b>Surface</b> , avec lequel vous pouvez √©viter les d√©tails de bas niveau.  C'est difficile pour moi en tant que profane de comprendre √† quel prix et ce que le d√©veloppeur perd, mais maintenant nous pouvons presque litt√©ralement dire: "Android, prenez cette Surface sur laquelle la vid√©o de la cam√©ra est affich√©e et ne changez rien l√†, eh bien, comme c'est le cas, encodez et envoyer. "  Et le plus √©tonnant, c'est que √ßa marche.  Et avec la nouvelle API Camera2, le programme lui-m√™me sait quand envoyer des donn√©es, de nouveaux rappels sont apparus! <br><br>  Alors maintenant pour encoder la vid√©o - il suffit de cracher.  Que ferons-nous maintenant. <br>  Nous prenons le code du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premier article</a> et, comme d'habitude, jetons tout hors de lui sauf les boutons et l'initialisation de la cam√©ra. <br><br><div class="spoiler">  <b class="spoiler_title">Commen√ßons par la mise en page de l'application.</b> <div class="spoiler_text"><pre><code class="java hljs">&lt;?xml version=<span class="hljs-string"><span class="hljs-string">"1.0"</span></span> encoding=<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=<span class="hljs-string"><span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span> xmlns:app=<span class="hljs-string"><span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span></span> xmlns:tools=<span class="hljs-string"><span class="hljs-string">"http://schemas.android.com/tools"</span></span> android:layout_width=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span> android:layout_height=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span> tools:context=<span class="hljs-string"><span class="hljs-string">".MainActivity"</span></span>&gt; &lt;TextureView android:id=<span class="hljs-string"><span class="hljs-string">"@+id/textureView"</span></span> android:layout_width=<span class="hljs-string"><span class="hljs-string">"356dp"</span></span> android:layout_height=<span class="hljs-string"><span class="hljs-string">"410dp"</span></span> android:layout_marginTop=<span class="hljs-string"><span class="hljs-string">"32dp"</span></span> app:layout_constraintEnd_toEndOf=<span class="hljs-string"><span class="hljs-string">"parent"</span></span> app:layout_constraintHorizontal_bias=<span class="hljs-string"><span class="hljs-string">"0.49"</span></span> app:layout_constraintStart_toStartOf=<span class="hljs-string"><span class="hljs-string">"parent"</span></span> app:layout_constraintTop_toTopOf=<span class="hljs-string"><span class="hljs-string">"parent"</span></span> /&gt; &lt;LinearLayout android:layout_width=<span class="hljs-string"><span class="hljs-string">"292dp"</span></span> android:layout_height=<span class="hljs-string"><span class="hljs-string">"145dp"</span></span> android:layout_marginStart=<span class="hljs-string"><span class="hljs-string">"16dp"</span></span> android:orientation=<span class="hljs-string"><span class="hljs-string">"vertical"</span></span> app:layout_constraintBottom_toBottomOf=<span class="hljs-string"><span class="hljs-string">"parent"</span></span> app:layout_constraintEnd_toEndOf=<span class="hljs-string"><span class="hljs-string">"parent"</span></span> app:layout_constraintStart_toStartOf=<span class="hljs-string"><span class="hljs-string">"parent"</span></span> app:layout_constraintTop_toBottomOf=<span class="hljs-string"><span class="hljs-string">"@+id/textureView"</span></span> app:layout_constraintVertical_bias=<span class="hljs-string"><span class="hljs-string">"0.537"</span></span>&gt; &lt;Button android:id=<span class="hljs-string"><span class="hljs-string">"@+id/button1"</span></span> android:layout_width=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span> android:layout_height=<span class="hljs-string"><span class="hljs-string">"wrap_content"</span></span> android:text=<span class="hljs-string"><span class="hljs-string">"   "</span></span> /&gt; &lt;Button android:id=<span class="hljs-string"><span class="hljs-string">"@+id/button2"</span></span> android:layout_width=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span> android:layout_height=<span class="hljs-string"><span class="hljs-string">"wrap_content"</span></span> android:text=<span class="hljs-string"><span class="hljs-string">" "</span></span> /&gt; &lt;Button android:id=<span class="hljs-string"><span class="hljs-string">"@+id/button3"</span></span> android:layout_width=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span> android:layout_height=<span class="hljs-string"><span class="hljs-string">"wrap_content"</span></span> android:text=<span class="hljs-string"><span class="hljs-string">" "</span></span> /&gt; &lt;/LinearLayout&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code> </pre> <br></div></div><br><h4>  Et terminez avec le raccordement Media Codec </h4><br>  Dans le dernier article, nous avons affich√© l'image de la cam√©ra sur la Surface et √©crit une vid√©o √† partir de celle-ci √† l'aide de MediaRecorder.  Pour ce faire, nous avons simplement sp√©cifi√© les deux composants dans la liste Surface. <br><br><pre> <code class="java hljs">(Arrays.asList(surface, mMediaRecorder.getSurface()).</code> </pre><br>  Ici, la m√™me chose, seulement au lieu de mMediaRecorder, nous sp√©cifions: <br><br><pre> <code class="java hljs">(Arrays.asList(surface, mEncoderSurface),</code> </pre><br>  Il s'av√®re que quelque chose comme: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startCameraPreviewSession</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ SurfaceTexture texture = mImageView.getSurfaceTexture(); texture.setDefaultBufferSize(<span class="hljs-number"><span class="hljs-number">320</span></span>, <span class="hljs-number"><span class="hljs-number">240</span></span>); surface = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Surface(texture); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { mPreviewBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW); mPreviewBuilder.addTarget(surface); mPreviewBuilder.addTarget(mEncoderSurface); mCameraDevice.createCaptureSession(Arrays.asList(surface, mEncoderSurface), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CameraCaptureSession.StateCallback() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onConfigured</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CameraCaptureSession session)</span></span></span><span class="hljs-function"> </span></span>{ mSession = session; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { mSession.setRepeatingRequest(mPreviewBuilder.build(), <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, mBackgroundHandler); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (CameraAccessException e) { e.printStackTrace(); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onConfigureFailed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CameraCaptureSession session)</span></span></span><span class="hljs-function"> </span></span>{ } }, mBackgroundHandler); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (CameraAccessException e) { e.printStackTrace(); } }</code> </pre><br>  Qu'est-ce que mEncoderSurface?  Et c'est la m√™me surface avec laquelle Media Codec fonctionnera.  Pour commencer, vous devez les initialiser tous les deux approximativement de cette fa√ßon. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpMediaCodec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { mCodec = MediaCodec.createEncoderByType(<span class="hljs-string"><span class="hljs-string">"video/avc"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// H264  } catch (Exception e) { Log.i(LOG_TAG, "  "); } int width = 320; //   int height = 240; //   int colorFormat = MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface; //    int videoBitrate = 500000; //    bps (  ) int videoFramePerSecond = 20; // FPS int iframeInterval = 2; // I-Frame    MediaFormat format = MediaFormat.createVideoFormat("video/avc", width, height); format.setInteger(MediaFormat.KEY_COLOR_FORMAT, colorFormat); format.setInteger(MediaFormat.KEY_BIT_RATE, videoBitrate); format.setInteger(MediaFormat.KEY_FRAME_RATE, videoFramePerSecond); format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, iframeInterval); mCodec.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE); //     mEncoderSurface = mCodec.createInputSurface(); //  Surface  mCodec.setCallback(new EncoderCallback()); mCodec.start(); //   Log.i(LOG_TAG, " "); }</span></span></code> </pre><br>  Reste maintenant √† enregistrer un seul rappel.  Lorsque Media Codec sent soudain que les prochaines donn√©es pour une diffusion ult√©rieure sont pr√™tes, il nous en informe par son interm√©diaire: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EncoderCallback</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MediaCodec</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Callback</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onInputBufferAvailable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MediaCodec codec, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onOutputBufferAvailable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MediaCodec codec, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, MediaCodec.BufferInfo info)</span></span></span><span class="hljs-function"> </span></span>{ outPutByteBuffer = mCodec.getOutputBuffer(index); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] outDate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[info.size]; outPutByteBuffer.get(outDate); Log.i(LOG_TAG, <span class="hljs-string"><span class="hljs-string">" outDate.length : "</span></span> + outDate.length); mCodec.releaseOutputBuffer(index, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MediaCodec codec, MediaCodec.CodecException e)</span></span></span><span class="hljs-function"> </span></span>{ Log.i(LOG_TAG, <span class="hljs-string"><span class="hljs-string">"Error: "</span></span> + e); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onOutputFormatChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MediaCodec codec, MediaFormat format)</span></span></span><span class="hljs-function"> </span></span>{ Log.i(LOG_TAG, <span class="hljs-string"><span class="hljs-string">"encoder output format changed: "</span></span> + format); } }</code> </pre><br>  Le tableau d'octets outDate est un v√©ritable tr√©sor.  Il contient des √©l√©ments pr√™ts √† l'emploi d'un flux vid√©o H264 encod√© avec lequel nous pouvons maintenant faire ce que nous voulons. <br><br>  Les voici ... <br><br><img src="https://habrastorage.org/webt/lh/pe/kz/lhpekzdgk-z95gpos8493tdgdqi.png"><br><br>  Certaines pi√®ces peuvent √™tre trop volumineuses pour √™tre transmises sur le r√©seau, mais rien, le syst√®me, si n√©cessaire, les d√©coupera par lui-m√™me et les enverra au destinataire. <br>  Mais si c'est tr√®s effrayant, alors vous pouvez vous d√©chiqueter en poussant un tel fragment <br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count =<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> temp =outDate.length ; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {<span class="hljs-comment"><span class="hljs-comment">//    byte[] ds; temp = temp-1024; if(temp&gt;=0) { ds = new byte[1024];} else { ds = new byte[temp+1024];} for(int i =0;i&lt;ds.length;i++) { ds[i]=outDate[i+1024*count]; } count=count+1; try { // Log.i(LOG_TAG, " outDate.length : " + ds.length); DatagramPacket packet = new DatagramPacket(ds, ds.length, address, port); udpSocket.send(packet); } catch (IOException e) { Log.i(LOG_TAG, "   UDP "); } } while (temp&gt;=0);</span></span></code> </pre><br><br>  Mais pour l'instant, nous devons voir de premi√®re main que les donn√©es dans le tampon sont vraiment un flux vid√©o H264.  Par cons√©quent, envoyons-les dans un fichier: <br><br>  Nous √©crirons dans la configuration: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpMediaCodec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ File mFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM), <span class="hljs-string"><span class="hljs-string">"test3.h264"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { outputStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferedOutputStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileOutputStream(mFile)); Log.i(<span class="hljs-string"><span class="hljs-string">"Encoder"</span></span>, <span class="hljs-string"><span class="hljs-string">"outputStream initialized"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { e.printStackTrace(); }</code> </pre><br>  Et dans le rappel o√π est le tampon: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { outputStream.write(outDate, <span class="hljs-number"><span class="hljs-number">0</span></span>, outDate.length);<span class="hljs-comment"><span class="hljs-comment">//     } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); }</span></span></code> </pre><br>  Ouvrez l'application, appuyez sur le bouton: "ALLUMER L'APPAREIL PHOTO ET LE FLUX".  L'enregistrement d√©marre automatiquement.  Nous attendons un peu et appuyons sur le bouton stop. <br><br>  Le fichier enregistr√© ne sera normalement pas perdu, car le format n'est pas MP4, mais si vous l'ouvrez avec un lecteur VLC ou le convertissez en ligne en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utilisant ONLINE CONVERT</a> , nous nous assurerons que nous sommes sur la bonne voie.  Certes, l'image se trouve sur le c√¥t√©, mais elle est r√©parable. <br><br>  En g√©n√©ral, pour chaque √©v√©nement d'enregistrement, de photographie ou de streaming, il est bien s√ªr pr√©f√©rable d'ouvrir une nouvelle session √† chaque fois et de fermer l'ancienne.  Autrement dit, nous allumons d'abord l'appareil photo et lan√ßons l'aper√ßu nu.  Ensuite, si vous devez prendre une photo, fermez l'aper√ßu et ouvrez l'aper√ßu, mais avec Image Reader fix√©.  Si nous passons √† l'enregistrement vid√©o, fermez la session en cours et d√©marrez la session avec l'aper√ßu et le Media Recorder qui y sont attach√©s.  Je ne l'ai pas fait, pour que la visibilit√© du code n'en souffre pas, et vous d√©cidez comment cela vous convient plus. <br><br>  Et voici tout le code. <br><br><div class="spoiler">  <b class="spoiler_title">BasicMediaCodec</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.basicmediacodec; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> androidx.annotation.RequiresApi; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> androidx.appcompat.app.AppCompatActivity; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> androidx.core.content.ContextCompat; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.Manifest; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.content.Context; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.content.pm.ActivityInfo; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.content.pm.PackageManager; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.graphics.SurfaceTexture; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CameraAccessException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CameraCaptureSession; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CameraDevice; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CameraManager; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CaptureRequest; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.media.MediaCodec; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.media.MediaCodecInfo; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.media.MediaFormat; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.Build; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.Bundle; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.Environment; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.Handler; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.HandlerThread; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.StrictMode; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.util.Log; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.view.Surface; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.view.TextureView; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.view.View; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.widget.Button; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.widget.Toast; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.BufferedOutputStream; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileOutputStream; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.ByteBuffer; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Arrays; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String LOG_TAG = <span class="hljs-string"><span class="hljs-string">"myLogs"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Surface surface = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; CameraService[] myCameras = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CameraManager mCameraManager = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CAMERA1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Button mButtonOpenCamera1 = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Button mButtonStreamVideo = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Button mButtonTStopStreamVideo = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> TextureView mImageView = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> HandlerThread mBackgroundThread; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Handler mBackgroundHandler = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MediaCodec mCodec = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Surface mEncoderSurface; // Surface      BufferedOutputStream outputStream; ByteBuffer outPutByteBuffer; private void startBackgroundThread() { mBackgroundThread = new HandlerThread("CameraBackground"); mBackgroundThread.start(); mBackgroundHandler = new Handler(mBackgroundThread.getLooper()); } private void stopBackgroundThread() { mBackgroundThread.quitSafely(); try { mBackgroundThread.join(); mBackgroundThread = null; mBackgroundHandler = null; } catch (InterruptedException e) { e.printStackTrace(); } } @RequiresApi(api = Build.VERSION_CODES.M) @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); setContentView(R.layout.activity_main); Log.d(LOG_TAG, " "); if (checkSelfPermission(Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED || (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) ) { requestPermissions(new String[]{Manifest.permission.CAMERA, Manifest.permission.WRITE_EXTERNAL_STORAGE}, 1); } mButtonOpenCamera1 = findViewById(R.id.button1); mButtonStreamVideo = findViewById(R.id.button2); mButtonTStopStreamVideo = findViewById(R.id.button3); mImageView = findViewById(R.id.textureView); mButtonOpenCamera1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { setUpMediaCodec();//    if (myCameras[CAMERA1] != null) {//   if (!myCameras[CAMERA1].isOpen()) myCameras[CAMERA1].openCamera(); } } }); mButtonStreamVideo.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { { //    } } }); mButtonTStopStreamVideo.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if (mCodec != null) { Toast.makeText(MainActivity.this, "  ", Toast.LENGTH_SHORT).show(); myCameras[CAMERA1].stopStreamingVideo(); } } }); mCameraManager = (CameraManager) getSystemService(Context.CAMERA_SERVICE); try { //      myCameras = new CameraService[mCameraManager.getCameraIdList().length]; for (String cameraID : mCameraManager.getCameraIdList()) { Log.i(LOG_TAG, "cameraID: " + cameraID); int id = Integer.parseInt(cameraID); //     myCameras[id] = new CameraService(mCameraManager, cameraID); } } catch (CameraAccessException e) { Log.e(LOG_TAG, e.getMessage()); e.printStackTrace(); } } public class CameraService { private String mCameraID; private CameraDevice mCameraDevice = null; private CameraCaptureSession mSession; private CaptureRequest.Builder mPreviewBuilder; public CameraService(CameraManager cameraManager, String cameraID) { mCameraManager = cameraManager; mCameraID = cameraID; } private CameraDevice.StateCallback mCameraCallback = new CameraDevice.StateCallback() { @Override public void onOpened(CameraDevice camera) { mCameraDevice = camera; Log.i(LOG_TAG, "Open camera with id:" + mCameraDevice.getId()); startCameraPreviewSession(); } @Override public void onDisconnected(CameraDevice camera) { mCameraDevice.close(); Log.i(LOG_TAG, "disconnect camera with id:" + mCameraDevice.getId()); mCameraDevice = null; } @Override public void onError(CameraDevice camera, int error) { Log.i(LOG_TAG, "error! camera id:" + camera.getId() + " error:" + error); } }; private void startCameraPreviewSession() { SurfaceTexture texture = mImageView.getSurfaceTexture(); texture.setDefaultBufferSize(320, 240); surface = new Surface(texture); try { mPreviewBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW); mPreviewBuilder.addTarget(surface); mPreviewBuilder.addTarget(mEncoderSurface); mCameraDevice.createCaptureSession(Arrays.asList(surface, mEncoderSurface), new CameraCaptureSession.StateCallback() { @Override public void onConfigured(CameraCaptureSession session) { mSession = session; try { mSession.setRepeatingRequest(mPreviewBuilder.build(), null, mBackgroundHandler); } catch (CameraAccessException e) { e.printStackTrace(); } } @Override public void onConfigureFailed(CameraCaptureSession session) { } }, mBackgroundHandler); } catch (CameraAccessException e) { e.printStackTrace(); } } public boolean isOpen() { if (mCameraDevice == null) { return false; } else { return true; } } public void openCamera() { try { if (checkSelfPermission(Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED) { mCameraManager.openCamera(mCameraID, mCameraCallback, mBackgroundHandler); } } catch (CameraAccessException e) { Log.i(LOG_TAG, e.getMessage()); } } public void closeCamera() { if (mCameraDevice != null) { mCameraDevice.close(); mCameraDevice = null; } } public void stopStreamingVideo() { if (mCameraDevice != null &amp; mCodec != null) { try { mSession.stopRepeating(); mSession.abortCaptures(); } catch (CameraAccessException e) { e.printStackTrace(); } mCodec.stop(); mCodec.release(); mEncoderSurface.release(); closeCamera(); } } } private void setUpMediaCodec() { File mFile = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM), "test3.h264"); try { outputStream = new BufferedOutputStream(new FileOutputStream(mFile)); Log.i("Encoder", "outputStream initialized"); } catch (Exception e) { e.printStackTrace(); } try { mCodec = MediaCodec.createEncoderByType("video/avc"); // H264  } catch (Exception e) { Log.i(LOG_TAG, "  "); } int width = 320; //   int height = 240; //   int colorFormat = MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface; //    int videoBitrate = 500000; //    bps (  ) int videoFramePerSecond = 20; // FPS int iframeInterval = 3; // I-Frame    MediaFormat format = MediaFormat.createVideoFormat("video/avc", width, height); format.setInteger(MediaFormat.KEY_COLOR_FORMAT, colorFormat); format.setInteger(MediaFormat.KEY_BIT_RATE, videoBitrate); format.setInteger(MediaFormat.KEY_FRAME_RATE, videoFramePerSecond); format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, iframeInterval); mCodec.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE); //     mEncoderSurface = mCodec.createInputSurface(); //  Surface  mCodec.setCallback(new EncoderCallback()); mCodec.start(); //   Log.i(LOG_TAG, " "); } private class EncoderCallback extends MediaCodec.Callback { @Override public void onInputBufferAvailable(MediaCodec codec, int index) { } @Override public void onOutputBufferAvailable(MediaCodec codec, int index, MediaCodec.BufferInfo info) { outPutByteBuffer = mCodec.getOutputBuffer(index); byte[] outDate = new byte[info.size]; outPutByteBuffer.get(outDate); try { Log.i(LOG_TAG, " outDate.length : " + outDate.length); outputStream.write(outDate, 0, outDate.length);//     } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } mCodec.releaseOutputBuffer(index, false); } @Override public void onError(MediaCodec codec, MediaCodec.CodecException e) { Log.i(LOG_TAG, "Error: " + e); } @Override public void onOutputFormatChanged(MediaCodec codec, MediaFormat format) { Log.i(LOG_TAG, "encoder output format changed: " + format); } } @Override public void onPause() { if (myCameras[CAMERA1].isOpen()) { myCameras[CAMERA1].closeCamera(); } stopBackgroundThread(); super.onPause(); } @Override public void onResume() { super.onResume(); startBackgroundThread(); } }</span></span></code> </pre><br></div></div><br>  Et n'oubliez pas les autorisations dans le manifeste. <br><br><pre> <code class="java hljs"> &lt;uses-permission android:name=<span class="hljs-string"><span class="hljs-string">"android.permission.CAMERA"</span></span> /&gt; &lt;uses-permission android:name=<span class="hljs-string"><span class="hljs-string">"android.permission.INTERNET"</span></span>/&gt;</code> </pre><br>  Nous nous sommes donc assur√©s que Media Codec fonctionne.  Mais l'utiliser pour √©crire une vid√©o dans un fichier est en quelque sorte insens√©.  L'enregistreur multim√©dia peut g√©rer cette t√¢che beaucoup mieux et il ajoutera du son.  Par cons√©quent, nous jetterons √† nouveau la partie fichier et ajouterons un bloc de code pour la vid√©o en streaming sur le r√©seau en utilisant le protocole udp.  C'est aussi tr√®s simple. <br><br>  Tout d'abord, nous initialisons le serveur UDP pratiquement. <br><br><pre> <code class="java hljs"> DatagramSocket udpSocket; String ip_address = <span class="hljs-string"><span class="hljs-string">"192.168.1.84"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      InetAddress address; int port = 40002; // ,      ‚Ä¶‚Ä¶.. try { udpSocket = new DatagramSocket(); Log.i(LOG_TAG, "  udp "); } catch ( SocketException e) { Log.i(LOG_TAG, "   udp "); } try { address = InetAddress.getByName(ip_address); Log.i(LOG_TAG, "  "); } catch (Exception e) {</span></span></code> </pre><br>  Et dans le m√™me rappel, o√π nous avons envoy√© des donn√©es de pr√©paration au flux pour le fichier, nous allons maintenant les envoyer sous forme de datagrammes √† notre r√©seau domestique (j'esp√®re que tout le monde les a?) <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { DatagramPacket packet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DatagramPacket(outDate, outDate.length, address, port); udpSocket.send(packet); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException e) { Log.i(LOG_TAG, <span class="hljs-string"><span class="hljs-string">"   UDP "</span></span>); }</code> </pre><br><br>  C'est tout? <br><br>  Il semblerait, mais non.  L'application s'√©claircira au d√©marrage.  Vous voyez, le syst√®me n'aime pas que dans le flux principal, nous envoyons toutes sortes de paquets de datagrammes.  Mais il n'y a aucune raison de paniquer.  Premi√®rement, bien que nous soyons dans le thread principal, nous travaillons toujours de mani√®re asynchrone, c'est-√†-dire pour d√©clencher un rappel.  Deuxi√®mement, l'envoi de paquets udp est le m√™me processus asynchrone.  Nous disons seulement au syst√®me d'exploitation qu'il serait bien d'envoyer un paquet, mais que nous comptons enti√®rement sur lui dans cette affaire.  Par cons√©quent, afin qu'Android ne se rebelle pas, nous ajouterons deux lignes au d√©but du programme: <br><br><pre> <code class="java hljs"> StrictMode.ThreadPolicy policy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StrictMode.ThreadPolicy.Builder().permitAll().build(); StrictMode.setThreadPolicy(policy);</code> </pre><br>  En g√©n√©ral, le petit programme de d√©monstration <s>√©l√©gant</s> suivant se r√©v√©lera: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.basicmediacodec; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> androidx.annotation.RequiresApi; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> androidx.appcompat.app.AppCompatActivity; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> androidx.core.content.ContextCompat; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.Manifest; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.content.Context; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.content.pm.ActivityInfo; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.content.pm.PackageManager; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.graphics.SurfaceTexture; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CameraAccessException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CameraCaptureSession; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CameraDevice; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CameraManager; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.camera2.CaptureRequest; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.media.MediaCodec; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.media.MediaCodecInfo; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.media.MediaFormat; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.Build; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.Bundle; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.Handler; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.HandlerThread; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.StrictMode; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.util.Log; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.view.Surface; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.view.TextureView; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.view.View; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.widget.Button; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.widget.Toast; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.BufferedOutputStream; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.DatagramPacket; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.DatagramSocket; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.InetAddress; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.SocketException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.ByteBuffer; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Arrays; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String LOG_TAG = <span class="hljs-string"><span class="hljs-string">"myLogs"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Surface surface = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; CameraService[] myCameras = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CameraManager mCameraManager = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CAMERA1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Button mButtonOpenCamera1 = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Button mButtonStreamVideo = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Button mButtonTStopStreamVideo = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> TextureView mImageView = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> HandlerThread mBackgroundThread; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Handler mBackgroundHandler = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MediaCodec mCodec = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Surface mEncoderSurface; // Surface      BufferedOutputStream outputStream; ByteBuffer outPutByteBuffer; DatagramSocket udpSocket; String ip_address = "192.168.1.84"; InetAddress address; int port = 40002; private void startBackgroundThread() { mBackgroundThread = new HandlerThread("CameraBackground"); mBackgroundThread.start(); mBackgroundHandler = new Handler(mBackgroundThread.getLooper()); } private void stopBackgroundThread() { mBackgroundThread.quitSafely(); try { mBackgroundThread.join(); mBackgroundThread = null; mBackgroundHandler = null; } catch (InterruptedException e) { e.printStackTrace(); } } @RequiresApi(api = Build.VERSION_CODES.M) @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitAll().build(); StrictMode.setThreadPolicy(policy); setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); setContentView(R.layout.activity_main); Log.d(LOG_TAG, " "); if (checkSelfPermission(Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED || (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) ) { requestPermissions(new String[]{Manifest.permission.CAMERA, Manifest.permission.WRITE_EXTERNAL_STORAGE}, 1); } mButtonOpenCamera1 = findViewById(R.id.button1); mButtonStreamVideo = findViewById(R.id.button2); mButtonTStopStreamVideo = findViewById(R.id.button3); mImageView = findViewById(R.id.textureView); mButtonOpenCamera1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { setUpMediaCodec();//    if (myCameras[CAMERA1] != null) {//   if (!myCameras[CAMERA1].isOpen()) myCameras[CAMERA1].openCamera(); } } }); mButtonStreamVideo.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { { //    } } }); mButtonTStopStreamVideo.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if (mCodec != null) { Toast.makeText(MainActivity.this, "  ", Toast.LENGTH_SHORT).show(); myCameras[CAMERA1].stopStreamingVideo(); } } }); try { udpSocket = new DatagramSocket(); Log.i(LOG_TAG, "  udp "); } catch ( SocketException e) { Log.i(LOG_TAG, "   udp "); } try { address = InetAddress.getByName(ip_address); Log.i(LOG_TAG, "  "); } catch (Exception e) { } mCameraManager = (CameraManager) getSystemService(Context.CAMERA_SERVICE); try { //      myCameras = new CameraService[mCameraManager.getCameraIdList().length]; for (String cameraID : mCameraManager.getCameraIdList()) { Log.i(LOG_TAG, "cameraID: " + cameraID); int id = Integer.parseInt(cameraID); //     myCameras[id] = new CameraService(mCameraManager, cameraID); } } catch (CameraAccessException e) { Log.e(LOG_TAG, e.getMessage()); e.printStackTrace(); } } public class CameraService { private String mCameraID; private CameraDevice mCameraDevice = null; private CameraCaptureSession mSession; private CaptureRequest.Builder mPreviewBuilder; public CameraService(CameraManager cameraManager, String cameraID) { mCameraManager = cameraManager; mCameraID = cameraID; } private CameraDevice.StateCallback mCameraCallback = new CameraDevice.StateCallback() { @Override public void onOpened(CameraDevice camera) { mCameraDevice = camera; Log.i(LOG_TAG, "Open camera with id:" + mCameraDevice.getId()); startCameraPreviewSession(); } @Override public void onDisconnected(CameraDevice camera) { mCameraDevice.close(); Log.i(LOG_TAG, "disconnect camera with id:" + mCameraDevice.getId()); mCameraDevice = null; } @Override public void onError(CameraDevice camera, int error) { Log.i(LOG_TAG, "error! camera id:" + camera.getId() + " error:" + error); } }; private void startCameraPreviewSession() { SurfaceTexture texture = mImageView.getSurfaceTexture(); texture.setDefaultBufferSize(320, 240); surface = new Surface(texture); try { mPreviewBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW); mPreviewBuilder.addTarget(surface); mPreviewBuilder.addTarget(mEncoderSurface); mCameraDevice.createCaptureSession(Arrays.asList(surface, mEncoderSurface), new CameraCaptureSession.StateCallback() { @Override public void onConfigured(CameraCaptureSession session) { mSession = session; try { mSession.setRepeatingRequest(mPreviewBuilder.build(), null, mBackgroundHandler); } catch (CameraAccessException e) { e.printStackTrace(); } } @Override public void onConfigureFailed(CameraCaptureSession session) { } }, mBackgroundHandler); } catch (CameraAccessException e) { e.printStackTrace(); } } public boolean isOpen() { if (mCameraDevice == null) { return false; } else { return true; } } public void openCamera() { try { if (checkSelfPermission(Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED) { mCameraManager.openCamera(mCameraID, mCameraCallback, mBackgroundHandler); } } catch (CameraAccessException e) { Log.i(LOG_TAG, e.getMessage()); } } public void closeCamera() { if (mCameraDevice != null) { mCameraDevice.close(); mCameraDevice = null; } } public void stopStreamingVideo() { if (mCameraDevice != null &amp; mCodec != null) { try { mSession.stopRepeating(); mSession.abortCaptures(); } catch (CameraAccessException e) { e.printStackTrace(); } mCodec.stop(); mCodec.release(); mEncoderSurface.release(); closeCamera(); } } } private void setUpMediaCodec() { try { mCodec = MediaCodec.createEncoderByType("video/avc"); // H264  } catch (Exception e) { Log.i(LOG_TAG, "  "); } int width = 320; //   int height = 240; //   int colorFormat = MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface; //    int videoBitrate = 500000; //    bps (  ) int videoFramePerSecond = 20; // FPS int iframeInterval = 3; // I-Frame    MediaFormat format = MediaFormat.createVideoFormat("video/avc", width, height); format.setInteger(MediaFormat.KEY_COLOR_FORMAT, colorFormat); format.setInteger(MediaFormat.KEY_BIT_RATE, videoBitrate); format.setInteger(MediaFormat.KEY_FRAME_RATE, videoFramePerSecond); format.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, iframeInterval); mCodec.configure(format, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE); //     mEncoderSurface = mCodec.createInputSurface(); //  Surface  mCodec.setCallback(new EncoderCallback()); mCodec.start(); //   Log.i(LOG_TAG, " "); } private class EncoderCallback extends MediaCodec.Callback { @Override public void onInputBufferAvailable(MediaCodec codec, int index) { } @Override public void onOutputBufferAvailable(MediaCodec codec, int index, MediaCodec.BufferInfo info) { outPutByteBuffer = mCodec.getOutputBuffer(index); byte[] outDate = new byte[info.size]; outPutByteBuffer.get(outDate); try { DatagramPacket packet = new DatagramPacket(outDate, outDate.length, address, port); udpSocket.send(packet); } catch (IOException e) { Log.i(LOG_TAG, "   UDP "); } mCodec.releaseOutputBuffer(index, false); } @Override public void onError(MediaCodec codec, MediaCodec.CodecException e) { Log.i(LOG_TAG, "Error: " + e); } @Override public void onOutputFormatChanged(MediaCodec codec, MediaFormat format) { Log.i(LOG_TAG, "encoder output format changed: " + format); } } @Override public void onPause() { if (myCameras[CAMERA1].isOpen()) { myCameras[CAMERA1].closeCamera(); } stopBackgroundThread(); super.onPause(); } @Override public void onResume() { super.onResume(); startBackgroundThread(); } }</span></span></code> </pre><br>  Je ne sais pas comment font les autres, mais sur mon Red Note 7, vous pouvez m√™me voir comment les kilo-octets sont t√©l√©charg√©s √† la bonne adresse <br><br><img src="https://habrastorage.org/webt/9x/3q/gz/9x3qgzrctdcevzw5ym5zi6imgq8.png"><br><br>  Et il y a beaucoup de telles sockets udp, combien de bande passante r√©seau est suffisante.  L'essentiel est qu'il y ait des adresses o√π.  Vous aurez une √©mission. <br><br><h4>  Maintenant, allons chercher l'adresse souhait√©e sur l'ordinateur </h4><br>  Je dois dire que tous les programmes informatiques ne sont pas capables d'absorber et de dig√©rer un flux vid√©o H264 via un seul canal udp sans aucune information suppl√©mentaire.  Mais certains le peuvent.  Il s'agit par exemple du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lecteur</a> multim√©dia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">VLC</a> extr√™mement connu.  C'est tellement cool que si vous commencez √† d√©crire ses capacit√©s, vous obtenez un livre entier dans l'article.  Vous l'avez s√ªrement.  Sinon, mettez-le. <br><br>  Et √† en juger par la description des commandes, les paquets udp peuvent dig√©rer ce lecteur. <br><br><pre> <code class="java hljs">URL syntax: file:<span class="hljs-comment"><span class="hljs-comment">///path/file Plain media file http://host[:port]/file HTTP URL ftp://host[:port]/file FTP URL mms://host[:port]/file MMS URL screen:// Screen capture dvd://[device] DVD device vcd://[device] VCD device cdda://[device] Audio CD device udp://[[&lt;source address&gt;]@[&lt;bind address&gt;][:&lt;bind port&gt;]]</span></span></code> </pre><br>  Et toutes ces adresses source et adresse de liaison, en th√©orie, ne sont pas n√©cessaires.  Seul le port d'√©coute est n√©cessaire. <br><br><img src="https://habrastorage.org/webt/7-/kw/pi/7-kwpik08ayqmgvd2rta1sqjtae.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et pourtant, bien s√ªr, vous ne devez pas oublier d'autoriser ce port √† √©couter (Malvar) </font></font><br><br><img src="https://habrastorage.org/webt/ix/9r/sj/ix9rsjovph-xzqgmosv_kgu-in4.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saviez-vous que Windows ne vous permet pas de faire un √©cran d'impression √† partir du moniteur de ressources? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ou vous pouvez d√©sactiver le pare-feu (je ne le recommande pas) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Donc, apr√®s avoir surmont√© ces √©pines, nous lan√ßons le lecteur VLC avec notre adresse et profitons de l'√©cran vide. </font><font style="vertical-align: inherit;">Pas de vid√©o.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comment √ßa? </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et ainsi. </font><font style="vertical-align: inherit;">Vous avez probablement la derni√®re version de VLC 3.08 Vetinari? </font><font style="vertical-align: inherit;">Voil√†, dans cette version d'udp, il est d√©clar√© obsol√®te et, de plus, il est foutu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La logique des d√©veloppeurs du joueur est donc claire. </font><font style="vertical-align: inherit;">Peu de gens ont besoin d'utiliser le canal udp nu aujourd'hui:</font></font><br><br><ul><li>       .                 ,    .       . </li><li>     </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par cons√©quent, les gens normaux, bien s√ªr, utilisent des protocoles de niveau sup√©rieur RTP et autres. Autrement dit, vous √©crivez un serveur qui utilise udp (pour la vitesse) de toute fa√ßon, mais en m√™me temps √©change des informations de contr√¥le avec le client auquel il diffuse la vid√©o. Quelle est sa bande passante, est-il n√©cessaire d'augmenter ou de diminuer le cache pour les donn√©es, quels d√©tails d'image sont optimaux maintenant, et ainsi de suite. Encore une fois, le son est parfois n√©cessaire. Et il a besoin, vous savez, de synchronisation avec la vid√©o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âcoutez, les gars d'Odnoklassniki ont m√™me d√ª </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©poser</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> leur </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">protocole</font></a><font style="vertical-align: inherit;"> pour le streaming. Mais leurs t√¢ches, bien s√ªr, sont beaucoup plus importantes - envoyer des vid√©os avec des chats √† des dizaines de millions de femmes au foyer √† travers le monde. L√†, vous ne g√©rerez pas un canal udp.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais nous sommes en quelque sorte tristes d'√©crire notre serveur RTP sur Android. Probablement, vous pouvez m√™me trouver des √©l√©ments pr√™ts √† l'emploi et m√™me gratuits, mais essayons de ne pas compliquer les entit√©s pour l'instant. Prenez simplement la version du lecteur VLC o√π le streaming udp fonctionnait toujours. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alors, t√©l√©chargez ici </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VLC 2.2.6 Umbrella</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Install au lieu de ou √† c√¥t√© de l'ancien (c'est-√†-dire le nouveau VLC), comme vous le souhaitez. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous commen√ßons et voyons √† nouveau un √©cran vide. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et tout cela parce que nous n'avons √©videmment pas configur√© l'utilisation du codec H264. Ainsi, VLC serait en mesure de s√©lectionner automatiquement le codec s'il devait traiter le fichier (dans les param√®tres initialement, la s√©lection automatique √©tait sp√©cifi√©e). Mais ils jettent un flux d'octets sur un seul canal, et il existe des dizaines de codecs pris en charge par VLC. Comment peut-il d√©terminer lequel appliquer?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par cons√©quent, nous installons le codec de force. </font></font><br><br><img src="https://habrastorage.org/webt/jq/f5/er/jqf5ercz20oa2hxzlbeqmokqgbs.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et maintenant, nous appr√©cions la diffusion de vid√©o "en direct". </font><font style="vertical-align: inherit;">La seule chose est que pour une raison quelconque, il se trouve sur le c√¥t√©, mais cela est d√©j√† facilement corrig√© dans les param√®tres du lecteur vid√©o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et vous pouvez simplement d√©marrer le lecteur √† partir de la ligne de commande avec cette cl√©:</font></font><br><br><pre> <code class="java hljs">C:\Program Files\VideoLAN\VLC\vlc udp:<span class="hljs-comment"><span class="hljs-comment">//@:40002 --demux h264 --video-filter=transform --transform-type=90</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et il va se d√©coder et tourner. </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/IbN9eh1uyv4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le streaming fonctionne donc. </font><font style="vertical-align: inherit;">Il ne reste plus qu'√† l'int√©grer dans la fen√™tre JAVA de l'application de contr√¥le du robot. </font><font style="vertical-align: inherit;">Nous en traiterons tr√®s prochainement dans la derni√®re partie.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr473036/">https://habr.com/ru/post/fr473036/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr473026/index.html">Om-yum-yum et validation des donn√©es</a></li>
<li><a href="../fr473028/index.html">En Russie a commenc√© √† importer des d√©chets radioactifs d'Europe? Tri√©</a></li>
<li><a href="../fr473030/index.html">Nous calculons les bots "mal√©fiques" potentiels et les bloquons par IP</a></li>
<li><a href="../fr473032/index.html">"L'espoir est une mauvaise strat√©gie." SRE intensif √† Moscou, 3-5 f√©vrier</a></li>
<li><a href="../fr473034/index.html">Comment s'asseoir timlid</a></li>
<li><a href="../fr473038/index.html">Code morse 8 bits</a></li>
<li><a href="../fr473042/index.html">Avantages et inconv√©nients de Django</a></li>
<li><a href="../fr473044/index.html">Comment cr√©er des captures d'√©cran efficaces pour une application dans l'App Store</a></li>
<li><a href="../fr473046/index.html">Vagues, vent et volont√©: comment la tablette robuste de Dell aide les Russes √† remporter des r√©gates internationales</a></li>
<li><a href="../fr473050/index.html">AMD oblige Intel √† r√©duire les prix non seulement sur les nouveaux, mais aussi sur les anciens mod√®les de CPU. C'est le d√©but d'une autre guerre des prix</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>