<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👶🏼 🐵 😴 Membuat mesin arcade emulator. Bagian 4 🚶🏼 🤷🏾 🤸🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagian yang pertama , kedua , ketiga . 

 Sisa mesin 
 Kode yang kami tulis untuk meniru prosesor 8080 cukup umum dan dapat dengan mudah diadaptasi un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membuat mesin arcade emulator. Bagian 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419143/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6eb/735/b99/6eb735b9990860a94f9ef0a18ba46a82.jpg" alt="gambar"></div><br>  Bagian yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kedua</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ketiga</a> . <br><br><h2>  Sisa mesin </h2><br>  Kode yang kami tulis untuk meniru prosesor 8080 cukup umum dan dapat dengan mudah diadaptasi untuk dijalankan pada mesin apa pun dengan kompiler C. Tetapi untuk memainkan permainan itu sendiri, kita perlu berbuat lebih banyak.  Kita harus meniru peralatan seluruh mesin arcade dan menulis kode yang menempelkan fitur spesifik dari lingkungan komputasi kita ke emulator. <br><br>  (Anda mungkin tertarik melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diagram sirkuit</a> mesin.) <br><a name="habracut"></a><br>
<h2>  Pengaturan waktu </h2><br>  Game ini berjalan pada 2 MHz 8080. Komputer Anda jauh lebih cepat.  Untuk mempertimbangkan ini, kita harus membuat semacam mekanisme. <br><br><h2>  Gangguan </h2><br>  Interupsi dirancang sedemikian rupa sehingga prosesor dapat memproses tugas dengan waktu eksekusi yang tepat, seperti I / O.  Prosesor dapat menjalankan program, dan ketika pin interupsi dipicu, ia berhenti menjalankan program saat ini dan melakukan sesuatu yang lain. <br><br>  Kita perlu mensimulasikan cara mesin arcade menghasilkan interupsi. <br><br><h2>  Grafik </h2><br>  Space Invaders menggambar grafik ke memorinya di kisaran alamat 0x2400.  Pengontrol video perangkat keras nyata akan membaca RAM dan mengontrol tampilan CRT.  Program kami harus meniru perilaku ini dengan menampilkan gambar permainan di jendela. <br><br><h2>  Tombol </h2><br>  Gim ini memiliki tombol fisik yang dibaca program menggunakan perintah IN pada prosesor 8080. Emulator kami harus mengikat input keyboard ke perintah IN ini. <br><br><h2>  ROM dan RAM </h2><br>  Saya harus mengakui: kita “memotong sudut” dengan membuat buffer memori 16-kilobyte, yang mencakup 16 KB alokasi memori prosesor yang lebih rendah.  Faktanya, alokasi memori 2 KB pertama adalah memori read-only (ROM) nyata.  Kita perlu menempatkan operasi tulis dalam memori ke dalam suatu fungsi sehingga tidak mungkin menulis ke ROM. <br><br><h2>  Suara </h2><br>  Sejauh ini kami belum mengatakan apa-apa tentang suara.  Space Invaders memiliki skema suara analog lucu yang mereproduksi satu dari 8 suara yang dikendalikan oleh perintah OUT, yang dikirim ke salah satu port.  Kami harus mengonversi perintah OUT ini untuk memutar sampel suara di platform kami. <br><br>  Ini mungkin terlihat seperti banyak pekerjaan, tetapi tidak terlalu buruk, dan kita dapat bergerak secara bertahap.  Hal pertama yang ingin kita lakukan adalah melihat layar, yang membutuhkan interupsi, grafik, dan bagian dari pemrosesan perintah IN dan OUT. <br><br><h2>  Menampilkan dan memperbarui </h2><br><h3>  Dasar-dasarnya </h3><br>  Anda mungkin akrab dengan komponen sistem tampilan video.  Di suatu tempat di sistem ada semacam RAM, yang berisi gambar untuk ditampilkan di layar.  Dalam hal perangkat analog, ada peralatan yang membaca RAM ini dan mengubah byte menjadi tegangan analog yang dikirim ke monitor. <br><br>  Pemahaman yang lebih dalam tentang sistem akan membantu kita dalam menganalisis tujuan alokasi memori dan fungsionalitas kode. <br><br>  Layar analog memiliki persyaratan untuk kecepatan dan waktu penyegaran.  Pada waktu tertentu, layar memiliki piksel spesifik yang diperbarui.  Gambar yang dikirimkan ke layar diisi titik demi titik, mulai dari sudut kiri atas dan ke kanan atas, kemudian titik pertama dari baris kedua, titik terakhir dari baris kedua, dll.  Setelah baris terakhir digambar di layar, pengontrol video dapat menghasilkan Vertical Blank Interrupt (juga dikenal sebagai VBI atau VBL). <br><br>  Untuk memastikan animasi yang lancar, gambar dalam RAM yang diproses oleh pengontrol video tidak dapat diubah.  Jika pembaruan RAM terjadi di tengah bingkai, pemirsa akan melihat bagian dari dua gambar.  Ini menghasilkan efek "sobekan" ketika bingkai yang berbeda dari bingkai di bagian bawah ditampilkan di bagian atas layar.  Jika Anda pernah melihat garis pemisah, Anda tahu seperti apa bentuknya. <br><br>  Untuk menghindari kesenjangan, perangkat lunak harus melakukan sesuatu untuk menghindari mentransfer lokasi pembaruan layar.  Dan hanya ada satu cara untuk melakukan ini. <br><br>  VBL dihasilkan setelah akhir baris terakhir, dan biasanya ada sejumlah waktu sebelum menggambar ulang baris pertama.  (Ini waktu Vertikal Kosong, dan bisa sekitar 1 milidetik.) <br><br>  Ketika VBL diterima, program mulai menampilkan layar dari atas. <br><br>  Setiap garis ditarik sebelum proses pemindaian bingkai terbalik. <br><br>  CPU selalu unggul, dan karenanya menghindari jeda baris. <br><br><div style="text-align:center;"><img src="http://www.emulator101.com/images/verticalretrace.jpg" alt="gambar"></div><br><h2>  Sistem Video Space Invaders </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Halaman yang</a> sangat informatif memberi tahu kami bahwa Space Invaders memiliki dua interupsi video.  Salah satunya adalah untuk ujung bingkai, tetapi juga menghasilkan interupsi di tengah layar.  Halaman ini menjelaskan sistem pembaruan layar - permainan menggambar grafik di bagian atas layar ketika menerima gangguan di tengah layar, dan menggambar grafik di bagian bawah layar ketika menerima gangguan di ujung bingkai.  Ini adalah cara yang cukup cerdas untuk menghilangkan jeda baris, dan contoh yang baik dari apa yang dapat dicapai ketika Anda mengembangkan perangkat keras dan perangkat lunak pada saat yang sama. <br><br>  Kita harus memaksa emulasi mesin kita untuk menghasilkan gangguan seperti itu.  Jika kita akan menghasilkan mereka dengan frekuensi 60 Hz, serta mesin Space Invaders, maka game akan ditarik dengan frekuensi yang benar. <br><br>  Pada bagian selanjutnya, kita akan berbicara tentang mekanisme interupsi dan memikirkan cara meniru mereka. <br><br><h2>  Tombol dan port </h2><br>  8080 mengimplementasikan I / O menggunakan instruksi IN dan OUT.  Ini memiliki 8 port IN dan OUT yang terpisah - port ditentukan oleh byte data dari perintah.  Misalnya, <code>IN 3</code> akan memasukkan nilai port 3 di register A, dan <code>OUT 2</code> akan mengirim A ke port 2. <br><br>  Saya mengambil informasi tentang tujuan masing-masing port dari situs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Arkeologi Komputer</a> .  Jika informasi ini tidak tersedia, kita harus mendapatkannya dengan mempelajari diagram sirkuit, serta membaca dan eksekusi kode langkah-demi-langkah. <br><br> <code>: <br>  1 <br>  0  (0,  ) <br> 1  Start   <br> 2  Start   <br> 3 ? <br> 4     <br> 5     <br> 6     <br> 7 ? <br> <br>  2 <br>  0,1 DIP-   (0:3,1:4,2:5,3:6) <br> 2 ""  <br> 3 DIP-  , 1:1000,0:1500 <br> 4     <br> 5     <br> 6     <br> 7    DIP-, 1:,0: <br> <br>  3    <br> <br>  2     ( 0,1,2) <br>  3    <br>  4    <br>  5    <br>  6  "" ? ,     , <br>       (0=a,1=b,2=c  ..) <br> <br> (  3,5,6      1=$01  2=$00 <br>    ,       (attract mode))</code> <br> <br>  Ada tiga cara untuk mengimplementasikan I / O di tumpukan perangkat lunak kami (yang terdiri dari emulator 8080, kode mesin, dan kode platform). <br><br><ol><li>  Cantumkan pengetahuan mesin di emulator 8080 kami </li><li>  Cantumkan pengetahuan 8080 emulator dalam kode mesin </li><li>  Ciptakan antarmuka formal antara tiga bagian kode untuk memungkinkan pertukaran informasi melalui API </li></ol><br>  Saya mengesampingkan opsi pertama - cukup jelas bahwa emulator berada di bagian paling bawah dari rantai panggilan ini dan harus tetap terpisah.  (Bayangkan Anda perlu menggunakan kembali emulator untuk gim lain, dan Anda akan mengerti apa yang saya maksud.) Dalam kasus umum, mentransfer struktur data tingkat tinggi ke level yang lebih rendah adalah solusi arsitektur yang buruk. <br><br>  Saya memilih opsi 2. Biarkan saya tunjukkan kode terlebih dahulu: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!done) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> opcode = state-&gt;memory[state-&gt;pc]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*opcode == <span class="hljs-number"><span class="hljs-number">0xdb</span></span>) <span class="hljs-comment"><span class="hljs-comment">//machine specific handling for IN { uint8_t port = opcode[1]; state-&gt;a = MachineIN(state, port); state-&gt;pc++; } else if (*opcode == 0xd3) //OUT { uint8_t port = opcode[1]; MachineOUT(state, port); state-&gt;pc++; } else Emulate8080Op(state); }</span></span></code> </pre> <br>  Kode ini mengimplementasikan kembali pemrosesan opcodes untuk IN dan OUT di lapisan yang sama, yang memanggil emulator untuk sisa perintah.  Menurut pendapat saya, ini membuat kode lebih bersih.  Ini mirip dengan override atau subclass untuk dua perintah, yang merujuk ke lapisan otomat. <br><br>  Kerugiannya adalah kita mentransfer emulasi opcode di dua tempat.  Saya tidak akan menyalahkan Anda karena memilih opsi ketiga.  Pada opsi kedua, lebih sedikit kode yang diperlukan, tetapi opsi 3 lebih "bersih", tetapi harganya merupakan peningkatan dalam kompleksitas.  Ini adalah masalah pilihan gaya. <br><br><h2>  Shift register </h2><br>  Mesin Space Invaders memiliki solusi perangkat keras yang menarik yang mengimplementasikan perintah bit shift.  8080 memiliki perintah untuk shift 1-bit, tetapi lusinan perintah 8080 akan diperlukan untuk mengimplementasikan shift multi-bit / multi-byte. Perangkat keras khusus memungkinkan game untuk melakukan operasi ini hanya dalam beberapa instruksi.  Dengan bantuannya, setiap frame digambar di bidang game, yaitu, ia digunakan berkali-kali per frame. <br><br>  Saya rasa saya tidak bisa menjelaskannya lebih baik daripada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">analisis</a> Arkeologi Komputer yang sangat baik: <br><br> <code>; 16- : <br> ; f 0  <br> ; xxxxxxxxyyyyyyyy <br> ; <br> ;    4  x  y,     x, : <br> ; $0000, <br> ; write $aa -&gt; $aa00, <br> ; write $ff -&gt; $ffaa, <br> ; write $12 -&gt; $12ff, .. <br> ; <br> ;    2 ( 0,1,2)    8- , : <br> ; offset 0: <br> ; rrrrrrrr result=xxxxxxxx <br> ; xxxxxxxxyyyyyyyy <br> ; <br> ; offset 2: <br> ; rrrrrrrr result=xxxxxxyy <br> ; xxxxxxxxyyyyyyyy <br> ; <br> ; offset 7: <br> ; rrrrrrrr result=xyyyyyyy <br> ; xxxxxxxxyyyyyyyy <br> ; <br> ;    3   .</code> <br> <br>  Untuk perintah OUT, menulis ke port 2 menetapkan jumlah shift, dan menulis ke port 4 mengatur data dalam register shift.  Membaca dengan IN 3 mengembalikan data yang digeser oleh jumlah shift.  Di mesin saya, ini diterapkan seperti ini: <br><br><pre> <code class="cpp hljs"> -(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>) MachineIN(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> port) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(port) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> v = (shift1&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>) | shift0; a = ((v &gt;&gt; (<span class="hljs-number"><span class="hljs-number">8</span></span>-shift_offset)) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } -(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) MachineOUT(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> port, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> value) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(port) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: shift_offset = value &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: shift0 = shift1; shift1 = value; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><h2>  Keyboard </h2><br>  Untuk mendapatkan respons mesin, kita perlu mengikat input keyboard ke sana.  Sebagian besar platform memiliki cara untuk menerima penekanan tombol dan melepaskan acara.  Kode platform untuk tombol akan terlihat seperti berikut: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(PeekMessage(&amp;msg,<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,PM_REMOVE)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (msg.message==WM_KEYDOWN ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( msg.wParam == VK_LEFT ) MachineKeyDown(LEFT); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (msg.message==WM_KEYUP ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( msg.wParam == VK_LEFT ) MachineKeyUp(LEFT); } }</code> </pre> <br>  Kode mesin yang menempelkan kode platform ke kode emulator akan terlihat seperti ini: <br><br><pre> <code class="cpp hljs"> MachineKeyDown(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> key) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(key) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> LEFT: port[<span class="hljs-number"><span class="hljs-number">1</span></span>] |= <span class="hljs-number"><span class="hljs-number">0x20</span></span>; <span class="hljs-comment"><span class="hljs-comment">//Set bit 5 of port 1 break; case RIGHT: port[1] |= 0x40; //Set bit 6 of port 1 break; /*....*/ } } PlatformKeyUp(char key) { switch(key) { case LEFT: port[1] &amp;= 0xDF //Clear bit 5 of port 1 break; case RIGHT: port[1] &amp;= 0xBF //Clear bit 6 of port 1 break; /*....*/ } }</span></span></code> </pre> <br>  Jika mau, Anda dapat menggabungkan kode mesin dan platform sesuka Anda - ini adalah pilihan implementasi.  Saya tidak akan melakukan ini karena saya akan port mesin ke beberapa platform yang berbeda. <br><br><h2>  Gangguan </h2><br>  Setelah mempelajari manual, saya menyadari bahwa 8080 menangani interupsi sebagai berikut: <br><br><ol><li>  Sumber interupsi (eksternal ke CPU) mengatur pin interupsi CPU. </li><li>  Ketika CPU mengonfirmasi interupsi diterima, sumber interupsi dapat mengirim opcode apa pun ke bus dan CPU melihatnya.  (Paling sering mereka menggunakan perintah RST.) </li><li>  CPU menjalankan perintah ini.  Jika RST, maka ini adalah analog dari perintah CALL untuk alamat tetap di bagian bawah memori.  Ini mendorong PC saat ini ke tumpukan. </li><li>  Kode di alamat memori yang lebih rendah memproses apa yang diinginkan interupsi untuk memberitahu program.  Setelah pemrosesan selesai, RST berakhir dengan panggilan ke RET. </li></ol><br>  Peralatan video dari gim ini menghasilkan dua interupsi yang harus kita tiru secara terprogram: ujung bingkai dan tengah bingkai.  Keduanya dilakukan pada 60 Hz (60 kali per detik).  1/60 detik adalah 16,6667 milidetik. <br><br>  Untuk mempermudah bekerja dengan interupsi, saya akan menambahkan fungsi ke emulator 8080: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> interrupt_num)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//perform "PUSH PC" Push(state, (state-&gt;pc &amp; 0xFF00) &gt;&gt; 8, (state-&gt;pc &amp; 0xff)); //Set the PC to the low memory vector. //This is identical to an "RST interrupt_num" instruction. state-&gt;pc = 8 * interrupt_num; }</span></span></code> </pre> <br>  Kode platform harus mengimplementasikan timer yang dapat kita panggil (untuk saat ini, saya hanya menyebutnya waktu ()).  Kode mesin akan menggunakannya untuk memberikan interupsi ke emulator 8080.  Dalam kode mesin, ketika penghitung waktu kedaluwarsa, saya akan memanggil GenerateInterrupt: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!done) { Emulate8080Op(state); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( time() - lastInterrupt &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//1/60 second has elapsed { //only do an interrupt if they are enabled if (state-&gt;int_enable) { GenerateInterrupt(state, 2); //interrupt 2 //Save the time we did this lastInterrupt = time(); } } }</span></span></code> </pre> <br>  Ada beberapa detail tentang bagaimana 8080 menangani interupsi, yang tidak akan kita tiru.  Saya percaya bahwa pemrosesan seperti itu akan cukup untuk tujuan kita. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419143/">https://habr.com/ru/post/id419143/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419131/index.html">Tanggal peluncuran awal modul lunar, SpaceIL diumumkan</a></li>
<li><a href="../id419133/index.html">Webinar Jumat: belajar program secara gratis</a></li>
<li><a href="../id419135/index.html">Friday JS: 0-line JS dan CSS game</a></li>
<li><a href="../id419137/index.html">Pencatatan aktivitas menggunakan Web Beacon API</a></li>
<li><a href="../id419141/index.html">Seks phishing mendapatkan momentum di AS</a></li>
<li><a href="../id419145/index.html">Fintech Digest: Kapitalisasi Apple melebihi $ 1 triliun, AI membantu eBay meningkatkan pendapatan hingga miliaran</a></li>
<li><a href="../id419147/index.html">Kubus 1000 dimensi: apakah mungkin untuk membuat model komputasi memori manusia saat ini?</a></li>
<li><a href="../id419149/index.html">Panduan untuk Mikrotik RoMON</a></li>
<li><a href="../id419151/index.html">Rumah pintar: dimensi baru kenyamanan dan pengejaran keunggulan. Bagian dua</a></li>
<li><a href="../id419153/index.html">Memorandum Hak Cyborg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>