<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ›ï¸ ğŸ‹ ğŸ¥ Penggunaan mixin di Dart ğŸ“– ğŸ˜ƒ ğŸ”¹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa kali pertanyaan diajukan dari rekan kerja bahwa tidak jelas mengapa mixin (pengotor) dalam bahasa Dart diperlukan sama sekali. Saya memutuska...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penggunaan mixin di Dart</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484206/"><p> Beberapa kali pertanyaan diajukan dari rekan kerja bahwa tidak jelas mengapa mixin (pengotor) dalam bahasa Dart diperlukan sama sekali.  Saya memutuskan untuk melihat apa yang ada di Internet tentang masalah ini.  Banyak hal yang menyebalkan dari artikel yang dapat ditemukan, mereka terutama berbicara tentang cara menggunakan kotoran, tetapi mereka tidak menjelaskan mengapa mereka diperlukan, dalam hal mana penggunaannya lebih disukai daripada warisan biasa atau implementasi antarmuka.  Artikel ini adalah upaya untuk mengisi celah ini. </p><a name="habracut"></a><br><p>  Terlepas dari kenyataan bahwa ada cukup banyak artikel di Internet tentang masalah ketidakmurnian di Dart dan Flutter, mereka tidak membawa kejelasan dalam pendapat saya karena contoh yang diberikan menunjukkan mekanisme murni membangun kelas dengan kotoran, yang jauh dari masuk akal dan karena itu tidak menunjukkan ruang lingkup aplikasi mereka yang sebenarnya. .  Secara khusus, saya bertemu <a href="https://habr.com/ru/post/467143/">dengan contoh</a> seperti <a href="https://habr.com/ru/post/467143/">itu</a> .  Kami memiliki: </p><br><pre><code class="plaintext hljs">class Animal {} class Dog {} class Cat {}</code> </pre> <br><p>  Dan untuk beberapa alasan kami ingin mendapatkan hewan yang memiliki sifat kucing dan anjing secara bersamaan.  Dalam hal ini, kita dapat melakukan ini: </p><br><pre> <code class="plaintext hljs">class CatDog extends Animal with Cat, Dog {}</code> </pre> <br><p>  Setidaknya ada dua pertanyaan untuk contoh ini: </p><br><ul><li>  mengapa kita membutuhkan persilangan antara kucing dan anjing? </li><li>  Mengapa kucing dan anjing tidak mewarisi dari <code>Animal</code> ?  Bukankah mereka binatang? </li></ul><br><p>  Pada saat yang sama, mengapa kotoran tetap dibutuhkan? Itu tetap menjadi misteri. </p><br><p>  Menurut pendapat saya yang sederhana, untuk memahami makna ketidakmurnian, seseorang harus mulai mempertimbangkan masalah ini dengan hubungan warisan.  Poin utama dari pewarisan dalam OOP adalah bahwa satu entitas <em>adalah variasi dari</em> entitas lain.  Misalnya, <code></code> adalah variasi dari <code></code> atau <code></code> adalah variasi dari <code></code> .  Dan inilah tepatnya yang seharusnya menjadi faktor penentu dalam membangun hirarki kelas. </p><br><p>  Jika kita melihat warisan dari sudut pandang yang berbeda, kita akan melihat bahwa <code></code> mewarisi sifat-sifat <code></code> , dan <code></code> mewarisi sifat-sifat <code></code> .  Jika Anda tidak memperhatikan logika, maka, murni secara teknis, Anda mungkin ingin mewarisi properti beberapa entitas yang berbeda.  Untuk melakukan ini, beberapa bahasa pemrograman mendukung <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25BD%25D0%25BE%25D0%25B6%25D0%25B5%25D1%2581%25D1%2582%25D0%25B2%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BD%25D0%25B0%25D1%2581%25D0%25BB%25D0%25B5%25D0%25B4%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">banyak pewarisan</a> . </p><br><p>  Multiple inheritance dikritik karena sejumlah kekurangan (lihat <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25BD%25D0%25BE%25D0%25B6%25D0%25B5%25D1%2581%25D1%2582%25D0%25B2%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BD%25D0%25B0%25D1%2581%25D0%25BB%25D0%25B5%25D0%25B4%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">Wikipedia</a> ), sehingga banyak bahasa pemrograman sama sekali tidak menggunakan multiple inheritance, tetapi menggunakan mekanisme untuk mengimplementasikan antarmuka dan / atau ketidakmurnian.  Dan, dari sudut pandang logika, konstruksi yang dihasilkan dari multiple inheritance tidak mudah untuk dipahami. </p><br><p>  Untuk memahami materi berikut ini, perlu untuk mengingat beberapa konsep dari logika elementer.  Secara khusus, konsep properti <em>esensial</em> dan <em>non-esensial</em> .  Sifat-sifat esensial dari objek adalah yang karena keberadaannya yang mengacu pada kelas objek tertentu.  Properti non-esensial dari suatu objek adalah mereka yang kehadiran, ketidakhadiran atau nilai-nilai spesifiknya tidak mempengaruhi objek milik kelas objek tertentu.  Misalnya, bentuk persegi panjang adalah properti penting dari gambar ini, karena jika kita mengubah bentuk ini (menghapus atau menambahkan sisi atau mengubah sudut), maka persegi panjang akan berhenti menjadi persegi panjang.  Tetapi jika Anda mengubah ukuran persegi panjang, maka itu akan tetap persegi panjang.  Oleh karena itu, dimensi adalah properti yang tidak signifikan. </p><br><p>  Membangun hierarki kelas biasanya didasarkan pada menambahkan properti <em>penting</em> apa pun ke kelas induk.  Sebagai contoh </p><br><pre> <code class="plaintext hljs">abstract class Shape { void draw(); } class Rectangle extends Shape { @override void draw() { print('Draw rectangle'); } } class Circle extends Shape { @override void draw() { print('Draw circle'); } }</code> </pre> <br><p>  Basis hierarki ini adalah sifat esensial dari bentuk gambar. </p><br><p>  Contoh lain: </p><br><pre> <code class="plaintext hljs">abstract class Widget { void render(); } class Container extends Widget { @override void render() { print('Renders container'); } } class Text extends Widget { @override void render('Render text'); }</code> </pre> <br><p>  Properti penting di sini adalah tujuan dari widget. </p><br><p>  Sekarang anggaplah kita perlu menambahkan beberapa properti yang tidak penting ke entitas kita.  Properti seperti itu, misalnya, adalah warna.  Mari kita sekarang ingin mewarnai beberapa bentuk dan widget. </p><br><p>  Untuk melakukan ini, Anda bisa, tentu saja, menggunakan warisan dan mengimplementasikan kelas <code>PaintableShape</code> dan <code>PaintableWidget</code> .  Tapi ini tidak nyaman, karena, pertama, kita harus menduplikasi implementasi fungsi pewarnaan di kedua hierarki, dan, kedua, untuk setiap gambar dan widget yang ingin kita warnai, kita harus mengimplementasikan kelas baru, misalnya, <code>PaintableRect</code> dan <code>PaintableContainer</code> . </p><br><p>  Anda dapat menggunakan mekanisme untuk mengimplementasikan antarmuka.  Lalu kita mendapatkan sesuatu seperti ini: </p><br><pre> <code class="plaintext hljs">enum Color {red, yellow, green} abstract class Paintable { void paint(Color color); Color get color; } class PaintableRect extends Rectangle implements Paintable { Color _color; @override void paint(Color color) {_color = color;} @override Color get color =&gt; _color; } class PaintableContainer extends Container implements Paintable { Color _color; @override void paint(Color color) {_color = color;} @override Color get color =&gt; _color; }</code> </pre> <br><p>  Seperti yang Anda lihat, ini juga bukan solusi terbaik, karena kami harus menduplikasi kode yang sama untuk setiap entitas yang dapat diselesaikan. </p><br><p>  Tetapi semua masalah ini dapat diselesaikan jika fungsional yang terkait dengan properti tidak signifikan dihapus sebagai campuran terpisah (mixin): </p><br><pre> <code class="plaintext hljs">enum Color {red, yellow, green} mixin PaintableMixin { Color _color; void paint(Color color) {_color = color;} Color get color =&gt; _color; } class PaintableRect extends Rectangle with PaintableMixin { @override void draw() { print('Draw rectangle with color $color'); } } class PaintableContainer extends Container with PaintableMixin { @override void render() { print('Render container with color $color'); } }</code> </pre> <br><p>  Sekarang Anda dapat menggunakannya: </p><br><pre> <code class="plaintext hljs">main() { PaintableRect() ..paint(Color.red) ..draw(); PaintableContainer() ..paint(Color.yellow) ..render(); }</code> </pre> <br><p>  Untuk meringkas hal di atas, seseorang dapat menentukan dengan cara berikut kapan akan lebih mudah menggunakan pengotor: jika ada beberapa hierarki berbeda yang perlu menambahkan fungsional yang sama yang mendefinisikan beberapa properti yang tidak esensial untuk entitas hierarki ini.  Atau bisa jadi satu hierarki, tetapi kita berurusan dengan cabang-cabangnya yang berbeda.  Sebagai contoh, pertimbangkan widget kerangka Flutter. </p><br><p>  Misalkan kita perlu menambahkan fungsionalitas yang terkait dengan properti yang sama ke beberapa widget.  Widget dalam Flutter dibuat sebagai berikut: </p><br><pre> <code class="plaintext hljs">class MyStatelessWidget extends StatelessWidget {}</code> </pre> <br><p>  atau </p><br><pre> <code class="plaintext hljs">class MyStatefulWidget extends StatefulWidget {}</code> </pre> <br><p>  Untuk menambahkan properti melalui warisan, Anda harus menerapkan setidaknya dua kelas: </p><br><pre> <code class="plaintext hljs">class StatelessWidgetWithProperty extends StatelessWidget {} class StatefulWidgetWithPropery extends StatefulWidget {}</code> </pre> <br><p>  pada saat yang sama, seperti yang Anda lihat lagi, Anda harus menduplikasi fungsi yang terkait dengan properti yang ditambahkan. </p><br><p>  Saat menggunakan kotoran, masalah terpecahkan: </p><br><pre> <code class="plaintext hljs">mixin Property {} class MyStatelessWidget extends StatelessWidget with Propery {} class MyStatefulWidget extends StatefulWidget with Property {}</code> </pre> <br><p>  Bagi mereka yang terbiasa dengan pola desain, penggunaan kotoran dalam beberapa kasus dapat menggantikan penggunaan pola <a href="https://refactoring.guru/ru/design-patterns/bridge">Bridge</a> . </p><br><p>  Sebagai kesimpulan, perlu dicatat bahwa dengan cara ini seseorang dapat mencampur fungsional beberapa properti yang berbeda sekaligus dalam kombinasi yang sewenang-wenang. </p><br><p>  Artikel ini tidak dimaksudkan untuk secara mendalam mendefinisikan penggunaan kotoran.  Mungkin pikiran yang ingin tahu dari pengembang akan dapat menemukan lebih banyak kegunaan yang indah untuk mereka.  Saya akan senang jika opsi ini untuk menggunakan kotoran muncul di komentar pada artikel ini. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id484206/">https://habr.com/ru/post/id484206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id484196/index.html">Merekam suara JS dari mikrofon atau komentar suara</a></li>
<li><a href="../id484198/index.html">Sisi sebaliknya dari koin: siapa yang menang dan kalah pada pertumbuhan saham Tesla</a></li>
<li><a href="../id484200/index.html">Cara menetapkan tujuan untuk mencapainya</a></li>
<li><a href="../id484202/index.html">Pembelajaran Mesin dalam Analisis Statis Kode Sumber Program</a></li>
<li><a href="../id484204/index.html">FTCODE ransomware tanpa fileless sekarang mencuri akun</a></li>
<li><a href="../id484208/index.html">Menggunakan pembelajaran mesin dalam analisis statis kode sumber program</a></li>
<li><a href="../id484212/index.html">Barang gratis untuk karma - kisah startup Belarusia yang mengubah prinsip konsumsi</a></li>
<li><a href="../id484214/index.html">Tensor dalam TensorFlow</a></li>
<li><a href="../id484216/index.html">Konferensi Zabbix kedua di Rusia: pendaftaran dan tanggal-tanggal penting</a></li>
<li><a href="../id484218/index.html">Kami mengoptimalkan otomatisasi: cara kami mempercepat autotest sebanyak 3-4 kali, menjaga perkembangan lama</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>