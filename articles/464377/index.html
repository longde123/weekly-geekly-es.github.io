<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚èØÔ∏è #‚É£ üîª Ensamblador sucio piratea 6502 üë≥ üìî üî†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art√≠culo enumera algunos de los trucos que utilizaron los participantes en mi peque√±o concurso de programaci√≥n Commodore 64 . Las reglas del conc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ensamblador sucio piratea 6502</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464377/">  Este art√≠culo enumera algunos de los trucos que utilizaron los participantes en mi peque√±o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">concurso de programaci√≥n Commodore 64</a> .  Las reglas del concurso eran simples: crear un archivo ejecutable C64 (PRG), que dibuja dos l√≠neas para formar la imagen a continuaci√≥n.  El que tiene un archivo de menor tama√±o gan√≥. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f4/5d1/afc/3f45d1afc9817c6530b6b34c44dd0497.png"></div><br>  Las entradas de la competencia se publicaron en tweets abiertos y en mensajes privados que conten√≠an solo bytes del archivo PRG y un hash MD5. <br><a name="habracut"></a><br>  Lista de participantes con enlaces al c√≥digo fuente: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Philip Heron</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥digo</a> - 34 bytes, ganador) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Geir Straume</a> ( <a href="">c√≥digo</a> - 34 bytes) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Petri Hakkinen</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥digo</a> - 37 bytes) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Matlev Raksenblatts</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥digo</a> - 38 bytes) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Jan Ahrenius</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥digo</a> - 48 bytes) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Jamie Fuller</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥digo</a> - 50 bytes) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">David A. Gershman</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥digo</a> - 53 bytes) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Janne Hellsten</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥digo</a> - 56 bytes) </li></ul><br>  (Si extra√±√© a alguien, av√≠seme, actualizar√© la lista). <br><br>  El resto del art√≠culo est√° dedicado a algunos trucos de ensamblador que se usaron en la competencia. <br><br><h1>  Los fundamentos </h1><br>  Graphics C64 funciona de manera predeterminada en el modo de codificaci√≥n de 40x25 caracteres.  El framebuffer en RAM se divide en dos matrices: <br><br><ul><li> <code>$0400</code> (RAM de pantalla, 40x25 bytes) <br></li><li>  <code>$d800</code> (RAM en color, 40x25 bytes) </li></ul><br>  Para establecer un car√°cter, guarde el byte en la RAM en pantalla, a <code>$0400</code> (por ejemplo, <code>$0400+y*40+x</code> ).  El color RAM se inicializa en azul claro de forma predeterminada (color 14): este es el color que usamos para las l√≠neas, es decir, el color RAM se puede dejar sin tocar. <br><br>  Puede controlar los colores del borde y el fondo utilizando los registros de E / S de memoria en <code>$d020</code> (borde) y <code>$d021</code> (fondo). <br><br>  Dibujar dos l√≠neas es bastante f√°cil si programa directamente la pendiente de una l√≠nea fija.  Aqu√≠ hay una implementaci√≥n en C que dibuja l√≠neas y vac√≠a el contenido de la pantalla a stdout ( <code>malloc()</code> se usa para hacer que el c√≥digo funcione en una PC): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void dump(const uint8_t* screen) { const uint8_t* s = screen; for (int y = 0; y &lt; 25; y++) { for (int x = 0; x &lt; 40; x++, s++) { printf("%c", *s == 0xa0 ? '#' : '.'); } printf("\n"); } } void setreg(uintptr_t dst, uint8_t v) { // *((uint8_t *)dst) = v; } int main() { // uint8_t* screenRAM = (uint_8*)0x0400; uint8_t* screenRAM = (uint8_t *)calloc(40*25, 0x20); setreg(0xd020, 0); // Set border color setreg(0xd021, 0); // Set background color int yslope = (25&lt;&lt;8)/40; int yf = yslope/2; for (int x = 0; x &lt; 40; x++) { int yi = yf &gt;&gt; 8; // First line screenRAM[x + yi*40] = 0xa0; // Second line (X-mirrored) screenRAM[(39-x) + yi*40] = 0xa0; yf += yslope; } dump(screenRAM); }</span></span></span></span></code> </pre> <br>  Los c√≥digos de pantalla anteriores son <code>$20</code> (en blanco) y <code>$a0</code> (bloque 8 √ó 8 lleno).  Si corres, ver√°s una imagen ASCII con dos l√≠neas: <br><br><pre>  ## .................................... ##
 .. # .................................. # ..
 ... ## .............................. ## ...
 ..... # ............................ # .....
 ...... ## ........................ ## ......
 ........ ## .................... ## ........
 .......... # .................. # ..........
 ........... ## .............. ## ...........
 ............. # ............ # .............
 .............. ## ........ ## ..............
 ................ ## .... ## ................
 .................. # .. # ..................
 ................... ## ...................
 .................. # .. # ..................
 ................ ## .... ## ................
 .............. ## ........ ## ..............
 ............. # ............ # .............
 ........... ## .............. ## ...........
 .......... # .................. # ..........
 ........ ## .................... ## ........
 ...... ## ........................ ## ......
 ..... # ............................ # .....
 ... ## .............................. ## ...
 .. # .................................. # ..
 ## .................................... ## </pre><br>  Lo mismo se implementa trivialmente en ensamblador: <br><br><pre> <code class="plaintext hljs">!include "c64.asm" +c64::basic_start(entry) entry: { lda #0 ; black color sta $d020 ; set border to 0 sta $d021 ; set background to 0 ; clear the screen ldx #0 lda #$20 clrscr: !for i in [0, $100, $200, $300] { sta $0400 + i, x } inx bne clrscr ; line drawing, completely unrolled ; with assembly pseudos lda #$a0 !for i in range(40) { !let y0 = Math.floor(25/40*(i+0.5)) sta $0400 + y0*40 + i sta $0400 + (24-y0)*40 + i } inf: jmp inf ; halt }</code> </pre> <br>  Resulta PRG un tama√±o bastante grande de 286 bytes. <br><br>  Antes de sumergirnos en la optimizaci√≥n, hacemos algunas observaciones. <br><br>  En primer lugar, trabajamos en C64 con las rutinas ROM instaladas.  Hay toneladas de rutinas que pueden ser √∫tiles.  Por ejemplo, limpiar la pantalla con <code>JSR $E544</code> . <br><br>  En segundo lugar, los c√°lculos de direcci√≥n en un procesador de 8 bits como 6502 pueden ser engorrosos y consumir muchos bytes.  Este procesador tampoco tiene un multiplicador, por lo que un c√°lculo como <code>y*40+i</code> generalmente incluye un mont√≥n de cambios l√≥gicos o una tabla de b√∫squeda que tambi√©n consume bytes.  Para evitar multiplicar por 40, es mejor avanzar el cursor de la pantalla de forma incremental: <br><br><pre> <code class="plaintext hljs"> int yslope = (25&lt;&lt;8)/40; int yf = yslope/2; uint8_t* dst = screenRAM; for (int x = 0; x &lt; 40; x++) { dst[x] = 0xa0; dst[(39-x)] = 0xa0; yf += yslope; if (yf &amp; 256) { // Carry set? dst += 40; yf &amp;= 255; } }</code> </pre> <br>  Continuamos agregando la pendiente de la l√≠nea al contador fijo <code>yf</code> , y cuando la adici√≥n de 8 bits establece la bandera de acarreo, suma 40. <br><br>  Aqu√≠ hay un enfoque de ensamblador incremental: <br><br><pre> <code class="plaintext hljs">!include "c64.asm" +c64::basic_start(entry) !let screenptr = $20 !let x0 = $40 !let x1 = $41 !let yf = $60 entry: { lda #0 sta x0 sta $d020 sta $d021 ; kernal clear screen jsr $e544 ; set screenptr = $0400 lda #&lt;$0400 sta screenptr+0 lda #&gt;$0400 sta screenptr+1 lda #80 sta yf lda #39 sta x1 xloop: lda #$a0 ldy x0 ; screenRAM[x] = 0xA0 sta (screenptr), y ldy x1 ; screenRAM[39-x] = 0xA0 sta (screenptr), y clc lda #160 ; line slope adc yf sta yf bcc no_add ; advance screen ptr by 40 clc lda screenptr adc #40 sta screenptr lda screenptr+1 adc #0 sta screenptr+1 no_add: inc x0 dec x1 bpl xloop inf: jmp inf }</code> </pre> <br>  Con 82 bytes, sigue siendo bastante fuerte.  Un problema obvio son los c√°lculos de direcciones de 16 bits.  Establezca el valor de <code>screenptr</code> para la <code>screenptr</code> indirecta: <br><br><pre> <code class="plaintext hljs"> ; set screenptr = $0400 lda #&lt;$0400 sta screenptr+0 lda #&gt;$0400 sta screenptr+1</code> </pre> <br>  <code>screenptr</code> a la siguiente l√≠nea agregando 40: <br><br><pre> <code class="plaintext hljs"> ; advance screen ptr by 40 clc lda screenptr adc #40 sta screenptr lda screenptr+1 adc #0 sta screenptr+1</code> </pre> <br>  Por supuesto, este c√≥digo se puede optimizar, pero ¬øqu√© pasa si se deshace de las direcciones de 16 bits?  Veamos como hacerlo. <br><br><h1>  Truco 1. ¬°Desplazamiento! </h1><br>  En lugar de construir una l√≠nea en la RAM en pantalla, dibujamos solo en la √∫ltima l√≠nea de pantalla Y = 24 y desplazamos hacia arriba toda la pantalla, ¬°llamando a la funci√≥n de desplazamiento ROM con <code>JSR $E8EA</code> ! <br><br>  As√≠ es como se optimiza xloop: <br><br><pre> <code class="plaintext hljs"> lda #0 sta x0 lda #39 sta x1 xloop: lda #$a0 ldx x0 ; hardcoded absolute address to last screen line sta $0400 + 24*40, x ldx x1 sta $0400 + 24*40, x adc yf sta yf bcc no_scroll ; scroll screen up! jsr $e8ea no_scroll: inc x0 dec x1 bpl xloop</code> </pre> <br>  As√≠ es como se ve el renderizado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63f/081/6a6/63f0816a6728ec839de0197b6e0a3179.gif"></div><br><br>  Este es uno de mis trucos favoritos en este programa.  Casi todos los concursantes lo encontraron por su cuenta. <br><br><h1>  Truco 2. C√≥digo auto modificable </h1><br>  El c√≥digo para almacenar valores de p√≠xeles termina as√≠: <br><br><pre> <code class="plaintext hljs"> ldx x1 ; hardcoded absolute address to last screen line sta $0400 + 24*40, x ldx x0 sta $0400 + 24*40, x inc x0 dec x1</code> </pre> <br>  Esto est√° codificado en la siguiente secuencia de 14 bytes: <br><br><pre> <code class="plaintext hljs">0803: A6 22 LDX $22 0805: 9D C0 07 STA $07C0,X 0808: A6 20 LDX $20 080A: 9D C0 07 STA $07C0,X 080D: E6 22 INC $22 080F: C6 20 DEC $20</code> </pre> <br>  Con el c√≥digo de modificaci√≥n autom√°tica (SMC), puede escribir esto de manera m√°s compacta: <br><br><pre> <code class="plaintext hljs"> ldx x1 sta $0400 + 24*40, x addr0: sta $0400 + 24*40 ; advance the second x-coord with SMC inc addr0+1 dec x1</code> </pre> <br>  ... que est√° codificado en 13 bytes: <br><br><pre> <code class="plaintext hljs">0803: A6 22 LDX $22 0805: 9D C0 07 STA $07C0,X 0808: 8D C0 07 STA $07C0 080B: EE 09 08 INC $0809 080E: C6 22 DEC $22</code> </pre> <br><h1>  Truco 3. Estado de operaci√≥n 'encendido' </h1><br>  Se consideraba normal en la competencia hacer suposiciones descabelladas sobre el entorno laboral.  Por ejemplo, que el dibujo lineal es lo primero que comienza despu√©s de encender el C64, y no hay requisitos para una salida limpia de vuelta a la l√≠nea de comando BASIC.  Por lo tanto, todo lo que encuentre en el entorno inicial al ingresar al PRG puede y debe usarse a su favor: <br><br><ul><li>  Los registros A, X, Y se toman como ceros <br></li><li>  Todos los indicadores de CPU borrados <br></li><li>  Contenido de p√°gina <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cero</a> (direcciones <code>$00</code> - <code>$ff</code> ) </li></ul><br>  Del mismo modo, al llamar a algunos procedimientos de ROM KERNAL, puede aprovechar al m√°ximo cualquier efecto secundario: indicadores de CPU devueltos, valores temporales de cero p√°ginas, etc. <br><br>  Despu√©s de las primeras optimizaciones, busquemos algo interesante en la memoria de la m√°quina: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0df/43f/93c/0df43f93c58a142911607d3ba5ba44dd.png"></div><br><br>  Zeropage contiene algunos valores √∫tiles para nuestros prop√≥sitos: <br><br><ul><li>  <code>$d5</code> : 39 / $ 27 == longitud de l√≠nea - 1 <br></li><li>  <code>$22</code> : 64 / $ 40 == valor inicial para el contador de pendiente de l√≠nea </li></ul><br>  Esto ahorrar√° algunos bytes durante la inicializaci√≥n.  Por ejemplo: <br><br><pre> <code class="plaintext hljs">!let x0 = $20 lda #39 ; 0801: A9 27 LDA #$27 sta x0 ; 0803: 85 20 STA $20 xloop: dec x0 ; 0805: C6 20 DEC $20 bpl xloop ; 0807: 10 FC BPL $0805</code> </pre> <br>  Como <code>$d5</code> contiene el valor 39, puede indicarlo al contador <code>x0</code> , deshaci√©ndose del par LDA / STA: <br><br><pre> <code class="plaintext hljs">!let x0 = $d5 ; nothing here! xloop: dec x0 ; 0801: C6 D5 DEC $D5 bpl xloop ; 0803: 10 FC BPL $0801</code> </pre> <br>  Philip, el ganador del concurso, lo lleva a extremos en <a href="">su c√≥digo</a> .  Recuerde la direcci√≥n del √∫ltimo car√°cter de la cadena <code>$07C0</code> (== <code>$0400+24*40</code> ).  Este valor no est√° presente en zeropage durante la inicializaci√≥n.  Sin embargo, como efecto secundario de c√≥mo la rutina de desplazamiento desde la ROM utiliza valores temporales de cero p√°ginas, las direcciones <code>$D1-$D2</code> en la salida de la funci√≥n contendr√°n el valor <code>$07C0</code> .  Por lo tanto, para almacenar un p√≠xel, en lugar de <code>STA $07C0,x</code> puede usar el direccionamiento de √≠ndice indirecto m√°s corto <code>STA ($D1),y</code> para un byte. <br><br><h1>  Truco 4. Descargar Optimization </h1><br>  Un binario PRG C64 t√≠pico contiene lo siguiente: <br><br><ul><li>  Primeros 2 bytes: direcci√≥n de descarga (generalmente <code>$0801</code> ) <br></li><li>  12 bytes de la secuencia de arranque BASIC </li></ul><br>  La secuencia de arranque principal se ve as√≠ (direcciones <code>$801-$80C</code> ): <br><br><pre> <code class="plaintext hljs">0801: 0B 08 0A 00 9E 32 30 36 31 00 00 00 080D: 8D 20 D0 STA $D020</code> </pre> <br>  Sin entrar en detalles sobre el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dise√±o de memoria tokenizada BASIC</a> , esta secuencia corresponde m√°s o menos a '10 SYS 2061 '.  La direcci√≥n <code>2061</code> ( <code>$080D</code> ) es donde se ejecuta nuestro programa de c√≥digo de m√°quina real cuando el int√©rprete BASIC ejecuta el comando SYS. <br><br>  Simplemente parece que 14 bytes es demasiado.  Philip, Matlev y Geir usaron varios trucos dif√≠ciles para deshacerse por completo de la secuencia principal.  Esto requiere cargar el PRG con <code>LOAD"*",8,1</code> , ya que <code>LOAD"*",8</code> ignora la direcci√≥n de carga PRG (primeros dos bytes) y siempre se carga a <code>$0801</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/911/d07/fdb/911d07fdb2c0e2e13b07e360bb16d03c.png"></div><br><br>  Aqu√≠ se usaron dos m√©todos: <br><br><ul><li>  Truco de pila <br></li><li>  Truco de reinicio c√°lido B√ÅSICO </li></ul><br><h3>  Truco de pila </h3><br>  El truco consiste en ingresar a la pila del procesador a <code>$01F8</code> valor que indica nuestro punto de entrada deseado.  Esto se hace creando un PRG que comienza con un puntero de 16 bits a nuestro c√≥digo y cargando el PRG a <code>$01F8</code> : <br><br><pre> <code class="plaintext hljs"> * = $01F8 !word scroll - 1 ; overwrite stack scroll: jsr $E8EA</code> </pre> <br>  Tan pronto como el cargador BASIC (vea el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥digo despu√©s del desensamblaje</a> ) haya terminado de cargarse y quiera regresar a la persona que llama usando <code>RTS</code> , regresa directamente a nuestro PRG. <br><br><h3>  Truco de reinicio c√°lido B√ÅSICO </h3><br>  Esto es un poco m√°s f√°cil de explicar simplemente mirando el PRG despu√©s del desmontaje. <br><br><pre> <code class="plaintext hljs">02E6: 20 EA E8 JSR $E8EA 02E9: A4 D5 LDY $D5 02EB: A9 A0 LDA #$A0 02ED: 99 20 D0 STA $D020,Y 02F0: 91 D1 STA ($D1),Y 02F2: 9D B5 07 STA $07B5,X 02F5: E6 D6 INC $D6 02F7: 65 90 ADC $90 02F9: 85 90 STA $90 02FB: C6 D5 DEC $D5 02FD: 30 FE BMI $02FD 02FF: 90 E7 BCC $02E8 0301: 4C E6 02 JMP $02E6</code> </pre> <br>  Presta atenci√≥n a la √∫ltima l√≠nea ( <code>JMP $02E6</code> ).  La instrucci√≥n JMP comienza en <code>$0301</code> con una direcci√≥n de salto de <code>$0302-$0303</code> . <br><br>  Cuando este c√≥digo se carga en la memoria comenzando en la direcci√≥n <code>$02E6</code> , el valor <code>$02E6</code> escribe en las direcciones <code>$0302-$0303</code> .  Bueno, esta ubicaci√≥n tiene un significado especial: contiene un puntero al "ciclo de espera B√ÅSICO" (vea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la tarjeta de memoria C64</a> para m√°s detalles).  La descarga de PRG lo sobrescribe con <code>$02E6</code> y, por lo tanto, cuando el int√©rprete BASIC despu√©s de un reinicio en caliente intenta ir al ciclo de espera, nunca ingresa a este ciclo, ¬°sino que ingresa al programa de renderizado! <br><br><h3>  Otros trucos con el lanzamiento de BASIC </h3><br>  Petri descubri√≥ <a href="">otro truco de lanzamiento BASIC</a> que le permite ingresar sus propias constantes en zeropage.  En este m√©todo, crea manualmente su propia secuencia de inicio BASIC tokenizada y codifica las constantes en los n√∫meros de l√≠nea del programa BASIC.  En la entrada, los n√∫meros de l√≠nea B√ÅSICOS, es decir, sus constantes se almacenar√°n en las direcciones <code>$39-$3A</code> .  Muy inteligente! <br><br><h1>  Truco 5. Flujo de control personalizado </h1><br>  Aqu√≠ hay una versi√≥n ligeramente simplificada de x-loop que solo imprime una l√≠nea y luego detiene la ejecuci√≥n: <br><br><pre> <code class="plaintext hljs"> lda #39 sta x1 xloop: lda #$a0 ldx x1 sta $0400 + 24*40, x adc yf sta yf bcc no_scroll ; scroll screen up! jsr $e8ea no_scroll: dec x1 bpl xloop ; intentionally halt at the end inf: jmp inf</code> </pre> <br>  Pero hay un error.  Cuando dibujamos el √∫ltimo p√≠xel, ya NO PODEMOS desplazar la pantalla.  Por lo tanto, se necesitan ramas adicionales para detener el desplazamiento despu√©s de grabar el √∫ltimo p√≠xel: <br><br><pre> <code class="plaintext hljs"> lda #39 sta x1 xloop: lda #$a0 ldx x1 sta $0400 + 24*40, x dec x1 ; skip scrolling if last pixel bmi done adc yf sta yf bcc no_scroll ; scroll screen up! jsr $e8ea no_scroll: jmp xloop done: ; intentionally halt at the end inf: jmp inf</code> </pre> <br>  El flujo de control es muy similar al que producir√° el compilador de C a partir de un programa estructurado.  El c√≥digo para omitir el √∫ltimo desplazamiento introduce una nueva instrucci√≥n <code>JMP abs</code> que toma 3 bytes.  Los saltos condicionales tienen solo dos bytes de longitud, ya que codifican direcciones de salto utilizando un operando relativo de 8 bits con direccionamiento directo. <br><br>  Se puede evitar JMP para "omitir el √∫ltimo desplazamiento" moviendo la llamada de desplazamiento hacia la parte superior del bucle y cambiando ligeramente la estructura del flujo de control.  As√≠ es como Philip lo implement√≥: <br><br><pre> <code class="plaintext hljs"> lda #39 sta x1 scroll: jsr $e8ea xloop: lda #$a0 ldx x1 sta $0400 + 24*40, x adc yf sta yf dec x1 ; doesn't set carry! inf: bmi inf ; hang here if last pixel! bcc xloop ; next pixel if no scroll bcs scroll ; scroll up and continue</code> </pre> <br>  Esto elimina por completo un JMP de tres bytes y convierte el otro JMP en una rama condicional de dos bytes, ahorrando un total de 4 bytes. <br><br><h1>  Truco 6. L√≠neas con compresi√≥n de bits </h1><br>  Algunos elementos no usan el contador de pendiente de l√≠nea, sino que comprimen los bits en una constante de 8 bits.  Tal empaque se basa en el hecho de que la posici√≥n del p√≠xel a lo largo de la l√≠nea corresponde a un patr√≥n repetitivo de 8 p√≠xeles: <br><br><pre> <code class="plaintext hljs">int mask = 0xB6; // 10110110 uint8_t* dst = screenRAM; for (int x = 0; x &lt; 40; x++) { dst[x] = 0xA0; if (mask &amp; (1 &lt;&lt; (x&amp;7))) { dst += 40; // go down a row } }</code> </pre> <br>  Esto se traduce en un ensamblador bastante compacto.  Sin embargo, las opciones de contador de inclinaci√≥n suelen ser incluso m√°s peque√±as. <br><br><h3>  Ganador </h3><br>  Aqu√≠ <a href="">est√° el programa ganador del concurso de 34 bytes</a> de Philip.  La mayor√≠a de los trucos anteriores funcionan bien en su c√≥digo: <br><br><pre> <code class="plaintext hljs">ov = $22 ; == $40, initial value for the overflow counter ct = $D5 ; == $27 / 39, number of passes. Decrementing, finished at -1 lp = $D1 ; == $07C0, pointer to bottom line. Set by the kernal scroller ; Overwrite the return address of the kernal loader on the stack ; with a pointer to our own code * = $01F8 .word scroll - 1 scroll: jsr $E8EA ; Kernal scroll up, also sets lp pointer to $07C0 loop: ldy ct ; Load the decrementing counter into Y (39 &gt; -1) lda #$A0 ; Load the PETSCII block / black col / ov step value sta $D020, y ; On the last two passes, sets the background black p1: sta $07C0 ; Draw first block (left &gt; right line) sta (lp), y ; Draw second block (right &gt; left line) inc p1 + 1 ; Increment pointer for the left &gt; right line adc ov ; Add step value $A0 to ov sta ov dec ct ; Decrement the Y counter bmi * ; If it goes negative, we're finished bcc loop ; Repeat. If ov didn't overflow, don't scroll bcs scroll ; Repeat. If ov overflowed, scroll</code> </pre> <br><h3>  Pero, ¬øpor qu√© detenerse en 34 bytes? </h3><br>  Tan pronto como termin√≥ el concurso, todos compartieron su c√≥digo y sus notas, y se llev√≥ a cabo una serie de discusiones animadas sobre c√≥mo mejorarlo a√∫n m√°s.  Despu√©s de la fecha l√≠mite, se presentaron varias opciones m√°s: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Philip - 33 bytes</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Philip - 32 bytes</a> <br></li><li>  <a href="">Petri - 31 bytes</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Philip - 29 bytes</a> </li></ul><br>  Aseg√∫rese de mirar, hay varias perlas reales. <br><br><hr><br>  Gracias por leer  Y un agradecimiento especial a Matlev, Phil, Geir, Petri, Jamie, Ian y David por su participaci√≥n (espero no haber extra√±ado a nadie, ¬°fue realmente dif√≠cil rastrear todas las menciones en Twitter!) <br><br>  PD Petri llam√≥ a mi concurso "anual", as√≠ que, probablemente nos veremos el a√±o que viene. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/464377/">https://habr.com/ru/post/464377/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../464367/index.html">Y otro Steam Windows Client Local Privilege Escalation 0day</a></li>
<li><a href="../464369/index.html">¬øQu√© bloqueador usas? Resultados</a></li>
<li><a href="../464371/index.html">/etc/resolv.conf para pods Kubernetes, opci√≥n ndots: 5, ya que esto puede afectar negativamente el rendimiento de la aplicaci√≥n</a></li>
<li><a href="../464373/index.html">Edge-to-edge en Android: hacerlo bien</a></li>
<li><a href="../464375/index.html">C√≥mo funcionan los motores de b√∫squeda</a></li>
<li><a href="../464381/index.html">Viaje a Alaska, o KDD'19 a trav√©s de los ojos de un testigo ocular</a></li>
<li><a href="../464383/index.html">C√≥mo pongo las cosas en orden en un proyecto donde hay un bosque de manos directas (configuraci√≥n tslint, m√°s bonita, etc.)</a></li>
<li><a href="../464385/index.html">Python como el √∫ltimo caso de C ++. Parte 1/2</a></li>
<li><a href="../464387/index.html">Huella rusa en la saga escandinava de videojuegos, terminando</a></li>
<li><a href="../464391/index.html">10 informes interesantes de conferencias de hackers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>