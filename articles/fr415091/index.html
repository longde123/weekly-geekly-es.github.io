<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏤 👼🏾 🤮 Rust 1.27 Release 💂🏼 🎥 🤡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'équipe de développement de Rust est heureuse d'annoncer la sortie d'une nouvelle version de Rust: 1.27.0. Rust est un langage de programmation systè...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rust 1.27 Release</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415091/"><p>  L'équipe de développement de Rust est heureuse d'annoncer la sortie d'une nouvelle version de Rust: 1.27.0.  Rust est un langage de programmation système destiné à la sécurité, la vitesse et l'exécution de code parallèle. </p><br><p>  Si vous avez une version précédente de Rust installée à l'aide de rustup, alors pour mettre à niveau Rust vers la version 1.27.0, il vous suffit de faire: </p><br><pre><code class="bash hljs">$ rustup update stable</code> </pre> <br><p>  Si vous n'avez pas encore installé rustup, vous pouvez l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">installer à</a> partir de la page correspondante de notre site Web.  <a href="">Des notes de version détaillées pour Rust 1.27.0</a> sont disponibles sur GitHub. </p><br><p>  Nous souhaitons également attirer votre attention sur ce point: avant la sortie de la version 1.27.0, nous avons découvert une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">erreur</a> dans les mappages de correspondance introduits dans la version 1.26.0, ce qui pouvait entraîner un comportement non correct.  Comme il a été découvert très tard, déjà en train de publier cette version, bien qu'il soit présent depuis la version 1.26.0, nous avons décidé de ne pas interrompre la routine et de préparer une version fixe 1.27.1, qui sera publiée dans un proche avenir.  Et en plus, si nécessaire, la version 1.26.3.  Les détails peuvent être trouvés dans les notes de version correspondantes. </p><br><h2 id="chto-voshlo-v-stabilnuyu-versiyu-1270">  Ce qui est inclus dans la version stable 1.27.0 </h2><br><p>  Dans ce numéro, deux améliorations importantes et tant attendues du langage sortent. <a name="habracut"></a>  Mais d'abord, un petit commentaire sur la documentation: la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">recherche est</a> désormais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">disponible</a> dans tous les livres de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la bibliothèque Rust</a> !  Par exemple, vous pouvez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trouver «emprunter» dans le livre «Rust Programming Language»</a> .  Nous espérons que cela vous permettra de trouver plus facilement les informations dont vous avez besoin.  De plus, un nouveau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">livre sur la rouille est paru</a> .  Ce livre explique comment utiliser directement <code>rustc</code> et comment obtenir d'autres informations utiles, telles qu'une liste de toutes les vérifications statiques. </p><br><h3 id="simd">  SIMD </h3><br><p>  Donc, maintenant sur l'important: désormais, les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fonctionnalités de base de l'utilisation de SIMD</a> sont disponibles dans Rust!  SIMD signifie "instruction unique, flux de données multiples" (instruction unique, données multiples).  Considérez la fonction: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(a: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>], b: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>], c: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ((a, b), c) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a.iter().zip(b).zip(c) { *c = *a + *b; } }</code> </pre> <br><p>  Ici, nous prenons deux tranches entières, additionnons leurs éléments et mettons le résultat dans la troisième tranche.  Le code ci-dessus illustre la façon la plus simple de le faire: vous devez parcourir l'ensemble des éléments, les assembler et enregistrer le résultat.  Cependant, les compilateurs trouvent souvent une meilleure solution.  LLVM «vectorise automatiquement» souvent un code similaire, où une telle formulation complexe signifie simplement «utilise SIMD».  Imaginez que les tranches <code>a</code> et <code>b</code> comportent 16 éléments, les deux.  Chaque élément est <code>u8</code> , ce qui signifie que les tranches contiendront chacune 128 bits de données.  À l'aide de SIMD, nous pouvons placer les <em>deux</em> tranches <code>a</code> et <code>b</code> dans des registres de 128 bits, les ajouter avec <em>une</em> instruction, puis copier les 128 bits résultants vers <code>c</code> .  Cela fonctionnera beaucoup plus vite! </p><br><p>  Malgré le fait que la version stable de Rust ait toujours pu tirer parti de la vectorisation automatique, le compilateur n'est parfois tout simplement pas assez intelligent pour comprendre qu'il peut être appliqué dans ce cas.  De plus, tous les processeurs ne prennent pas en charge ces fonctionnalités.  Par conséquent, LLVM ne peut pas toujours les utiliser, car votre programme peut s'exécuter sur diverses plates-formes matérielles.  Par conséquent, dans Rust 1.27, avec l'ajout du module <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>std::arch</code></a> , il est devenu possible d'utiliser <em>directement</em> ce type d'instructions, c'est-à-dire que maintenant nous ne sommes plus obligés de compter uniquement sur une compilation intelligente.  De plus, nous avons la possibilité de choisir une implémentation spécifique, en fonction de différents critères.  Par exemple: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[cfg(all(any(target_arch = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86"</span></span></span><span class="hljs-meta">, target_arch = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86_64"</span></span></span><span class="hljs-meta">), target_feature = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"avx2"</span></span></span><span class="hljs-meta">))]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-meta"><span class="hljs-meta">#[cfg(target_arch = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::arch::x86::_mm256_add_epi64; <span class="hljs-meta"><span class="hljs-meta">#[cfg(target_arch = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86_64"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::arch::x86_64::_mm256_add_epi64; <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { _mm256_add_epi64(...); } }</code> </pre> <br><p>  Ici, nous utilisons les drapeaux <code>cfg</code> pour sélectionner la version correcte du code en fonction de la plate-forme cible: sur <code>x86</code> sa propre version sera utilisée, et sur <code>x86_64</code> la sienne.  Nous pouvons également choisir au moment de l'exécution: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-meta"><span class="hljs-meta">#[cfg(any(target_arch = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86"</span></span></span><span class="hljs-meta">, target_arch = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86_64"</span></span></span><span class="hljs-meta">))]</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_x86_feature_detected!(<span class="hljs-string"><span class="hljs-string">"avx2"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { foo_avx2() }; } } foo_fallback(); }</code> </pre> <br><p>  Ici, nous avons deux versions de la fonction: l'une utilise <code>AVX2</code> - un type spécifique de SIMD qui vous permet d'effectuer des opérations 256 bits.  La macro <code>is_x86_feature_detected!</code>  va générer un code qui vérifie si le processeur prend en charge AVX2, et si c'est le cas, la fonction <code>foo_avx2</code> sera appelée.  Sinon, nous recourrons à une implémentation sans AVX, <code>foo_fallback</code> .  Notre code fonctionnera donc très rapidement sur les processeurs qui prennent en charge AVX2, mais il fonctionnera également sur d'autres processeurs, quoique plus lentement. </p><br><p>  Tout semble un peu bas et inconfortable - oui, ça l'est!  <code>std::arch</code> sont les <em>primitives</em> de ce genre de choses.  Nous espérons qu'à l'avenir nous stabiliserons toujours le <code>std::simd</code> avec des capacités de haut niveau.  Mais l'émergence de capacités SIMD de base vous permet désormais d'expérimenter la prise en charge de haut niveau de diverses bibliothèques.  Par exemple, consultez le package le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plus rapide</a> .  Voici un extrait de code sans SIMD: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lots_of_3s = (&amp;[-<span class="hljs-number"><span class="hljs-number">123.456f32</span></span>; <span class="hljs-number"><span class="hljs-number">128</span></span>][..]).iter() .map(|v| { <span class="hljs-number"><span class="hljs-number">9.0</span></span> * v.abs().sqrt().sqrt().recip().ceil().sqrt() - <span class="hljs-number"><span class="hljs-number">4.0</span></span> - <span class="hljs-number"><span class="hljs-number">2.0</span></span> }) .collect::&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>&gt;&gt;();</code> </pre> <br><p>  Pour utiliser SIMD dans ce code avec <code>faster</code> , vous devez le changer comme ceci: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lots_of_3s = (&amp;[-<span class="hljs-number"><span class="hljs-number">123.456f32</span></span>; <span class="hljs-number"><span class="hljs-number">128</span></span>][..]).simd_iter() .simd_map(f32s(<span class="hljs-number"><span class="hljs-number">0.0</span></span>), |v| { f32s(<span class="hljs-number"><span class="hljs-number">9.0</span></span>) * v.abs().sqrt().rsqrt().ceil().sqrt() - f32s(<span class="hljs-number"><span class="hljs-number">4.0</span></span>) - f32s(<span class="hljs-number"><span class="hljs-number">2.0</span></span>) }) .scalar_collect();</code> </pre> <br><p>  Cela ressemble presque à la même chose: <code>simd_iter</code> au lieu d' <code>iter</code> , <code>simd_map</code> au lieu de <code>map</code> , <code>f32s(2.0)</code> au lieu de <code>2.0</code> .  Mais au final, vous obtenez une version certifiée SIMD de votre code. </p><br><p>  En plus de <em>cela</em> , vous ne pouvez jamais écrire cela vous-même, mais, comme toujours, les bibliothèques dont vous dépendez peuvent le faire.  Par exemple, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">support a déjà été ajouté <code>  regex</code></a> , et sa nouvelle version aura une accélération SIMD sans que vous ayez à faire quoi que ce soit! </p><br><h3 id="dyn-trait"> <code>dyn Trait</code> </h3> <br><p>  En fin de compte, nous avons regretté la syntaxe initialement sélectionnée des objets trait dans Rust.  Comme vous vous en souvenez, pour un <code>Foo</code> vous pouvez définir un objet trait comme celui-ci: </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Foo&gt;</code> </pre> <br><p>  Cependant, si <code>Foo</code> était une structure, cela signifierait simplement placer la structure à l'intérieur d'une <code>Box&lt;T&gt;</code> .  Lors du développement du langage, nous avons pensé que de telles similitudes seraient une bonne idée, mais l'expérience a montré que cela conduit à la confusion.  Et ce n'est pas seulement <code>Box&lt;Trait&gt;</code> : <code>impl SomeTrait for SomeOtherTrait</code> également une syntaxe formellement correcte, mais vous devez presque toujours écrire <code>impl&lt;T&gt; SomeTrait for T where T: SomeOtherTrait</code> place.  C'est la même chose avec <code>impl SomeTrait</code> , qui semble ajouter des méthodes ou une implémentation par défaut possible au type, mais en fait, il ajoute ses propres méthodes à l'objet type.  Enfin, par rapport à la syntaxe <code>impl Trait</code> récemment ajoutée, la syntaxe <code>Trait</code> semble plus courte et préférable à utiliser, mais en réalité ce n'est pas toujours vrai. </p><br><p>  Par conséquent, dans Rust 1.27, nous avons stabilisé la nouvelle syntaxe <a href=""><code>dyn Trait</code></a> .  Les objets caractéristiques ressemblent maintenant à ceci: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//  =&gt;  Box&lt;Foo&gt; =&gt; Box&lt;dyn Foo&gt; &amp;Foo =&gt; &amp;dyn Foo &amp;mut Foo =&gt; &amp;mut dyn Foo</span></span></code> </pre> <br><p>  De même pour les autres types de pointeurs: <code>Arc&lt;Foo&gt;</code> maintenant <code>Arc&lt;dyn Foo&gt;</code> , etc.  En raison de l'exigence de compatibilité descendante, nous ne pouvons pas supprimer l'ancienne syntaxe, mais nous avons ajouté une vérification statique de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>bare-trait-object</code></a> , qui par défaut résout l'ancienne syntaxe.  Si vous souhaitez l'interdire, vous pouvez activer cette vérification.  Nous pensions qu'avec la vérification activée par défaut, trop d'avertissements seront désormais affichés. </p><br><blockquote>  Soit dit en passant, nous travaillons sur un outil appelé <code>rustfix</code> , qui peut automatiquement mettre à jour votre code vers des idiomes plus récents.  Il utilisera des contrôles statiques similaires pour cela.  Restez à l'écoute pour les annonces <code>rustfix</code> dans les prochaines annonces. </blockquote><br><h3 id="must_use-dlya-funkciy">  <code>#[must_use]</code> pour les fonctions </h3><br><p>  En conclusion, l'effet de l'attribut <code>#[must_use]</code> été étendu: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">il peut désormais être utilisé pour les fonctions</a> . </p><br><p>  Auparavant, il ne s'appliquait qu'aux types, tels que <code>Result &lt;T, E&gt;</code> .  Mais maintenant, vous pouvez le faire: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[must_use]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">double</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { <span class="hljs-number"><span class="hljs-number">2</span></span> * x } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { double(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-comment"><span class="hljs-comment">// warning: unused return value of `double` which must be used let _ = double(4); // (no warning) }</span></span></code> </pre> <br><p>  Avec cet attribut, nous avons également <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">légèrement amélioré la bibliothèque standard</a> : <code>Clone::clone</code> , <code>Iterator::collect</code> et <code>ToOwned::to_owned</code> si vous n'utilisez pas leurs valeurs de retour, ce qui vous aidera à remarquer des opérations coûteuses dont vous ignorez accidentellement les résultats. </p><br><p>  Voir <a href="">les notes de version pour plus de</a> détails. </p><br><h3 id="stabilizaciya-bibliotek">  Stabilisation de bibliothèque </h3><br><p>  Les nouvelles API suivantes ont été stabilisées dans cette version: </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>DoubleEndedIterator::rfind</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>DoubleEndedIterator::rfold</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>DoubleEndedIterator::try_rfold</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Duration::from_micros</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Duration::from_nanos</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Duration::subsec_micros</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Duration::subsec_millis</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>HashMap::remove_entry</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Iterator::try_fold</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Iterator::try_for_each</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>NonNull::cast</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Option::filter</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>String::replace_range</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Take::set_limit</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>slice::rsplit_mut</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>slice::rsplit</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>slice::swap_with_slice</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>hint::unreachable_unchecked</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>os::unix::process::parent_id</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>ptr::swap_nonoverlapping</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>process::id</code></a> </li> </ul><br><p>  Voir <a href="">les notes de version pour plus de</a> détails. </p><br><h3 id="uluchsheniya-v-cargo">  Améliorations du fret </h3><br><p>  Cargo a reçu deux améliorations mineures dans cette version.  Tout d'abord, un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>  --target-dir</code></a> , qui peut être utilisé pour changer le répertoire d'exécution cible. </p><br><p>  De plus, l'approche de Cargo sur la façon de gérer les cibles a été finalisée.  Cargo essaie de détecter des tests, des exemples et des exécutables dans votre projet.  Cependant, une configuration explicite est parfois requise.  Mais dans la mise en œuvre initiale, c'était problématique.  Disons que vous avez deux exemples et que Cargo les détecte tous les deux.  Vous souhaitez configurer l'un d'eux, pour lequel vous ajoutez <code>[[example]]</code> à <code>Cargo.toml</code> pour spécifier des exemples de paramètres.  Actuellement, Cargo verra que vous avez défini l'exemple de manière explicite et ne tentera donc pas de détecter automatiquement les autres.  C'est un peu bouleversant. </p><br><p>  Par conséquent, nous avons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>  'auto'-  Cargo.toml</code></a> .  Nous ne pouvons pas résoudre ce problème sans une panne possible des projets qui en dépendent par inadvertance.  Par conséquent, si vous souhaitez configurer certains objectifs, mais pas tous, vous pouvez définir la clé <code>autoexamples</code> sur <code>true</code> dans la section <code>[package]</code> . </p><br><p>  Voir <a href="">les notes de version pour plus de</a> détails. </p><br><h2 id="razrabotchiki-1270">  Développeurs 1.27.0 </h2><br><p>  Beaucoup de gens ont participé au développement de Rust 1.27.  Nous n'aurions pas pu terminer le travail sans chacun de vous. </p><br><p>  <a href="">Je vous remercie!</a> </p><br><p>  <em>De la part d'un traducteur: j'exprime ma gratitude aux membres de la communauté ruRust et personnellement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">ozkriff</a> pour leur aide dans la traduction et la relecture</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr415091/">https://habr.com/ru/post/fr415091/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr415075/index.html">La troisième version de reCAPTCHA fonctionne en arrière-plan sans être remarquée par les utilisateurs</a></li>
<li><a href="../fr415079/index.html">Une métrique pour les gouverner tous - Existe-t-il une seule métrique universelle?</a></li>
<li><a href="../fr415083/index.html">5. Vérifiez Point au maximum. IPS Partie 1</a></li>
<li><a href="../fr415085/index.html">Qu'est-ce que le CISSP, comment l'obtenir, ne pas le perdre et pourquoi il n'est pas nécessaire</a></li>
<li><a href="../fr415087/index.html">[CASE] Impression 3D SLA dans une usine d'électronique navale</a></li>
<li><a href="../fr415093/index.html">PVP: pourquoi injecter de la colle par voie intraveineuse</a></li>
<li><a href="../fr415153/index.html">Les exigences idéales reviennent</a></li>
<li><a href="../fr415155/index.html">Performances dans iOS ou comment décharger le thread principal. Partie 1</a></li>
<li><a href="../fr415159/index.html">Annonce de la conférence DevOps DevOops 2018</a></li>
<li><a href="../fr415163/index.html">Réseau sans fil dans une usine pharmaceutique spécialement gardée et spécialement protégée à certains endroits en Russie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>