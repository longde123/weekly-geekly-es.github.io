<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍩 👦🏿 🕖 MAM: montaje frontend sin dolor 🙂 🚴🏻 👲🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola, mi nombre es Dmitry Karlovsky y adoro a MAM. M AM gobierna los módulos Gnósticos M , ahorrándome la mayor parte de la rutina. 





 El módulo a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MAM: montaje frontend sin dolor</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456288/"><p>  Hola, mi nombre es Dmitry Karlovsky y adoro a MAM.  <strong>M</strong> AM gobierna los módulos Gnósticos <strong>M</strong> , ahorrándome la mayor parte de la rutina. </p><br><p><img src="https://habrastorage.org/webt/m2/5h/ps/m25hpsfevki-o6lwx4v_ukfxvtu.png" alt="Módulo agnóstico típico"></p><br><p> <strong>El módulo agnóstico</strong> , a diferencia del tradicional, no es un archivo fuente, sino un directorio dentro del cual puede haber códigos fuente en una variedad de idiomas: lógica de programa en <code>JS</code> / <code>TS</code> , pruebas para él en <code>TS</code> / <code>JS</code> , composición de componentes en <code>view.tree</code> , estilos en <code>CSS</code> , localización en <code>locale=*.json</code> , imágenes, etc., etc.  Si lo desea, no es difícil asegurar el soporte de cualquier otro idioma.  Por ejemplo, Stylus para escribir estilos o HTML para describir plantillas. </p><br><p>  Las dependencias entre módulos se rastrean automáticamente mediante el análisis de la fuente.  Si el módulo se enciende, se enciende como un todo: cada código fuente del módulo se transpone y cae en el paquete correspondiente: scripts - por separado, estilos - por separado, pruebas - por separado.  Para diferentes plataformas, sus paquetes: para un nodo, el suyo, para un navegador, el suyo. </p><br><p>  Automatización total, falta de configuración y repetitivo, tamaños de paquete mínimos, bombeo automático de dependencias, desarrollo de cientos de bibliotecas y aplicaciones enajenadas en una base de código sin dolor ni sufrimiento.  <strong>Wow que adicción!</strong>  ¡Saquen a los niños embarazadas, nerviosos, de los monitores y bienvenidos al submarino! </p><a name="habracut"></a><br><h1 id="filosofiya">  Filosofía </h1><br><p>  MAM es un experimento audaz para cambiar radicalmente la forma en que se organiza el código y el proceso de trabajar con él.  Aquí están los principios básicos: </p><br><p>  <strong>Convenciones en lugar de configuración.</strong>  Los acuerdos razonables, simples y universales le permiten automatizar toda la rutina, manteniendo la comodidad y la uniformidad entre los diferentes proyectos. </p><br><p>  <strong>La infraestructura está separada, el código está separado.</strong>  Una situación no es infrecuente cuando necesita desarrollar docenas, o incluso cientos de bibliotecas y aplicaciones.  No despliegue la infraestructura de ensamblaje, desarrollo, despliegue, etc. para cada uno de ellos.  Es suficiente pedirlo una vez y luego remachar aplicaciones como pasteles. </p><br><p>  <strong>No pague por lo que no usa.</strong>  Utiliza algún tipo de módulo: está incluido en el paquete con todas sus dependencias.  No utilizar: no se enciende.  Cuanto más pequeños son los módulos, mayor es la granularidad y menos código innecesario en el paquete. </p><br><p>  <strong>Código mínimo redundante.</strong>  Romper el código en los módulos debería ser tan simple como escribir todo el código en un solo archivo.  De lo contrario, el desarrollador será perezoso para dividir los módulos grandes en pequeños. </p><br><p>  <strong>No hay conflictos de versiones.</strong>  Solo hay una versión: la actual.  No es necesario gastar recursos en el soporte de versiones antiguas, si puede gastarlas en actualizar las últimas. </p><br><p>  <strong>Mantenga un dedo en el pulso.</strong>  Los comentarios más rápidos con respecto a las incompatibilidades no permitirán que el código salga mal. </p><br><p>  <strong>La forma más fácil es la más segura.</strong>  Si el camino correcto requiere un esfuerzo adicional, asegúrese de que nadie vaya a ellos. </p><br><h1 id="importyeksporty">  Importaciones / Exportaciones </h1><br><p>  Abrimos el primer proyecto que <a href="">surgió</a> utilizando un sistema de módulos moderno: <a href="">un módulo tiene menos de 300 líneas de largo, 30 de las cuales son importaciones.</a> </p><br><p>  Pero estas siguen siendo flores: <a href="">para una función de 9 líneas, se requieren 8 importaciones.</a> </p><br><p>  Y mi favorito: <a href="">ni una sola línea de código útil.</a>  20 líneas de cambio de valores del montón de módulos a uno, para que luego pueda importar desde un módulo, y no desde veinte. </p><br><p>  Todo esto es repetitivo, lo que lleva al hecho de que los desarrolladores son demasiado vagos para asignar pequeños fragmentos de código en módulos separados, prefiriendo módulos grandes a pequeños.  E incluso si no son perezosos, resulta mucho código para importar módulos pequeños o módulos especiales que importan muchos módulos en sí mismos y los exportan a granel. </p><br><p>  Todo esto conduce a una baja granularidad del código y a inflar el tamaño de los paquetes con código no utilizado, lo cual es lo suficientemente afortunado como para estar cerca del que se usa.  Para JS, están tratando de resolver este problema complicando la tubería de ensamblaje, agregando la llamada "sacudida del árbol", que corta el exceso de lo que importó.  Esto ralentiza el montaje, pero no todo está cortado. </p><br><p>  Idea: <strong>¿Qué sucede si no importamos, sino que solo tomamos y usamos, y el recolector mismo descubrirá qué necesita importarse?</strong> </p><br><p>  Los IDE modernos pueden generar automáticamente importaciones para las entidades que utiliza.  Si el IDE puede hacer esto, ¿qué impide que el recopilador haga esto?  Es suficiente tener un acuerdo simple sobre el nombre y la ubicación de los archivos, lo que sería conveniente para el usuario y comprensible para la máquina.  PHP ha tenido durante mucho tiempo una convención estándar: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PSR-4</a> .  MAM introduce lo mismo para los archivos <em>.ts y</em> .jam.js: los nombres que comienzan con $ son el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nombre completo de</a> alguna entidad global cuyo código se carga a lo largo de la ruta obtenida de FQN reemplazando los delimitadores con barras inclinadas.  Un ejemplo simple de dos módulos: </p><br><p>  <strong>my / alert / alert.ts</strong> </p><br><pre> <code class="plaintext hljs">const $my_alert = alert // FQN   </code> </pre> <br><p>  <strong>my / app / app.ts</strong> </p><br><pre> <code class="plaintext hljs">$my_alert( 'Hello!' ) // ,   /my/alert/</code> </pre> <br><p>  Un módulo completo de una línea: ¿qué podría ser más simple?  El resultado no se hace esperar: la simplicidad de crear y usar módulos lleva a minimizar su tamaño.  Como resultado, para maximizar la granularidad.  Y como una cereza, minimiza el tamaño de los bultos sin sacudir los árboles. </p><br><p>  Un buen ejemplo es la familia de módulos de validación JSON <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">/ mol / data</a> .  Si utiliza la función <code>$mol_data_integer</code> en algún lugar de su código, los módulos <code>/mol/data/integer</code> y <code>/mol/data/number</code> , de los que depende <code>$mol_data_integer</code> , se incluirán en el paquete.  Pero, por ejemplo, el recopilador <code>/mol/data/email</code> ni siquiera leerá desde el disco, ya que nadie depende de él. </p><br><h1 id="razgrebaya-bardak">  Rastrillar un desastre </h1><br><p>  Desde que comenzamos a patear Angular, no nos detendremos.  ¿Dónde piensa buscar la <code>applyStyles</code> función <code>applyStyles</code> ?  No adivinará en <a href=""><code>/packages/core/src/render3/styling_next/bindings.ts</code></a> .  La capacidad de colocar cualquier cosa en cualquier lugar conduce al hecho de que en cada proyecto observamos un sistema único de ubicación de archivos, a menudo no susceptible de ninguna lógica.  Y si el "salto a la definición" a menudo guarda el IDE, entonces ver el código en el github o revisar la solicitud de extracción se ven privados de esta oportunidad. </p><br><p>  Idea: <strong>¿Qué pasa si los nombres de las entidades corresponden estrictamente a su ubicación?</strong> </p><br><p>  Para colocar el código en el archivo <code>/angular/packages/core/src/render3/stylingNext/bindings.ts</code> , en la arquitectura MAM deberá nombrar la entidad <code>$angular_packages_core_src_render3_stylingNext_applyStyles</code> , pero, por supuesto, nadie actuará, porque hay mucho más en el nombre.  Pero los nombres en el código quiero ver cortos y concisos, por lo que el desarrollador intentará excluir todo lo innecesario del nombre, dejando solo lo importante: <code>$angular_render3_applyStyles</code> .  Y se ubicará en consecuencia en <code>/angular/render3/applyStyles/applyStyles.ts</code> . </p><br><p>  Observe cómo MAM utiliza las debilidades de los desarrolladores para lograr el resultado deseado: cada entidad obtiene un nombre corto globalmente único que puede usarse en cualquier contexto.  Por ejemplo, en los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mensajes de confirmaciones,</a> estos nombres le permiten captar de manera rápida y precisa de lo que están hablando: </p><br><pre> <code class="plaintext hljs">73ebc45e517ffcc3dcce53f5b39b6d06fc95cae1 $mol_vector: range expanding support 3a843b2cb77be19688324eeb72bd090d350a6cc3 $mol_data: allowed transformations 24576f087133a18e0c9f31e0d61052265fd8a31a $mol_data_record: support recursion</code> </pre> <br><p>  O supongamos que desea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">encontrar todas las menciones del módulo $ mol_fiber en Internet</a> , lo que lo hace más fácil que nunca gracias a FQN. </p><br><h1 id="ciklicheskie-zavisimosti">  Dependencias cíclicas </h1><br><p>  Escribamos 7 líneas de código simple en un archivo: </p><br><pre> <code class="plaintext hljs">export class Foo { get bar() { return new Bar(); } } export class Bar extends Foo {} console.log(new Foo().bar);</code> </pre> <br><p>  A pesar de la dependencia cíclica, funciona correctamente.  Lo dividimos en 3 archivos: </p><br><p>  <strong>my / foo.js</strong> </p><br><pre> <code class="plaintext hljs">import { Bar } from './bar.js'; export class Foo { get bar() { return new Bar(); } }</code> </pre> <br><p>  <strong>my / bar.js</strong> </p><br><pre> <code class="plaintext hljs">import { Foo } from './foo.js'; export class Bar extends Foo {}</code> </pre> <br><p>  <strong>my / app.js</strong> </p><br><pre> <code class="plaintext hljs">import { Foo } from './foo.js'; console.log(new Foo().bar);</code> </pre> <br><p>  ¡Vaya! Error de <code>ReferenceError: Cannot access 'Foo' before initialization</code> .  ¿Qué tipo de tonterías?  Para solucionar esto, nuestra <code>app.js</code> necesita saber que <code>foo.js</code> depende de <code>bar.js</code>  Por lo tanto, primero tenemos que importar <code>bar.js</code> , que importa <code>foo.js</code>  Después de lo cual ya podemos importar <code>foo.js</code> sin error: </p><br><p>  <strong>my / app.js</strong> </p><br><pre> <code class="plaintext hljs">import './bar.js'; import { Foo } from './foo.js'; console.log(new Foo().bar);</code> </pre> <br><p>  Esos navegadores, ese NodeJS, ese paquete web, ese paquete, todos funcionan de manera torcida con dependencias circulares.  Y bueno, simplemente los prohibirían: uno podría complicar de inmediato el código para que no haya bucles.  Pero pueden funcionar bien, y luego bam, y dar un error incomprensible. </p><br><p>  Idea: <strong>¿Qué</strong> sucede <strong>si durante el ensamblaje simplemente pegamos los archivos en el orden correcto, como si todo el código se hubiera escrito originalmente en un archivo?</strong> </p><br><p>  Dividamos el código usando los principios de MAM: </p><br><p>  <strong>my / foo / foo.ts</strong> </p><br><pre> <code class="plaintext hljs">class $my_foo { get bar() { return new $my_bar(); } }</code> </pre> <br><p>  <strong>my / bar / bar.ts</strong> </p><br><pre> <code class="plaintext hljs">class $my_bar extends $my_foo {}</code> </pre> <br><p>  <strong>my / app / app.ts</strong> </p><br><pre> <code class="plaintext hljs">console.log(new $my_foo().bar);</code> </pre> <br><p>  Todas las mismas 7 líneas de código que originalmente.  Y simplemente funcionan sin chamanismo adicional.  El caso es que el coleccionista entiende que la dependencia de <code>my/bar</code> de <code>my/foo</code> más estricta que <code>my/foo</code> de <code>my/bar</code> .  Esto significa que debe incluir estos módulos en el paquete en este orden: <code>my/foo</code> , <code>my/bar</code> , <code>my/app</code> . </p><br><p>  ¿Cómo entiende esto el coleccionista?  Ahora la heurística es simple: por el número de sangría en la línea en la que se detecta la dependencia.  Tenga en cuenta que una dependencia más fuerte en nuestro ejemplo tiene cero sangría, y una débil tiene doble sangría. </p><br><h1 id="raznye-yazyki">  Diferentes idiomas </h1><br><p>  Dio la casualidad de que para diferentes cosas tenemos diferentes idiomas para estas diferentes cosas agudizadas.  Los más comunes son: JS, TS, CSS, HTML, SVG, SCSS, Less, Stylus.  Cada uno tiene su propio sistema de módulos, que no interactúa con otros idiomas de ninguna manera.  No hace falta decir que hay unos 100500 tipos de idiomas más específicos.  Como resultado, para conectar un componente, debe conectar por separado sus scripts, estilos separados, registrar plantillas por separado, configurar por separado la implementación de los archivos estáticos que necesita, etc., etc. </p><br><p>  Gracias a los cargadores, Webpack está tratando de resolver este problema.  Pero tiene un punto de entrada es un script que ya conecta archivos en otros idiomas.  ¿Y si no necesitamos un script?  Por ejemplo, tenemos un módulo con hermosos estilos para platos y queremos que tengan los mismos colores en el tema claro y otros en la oscuridad: </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.dark-theme</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">table</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: black; } <span class="hljs-selector-class"><span class="hljs-selector-class">.light-theme</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">table</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: white; }</code> </pre> <br><p>  Además, si dependemos del tema, se debe cargar un script que instalará el tema deseado según la hora del día.  Es decir, CSS en realidad depende de JS. </p><br><p>  Idea: <strong>¿Qué pasa si un sistema modular no depende de idiomas?</strong> </p><br><p>  Dado que en MAM el sistema modular está separado de los idiomas, las dependencias pueden ser entre idiomas.  CSS puede depender de JS, que puede depender de TS, que puede depender de otro JS.  Esto se logra debido al hecho de que las dependencias de origen se detectan en los módulos, y los módulos están conectados por completo y pueden contener códigos fuente en cualquier idioma.  En el caso del ejemplo de temas, se ve así: </p><br><p>  <strong>/my/table/table.css</strong> </p><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* ,   /my/theme */</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[my_theme="dark"]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">table</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: black; } <span class="hljs-selector-attr"><span class="hljs-selector-attr">[my_theme="light"]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">table</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: white; }</code> </pre> <br><p>  <strong>/my/theme/theme.js</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.documentElement.setAttribute( <span class="hljs-string"><span class="hljs-string">'my_theme'</span></span> , ( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>().getHours() + <span class="hljs-number"><span class="hljs-number">15</span></span> ) % <span class="hljs-number"><span class="hljs-number">24</span></span> &lt; <span class="hljs-number"><span class="hljs-number">12</span></span> ? <span class="hljs-string"><span class="hljs-string">'light'</span></span> : <span class="hljs-string"><span class="hljs-string">'dark'</span></span> , )</code> </pre> <br><p>  Utilizando esta técnica, por cierto, puede implementar su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Modernizador</a> , pero sin 300 comprobaciones que no necesita, porque solo se incluirán en el paquete las comprobaciones de las que realmente depende su CSS. </p><br><h1 id="mnogo-bibliotek">  Muchas bibliotecas </h1><br><p>  Por lo general, el punto de entrada para crear un paquete es algún tipo de archivo.  En el caso de Webpack, este es JS.  Si desarrolla muchas bibliotecas y aplicaciones enajenables, entonces necesita muchos paquetes.  Y para cada paquete necesita crear un punto de entrada separado.  En el caso de Parcel, el punto de entrada es HTML, que para las aplicaciones deberá crearse de todos modos.  Pero para las bibliotecas, esto de alguna manera no es muy adecuado. </p><br><p>  Idea: <strong>¿Qué pasa si cualquier módulo puede ensamblarse en un paquete independiente sin preparación previa?</strong> </p><br><p>  Armemos la última versión del generador de proyectos $ mol_build MAM: </p><br><pre> <code class="plaintext hljs">mam mol/build</code> </pre> <br><p>  Ahora ejecute este colector y deje que se vuelva a armar para asegurarse de que todavía puede hacerlo: </p><br><pre> <code class="plaintext hljs">node mol/build/-/node.js mol/build</code> </pre> <br><p>  Aunque, no, vamos a pedirle que ejecute pruebas junto con la asamblea: </p><br><pre> <code class="plaintext hljs">node mol/build/-/node.test.js mol/build</code> </pre> <br><p>  Y si todo salió bien, publique el resultado en NPM: </p><br><pre> <code class="plaintext hljs">npm publish mol/build/-</code> </pre> <br><p>  Como puede ver, al ensamblar el módulo, se crea un subdirectorio con el nombre <code>-</code> y todos los artefactos de ensamblaje se colocan allí.  Veamos los archivos que puedes encontrar allí: </p><br><ul><li>  <code>web.dep.json</code> : toda la información sobre el gráfico de dependencia </li><li>  <code>web.js</code> - paquete de script del navegador </li><li>  <code>web.js.map</code> - sorsmaps para él </li><li>  <code>web.esm.js</code> : tiene la forma de un módulo es </li><li>  <code>web.esm.js.map</code> - y sorsmaps para ello </li><li>  <code>web.test.js</code> - paquete de prueba </li><li>  <code>web.test.js.map</code> - y para pruebas sorsmap </li><li>  <code>web.d.ts</code> - paquete con tipos de todo lo que está en el paquete de script </li><li>  <code>web.css</code> - paquete con estilos </li><li>  <code>web.css.map</code> - y clasifica mapas para ello </li><li>  <code>web.test.html</code> : punto de entrada para ejecutar pruebas de rendimiento en un navegador </li><li>  <code>web.view.tree</code> : declaraciones de todos los componentes incluidos en el paquete view.tree </li><li>  <code>web.locale=*.json</code> - paquetes con textos localizados, cada paquete tiene su propio paquete </li><li>  <code>package.json</code> : le permite publicar inmediatamente el módulo ensamblado en NPM </li><li>  <code>node.dep.json</code> : toda la información sobre el gráfico de dependencia </li><li>  <code>node.js</code> - paquete de script de nodo </li><li>  <code>node.js.map</code> - sorsmaps para ello </li><li>  <code>node.esm.js</code> : tiene la forma de un módulo es </li><li>  <code>node.esm.js.map</code> - y sorsmaps para ello </li><li>  <code>node.test.js</code> : el mismo paquete, pero también con pruebas </li><li>  <code>node.test.js.map</code> - y sorsmaps para ello </li><li>  <code>node.d.ts</code> : paquete con tipos de todo lo que está en el paquete de script </li><li>  <code>node.view.tree</code> : declaraciones de todos los componentes incluidos en el paquete view.tree </li><li>  <code>node.locale=*.json</code> - paquetes con textos localizados, cada paquete tiene su propio paquete </li></ul><br><p>  La estática simplemente se copia junto con las rutas.  Como ejemplo, tome una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aplicación que muestre sus propios códigos fuente</a> .  Sus fuentes están aquí: </p><br><ul><li> <code>/mol/app/quine/quine.view.tree</code> </li> <li> <code>/mol/app/quine/quine.view.ts</code> </li> <li> <code>/mol/app/quine/index.html</code> </li> <li> <code>/mol/app/quine/quine.locale=ru.json</code> </li> </ul><br><p>  Desafortunadamente, en el caso general, el recopilador no puede saber que necesitaremos estos archivos en tiempo de ejecución.  Pero podemos decirle esto poniendo un archivo especial cerca: </p><br><p>  <strong>/mol/app/quine/quine.meta.tree</strong> </p><br><pre> <code class="plaintext hljs">deploy \/mol/app/quine/quine.view.tree deploy \/mol/app/quine/quine.view.ts deploy \/mol/app/quine/index.html deploy \/mol/app/quine/quine.locale=ru.json</code> </pre> <br><p>  Como resultado del ensamblado <code>/mol/app/quine</code> , se copiarán de las siguientes maneras: </p><br><ul><li> <code>/mol/app/quine/-/mol/app/quine/quine.view.tree</code> </li> <li> <code>/mol/app/quine/-/mol/app/quine/quine.view.ts</code> </li> <li> <code>/mol/app/quine/-/mol/app/quine/index.html</code> </li> <li> <code>/mol/app/quine/-/mol/app/quine/quine.locale=ru.json</code> </li> </ul><br><p>  Ahora el directorio <code>/mol/app/quine/-</code> se puede diseñar en cualquier alojamiento estático y la aplicación será completamente funcional. </p><br><h1 id="celevye-platformy">  Plataformas de destino </h1><br><p>  JS se puede ejecutar tanto en el cliente como en el servidor.  Y qué bueno es cuando puedes escribir un código y funcionará en todas partes.  Sin embargo, a veces la implementación de lo mismo en el cliente y el servidor es fundamentalmente diferente.  Y quiero, por ejemplo, que se use una implementación para un nodo y otra para un navegador. </p><br><p>  Idea: <strong>¿Qué</strong> sucede <strong>si el propósito del archivo se refleja en su nombre?</strong> </p><br><p>  MAM usa un sistema de etiquetas en los nombres de archivo.  Por ejemplo, el módulo <code>$mol_state_arg</code> proporciona acceso a los parámetros de aplicación definidos por el usuario.  En el navegador, estos parámetros se establecen a través de la barra de direcciones.  Y en el nodo, a través de argumentos de línea de comando.  <code>$mol_sate_arg</code> el resto de la aplicación de estos matices mediante la implementación de ambas opciones con una única interfaz, colocándolas en archivos: </p><br><ul><li>  / mol / state / arg / arg.  <strong>web</strong> .ts - implementación para navegadores </li><li>  / mol / state / arg / arg.  <strong>nodo</strong> .ts: implementación para un nodo </li></ul><br><p>  Las fuentes no etiquetadas con estas etiquetas se incluyen independientemente de la plataforma de destino. </p><br><p>  Se observa una situación similar con las pruebas: desean almacenarse junto al resto de las fuentes, pero no quieren incluirse en el paquete que va al usuario final.  Por lo tanto, las pruebas también están marcadas con una etiqueta separada: </p><br><ul><li>  / mol / state / arg / arg.  <strong>test</strong> .ts - pruebas de módulo, caerán en el paquete de prueba </li></ul><br><p>  Las etiquetas pueden ser paramétricas.  Por ejemplo, con cada módulo pueden venir textos en varios idiomas y deben incluirse en los paquetes de idiomas correspondientes.  Un archivo de texto es un diccionario JSON normal nombrado con la configuración regional en el nombre: </p><br><ul><li>  / mol / app / life / life.  <strong>locale = ru</strong> .json - textos para el idioma ruso </li><li>  / mol / app / life / life.  <strong>locale = jp</strong> .json - textos para japonés </li></ul><br><p>  Finalmente, ¿qué pasa si queremos poner archivos cerca, pero queremos que el recopilador los ignore y no los incluya automáticamente en el paquete?  Es suficiente agregar al comienzo de su nombre cualquier carácter no alfanumérico.  Por ejemplo: </p><br><ul><li>  / hyoo / juguetes / <strong>.</strong>  git: comienza con un punto, por lo que el recopilador ignorará este directorio </li></ul><br><h1 id="versionirovanie">  Versionado </h1><br><p>  Google lanzó AngularJS por primera vez y lo publicó en NPM como <code>angular</code> .  Luego creó un marco completamente nuevo con un nombre similar: Angular y lo publicó con el mismo nombre, pero ya la versión 2. Ahora estos dos fuegos artificiales se están desarrollando de forma independiente.  Solo se produce un cambio de ruptura de API entre las versiones principales.  Y el otro, <a href="">entre el menor</a> .  Y dado que es imposible poner dos versiones de la misma dependencia en el mismo nivel, no se puede hablar de una transición fluida, cuando dos versiones de la biblioteca coexisten simultáneamente durante algún tiempo en la aplicación. </p><br><p>  Parece que el equipo de Angular ya ha pisado todos los rastrillos posibles.  Y una cosa más: el código marco está dividido en varios módulos grandes.  Al principio, los versionaron de forma independiente, pero muy rápidamente, incluso ellos mismos comenzaron a confundirse sobre las versiones de los módulos que son compatibles entre sí, y mucho menos los desarrolladores comunes.  Por lo tanto, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Angular cambió a versiones de extremo a extremo</a> , donde la versión principal del módulo puede cambiar incluso sin ningún cambio en el código.  El soporte para múltiples versiones de múltiples módulos es un gran problema tanto para los propios mantenedores como para el ecosistema en su conjunto.  Después de todo, se gastan muchos recursos de todos los miembros de la comunidad para garantizar la compatibilidad con módulos ya obsoletos. </p><br><p>  La hermosa idea de las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">versiones semánticas</a> se convierte en una realidad dura: nunca se sabe si algo se romperá cuando cambie la versión menor <a href="">o incluso la versión del parche</a> .  Por lo tanto, en muchos proyectos, se repara una versión específica de la dependencia.  Sin embargo, una solución de este tipo no afecta las dependencias transitivas, que pueden ser atraídas a la última versión cuando se instala desde cero, pero pueden seguir siendo las mismas si ya lo son.  Este desastre lleva al hecho de que nunca puede confiar en una versión fija y necesita verificar regularmente la compatibilidad con las versiones actuales de dependencias (al menos transitivas). </p><br><p>  ¿Pero qué pasa con <a href="">los archivos de bloqueo</a> ?  Si está desarrollando una biblioteca que se instala a través de dependencias, el archivo de bloqueo no lo ayudará, ya que el administrador de paquetes lo ignorará.  Para la aplicación final, el archivo de bloqueo le dará la llamada "reproducibilidad de ensamblajes".  Pero seamos honestos.  ¿Cuántas veces necesitas construir la aplicación final desde la misma fuente?  Exactamente una vez.  Al recibir la salida, independientemente de cualquier NPM, el artefacto de ensamblaje: un binario ejecutable, un contenedor de acoplador o simplemente un archivo con todo el código necesario para ejecutarlo.  Espero que no <code>npm install</code> haciendo <code>npm install</code> en prod? </p><br><p>  Algunos encuentran el uso de archivos de bloqueo para que el servidor CI reúna exactamente lo que el desarrollador ha comprometido.  Pero espere, el desarrollador mismo puede simplemente ensamblarlo en su máquina local.  ,    ,  ,    . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Continuous Integration</a>       ,     ,    ,  ,   - .  CI        ,            . </p><br><p>        ,     ,  . ,            Angular@4 (  3).  ,     ,  "     "  "     ".      Angular@4     ,      Angular@5.      Angular@6,         .  Angular   TypeScript    .     .  ,   2  ,  …      ,   business value    ,     ,  ,  ,  . </p><br><p>                   ,    ,       ,   ,       2 .    :      ,  — ,  — .       3 React, 5 jQuery, 7 lodash. </p><br><p> : <strong>         — ?</strong> </p><br><p>         .     -   .     ,       .     ,     .  ,    .  ,       .        ,    .   ,        ,            .      :  issue,    ,  workaround,  pull request,    ,      .          ,    ,    .        .            . </p><br><p>               ,        . ,        ,       .        .        .  :  ,       ,     -.     -      —       .  ,            ,    -  .         , ,  ,   NPM <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>     .  ,      .       . </p><br><p>         ,      ?   —   .  <code>mobx</code> ,  <code>mobx2</code>     API  .   —    ,    :     ,       .     <code>mobx</code>        <code>mobx2</code> ,      API.         API,     . </p><br><p>        .           — .  ,      : </p><br><pre> <code class="plaintext hljs">var pages_count = $mol_atom2_sync( ()=&gt; $lib_pdfjs.getDocument( uri ).promise ).document().numPages</code> </pre> <br><p>  <strong> </strong>   <code>mol_atom2_sync</code>  <code>lib_pdfjs</code> ,      : </p><br><pre> <code class="plaintext hljs">npm install mol_atom2_sync@2.1 lib_pdfjs@5.6</code> </pre> <br><p> ,   , —   ,       .        ?    —    ,    <code>*.meta.tree</code> ,          : </p><br><p> <strong>/.meta.tree</strong> </p><br><pre> <code class="plaintext hljs">pack node git \https://github.com/nin-jin/pms-node.git pack mol git \https://github.com/eigenmethod/mol.git pack lib git \https://github.com/eigenmethod/mam-lib.git</code> </pre> <br><p>    .             . </p><br><h1 id="integraciya-s-npm">   NPM </h1><br><p> MAM —    NPM . ,         — . ,    ,     NPM      . </p><br><p>          NPM ,     $node. ,   -        -: </p><br><p> <strong>/my/app/app.ts</strong> </p><br><pre> <code class="plaintext hljs">$node.portastic.find({ min : 8080 , max : 8100 , retrieve : 1 }).then( ( ports : number[] ) =&gt; { $node.express().listen( ports[0] ) })</code> </pre> <br><p>       ,     . -    <code>lib</code>      NPM . ,     NPM- <code>pdfjs-dist</code> : </p><br><p> <strong>/lib/pdfjs/pdfjs.ts</strong> </p><br><pre> <code class="plaintext hljs">namespace $ { export let $lib_pdfjs : typeof import( 'pdfjs-dist' ) = require( 'pdfjs-dist/build/pdf.min.js' ) $lib_pdfjs.disableRange = true $lib_pdfjs.GlobalWorkerOptions.workerSrc = '-/node_modules/pdfjs-dist/build/pdf.worker.min.js' }</code> </pre> <br><p> <strong>/lib/pdfjs/pdfjs.meta.tree</strong> </p><br><pre> <code class="plaintext hljs">deploy \/node_modules/pdfjs-dist/build/pdf.worker.min.js</code> </pre> <br><p>        ,    . </p><br><h1 id="okruzhenie-razrabotchika">   </h1><br><p>          .     <code>create-react-app</code>  <code>angular-cli</code> ,       . , ,   <code>eject</code>       .          .       ,         ,       . </p><br><p> : <strong>      ?</strong> </p><br><p>    MAM      .          . </p><br><p>      MAM  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   MAM </a> ,    : </p><br><pre> <code class="plaintext hljs">git clone https://github.com/eigenmethod/mam.git ./mam &amp;&amp; cd mam npm install npm start</code> </pre> <br><p>   8080   . ,    —        MAM. </p><br><p>     (  — <code>acme</code> )         (  — <code>hello</code>  <code>home</code> ): </p><br><p> <strong>/acme/acme.meta.tree</strong> </p><br><pre> <code class="plaintext hljs">pack hello git \https://github.com/acme/hello.git pack home git \https://github.com/acme/home.git</code> </pre> <br><p>           <code>npm start</code> : </p><br><pre> <code class="plaintext hljs">npm start acme/hello acme/home</code> </pre> <br><p>         .     —  . ,  ,   .     —   : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://t.me/mam_mol</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/456288/">https://habr.com/ru/post/456288/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456272/index.html">¿Qué es Android Lint y cómo te ayuda a escribir código compatible?</a></li>
<li><a href="../456274/index.html">Psicólogos: los robots sexuales conducirán a un aumento en el número de personas sin pareja que no necesitan relaciones con otras personas</a></li>
<li><a href="../456276/index.html">¿Qué es la información?</a></li>
<li><a href="../456280/index.html">Comenzar con stm32 o no repetir mis errores</a></li>
<li><a href="../456282/index.html">Gráficos multidimensionales en Python: de tridimensional a seis dimensional</a></li>
<li><a href="../456290/index.html">Telegrama Unidad de red ilimitada. Gratis</a></li>
<li><a href="../456294/index.html">Diferencias entre LabelEncoder y OneHotEncoder en SciKit Learn</a></li>
<li><a href="../456296/index.html">El mundo de la hiperesfera tridimensional. Trazado de rayos geodésicos en un universo cerrado con geometría esférica</a></li>
<li><a href="../456298/index.html">Tecnologías de microelectrónica en los dedos: la Ley de Moore, los movimientos de marketing y por qué los nanómetros no son lo mismo ahora. Parte 2</a></li>
<li><a href="../456300/index.html">Encontrar zina</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>