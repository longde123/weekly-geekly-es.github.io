<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåã üåÖ üë®‚Äçüë®‚Äçüë¶ Optimizaci√≥n del rendimiento para aplicaciones .NET (C #) üë©üèΩ‚Äç‚öïÔ∏è üëåüèº üë®üèæ‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hay muchos art√≠culos con un encabezado similar, por lo que intentar√© evitar los temas comunes. Espero que incluso un desarrollador con mucha experienc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimizaci√≥n del rendimiento para aplicaciones .NET (C #)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466931/"><img src="https://habrastorage.org/webt/gs/yu/jc/gsyujcvzccxootdcxkywpaida0k.jpeg" alt="imagen"><br><br>  Hay muchos art√≠culos con un encabezado similar, por lo que intentar√© evitar los temas comunes.  Espero que incluso un desarrollador con mucha experiencia encuentre algo √∫til aqu√≠.  Este art√≠culo considerar√° solo mecanismos y enfoques de optimizaci√≥n simples que les permitir√°n aplicarse con un m√≠nimo de esfuerzo.  Y estos cambios no aumentar√°n la entrop√≠a de su c√≥digo.  El art√≠culo no prestar√° atenci√≥n a qu√© y cu√°ndo optimizar, este art√≠culo trata m√°s sobre el enfoque para escribir c√≥digo en general. <br><a name="habracut"></a><br><h4>  1. ToArray vs ToList </h4><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetItems</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _storage.Items.Where(...).ToList(); }</code> </pre> <br>  De acuerdo, un c√≥digo muy t√≠pico para proyectos industriales.  ¬øPero qu√© le pasa?  La interfaz IEnumerable devuelve una colecci√≥n que puede "revisar"; esta interfaz no implica que podamos agregar / eliminar elementos.  En consecuencia, no hay necesidad de finalizar la expresi√≥n LINQ mediante la conversi√≥n a una Lista (ToList).  En este caso, es preferible enviar a matriz (ToArray).  Como List es un contenedor sobre Array, y todas las caracter√≠sticas adicionales proporcionadas por este contenedor, cortamos la interfaz.  Una matriz consume menos memoria y el acceso a sus valores es m√°s r√°pido.  En consecuencia, ¬øpor qu√© pagar m√°s?  Por un lado, esta optimizaci√≥n no es significativa, ya que dicen "optimizaci√≥n en los partidos", pero esto no es del todo cierto.  El hecho es que en una aplicaci√≥n t√≠pica en la que los servicios devuelven modelos para la capa de presentaci√≥n, puede haber una mir√≠ada de llamadas ToList.  En el ejemplo descrito anteriormente, la interfaz IEnumerable se introduce solo con fines ilustrativos.  Este enfoque es relevante para todos los casos en los que necesita devolver una colecci√≥n que no va a cambiar m√°s adelante. <br><br>  Preveo un comentario de que Array y List no funcionar√°n de manera equivalente en el caso de acceso multiproceso a la colecci√≥n.  Realmente lo es  Pero si usted, como desarrollador, est√° considerando la posibilidad de acceso multiproceso a dicha colecci√≥n con la posibilidad de cambiarla, entonces, con un alto grado de probabilidad, ni Array ni List ser√°n adecuados para usted. <br><br><h4>  2. El par√°metro "ruta del archivo" no siempre es la mejor opci√≥n para su m√©todo </h4><br>  Al desarrollar una API, evite las firmas de m√©todos que reciben una ruta de archivo como entrada (para su posterior procesamiento por su m√©todo).  En su lugar, proporcione la capacidad de pasar una matriz de bytes a la entrada, o <b>como un √∫ltimo recurso</b> Stream.  El hecho es que, con el tiempo, su m√©todo se puede aplicar no solo a un archivo del disco, sino tambi√©n a un archivo transferido a trav√©s de la red, a un archivo de un archivo, a un archivo de una base de datos, a un archivo cuyo contenido se genera din√°micamente en la memoria, etc. e) Al proporcionar un m√©todo con el par√°metro de entrada "ruta de archivo", obliga al usuario de su API a guardar los datos en el disco antes de leerlos nuevamente.  Esta operaci√≥n sin sentido afecta cr√≠ticamente el rendimiento.  Un viaje es algo extremadamente lento.  Para mayor comodidad, puede proporcionar un m√©todo con un par√°metro de entrada "ruta a un archivo", pero en el interior siempre use un m√©todo p√∫blico sobrecargado con una matriz de bytes o flujo en la entrada.  Hay un "marcador" que puede ayudar a encontrar operaciones adicionales de escritura / lectura de disco, intente encontrar en su proyecto utilizando m√©todos est√°ndar: <code>Path.GetTempPath()</code> y <code>Path.GetRandomFileName()</code> (de System.IO).  Con un alto grado de probabilidad, encontrar√° una soluci√≥n alternativa al problema anterior o similar. <br><br>  Un lector atento y experimentado notar√° que, en algunos casos, escribir en el disco puede, por el contrario, mejorar el rendimiento, por ejemplo, si se trata de archivos muy grandes.  Esto es cierto, debe tenerse en cuenta, pero supongo que esta es una situaci√≥n muy rara con una implementaci√≥n espec√≠fica. <br><br><h4>  3. Evite usar hilos como par√°metros y el resultado de retorno de sus m√©todos </h4><br>  ¬øCu√°l es el problema aqu√≠ ... cuando recibimos una transmisi√≥n de alg√∫n "recuadro negro", debemos tener en cuenta su estado.  Es decir  ¬øEst√° abierta la corriente?  ¬øD√≥nde est√° el marcador de lectura / escritura?  ¬øPuede cambiar su estado independientemente de nuestro c√≥digo?  Si una transmisi√≥n se declara como una clase base de Transmisi√≥n, ni siquiera tenemos informaci√≥n sobre qu√© operaciones est√°n disponibles.  Todo esto se resuelve mediante controles adicionales, y esto es un c√≥digo y costos adicionales.  Adem√°s, repetidamente me encontr√© con una situaci√≥n en la que, cuando recib√≠a Stream de alg√∫n m√©todo "oscuro", el desarrollador prefer√≠a jugar de forma segura y "transferir" datos de √©l a un nuevo MemoryStream local completamente controlado.  Aunque, la secuencia de origen podr√≠a ser bastante segura.  Tal vez incluso esto ya estaba amablemente preparado para leer MemoryStream.  A veces puede llegar al punto de lo absurdo: dentro de un m√©todo, se coloca una matriz de bytes en un MemoryStream, luego este MemoryStream se devuelve como resultado de un m√©todo declarado como Stream base.  Afuera, este Stream se convierte en un nuevo MemoryStream, y luego ToArray () devuelve una matriz de bytes, que originalmente ten√≠amos.  M√°s precisamente, ser√° su pr√≥xima copia.  La iron√≠a es que dentro y fuera de nuestro m√©todo, el c√≥digo es completamente correcto.  En mi opini√≥n, este ejemplo no est√° fuera de mi cabeza, pero se encontr√≥ en alg√∫n lugar del c√≥digo comercial. <br><br>  Como resultado, si tiene la capacidad de enviar / recibir datos "limpios", no use transmisiones para esto, no cree trampas para quienes los usar√°n.  Si su aplicaci√≥n ya tiene flujos de transferencia / devoluci√≥n, analice su uso en funci√≥n de lo anterior. <br><br><h4>  4. Herencia de enumeraciones </h4><br>  Esta optimizaci√≥n es com√∫n, todos lo saben, incluso los estudiantes.  Pero desde mi experiencia, se usa extremadamente raramente.  Entonces, por defecto, enum hereda de int.  Sin embargo, se puede heredar del byte, que contiene 256 valores (u 8 valores "marcables").  Que casi siempre cubre la funcionalidad de la enumeraci√≥n "media".  Un cambio m√≠nimo en el c√≥digo y todos los valores de su enumeraci√≥n ocupan menos memoria para siempre.  A continuaci√≥n se muestra una ilustraci√≥n de un punto de referencia para llenar una colecci√≥n con valores enum heredados de int y byte. <br><br><img src="https://habrastorage.org/webt/e-/ir/q2/e-irq2g_r9iorxjbadfqyxuc9ei.png"><br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo de referencia</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CollectEnums</span></span> { [Params(<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>, <span class="hljs-number"><span class="hljs-number">100000</span></span>, <span class="hljs-number"><span class="hljs-number">1000000</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N; [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> EnumFromInt[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnumOfInt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { EnumFromInt[] results = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnumFromInt[N]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) { results[i] = EnumFromInt.Value1; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> results; } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> EnumFromByte[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnumOfByte</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { EnumFromByte[] results = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnumFromByte[N]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) { results[i] = EnumFromByte.Value1; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> results; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EnumFromInt { Value1, Value2 } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EnumFromByte: <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> { Value1, Value2 }</code> </pre> <br></div></div><br><h4>  5. Algunas palabras m√°s sobre las clases Array y List </h4><br>  Siguiendo la l√≥gica, iterar sobre una matriz siempre es m√°s eficiente que iterar sobre una "hoja", ya que una "hoja" es una envoltura sobre una matriz.  Adem√°s, siguiendo la l√≥gica, "for" es siempre m√°s r√°pido que "foreach", ya que "foreach" realiza muchas de las acciones requeridas por la implementaci√≥n de la interfaz IEnumerable.  Aqu√≠ todo es l√≥gico, ¬°pero est√° mal!  Echemos un vistazo a los resultados de referencia: <br><br><img src="https://habrastorage.org/webt/p7/7z/ih/p77zihj1drhzs84wcik9vtyq4qg.png"><br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo de referencia</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IterationBenchmark</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; _list; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] _array; [Params(<span class="hljs-number"><span class="hljs-number">100000</span></span>, <span class="hljs-number"><span class="hljs-number">10000000</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N; [GlobalSetup] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Setup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MIN = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MAX = <span class="hljs-number"><span class="hljs-number">10</span></span>; Random rnd = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); _list = Enumerable.Repeat(<span class="hljs-number"><span class="hljs-number">0</span></span>, N).Select(i =&gt; rnd.Next(MIN, MAX)).ToList(); _array = _list.ToArray(); } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _list.Count; i++) { total += _list[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total; } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForeachList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _list) { total += i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total; } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForeachArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _array) { total += i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total; } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _array.Length; i++) { total += _array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total; } }</code> </pre> <br></div></div><br>  El hecho es que para iterar sobre una matriz, "foreach" no utiliza una implementaci√≥n IEnumerable.  En este caso particular, se realiza la iteraci√≥n m√°s optimizada por √≠ndice, sin verificar fuera de los l√≠mites de la matriz, ya que la construcci√≥n "foreach" no funciona con √≠ndices, por lo que el desarrollador no tiene la opci√≥n de "desordenar" el c√≥digo.  Tal es la excepci√≥n a la regla.  Por lo tanto, si en alguna secci√≥n cr√≠tica del c√≥digo reemplaz√≥ el uso de "foreach" por "for" en aras de la optimizaci√≥n, se dispar√≥ en el pie.  Tenga en cuenta que esto <b>solo</b> es relevante <b>para las matrices</b> .  Hay varias ramas en StackOverflow donde se discute esta caracter√≠stica. <br><br><h4>  6. ¬øLa b√∫squeda en una tabla hash siempre est√° justificada? </h4><br>  Todos saben que las tablas hash son muy efectivas para la b√∫squeda.  Pero a menudo olvidan que el precio de una b√∫squeda r√°pida es una adici√≥n lenta a la tabla hash.  ¬øQu√© se sigue de esto?  Para que se justifique el uso de la tabla hash, es necesario que el n√∫mero de elementos de la tabla hash sea al menos 8 (aproximadamente).  Y para que el n√∫mero de operaciones de b√∫squeda fuera al menos un orden de magnitud mayor que el n√∫mero de operaciones de sumar.  De lo contrario, use una colecci√≥n m√°s simple.  La calidad de la funci√≥n hash har√° sus propios ajustes a la eficiencia, pero el significado de esto no cambiar√°.  En mi pr√°ctica, hubo un caso en el que el mayor cuello de botella en el c√≥digo cargado estaba llamando al m√©todo Dictionary.Add ().  La llave era una cuerda regular, de corta longitud.  Recordando esto y se convirti√≥ en un disparador para escribir este p√°rrafo.  Para ilustrar, un ejemplo de c√≥digo muy malo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numberStr</span></span></span><span class="hljs-function">)</span></span> { Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; dictionary = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; { {<span class="hljs-string"><span class="hljs-string">"One"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Two"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Three"</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} }; dictionary.TryGetValue(numberStr, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  Tal vez algo similar ocurre en su proyecto? <br><br><h4>  7. M√©todos de incrustaci√≥n </h4><br>  El c√≥digo se divide en m√©todos con mayor frecuencia por 2 razones.  Asegure la reutilizaci√≥n y descomposici√≥n del c√≥digo cuando una tarea se divide en varias subtareas.  Es m√°s f√°cil para una persona.  La alineaci√≥n es el proceso inverso de descomposici√≥n, es decir  el c√≥digo del m√©todo est√° incrustado en el lugar donde debe llamarse el m√©todo; como resultado, guardamos en la pila de llamadas y pasando par√°metros.  De ninguna manera recomiendo poner todo en un solo m√©todo.  Pero aquellos m√©todos que te√≥ricamente podr√≠amos "en l√≠nea" pueden marcarse con el atributo correspondiente: <br><br><pre> <code class="plaintext hljs">[MethodImpl(MethodImplOptions.AggressiveInlining)]</code> </pre> <br>  Este atributo le dir√° al sistema que este m√©todo puede integrarse.  Esto no significa que el m√©todo marcado con este atributo est√© necesariamente incorporado.  Por ejemplo, no es posible incrustar m√©todos recursivos o virtuales.  Tambi√©n vale la pena se√±alar que el mecanismo de inserci√≥n es extremadamente "delicado".  Hay muchas otras razones por las cuales el sistema se negar√° a incorporar su m√©todo.  Sin embargo, el equipo de Microsoft que trabaja en .NET Core est√° utilizando activamente este atributo.  El c√≥digo fuente de .NET Core tiene muchos ejemplos de su uso. <br><br><h4>  8. Capacidad estimada </h4><br>  Yo (y espero que la mayor√≠a de los desarrolladores tambi√©n) hayan desarrollado un reflejo: Inicialic√© la colecci√≥n, pens√© si es posible configurar Capacidad para ella.  Sin embargo, el n√∫mero exacto de elementos de colecci√≥n no siempre se conoce de antemano.  Pero esta no es una raz√≥n para ignorar este par√°metro.  Por ejemplo, si, hablando de cu√°ntos elementos habr√° en su colecci√≥n, asume un borroso "par de miles", esta es una ocasi√≥n para establecer Capacidad en 1000. Una peque√±a teor√≠a, por ejemplo, para Lista por defecto, Capacidad = 16, de modo que solo Al llegar a 1000, el sistema realizar√° 1008 (16 + 32 + 64 + 128 + 256 + 512) copias adicionales de los elementos y crear√° 7 matrices temporales para la pr√≥xima llamada del GC.  Es decir  todo este trabajo se desperdiciar√°.  Adem√°s, como Capacidad, nadie proh√≠be usar la f√≥rmula.  Si se estima que el tama√±o de su colecci√≥n es un tercio de la otra colecci√≥n, puede establecer la capacidad igual a otherCollection.Count / 3. Al configurar la capacidad, es bueno comprender el rango del tama√±o posible de la colecci√≥n y qu√© tan cerca se distribuye su valor.  Siempre existe la posibilidad de da√±o, pero si se usa correctamente, una capacidad estimada le dar√° una buena victoria. <br><br><h4>  9. Siempre especifique su c√≥digo. </h4><br>  Utilice activamente (a primera vista, opcional) palabras clave de C #, como: est√°tico, constante, de solo lectura, sellado, abstracto, etc.  Naturalmente, donde tienen sentido.  ¬øY aqu√≠ est√° el rendimiento?  El hecho es que cuanto m√°s detallado describa su sistema al compilador, m√°s √≥ptimo ser√° el c√≥digo que puede generar.  Un lector atento y experimentado puede notar que, por ejemplo, la palabra clave sellada no tiene ning√∫n efecto en el rendimiento.  Ahora esto es cierto, pero en futuras versiones todo puede cambiar.  ¬°Dale una oportunidad al compilador y a la m√°quina virtual!  Obtenga una bonificaci√≥n, identificando muchos errores de uso incorrecto de su c√≥digo en la etapa de compilaci√≥n.  Regla general: cuanto m√°s claramente se describe el sistema, m√°s √≥ptimo es el resultado.  Aparentemente, tambi√©n con personas. <br><br><div class="spoiler">  <b class="spoiler_title">La historia real confirma esta regla, pero si lees pereza, puedes saltarte</b> <div class="spoiler_text">  Una noche, mientras participaba en su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">proyecto de pasatiempo</a> , se propuso la tarea de aumentar el rendimiento de una secci√≥n de c√≥digo por encima de cierto nivel.  Pero este sitio era corto y hab√≠a pocas opciones sobre qu√© hacer con √©l.  En la documentaci√≥n encontr√© que, comenzando con la versi√≥n C # 7.2, la palabra clave "solo lectura" se puede usar para estructuras.  Y en mi caso, se utilizaron estructuras inmutables, al agregar una sola palabra "solo lectura" obtuve lo que quer√≠a, ¬°incluso con un margen!  El sistema, sabiendo que mis estructuras no est√°n destinadas a ser cambiadas, pudo generar un mejor c√≥digo para mi caso. <br></div></div><br><h4>  10. Si es posible, use una versi√≥n de .NET para todos los proyectos de Soluci√≥n </h4><br>  Debe esforzarse por asegurarse de que todos los ensamblados dentro de su aplicaci√≥n pertenezcan a la misma versi√≥n de .NET.  Esto se aplica tanto a los paquetes NuGet (editados en packages.config / json) como a sus propios ensamblajes (editados en las propiedades del Proyecto).  Esto ahorrar√° RAM y acelerar√° el inicio "en fr√≠o", ya que en la memoria de su aplicaci√≥n no habr√° copias de las mismas bibliotecas para diferentes versiones de .NET.  Vale la pena se√±alar que no en todos los casos, diferentes versiones de .NET generar√°n copias en la memoria.  Pero suponga que una aplicaci√≥n creada en la misma versi√≥n de .NET siempre es mejor.  Adem√°s, esto elimina una serie de problemas potenciales que est√°n fuera del alcance de este art√≠culo.  La consolidaci√≥n de versiones de todos los paquetes NuGet que use tambi√©n contribuir√° a mejorar el rendimiento de su aplicaci√≥n. <br><br><h4>  Algunas herramientas √∫tiles </h4><br>  <b>ILSpy</b> es una herramienta gratuita que le permite ver el c√≥digo fuente del ensamblado restaurado.  Si tengo una pregunta sobre qu√© mecanismo .NET es m√°s eficiente, en primer lugar, abro ILSpy (y no Google o StackOverflow), y ya veo c√≥mo se implementa.  Por ejemplo, para averiguar qu√© se utiliza mejor en t√©rminos de rendimiento para recibir datos a trav√©s de HTTP, la clase HttpWebRequest o WebClient, solo mire su implementaci√≥n a trav√©s de ILSpy.  En este caso particular, WebClient es un contenedor sobre HttpWebRequest, respectivamente, la respuesta es obvia.  No vale la pena temer los c√≥digos fuente .NET, est√°n escritos por los mismos programadores ordinarios. <br><br>  <b>BenchmarkDotNet</b> es una biblioteca gratuita de puntos de referencia.  Hay un cron√≥metro simple e intuitivo (de System.Diagnostics).  Pero a veces no es suficiente.  Dado que, en el buen sentido, es necesario tener en cuenta no un solo resultado, sino el promedio de varias comparaciones, es mejor comparar su mediana para minimizar la influencia del sistema operativo.  Adem√°s, debe tener en cuenta el "arranque en fr√≠o" y la cantidad de memoria asignada.  Para pruebas tan complejas, se cre√≥ BenchmarkDotNet.  Es esta biblioteca la que usan los desarrolladores de .NET Core en las pruebas oficiales.  La biblioteca es f√°cil de usar, pero si sus autores leen de repente esta publicaci√≥n, brinde una oportunidad m√°s conveniente para influir en la estructura de la tabla de resultados. <br><br>  <b>U2U Consult Performance Analyzers</b> es un complemento gratuito para Visual Studio que proporciona consejos para mejorar el c√≥digo en t√©rminos de rendimiento.  El 100% conf√≠a en los consejos de este analizador que no vale la pena.  Desde que me encontr√© con una situaci√≥n en la que un consejo me sorprendi√≥ un poco y despu√©s de un an√°lisis detallado, result√≥ ser err√≥neo.  Desafortunadamente, este ejemplo est√° perdido, as√≠ que tome una palabra.  Sin embargo, si lo usa con cuidado, es una herramienta muy √∫til.  Por ejemplo, sugerir√° que en lugar de <code>myStr.Replace("*", "-")</code> m√°s eficiente usar <code>myStr.Replace('*', '-')</code> .  Y las dos expresiones Where en LINQ se combinan mejor en una.  Todos estos son "optimizaci√≥n en coincidencias", pero son f√°ciles de aplicar y no conducen a un aumento en el c√≥digo / complejidad. <br><br><h4>  En conclusi√≥n </h4><br>  Si cada d√©cima persona que lee el art√≠culo aplica los enfoques anteriores a su proyecto actual (o una parte cr√≠tica del mismo), y tambi√©n se adhiere a estos enfoques en el futuro, ¬°juntos podemos salvar todo el bosque!  Bosque ???  Es decir  Los recursos ahorrados de los sistemas inform√°ticos, en forma de electricidad obtenida de la quema de madera, no se utilizar√°n.  En este caso, el "bosque" es solo una especie de equivalente.  Probablemente surgi√≥ una conclusi√≥n extra√±a, pero espero que te inspire el pensamiento. <br><br><h4>  Actualizaci√≥n de PS basada en comentarios de publicaciones </h4><br>  La ventaja de ToArray sobre ToList es relevante para .NET Core.  Pero si usa el antiguo .NET Framework, entonces ToList probablemente ser√° preferible para usted.  El problema es que en .NET Framework, la llamada ToArray en s√≠ es significativamente m√°s lenta que la llamada ToList.  Y estas p√©rdidas pueden no compensarse con accesos m√°s r√°pidos a los elementos y menos almacenamiento de matriz.  En general, este problema result√≥ ser m√°s complicado, ya que diferentes clases que implementan IEnumerable pueden tener diferentes implementaciones de ToArray y ToList, con diferentes niveles de eficiencia. <br><br>  Si la enumeraci√≥n heredada del byte se usa como miembro de una clase (estructura), y no por separado, es posible que no haya ning√∫n ahorro de memoria.  Debido a la alineaci√≥n de la memoria ocupada de todos los miembros de la clase (estructura).  Este punto falta en el art√≠culo.  Sin embargo, la ganancia potencial es mejor que su ausencia, ya que adem√°s de la memoria ocupada, tambi√©n se usan enum.  Por lo tanto, el p√°rrafo 4 sigue siendo relevante, pero con esta importante reserva. <br><br>  Gracias a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">KvanTTT</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">epetrukhin</a> por sus comentarios constructivos sobre estos temas. <br><br>  Adem√°s, como se√±al√≥ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Taritsyn</a> , la optimizaci√≥n en la etapa de compilaci√≥n JIT para la palabra clave "sellada" todav√≠a existe.  Pero, esto solo confirma todas las tesis del noveno p√°rrafo. <br><br>  Parece que todos los comentarios constructivos se han tenido en cuenta.  Estoy muy satisfecho con estos comentarios.  Como yo, como autor, recib√≠ un comentario y tambi√©n aprend√≠ algo nuevo para m√≠. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/466931/">https://habr.com/ru/post/466931/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../466917/index.html">Cuando el est√°ndar HTTP no es suficiente. Micronaut commit</a></li>
<li><a href="../466921/index.html">5 problemas de cualquier empresa de servicios y su soluci√≥n utilizando la plataforma de automatizaci√≥n</a></li>
<li><a href="../466923/index.html">C√≥mo profesionales de TI en un banco extranjero para probar el origen de los fondos</a></li>
<li><a href="../466925/index.html">C√≥mo ejecutar VDS Hi-CPU para Bitrix, dispersar loros y no quebrar</a></li>
<li><a href="../466929/index.html">Agregar token de actualizaci√≥n</a></li>
<li><a href="../466933/index.html">C√≥mo hacer amigos industria y big data</a></li>
<li><a href="../466937/index.html">C√≥mo hacemos la Olimpiada en l√≠nea de toda Rusia en ingl√©s, matem√°ticas y ciencias de la computaci√≥n</a></li>
<li><a href="../466941/index.html">¬øPor qu√© Windows lee un archivo cien mil veces para abrir un men√∫?</a></li>
<li><a href="../466949/index.html">Perspectivas para las redes cu√°nticas: qui√©n participa en ellas y por qu√©</a></li>
<li><a href="../466955/index.html">Adivinanzas del curr√≠culum. Parte 3. El velo de los secretos quitados</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>