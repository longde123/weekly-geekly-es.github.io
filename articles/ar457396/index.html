<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤙 🕵🏽 ⚰️ إلغاء تأمين حاوية LUKS الجذرية تلقائيًا بعد التمهيد السريع 🚳 🌠 🚕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="لماذا يقوم الناس عمومًا بتشفير محركات أقراص أجهزة الكمبيوتر الشخصية ، وأحيانًا الخوادم؟ من الواضح أن لا أحد سرق صور القطط الأليفة المفضلة لديهم من الق...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>إلغاء تأمين حاوية LUKS الجذرية تلقائيًا بعد التمهيد السريع</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457396/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  لماذا يقوم الناس عمومًا بتشفير محركات أقراص أجهزة الكمبيوتر الشخصية ، وأحيانًا الخوادم؟  من الواضح أن لا أحد سرق صور القطط الأليفة المفضلة لديهم من القرص!  هذا مجرد سوء حظ: محرك الأقراص المشفر يتطلب منك إدخال عبارة رئيسية من لوحة المفاتيح في كل تمهيد ، وهي طويلة ومملة.  لإزالته حتى في بعض الأحيان على الأقل لن يكون من الضروري تجنيده.  نعم ، حتى لا يضيع معنى التشفير. </p><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">القط للاهتمام</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/sr/rt/ny/srrtnywyggbrscsufm8ux8tvxmu.jpeg" alt="مايك فارلي"></p></div></div><br><p style=";text-align:right;direction:rtl">  حسنا ، إزالته تماما لن تعمل.  يمكنك بدلاً من ذلك إنشاء ملف مفتاح على محرك أقراص فلاش USB ، وسيعمل أيضًا.  وبدون محرك أقراص فلاش (وبدون كمبيوتر آخر على الشبكة) هل من الممكن؟  إذا كنت محظوظًا مع BIOS ، فيمكنك تقريبًا!  تحت القص سيكون دليل حول كيفية تكوين تشفير القرص من خلال LUKS مع الخصائص التالية: </p><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> لا يتم تخزين عبارة المرور أو ملف المفتاح في أي مكان في شكل مفتوح (أو في النموذج المكافئ لفتح) عند إيقاف تشغيل الكمبيوتر. </li><li style=";text-align:right;direction:rtl">  عند تشغيل الكمبيوتر لأول مرة ، يجب إدخال عبارة مرور. </li><li style=";text-align:right;direction:rtl">  في عمليات إعادة التمهيد اللاحقة (قبل إيقاف التشغيل) ، لا يلزم استخدام عبارة مرور. </li></ol><br><p style=";text-align:right;direction:rtl">  تم اختبار التعليمات على CentOS 7.6 و Ubuntu 19.04 و openSUSE Leap 15.1 في الأجهزة الافتراضية والأجهزة الحقيقية (سطح المكتب والكمبيوتر المحمول وخادمان).  يجب أن تعمل على التوزيعات الأخرى التي لديها إصدار عمل من Dracut. </p><br><p style=";text-align:right;direction:rtl">  ونعم ، بطريقة جيدة ، كان يجب أن ينتهي هذا في محور "إدارة النظام غير الطبيعي" ، ولكن لا يوجد مثل هذا المحور. </p><a name="habracut"></a><br><p style=";text-align:right;direction:rtl">  أقترح استخدام فتحة منفصلة في حاوية LUKS وتخزين المفتاح إليها ... في RAM! </p><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">أي نوع من الفتحة؟</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl"> حاوية LUKS تنفذ التشفير متعدد المستويات.  يتم تشفير البيانات المفيدة الموجودة على القرص باستخدام تشفير متماثل ، عادةً <code>aes-xts-plain64</code> .  يتم إنشاء مفتاح هذا التشفير المتماثل (المفتاح الرئيسي) في مرحلة إنشاء الحاوية كتسلسل عشوائي للبايت.  يتم تخزين المفتاح الرئيسي في شكل مشفر ، في الحالة العامة - في عدة نسخ (فتحات).  بشكل افتراضي ، واحدة فقط من فتحات الثمانية نشطة.  تحتوي كل فتحة نشطة على عبارة مفتاح منفصلة (أو ملف مفتاح منفصل) ، حيث يمكنك فك تشفير المفتاح الرئيسي.  من وجهة نظر المستخدم ، اتضح أنه يمكنك فتح محرك الأقراص باستخدام أي من عدة عبارات رئيسية مختلفة (أو ملفات المفاتيح).  في حالتنا ، استخدام عبارة رئيسية (الفتحة 0) أو استخدام قطعة من الذاكرة تستخدم كملف مفتاح (الفتحة 6). </p></div></div><br><p style=";text-align:right;direction:rtl">  لا يقوم BIOS في معظم اللوحات الأم بتنظيف الذاكرة عند إعادة التشغيل ، أو يمكنك تكوينه بحيث لا يتم تنظيفه (استثناء معروف: "Intel Corporation S1200SP / S1200SP ، BIOS S1200SP.86B.03.01.0042.013020190050 01/30/2019").  لذلك ، يمكنك تخزين المفتاح هناك.  عند إيقاف تشغيل الطاقة ، يتم مسح محتويات ذاكرة الوصول العشوائي نفسها بعد فترة من الوقت ، بالإضافة إلى نسخة غير محمية من المفتاح. </p><br><p style=";text-align:right;direction:rtl">  لذلك دعونا نذهب. </p><br><h3 id="shag-pervyy-ustanovit-sistemu-na-zashifrovannyy-s-pomoschyu-luks-disk" style=";text-align:right;direction:rtl">  الخطوة الأولى: تثبيت النظام على قرص مشفر باستخدام LUKS </h3><br><p style=";text-align:right;direction:rtl">  في هذه الحالة ، يجب أن يظل قسم القرص (على سبيل المثال ، <code>/dev/sda1</code> ) المثبت في <code>/boot</code> غير مشفر ، <code>/dev/sda2</code> يجب تشفير كل شيء آخر عليه (على سبيل المثال ، <code>/dev/sda2</code> ).  يمكن أن يكون نظام الملفات الموجود على القسم المشفر أيًا ، ويمكنك أيضًا استخدام LVM بحيث يكون نظام الملفات الجذر ووحدة التخزين للتبادل وكل شيء آخر باستثناء <code>/boot</code> في الحاوية نفسها.  هذا يتوافق مع تقسيم القرص الافتراضي في CentOS 7 و Debian عند اختيار خيار التشفير.  SUSE يفعل كل شيء بشكل مختلف (تشفير <code>/boot</code> ) وبالتالي يتطلب التقسيم اليدوي للقرص. </p><br><p style=";text-align:right;direction:rtl">  يجب أن تكون النتيجة كما يلي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">$ lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 10G 0 disk ├─sda1 8:1 0 1G 0 part /boot └─sda2 8:2 0 9G 0 part └─luks-d07a97d7-3258-408c-a17c-e2fb56701c69 253:0 0 9G 0 crypt ├─centos_centos--encrypt2-root 253:1 0 8G 0 lvm / └─centos_centos--encrypt2-swap 253:2 0 1G 0 lvm [SWAP]</code> </pre> <br><p style=";text-align:right;direction:rtl">  في حالة استخدام UEFI ، سيكون هناك أيضًا قسم نظام EFI. </p><br><blockquote style=";text-align:right;direction:rtl">  لمستخدمي Debian و Ubuntu: <code>initramfs-tools</code> حزمة <code>initramfs-tools</code> <code>dracut</code> . <br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># apt install --no-install-recommends dracut</code> </pre> <br><br>  <code>initramfs-tools</code> منطقًا غير صحيح في حالتنا ، يتم تطبيقه على الأقسام المشفرة باستخدام ملف مفتاح.  يتم تجاهل مثل هذه الأقسام تمامًا ، أو يتم نسخ محتويات ملف المفتاح إلى initramfs (أي كنتيجة لذلك ، على القرص) بشكل واضح ، وهو ما لا نحتاج إليه. </blockquote><br><h3 id="shag-vtoroy-sozdat-klyuchevoy-fayl-kotoryy-budet-ispolzovatsya-dlya-avtomaticheskogo-razblokirovaniya-diska-posle-goryachey-perezagruzki" style=";text-align:right;direction:rtl">  الخطوة الثانية: قم بإنشاء ملف مفتاح ليتم استخدامه لإلغاء تأمين محرك الأقراص تلقائيًا بعد إعادة التشغيل السريع </h3><br><p style=";text-align:right;direction:rtl">  128 بت عشوائية كافية بالنسبة لنا ، أي  16 بايت.  سيتم تخزين الملف على قرص مشفر ، لذلك لن يقرأه أي شخص لا يعرف مفتاح التشفير ولا يملك حق الوصول الجذر إلى النظام الذي تم تحميله. </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># touch -m 0600 /root/key # head -c16 /dev/urandom &gt; /root/key</code> </pre> <br><p style=";text-align:right;direction:rtl">  يوجد ما يكفي من البتات العشوائية في ملف المفتاح بحيث لا تكون هناك حاجة إلى خوارزمية PBKDF البطيئة ، والتي تصنع مفتاح تشفير يصعب اختياره من عبارة مفتاح ضعيفة محتملة.  لذلك ، عند إضافة مفتاح ، يمكنك تقليل عدد التكرارات: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># cryptsetup luksAddKey --key-slot=6 --iter-time=1 /dev/sda2 /root/key Enter any existing passphrase:</code> </pre> <br><p style=";text-align:right;direction:rtl">  كما ترون ، يتم تخزين ملف المفتاح على قرص مشفر وبالتالي لا يشكل أي خطر على الأمان في حالة إيقاف تشغيل الكمبيوتر. </p><br><h3 id="shag-tretiy-vydelit-mesto-v-fizicheskoy-pamyati-dlya-hraneniya-klyucha" style=";text-align:right;direction:rtl">  الخطوة الثالثة: تخصيص مساحة في الذاكرة الفعلية لتخزين المفتاح </h3><br><p style=";text-align:right;direction:rtl">  يحتوي Linux على ثلاثة برامج تشغيل مختلفة على الأقل تتيح لك الوصول إلى الذاكرة الفعلية في عنوان معروف.  هذا هو <code>linux/drivers/char/mem.c</code> ، وهو مسؤول أيضًا عن الجهاز <code>/dev/mem</code> ، بالإضافة إلى وحدات <code>phram</code> (تحاكي شريحة MTD ، ويعطي الجهاز <code>/dev/mtd0</code> ) و <code>nd_e820</code> (يستخدم عند العمل مع NVDIMM ، ويعطي <code>/dev/pmem0</code> ).  لديهم جميع ميزاتها غير السارة: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <code>/dev/mem</code> قابل للكتابة عند استخدام Secure Boot ، إذا كانت <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مجموعة</a> التوزيع <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تستخدم مجموعة تصحيح LOCKDOWN</a> من Matthew Garrett (وتكون مجموعة التصحيح هذه مطلوبة إذا كان التوزيع سيدعم Secure Boot مع أداة تحميل bootloaded موقعة من قبل Microsoft) ؛ </li><li style=";text-align:right;direction:rtl">  <code>phram</code> متاح على CentOS و Fedora - لم يقم <code>phram</code> ببساطة بتمكين الخيار المقابل عند إنشاء النواة ؛ </li><li style=";text-align:right;direction:rtl">  يحتاج <code>nd_e820</code> إلى حجز 128 ميجابايت على الأقل من الذاكرة - هكذا يعمل NVDIMM.  ولكن هذا هو الخيار الوحيد الذي يعمل على CentOS مع Secure Boot. </li></ul><br><p style=";text-align:right;direction:rtl">  نظرًا لعدم وجود خيار مثالي ، يتم النظر في العناصر الثلاثة أدناه. </p><br><blockquote style=";text-align:right;direction:rtl">  عند استخدام أي من الطرق ، يلزم توخي الحذر الشديد حتى لا تؤثر بشكل غير مقصود على الأجهزة أو نطاقات الذاكرة بخلاف ما هو مطلوب.  ينطبق هذا بشكل خاص على أجهزة الكمبيوتر التي تحتوي بالفعل على شرائح MTD أو وحدات NVDIMM.  وهي <code>/dev/mtd0</code> أو <code>/dev/pmem0</code> قد لا يكون الجهاز الذي يتوافق مع مساحة الذاكرة المخصصة لتخزين المفتاح.  قد يتم الخلط بين ترقيم الأجهزة الموجودة ، والتي تعتمد عليها ملفات التكوين والبرامج النصية.  وفقًا لذلك ، يوصى بتعطيل جميع الخدمات التي تعتمد على الأجهزة الحالية <code>/dev/mtd*</code> و <code>/dev/pmem*</code> . </blockquote><p style=";text-align:right;direction:rtl">  يتم <code>memmap</code> من الذاكرة الفعلية لنظام Linux بتمرير خيار <code>memmap</code> إلى <code>memmap</code> .  نحن مهتمون بنوعين من هذا الخيار: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <code>memmap=4K$0x10000000</code> احتياطي <code>memmap=4K$0x10000000</code> (بمعنى ، العلامات المحجوزة بحيث لا يستخدم kernel نفسه) 4 كيلو بايت من الذاكرة ، بدءًا من العنوان الفعلي 0x10000000 ؛ </li><li style=";text-align:right;direction:rtl">  <code>memmap=128M!0x10000000</code> يصور 128 ميغابايت من الذاكرة الفعلية ، بدءًا من العنوان 0x10000000 ، مثل NVDIMM (من الواضح أنها مزيفة ، ولكنها ستفعل بالنسبة لنا). </li></ul><br><p style=";text-align:right;direction:rtl">  الخيار c <code>$</code> مناسب للاستخدام مع <code>/dev/mem</code> و <code>phram</code> ، الخيار c <code>!</code>  - ل <code>nd_e820</code> .  عند استخدام <code>$</code> يجب أن يكون عنوان البداية للذاكرة المحجوزة مضاعفات <code>0x1000</code> (أي 4 كيلو بايت) ، عند استخدام <code>!</code>  - مضاعفات <code>0x8000000</code> (أي 128 ميجابايت). </p><br><p style=";text-align:right;direction:rtl">  هام: علامة الدولار ( <code>$</code> ) في ملفات تكوين GRUB هي شخصية خاصة ويجب الهروب منها.  <code>grub.cfg</code> : مرة واحدة - عند <code>grub.cfg</code> من <code>/etc/default/grub</code> ، مرة ثانية - عند تفسير ملف التكوين الناتج في مرحلة التمهيد.  أي  في <code>/etc/default/grub</code> ، يجب أن يظهر السطر التالي في النهاية: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">GRUB_CMDLINE_LINUX="memmap=4K\\\$0x10000000 ...  ..."</code> </pre> <br><p style=";text-align:right;direction:rtl">  بدون تجاوز ضعف علامة <code>$</code> ، لن يقوم النظام ببساطة بالتمهيد ، حيث يعتقد أن لديه 4 كيلوبايت فقط من الذاكرة.  لا توجد مثل هذه الصعوبات في علامة التعجب: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">GRUB_CMDLINE_LINUX="memmap=128M!0x10000000 ...  ..."</code> </pre> <br><p style=";text-align:right;direction:rtl">  يمكن الوصول إلى بطاقة الذاكرة الفعلية (والمطلوبة لمعرفة العناوين التي يجب <code>/proc/iomem</code> <code>root</code> في <code>/proc/iomem</code> الزائف <code>/proc/iomem</code> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># cat /proc/iomem ... 000f0000-000fffff : reserved 000f0000-000fffff : System ROM 00100000-7ffddfff : System RAM 2b000000-350fffff : Crash kernel 73a00000-7417c25e : Kernel code 7417c25f-747661ff : Kernel data 74945000-74c50fff : Kernel bss 7ffde000-7fffffff : reserved 80000000-febfffff : PCI Bus 0000:00 fd000000-fdffffff : 0000:00:02.0 ...</code> </pre> <br><p style=";text-align:right;direction:rtl">  تم وضع علامة على ذاكرة الوصول العشوائي باسم "ذاكرة الوصول العشوائي للنظام" ، وهو ما يكفي بالنسبة لنا لحجز إحدى صفحاتها لتخزين المفتاح.  إن تخمين أي جزء من ذاكرة BIOS لا يمس عند إعادة التشغيل لن يعمل بشكل موثوق مسبقًا.  ما لم يكن هناك كمبيوتر آخر بنفس إصدار BIOS تمامًا وبنفس تكوين الذاكرة الذي تم بالفعل استكمال هذا الدليل عليه.  لذلك ، في الحالة العامة ، سيكون عليك التصرف عن طريق التجربة والخطأ.  كقاعدة عامة ، عند إعادة تشغيل BIOS ، فإنه يغير البيانات فقط في بداية ونهاية كل نطاق الذاكرة.  عادة ما يكون كافياً التراجع 128 ميغابايت ( <code>0x8000000</code> ) من الحواف.  بالنسبة إلى الأجهزة الافتراضية KVM ذات 1 جيجابايت من الذاكرة أو أكثر ، تعمل الخيارات المقترحة ( <code>memmap=4K$0x10000000</code> و <code>memmap=128M!0x10000000</code> ). </p><br><p style=";text-align:right;direction:rtl">  عند استخدام وحدة <code>phram</code> ، <code>phram</code> إلى معلمة سطر أوامر kernel أخرى ، والتي في الواقع ، تخبر الوحدة النمطية أي جزء من الذاكرة الفعلية لاستخدامها - خاصتنا ، محفوظة.  تسمى المعلمة <code>phram.phram</code> وتحتوي على ثلاثة أجزاء: الاسم (التعسفي حتى 63 حرفًا ، سيكون مرئيًا في <code>sysfs</code> ) ، وعنوان البدء والطول.  يجب أن يكون عنوان البداية والطول هو نفسه كما هو الحال في <code>memmap</code> ، لكن اللاحقات <code>K</code> و <code>M</code> غير مدعومة. </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">GRUB_CMDLINE_LINUX="memmap=4K\\\$0x10000000 phram.phram=savedkey,0x10000000,4096 ..."</code> </pre> <br><p style=";text-align:right;direction:rtl">  بعد التحرير <code>/etc/default/grub</code> تحتاج إلى إعادة إنشاء ملف التكوين الحقيقي الذي يقرأه GRUB عند التمهيد.  الأمر الصحيح لهذا يعتمد على التوزيع. </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># grub2-mkconfig -o /boot/grub2/grub.cfg # CentOS (Legacy BIOS) # grub2-mkconfig -o /boot/efi/EFI/centos/grub.cfg # CentOS (UEFI) # update-grub # Debian, Ubuntu # update-bootloader --reinit # SUSE</code> </pre> <br><p style=";text-align:right;direction:rtl">  بعد تحديث تكوين GRUB ، يجب إعادة تشغيل الكمبيوتر ، لكننا سنقوم بذلك لاحقًا عندما نقوم بتحديث initramfs. </p><br><h3 id="shag-chetvertyy-nastroit-luks-na-chtenie-klyucha-iz-pamyati" style=";text-align:right;direction:rtl">  الخطوة الرابعة: تكوين LUKS لقراءة المفتاح من الذاكرة </h3><br><p style=";text-align:right;direction:rtl">  يتم تخزين إعدادات تشفير <code>/etc/crypttab</code> في ملف <code>/etc/crypttab</code> .  يتكون كل صف من أربعة حقول: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  الجهاز الذي يجب الحصول عليه عند فتح ، </li><li style=";text-align:right;direction:rtl">  جهاز مشفر </li><li style=";text-align:right;direction:rtl">  أين يمكن الحصول على ملف المفتاح ( <code>none</code> يعني إدخال عبارة رئيسية من لوحة المفاتيح) ، </li><li style=";text-align:right;direction:rtl">  حقل اختياري للخيارات. </li></ul><br><p style=";text-align:right;direction:rtl">  إذا كان ملف المفتاح موجودًا ولكنه غير مناسب ، يسأل Dracut عن العبارة الرئيسية.  والتي ، في الواقع ، سوف تكون مطلوبة في التمهيد الأول. </p><br><p style=";text-align:right;direction:rtl">  مثال على ملف <code>/etc/crypttab</code> من توزيع تم تثبيته حديثًا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># cat /etc/crypttab #   luks-d07....69 UUID=d07....69 none</code> </pre> <br><p style=";text-align:right;direction:rtl">  سيكون الملف الرئيسي في حالتنا قطعة من الذاكرة الفعلية.  أي  <code>/dev/mem</code> ، <code>/dev/mtd0</code> أو <code>/dev/pmem0</code> ، اعتمادًا على تقنية الوصول إلى الذاكرة المحددة.  هناك حاجة إلى خيارات للإشارة إلى أي جزء من الملف هو المفتاح. </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># cat /etc/crypttab #   #   /dev/mem: luks-d07....69 UUID=d07....69 /dev/mem keyfile-offset=0x10000000,keyfile-size=16 #   phram: luks-d07....69 UUID=d07....69 /dev/mtd0 keyfile-size=16 #   nd_e820: luks-d07....69 UUID=d07....69 /dev/pmem0 keyfile-size=16</code> </pre> <br><p style=";text-align:right;direction:rtl">  هذا فقط لن ينجح هكذا. </p><br><p style=";text-align:right;direction:rtl">  النقطة المهمة هي كيف يحدد systemd متى يمكن إلغاء قفل الجهاز.  وهو يأخذ الجهاز من العمود الثالث وينتظر أن تصبح وحدة الجهاز المقابلة نشطة.  يبدو منطقيًا: من غير المنطقي محاولة فتح قفل حاوية LUKS حتى يظهر جهاز به ملف مفتاح.  لكن وحدة الجهاز ليست هي نفسها الجهاز نفسه.  يقوم Systemd افتراضيًا بإنشاء وحدات الجهاز فقط لأجهزة kernel المتعلقة بالنظم الفرعية لأجهزة الكتلة وواجهات الشبكة.  تعد الأجهزة <code>/dev/mem</code> و <code>/dev/mtd0</code> حرفًا تلو الآخر ، وبالتالي لا يتم مراقبتها افتراضيًا ولن يتم التعرف عليها على أنها جاهزة أبدًا. </p><br><p style=";text-align:right;direction:rtl">  سيكون عليك إخبار systemd أنه يجب عليه تتبعها عن طريق إنشاء قواعد udev في ملف <code>/etc/udev/rules.d/99-mem.rules</code> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># /dev/mem KERNEL=="mem", TAG+="systemd" # /dev/mtd* KERNEL=="mtd*", TAG+="systemd" #  /dev/pmem*      </code> </pre> <br><h3 id="shag-pyatyy-peregenerirovat-initramfs" style=";text-align:right;direction:rtl">  الخطوة الخامسة: تجديد initramfs </h3><br><blockquote style=";text-align:right;direction:rtl">  أذكركم: هذا المقال يناقش التوزيعات فقط باستخدام Dracut.  بما في ذلك تلك التي لا يتم استخدامها بشكل افتراضي ، ولكن يمكن الوصول إليها وفعالة. </blockquote><p style=";text-align:right;direction:rtl">  تحتاج إلى تجديد initramfs من أجل تحديث الملف <code>/etc/crypttab</code> هناك.  وأيضا - لتشمل وحدات نواة إضافية وقواعد udev هناك.  وإلا ، فلن يتم إنشاء الجهاز <code>/dev/mtd0</code> أو <code>/dev/pmem0</code> .  تعتبر معلمة التكوين <code>force_drivers</code> مسؤولة عن تمكين وحدات kernel الإضافية وتحميلها ، وتكون <code>install_items</code> مسؤولة عن الملفات الإضافية.  نقوم بإنشاء الملف <code>/etc/dracut.conf.d/mem.conf</code> التالية (مسافة بعد علامة اقتباس الفتح مطلوبة ، هذا فاصل): </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">#   /dev/mem: install_items+=" /etc/udev/rules.d/99-mem.rules" #   phram: install_items+=" /etc/udev/rules.d/99-mem.rules" force_drivers+=" phram" #   nd_e820: force_drivers+=" nd_e820 nd_pmem"</code> </pre> <br><p style=";text-align:right;direction:rtl">  في الواقع تجديد initramfs: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># dracut -f</code> </pre> <br><blockquote style=";text-align:right;direction:rtl">  بالنسبة لمستخدمي Debian و Ubuntu ، قام المشرف بوضع أشعل النار: يسمى الملف الناتج بشكل غير صحيح.  تحتاج إلى إعادة تسميته بحيث يتم تسميته بنفس الطريقة الموضحة في تكوين GRUB: <br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># mv /boot/initramfs-5.0.0-19-generic.img /boot/initrd.img-5.0.0-19-generic</code> </pre> <br><br>  عند تثبيت حبات جديدة ، يتم التنفيذ التلقائي للرابطات عبر Dracut بشكل صحيح ، يؤثر الخطأ فقط على الإطلاق اليدوي لل <code>dracut -f</code> . </blockquote><br><h3 id="shag-shestoy-perezagruzit-kompyuter" style=";text-align:right;direction:rtl">  الخطوة السادسة: أعد تشغيل الكمبيوتر </h3><br><p style=";text-align:right;direction:rtl">  هناك حاجة إلى إعادة التشغيل لتصبح التغييرات نافذة المفعول على GRUB و Dracut. </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># reboot</code> </pre> <br><p style=";text-align:right;direction:rtl">  في هذه المرحلة ، لا يوجد مفتاح في الذاكرة ، لذلك ستحتاج إلى إدخال عبارة مرور. </p><br><p style=";text-align:right;direction:rtl">  بعد إعادة التشغيل ، تحتاج إلى التحقق من عمل نسخة احتياطية للذاكرة بشكل صحيح.  كحد أدنى ، في <code>/proc/iomem</code> الزائف <code>/proc/iomem</code> يجب تمييز موقع الذاكرة المرغوب فيه على أنه "محجوز" (عند استخدام <code>/dev/mem</code> أو <code>phram</code> ) أو "الذاكرة الدائمة (إرث)". </p><br><p style=";text-align:right;direction:rtl">  عند استخدام <code>phram</code> أو <code>nd_e820</code> تحتاج إلى التأكد من أن الجهاز <code>/dev/mtd0</code> أو <code>/dev/pmem0</code> يشير فعليًا إلى الجزء <code>/dev/pmem0</code> مسبقًا من الذاكرة ، وليس إلى شيء آخر. </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># cat /sys/class/mtd/mtd0/name #  : "savedkey" # cat /sys/block/pmem0/device/resource #    </code> </pre> <br><p style=";text-align:right;direction:rtl">  إذا لم يكن الأمر كذلك ، فأنت بحاجة إلى العثور على أي من الأجهزة <code>/dev/mtd*</code> أو <code>/dev/pmem*</code> "خاصتنا" ، ثم إصلاح / etc / crypttab ، وتجديد initramfs وإعادة التحقق من النتيجة بعد إعادة تشغيل أخرى. </p><br><h3 id="shag-sedmoy-nastroit-kopirovanie-klyuchevogo-fayla-v-pamyat" style=";text-align:right;direction:rtl">  الخطوة السابعة: تكوين نسخ ملف المفتاح إلى الذاكرة </h3><br><p style=";text-align:right;direction:rtl">  سيتم نسخ ملف المفتاح إلى الذاكرة قبل إعادة التشغيل.  إحدى الطرق لتشغيل أي أمر في مرحلة إيقاف تشغيل النظام هي تسجيله في توجيه <code>ExecStop</code> في خدمة systemd.  لكي يفهم systemd أن هذا ليس برنامجًا <code>ExecStart</code> ولا يقسم على عدم وجود توجيه <code>ExecStart</code> ، فأنت بحاجة إلى تحديد نوع الخدمة كصورة <code>oneshot</code> أيضًا إلى أن الخدمة تعتبر قيد التشغيل ، حتى إذا لم تكن هناك عملية تشغيل مرتبطة بها.  لذلك ، <code>/etc/systemd/system/savekey.service</code> ملف <code>/etc/systemd/system/savekey.service</code> .  من الضروري ترك واحد فقط من المتغيرات المعطاة في توجيه <code>ExecStop</code> . </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">[Unit] Description=Saving LUKS key into RAM Documentation=https://habr.com/ru/post/457396/ [Service] Type=oneshot RemainAfterExit=true #   /dev/mem: ExecStop=/bin/sh -c 'dd if=/root/key of=/dev/mem bs=1 seek=$((0x10000000))' #   /dev/mtd0: ExecStop=/bin/dd if=/root/key of=/dev/mtd0 #   /dev/pmem0: ExecStop=/bin/dd if=/root/key of=/dev/pmem0 [Install] WantedBy=default.target</code> </pre> <br><p style=";text-align:right;direction:rtl">  هناك حاجة إلى البناء مع <code>/bin/sh</code> لأن <code>dd</code> لا يفهم الترميز السداسي عشري. </p><br><p style=";text-align:right;direction:rtl">  نقوم بتنشيط الخدمة ، تحقق: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># systemctl enable savekey # systemctl start savekey # reboot</code> </pre> <br><p style=";text-align:right;direction:rtl">  أثناء إعادة التشغيل اللاحقة ، لا يلزم إدخال عبارة المرور من القرص.  وإذا لزم الأمر ، فهذا يعني عادةً أن عنوان البدء الخاص بمنطقة الذاكرة المحجوزة محدد بشكل غير صحيح.  لا بأس في إصلاح وتجديد العديد من الملفات وإعادة تشغيل الكمبيوتر مرتين. </p><br><p style=";text-align:right;direction:rtl">  عند استخدام <code>phram</code> أو <code>nd_e820</code> تعديل تكوين GRUB فقط.  عند استخدام <code>/dev/mem</code> يتم ذكر عنوان البداية أيضًا في <code>/etc/crypttab</code> (وبالتالي ، يجب إعادة إنشاء initramfs) وفي خدمة systemd. </p><br><p style=";text-align:right;direction:rtl">  لكن هذا ليس كل شيء. </p><br><h3 id="voprosy-bezopasnosti" style=";text-align:right;direction:rtl">  قضايا الأمن </h3><br><p style=";text-align:right;direction:rtl">  تستند أي مناقشة لقضايا الأمن إلى نموذج تهديد.  أي  على أهداف ووسائل المهاجم.  أدرك أن بعض الأمثلة أدناه بعيدة المنال. </p><br><p style=";text-align:right;direction:rtl">  لا تختلف المواقف مع الوصول الفعلي إلى جهاز الكمبيوتر الذي تم إيقاف تشغيله عن تلك التي لا تحتوي على تخزين مفتاح مكوّن في الذاكرة.  هناك نفس أنواع الهجمات التي تهدف إلى الحصول على عبارات رئيسية ، بما في ذلك <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Evil Maid</a> ، ونفس <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ميزات الأمان</a> .  نحن لا نتوقف عندهم ، لأنه لا يوجد شيء جديد. </p><br><p style=";text-align:right;direction:rtl">  مواقف أكثر إثارة للاهتمام عندما يتم تشغيل الكمبيوتر. </p><br><p style=";text-align:right;direction:rtl">  <strong>الوضع 1</strong> .  لا يملك المهاجم إمكانية الوصول الفعلي إلى الكمبيوتر ، ولا يعرف عبارة المرور ، ولكن لديه حق الوصول إلى الجذر عبر ssh.  الهدف هو المفتاح لفك تشفير القرص.  على سبيل المثال ، للوصول إلى النسخ الاحتياطية القديمة لكل قطاع لصورة قرص الجهاز الظاهري. </p><br><p style=";text-align:right;direction:rtl">  في الواقع ، المفتاح في الصحن موجود في ملف <code>/root/key</code> الملف.  والسؤال هو كيف يرتبط هذا بما حدث قبل تنفيذ هذه التعليمات.  الإجابة: بالنسبة إلى luks1 ، التهديد ليس جديدًا.  هناك <code>dmsetup table --target crypt --showkeys</code> الذي يظهر المفتاح الرئيسي ، أي  أيضا البيانات التي تسمح بالوصول إلى النسخ الاحتياطية القديمة.  بالنسبة إلى luks2 ، يحدث تخفيض الأمان في هذا السيناريو بالفعل: يتم تخزين مفاتيح dm-crypt في سلسلة المفاتيح على مستوى kernel ، ومن المستحيل أن ننظر إليها من مساحة المستخدمين. </p><br><p style=";text-align:right;direction:rtl">  <strong>الوضع 2</strong> .  يمكن للمهاجم استخدام لوحة المفاتيح والنظر إلى الشاشة ، لكنه غير جاهز لفتح العلبة.  على سبيل المثال ، استخدمت كلمة المرور المسربة من IPMI أو اعترضت جلسة noVNC في السحابة.  إنه لا يعرف العبارة الأساسية ، ولا يعرف أي كلمات مرور أخرى أيضًا.  الهدف هو الوصول إلى الجذر. </p><br><p style=";text-align:right;direction:rtl">  يرجى: إعادة التشغيل عبر <code>Ctrl-Alt-Del</code> ، مع إضافة خيار kernel <code>init=/bin/sh</code> عبر GRUB.  لم تكن كلمة المرور مطلوبة ، حيث تمت قراءة المفتاح بنجاح من الذاكرة.  لحماية نفسك من هذا ، يجب عليك منع GRUB من تحميل ما هو غير موجود في القائمة.  لسوء الحظ ، يتم تنفيذ هذه الوظيفة بشكل مختلف في توزيعات مختلفة. </p><br><p style=";text-align:right;direction:rtl">  بدءًا من الإصدار 7.2 ، يحتوي CentOS على <code>grub2-setpassword</code> ، والذي يحمي GRUB فعليًا بكلمة مرور.  قد يكون للتوزيعات الأخرى أدوات مساعدة خاصة بها لنفس المهمة.  إذا لم تكن كذلك ، فيمكنك تحرير الملفات مباشرة في دليل <code>grub.cfg</code> وإعادة <code>grub.cfg</code> . </p><br><p style=";text-align:right;direction:rtl">  في الملف <code>/etc/grub.d/10_linux</code> ، قم بتغيير المتغير CLASS ، أضف الخيار - <code>--unrestricted</code> إلى النهاية ، إذا لم يكن هناك: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">CLASS="--class gnu-linux --class gnu --class os --unrestricted"</code> </pre> <br><p style=";text-align:right;direction:rtl">  في الملف <code>/etc/grub.d/40_custom</code> أضف الأسطر التي تحدد اسم المستخدم وكلمة المرور اللازمة لتحرير سطر أوامر kernel: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">set superusers="root" password_pbkdf2 root grub.pbkdf2....... #    grub2-mkpasswd-pbkdf2</code> </pre> <br><p style=";text-align:right;direction:rtl">  أو ، إذا كانت هذه الوظيفة بحاجة إلى تعطيل على الإطلاق ، فإليك سطرًا مثل هذا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">set superusers=""</code> </pre> <br><p style=";text-align:right;direction:rtl">  <strong>الموقف 3</strong> .  يمتلك المهاجم إمكانية الوصول إلى الكمبيوتر المضمّن ، مما يسمح لك بالتشغيل من وسائط غير موثوق بها.  يمكن أن يكون هذا الوصول الفعلي دون فتح الحالة أو الوصول عبر IPMI.  الهدف هو الوصول إلى الجذر. </p><br><p style=";text-align:right;direction:rtl">  يمكنه تحميل GRUB الخاص به من محرك أقراص USB محمول أو قرص مضغوط وإضافة <code>init=/bin/sh</code> إلى معلمات kernel ، كما في المثال السابق.  وفقا لذلك ، يجب حظر التمهيد من أي وسائط فظيعة في BIOS.  وكذلك حماية إعدادات BIOS تتغير بكلمة مرور. </p><br><p style=";text-align:right;direction:rtl">  <strong>الوضع 4</strong> .  يمتلك المهاجم إمكانية الوصول الفعلي إلى الكمبيوتر المضمّن ، بما في ذلك القدرة على فتح العلبة.  الهدف هو معرفة المفتاح أو الوصول إلى الجذر. </p><br><p style=";text-align:right;direction:rtl">  بشكل عام ، هذا وضع خاسر على أي حال.  لم يتم إلغاء الهجوم على وحدات الذاكرة عن طريق تبريدها ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هجوم تمهيد بارد</a> ).  نظريًا أيضًا (لم يتم التحقق) ، يمكنك الاستفادة من حقيقة أن أقراص SATA الحديثة تدعم إعادة الاتصال الساخن.  عند إعادة تشغيل جهاز الكمبيوتر ، قم بفصل القرص ، <code>grub.cfg</code> بتغيير <code>grub.cfg</code> لـ <code>init=/bin/sh</code> ، <code>grub.cfg</code> الاتصال ، واسمح للنظام بإعادة التشغيل.  اتضح (إذا فهمت بشكل صحيح) الوصول إلى الجذر. </p><br><p style=";text-align:right;direction:rtl">  يمكن القيام بالشيء نفسه من قبل موظف لا ضمير له لاستضافة سحابة عن طريق عمل لقطة لجهاز ظاهري مع تعديله اللاحق. </p><br><h3 id="prochie-voprosy" style=";text-align:right;direction:rtl">  مسائل أخرى </h3><br><p style=";text-align:right;direction:rtl">  <strong>الحفاظ على المفتاح في الذاكرة أثناء إعادة التشغيل هو استهزاء.</strong>  <strong>الاستخدام بعد خالية في أنقى صورها.</strong>  <strong>الحل الأنظف هو استخدام kexec وإضافة المفتاح إلى initramfs المولدة ديناميكيًا.</strong>  <strong>كما أنه يحمي من استبدال معلمات kernel</strong> .  نعم ، هو ، إذا كان يعمل kexec.  جعلت التوزيعات الحديثة التكوين kexec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">معقدة للغاية</a> . </p><br><p style=";text-align:right;direction:rtl">  <strong>في مراكز البيانات ، وحتى أكثر من ذلك في السحابة ، لا تختفي السلطة أبدًا.</strong>  <strong>اتضح أن العبارة الرئيسية لم تعد هناك حاجة؟</strong>  في الواقع ، <em>إذا</em> كنت متأكدًا من ذلك ، فيمكنك حذفه.  سوف يتحول إلى خادم يعمل ، وهو المفتاح الذي لا يعرفه أحد على القرص ، وبالتالي لن يعطيه ، ولكن النظام الذي يمكن تحديثه باستخدام الوسائل العادية.    —        <code>sudo poweroff</code> . </p><br><p style=";text-align:right;direction:rtl"> ¹    <code>/root/key</code> —         ,        cron. </p><br><p style=";text-align:right;direction:rtl"> <strong>   ?  IPMI,       </strong> .    IPMI      Java.        . </p><br><p style=";text-align:right;direction:rtl"> <strong>   ?     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="> SSH</a></strong> .  عظيم!    .  ,      <code>sudo reboot</code> ,      ? </p><br><p style=";text-align:right;direction:rtl">             ,         .     SSH       ,      .       ,      ,   . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar457396/">https://habr.com/ru/post/ar457396/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar457380/index.html">Ultramodern OpenGL. الجزء 2</a></li>
<li><a href="../ar457382/index.html">7 عادات للمبرمجين ذوي الأداء العالي</a></li>
<li><a href="../ar457386/index.html">تقديم لينكس واجهات افتراضية: الأنفاق</a></li>
<li><a href="../ar457390/index.html">مدغشقر - جزيرة التناقضات</a></li>
<li><a href="../ar457392/index.html">وفورات في التنمية عبر منصة متنقلة: دراسة حالة Skyeng</a></li>
<li><a href="../ar457398/index.html">لكن هل أفعل هراء؟ لماذا يذهب المطورون إلى gemba</a></li>
<li><a href="../ar457400/index.html">إن عدد الضحايا في الكوارث النووية مثل تشيرنوبيل مبالغ فيه إلى حد كبير بسبب الدراما</a></li>
<li><a href="../ar457402/index.html">كيفية تنظيم تطوير ودعم مدونة على WordPress في 2Q19 وليس إصلاحها</a></li>
<li><a href="../ar457404/index.html">أخبار من خريطة الشارع المفتوح رقم 465 (06/11/2019 - 06/16/2019)</a></li>
<li><a href="../ar457406/index.html">كم يكسب خريجو الجامعات الروسية المختلفة؟</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>