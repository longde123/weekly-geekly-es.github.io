<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚è∫Ô∏è üëåüèª üëäüèΩ ¬øC√≥mo funciona zig? üé∑ üç† üéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De un traductor: esta publicaci√≥n se public√≥ en el blog del autor el 15 de marzo de 2018. A medida que evoluciona un lenguaje, su sintaxis puede ser d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øC√≥mo funciona zig?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435574/">  <i>De un traductor: esta publicaci√≥n se public√≥ en el blog del autor el 15 de marzo de 2018.</i>  <i>A medida que evoluciona un lenguaje, su sintaxis puede ser diferente en la actualidad.</i>  <i>Todo lo descrito se relaciona con Zig 0.2.0, la versi√≥n actual del lenguaje es Zig 0.3.0.</i> <i><br><br></i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Me puse en contacto con el autor de la publicaci√≥n, y amablemente proporcion√≥ un enlace al repositorio con la versi√≥n actual de las fuentes del proyecto en Zig 0.3.0</a></i> <i><br></i> <br>  Hola  ¬°Escribamos un int√©rprete Brainfuck!  "¬øPor qu√©?"  "Puede preguntar, pero no encontrar√° la respuesta aqu√≠". <br><br>  Lo har√© en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Zig</a> . <br><img src="https://habrastorage.org/webt/p2/l1/zs/p2l1zsmnlu7j_yqwm6fczu4ycay.jpeg"><br><h3>  Zig es ... </h3><br>  ... un nuevo lenguaje de programaci√≥n.  Todav√≠a est√° en beta y se est√° desarrollando r√°pidamente.  Si has visto el c√≥digo Zig antes, el c√≥digo en esta publicaci√≥n puede parecerte un poco diferente.  ¬°√âl es realmente diferente!  Zig 0.2.0 acaba de ser lanzado, coincidiendo con el lanzamiento de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LLVM 6 hace</a> unas semanas, e incluye muchos cambios de sintaxis y mejoras generales del lenguaje.  En su mayor√≠a, muchos "hechizos" han sido reemplazados por palabras clave.  ¬°Vea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> para una explicaci√≥n m√°s profunda de todos los cambios! <br><br>  Zig est√° dise√±ado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">para ser legible</a> y relativamente intuitivo para aquellos familiarizados con lenguajes compilados y mecanografiados como C, C ++ y, en algunos puntos, Rust. <br><br>  El c√≥digo fue compilado y probado con Zig 0.2.0, que est√° disponible ahora a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">trav√©s de varios canales</a> , incluido homebrew, si est√° en OSX: brew install zig. <br><a name="habracut"></a><br><h3>  Empecemos </h3><br>  Para aprender c√≥mo funciona Brainfuck, mira <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  No hay casi nada que aprender all√≠, pero es un lenguaje <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">completo de Turing</a> , lo que significa que puede escribir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cualquier cosa</a> en √©l. <br><br>  Publiqu√© el c√≥digo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> , en caso de que quiera ver el producto final o las confirmaciones iniciales. <br><br>  Zig es un lenguaje compilado.  Cuando compila un programa, el binario resultante (si est√° compilando un binario ejecutable, no una biblioteca) debe tener una funci√≥n principal que marque el punto de entrada. <br><br>  Entonces ... <br><br><pre><code class="plaintext hljs">// main.zig fn main() void { }</code> </pre> <br>  ... y empezar ... <br><br><pre> <code class="bash hljs">$ zig build-exe main.zig</code> </pre> <br>  ... se da por vencido ... <br><br><pre> <code class="bash hljs">/zig/std/special/bootstrap.zig:70:33: error: <span class="hljs-string"><span class="hljs-string">'main'</span></span> is private /zigfuck/main.zig:2:1: note: declared here</code> </pre> <br>  main debe declararse como p√∫blico para ser visible fuera del m√≥dulo ... <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { }</code> </pre> <br>  Deje que el programa Brainfuck use una matriz de 30,000 bytes como memoria, har√© una matriz de este tipo. <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { const mem: [30000]u8; }</code> </pre> <br>  Puedo declarar una constante (const) o una variable (var).  Aqu√≠, declare mem como una matriz de 30,000 bytes sin signo (u) (8 bits). <br><br>  Esto no se compila. <br><br><pre> <code class="bash hljs">/main.zig:3:5: error: variables must be initialized</code> </pre> <br>  Un programa C equivalente se compilar√≠a normalmente: puedo declarar una variable sin inicializaci√≥n, pero Zig me obliga a tomar una decisi√≥n ahora, en el momento en que se declara la variable.  Puede que no me importe lo que se escriba en √©l, pero debo indicarlo expl√≠citamente.  Har√© esto inicializando la variable con un valor indefinido (indefinido). <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { const mem: [30000]u8 = undefined; }</code> </pre> <br>  La inicializaci√≥n de una variable con un valor indefinido no ofrece ninguna garant√≠a sobre el valor de la variable en la memoria.  Esto es lo mismo que una declaraci√≥n de variable no inicializada en C, excepto que debe indicarlo expl√≠citamente. <br><br>  Pero tal vez no me importa c√≥mo inicializar este recuerdo.  Quiz√°s quiero tener una garant√≠a de que los ceros o alg√∫n valor arbitrario est√°n escritos all√≠.  En este caso, tambi√©n deber√≠a decir expl√≠citamente esto: <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { const mem = []u8{0} ** 30000; }</code> </pre> <br>  Puede parecer extra√±o, pero ** es el operador utilizado para expandir las matrices.  Declaro una matriz de 0 bytes y luego la ampl√≠o a 30,000 y obtengo el valor de inicializaci√≥n final de 30,000 bytes cero.  Esta operaci√≥n ocurre una vez, <i>en tiempo de compilaci√≥n</i> .  comptime es una de las grandes ideas de Zig, y volver√© sobre ella en una de las siguientes publicaciones. <br><br>  ¬°Ahora escribamos un programa sobre brainfuck que no hace m√°s que incrementar la primera ranura de memoria cinco veces! <br><br><pre> <code class="plaintext hljs">pub fn main() void { const mem = []u8{0} ** 30000; const src = "+++++"; }</code> </pre> <br>  En Zig, las cadenas son conjuntos de bytes.  No deber√≠a declarar src como una matriz de bytes, porque el compilador implica esto.  Esto es opcional, pero si lo desea, es posible: <br><br><pre> <code class="plaintext hljs">const src: [5]u8 = "+++++";</code> </pre> <br>  Esto compilar√° bien.  Sin embargo, esto: <br><br><pre> <code class="plaintext hljs">const src: [6]u8= "+++++";</code> </pre> <br>  No ser√°. <br><br><pre> <code class="bash hljs">main.zig:5:22: error: expected <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-string"><span class="hljs-string">'[6]u8'</span></span>, found <span class="hljs-string"><span class="hljs-string">'[5]u8'</span></span></code> </pre> <br>  Una nota m√°s: dado que las cadenas son solo matrices, no terminan en cero.  Sin embargo, puede declarar una cadena C terminada en nulo. Como literal, se ver√° as√≠: <br><br><pre> <code class="plaintext hljs">c"Hello I am a null terminated string";</code> </pre> <br><h3>  Por el bien com√∫n ... </h3><br>  Quiero hacer <i>algo</i> con cada personaje de una cadena.  Puedo hacerlo!  Al comienzo de main.zig, importo algunas funciones de la biblioteca est√°ndar: <br><br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn;</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">importar</a> , como pr√°cticamente todo lo que comienza con el signo @, es una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">funci√≥n de compilaci√≥n incorporada</a> .  Dichas caracter√≠sticas siempre est√°n disponibles a nivel mundial.  Importar aqu√≠ funciona de manera similar a JavaScript: puede importar cualquier cosa al cavar en el espacio de nombres y extraer de √©l cualquier funci√≥n o variable disponible p√∫blicamente.  En el ejemplo anterior, importo directamente la funci√≥n de advertencia y la asigno, de repente, a la constante de advertencia.  Ahora ella puede ser llamada.  Este es un patr√≥n com√∫n: importamos directamente desde el espacio de nombres est√°ndar y luego llamamos a std.debug.warn () o lo asignamos a la variable de advertencia.  Se ve as√≠: <br><br><pre> <code class="plaintext hljs">const std = @import("std"); const warn = std.debug.warn;</code> </pre> <br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn; // main.zig pub fn main() void { const mem = []u8{0} ** 30000; const src = "+++++"; for (src) |c| { warn("{}", c); } }</code> </pre> <br>  Durante la depuraci√≥n y el desarrollo inicial y las pruebas, solo quiero imprimir algo en la pantalla.  Zig es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">propenso a errores</a> , y stdout tambi√©n es propenso a errores.  No quiero hacer esto ahora, y puedo imprimir directamente en stderr usando warn, que importamos de la biblioteca est√°ndar. <br><br>  warn toma una cadena formateada, como printf en C!  El c√≥digo anterior imprimir√°: <br><br><pre> <code class="plaintext hljs">4343434343</code> </pre> <br>  43 es el c√≥digo de car√°cter ascii +.  Tambi√©n puedo escribir: <br><br><pre> <code class="plaintext hljs">warn("{c}", c);</code> </pre> <br>  y obtener: <br><br><pre> <code class="plaintext hljs">+++++</code> </pre> <br>  Entonces, inicializamos el espacio de memoria y escribimos el programa.  Ahora nos estamos dando cuenta del lenguaje mismo.  Comenzar√© con + y reemplazar√© el cuerpo del bucle for con el interruptor: <br><br><pre> <code class="plaintext hljs">for (src) |c| { switch(c) { '+' =&gt; mem[0] += 1 } }</code> </pre> <br>  Me dan dos errores: <br><br><pre> <code class="plaintext hljs">/main.zig:10:7: error: switch must handle all possibilities switch(c) { ^ /main.zig:11:25: error: cannot assign to constant '+' =&gt; mem[0] += 1 ^</code> </pre> <br>  ¬°Por supuesto, no puedo asignar un nuevo valor a una variable, que es una constante!  mem necesita hacerse una variable ... <br><br><pre> <code class="plaintext hljs">var mem = []u8{0} ** 30000;</code> </pre> <br>  Al igual que con otros errores, mi construcci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">interruptor</a> deber√≠a saber qu√© hacer si el car√°cter no es +, incluso si no se necesita hacer nada.  En mi caso, esto es exactamente lo que quiero.  Lleno este caso con un bloque vac√≠o: <br><br><pre> <code class="plaintext hljs">for (src) |c| { switch(c) { '+' =&gt; mem[0] += 1, else =&gt; {} } }</code> </pre> <br>  Ahora puedo compilar el programa.  Llama al avisar al final y ejecuta: <br><br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn; pub fn main() void { var mem = []u8{0} ** 30000; const src = "+++++"; for (src) |c| { switch(c) { '+' =&gt; mem[0] += 1, else =&gt; {} } } warn("{}", mem[0]); }</code> </pre> <br>  Me sale el n√∫mero 5 impreso en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">stderr</a> , como esperaba. <br><br><h3>  Sigamos adelante ... </h3><br>  Del mismo modo, apoyamos. <br><br><pre> <code class="plaintext hljs">switch(c) { '+' =&gt; mem[0] += 1, '-' =&gt; mem[0] -= 1, else =&gt; {} }</code> </pre> <br>  Para usar&gt; y &lt;, necesita usar una variable adicional, que sirve como un "puntero" en la memoria que asign√© para el programa brainfuck del usuario. <br><br><pre> <code class="plaintext hljs">var memptr: u16 = 0;</code> </pre> <br>  Dado que un 16 bits sin signo puede ser un m√°ximo de 65535, es m√°s que suficiente para indexar 30,000 bytes de espacio de direcciones. <br><br><blockquote>  <i>de hecho, 15 bits ser√≠an suficientes para nosotros, lo que nos permite direccionar 32767 bytes.</i>  <i>Zig permite tipos con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">diferentes anchos</a> , pero a√∫n no u15.</i> <i><br><br></i>  <i>en realidad puedes hacer u15 de esta manera:</i> <i><br><br></i> <pre> <code class="plaintext hljs">const u15 = @IntType(false, 15):</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Se propone</a> que cualquier tipo [iu] \ d + sea v√°lido como un tipo entero. </blockquote><br>  Ahora, en lugar de usar mem [0], puedo usar esta variable. <br><br><pre> <code class="plaintext hljs">'+' =&gt; mem[memptr] += 1, '-' =&gt; mem[memptr] -= 1,</code> </pre> <br>  &lt;y&gt; simplemente incremente y disminuya este puntero. <br><br><pre> <code class="plaintext hljs">'&gt;' =&gt; memptr += 1, '&lt;' =&gt; memptr -= 1,</code> </pre> <br>  Genial  ¬°Podemos escribir un programa real ahora! <br><br><h3>  Comprobar 1,2,3 </h3><br>  Zig tiene un motor de prueba incorporado.  En cualquier parte de cualquier archivo puedo escribir un bloque de prueba: <br><br><pre> <code class="plaintext hljs">test "Name of Test" { // test code }</code> </pre> <br>  y ejecute la prueba desde la l√≠nea de comando: zig test $ FILENAME.  El resto de los bloques de prueba son los mismos que los del c√≥digo regular. <br><br>  Veamos esto: <br><br><pre> <code class="plaintext hljs">// test.zig test "testing tests" {} zig test test.zig Test 1/1 testing tests...OK</code> </pre> <br>  Por supuesto, una prueba vac√≠a es in√∫til.  Puedo usar afirmar para confirmar realmente la ejecuci√≥n de las pruebas. <br><br><pre> <code class="plaintext hljs">const assert = @import("std").debug.assert; test "test true" { assert(true); } test "test false" { assert(false); }</code> </pre> <br><pre> <code class="bash hljs">zig <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> test.zig <span class="hljs-string"><span class="hljs-string">"thing.zig"</span></span> 10L, 127C written :!zig <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> thing.zig Test 1/2 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> true...OK Test 2/2 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> false...assertion failure [37;1m_panic.7 [0m: [2m0x0000000105260f34 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_panic [0m: [2m0x0000000105260d6b <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_assert [0m: [2m0x0000000105260619 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_test <span class="hljs-literal"><span class="hljs-literal">false</span></span> [0m: [2m0x0000000105260cfb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_main.0 [0m: [2m0x00000001052695ea <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_callMain [0m: [2m0x0000000105269379 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_callMainWithArgs [0m: [2m0x00000001052692f9 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_main [0m: [2m0x0000000105269184 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m??? [0m: [2m0x00007fff5c75c115 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m??? [0m: [2m0x0000000000000001 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m</code> </pre> <br>  La prueba cay√≥.  Use el siguiente comando para reproducir el error: <br><br><pre> <code class="plaintext hljs">./zig-cache/test</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El seguimiento de la pila en la amapola a√∫n est√° en desarrollo.</a> <br><br>  Para probar esto de manera eficiente, necesito romperlo en pedazos.  Comencemos con esto: <br><br><pre> <code class="plaintext hljs">fn bf(src: []const u8, mem: [30000]u8) void { var memptr: u16 = 0; for (src) |c| { switch(c) { '+' =&gt; mem[memptr] += 1, '-' =&gt; mem[memptr] -= 1, '&gt;' =&gt; memptr += 1, '&lt;' =&gt; memptr -= 1, else =&gt; {} } } } pub fn main() void { var mem = []u8{0} ** 30000; const src = "+++++"; bf(src, mem); }</code> </pre> <br>  Parece que funciona, ¬øverdad? <br><br>  Pero ... <br><br><pre> <code class="plaintext hljs">/main.zig:1:29: error: type '[30000]u8' is not copyable; cannot pass by value</code> </pre> <br><blockquote>  Esto se describe en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/zig-lang/zig/issues/733</a> . </blockquote><br>  Zig es estricto sobre esto.  Los tipos complejos y todos los objetos que pueden cambiar de tama√±o no se pueden pasar por valor.  Esto hace que la asignaci√≥n de la pila sea predecible y l√≥gica, y evita copias innecesarias.  Si desea utilizar la sem√°ntica de transferencia por valor en su programa, puede implementarla usted mismo utilizando su estrategia de asignaci√≥n, pero el lenguaje en s√≠ mismo no lo admite en circunstancias normales. <br><br>  La forma natural de evitar esta limitaci√≥n es pasar un puntero en lugar de un valor (pasar por referencia).  Zig usa una estrategia diferente, cortes.  Una rebanada es un puntero con una longitud adjunta y con un cheque para caer en los bordes.  La sintaxis en la firma de la funci√≥n se ve as√≠: <br><br><pre> <code class="plaintext hljs">fn bf(src: []const u8, mem: []u8) void { ... }</code> </pre> <br>  y al llamar a la funci√≥n se ve as√≠: <br><br><pre> <code class="plaintext hljs">bf(src, mem[0..mem.len]);</code> </pre> <br>  Tenga en cuenta que defin√≠ el l√≠mite superior simplemente haciendo referencia a la longitud de la matriz.  Hay una forma abreviada de notaci√≥n para tales casos: <br><br><pre> <code class="plaintext hljs">bf(src, mem[0..]);</code> </pre> <br>  Ahora puedo comenzar a escribir pruebas que prueben la funci√≥n bf () directamente.  Agregar√© funciones de prueba al final del archivo por ahora ... <br><br><pre> <code class="plaintext hljs">test "+" { var mem = []u8{0}; const src = "+++"; bf(src, mem[0..]); assert(mem[0] == 3); }</code> </pre> <br>  Tomo la matriz de memoria de un byte y luego verifico lo que deber√≠a suceder (el byte se incrementa tres veces).  Funciona! <br><br><pre> <code class="plaintext hljs">Test 1/1 +...OK</code> </pre> <br>  "-" se marca de la misma manera: <br><br><pre> <code class="plaintext hljs">test "-" { var mem = []u8{0}; const src = "---"; bf(src, mem[0..]); assert(mem[0] == 253); }</code> </pre> <br>  No funciona!  Cuando trato de restar 1 de 0, obtengo ... <br><br><pre> <code class="bash hljs">Test 2/2 -...<span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> overflow</code> </pre> <br>  mem es una matriz de bytes sin signo, y restar 1 de 0 provoca un desbordamiento.  Nuevamente, Zig me hace declarar lo que quiero expl√≠citamente.  En este caso, no tengo que preocuparme por el desbordamiento, de hecho, quiero que suceda, ya que estamos tratando con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aritm√©tica modular</a> , de acuerdo con la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">especificaci√≥n de brainfuck</a> .  Esto significa que decrementar una celda con el n√∫mero 0 me dar√° 255, y un incremento de 255 me dar√° 0. <br><br>  Zig tiene varias operaciones aritm√©ticas auxiliares que ofrecen la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sem√°ntica de la "envoltura" garantizada</a> . <br><br><pre> <code class="plaintext hljs">'+' =&gt; mem[memptr] +%= 1, '-' =&gt; mem[memptr] -%= 1,</code> </pre> <br>  Esto resuelve todo el problema de desbordamiento y hace lo que esperaba. <br><br>  Para probar &lt;and&gt;, navego a trav√©s de una peque√±a matriz y verifico el valor de la celda incrementada: <br><br><pre> <code class="plaintext hljs">test "&gt;" { var mem = []u8{0} ** 5; const src = "&gt;&gt;&gt;+++"; bf(src, mem[0..]); assert(mem[3] == 3); }</code> </pre> <br>  y ... <br><br><pre> <code class="plaintext hljs">test "&lt;" { var mem = []u8{0} ** 5; const src = "&gt;&gt;&gt;+++&lt;++&lt;+"; bf(src, mem[0..]); assert(mem[3] == 3); assert(mem[2] == 2); assert(mem[1] == 1); }</code> </pre> <br>  En el √∫ltimo caso, puedo comparar directamente el resultado con una matriz est√°tica usando ... <br><br><pre> <code class="plaintext hljs">const mem = std.mem;</code> </pre> <br>  Recordemos que ya he importado std.  En el siguiente ejemplo, uso mem.eql en este espacio de nombres: <br><br><pre> <code class="plaintext hljs">test "&lt;" { var storage = []u8{0} ** 5; const src = "&gt;&gt;&gt;+++&lt;++&lt;+"; bf(src, storage[0..]); assert(mem.eql(u8, storage, []u8{ 0, 1, 2, 3, 0 })); }</code> </pre> <br>  ... y recuerden, literales de cadena, estos son solo matrices u8 en zig, y puedo poner literales hexadecimales en ellos, es decir  ¬°El siguiente c√≥digo funcionar√° de la misma manera! <br><br><pre> <code class="plaintext hljs">assert(mem.eql(u8, storage, "\x00\x01\x02\x03\x00"));</code> </pre> <br>  A√±adir el "."  Simplemente imprime como car√°cter el valor de byte en la celda a la que apunta el puntero.  Estoy usando warn ahora, pero m√°s tarde lo reemplazar√© con stdout.  Esto es f√°cil de hacer conceptualmente, pero algo confuso en la implementaci√≥n.  ¬°Lo har√© luego! <br><br><pre> <code class="plaintext hljs">'.' =&gt; warn("{c}", storage[memptr]),</code> </pre> <br>  Ciclos <br>  [y] - la magia comienza aqu√≠ ... <br><br>  [- si el valor de la celda actual es cero, omita los pasos al corchete de cierre sin ejecutar el c√≥digo. <br>  ] - si el valor de la celda actual no es cero, regrese al par√©ntesis de apertura y ejecute el c√≥digo nuevamente. <br><br>  Esta vez comenzar√© con una prueba, los probar√© juntos (obviamente, no tiene sentido probarlos por separado).  El primer caso de prueba: la celda de almacenamiento [2] debe estar vac√≠a, aunque el ciclo debe aumentarla si comienza: <br><br><pre> <code class="plaintext hljs">test "[] skips execution and exits" { var storage = []u8{0} ** 3; const src = "+++++&gt;[&gt;+++++&lt;-]"; bf(src, storage[0..]); assert(storage[0] == 5); assert(storage[1] == 0); assert(storage[2] == 0); }</code> </pre> <br>  y crear√© espacios en blanco para la declaraci√≥n de cambio: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) { }, ']' =&gt; if (storage[memptr] == 0) { },</code> </pre> <br>  Que hacer ahora  Puedes usar un enfoque ingenuo.  Simplemente incremente el puntero src hasta que lo encuentre].  Pero no puedo usar el bucle for en zig para esto, se cre√≥ solo para iterar a trav√©s de colecciones, sin perder sus elementos.  Una construcci√≥n adecuada aqu√≠ es mientras: <br><br>  fue: <br><br><pre> <code class="plaintext hljs">var memptr: u16 = 0; for (src) |c| { switch(c) { ... } }</code> </pre> <br>  se convirti√≥ en ... <br><br><pre> <code class="plaintext hljs">var memptr: u16 = 0; var srcptr: u16 = 0; while (srcptr &lt; src.len) { switch(src[srcptr]) { ... } srcptr += 1; }</code> </pre> <br>  Ahora puedo reasignar el puntero srcptr en el medio del bloque, har√© esto: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) { while (src[srcptr] != ']') srcptr += 1; },</code> </pre> <br>  Esto satisface la prueba "[] omite la ejecuci√≥n del c√≥digo y sale" <br>  Esto satisface la prueba "[] omite la ejecuci√≥n y sale", aunque no es del todo confiable, como veremos. <br><br>  ¬øQu√© hay de cerrar los corchetes?  Creo que se puede escribir simplemente por analog√≠a: <br><br><pre> <code class="plaintext hljs">test "[] executes and exits" { var storage = []u8{0} ** 2; const src = "+++++[&gt;+++++&lt;-]"; bf(src, storage[0..]); assert(storage[0] == 0); assert(storage[1] == 25); } ']' =&gt; if (storage[memptr] != 0) { while (src[srcptr] != '[') srcptr -= 1; },</code> </pre> <br>  Puedes ver lo que sucede ... Una soluci√≥n ingenua con dos par√©ntesis tiene un defecto fatal y se rompe por completo en los bucles anidados.  Considere lo siguiente: <br><br><pre> <code class="plaintext hljs">++&gt;[&gt;++[-]++&lt;-]</code> </pre> <br>  El resultado deber√≠a ser {2, 0}, pero el primer par√©ntesis abierto simplemente se mueve est√∫pidamente al primer par√©ntesis de cierre, y todo se vuelve desordenado.  Debe saltar al siguiente corchete de cierre en el mismo nivel de anidamiento.  Es f√°cil agregar un contador de profundidad y rastrearlo a medida que avanza a lo largo de la l√≠nea.  Lo hacemos en ambas direcciones: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) { var depth:u16 = 1; srcptr += 1; while (depth &gt; 0) { srcptr += 1; switch(src[srcptr]) { '[' =&gt; depth += 1, ']' =&gt; depth -= 1, else =&gt; {} } } }, ']' =&gt; if (storage[memptr] != 0) { var depth:u16 = 1; srcptr -= 1; while (depth &gt; 0) { srcptr -= 1; switch(src[srcptr]) { '[' =&gt; depth -= 1, ']' =&gt; depth += 1, else =&gt; {} } } },</code> </pre> <br>  y pruebas relacionadas: tenga en cuenta que src en ambas pruebas incluye un bucle interno. <br><br><pre> <code class="plaintext hljs">test "[] skips execution with internal braces and exits" { var storage = []u8{0} ** 2; const src = "++&gt;[&gt;++[-]++&lt;-]"; try bf(src, storage[0..]); assert(storage[0] == 2); assert(storage[1] == 0); } test "[] executes with internal braces and exits" { var storage = []u8{0} ** 2; const src = "++[&gt;++[-]++&lt;-]"; try bf(src, storage[0..]); assert(storage[0] == 0); assert(storage[1] == 2); }</code> </pre> <br><blockquote>  Por separado, tenga en cuenta [-] - el idioma de brainfuck, que significa "cero esta celda".  Puede ver que no importa qu√© valor ten√≠a la celda al principio, se reducir√° hasta llegar a 0 y luego la ejecuci√≥n continuar√°. </blockquote><br><h3>  Camino desafortunado </h3><br>  No cont√© con la posibilidad de que el programa en bf se rompiera.  ¬øQu√© sucede si env√≠o un programa de entrada incorrecto a mi int√©rprete?  Por ejemplo, simplemente [sin un corchete de cierre, o &lt;, que inmediatamente va m√°s all√° de la matriz de memoria?  (Puedo ajustar el puntero de memoria, pero es mejor considerar esto como un error). <br><br>  Voy a mirar un poco m√°s adelante y explicar todas las diferencias en el c√≥digo.  Pondr√© la funci√≥n de int√©rprete bf en un archivo separado y tambi√©n pondr√© la funcionalidad seekBack y seekForward en mis peque√±as funciones. <br><br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn; const sub = @import("std").math.sub; fn seekBack(src: []const u8, srcptr: u16) !u16 { var depth:u16 = 1; var ptr: u16 = srcptr; while (depth &gt; 0) { ptr = sub(u16, ptr, 1) catch return error.OutOfBounds; switch(src[ptr]) { '[' =&gt; depth -= 1, ']' =&gt; depth += 1, else =&gt; {} } } return ptr; } fn seekForward(src: []const u8, srcptr: u16) !u16 { var depth:u16 = 1; var ptr: u16 = srcptr; while (depth &gt; 0) { ptr += 1; if (ptr &gt;= src.len) return error.OutOfBounds; switch(src[ptr]) { '[' =&gt; depth += 1, ']' =&gt; depth -= 1, else =&gt; {} } } return ptr; } pub fn bf(src: []const u8, storage: []u8) !void { var memptr: u16 = 0; var srcptr: u16 = 0; while (srcptr &lt; src.len) { switch(src[srcptr]) { '+' =&gt; storage[memptr] +%= 1, '-' =&gt; storage[memptr] -%= 1, '&gt;' =&gt; memptr += 1, '&lt;' =&gt; memptr -= 1, '[' =&gt; if (storage[memptr] == 0) srcptr = try seekForward(src, srcptr), ']' =&gt; if (storage[memptr] != 0) srcptr = try seekBack(src, srcptr), '.' =&gt; warn("{c}", storage[memptr]), else =&gt; {} } srcptr += 1; } }</code> </pre> <br>  Esto hace que el cambio sea mucho m√°s f√°cil de leer, en mi opini√≥n, seekForward y seekBack funcionan y se ven muy similares, y tuve la tentaci√≥n de refactorizarlos en algo m√°s inteligente y compacto, pero al final hacen cosas diferentes y manejan los errores Tambi√©n de diferentes maneras.  M√°s f√°cil de copiar y ajustar, por lo que ser√° m√°s claro.  Tambi√©n ajustar√© seekForward m√°s tarde, en alg√∫n momento, posiblemente en una publicaci√≥n posterior. <br><br>  ¬°Agregu√© algunas cosas importantes!  ¬°Tenga en cuenta que las tres funciones ahora devuelven un tipo! .. Esta es la nueva sintaxis de lo que sol√≠a ser el tipo% T (uni√≥n de error).  Esto significa que la funci√≥n puede devolver cierto tipo o un error.  Cuando intento llamar a tal funci√≥n, debo usar try antes de llamar a la funci√≥n, que arroja el error en la pila de llamadas si ocurre el error, o usar catch: <br><br><pre> <code class="plaintext hljs">const x = functionCall() catch {}</code> </pre> <br>  Donde manejo errores en un bloque catch.  Tal como est√° escrito, catch puede tragarse cualquier error.  Esta es una mala pr√°ctica, pero aqu√≠ Zig nos obliga a hacerlo expl√≠citamente.  Si encuentro un error en un bloque vac√≠o, declaro que no creo que pueda ocurrir un error o que no necesito manejarlo.  En la pr√°ctica, puede ser algo como TODO, y de hecho es muy f√°cil hacerlo expl√≠cito. <br><br><pre> <code class="plaintext hljs">const x = functionCall() catch { @panic("TODO") }</code> </pre> <br>  Recuerde que tal caso nunca suceder√° en el c√≥digo de producci√≥n.  Estoy notificando al compilador que s√© lo que estoy haciendo.  Si pudiera ocurrir un error, tendr√≠a que agregar el manejo de errores. <br><br>  Entonces, ¬øqu√© errores debo devolver de seekBack o seekForward? <br><br>  En seekBack: <br><br><pre> <code class="plaintext hljs">ptr = sub(u16, ptr, 1) catch return error.OutOfBounds;</code> </pre> <br>  Reemplac√© el puntero de disminuci√≥n para usar la subfunci√≥n de std lib, que arroja un error de desbordamiento si ocurre un desbordamiento.  Quiero detectar este error y devolver el error OutOfBounds en su lugar, que creo aqu√≠ solo con usarlo. <br><br><blockquote>  <i>Errores Zig es b√°sicamente una matriz de c√≥digos de error que genera el compilador cuando usa el error. Alg√∫n tipo de error.</i>  <i>Se garantiza que son √∫nicos y se pueden usar como valores en un bloque de interruptores.</i> </blockquote><br>  Quiero usar OutOfBounds aqu√≠ porque, sem√°nticamente, si el puntero de memoria se vuelve menor que cero, le pido al tiempo de ejecuci√≥n que vaya m√°s all√° del espacio de memoria que asign√©. <br><br>  de manera similar en la funci√≥n seekForward: <br><br><pre> <code class="plaintext hljs">if (ptr &gt;= src.len) return error.OutOfBounds;</code> </pre> <br>  En este caso, si el puntero es m√°s grande que src.len, capto el error aqu√≠ y devuelvo el mismo error. <br><br>  al llamar: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) srcptr = try seekForward(src, srcptr), ']' =&gt; if (storage[memptr] != 0) srcptr = try seekBack(src, srcptr),</code> </pre> <br>  Intento llamar a estas funciones.  Si se llaman con √©xito, se ejecutan correctamente e intenta devolver srcptr.  Si no tienen √©xito, intente termina la funci√≥n y devuelve un error al lugar de la llamada a toda la funci√≥n bf. <br><br>  ¬°La llamada puede ser de main! <br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; // yes, hello const hello_world = "++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.&gt;.+++.------.--------.&gt;+.&gt;."; pub fn main() void { storage = []u8{0} ** 30000; bf(hello_world, storage[0..]) catch {}; }</code> </pre> <br>  Me trago este error aqu√≠, y no deber√≠a hacerse, pero notaremos un punto importante sobre la facilidad con la que zig puede pasar errores por la pila de llamadas.  No es responsabilidad de la funci√≥n de llamada verificar cada caso de error, pero el compilador fuerza la llamada de cada funci√≥n que puede fallar con un intento.  ¬°Esto siempre debe hacerse, incluso si se ignoran los errores! <br><br><blockquote>  <i>La nueva sintaxis try / catch elimina los muchos hechizos como %% y% que a la gente no le gusta tanto.</i> </blockquote><br>  Ahora he implementado 7 de 8 personajes de brainfuck, y esto es suficiente para ejecutar un programa "significativo". <br><br><h3>  Un programa significativo </h3><br>  Aqu√≠ est√° el programa: <br><br><pre> <code class="plaintext hljs">//   ,   const fib = "++++++++++++++++++++++++++++++++++++++++++++&gt;++++++++++++++++++++++++++++++++&gt;++++++++++++++++&gt;&gt;+&lt;&lt;[&gt;&gt;&gt;&gt;++++++++++&lt;&lt;[-&gt;+&gt;-[&gt;+&gt;&gt;]&gt;[+[-&lt;+&gt;]&gt;+&gt;&gt;]&lt;&lt;&lt;&lt;&lt;&lt;]&gt;[&lt;+&gt;-]&gt;[-]&gt;&gt;&gt;++++++++++&lt;[-&gt;-[&gt;+&gt;&gt;]&gt;[+[-&lt;+&gt;]&gt;+&gt;&gt;]&lt;&lt;&lt;&lt;&lt;]&gt;[-]&gt;&gt;[++++++++++++++++++++++++++++++++++++++++++++++++.[-]]&lt;[++++++++++++++++++++++++++++++++++++++++++++++++.[-]]&lt;&lt;&lt;++++++++++++++++++++++++++++++++++++++++++++++++.[-]&lt;&lt;&lt;&lt;&lt;&lt;&lt;.&gt;.&gt;&gt;[&gt;&gt;+&lt;&lt;-]&gt;[&gt;+&lt;&lt;+&gt;-]&gt;[&lt;+&gt;-]&lt;&lt;&lt;-]&lt;&lt;++...";</code> </pre> <br>  Corramos ... <br><br><pre> <code class="plaintext hljs">pub fn main() void { storage = []u8{0} ** 30000; bf(fib, storage[0..]) catch {}; }</code> </pre> <br>  voila! <br><br><pre> <code class="plaintext hljs">1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 121, 98, 219,</code> </pre> <br><blockquote>  <i>Cada vez que pienso en una serie de Fibonacci recuerdo un recuerdo ... Lo descubr√≠ en el programa PBS (Public Broadcasting Service, un servicio de transmisi√≥n de televisi√≥n no comercial estadounidense) en los a√±os 80, y siempre recuerdo eso.</i>  <i>Pens√© que ser√≠a olvidado, pero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">YouTube es una gran cosa</a> .</i> </blockquote><br><h3>  ¬øC√≥mo puedo mejorar esto? </h3><br>  Ya he insinuado algunos TODOS.  No deber√≠a haber usado stderr para la salida.  Quiero usar stdout. <br><br>  Cada vez que abro el int√©rprete, abro la secuencia en stdout e imprimo en ella: <br><br><pre> <code class="plaintext hljs">const io = std.io; ... pub fn bf(src: []const u8, storage: []u8) !void { const stdout = &amp;(io.FileOutStream.init(&amp;(io.getStdOut() catch unreachable)).stream); ... '.' =&gt; stdout.print("{c}", storage[memptr]) catch unreachable, ...</code> </pre> <br>  ¬øQu√© est√° pasando aqu√≠?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llamo a io.getStdOut (), que puede generar errores (y de nuevo, expl√≠citamente me trago un posible error con catch inalcanzable: si esta funci√≥n devuelve un error, ¬°el programa se bloquear√°!). Inicializo la secuencia, tomo un puntero e inicializo como una secuencia de salida en la que puedo escribir llamando a print. print acepta una cadena formateada, al igual que warn, por lo que el reemplazo se realiza directamente. print tambi√©n puede generar un error, y tambi√©n me trago estos errores. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En un programa escrito correctamente, debo tener en cuenta los posibles errores de abrir stdout, as√≠ como los posibles errores de intentos de escribir en stdout. Zig hace que sea muy f√°cil ignorar estos errores siempre que sepa que los est√° ignorando.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© sucede si decido que quiero convertir mi prototipo en un lanzamiento? </font><font style="vertical-align: inherit;">¬øMe sentar√© con una taza de caf√© y har√© un trabajo desagradecido de manejo de errores, confiando en d√©cadas de experiencia y conocimiento para enumerar cada posible caso de error, y c√≥mo puedo manejarlo? </font><font style="vertical-align: inherit;">Pero, ¬øqu√© pasa si no tengo d√©cadas de experiencia y conocimiento? </font><font style="vertical-align: inherit;">¬°Est√° bien, Zig lo har√°! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quiero demostrar algo poderoso, ¬°salida de error!</font></font><br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; const warn = @import("std").debug.warn; const serpinsky = "++++++++[&gt;+&gt;++++&lt;&lt;-]&gt;++&gt;&gt;+&lt;[-[&gt;&gt;+&lt;&lt;-]+&gt;&gt;]&gt;+[ -&lt;&lt;&lt;[ -&gt;[+[-]+&gt;++&gt;&gt;&gt;-&lt;&lt;]&lt;[&lt;]&gt;&gt;++++++[&lt;&lt;+++++&gt;&gt;-]+&lt;&lt;++.[-]&lt;&lt; ]&gt;.&gt;+[&gt;&gt;]&gt;+ ] "; pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch unreachable; }</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S√© que bf puede generar errores porque devuelve! Void. </font><font style="vertical-align: inherit;">Me trago este error en el lado de la llamada, en la funci√≥n principal. </font><font style="vertical-align: inherit;">Cuando estoy listo para aceptar mi destino y hacer lo correcto, puedo detectar posibles errores como este:</font></font><br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; const warn = @import("std").debug.warn; const serpinsky = "++++++++[&gt;+&gt;++++&lt;&lt;-]&gt;++&gt;&gt;+&lt;[-[&gt;&gt;+&lt;&lt;-]+&gt;&gt;]&gt;+[ -&lt;&lt;&lt;[ -&gt;[+[-]+&gt;++&gt;&gt;&gt;-&lt;&lt;]&lt;[&lt;]&gt;&gt;++++++[&lt;&lt;+++++&gt;&gt;-]+&lt;&lt;++.[-]&lt;&lt; ]&gt;.&gt;+[&gt;&gt;]&gt;+ ] "; pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch |err| switch (err) { }; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬°El compilador ahora es mi amigo! </font></font><br><br><pre> <code class="bash hljs">/Users/jfo/code/zigfuck/main.zig:7:46: error: error.OutOfBounds not handled <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> switch shell returned 1</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Este error deber√≠a serle familiar, ya que se gener√≥ desde bf y funciones auxiliares! </font><font style="vertical-align: inherit;">Pero imaginemos que miro los errores generados por stdout que tragu√© en bf. </font><font style="vertical-align: inherit;">En lugar de tragarlos, deber√≠a empujarlos hacia arriba de la cadena usando try. </font><font style="vertical-align: inherit;">Recuerde que usando una llamada a la funci√≥n que genera errores sin captura, usamos try, que termina la funci√≥n cuando ocurre un error, proporcionando a la funci√≥n de llamada el manejo de cualquier error potencial. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, en lugar de:</font></font><br><br><pre> <code class="plaintext hljs">const io = std.io; ... pub fn bf(src: []const u8, storage: []u8) !void { const stdout = &amp;(io.FileOutStream.init(&amp;(io.getStdOut() catch unreachable)).stream); ... '.' =&gt; stdout.print("{c}", storage[memptr]) catch unreachable, ...</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nosotros hacemos: </font></font><br><br><pre> <code class="plaintext hljs">const io = std.io; ... pub fn bf(src: []const u8, storage: []u8) !void { const stdout = &amp;(io.FileOutStream.init(&amp;(try io.getStdOut())).stream); ... '.' =&gt; try stdout.print("{c}", storage[memptr]), ...</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compilamos: </font></font><br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; const warn = @import("std").debug.warn; const serpinsky = "++++++++[&gt;+&gt;++++&lt;&lt;-]&gt;++&gt;&gt;+&lt;[-[&gt;&gt;+&lt;&lt;-]+&gt;&gt;]&gt;+[ -&lt;&lt;&lt;[ -&gt;[+[-]+&gt;++&gt;&gt;&gt;-&lt;&lt;]&lt;[&lt;]&gt;&gt;++++++[&lt;&lt;+++++&gt;&gt;-]+&lt;&lt;++.[-]&lt;&lt; ]&gt;.&gt;+[&gt;&gt;]&gt;+ ] "; pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch |err| switch (err) { }; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬°y obtenga una lista de todos los posibles errores que puedo obtener llamando a la funci√≥n! </font></font><br><br><pre> <code class="plaintext hljs">/Users/jfo/code/zigfuck/main.zig:7:46: error: error.SystemResources not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.OperationAborted not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.IoPending not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.BrokenPipe not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.Unexpected not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.WouldBlock not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.FileClosed not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.DestinationAddressRequired not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.DiskQuota not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.FileTooBig not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.InputOutput not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.NoSpaceLeft not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.AccessDenied not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.OutOfBounds not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.NoStdHandles not handled in switch shell returned 1</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Zig me da la oportunidad de manejar estos errores con cuidado si quiero o puedo hacerlo! </font><font style="vertical-align: inherit;">Realizo un cambio en funci√≥n de los valores de error, manejo de casos si lo deseo y omitir si quiero omitirlos.</font></font><br><br><pre> <code class="plaintext hljs">pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch |err| switch (err) { error.OutOfBounds =&gt; @panic("Out Of Bounds!"), else =&gt; @panic("IO error") }; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto todav√≠a no es un manejo correcto de los errores, estrictamente hablando, ¬°pero solo quiero demostrar cu√°n inteligente es Zig informando todo tipo de casos de error a la funci√≥n de llamada! </font><font style="vertical-align: inherit;">Y cuando se produce un error, se obtiene un </font><font style="vertical-align: inherit;">seguimiento de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">error en</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lugar de un seguimiento de pila. </font><font style="vertical-align: inherit;">Cosa genial!</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Todo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Hay muchas mejoras diferentes que puede hacer con el int√©rprete! En realidad, necesita manejar correctamente todos los errores, y debe implementar el operador "," que en brainfuck act√∫a como la funci√≥n getc, permiti√©ndole ingresar datos en el programa cuando se ejecuta. Tambi√©n debe hacer posible leer el archivo fuente en el b√∫fer e interpretarlo, en lugar de usar el c√≥digo fuente bf codificado. Tambi√©n hay algunas mejoras que no son estrictamente necesarias, pero que pueden ilustrar algunas de las caracter√≠sticas de Zig. En lugar de tirarlos todos al final de la publicaci√≥n, los dividir√© en partes y los publicar√© en publicaciones futuras, que ser√°n m√°s peque√±as y f√°ciles de digerir.</font></font><br><br><h3>  Conclusi√≥n </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espero que este proyecto en miniatura a medio terminar te d√© una idea de c√≥mo se ve el c√≥digo Zig y para qu√© se puede usar. Zig no es un cuchillo suizo, no es una herramienta perfecta para todo, se enfoca en ciertas cosas, en ser un lenguaje de sistema pragm√°tico que se puede usar en conjunto o en lugar de C y C ++. Esto me hizo abordar cuidadosamente el uso de la memoria, la administraci√≥n de la memoria y el manejo de errores. En un entorno con recursos limitados, esta es una caracter√≠stica √∫til, no un error. Zig es determinista, no tiene ambig√ºedades e intenta facilitar la escritura de c√≥digo confiable en un entorno en el que tradicionalmente es dif√≠cil de hacer.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Describ√≠ solo una peque√±a parte de la sintaxis y las caracter√≠sticas de Zig, ¬°hay muchos cambios interesantes que han llegado al lenguaje en la versi√≥n 0.2.0 y superior! ¬°Todo el c√≥digo que escrib√≠ est√° compilado en modo de depuraci√≥n, lo cual es √≥ptimo para las comprobaciones de seguridad y para reducir el tiempo de compilaci√≥n para acelerar las iteraciones! Hay modos de liberaci√≥n r√°pida y segura de liberaci√≥n, y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habr√° m√°s</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en el futuro </font><font style="vertical-align: inherit;">. Puede leer m√°s sobre sus diferencias y explicaciones sobre estos modos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Constantemente me sorprende la velocidad y direcci√≥n del desarrollo de Zig. Todav√≠a hay muchas cosas en movimiento, y lo ser√° hasta el lanzamiento de la versi√≥n 1.0.0, y si decides probar Zig, solo recuerda que hay muchas buenas ideas, ¬°y espero implementarlas!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pru√©balo y √∫nete a #zig en freenode en cualquier momento si tienes preguntas. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es435574/">https://habr.com/ru/post/es435574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es435560/index.html">Primera computadora cu√°ntica comercial - IBM</a></li>
<li><a href="../es435562/index.html">El camino de un fumador: c√≥mo ingresar a la profesi√≥n de programador, si usted es humanista</a></li>
<li><a href="../es435564/index.html">Usando GtkApplication. Funciones de representaci√≥n de Librsvg</a></li>
<li><a href="../es435568/index.html">Enrutador VyOS OpenSource</a></li>
<li><a href="../es435572/index.html">Anycubic i3 Mega: remake de calidad de Prusa i3</a></li>
<li><a href="../es435576/index.html">1C, sin dolor</a></li>
<li><a href="../es435578/index.html">Spacewalk para Navidad</a></li>
<li><a href="../es435580/index.html">Servicios Java, Spring, Kurento y Media</a></li>
<li><a href="../es435582/index.html">¬øC√≥mo agregar un √≠ndice en un sistema cargado 24/7 sin tiempo de inactividad?</a></li>
<li><a href="../es435584/index.html">Slush 2018. D√≠a uno, D√≠a dos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>