<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∏üèª üëáüèø üë´ RabbitMQ vs. Kafka: conmutaci√≥n por error y alta disponibilidad en cl√∫steres üë©üèΩ‚Äç‚öñÔ∏è üë©üèæ‚Äç‚öñÔ∏è üßòüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La tolerancia a fallas y la alta disponibilidad son temas importantes, por lo que RabbitMQ y Kafka dedicar√°n art√≠culos separados. Este art√≠culo es sob...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RabbitMQ vs. Kafka: conmutaci√≥n por error y alta disponibilidad en cl√∫steres</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/471858/"><img src="https://habrastorage.org/webt/hr/j2/oy/hrj2oyxwqv8-wo-vpmagx_dwmia.jpeg"><br><br>  La tolerancia a fallas y la alta disponibilidad son temas importantes, por lo que RabbitMQ y Kafka dedicar√°n art√≠culos separados.  Este art√≠culo es sobre RabbitMQ, y el siguiente es sobre Kafka, en comparaci√≥n con RabbitMQ.  El art√≠culo es largo, as√≠ que ponte c√≥modo. <br><br>  Considere las estrategias de tolerancia a fallas, consistencia y alta disponibilidad (HA), as√≠ como las compensaciones que cada estrategia tiene que hacer.  RabbitMQ puede ejecutarse en un grupo de nodos, y luego se clasifica como un sistema distribuido.  Cuando se trata de sistemas distribuidos, a menudo hablamos de consistencia y accesibilidad. <br><br>  Estos conceptos describen c√≥mo se comporta el sistema en caso de falla.  Falla de conexi√≥n de red, falla del servidor, falla del disco duro, indisponibilidad temporal del servidor debido a recolecci√≥n de basura, p√©rdida de paquetes o ralentizaci√≥n de la conexi√≥n de red.  Todo esto puede conducir a la p√©rdida de datos o conflictos.  Resulta que es casi imposible crear un sistema que sea simult√°neamente completamente consistente (sin p√©rdida de datos, sin discrepancias de datos) y accesible (aceptar√° operaciones de lectura y escritura) para todo tipo de fallas. <br><a name="habracut"></a><br>  Veremos que la coherencia y la accesibilidad se encuentran en diferentes extremos del espectro, y debe elegir qu√© forma optimizar.  La buena noticia es que con RabbitMQ tal elecci√≥n es posible.  Tiene una especie de apalancamiento "Nerd" para cambiar el equilibrio hacia una mayor coherencia o mayor accesibilidad. <br><br>  Prestaremos especial atenci√≥n a qu√© configuraciones conducen a la p√©rdida de datos debido a registros confirmados.  Existe una cadena de responsabilidad entre editores, corredores y consumidores.  Despu√©s de que el mensaje se transmite al agente, es su trabajo no perder el mensaje.  Cuando el corredor confirma al editor el recibo del mensaje, no esperamos que se pierda.  Pero veremos que esto realmente puede suceder dependiendo de la configuraci√≥n de su corredor y editor. <br><br><h1>  Las primitivas de estabilidad de un nodo </h1><br><h3>  Colas sostenidas / enrutamiento </h3><br>  Hay dos tipos de colas en RabbitMQ: duraderas / no duraderas.  Todas las colas se almacenan en la base de datos de Mnesia.  Las colas persistentes se vuelven a declarar cuando el nodo se inicia y, por lo tanto, sobreviven a un reinicio, un bloqueo del sistema o un bloqueo del servidor (siempre que se guarden los datos).  Esto significa que mientras declara el enrutamiento (intercambio) y la resistencia de la cola, la infraestructura de las colas / enrutamiento volver√° a estar en l√≠nea. <br><br>  Las colas vol√°tiles y el enrutamiento se eliminan cuando se reinicia el host. <br><br><h3>  Publicaciones persistentes </h3><br>  El hecho de que la cola sea larga no significa que todos sus mensajes sobrevivir√°n al reinicio de un nodo.  Solo se restaurar√°n los mensajes establecidos por el editor como persistentes.  Los mensajes persistentes crean una carga adicional para el intermediario, pero si la p√©rdida de mensajes es inaceptable, entonces no hay otra manera. <br><br><img src="https://habrastorage.org/webt/hl/nv/gv/hlnvgvt20t-fbikkajwnkirflyo.png"><br>  <i>Fig.</i>  <i>1. Matriz de estabilidad</i> <br><br><h1>  Agrupaci√≥n de cl√∫steres de reflejo </h1><br>  Para sobrevivir a la p√©rdida de un corredor, necesitamos redundancia.  Podemos combinar varios nodos RabbitMQ en un cl√∫ster y luego agregar redundancia adicional replicando las colas entre varios nodos.  Por lo tanto, si un nodo cae, no perdemos datos y permanecemos disponibles. <br><br>  Espejo de cola: <br><br><ul><li>  una cola principal (maestra), que recibe todos los comandos de escritura y lectura <br></li><li>  uno o m√°s espejos que reciben todos los mensajes y metadatos de la cola principal.  Estos espejos no existen para escalar, sino √∫nicamente para redundancia. </li></ul><br><img src="https://habrastorage.org/webt/am/-b/ol/am-boljly334-fiqfajsoowe3iu.png"><br>  <i>Fig.</i>  <i>2. Reflejando la cola</i> <br><br>  La duplicaci√≥n se establece mediante la pol√≠tica adecuada.  En √©l, puede elegir la tasa de replicaci√≥n e incluso los nodos en los que se debe colocar la cola.  Ejemplos: <br><br><ul><li><code>ha-mode: all</code> <br> </li><li>  <code>ha-mode: exactly, ha-params: 2</code> (un maestro y un espejo) <br></li><li> <code>ha-mode: nodes, ha-params: rabbit@node1, rabbit@node2</code> </li> </ul><br><h1>  Confirmaci√≥n al editor </h1><br>  Para lograr la grabaci√≥n secuencial, Publisher Confirms debe confirmarse.  Sin ellos, existe la posibilidad de perder mensajes.  Se env√≠a una confirmaci√≥n al editor despu√©s de escribir el mensaje en el disco.  RabbitMQ escribe mensajes en el disco no al recibirlos, sino peri√≥dicamente, en la regi√≥n de varios cientos de milisegundos.  Cuando la cola se refleja, la confirmaci√≥n se env√≠a solo despu√©s de que todas las r√©plicas tambi√©n hayan escrito su copia del mensaje en el disco.  Esto significa que el uso de reconocimientos aumenta la demora, pero si la seguridad de los datos es importante, entonces son necesarios. <br><br><h1>  Cola de conmutaci√≥n por error </h1><br>  Cuando el intermediario se cierra o se bloquea, todas las colas principales (maestros) en este nodo se caen con √©l.  El cl√∫ster luego selecciona el espejo m√°s antiguo de cada maestro y lo promueve como un nuevo maestro. <br><br><img src="https://habrastorage.org/webt/pq/v_/_a/pqv__ahffpye5i6h_2pdzozyrgi.png"><br>  <i>Fig.</i>  <i>3. Varias colas reflejadas y sus pol√≠ticas.</i> <br><br>  Broker 3 gotas.  Tenga en cuenta que el espejo de la cola C en Broker 2 se actualiza a maestro.  Tambi√©n tenga en cuenta que se ha creado un nuevo espejo para la cola C en el corredor 1. RabbitMQ siempre intenta mantener la tasa de replicaci√≥n especificada en sus pol√≠ticas. <br><br><img src="https://habrastorage.org/webt/df/e7/la/dfe7laf8pyg0pobmrkgteky-wsw.png"><br>  <i>Fig.</i>  <i>4. El corredor 3 se cae, haciendo que la cola C falle</i> <br><br>  ¬°El pr√≥ximo Broker 1 est√° cayendo!  Solo nos queda un corredor.  El espejo de la Cola B se eleva hacia el maestro. <br><br><img src="https://habrastorage.org/webt/b2/bd/qi/b2bdqi_lz21qoe8hcdmsjy8g5kc.png"><br>  <i>Fig.</i>  <i>5 5</i> <br><br>  Devolvimos el Broker 1. No importa cu√°n exitosamente sobrevivieron los datos a la p√©rdida y recuperaci√≥n del broker, todos los mensajes de cola reflejados se descartan al reiniciar.  Es importante tener en cuenta que habr√° consecuencias.  Pronto consideraremos estas consecuencias.  Por lo tanto, el Broker 1 ahora es nuevamente miembro del cl√∫ster, y el cl√∫ster est√° tratando de cumplir con las pol√≠ticas y, por lo tanto, crea espejos en el Broker 1. <br><br>  En este caso, la p√©rdida del Broker 1 se complet√≥, as√≠ como los datos, por lo que la Cola D sin duplicaci√≥n se perdi√≥ por completo. <br><br><img src="https://habrastorage.org/webt/wi/ql/68/wiql68dzsoerzuibhspllun85ec.png"><br>  <i>Fig.</i>  <i>6. El corredor 1 vuelve a estar en servicio</i> <br><br>  Broker 3 vuelve a estar en l√≠nea, por lo que las l√≠neas A y B vuelven a crear espejos para que se ajusten a sus pol√≠ticas de HA.  ¬°Pero ahora todas las l√≠neas principales est√°n en un nodo!  Esto no es ideal; una distribuci√≥n uniforme entre nodos es mejor.  Desafortunadamente, no hay opciones especiales para reequilibrar los maestros.  Volveremos a este problema m√°s tarde, ya que primero debemos considerar la sincronizaci√≥n de la cola. <br><br><img src="https://habrastorage.org/webt/bg/hj/4n/bghj4n6pdd5ki4oideq7zbwmasi.png"><br>  <i>Fig.</i>  <i>7. El corredor 3 vuelve a estar en servicio.</i>  <i>¬°Todas las colas principales en un nodo!</i> <br><br>  Por lo tanto, ahora debe tener una idea de c√≥mo los espejos proporcionan redundancia y tolerancia a fallas.  Esto garantiza la disponibilidad en caso de falla de un solo nodo y protege contra la p√©rdida de datos.  Pero a√∫n no hemos terminado, porque en realidad todo es mucho m√°s complicado. <br><br><h1>  Sincronizaci√≥n </h1><br>  Al crear un nuevo espejo, todos los mensajes nuevos siempre se replicar√°n en este espejo y en cualquier otro.  En cuanto a los datos existentes en la cola principal, podemos replicarlos en un nuevo espejo, que se convierte en una copia completa del maestro.  Tampoco podemos replicar los mensajes existentes y permitir que la cola principal y el nuevo espejo converjan a tiempo cuando lleguen mensajes nuevos a la cola y los mensajes existentes abandonen la cabecera de la cola principal. <br><br>  Esta sincronizaci√≥n se realiza de forma autom√°tica o manual y se controla mediante una pol√≠tica de cola.  Considera un ejemplo. <br><br>  Tenemos dos l√≠neas espejadas.  La cola A se sincroniza autom√°ticamente y la cola B manualmente.  Ambas l√≠neas tienen diez mensajes cada una. <br><br><img src="https://habrastorage.org/webt/vz/zm/5x/vzzm5x_2w3tphqi09kn6h_9_e1c.png"><br>  <i>Fig.</i>  <i>8. Dos colas con diferentes modos de sincronizaci√≥n.</i> <br><br>  Ahora estamos perdiendo Broker 3. <br><br><img src="https://habrastorage.org/webt/5x/wp/ki/5xwpki1aoj_-e1hdt0i-gswn-nu.png"><br>  <i>Fig.</i>  <i>9. El corredor 3 cay√≥</i> <br><br>  Broker 3 vuelve a estar en servicio.  El cl√∫ster crea un espejo para cada cola en el nuevo nodo y sincroniza autom√°ticamente la nueva Cola A con el maestro.  Sin embargo, el espejo del nuevo Turno B permanece vac√≠o.  Por lo tanto, tenemos una redundancia completa de la cola A y solo un espejo para los mensajes existentes de la cola B. <br><br><img src="https://habrastorage.org/webt/zo/hb/ha/zohbhaicbgsjdynexgjhuh70ujg.png"><br>  <i>Fig.</i>  <i>10. El nuevo espejo de la Cola A recibe todos los mensajes existentes, pero el nuevo espejo de la Cola B no</i> <br><br>  Ambas l√≠neas reciben diez mensajes m√°s.  Luego, el corredor 2 cae y la cola A regresa al espejo m√°s antiguo, que se encuentra en el corredor 1. En caso de falla, no hay p√©rdida de datos.  Hay veinte mensajes en la cola B del asistente y solo diez en el espejo, ya que esta cola nunca replic√≥ los diez mensajes originales. <br><br><img src="https://habrastorage.org/webt/yy/hc/sz/yyhcszfowfi6eiidhubgqfy1zry.png"><br>  <i>Fig.</i>  <i>11. La l√≠nea A se revierte al corredor 1 sin perder mensajes</i> <br><br>  Ambas l√≠neas reciben diez mensajes m√°s.  El agente 1 ahora se bloquea. La cola A cambia al espejo sin ning√∫n problema sin perder mensajes.  Sin embargo, la cola B tiene problemas.  En este punto, podemos optimizar la accesibilidad o la coherencia. <br><br>  Si queremos optimizar la accesibilidad, entonces la pol√≠tica de <b><i>promoci√≥n de fallas</i></b> ha debe establecerse como <b><i>siempre</i></b> .  Este es el valor predeterminado, por lo que simplemente puede omitir la pol√≠tica.  En este caso, de hecho, permitimos fallas en espejos no sincronizados.  Esto provocar√° la p√©rdida de mensajes, pero la cola sigue siendo legible y grabable. <br><br><img src="https://habrastorage.org/webt/4h/hv/_n/4hhv_n4seyvz33pq_sk3my2bnmk.png"><br>  <i>Fig.</i>  <i>12. La l√≠nea A se revierte al corredor 3 sin perder mensajes.</i>  <i>La l√≠nea B regresa al corredor 3 con la p√©rdida de diez mensajes</i> <br><br>  Tambi√©n podemos configurar <code>ha-promote-on-failure</code> para <code>when-synced</code> .  En este caso, en lugar de regresar al espejo, la cola esperar√° hasta que el Agente 1 con sus datos vuelva al modo en l√≠nea.  Despu√©s de su regreso, la cola principal aparece nuevamente en el Broker 1 sin p√©rdida de datos.  La accesibilidad se sacrifica por la seguridad de los datos.  Pero este es un modo arriesgado, que incluso puede conducir a una p√©rdida completa de datos, que consideraremos en el futuro cercano. <br><br><img src="https://habrastorage.org/webt/fk/mx/gx/fkmxgxilgyi8bp_n_-osz6q8be0.png"><br>  <i>Fig.</i>  <i>13. La l√≠nea B no est√° disponible despu√©s de perder el corredor 1</i> <br><br>  Puede hacer una pregunta: "¬øQuiz√°s es mejor nunca usar la sincronizaci√≥n autom√°tica?".  La respuesta es que la sincronizaci√≥n es una operaci√≥n de bloqueo.  ¬°Durante la sincronizaci√≥n, la cola principal no puede realizar ninguna operaci√≥n de lectura o escritura! <br><br>  Considera un ejemplo.  Ahora tenemos l√≠neas muy largas.  ¬øC√≥mo pueden crecer a este tama√±o?  Por varias razones: <br><br><ul><li>  Las colas no se usan activamente. <br></li><li>  Estas son l√≠neas de alta velocidad, y en este momento los consumidores son lentos <br></li><li>  Estas son colas de alta velocidad, se produjo un error y los consumidores se est√°n poniendo al d√≠a </li></ul><br><img src="https://habrastorage.org/webt/es/6q/gy/es6qgy7p-1cu0avxb1xivijyjii.png"><br>  <i>Fig.</i>  <i>14. Dos grandes colas con diferentes modos de sincronizaci√≥n.</i> <br><br>  Ahora Broker 3 se bloquea. <br><br><img src="https://habrastorage.org/webt/vg/ta/ue/vgtauedea7kaitatv7oshzottps.png"><br>  <i>Fig.</i>  <i>15. El corredor 3 cae, dejando un maestro y un espejo en cada cola</i> <br><br>  Broker 3 regresa y se crean nuevos espejos.  La cola principal A comienza a replicar los mensajes existentes en un nuevo espejo, y durante este tiempo, la cola A no est√° disponible.  La replicaci√≥n de datos requiere dos horas, lo que resulta en dos horas de tiempo de inactividad para esta cola. <br><br>  Sin embargo, la L√≠nea B permanece disponible durante todo el per√≠odo.  Ella sacrific√≥ algo de redundancia en aras de la accesibilidad. <br><br><img src="https://habrastorage.org/webt/qn/rd/ep/qnrdep5m7sszgxjesb_kfwuw-zw.png"><br>  <i>Fig.</i>  <i>16. La cola no est√° disponible durante la sincronizaci√≥n</i> <br><br>  Despu√©s de dos horas, la Cola A tambi√©n est√° disponible y puede comenzar nuevamente a aceptar operaciones de lectura y escritura. <br><br><h3>  Actualizaciones </h3><br>  Este comportamiento de bloqueo durante la sincronizaci√≥n dificulta la actualizaci√≥n de cl√∫steres con colas muy grandes.  En alg√∫n momento, el nodo con el asistente debe reiniciarse, lo que significa cambiar al espejo o apagar la cola durante la actualizaci√≥n del servidor.  Si elegimos una transici√≥n, perderemos mensajes si los espejos no est√°n sincronizados.  De manera predeterminada, cuando un intermediario est√° deshabilitado, la transici√≥n a un espejo no sincronizado no se realiza.  Esto significa que tan pronto como el corredor regrese, no perdamos ning√∫n mensaje, el √∫nico da√±o fue solo una simple cola.  La desactivaci√≥n de los corredores se rige por la pol√≠tica de <code>ha-promote-on-shutdown</code> .  Puede establecer uno de dos valores: <br><br><ul><li>  <code>always</code> = habilitado para cambiar a espejos no sincronizados <br></li><li>  <code>when-synced</code> = cambia solo al espejo sincronizado, de lo contrario la cola se vuelve inaccesible para leer y escribir.  La cola vuelve tan pronto como regresa el corredor </li></ul><br>  De una forma u otra, con grandes colas, debe elegir entre p√©rdida de datos e inaccesibilidad. <br><br><h3>  Cuando la disponibilidad mejora la seguridad de los datos </h3><br>  Antes de tomar una decisi√≥n, se debe tener en cuenta una complicaci√≥n m√°s.  Si bien la sincronizaci√≥n autom√°tica es mejor para la redundancia, ¬øc√≥mo afecta la seguridad de los datos?  Por supuesto, gracias a una mejor redundancia, RabbitMQ tiene menos probabilidades de perder los mensajes existentes, pero ¬øqu√© pasa con los nuevos mensajes de los editores? <br><br>  Aqu√≠ debe considerar lo siguiente: <br><ul><li>  ¬øPuede un editor devolver un error y un servicio o usuario superior volver√° a intentarlo m√°s tarde? <br></li><li>  ¬øPuede un editor guardar un mensaje localmente o en una base de datos para volver a intentarlo m√°s tarde? </li></ul><br>  Si el editor solo puede soltar el mensaje, de hecho, mejorar la accesibilidad tambi√©n aumenta la seguridad de los datos. <br><br>  Por lo tanto, debe buscar un equilibrio, y la decisi√≥n depende de la situaci√≥n espec√≠fica. <br><br><h1>  Problemas con ha-promote-on-failure = cuando se sincroniza </h1><br>  La idea de <i><b>ha-promote-on-failure</b></i> = <i><b>cuando se sincroniza</b></i> es que evitamos cambiar a un espejo no sincronizado y, por lo tanto, evitamos la p√©rdida de datos.  La cola permanece inaccesible para leer o escribir.  En cambio, tratamos de devolver un corredor ca√≠do con datos no da√±ados para que reanude el trabajo como maestro sin p√©rdida de datos. <br><br>  Pero (y esto es grande pero) si el corredor perdi√≥ sus datos, entonces tenemos un gran problema: ¬°se pierde la cola!  ¬°Todos los datos se han ido!  Incluso si tiene espejos que b√°sicamente se ponen al d√≠a con la cola principal, estos espejos tambi√©n se descartan. <br><br>  Para volver a agregar un nodo con el mismo nombre, le decimos al cl√∫ster que olvide el nodo perdido (con el <i>comando rabbitmqctl forget_cluster_node</i> ) e inicie un nuevo agente con el mismo nombre de host.  Mientras el cl√∫ster recuerde el nodo perdido, recordar√° la cola anterior y los espejos no sincronizados.  Cuando se le dice a un cl√∫ster que olvide un nodo perdido, esta cola tambi√©n se olvida.  Ahora necesita volver a declararlo.  Perdimos todos los datos, aunque ten√≠amos espejos con un conjunto de datos parcial.  ¬°Ser√≠a mejor cambiar a un espejo no sincronizado! <br><br>  Por lo tanto, la sincronizaci√≥n manual (y la falla de sincronizaci√≥n) en combinaci√≥n con <code>ha-promote-on-failure=when-synced</code> , en mi opini√≥n, es bastante arriesgado.  Los documentos dicen que esta opci√≥n existe para la seguridad de los datos, pero es un cuchillo de doble filo. <br><br><h1>  Maestros reequilibrantes </h1><br>  Seg√∫n lo prometido, volvemos al problema de la acumulaci√≥n de todos los maestros en uno o m√°s nodos.  Esto puede suceder incluso como resultado de actualizaciones continuas del cl√∫ster.  En un cl√∫ster con tres nodos, todas las colas principales se acumular√°n en uno o dos nodos. <br><br>  El reequilibrio de los maestros puede ser problem√°tico por dos razones: <br><br><ul><li>  No hay buenas herramientas de reequilibrio </li><li>  Sincronizaci√≥n de cola </li></ul><br>  Para reequilibrar, hay un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">complemento de</a> terceros que no es oficialmente compatible.  Con respecto a los complementos de terceros, el manual de RabbitMQ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dice</a> : ‚ÄúEl complemento proporciona algunas herramientas de configuraci√≥n e informes adicionales, pero el equipo de RabbitMQ no lo admite y no lo prueba.  √öselo bajo su propio riesgo. <br><br>  Hay otro truco para mover la cola principal a trav√©s de las pol√≠ticas de HA.  El manual menciona un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gui√≥n</a> para esto.  Funciona de la siguiente manera: <br><br><ul><li>  Elimina todos los espejos utilizando una pol√≠tica temporal con una prioridad m√°s alta que la pol√≠tica HA existente. <br></li><li>  Cambia la pol√≠tica temporal de HA para usar el modo de nodos con el nodo al que se debe mover la cola principal. <br></li><li>  Sincroniza la cola para la migraci√≥n forzada. <br></li><li>  Una vez completada la migraci√≥n, elimina la pol√≠tica temporal.  La pol√≠tica inicial de HA entra en vigor y se crea el n√∫mero requerido de r√©plicas. </li></ul><br>  La desventaja es que este enfoque puede no funcionar si tiene grandes colas o estrictos requisitos de redundancia. <br><br>  Ahora veamos c√≥mo funcionan los cl√∫steres RabbitMQ con particiones de red. <br><br><h1>  Interrupci√≥n de la conectividad </h1><br>  Los nodos de un sistema distribuido est√°n conectados por enlaces de red, y los enlaces de red pueden y estar√°n desconectados.  La frecuencia de las interrupciones depende de la infraestructura local o de la confiabilidad de la nube seleccionada.  En cualquier caso, los sistemas distribuidos deber√≠an poder manejarlos.  Una vez m√°s, tenemos que elegir entre accesibilidad y coherencia, y una vez m√°s, la buena noticia es que RabbitMQ proporciona ambas (simplemente no al mismo tiempo). <br><br>  Con RabbitMQ, tenemos dos opciones principales: <br><br><ul><li>  Permitir la separaci√≥n l√≥gica (cerebro dividido).  Esto proporciona accesibilidad, pero puede causar p√©rdida de datos. <br></li><li>  No permitir la separaci√≥n l√≥gica.  Puede resultar en una p√©rdida de disponibilidad a corto plazo dependiendo de c√≥mo los clientes se conectan al cl√∫ster.  Tambi√©n puede conducir a la inaccesibilidad completa en un grupo de dos nodos. </li></ul><br>  Pero, ¬øqu√© es la separaci√≥n l√≥gica?  Esto es cuando un cl√∫ster se divide en dos debido a la p√©rdida de conexiones de red.  En cada lado, los espejos se elevan hasta el maestro, por lo que al final, hay varios maestros en cada turno. <br><br><img src="https://habrastorage.org/webt/mi/4f/bb/mi4fbbuk9maj487alkqsbbykkns.png"><br>  <i>Fig.</i>  <i>17. La l√≠nea principal y dos espejos, cada uno en un nodo separado.</i>  <i>Luego ocurre una falla en la red y se separa un espejo.</i>  <i>El nodo separado ve que los otros dos se han ca√≠do y avanza sus espejos hacia el maestro.</i>  <i>Ahora tenemos dos l√≠neas principales, y ambas permiten escribir y leer.</i> <br><br>  Si los editores env√≠an datos a ambos maestros, obtenemos dos copias divergentes de la cola. <br><br>  Los diversos modos RabbitMQ proporcionan accesibilidad o consistencia. <br><br><h3>  Ignorar modo (predeterminado) </h3><br>  Este modo proporciona accesibilidad.  Despu√©s de la p√©rdida de conectividad, se produce una separaci√≥n l√≥gica.  Despu√©s de reconectarse, el administrador debe decidir qu√© partici√≥n prefiere.  El lado perdedor se reiniciar√° y todos los datos acumulados de este lado se perder√°n. <br><br><img src="https://habrastorage.org/webt/ih/rj/ow/ihrjow-ceolx0wy8y2o-cn2yiuk.png"><br>  <i>Fig.</i>  <i>18. Tres editores est√°n asociados con tres corredores.</i>  <i>Internamente, el cl√∫ster reenv√≠a todas las solicitudes a la cola principal en Broker 2.</i> <br><br>  Ahora estamos perdiendo al corredor 3. √âl ve que otros corredores se han ca√≠do y mueve su espejo hacia el maestro.  Esta es la separaci√≥n l√≥gica. <br><br><img src="https://habrastorage.org/webt/u_/l8/af/u_l8af-qqcyv4ldqdgwrn4t22ei.png"><br>  <i>Fig.</i>  <i>19. Separaci√≥n l√≥gica (cerebro dividido).</i>  <i>Los registros van en dos l√≠neas principales, y dos copias divergen.</i> <br><br>  La conectividad se restaura, pero la separaci√≥n l√≥gica permanece.  El administrador debe seleccionar manualmente el lado perdedor.  En el siguiente caso, el administrador reinicia el Broker 3. Todos los mensajes que no logr√≥ transmitir se pierden. <br><br><img src="https://habrastorage.org/webt/_o/a9/ft/_oa9ftbuvl6dwnewtgfkrhkyva4.png"><br>  <i>Fig.</i>  <i>20. El administrador deshabilita el Broker 3.</i> <br><br><img src="https://habrastorage.org/webt/ni/y_/xq/niy_xqsgzuvf5ktcta35z98zzxs.png"><br>  <i>Fig.</i>  <i>21. El administrador inicia el Broker 3, y se une al cl√∫ster, perdiendo todos los mensajes que permanecieron all√≠.</i> <br><br>  Durante la p√©rdida de conectividad y despu√©s de su restauraci√≥n, el cl√∫ster y esta cola estaban disponibles para lectura y escritura. <br><br><h3>  Modo de curaci√≥n autom√°tica </h3><br>  Funciona de manera similar al modo Ignorar, excepto que el cl√∫ster selecciona autom√°ticamente el lado perdedor despu√©s de dividir y restaurar la conectividad.  El lado perdedor regresa al cl√∫ster vac√≠o, y la cola pierde todos los mensajes que se enviaron solo a ese lado. <br><br><h3>  Pausa en modo minoritario </h3><br>  Si no queremos permitir la separaci√≥n l√≥gica, entonces nuestra √∫nica opci√≥n es negarnos a leer y escribir en el lado m√°s peque√±o despu√©s de la partici√≥n del cl√∫ster.  Cuando un corredor ve que est√° en el lado inferior, hace una pausa, es decir, cierra todas las conexiones existentes y rechaza las nuevas.  Una vez por segundo, verifica la reconexi√≥n.  Una vez que se restaura la conectividad, reanuda el trabajo y se une al cl√∫ster. <br><br><img src="https://habrastorage.org/webt/xl/cc/af/xlccafaylyx2nrsz5scaafo1h6u.png"><br>  <i>Fig.</i>  <i>22. Tres editores est√°n asociados con tres corredores.</i>  <i>Internamente, el cl√∫ster reenv√≠a todas las solicitudes a la cola principal en Broker 2.</i> <br><br>  Luego, los corredores 1 y 2 se separan del corredor 3. En lugar de actualizar su espejo a maestro, el corredor 3 se detiene y queda inaccesible. <br><br><img src="https://habrastorage.org/webt/8h/0_/hc/8h0_hc8vj99u6zaht7cgymlckve.png"><br>  <i>Fig.</i>  <i>23. Broker 3 hace una pausa, desconecta a todos los clientes y rechaza las solicitudes de conexi√≥n.</i> <br><br>  Una vez que se restablece la conectividad, vuelve al cl√∫ster. <br><br>  Veamos otro ejemplo, donde la l√≠nea principal est√° en Broker 3. <br><br><img src="https://habrastorage.org/webt/rs/0s/if/rs0siffyxwpdc8imasvfvkapykw.png"><br>  <i>Fig.</i>  <i>24. La l√≠nea principal en Broker 3.</i> <br><br>  Entonces se produce la misma p√©rdida de conectividad.  El corredor 3 hace una pausa porque est√° en el lado m√°s peque√±o.  Por otro lado, los nodos ven que el Broker 3 se ha ca√≠do, por lo que el espejo m√°s antiguo de los Brokers 1 y 2 se eleva al maestro. <br><br><img src="https://habrastorage.org/webt/ba/o3/gr/bao3gr7y31x5ljbbpkqkretaaty.png"><br>  <i>Fig.</i>  <i>25. Transici√≥n al corredor 2 si el corredor 3 no est√° disponible.</i> <br><br>  Cuando se restablezca la conectividad, Broker 3 se unir√° al cl√∫ster. <br><br><img src="https://habrastorage.org/webt/3z/rp/3k/3zrp3knvfoew7m25bg6bg4dlhju.png"><br>  <i>Fig.</i>  <i>26. El cl√∫ster volvi√≥ a la operaci√≥n normal.</i> <br><br>  Es importante comprender que estamos obteniendo coherencia, pero tambi√©n podemos obtener accesibilidad <i><b>si</b></i> transferimos con √©xito a los clientes a la mayor parte de la secci√≥n.  Para la mayor√≠a de las situaciones, personalmente elegir√≠a el modo Pausa Minoritaria, pero realmente depende del caso particular. <br><br>  Para garantizar la disponibilidad, es importante asegurarse de que los clientes se conecten con √©xito al sitio.  Considera nuestras opciones. <br><br><h1>  Conectividad del cliente </h1><br>  Tenemos varias opciones sobre c√≥mo, despu√©s de perder la conectividad, enviar clientes a la parte principal del cl√∫ster o a los nodos de trabajo (despu√©s de una falla de un nodo).  Primero, recordemos que una cola particular est√° alojada en un host particular, pero el enrutamiento y las pol√≠ticas se replican en todos los hosts.  Los clientes pueden conectarse a cualquier nodo, y el enrutamiento interno los dirigir√° cuando sea necesario.  Pero cuando se suspende un nodo, rechaza la conexi√≥n, por lo que los clientes deben conectarse a otro nodo.  Si un nodo se cae, puede hacer poco. <br><br>  Nuestras opciones: <br><br><ul><li>  Se accede al cl√∫ster utilizando un equilibrador de carga, que simplemente recorre los nodos y los clientes hacen intentos repetidos de conectarse hasta que se completan con √©xito.      ,        ,        (  ).         ,    . <br></li><li>         /   ,    .    ,        ,     . <br></li><li>      ,          .       ,       ,   . <br></li><li>    /    DNS.      TTL. </li></ul><br><h1>  Conclusiones </h1><br>   RabbitMQ    .      , : <br><br><ul><li>        ; <br></li><li>      . </li></ul><br>         .   RabbitMQ      ,     .        ,     .         RabbitMQ        .      RabbitMQ     : <br><br><ul><li>  . <br></li><li>  . <br></li><li>   . </li></ul><br>      ,   : <br><br><ul><li> <code>ha-promote-on-failure=always</code> <br> </li><li> <code>ha-sync-mode=manual</code> <br> </li><li> <code>cluster_partition_handling=ignore</code> ( <code>autoheal</code> ) <br></li><li>   <br></li><li> ,      ,  -     </li></ul><br>   ( )   : <br><br><ul><li> Publisher Confirms  Manual Acknowledgements    <br></li><li> <code>ha-promote-on-failure=when-synced</code> ,              !   <code>=always</code> . <br></li><li> <code>ha-sync-mode=automatic</code> (        ;  , ,       ) <br></li><li>  Pause Minority <br></li><li>   </li></ul><br>          ; ,      (,   ).        Shovel. <br><br>    - , ,  . <br><br> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> ,       RabbitMQ   Docker  Blockade,      ,    . <br><br>   : <br> ‚Ññ1 ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">habr.com/ru/company/itsumma/blog/416629</a> <br> ‚Ññ2 ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">habr.com/ru/company/itsumma/blog/418389</a> <br> ‚Ññ3 ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">habr.com/ru/company/itsumma/blog/437446</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/471858/">https://habr.com/ru/post/471858/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../471840/index.html">¬øPor qu√© ir a entrevistas?</a></li>
<li><a href="../471844/index.html">5 razones para visitar EPAM INSIDER en Kazajst√°n</a></li>
<li><a href="../471852/index.html">Noticias del mundo de OpenStreetMap No. 481 (01/10/2019 - 07/10/2019)</a></li>
<li><a href="../471854/index.html">Heat Death 5G</a></li>
<li><a href="../471856/index.html">Resolvemos las 42 versiones del rompecabezas de pociones de Harry Potter</a></li>
<li><a href="../471860/index.html">Analizadores de clavijas</a></li>
<li><a href="../471864/index.html">Generador de analizador PEG</a></li>
<li><a href="../471866/index.html">Visualizaci√≥n del analizador PEG</a></li>
<li><a href="../471868/index.html">Gen√©tica del amor: conflicto entre g√©neros como base para la cooperaci√≥n en parejas de p√°jaros mon√≥gamos</a></li>
<li><a href="../471870/index.html">Uso efectivo de libdispatch</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>