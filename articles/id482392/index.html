<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí± ü§æüèø üõ∂ Trik ELF di Go üßõüèæ üâê üëäüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam catatan ini, kita akan belajar cara mendapatkan kode mesin dari fungsi Go secara langsung dalam runtime, mencetaknya menggunakan disassembler, d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Trik ELF di Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482392/"><p><img src="https://habrastorage.org/webt/hd/mj/7h/hdmj7hkb2kyjkyyybccynazhd7s.png"></p><br><p>  Dalam catatan ini, kita akan belajar cara mendapatkan kode mesin dari fungsi Go secara langsung dalam runtime, mencetaknya menggunakan disassembler, dan di sepanjang jalan kita akan menemukan beberapa trik seperti mendapatkan alamat fungsi tanpa memanggilnya. </p><br><p>  <strong>Peringatan</strong> : artikel mini ini tidak akan mengajarkan Anda sesuatu yang berguna. </p><a name="habracut"></a><br><h1 id="function-value-v-go">  Nilai fungsi di Go </h1><br><p>  Pertama, mari kita tentukan apa fungsi Go dan mengapa kita membutuhkan konsep <strong>nilai fungsi</strong> . </p><br><p>  Ini paling baik dijelaskan oleh dokumen <a href="https://golang.org/s/go11func" rel="nofollow">Panggilan Fungsi Go 1.1</a> .  Dokumen ini bukan baru, tetapi sebagian besar informasi di dalamnya masih relevan. </p><br><p> Pada level terendah, selalu merupakan pointer ke kode yang dapat dieksekusi, tetapi ketika kita menggunakan fungsi / penutupan anonim atau meneruskan fungsi sebagai <code>interface{}</code> , pointer ini tersembunyi di dalam beberapa struktur. </p><br><p>  Nama fungsi itu sendiri bukan ekspresi, oleh karena itu, kode tersebut tidak berfungsi: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// https://play.golang.org/p/wXeVLU7nLPs package main func add1(x int) int { return 1 } func main() { addr := &amp;add1 println(addr) }</span></span></code> </pre> <br><blockquote> <code>compile: cannot take the address of add1</code> </blockquote> <p>  Tetapi pada saat yang sama kita bisa mendapatkan <code>function value</code> melalui nama fungsi yang sama: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// https://play.golang.org/p/oWqv_FQq4hy package main func add1(x int) int { return 1 } func main() { f := add1 // &lt;-------- addr := &amp;f println(addr) }</span></span></code> </pre> <br><p>  Kode ini diluncurkan, tetapi akan mencetak alamat variabel lokal pada stack, yang tidak persis seperti yang kita inginkan.  Tetapi, seperti yang disebutkan di atas, alamat fungsi masih ada, Anda hanya perlu tahu cara mengaksesnya. </p><br><p>  Paket <a href="https://golang.org/pkg/reflect/" rel="nofollow"><code>reflect</code></a> tergantung pada detail implementasi ini untuk berhasil menjalankan <a href="https://golang.org/pkg/reflect/" rel="nofollow"><code>reflect.Value.Call()</code></a> .  <a href="" rel="nofollow">Di sana (mencerminkan / makefunc.go)</a> Anda dapat memata-matai langkah selanjutnya untuk mendapatkan alamat fungsi: </p><br><pre> <code class="go hljs">dummy := makeFuncStub code := **(**<span class="hljs-keyword"><span class="hljs-keyword">uintptr</span></span>)(unsafe.Pointer(&amp;dummy))</code> </pre> <br><p>  Kode di atas menunjukkan gagasan dasar bahwa Anda dapat memperbaiki ke suatu fungsi: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// funcAddr returns function value fn executable code address. func funcAddr(fn interface{}) uintptr { // emptyInterface is the header for an interface{} value. type emptyInterface struct { typ uintptr value *uintptr } e := (*emptyInterface)(unsafe.Pointer(&amp;fn)) return *e.value }</span></span></code> </pre> <br><p>  <code>add1</code> fungsi <code>add1</code> dapat <code>add1</code> dengan memanggil <code>funcAddr(add1)</code> . </p><br><h1 id="poluchenie-bloka-mashinnogo-koda-funkcii">  Mendapatkan blok kode fungsi mesin </h1><br><p>  Sekarang kita memiliki alamat awal kode mesin fungsi, kami ingin mendapatkan seluruh kode mesin fungsi.  Di sini Anda harus dapat menentukan di mana kode fungsi saat ini berakhir. </p><br><p>  Jika arsitektur x86 memiliki instruksi panjang tetap, itu tidak akan terlalu sulit dan beberapa heuristik dapat membantu kami, di antaranya: </p><br><ul><li>  Sebagai aturan, pada akhir kode fungsi ada pemukulan dari instruksi <a href="https://en.wikipedia.org/wiki/INT_(x86_instruction)" rel="nofollow"><code>INT3</code></a> .  Ini adalah penanda yang baik untuk akhir kode fungsi, tetapi mungkin tidak ada. </li><li>  Fungsi dengan frame non-nol untuk stack memiliki prolog yang memeriksa apakah stack ini perlu diperluas.  Jika ya, maka lompatan ke kode dilakukan segera setelah kode fungsi, dan kemudian lompatan ke awal fungsi.  Kode yang kami minati akan berada di tengah. </li></ul><br><p>  Tetapi Anda harus secara jujur ‚Äã‚Äãmendekode instruksi, karena byte-by-pass dapat menemukan byte <code>INT3</code> di dalam instruksi lain.  Menghitung panjang instruksi untuk dilewati juga tidak mudah, <a href="https://stackoverflow.com/questions/45801447/x86-assembly-how-to-calculate-instruction-opcodes-length-in-bytes" rel="nofollow">karena itu x86, sayang</a> . </p><br><p>  Alamat suatu fungsi dalam konteks paket <a href="https://golang.org/pkg/runtime" rel="nofollow"><code>runtime</code></a> kadang-kadang disebut <code>PC</code> , untuk menekankan kemampuan untuk menggunakan alamat di suatu tempat di dalam fungsi, dan bukan hanya titik masuk dari fungsi.  Hasil <code>funcAddr</code> dapat digunakan sebagai argumen untuk fungsi <a href="https://golang.org/pkg/runtime/" rel="nofollow"><code>runtime.FuncForPC()</code></a> untuk mendapatkan <a href="https://golang.org/pkg/runtime/" rel="nofollow"><code>runtime.Func</code></a> tanpa memanggil fungsi itu sendiri.  Melalui transformasi Tahun Baru yang tidak aman, kita dapat mengakses <a href="https://play.golang.org/p/lQxxK36ZXru" rel="nofollow"><code>runtime._func</code></a> , yang informatif, tetapi tidak terlalu berguna: tidak ada informasi tentang ukuran blok kode fungsi. </p><br><p>  Tampaknya tanpa bantuan <a href="https://golang.org/pkg/debug/elf/" rel="nofollow">ELF</a> kita tidak bisa mengatasinya. </p><br><blockquote>  Untuk platform di mana executable memiliki format berbeda, sebagian besar artikel akan tetap relevan, tetapi Anda harus menggunakan bukan <a href="https://golang.org/pkg/debug/elf/" rel="nofollow"><code>debug/elf</code></a> , tetapi paket lain dari <a href="https://golang.org/pkg/debug/" rel="nofollow"><code>debug</code></a> . </blockquote><br><h1 id="elf-kotoryy-pryachetsya-v-vashey-programme">  ELF yang bersembunyi di program Anda </h1><br><p>  Informasi yang kami butuhkan sudah terkandung dalam metadata file <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" rel="nofollow">ELF</a> . </p><br><p>  Melalui <a href="https://golang.org/pkg/os/" rel="nofollow"><code>os.Args[0]</code></a> kita dapat mengakses file yang dapat dieksekusi itu sendiri, dan sudah mendapatkan tabel simbol darinya. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readELF</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*elf.File, error)</span></span></span></span> { f, err := os.Open(os.Args[<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"open argv[0]: %w"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elf.NewFile(f) }</code> </pre> <br><h1 id="poisk-simvola-vnutri-elffilehttpsgolangorgpkgdebugelffile">  Cari karakter di dalam <a href="https://golang.org/pkg/debug/elf/" rel="nofollow"><code>elf.File</code></a> </h1><br><p>  Semua karakter dapat <a href="https://golang.org/pkg/debug/elf/" rel="nofollow"><code>File.Symbols()</code></a> menggunakan metode <a href="https://golang.org/pkg/debug/elf/" rel="nofollow"><code>File.Symbols()</code></a> .  Metode ini mengembalikan <a href="https://golang.org/pkg/debug/elf/" rel="nofollow"><code>[]elf.Symbol</code></a> , yang berisi bidang <code>Symbol.Size</code> - ini adalah "ukuran fungsi" yang kita <code>Symbol.Size</code> .  Bidang <code>Symbol.Value</code> harus cocok dengan nilai yang dikembalikan oleh <code>funcAddr</code> . </p><br><p>  Anda dapat mencari simbol yang diinginkan baik dengan alamat ( <code>Symbol.Value</code> ) atau dengan nama ( <code>Symbol.Name</code> ).  Jika karakter diurutkan berdasarkan nama, dimungkinkan untuk menggunakan <a href="https://golang.org/pkg/sort/" rel="nofollow"><code>sort.Search()</code></a> , tetapi ini tidak begitu: </p><br><blockquote>  Simbol akan dicantumkan sesuai urutan yang muncul dalam file. </blockquote><p>  Jika Anda sering perlu menemukan karakter dalam tabel, Anda harus membuat indeks tambahan, misalnya, melalui <code>map[string]*elf.Symbol</code> atau <code>map[uintptr]*elf.Symbol</code> . </p><br><p>  Karena kita sudah tahu cara mendapatkan alamat suatu fungsi berdasarkan nilainya, kita akan mencarinya: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elfLookup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f *elf.File, value </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elf</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Symbol</span></span></span></span> { symbols, err := f.Symbols() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, sym := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> symbols { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sym.Value == value { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;sym } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><blockquote>  <strong>Catatan</strong> : agar pendekatan ini berfungsi, kita membutuhkan tabel karakter.  Jika biner dibangun dengan ` <code>-ldflags "-s"</code> ', maka <code>elfLookup()</code> akan selalu mengembalikan <code>nil</code> .  Jika Anda menjalankan program melalui <code>go run</code> Anda dapat mengalami masalah yang sama.  Untuk contoh dari artikel ini, disarankan untuk melakukan ' <code>go build</code> ' atau ' <code>go install</code> ' untuk mendapatkan file yang dapat dieksekusi. </blockquote><br><h1 id="poluchenie-mashinnogo-koda-funkcii">  Mendapatkan kode fungsi mesin </h1><br><p>  Mengetahui kisaran alamat di mana kode yang dapat dieksekusi terletak, tetap hanya untuk menariknya dalam bentuk <code>[]byte</code> untuk pemrosesan yang mudah. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">funcCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uintptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { elffile, err := readELF() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"read elf: %w"</span></span>, err) } sym := elfLookup(elffile, <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>(addr)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sym == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"can't lookup symbol for %x"</span></span>, addr) } code := *(*[]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(unsafe.Pointer(&amp;reflect.SliceHeader{ Data: addr, Len: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(sym.Size), Cap: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(sym.Size), })) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> code, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  Kode ini sengaja disederhanakan untuk demonstrasi.  Anda tidak harus membaca <code>ELF</code> setiap kali dan melakukan pencarian linear di atas meja. </p><br><p>  Hasil dari fungsi <code>funcCode()</code> adalah irisan dengan byte dari kode fungsi mesin.  Dia harus <code>funcAddr()</code> hasil pemanggilan <code>funcAddr()</code> . </p><br><pre> <code class="go hljs">code, err := funcCode(funcAddr(add1)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Panicf(<span class="hljs-string"><span class="hljs-string">"can't get function code: %v"</span></span>, err) } fmt.Printf(<span class="hljs-string"><span class="hljs-string">"% x\n"</span></span>, code) <span class="hljs-comment"><span class="hljs-comment">// =&gt; 48 8b 44 24 08 48 ff c0 48 89 44 24 10 c3</span></span></code> </pre> <br><h1 id="dizassemblirovanie-mashinnogo-koda">  Membongkar kode mesin </h1><br><p>  Untuk membuat kode mesin lebih mudah dibaca, kami akan menggunakan disassembler. </p><br><p>  Saya paling akrab dengan proyek <a href="https://github.com/zyantific/zydis" rel="nofollow">zydis</a> dan <a href="https://github.com/intelxed/xed" rel="nofollow">Intel XED</a> , jadi pertama-tama pilihan saya jatuh pada mereka. </p><br><p>  Untuk Go, Anda dapat mengambil <a href="https://github.com/jpap/go-zydis" rel="nofollow">go-zydis binding</a> , yang cukup bagus dan mudah dipasang untuk tugas kami. </p><br><p>  Mari kita gambarkan abstraksi "melewati instruksi mesin", dengan bantuan yang memungkinkan untuk mengimplementasikan operasi lain: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">walkDisasm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(code []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, visit </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(*zydis.DecodedInstruction)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { dec := zydis.NewDecoder(zydis.MachineMode64, zydis.AddressWidth64) buf := code <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(buf) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { instr, err := dec.Decode(buf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := visit(instr); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } buf = buf[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(instr.Length):] } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  Fungsi ini mengambil irisan kode mesin sebagai input dan memanggil fungsi callback untuk setiap instruksi yang diterjemahkan. </p><br><p>  Berdasarkan itu, kita dapat menulis <code>printDisasm</code> kita <code>printDisasm</code> : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printDisasm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(code []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ZYDIS_RUNTIME_ADDRESS_NONE = math.MaxUint64 formatter, err := zydis.NewFormatter(zydis.FormatterStyleIntel) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> walkDisasm(code, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(instr *zydis.DecodedInstruction)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { s, err := formatter.FormatInstruction(instr, ZYDIS_RUNTIME_ADDRESS_NONE) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } fmt.Println(s) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }) }</code> </pre> <br><p>  Jika kita menjalankan <code>printDisasm</code> pada <code>add1</code> fungsi <code>add1</code> , kita mendapatkan hasil yang sudah lama ditunggu-tunggu: </p><br><pre> <code class="plaintext hljs">mov rax, [rsp+0x08] inc rax mov [rsp+0x10], rax ret</code> </pre> <br><h2 id="validaciya-rezultata">  Validasi hasil </h2><br><p>  Sekarang kita akan mencoba memastikan bahwa kode assembler yang diperoleh di bagian sebelumnya sudah benar. </p><br><p>  Karena kami sudah memiliki biner terkompilasi, Anda dapat menggunakan <code>objdump</code> disertakan dengan Go: </p><br><pre> <code class="bash hljs">$ go tool objdump -s <span class="hljs-string"><span class="hljs-string">'add1'</span></span> exe TEXT main.add1(SB) example.go example.go:15 0x4bb760 488b442408 MOVQ 0x8(SP), AX example.go:15 0x4bb765 48ffc0 INCQ AX example.go:15 0x4bb768 4889442410 MOVQ AX, 0x10(SP) example.go:15 0x4bb76d c3 RET</code> </pre> <br><p>  Semuanya bertemu, hanya sintaks yang sedikit berbeda, yang diharapkan. </p><br><h1 id="method-expressions">  Ekspresi metode </h1><br><p>  Jika kita perlu melakukan hal yang sama dengan metode, maka alih-alih nama fungsi kita akan menggunakan <a href="https://golang.org/ref/spec" rel="nofollow">ekspresi metode</a> . </p><br><p>  Katakanlah <code>add1</code> kami <code>add1</code> bukan fungsi, tetapi metode jenis <code>adder</code> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> adder <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(adder)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + <span class="hljs-number"><span class="hljs-number">2</span></span> }</code> </pre> <br><p>  Maka panggilan untuk mendapatkan alamat fungsi akan terlihat seperti <code>funcAddr(adder.add1)</code> . </p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>  Saya sampai pada hal-hal ini bukan karena kebetulan dan, mungkin, dalam salah satu artikel berikut ini saya akan memberi tahu Anda bagaimana rencananya akan menggunakan semua mekanisme ini.  Sementara itu, saya sarankan memperlakukan catatan ini sebagai deskripsi dangkal tentang bagaimana <code>runtime</code> dan <code>reflect</code> melihat fungsi Go kami melalui nilai fungsi. </p><br><p>  Daftar sumber daya yang digunakan: </p><br><ul><li>  <a href="https://golang.org/s/go11func" rel="nofollow">Go 1.1 Panggilan Fungsi</a> </li><li>  <a href="https://www.pnfsoftware.com/blog/analyzing-golang-executables/" rel="nofollow">Menganalisis Golang Executables</a> </li><li>  <a href="" rel="nofollow">Pergi desain "ABI internal"</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id482392/">https://habr.com/ru/post/id482392/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id482378/index.html">Sejarah singkat Wacom: bagaimana teknologi tablet grafis sampai pada pembaca elektronik</a></li>
<li><a href="../id482382/index.html">Empat prinsip terjemahan, atau dengan cara apa seseorang tidak akan menyerah pada penerjemah mesin?</a></li>
<li><a href="../id482384/index.html">Proyek saya yang belum direalisasi. Jaringan 200 MikroTik Router</a></li>
<li><a href="../id482386/index.html">Visual Studio untuk Mac: Kendalikan IDE Anda dengan Keybindings</a></li>
<li><a href="../id482390/index.html">Tutorial dari tutorial Ember.js. Aplikasi Super Rentals. Bagian 1.2</a></li>
<li><a href="../id482396/index.html">Bagaimana memilih kursus komersial yang mengajarkan profesi IT</a></li>
<li><a href="../id482398/index.html">Replikasi logis dari PostgreSQL ke Erlang</a></li>
<li><a href="../id482402/index.html">Pola pabrik. Contoh aplikasi dalam Unity</a></li>
<li><a href="../id482404/index.html">Mnemonik: menjelajahi metode untuk meningkatkan memori otak</a></li>
<li><a href="../id482406/index.html">Buku DLC Teratas untuk Seri Fiksi Ilmiah Modern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>