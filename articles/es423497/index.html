<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç´ ‚õπÔ∏è ‚¨õÔ∏è Tratemos de hablar sobre m√°quinas de estado jer√°rquicas en general y su soporte en SObjectizer-5 en particular üíπ üë®üèª‚Äçüöí ‚ôªÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Las m√°quinas de estados finitos son quiz√°s uno de los conceptos m√°s fundamentales y ampliamente utilizados en la programaci√≥n. Las m√°quinas de estado ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tratemos de hablar sobre m√°quinas de estado jer√°rquicas en general y su soporte en SObjectizer-5 en particular</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423497/">  Las m√°quinas de estados finitos son quiz√°s uno de los conceptos m√°s fundamentales y ampliamente utilizados en la programaci√≥n.  Las m√°quinas de estado finito (KA) se utilizan activamente en muchos nichos aplicados.  En particular, en nichos como APCS y telecomunicaciones, con los que fue posible tratar, las naves espaciales se encuentran con un poco menos de frecuencia que en cada paso. <br><br>  Por lo tanto, en este art√≠culo intentaremos hablar sobre naves espaciales, principalmente sobre m√°quinas de estados finitos jer√°rquicos y sus capacidades avanzadas.  Y cuente un poco sobre el soporte para naves espaciales en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SObjectizer-5</a> , el marco "actor" para C ++.  Uno de esos <s>dos</s> pocos que est√°n abiertos, libres, multiplataforma y a√∫n vivos. <br><br>  Incluso si no est√° interesado en SObjectizer, pero nunca ha o√≠do hablar de m√°quinas de estados finitos jer√°rquicos o de lo √∫tiles que son las funciones avanzadas de la nave espacial como manejadores de entrada / salida para estados o la historia del estado, entonces puede estar interesado en mirar debajo del gato y lea al menos la primera parte del art√≠culo. <br><a name="habracut"></a><br><h1>  Palabras generales sobre m√°quinas de estados finitos </h1><br>  No trataremos de llevar a cabo un programa educativo completo en el art√≠culo sobre el tema de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aut√≥matas</a> y una variedad tal como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">m√°quinas de estados finitos</a> .  El lector debe tener al menos una comprensi√≥n b√°sica de este tipo de entidades. <br><br><h2>  M√°quinas avanzadas de estados finitos y sus capacidades. </h2><br>  La nave espacial tiene varias caracter√≠sticas "avanzadas" que aumentan en gran medida la usabilidad de la nave espacial en el programa.  Echemos un vistazo r√°pido a estas funciones "avanzadas". <br><br>  Descargo de responsabilidad: si el lector conoce bien los diagramas de estado de UML, entonces no encontrar√° nada nuevo para √©l aqu√≠. <br><br><h3>  M√°quinas de estado jer√°rquico </h3><br>  Quiz√°s la oportunidad m√°s importante y valiosa es la organizaci√≥n de una jerarqu√≠a / anidaci√≥n de estados.  Dado que es precisamente la capacidad de poner estados entre s√≠ lo que elimina la "explosi√≥n" del n√∫mero de transiciones de un estado a otro a medida que aumenta la complejidad de la nave espacial. <br><br>  Es m√°s dif√≠cil explicar esto con palabras que mostrar con el ejemplo.  Por lo tanto, imaginemos que tenemos un infokiosk en la pantalla del cual se muestra primero un mensaje de bienvenida.  El usuario puede seleccionar el elemento "Servicios" e ir a la secci√≥n para seleccionar los servicios que necesita.  O puede seleccionar el elemento "Cuenta personal" e ir a la secci√≥n sobre c√≥mo trabajar con sus datos y servicios personales.  O puede seleccionar la secci√≥n de Ayuda.  Hasta ahora, todo parece ser simple y puede representarse mediante el siguiente diagrama de estado (lo m√°s simplificado posible): <br><br><img src="https://habrastorage.org/webt/6e/lv/bm/6elvbm4wcsbmfbjaasp8zynjmtw.png"><br><br>  Pero tratemos de asegurarnos de que al hacer clic en el bot√≥n "Cancelar", el usuario pueda regresar de cualquier secci√≥n a la p√°gina de inicio con un mensaje de bienvenida: <br><br><img src="https://habrastorage.org/webt/ok/hn/u3/okhnu3xrsjiss8u1fl1gygirn9u.png"><br><br>  El esquema se est√° volviendo complicado, pero a√∫n est√° bajo control.  Sin embargo, recordemos que en la secci√≥n "Servicios" podemos tener varias subsecciones m√°s, por ejemplo, "Servicios populares", "Nuevos servicios" y "Lista completa".  Y de cada una de estas secciones tambi√©n debe volver a la p√°gina de inicio.  Nuestra nave espacial simple se est√° volviendo cada vez m√°s dif√≠cil: <br><br><img src="https://habrastorage.org/webt/ic/zx/hu/iczxhus-j_5ohrzwdxpbdf5n2qi.png"><br><br>  Pero esto est√° lejos de todo.  Todav√≠a no hemos tenido en cuenta el bot√≥n "Atr√°s", por el cual debemos volver a la secci√≥n anterior.  Agreguemos una reacci√≥n al bot√≥n "Atr√°s" y veamos qu√© obtenemos: <br><br><img src="https://habrastorage.org/webt/mn/rq/t7/mnrqt7zjk8kyq6e3i1-jb9fgwya.png"><br><br>  S√≠, ahora vemos el camino hacia la verdadera diversi√≥n.  Pero ni siquiera hemos considerado las subsecciones en las secciones "Mi cuenta" y "Ayuda" ... Si comenzamos, entonces casi de inmediato, nuestra simple nave espacial, al principio, se convertir√° en algo inimaginable. <br><br>  Aqu√≠ la anidaci√≥n de estados viene en nuestra ayuda.  Imaginemos que solo tenemos dos estados de nivel superior: WelcomeScreen y UserSelection.  Todas nuestras secciones (es decir, "Servicios", "Mi cuenta" y "Ayuda") estar√°n "anidadas" en el estado de Selecci√≥n de usuario.  Puede decir que los estados de ServicesScreen, ProfileScreen y HelpScreen ser√°n hijos de UserSelection.  Y como son ni√±os, heredar√°n la reacci√≥n a algunas se√±ales de su estado parental.  Por lo tanto, podemos definir la respuesta al bot√≥n Cancelar en UserSelection.  Pero no necesitamos determinar esta reacci√≥n en todos los subestados subsidiarios.  Lo que hace que nuestra nave espacial sea m√°s concisa y comprensible: <br><br><img src="https://habrastorage.org/webt/lx/nb/qn/lxnbqn3kqv9rst-fbebmx1kxhi8.png"><br><br>  Aqu√≠ puede observar que la reacci√≥n para "Cancelar" y "Atr√°s" la definimos en UserSelection.  Y esta reacci√≥n al bot√≥n Cancelar funciona para todos sin excepci√≥n de los subestados de UserSelection (incluido otro subestado de ServicesSelection compuesto).  Pero en el subestado de ServicesSelection, la reacci√≥n al bot√≥n Atr√°s ya es diferente: el retorno no est√° en WelcomScreen, sino en ServicesScreen. <br><br>  Las CA que usan una jerarqu√≠a / anidamiento de estados se denominan m√°quinas jer√°rquicas de estado finito (ICA). <br><br><h3>  Reacci√≥n a la entrada / salida hacia / desde el estado </h3><br>  Una caracter√≠stica muy √∫til es la capacidad de asignar una respuesta al entrar en un estado particular, as√≠ como una reacci√≥n al salir de un estado.  Entonces, en el ejemplo anterior con un infokiosk, se puede colgar un controlador para ingresar a cada uno de los estados, lo que cambiar√° el contenido de la pantalla del infokiosk. <br><br>  El ejemplo anterior se puede ampliar un poco.  Supongamos que tenemos dos subestados en WelcomScreen: BrightWelcomScreen, en el que la pantalla se resaltar√° normalmente, y DarkWelcomScreen, en el que se reducir√° el brillo de la pantalla.  Podemos hacer un controlador de entrada DarkWelcomScreen que atenuar√° la pantalla.  Y un controlador de salida DarkWelcomScreen que restaurar√° el brillo normal. <br><br><img src="https://habrastorage.org/webt/qm/n0/2y/qmn02yrt9xxxmmawcpzufiexrpg.png"><br><br><h3>  Cambio autom√°tico de estado despu√©s de un tiempo establecido </h3><br>  A veces, puede ser necesario limitar la permanencia de la nave espacial en un estado particular.  Entonces, en el ejemplo anterior, podemos limitar el tiempo que nuestro ICA permanece en el estado de BrightWelcomScreen a un minuto.  Tan pronto como expire el minuto, el ICA cambia autom√°ticamente al estado DarkWelcomScreen. <br><br><h3>  Historia de naves espaciales </h3><br>  Otra caracter√≠stica muy √∫til de ICA es la historia del estado de la nave espacial. <br><br>  Imaginemos que tenemos alg√∫n tipo de ICA abstracto de este tipo: <br><br><img src="https://habrastorage.org/webt/6i/6n/bl/6i6nblfh7l89fzaulpzsa3mo4a4.png"><br><br>  Este nuestro ICA puede ir de TopLevelState1 a TopLevelState2 y viceversa.  Pero dentro de TopLevelState1 hay varios estados anidados.  Si el ICA simplemente se mueve de TopLevelState2 a TopLevelState1, se activan dos estados inmediatamente: TopLevelState1 y NestedState1.  NestedState1 se activa porque es el subestado inicial del estado TopLevelState1. <br><br>  Ahora imagine que a√∫n m√°s nuestro ICA cambi√≥ su estado de NestedState1 a NestedState2.  Dentro de NestedState2, se activ√≥ el SubState InternalState1 (ya que es el subestado inicial de NestedState2).  Y desde InternalState1 fuimos a InternalState2.  Por lo tanto, simult√°neamente tenemos activos los siguientes estados: TopLevelState1, NestedState2 e InternalState2.  Y aqu√≠ vamos a TopLevelState2 (es decir, generalmente dejamos TopLevelState1). <br><br>  Activo se convierte en TopLevelState2.  Despu√©s de lo cual queremos volver a TopLevelState1.  Est√° en TopLevelState1, y no en ning√∫n subestado particular en TopLevelState1. <br><br>  Entonces, desde TopLevelState2 vamos a TopLevelState1 y ¬øa d√≥nde llegamos? <br><br>  Si TopLevelState1 no tiene historial, llegaremos a TopLevelState1 y NestedState1 (ya que NestedState1 es el subestado inicial de TopLevelState1).  Es decir  toda la historia sobre las transiciones dentro de TopLevelState1, que tuvo lugar antes de abandonar TopLevelState2, se perdi√≥ por completo. <br><br>  Si TopLevelState1 tiene un llamado  historial poco profundo, luego, al regresar de TopLevelState2 a TopLevelState1, ingresamos en NestedState2 e InternalState1.  Entramos en NestedState2 porque est√° registrado en el historial de estado de TopLevelState1.  Y llegamos a InternalState1 porque es el inicio de NestedState2.  Resulta que en la historia superficial de TopLevelState1, la informaci√≥n se almacena solo sobre los subestados del primer nivel.  La historia de los estados integrados en estos subestados no se conserva. <br><br>  Pero si TopLevelState1 tiene un historial profundo, entonces cuando volvemos de TopLevelState2 a TopLevelState1 nos metemos en NestedState2 e InternalState2.  Porque en una historia profunda, se almacena informaci√≥n completa sobre los subestados activos, independientemente de su profundidad. <br><br><h3>  Estados ortogonales </h3><br>  Hasta ahora, hemos examinado ICA en el que solo uno de los subestados podr√≠a estar activo dentro del estado.  Pero a veces puede haber situaciones en las que en un estado particular de ICA deber√≠a haber varios subestados activos simult√°neamente.  Dichos subestados se denominan estados ortogonales. <br><br>  Un ejemplo cl√°sico que demuestra estados ortogonales es el teclado de computadora familiar y sus modos NumLock, CapsLock y ScrollLock.  Podemos decir que el trabajo con NumLock / CapsLock / ScrollLock se describe en subestados ortogonales dentro del estado Activo: <br><br><img src="https://habrastorage.org/webt/hv/kf/8p/hvkf8p_gqijakghmndndhlileag.png"><br><br><h3>  Todo lo que quer√≠as saber sobre las m√°quinas de estados finitos, pero ... </h3><br>  En general, hay un art√≠culo fundamental sobre notaci√≥n formal para diagramas de estado de David Harel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Statecharts: A Visual Formalism For Complex Systems (1987)</a> . <br><br>  All√≠, se examinan varias situaciones que se pueden encontrar al trabajar con m√°quinas de estados finitos utilizando el ejemplo de controlar un reloj electr√≥nico ordinario.  Si alguien no lo ha le√≠do, lo recomiendo encarecidamente.  B√°sicamente, todo lo que Harel describi√≥ luego entr√≥ en notaci√≥n UML.  Pero cuando lee la descripci√≥n de los diagramas de estado del UML, no siempre comprende qu√©, por qu√© y cu√°ndo lo necesita.  Pero en el art√≠culo de Harel, la presentaci√≥n va desde situaciones simples a situaciones m√°s complejas.  Y conoce mejor toda la potencia que las m√°quinas de estados finitos esconden en s√≠ mismas. <br><br><h1>  M√°quinas de estados finitos en SObjectizer </h1><br>  Adem√°s hablaremos sobre SObjectizer y sus detalles.  Si no comprende los ejemplos a continuaci√≥n, podr√≠a tener sentido aprender m√°s sobre SObjectizer.  Por ejemplo, de nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo de revisi√≥n sobre SObjecizer</a> y varios posteriores que presentan a los lectores SObjectizer, pasando de simple a complejo ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primer</a> art√≠culo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">segundo</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tercero</a> ). <br><br><h2>  Los agentes en SObjectizer son m√°quinas de estado </h2><br>  Los agentes en SObjectizer desde el principio eran m√°quinas de estados con estados expl√≠citos.  Incluso si el desarrollador del agente no describi√≥ ninguno de sus propios estados en su clase de agente, el agente todav√≠a ten√≠a un estado predeterminado, que se utiliz√≥ de manera predeterminada.  Por ejemplo, si un desarrollador hizo un agente tan trivial: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">simple_demo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//   ,       . struct how_are_you final : public so_5::signal_t {}; //   ,     . struct quit final : public so_5::signal_t {}; // ..   ,      . simple_demo(context_t ctx) : so_5::agent_t{std::move(ctx)} { so_subscribe_self() .event&lt;how_are_you&gt;([]{ std::cout &lt;&lt; "I'm fine!" &lt;&lt; std::endl; }) .event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); } };</span></span></code> </pre> <br>  entonces puede que ni siquiera sospeche que en realidad todas las suscripciones que hizo est√°n hechas para el estado predeterminado.  Pero si el desarrollador agrega sus propios estados al agente, entonces ya debe pensar en firmar correctamente el agente en el estado correcto.  Aqu√≠, digamos, una modificaci√≥n incorrecta simple (y, como de costumbre) del agente que se muestra arriba: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">simple_demo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,  ,   . state_t st_free{this}; // ,  ,   . state_t st_busy{this}; public: //   ,       . struct how_are_you final : public so_5::signal_t {}; //   ,     . struct quit final : public so_5::signal_t {}; // ..   ,      . simple_demo(context_t ctx) : so_5::agent_t{std::move(ctx)} { so_subscribe_self() .event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); //   how_are_you   ,    . st_free.event([]{ std::cout &lt;&lt; "I'm free" &lt;&lt; std::endl; }); st_busy.event([]{ std::cout &lt;&lt; "I'm busy" &lt;&lt; std::endl; }); //     st_free. this &gt;&gt;= st_free; } };</span></span></code> </pre> <br>  Establecemos dos manejadores diferentes para la se√±al how_are_you, cada uno para su propio estado. <br><br>  Y el error en esta modificaci√≥n del agente simple_demo es que al estar en st_free o st_busy el agente no responder√° para dejar de fumar, porque  Dejamos la suscripci√≥n de abandono en el estado predeterminado, pero no realizamos las suscripciones correspondientes para st_free y st_busy.  Una forma simple y obvia de solucionar este problema es agregar las suscripciones apropiadas a st_free y st_busy: <br><pre> <code class="cpp hljs"> simple_demo(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx)} { <span class="hljs-comment"><span class="hljs-comment">//   how_are_you   ,    . st_free .event([]{ std::cout &lt;&lt; "I'm free" &lt;&lt; std::endl; }) .event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); st_busy .event([]{ std::cout &lt;&lt; "I'm busy" &lt;&lt; std::endl; }) .event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); //     st_free. this &gt;&gt;= st_free; }</span></span></code> </pre> <br>  Es cierto que este m√©todo huele a copiar y pegar, lo que no es bueno.  Puede deshacerse de copiar y pegar ingresando un estado padre com√∫n para st_free y st_busy: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">simple_demo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      . state_t st_basic{this}; // ,  ,   . //      st_basic. state_t st_free{initial_substate_of{st_basic}}; // ,  ,   . //     st_basic. state_t st_busy{substate_of{st_basic}}; public: //   ,       . struct how_are_you final : public so_5::signal_t {}; //   ,     . struct quit final : public so_5::signal_t {}; // ..   ,      . simple_demo(context_t ctx) : so_5::agent_t{std::move(ctx)} { //   quit   st_basic    //  ""  . st_basic.event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); //   how_are_you   ,    . st_free.event([]{ std::cout &lt;&lt; "I'm free" &lt;&lt; std::endl; }); st_busy.event([]{ std::cout &lt;&lt; "I'm busy" &lt;&lt; std::endl; }); //     st_free. this &gt;&gt;= st_free; } };</span></span></code> </pre> <br>  En aras de la justicia, debe agregarse que inicialmente en SObjectizer los agentes solo podr√≠an ser m√°quinas de estado simples.  El apoyo a las naves espaciales jer√°rquicas apareci√≥ relativamente recientemente, en enero de 2016. <br><br><h2>  ¬øPor qu√© los agentes SObjectizer son m√°quinas de estados finitos? </h2><br>  Esta pregunta tiene una respuesta muy simple: <s>sucedi√≥ que las</s> ra√≠ces de SObjectizer crecen del mundo de los sistemas de control de procesos, y all√≠ las m√°quinas de estado finito se usan con mucha frecuencia.  Por lo tanto, consideramos necesario que los agentes en SObjectizer tambi√©n sean m√°quinas de estado.  Esto es muy conveniente si en la aplicaci√≥n para qu√© SObjectizer est√°n tratando de aplicar, se utilizan CAs.  Y el estado predeterminado, que tienen todos los agentes, nos permite no pensar en naves espaciales si no se requiere el uso de naves espaciales. <br><br>  En principio, si observa el modelo de actores en s√≠ y los principios sobre los que se basa este modelo: <br><br><ul><li>  un actor es una entidad con comportamiento; </li><li>  los actores responden a los mensajes entrantes; </li><li>  Una vez recibido el mensaje, el actor puede: <br><ul><li>  enviar un cierto n√∫mero de mensajes a otros actores; </li><li>  crear una serie de nuevos actores; </li><li>  Defina un nuevo comportamiento para procesar mensajes posteriores. </li></ul></li></ul><br>  Uno puede encontrar una fuerte similitud entre una nave espacial simple y actores.  Incluso se podr√≠a decir que los actores son simples m√°quinas de estados finitos. <br><br><h2>  ¬øQu√© caracter√≠sticas de las m√°quinas de estado avanzadas admite SObjectizer? </h2><br>  De las caracter√≠sticas anteriores de las m√°quinas de estados finitos avanzados, SObjectizer admite todo excepto los estados ortogonales.  Se admiten otras ventajas, como estados anidados, manejadores de entrada / salida, restricciones en el tiempo pasado en el estado, historial de los estados. <br><br>  Con el apoyo de los estados ortogonales, la primera vez no creci√≥ juntos.  Por un lado, la arquitectura interna de SObjectizer no estaba destinada a admitir varios estados independientes y simult√°neamente activos del agente.  Por otro lado, hay preguntas ideol√≥gicas sobre c√≥mo debe comportarse un agente que tiene estados ortogonales.  La mara√±a de estas preguntas result√≥ ser demasiado complicada, y el escape √∫til fue demasiado peque√±o para resolver este problema.  S√≠, y en nuestra pr√°ctica, todav√≠a no ha habido situaciones en las que se hubieran requerido estados ortogonales, pero habr√≠a sido imposible hacerlo, por ejemplo, dividiendo el trabajo entre varios agentes vinculados a un contexto de trabajo com√∫n. <br><br>  Sin embargo, si alguien necesita una funci√≥n, como los estados ortogonales, y tiene ejemplos del mundo real de tareas en las que esto est√° en demanda, hablemos.  Quiz√°s, teniendo ejemplos concretos ante nuestros ojos, podamos agregar esta funci√≥n a SObjectizer. <br><br><h2>  C√≥mo se ve en el c√≥digo el soporte para funciones avanzadas de ICA </h2><br>  En esta parte de la historia, intentaremos revisar r√°pidamente la API SObjectizer-5 para trabajar con ICA.  Sin profundizar en los detalles, solo para que el lector tenga una idea de qu√© es y c√≥mo se ve.  Si lo desea, puede encontrar informaci√≥n m√°s detallada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en la documentaci√≥n oficial</a> . <br><br><h3>  Estados anidados </h3><br>  Para declarar un estado anidado, debe pasar la expresi√≥n initial_substate_of o substate_of al constructor del objeto state_t correspondiente: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_parent{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//  . state_t st_first_child{initial_substate_of{st_parent}}; //   . //    . state_t st_second_child{substate_of{st_parent}}; //   . state_t st_third_child{substate_of{st_parent}}; //   . state_t st_first_grandchild{initial_substate_of{st_third_child}}; //    . state_t st_second_grandchild{substate_of{st_third_child]}; ... };</span></span></code> </pre> <br>  Si el estado S tiene varios subestados C1, C2, ..., Cn, entonces uno de ellos (y solo uno) debe marcarse como initial_substate_of.  La violaci√≥n de esta regla se diagnostica en tiempo de ejecuci√≥n. <br><br>  La profundidad m√°xima de anidaci√≥n de estado en SObjectizer-5 es limitada.  En las versiones 5.5, estos son 16 niveles.  La violaci√≥n de esta regla se diagnostica en tiempo de ejecuci√≥n. <br><br>  El truco m√°s importante con los estados anidados es que cuando se activa un estado que tiene estados anidados, se activan varios estados a la vez.  Supongamos que hay un estado A que tiene los subestados B y C, y en el subestado B hay los subestados D y E: <br><br><img src="https://habrastorage.org/webt/pf/1n/gb/pf1ngbtknzrf5qxlluht3yfiraq.png"><br><br>  Cuando se activa el estado A, entonces, de hecho, se activan tres estados inmediatamente: A, AB y ABD <br><br>  El hecho de que varios estados puedan estar activos a la vez tiene el efecto m√°s grave en dos cosas de archivo.  En primer lugar, buscar un controlador para el pr√≥ximo mensaje entrante.  Entonces, en el ejemplo que se muestra, primero se buscar√° el controlador de mensajes en el estado ABD. Si no hay un controlador adecuado all√≠, la b√∫squeda continuar√° en su estado principal, es decir,  en AB Y ya herido, si es necesario, la b√∫squeda continuar√° en el estado A. <br><br>  En segundo lugar, la presencia de varios estados activos afecta el orden de invocaci√≥n de los manejadores de entrada / salida para los estados.  Pero esto se discutir√° a continuaci√≥n. <br><br><h3>  Manejadores de E / S estatales </h3><br>  Para un estado, se pueden especificar controladores de estado de entrada y salida de estado.  Esto se hace usando los m√©todos state_t :: on_enter y state_t :: on_exit.  Por lo general, estos m√©todos se invocan en el m√©todo so_define_agent () (o directamente en el constructor del agente si el agente es trivial y no se proporciona la herencia del mismo). <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_free{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_busy{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// :       , //     . st_free.on_enter([]{ ... }); st_busy.on_exit([]{ ...}); ... this &gt;&gt;= st_free; } ... };</span></span></code> </pre> <br>  Probablemente el momento m√°s dif√≠cil con los controladores on_enter / on_exit es usarlos para estados anidados.  Volvamos al ejemplo con los estados A, B, C, D y E. <br><br><img src="https://habrastorage.org/webt/pf/1n/gb/pf1ngbtknzrf5qxlluht3yfiraq.png"><br><br>  Supongamos que cada estado tiene un controlador on_enter y on_exit. <br><br>  Deje que A. se convierta en el estado actual del agente.  los estados A, AB y ABD se activan Durante el cambio de estado de un agente, se llamar√° a A.on_enter, ABon_enter y ABDon_enter.  Y en ese orden. <br><br>  Supongamos que hay una transici√≥n a ABE. Se llamar√° a ABDon_exit y ABEon_enter. <br><br>  Si luego ponemos al agente en estado de CA, se llamar√° a ABEon_exit, ABon_exit, ACon_enter. <br><br>  Si el agente, que se encuentra en el estado de CA, se da de baja, inmediatamente despu√©s de completar el m√©todo so_evt_finish (), se llamar√°n los controladores ACon_exit y A.on_exit. <br><br><h3>  Plazos </h3><br>  El l√≠mite de tiempo para que el agente permanezca en un estado particular se establece utilizando el m√©todo state_t :: time_limit.  Al igual que con on_enter / on_exit, los m√©todos time_limit generalmente se llaman donde el agente est√° configurado para funcionar dentro del SObjectizer: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">led_indicator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> inactive{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> active{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        15s. //        inactive. active.time_limit(15s, inactive); ... } ... };</span></span></code> </pre> <br>  Si se establece el l√≠mite de tiempo para el estado, tan pronto como el agente ingrese a este estado, SObjectizer comienza a contar el tiempo pasado en el estado.  Si el agente abandona el estado y luego vuelve a este estado nuevamente, la cuenta regresiva comienza nuevamente. <br><br>  Si se establecen l√≠mites de tiempo para los estados incrustados, entonces debe tener cuidado, porque  Son posibles trucos curiosos: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   . state_t A{this}, B{this}; //   first . state_t C{initial_substate_of{A}}, st_D{substate_of{A}}; ... void so_define_agent() override { A.time_limit(15s, B); C.time_limit(10s, D); D.time_limit(20s, C); ... } ... };</span></span></code> </pre> <br>  Supongamos que un agente entra en el estado A. I.e.  los estados A y C se activan tanto para A como para C.  Anteriormente, finalizar√° para el estado C y el agente cambiar√° al estado D. Esto comenzar√° la cuenta regresiva para permanecer en el estado D. ¬°Pero la cuenta regresiva continuar√° para permanecer en A!  Como durante la transici√≥n de C a D, el agente continu√≥ en el estado A. Y cinco segundos despu√©s de la transici√≥n forzada de C a D, el agente pasar√° al estado B. <br><br><h3>  Historia de fortuna </h3><br>  Por defecto, los estados del agente no tienen un historial.  Para activar el ahorro de historial para un estado, pase la constante shallow_history (el estado tendr√° un historial superficial) o deep_history (el estado tendr√° un historial profundo) al constructor state_t.  Por ejemplo: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> A{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, shallow_history}; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> B{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, deep_history}; ... };</code> </pre> <br>  La historia de los estados es un tema dif√≠cil, especialmente cuando se utiliza una profundidad de anidaci√≥n decente de los estados y los subestados tienen su propia historia.  Por lo tanto, para obtener informaci√≥n m√°s completa sobre este tema, es mejor consultar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la documentaci√≥n</a> y experimentar.  Bueno, para preguntarnos si no puede resolverlo usted mismo;) <br><br><h3>  just_switch_to, transfer_to_state, suprimir </h3><br>  La clase state_t tiene varios de los m√©todos m√°s com√∫nmente utilizados que ya se han mostrado anteriormente: evento () para suscribir eventos a un mensaje, on_enter () y on_exit () para configurar controladores de entrada / salida, time_limit () para establecer un l√≠mite para el tiempo pasado en un estado. <br><br>  Junto con estos m√©todos, cuando se trabaja con ICA, los siguientes m√©todos de la clase state_t son muy √∫tiles: <br><br>  M√©todo just_switch_to (), que est√° dise√±ado para el caso en que la √∫nica reacci√≥n a un mensaje entrante es transferir el agente a un nuevo estado.  Puedes escribir: <br><pre> <code class="cpp hljs">some_state.just_switch_to&lt;some_msg&gt;(another_state);</code> </pre> <br>  en lugar de: <br><pre> <code class="cpp hljs">some_state.event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;some_msg&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= another_state; });</code> </pre> <br>  El m√©todo transfer_to_state () es muy √∫til cuando tenemos alg√∫n mensaje M procesado de la misma manera en dos o m√°s estados S1, S2, ..., Sn.  Pero, si estamos en los estados S2, ..., Sn, primero tenemos que volver a S1, y solo entonces hacemos el procesamiento M. <br><br>  Si esto suena complicado, entonces tal vez en un ejemplo de c√≥digo se entender√° mejor esta situaci√≥n: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> S1{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, S2{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, ..., Sn{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actual_M_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;M&gt; cmd)</span></span></span><span class="hljs-function"> </span></span>{...} ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ S1.event(&amp;demo::actual_M_handler); ... <span class="hljs-comment"><span class="hljs-comment">//           S1, //      M  . S2.event([this](mhood_t&lt;M&gt; cmd) { this &gt;&gt;= S1; actual_M_handler(cmd); }); ... //      . Sn.event([this](mhood_t&lt;M&gt; cmd) { this &gt;&gt;= S1; actual_M_handler(cmd); }); } ... };</span></span></code> </pre> <br>  Pero en lugar de definir controladores de eventos muy similares para S2, ..., Sn, use transfer_to_state: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> S1{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, S2{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, ..., Sn{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actual_M_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;M&gt; cmd)</span></span></span><span class="hljs-function"> </span></span>{...} ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ S1.event(&amp;demo::actual_M_handler); ... <span class="hljs-comment"><span class="hljs-comment">//           S1, //      M  . S2.transfer_to_state&lt;M&gt;(S1); ... //      . Sn.transfer_to_state&lt;M&gt;(Sn); } ... };</span></span></code> </pre> <br>  El m√©todo suppress () suprime una b√∫squeda de controlador de eventos para el subestado actual y todos sus subestados principales.  Supongamos que tenemos un estado primario A en el que se llama std :: abort () en el mensaje M.  Y hay un estado secundario de B en el que M puede ignorarse con seguridad.  Debemos determinar la reacci√≥n a M en el subestado B, porque si no lo hacemos, entonces el controlador para B se encontrar√° en A. Por lo tanto, necesitaremos escribir algo como: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ A.event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;M&gt;) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); }); ... B.event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;M&gt;) {}); <span class="hljs-comment"><span class="hljs-comment">//    ,      //   M   . ... }</span></span></code> </pre> <br>  El m√©todo suppress () le permite escribir esta situaci√≥n en c√≥digo de manera m√°s expl√≠cita y gr√°fica: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ A.event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;M&gt;) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); }); ... B.suppress&lt;M&gt;(); <span class="hljs-comment"><span class="hljs-comment">//    ,      //   M   . ... }</span></span></code> </pre> <br><h2>  Ejemplo muy simple </h2><br>  Los ejemplos est√°ndar de SObjectizer v.5.5 incluyen un ejemplo simple, <a href="">parpadeando_led</a> , que simula el funcionamiento de un indicador LED parpadeante.  El diagrama de estado del agente de este ejemplo es el siguiente: <br><br><img src="https://habrastorage.org/webt/9d/yt/ms/9dytmskalbsypsg9xjjzkwupl5k.png"><br><br>  Y aqu√≠ est√° el c√≥digo de agente completo de este ejemplo: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blinking_led</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> off{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }, blinking{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }, blink_on{ initial_substate_of{ blinking } }, blink_off{ substate_of{ blinking } }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">turn_on_off</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; blinking_led( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{ ctx } { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= off; off.just_switch_to&lt; turn_on_off &gt;( blinking ); blinking.just_switch_to&lt; turn_on_off &gt;( off ); blink_on .on_enter( []{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ON"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } ) .on_exit( []{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"off"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } ) .time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{<span class="hljs-number"><span class="hljs-number">1250</span></span>}, blink_off ); blink_off .time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{<span class="hljs-number"><span class="hljs-number">750</span></span>}, blink_on ); } };</code> </pre> <br>  Aqu√≠, todo el trabajo real se realiza dentro de los manejadores de E / S para el subestado blink_on.  Bueno, adem√°s, limita la duraci√≥n de la estad√≠a en el trabajo de los subestaciones blink_on y blink_off. <br><br><h2>  No es un ejemplo muy simple. </h2><br>  Los ejemplos est√°ndar de SObjectizer v.5.5 tambi√©n incluyen un ejemplo mucho m√°s complejo, <a href="">intercom_statechart</a> , que imita el comportamiento del panel del interfono.  Y el diagrama de estado del agente principal en este ejemplo se ve as√≠: <br><br><img src="https://habrastorage.org/webt/o-/i6/7d/o-i67dswwms9rkutntnvd-hrx7e.jpeg"><br><br>  Todo es tan duro porque esta imitaci√≥n admite no solo llamar a un departamento por n√∫mero, sino tambi√©n cosas como un c√≥digo secreto √∫nico para cada departamento, as√≠ como un c√≥digo de servicio especial.  Estos c√≥digos le permiten abrir la cerradura de la puerta sin marcar en ning√∫n lado. <br><br>  Todav√≠a hay cosas interesantes en este ejemplo.  Pero es demasiado grande para ser descrito en detalle (incluso un art√≠culo separado puede no ser suficiente para esto).  Entonces, si est√° interesado en c√≥mo se ven los ICA realmente complejos en SObjectizer, puede ver en este ejemplo.  Y si algo no est√° claro, puede hacernos una pregunta.  Por ejemplo, en los comentarios a este art√≠culo. <br><br><h1>  ¬øEs posible no usar el soporte para naves espaciales integradas en SObjectizer-5? </h1><br>  Entonces, SObjectizer-5 tiene soporte integrado para ICA con una amplia gama de caracter√≠sticas compatibles.  Este soporte se hace, por supuesto, para usarlo.  En particular, los mecanismos de depuraci√≥n de SObjectizer, como el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">rastreo de entrega de mensajes</a> , conocen el estado del agente y muestran el estado actual en sus respectivos mensajes de depuraci√≥n. <br><br>  Sin embargo, si el desarrollador no quiere, por alg√∫n motivo, utilizar las herramientas integradas SObjectizer-5, entonces puede que no lo haga. <br><br>  Por ejemplo, puede negarse a utilizar SObjectizer state_t y otros similares porque state_t es un objeto bastante pesado con std :: string, un par de funciones std ::, varios contadores como std :: size_t, cinco punteros a varios objetos y alguna otra bagatela.  Juntos, esto en Linux de 64 bits y GCC-5.5, por ejemplo, proporciona 160 bytes por state_t (aparte de lo que se puede asignar en la memoria din√°mica). <br><br>  Si necesita, por ejemplo, un mill√≥n de agentes en la aplicaci√≥n, cada uno de los cuales tendr√° 10 estados, entonces la sobrecarga de SObjectizer state_t puede no ser aceptable.  En este caso, puede usar alg√∫n otro mecanismo para trabajar con m√°quinas de estado, delegando manualmente el procesamiento de mensajes a este mecanismo.  Algo como: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">external_fsm_demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { some_fsm_type my_fsm_; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ so_subscribe_self() .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_one&gt; cmd) { my_fsm_.handle(*cmd); }) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_two&gt; cmd) { my_fsm_.handle(*cmd); }) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_three&gt; cmd) { my_fsm_.handle(*cmd); }); ... } ... };</code> </pre> <br>  En este caso, est√° pagando por la eficiencia al aumentar la cantidad de trabajo manual y la falta de ayuda de los mecanismos de depuraci√≥n de SObjectizer.  Pero aqu√≠ depende del desarrollador decidir. <br><br><h1>  Conclusi√≥n </h1><br>  El art√≠culo result√≥ ser voluminoso, mucho m√°s de lo planeado originalmente.  Gracias a todos los que leyeron a este lugar.  Si uno de los lectores considera que es posible dejar sus comentarios en los comentarios al art√≠culo, entonces ser√° genial. <br><br>  Si algo no est√° claro, entonces haga preguntas, le responderemos con gusto. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, aprovechando esta oportunidad, quiero llamar la atenci√≥n de aquellos interesados ‚Äã‚Äãen SObjectizer, que el trabajo ha comenzado en la pr√≥xima versi√≥n de SObjectizer en el marco de la rama 5.5. </font><font style="vertical-align: inherit;">Brevemente sobre lo que se considera para la implementaci√≥n en 5.5.23, descrito </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">M√°s completamente, pero en ingl√©s, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Puede dejar su opini√≥n sobre cualquiera de las caracter√≠sticas propuestas para la implementaci√≥n u ofrecer algo m√°s.</font></font> Es decir<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existe una oportunidad real de influir en el desarrollo de SObjectizer. </font><font style="vertical-align: inherit;">Adem√°s, despu√©s del lanzamiento de v.5.5.23, puede haber una pausa en el trabajo en SObjectizer y la pr√≥xima oportunidad de incluir algo √∫til en SObjectizer 2018 puede no ser posible.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es423497/">https://habr.com/ru/post/es423497/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es423487/index.html">Node.js sin node_modules</a></li>
<li><a href="../es423489/index.html">Soy m√©dico de urgencias y quiero hablar sobre el nuevo electrocardiograma Apple Watch.</a></li>
<li><a href="../es423491/index.html">PHP Digest No. 139 (3 al 17 de septiembre de 2018)</a></li>
<li><a href="../es423493/index.html">Android Go es el futuro bill√≥n de dispositivos y un l√≠mite de 50 MB. Conferencia de Yandex</a></li>
<li><a href="../es423495/index.html">¬øQu√© hay dentro de XGBoost y qu√© tiene que ver Go con √©l?</a></li>
<li><a href="../es423499/index.html">DevBoy: c√≥mo cre√© un proyecto de dispositivo de c√≥digo abierto y lanc√© un proyecto en Kickstarter</a></li>
<li><a href="../es423501/index.html">B√∫squeda y creaci√≥n de estilo visual para un proyecto de dise√±o.</a></li>
<li><a href="../es423503/index.html">Mi experiencia de mudarme, vivir y estudiar en Alemania</a></li>
<li><a href="../es423505/index.html">Zuckerberg vende acciones de Facebook por $ 13 mil millones para que "nuestros ni√±os nunca tengan que enfermarse"</a></li>
<li><a href="../es423507/index.html">C√≥mo ahorrar memoria en las pesta√±as del navegador, pero no perder su contenido. La experiencia del equipo Yandex.Browser</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>