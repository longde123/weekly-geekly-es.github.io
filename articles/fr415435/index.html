<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç∏ üë®üèæ‚Äçüî¨ ‚öôÔ∏è D√©veloppement de cartes d'interface sur Soil Xilinx Zynq 7000 pour l'enregistrement vocal au format analogique et num√©rique ‚ôÄÔ∏è üë©üèª‚Äçü§ù‚Äçüë®üèΩ üë®üèº‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, nous partagerons notre exp√©rience dans le d√©veloppement de cartes d'interface de l'unit√© d'interface bas√©e sur le SoC ARM + FPGA Xil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>D√©veloppement de cartes d'interface sur Soil Xilinx Zynq 7000 pour l'enregistrement vocal au format analogique et num√©rique</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415435/"><img src="https://habrastorage.org/webt/rg/2_/55/rg2_55mpm_gc8ip2vlemo9tel9k.jpeg"><br><br>  Dans cet article, nous partagerons notre exp√©rience dans le d√©veloppement de cartes d'interface de l'unit√© d'interface bas√©e sur le SoC ARM + FPGA Xilinx Zynq 7000. Les cartes ont √©t√© con√ßues pour enregistrer des signaux vocaux au format analogique et num√©rique PRI / BRI (ISDN, E1 / T1).  Le dispositif final lui-m√™me sera utilis√© pour enregistrer les n√©gociations dans l'aviation civile. <br><a name="habracut"></a><br><h2>  Iron: s√©lection de la plate-forme mat√©rielle de l'appareil </h2><br>  Le choix de la plate-forme mat√©rielle a √©t√© d√©termin√© par la prise en charge des protocoles PRI / BRI, qui ne peuvent √™tre mis en ≈ìuvre que du c√¥t√© FPGA.  Les microcontr√¥leurs (MCU) et les microprocesseurs (MPU) ne convenaient pas. <br><br>  On pourrait choisir deux solutions √† ce probl√®me: <br><br><ol><li>  Microblaze IP core synthese </li><li>  SoC Zynq-7000. </li></ol><br>  Nous avons opt√© pour un syst√®me sur puce Zynq 7000 (SoC), car  il est plus facile d'√©crire des applications logicielles et offre plus de fonctionnalit√©s pour les t√¢ches actuelles et futures. <br><br>  Au total, la liste de fer suivante a √©t√© collect√©e dans le cadre du projet: <br><br>  <b>1.Xilinx Zynq 7020</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mars-ZX3</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mars EB1</a> ) <br><img src="https://habrastorage.org/webt/ls/g9/4w/lsg94w0qj20bxkf5t8k2gzvzx1e.jpeg"><br>  <i>Enclustra Mars ZX3 SOM</i> <br><img src="https://habrastorage.org/webt/ft/z3/4t/ftz34tc8zkk-9gddjcx2atmufc8.jpeg"><br>  <i>Plinthe Enclustra Mars EB1</i> <br><br>  <b>2. TI TLV320AIC34</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tlv320aic34evm-k</a> et carte m√®re USB). <br><br><img src="https://habrastorage.org/webt/3z/ls/g-/3zlsg-yry1k4e4qyqu1g-o0xt4a.jpeg"><br>  <i>Carte de d√©bogage pour TLV320AIC34 (TLV320AIC34EVM-K)</i> <br><br><img src="https://habrastorage.org/webt/pb/mk/84/pbmk84mawx1rbpmqreghow9fjim.jpeg"><br>  <i>Carte d'extension USB-MODEVM pour TLV320AIC34EVM-K</i> <br><br>  <b>3. IDT82P2288 - Microcircuits PRI, XHFC-4SU - BRI,</b> il n'y avait pas de kits de d√©bogage, nous n'avons donc pos√© que les bases d'un noyau ip pour les tests, et le bapt√™me du feu s'est produit en plein processus, apr√®s avoir fabriqu√© des cartes prototypes. <br><br><h2>  Travailler avec le syst√®me sur la puce Xilinx Zynq 7000 </h2><br><br><img src="https://habrastorage.org/webt/t5/2n/ka/t52nkauzukagn0mp_aruobwjigm.png"><br>  <i>La structure interne du SoC Xilinx Zynq 7000</i> <br><br><img src="https://habrastorage.org/webt/u9/nn/nl/u9nnnlwp0nib8s4td2drrorqm54.png"><br>  <i>√âtapes pour g√©n√©rer des fichiers de d√©marrage pour Xilinx Zynq</i> <br><br>  Le clignotement / t√©l√©chargement des ex√©cutables pour Zynq est diff√©rent du t√©l√©chargement habituel pour MPU.  Le travail habituel avec les processeurs Cortex-A consiste √† charger u-boot, kernel linux, rootfs.  Et sur Zynq, le bitstream appara√Æt, le fichier du firmware pour les FPGA.  Le train de bits contient une description des blocs mat√©riels du FPGA et de la communication interne avec le processeur.  Ce fichier est charg√© au d√©marrage du syst√®me.  Du c√¥t√© de Linux, il existe √©galement un m√©canisme qui vous permet de flasher la pi√®ce PL imm√©diatement pendant le fonctionnement, un tel appareil est appel√© xdevcfg ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gestionnaire ZYNQ FPGA depuis 2018.1</a> ). <br><br><h2>  Interfaces PRI / BRI </h2><br><img src="https://habrastorage.org/webt/om/zo/dr/omzodrzsfz9d5oqyo-ukvvsozve.jpeg"><br>  <i>Caract√©ristiques des r√©seaux num√©riques PRI / BRI</i> <br><br>  L'interface √† d√©bit primaire (PRI) est une interface r√©seau RNIS standard qui d√©finit la discipline de connexion des stations RNIS √† des circuits √† large bande qui connectent les commutateurs locaux et centraux ou les commutateurs de r√©seau. <br><br><img src="https://habrastorage.org/webt/_5/p0/5k/_5p05km2btytoe7ptkdrfuz_-8o.png"><br>  <i>Type de trame transmise pour PRI</i> <br><br><img src="https://habrastorage.org/webt/rp/ux/hd/rpuxhdxujlk8c2cnxxgdga74-tk.png"><br>  <i>Vue de la trame transmise pour BRI</i> <br><br><img src="https://habrastorage.org/webt/-i/1c/90/-i1c90_mrzspj2jhrog9akk_u4g.png"><br>  <i>La structure interne de la physique PRI - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IDT82P2288</a></i> <br><br><img src="https://habrastorage.org/webt/ca/iv/s5/caivs5jr2frxcu_xiign_my2db8.png"><br>  <i>La structure interne de la physique BRI - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">XHFC-4SU</a></i> <br><br><h2>  Codec audio TLV320AIC34 </h2><br>  Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">codec audio TLV320AIC34</a> basse consommation √† quatre canaux pour l'audio et la t√©l√©phonie portables est une bonne solution pour une utilisation en t√©l√©phonie analogique. <br><br><img src="https://habrastorage.org/webt/7i/7g/lr/7i7glrlam_fmxm2inkwcgqinrl8.png"><br>  <i>Tlv320aic34 Partie A, le codec audio contient deux de ces blocs fonctionnels</i> <br><br>  Les donn√©es peuvent √™tre transmises via l'interface I2S, ainsi que via DSP, PCM, TDM. <br><br>  I2S est une norme d'interface de bus s√©rie, il est utilis√© pour connecter des appareils audio num√©riques et repr√©sente √©lectriquement 3 conducteurs qui vont d'un appareil actif √† un appareil passif, ainsi que 4 signaux qui leur correspondent comme suit: <br><br><ol><li>  Horloge Bit (BCLK). </li><li>  Synchronisation de trame de signal d'horloge (selon les mots) (WCLK). </li><li>  Signal de donn√©es qui peut √©mettre ou recevoir 2 canaux divis√©s dans le temps (DIN / DOUT). </li></ol><br>  Les canaux pour recevoir et transmettre des donn√©es sont divis√©s, c'est-√†-dire qu'il existe un canal s√©par√© pour recevoir des donn√©es et un canal pour la transmission.  Le contr√¥leur re√ßoit les donn√©es transmises par le codec audio, mais l'inverse est √©galement possible. <br><br><img src="https://habrastorage.org/webt/p5/op/th/p5opthpov06xstxalowbqz_emt8.png"><br>  <i>Cadre I2S, caract√©ristiques de l'interface I2S</i> <br><br>  Apr√®s avoir s√©lectionn√© tous les composants mat√©riels, nous avons r√©solu le probl√®me de connexion du codec audio et du Xilinx Zynq 7020. <br><br><h2>  Recherche de c≈ìurs I2S </h2><br>  Le moment probablement le plus difficile lorsque je travaillais avec le flux audio dans le Xilinx Zynq 7020 √©tait que sur la partie processeur de ce syst√®me, il n'y avait pratiquement pas de bus I2S sur la puce, j'ai donc d√ª trouver le c≈ìur I2S.  Cette t√¢che √©tait compliqu√©e par la condition que le noyau ip soit libre. <br><br>  Nous nous sommes install√©s sur plusieurs c≈ìurs ip.  Trouv√© pour le noyau en m√©tal nu I2S <b>Digilent</b> .  Nous avons trouv√© plusieurs c≈ìurs ip sur les <b>opencores</b> et, probablement, la meilleure option pour nous est le noyau ip <b>Analog Devices</b> .  Ils produisent des coeurs ip pour leur √©quipement, pour l'interaction FPGA / FPGA. <br><br>  Nous sommes int√©ress√©s par l'ip-core appel√© <b>AXI-I2S-ADI.</b>  Analog Devices lui-m√™me fait la promotion de ces c≈ìurs ip pour ses plates-formes mat√©rielles. <br><br>  Liste totale des cas d'utilisation: <br><br><ol><li>  M√©tal nu - noyau IP pour I2S (audio Digilent ZYBO) </li><li>  opencores.org </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Contr√¥leur AXI-I2S-ADI</a> (Analog Devices) </li></ol><br><h3>  AXI-I2S-ADI IP Core </h3><br>  Le noyau ip lui-m√™me ressemble √† ceci: il a les lignes bclk, wclk, din, dout.  Il se connecte au DMA Xilinx Zynq 7000, dans notre exemple, la partie DMA PS est utilis√©e.  Tous les √©changes de donn√©es ont lieu via DMA.  Le DMA peut √™tre une unit√© autonome ou faire partie int√©grante du PS SoC. <br><br>  Lors de la configuration de ce noyau ip, il est important de ne pas oublier de soumettre la fr√©quence ma√Ætre mclk √† tlv320aic34 lui-m√™me, en option lors de l'utilisation du kit de d√©bogage pour tlv320aic34 - soumettre une fr√©quence ma√Ætre externe. <br><br><img src="https://habrastorage.org/webt/i8/xn/z4/i8xnz4rijta_07gc1zgc2a8vfxc.png"><br>  <i>Bloc fonctionnel avec axi-i2s-adi connect√©</i> <br><br>  Apr√®s la proc√©dure de configuration, la t√¢che consistait √† lancer la fonctionnalit√© dans le syst√®me d'exploitation Linux. <br><br><h2>  Lancer et configurer l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">arborescence des p√©riph√©riques</a> pour tlv320aic34 </h2><br>  Configuration d'i2c (tlv320aic34 est configur√© sur cette interface): <br><br><pre><code class="cpp hljs">i2c0: i2c@e0004000 { ... tlv320aic3x: tlv320aic3x@<span class="hljs-number"><span class="hljs-number">18</span></span> { <span class="hljs-meta"><span class="hljs-meta">#sound-dai-cells = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;0&gt;; compatible = "ti,tlv320aic3x"; reg = &lt;0x18&gt;; gpio-reset = &lt;&amp;axi_gpio_0 0 0&gt;; ai3x-gpio-func = &lt;&amp;axi_gpio_0 1 0&gt;, /* AIC3X_GPIO1_FUNC_DISABLED */ &lt;&amp;axi_gpio_0 2 0&gt;; /* AIC3X_GPIO2_FUNC_DIGITAL_MIC_INPUT */ AVDD-supply = &lt;&amp;vmmc2&gt;; DRVDD-supply = &lt;&amp;vmmc2&gt;; IOVDD-supply = &lt;&amp;vmmc2&gt;; DVDD-supply = &lt;&amp;vmmc2&gt;; ai3x-micbias-vg = &lt;1&gt;; }; ... };</span></span></span></span></code> </pre> <br>  Configuration d'i2s (les donn√©es audio sont transmises via cette interface): <br><br><pre> <code class="cpp hljs">i2s_clk: i2s_clk { <span class="hljs-meta"><span class="hljs-meta">#clock-cells = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;0&gt;; compatible = "fixed-clock"; clock-frequency = &lt;11289600&gt;; clock-output-names = "i2s_clk"; }; axi_i2s_adi_0: axi_i2s_adi@43C00000 { compatible = "adi,axi-i2s-1.00.a"; reg = &lt;0x43C00000 0x1000&gt;; xlnx,bclk-pol = &lt;0x0&gt;; xlnx,dma-type = &lt;0x1&gt;; xlnx,has-rx = &lt;0x1&gt;; xlnx,has-tx = &lt;0x1&gt;; xlnx,lrclk-pol = &lt;0x0&gt;; xlnx,num-ch = &lt;0x1&gt;; xlnx,s-axi-min-size = &lt;0x000001FF&gt;; xlnx,slot-width = &lt;0x18&gt;; }; &amp;axi_i2s_adi_0 { #sound-dai-cells = &lt;0&gt;; compatible = "adi,axi-i2s-1.00.a"; clocks = &lt;&amp;clkc 15&gt;, &lt;&amp;i2s_clk&gt;; clock-names = "axi", "ref"; dmas = &lt;&amp;dmac_s 0 &amp;dmac_s 1&gt;; dma-names = "tx", "rx"; };</span></span></span></span></code> </pre> <br>  Configuration de la carte son dans l'arborescence des appareils (cartes audio): <br><br><pre> <code class="cpp hljs"> sound { compatible = <span class="hljs-string"><span class="hljs-string">"simple-audio-card"</span></span>; simple-audio-card,name = <span class="hljs-string"><span class="hljs-string">"TLV320AIC34"</span></span>; simple-audio-card,format = <span class="hljs-string"><span class="hljs-string">"i2s"</span></span>; simple-audio-card,bitclock-master = &lt;&amp;dailink0_master&gt;; simple-audio-card,frame-master = &lt;&amp;dailink0_master&gt;; simple-audio-card,widgets = ... simple-audio-card,routing = ... dailink0_master: simple-audio-card,cpu { clocks = &lt;&amp;i2s_clk&gt;; sound-dai = &lt;&amp;axi_i2s_adi_0&gt;; }; simple-audio-card,codec { clocks = &lt;&amp;i2s_clk&gt;; sound-dai = &lt;&amp;tlv320aic3x&gt;; }; }; };</code> </pre> <br>  Apr√®s toutes les manipulations pour configurer et configurer le codec dans l'arborescence des p√©riph√©riques sous Linux, la carte audio convoit√©e est apparue et nous avons pu entendre de la musique (notre premier morceau de musique √©tait Highway to Hell, AC / DC). <br><br>  Voici ce que nous devions faire pour cela: <br><br><ul><li>  G√©n√©r√© la fr√©quence n√©cessaire √† l'aide de clk_wiz (assistant de pointage) </li><li>  DTS correctement configur√© pour tlv320aic34 </li><li>  Ajout de la prise en charge du pilote tlv320aic3x </li><li>  Ajout de packages audio √† buildroot pour lire le flux audio (aplay, madplay, etc.) </li></ul><br>  Dans le processus de d√©veloppement du dispositif final, nous avons √©t√© confront√©s √† la t√¢che de connecter 4 microcircuits tlv320aic34.  La puce tlv320aic34 d√©crite ci-dessus contient 2 blocs pour travailler avec le flux audio, chaque bloc a sa propre ligne i2c pour configurer et configurer les param√®tres audio.  Un bloc ne peut avoir que quatre adresses, respectivement, il est impossible de connecter quatre microcircuits tlv320aic34 √† une interface i2c, vous devez utiliser deux interfaces i2c (8 blocs audio ind√©pendants).  Pour chaque bloc, si vous d√©marrez mclk, blck, wclk, din / dout individuellement, vous devez ajouter 40 lignes de signal au total, ce qui est impossible et irrationnel du point de vue du circuit pour le module som que nous avons choisi, car en plus de ces signaux, vous avez d√ª connecter de nombreuses autres lignes et interfaces. <br><br>  En cons√©quence, nous avons d√©cid√© de passer la carte audio en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mode TDM</a> , dans lequel toutes les lignes mclk, bclk, din, dout sont combin√©es, ce qui r√©duit le nombre total de lignes de communication.  Cette d√©cision a affect√© le fonctionnement de axi-i2s-adi, car le noyau ip lui-m√™me fonctionnait en mode ma√Ætre.  De plus, ce changement ne nous a pas permis d'utiliser notre ip-core en mode TDM, et une d√©cision r√©solue nous a oblig√© √† abandonner l'utilisation de l'ip-core s√©lectionn√©.  J'ai d√ª √©crire un noyau ip pour √©couter le trafic i2s et l'envoyer √† dma, cette solution nous a permis de cr√©er une interface commune pour recevoir des donn√©es qui ne d√©pendrait pas du type de carte pour l'enregistrement des appels (cartes analogiques et num√©riques). <br><br>  L'architecture initiale pour recevoir le flux audio et son traitement via l'interface i2s: <br><br><img src="https://habrastorage.org/webt/yn/24/2d/yn242d_8cm4kazs2ycwceevqqe8.jpeg"><br><br>  L'architecture finale pour recevoir le flux audio et son traitement via l'interface i2s: <br><br><img src="https://habrastorage.org/webt/mz/py/dt/mzpydtgravupatvivp_zmpiitig.jpeg"><br><br>  Architecture de r√©ception d'un flux PRI et de son traitement: <br><br><img src="https://habrastorage.org/webt/qx/ee/7w/qxee7wt1mdazgm0tu0eukbm5rmy.jpeg"><br><br>  Architecture de r√©ception et de traitement des flux BRI: <br><br><img src="https://habrastorage.org/webt/wd/uf/ny/wdufnykenpfxgwyhrnr3x6ep2kg.jpeg"><br><br><h2>  Axi dma </h2><br>  Il s'agit d'un √©l√©ment important du syst√®me de synchronisation des donn√©es pour dma. <br><br><img src="https://habrastorage.org/webt/v7/fx/pk/v7fxpk_3eemrqnlmy3iejsjrup4.png"><br>  <i>Fen√™tre de configuration AXI DMA dans Xilinx Vivado</i> <br><br>  Sur l'√©cran d'impression, le bloc AXI DMA lui-m√™me est pr√©sent√©.  Il a de nombreux param√®tres.  Vous pouvez configurer le bus combien de donn√©es √† transf√©rer.  Les donn√©es peuvent √™tre align√©es ou dans n'importe quel format.  Une description d√©taill√©e du fonctionnement et de l'interaction avec axi dma est d√©crite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans la documentation technique</a> (de version en version, il y a un ajout et une correction des inexactitudes dans la description, ainsi qu'un raffinement des noyaux ip). <br><br><h2>  V√©rifier le transfert de donn√©es via AXI DMA, les options de test AXI DMA </h2><br>  Lors du d√©veloppement du pilote, nous avons d√©cid√© de trouver l'open source et de l'adapter √† notre t√¢che.  En cons√©quence, nous avons choisi les sources du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet github ezdma</a> (jeu de mots, lu comme dma facile). <br><br>  La prochaine √©tape est le d√©veloppement d'un pilote de test, c'√©tait une √©tape pr√©paratoire en pr√©vision du moment o√π un noyau ip avec des fonctionnalit√©s pr√™tes √† l'emploi du d√©partement de d√©veloppement FPGA nous est parvenu (le processus de d√©veloppement d√©crit a √©t√© form√© par des programmeurs int√©gr√©s).  Avant ce moment, nous avons d√©cid√© de prendre AXI DMA, AXI DATA FIFO et de faire un bouclage pour √©viter les erreurs futures.  Nous avons boucl√© l'envoi et la r√©ception des donn√©es, nous avons donc v√©rifi√© le r√©sultat de notre travail et les performances de notre chauffeur.  Nous avons un peu adapt√© la fonctionnalit√©, l'avons adapt√©e √† nos souhaits sur l'interface d'interaction et v√©rifi√© une fois de plus l'op√©rabilit√© du pilote et le principe d'interaction s√©lectionn√©. <br><br><img src="https://habrastorage.org/webt/iw/si/uj/iwsiujsbv1tckuamu1lsjalzrao.png"><br>  <i>Conception de blocs r√©trospectifs, la premi√®re fa√ßon de tester AXI DMA</i> <br><br>  Un exemple de description de DMA et ezdma dans une arborescence de p√©riph√©riques: <br><br><pre> <code class="cpp hljs">/ { amba_pl: amba_pl { <span class="hljs-meta"><span class="hljs-meta">#address-cells = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;1&gt;; #size-cells = &lt;1&gt;; compatible = "simple-bus"; ranges ; axi_dma_1: axi_dma { #dma-cells = &lt;1&gt;; compatible = "xlnx,axi-dma-1.00.a"; reg = &lt;0x40400000 0x10000&gt;; clock-names = "s_axi_lite_aclk", "m_axi_sg_aclk", "m_axi_mm2s_aclk", "m_axi_s2mm_aclk"; clocks = &lt;&amp;clkc 15&gt;, &lt;&amp;clkc 15&gt;, &lt;&amp;clkc 15&gt;, &lt;&amp;clkc 15&gt;; interrupt-parent = &lt;&amp;intc&gt;; interrupts = &lt;0 29 4 0 30 4&gt;; xlnx,addrwidth = &lt;0x20&gt;; xlnx,include-sg; dma-channel@40400000 { compatible = "xlnx,axi-dma-mm2s-channel"; dma-channels = &lt;0x1&gt;; interrupts = &lt;0 29 4&gt;; xlnx,datawidth = &lt;0x20&gt;; xlnx,device-id = &lt;0x0&gt;; xlnx,include-dre ; }; dma-channel@40400030 { compatible = "xlnx,axi-dma-s2mm-channel"; dma-channels = &lt;0x1&gt;; interrupts = &lt;0 30 4&gt;; xlnx,datawidth = &lt;0x20&gt;; xlnx,device-id = &lt;0x0&gt;; xlnx,include-dre ; }; }; ezdma0 { compatible = "ezdma"; dmas = &lt;&amp;axi_dma_1 0 &amp;axi_dma_1 1&gt;; dma-names = "loop_tx", "loop_rx"; // used when obtaining reference to above DMA core using dma_request_slave_channel() ezdma,dirs = &lt;2 1&gt;; // direction of DMA channel: 1 = RX (dev-&gt;cpu), 2 = TX (cpu-&gt;dev) }; ... }; };</span></span></span></span></code> </pre> <br>  Vous pouvez facilement g√©n√©rer des fichiers dts / dtsi √† l'aide de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">outil G√©n√©rateur d'arborescence de p√©riph√©riques</a> . <br><br>  La deuxi√®me √©tape de notre processus de d√©veloppement est la cr√©ation d'un noyau ip de test pour v√©rifier les performances du pilote, mais cette fois, les donn√©es seront significatives, avec le transfert via AXIS vers AXI_DMA (comme ce sera le cas dans la version finale du noyau ip). <br><br><img src="https://habrastorage.org/webt/uc/nc/iz/ucncizx2gwl3am9mxz5iursdy1q.png"><br>  <i>Flux de travail de l'interface AXIS</i> <br><br>  Nous impl√©mentons deux variantes d'ip-kernels pour la g√©n√©ration de donn√©es, la premi√®re version test√©e est impl√©ment√©e via verilog, la seconde - sur HLS (dans ce contexte, HLS est apparu sous le slogan "styl√©-mode-jeunesse"). <br><br>  Le g√©n√©rateur de donn√©es verilog (et g√©n√©ralement dans les langages de la famille hdl - verilog, vhdl, etc.) est une solution standard lors du d√©veloppement de c≈ìurs ip de ce type.  Voici quelques extraits de code pour le noyau IP interm√©diaire: <br><br><pre> <code class="hljs sql">module GenCnt ( ‚Ä¶. assign HandsHake = m_axis_din_tready &amp; m_axis_dout_tvalid; always @(posedge Clk) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Rst) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> smCnt &lt;= sIDLE; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (smCnt) sIDLE: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> smCnt &lt;= sDATA; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> sDATA: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Cnt == cTopCnt - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> smCnt &lt;= sLAST; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ... endmodule</code> </pre> <br>  Il n'est pas n√©cessaire d'avoir une description plus d√©taill√©e, car il s'agit d'une t√¢che typique d'un concepteur FPGA. <br><br>  Une ¬´b√™te¬ª plus int√©ressante ici est HLS.  <b>Vivado HLS (High Level Synthesis)</b> est le nouveau logiciel de CAO Xilinx pour cr√©er des appareils num√©riques en utilisant des langages de haut niveau tels que OpenCL, C ou C ++. <br><br>  C / C ++ sont les principaux langages pour un ing√©nieur logiciel embarqu√©, donc r√©soudre un probl√®me en utilisant ces langages est plus int√©ressant en termes d'impl√©mentation et d'analyse comparative pour de futurs projets. <br><br>  Voici deux petits exemples de travail avec HLS.  Le premier exemple est un g√©n√©rateur de donn√©es pour AXI_DMA, le deuxi√®me exemple est l'√©change de donn√©es entre la partie processeur et la logique programmable via l'interface s_axilite. <br><br>  L'√©change de donn√©es via l'interface s_axilite (le deuxi√®me exemple) a √©t√© impl√©ment√© de sorte qu'√† tout moment dans procfs, il √©tait possible de soustraire le flux binaire charg√©, et qu'il √©tait possible de suivre l'exactitude du travail en versionnant pour la partie PL de SoC.  Ici, un point tr√®s int√©ressant appara√Æt avec s_axilite: Vivado HLS g√©n√®re un pilote pour Linux (le pilote, √† son tour, nous nous sommes adapt√©s pour travailler √† travers procfs pour pr√©server l'h√©r√©dit√© de l'√©criture).  Un exemple du code g√©n√©r√© pour Linux est ci-dessous (le chemin vers la solution source1 / impl / ip / drivers / name_xxx / src /). <br><br><img src="https://habrastorage.org/webt/ss/kd/rh/sskdrh3olokqp7miv9qm-ni1gnq.png"><br>  <i>√âtapes de la synth√®se HLS et de la g√©n√©ration de code RTL</i> <br><br>  G√©n√©rateur de donn√©es HLS pour v√©rifier le fonctionnement avec AXI_DMA: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ap_axi_sdata.h&gt; #include &lt;hls_stream.h&gt; #define SIZE_STREAM 1024 struct axis { int tdata; bool tlast; }; void data_generation(axis outStream[SIZE_STREAM]) { #pragma HLS INTERFACE axis port=outStream int i = 0; do{ outStream[i].tdata = i; outStream[i].tlast = (i == (SIZE_STREAM - 1)) ? 1 : 0; i++; }while( i &lt; SIZE_STREAM); }</span></span></span></span></code> </pre> <br>  Un exemple d'obtention de version et de type de carte d'interface: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; void info( int &amp;aVersion, int &amp;bSubVersion, int &amp;cTypeBoard, int version, int subVersion, int typeBoard ){ #pragma HLS INTERFACE s_axilite port=aVersion #pragma HLS INTERFACE s_axilite port=bSubVersion #pragma HLS INTERFACE s_axilite port=cTypeBoard #pragma HLS INTERFACE ap_ctrl_none port=return aVersion = version; bSubVersion = subVersion; cTypeBoard = typeBoard; }</span></span></span></span></code> </pre> <br>  Comme vous l'avez remarqu√©, pour le d√©veloppement sur hls, il est tr√®s important de comprendre le travail et l'application de divers pragmas (HLS pragma), car le processus de synth√®se est directement li√© aux pragmas. <br><br>  Pilote g√©n√©r√© pour s_axilite: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ============================================================== // File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC // Version: 2016.4 // Copyright (C) 1986-2016 Xilinx, Inc. All Rights Reserved. // // ============================================================== #ifdef __linux__ /***************************** Include Files *********************************/ #include "xinfo.h" /***************** Macros (Inline Functions) Definitions *********************/ #define MAX_UIO_PATH_SIZE 256 #define MAX_UIO_NAME_SIZE 64 #define MAX_UIO_MAPS 5 #define UIO_INVALID_ADDR 0 /**************************** Type Definitions ******************************/ typedef struct { u32 addr; u32 size; } XInfo_uio_map; typedef struct { int uio_fd; int uio_num; char name[ MAX_UIO_NAME_SIZE ]; char version[ MAX_UIO_NAME_SIZE ]; XInfo_uio_map maps[ MAX_UIO_MAPS ]; } XInfo_uio_info; /***************** Variable Definitions **************************************/ static XInfo_uio_info uio_info; /************************** Function Implementation *************************/ static int line_from_file(char* filename, char* linebuf) { char* s; int i; FILE* fp = fopen(filename, "r"); if (!fp) return -1; s = fgets(linebuf, MAX_UIO_NAME_SIZE, fp); fclose(fp); if (!s) return -2; for (i=0; (*s)&amp;&amp;(i&lt;MAX_UIO_NAME_SIZE); i++) { if (*s == '\n') *s = 0; s++; } return 0; } static int uio_info_read_name(XInfo_uio_info* info) { char file[ MAX_UIO_PATH_SIZE ]; sprintf(file, "/sys/class/uio/uio%d/name", info-&gt;uio_num); return line_from_file(file, info-&gt;name); } static int uio_info_read_version(XInfo_uio_info* info) { char file[ MAX_UIO_PATH_SIZE ]; sprintf(file, "/sys/class/uio/uio%d/version", info-&gt;uio_num); return line_from_file(file, info-&gt;version); } static int uio_info_read_map_addr(XInfo_uio_info* info, int n) { int ret; char file[ MAX_UIO_PATH_SIZE ]; info-&gt;maps[n].addr = UIO_INVALID_ADDR; sprintf(file, "/sys/class/uio/uio%d/maps/map%d/addr", info-&gt;uio_num, n); FILE* fp = fopen(file, "r"); if (!fp) return -1; ret = fscanf(fp, "0x%x", &amp;info-&gt;maps[n].addr); fclose(fp); if (ret &lt; 0) return -2; return 0; } static int uio_info_read_map_size(XInfo_uio_info* info, int n) { int ret; char file[ MAX_UIO_PATH_SIZE ]; sprintf(file, "/sys/class/uio/uio%d/maps/map%d/size", info-&gt;uio_num, n); FILE* fp = fopen(file, "r"); if (!fp) return -1; ret = fscanf(fp, "0x%x", &amp;info-&gt;maps[n].size); fclose(fp); if (ret &lt; 0) return -2; return 0; } int XInfo_Initialize(XInfo *InstancePtr, const char* InstanceName) { XInfo_uio_info *InfoPtr = &amp;uio_info; struct dirent **namelist; int i, n; char* s; char file[ MAX_UIO_PATH_SIZE ]; char name[ MAX_UIO_NAME_SIZE ]; int flag = 0; assert(InstancePtr != NULL); n = scandir("/sys/class/uio", &amp;namelist, 0, alphasort); if (n &lt; 0) return XST_DEVICE_NOT_FOUND; for (i = 0; i &lt; n; i++) { strcpy(file, "/sys/class/uio/"); strcat(file, namelist[i]-&gt;d_name); strcat(file, "/name"); if ((line_from_file(file, name) == 0) &amp;&amp; (strcmp(name, InstanceName) == 0)) { flag = 1; s = namelist[i]-&gt;d_name; s += 3; // "uio" InfoPtr-&gt;uio_num = atoi(s); break; } } if (flag == 0) return XST_DEVICE_NOT_FOUND; uio_info_read_name(InfoPtr); uio_info_read_version(InfoPtr); for (n = 0; n &lt; MAX_UIO_MAPS; ++n) { uio_info_read_map_addr(InfoPtr, n); uio_info_read_map_size(InfoPtr, n); } sprintf(file, "/dev/uio%d", InfoPtr-&gt;uio_num); if ((InfoPtr-&gt;uio_fd = open(file, O_RDWR)) &lt; 0) { return XST_OPEN_DEVICE_FAILED; } // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">NOTE:</span></span></span><span class="hljs-comment"> slave interface 'Axilites' should be mapped to uioX/map0 InstancePtr-&gt;Axilites_BaseAddress = (u32)mmap(NULL, InfoPtr-&gt;maps[0].size, PROT_READ|PROT_WRITE, MAP_SHARED, InfoPtr-&gt;uio_fd, 0 * getpagesize()); assert(InstancePtr-&gt;Axilites_BaseAddress); InstancePtr-&gt;IsReady = XIL_COMPONENT_IS_READY; return XST_SUCCESS; } int XInfo_Release(XInfo *InstancePtr) { XInfo_uio_info *InfoPtr = &amp;uio_info; assert(InstancePtr != NULL); assert(InstancePtr-&gt;IsReady == XIL_COMPONENT_IS_READY); munmap((void*)InstancePtr-&gt;Axilites_BaseAddress, InfoPtr-&gt;maps[0].size); close(InfoPtr-&gt;uio_fd); return XST_SUCCESS; } #endif</span></span></code> </pre> <br>  Un fichier important qui vous indique l'emplacement des variables (registres) dans l'espace d'adressage est le fichier x # votre_nom # _hw.h.  Vous pouvez toujours v√©rifier l'exactitude du noyau ip √©crit √† l'aide de l'outil devmem. <br><br>  Le contenu de ce fichier: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ============================================================== // File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC // Version: 2016.4 // Copyright (C) 1986-2016 Xilinx, Inc. All Rights Reserved. // // ============================================================== // AXILiteS // 0x00 : reserved // 0x04 : reserved // 0x08 : reserved // 0x0c : reserved // 0x10 : Data signal of aVersion // bit 31~0 - aVersion[31:0] (Read) // 0x14 : Control signal of aVersion // bit 0 - aVersion_ap_vld (Read/COR) // others - reserved // 0x18 : Data signal of bSubVersion // bit 31~0 - bSubVersion[31:0] (Read) // 0x1c : Control signal of bSubVersion // bit 0 - bSubVersion_ap_vld (Read/COR) // others - reserved // 0x20 : Data signal of cTypeBoard // bit 31~0 - cTypeBoard[31:0] (Read) // 0x24 : Control signal of cTypeBoard // bit 0 - cTypeBoard_ap_vld (Read/COR) // others - reserved // (SC = Self Clear, COR = Clear on Read, TOW = Toggle on Write, COH = Clear on Handshake) #define XINFO_AXILITES_ADDR_AVERSION_DATA 0x10 #define XINFO_AXILITES_BITS_AVERSION_DATA 32 #define XINFO_AXILITES_ADDR_AVERSION_CTRL 0x14 #define XINFO_AXILITES_ADDR_BSUBVERSION_DATA 0x18 #define XINFO_AXILITES_BITS_BSUBVERSION_DATA 32 #define XINFO_AXILITES_ADDR_BSUBVERSION_CTRL 0x1c #define XINFO_AXILITES_ADDR_CTYPEBOARD_DATA 0x20 #define XINFO_AXILITES_BITS_CTYPEBOARD_DATA 32 #define XINFO_AXILITES_ADDR_CTYPEBOARD_CTRL 0x24</span></span></code> </pre><br>  Ce fichier d√©crit les adresses des registres, les registres correspondent √† l'emplacement des arguments dans la fonction.  Apr√®s la synth√®se du projet, vous pouvez voir comment le projet cr√©√© sera ex√©cut√© en cycles. <br><br><img src="https://habrastorage.org/webt/lj/jw/na/ljjwnalfpfgcsi4yindklhqvowe.png"><br>  <i>Exemple de battement de projet</i> <br><br>  Travailler avec hls a montr√© que cet outil est adapt√© pour r√©soudre rapidement des t√¢ches, en particulier il a fait ses preuves pour r√©soudre des probl√®mes math√©matiques de vision par ordinateur, qui peuvent √™tre facilement d√©crits en C ++ ou C, ainsi que pour cr√©er de petits noyaux ip pour les interactions et les √©changes informations avec des interfaces FPGA standard. <br><br>  Dans le m√™me temps, HLS n'est pas adapt√© √† la mise en ≈ìuvre d'interfaces mat√©rielles sp√©cifiques, par exemple, dans notre cas, il s'agissait d'I2S, et le code rtl g√©n√©r√© prend plus d'espace sur FPGA que celui √©crit dans les langages hdl standard. <br><br>  La derni√®re √©tape des tests de pilotes est le d√©veloppement d'un g√©n√©rateur de trafic I2S.  Ce noyau ip r√©p√®te les fonctionnalit√©s des noyaux ip pr√©c√©dents, sauf qu'il g√©n√®re des donn√©es incr√©mentielles (trafic) qui correspondent aux donn√©es I2S r√©elles en mode TDM. <br><br><img src="https://habrastorage.org/webt/vc/81/xz/vc81xzbieylxtzhrp6lz-psikva.png"><br>  <i>Conception de blocs pour les futurs tests de c≈ìur I2S personnalis√©s et g√©n√©rateur de trafic I2S</i> <br><br>  En cons√©quence, nous avons obtenu les r√©sultats de hls, axi dma et s_axilite, v√©rifi√© les performances de nos logiciels et pilotes. <br><br><h2>  Conclusions </h2><br>  Nous avons r√©ussi √† d√©velopper les types de cartes d'interface n√©cessaires, ainsi que les noyaux ip pour tdm, pri, bri.  Nous avons consid√©rablement am√©lior√© l'approche actuelle du d√©veloppement de tels appareils et cr√©√© une solution compl√®te qui peut rivaliser avec des cartes d'interface similaires d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Asterick</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">patton</a> et autres.  L'avantage de notre solution est que le d√©veloppeur n'a pas besoin d'une liaison interm√©diaire entre le PC et le PCI pour le transfert de donn√©es, il pourra transmettre directement les informations re√ßues via Ethernet. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr415435/">https://habr.com/ru/post/fr415435/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr415423/index.html">Infrastructure √† cl√© publique: autorit√© de certification bas√©e sur OpenSSL et SQLite3 Utility (Postcryptum)</a></li>
<li><a href="../fr415427/index.html">Toute la v√©rit√© sur RTOS de Colin Walls. Article # 4. T√¢ches, changement de contexte et interruptions</a></li>
<li><a href="../fr415429/index.html">Toute la v√©rit√© sur RTOS de Colin Walls. Article # 5. Interaction et synchronisation des t√¢ches</a></li>
<li><a href="../fr415431/index.html">Annonce du hackathon SmartMail Hack 2: Appel de donn√©es</a></li>
<li><a href="../fr415433/index.html">G√©rer les communiqu√©s sur le logement SIG et les services communaux - nous partageons notre exp√©rience et combattons avec intuition</a></li>
<li><a href="../fr415437/index.html">Comment rouler ML en prod: six r√¢teaux sur lesquels nous avons march√©</a></li>
<li><a href="../fr415439/index.html">La communication d'entreprise vous oblige-t-elle √† quitter ou vous entra√Æne-t-elle dans un projet comme un jeu?</a></li>
<li><a href="../fr415441/index.html">Aux √âtats-Unis, les attaques de ransomwares contre les agences gouvernementales se multiplient</a></li>
<li><a href="../fr415443/index.html">MDG et ITMO University invitent √† l'√©cole d'√©t√© d'apprentissage automatique</a></li>
<li><a href="../fr415445/index.html">Le condens√© des √©v√©nements pour les professionnels des RH dans le domaine des TI pour juillet 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>