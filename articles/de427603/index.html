<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçó üêô üë®üèæ‚Äçüè≠ Wie man endlich anf√§ngt, Tests zu schreiben und es nicht bereut üí® üèõÔ∏è üõÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn ich zu einem neuen Projekt komme, sto√üe ich regelm√§√üig auf eine der folgenden Situationen: 



1. Es gibt √ºberhaupt keine Tests. 
2. Es gibt nur ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man endlich anf√§ngt, Tests zu schreiben und es nicht bereut</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/custis/blog/427603/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/vr/v7/q_/vrv7q_kwfiqd5f7qx7jxwukv62g.jpeg"></a> <br><br>  Wenn ich zu einem neuen Projekt komme, sto√üe ich regelm√§√üig auf eine der folgenden Situationen: <br><br><ol><li>  Es gibt √ºberhaupt keine Tests. </li><li>  Es gibt nur wenige Tests, sie werden selten geschrieben und nicht fortlaufend ausgef√ºhrt. </li><li>  Tests sind vorhanden und in CI (Continuous Integration) enthalten, schaden aber mehr als sie n√ºtzen. </li></ol><br>  Leider ist es das letztere Szenario, das h√§ufig zu ernsthaften Versuchen f√ºhrt, Tests durchzuf√ºhren, wenn keine geeigneten F√§higkeiten vorhanden sind. <br><br>  Was kann getan werden, um die aktuelle Situation zu √§ndern?  Die Idee, Tests zu verwenden, ist nicht neu.  Gleichzeitig √§hneln die meisten Tutorials dem ber√ºhmten Bild, wie man eine Eule zeichnet: Verbinden Sie JUnit, schreiben Sie den ersten Test, verwenden Sie den ersten Mock - und los geht's!  Solche Artikel beantworten keine Fragen dar√ºber, welche Tests geschrieben werden m√ºssen, worauf es sich zu achten lohnt und wie man damit umgeht.  Von hier aus wurde die Idee dieses Artikels geboren.  Ich habe versucht, meine Erfahrungen bei der Implementierung von Tests in verschiedenen Projekten kurz zusammenzufassen, um diesen Weg f√ºr alle zu erleichtern. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ra/7v/m-/ra7vm-kgn__gsmaeg6xg7aud4ey.jpeg"></div><br>  Es gibt mehr als genug einf√ºhrende Artikel zu diesem Thema, daher werden wir uns nicht wiederholen und versuchen, von der anderen Seite zu gehen.  Im ersten Teil werden wir den Mythos entlarven, dass das Testen ausschlie√ülich zus√§tzliche Kosten verursacht.  Es wird gezeigt, wie die Erstellung von Qualit√§tstests wiederum den Entwicklungsprozess beschleunigen kann.  Am Beispiel eines kleinen Projekts werden dann die Grundprinzipien und Regeln ber√ºcksichtigt, die befolgt werden sollten, um diesen Vorteil zu realisieren.  Schlie√ülich werden im letzten Abschnitt spezifische Implementierungsempfehlungen gegeben: Wie k√∂nnen typische Probleme vermieden werden, wenn Tests beginnen, im Gegenteil, die Entwicklung wird erheblich verlangsamt. <br><br>  Da meine Hauptspezialisierung das Java-Backend ist, wird in den Beispielen der folgende Technologie-Stack verwendet: Java, JUnit, H2, Mockito, Spring, Hibernate.  Gleichzeitig widmet sich ein wesentlicher Teil des Artikels allgemeinen Testproblemen, und die darin enthaltenen Tipps gelten f√ºr ein viel breiteres Aufgabenspektrum. <br><br>  Seien Sie jedoch vorsichtig!  Tests machen s√ºchtig: Wenn Sie erst einmal gelernt haben, wie man sie benutzt, k√∂nnen Sie nicht mehr ohne sie leben. <br><br><div class="spoiler">  <b class="spoiler_title">Inhalt</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tests gegen Entwicklungsgeschwindigkeit</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code an jedem Ort ausf√ºhren</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tests neu starten</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Debuggen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wirksamkeit</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Von der Theorie zur Praxis</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Herausforderung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dom√§nenmodell</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projektstruktur</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Integrationstests</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unit-Tests</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierungsempfehlungen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fazit</a> </div></div><br><a name="TestsVsSpeed"></a><h2>  Tests gegen Entwicklungsgeschwindigkeit </h2><br>  Die wichtigsten Fragen, die sich bei der Er√∂rterung der Implementierung von Tests stellen: Wie lange dauert das Schreiben von Tests und welche Vorteile ergeben sich daraus?  Das Testen erfordert wie jede andere Technologie ernsthafte Anstrengungen f√ºr die Entwicklung und Implementierung, sodass zun√§chst keine signifikanten Vorteile zu erwarten sind.  Die Zeitkosten h√§ngen stark vom jeweiligen Team ab.  Weniger als 20-30% der zus√§tzlichen Kosten f√ºr die Codierung sollten jedoch nicht genau berechnet werden.  Weniger ist einfach nicht genug, um zumindest ein Ergebnis zu erzielen.  Die Erwartung sofortiger Renditen ist h√§ufig der Hauptgrund f√ºr die Einschr√§nkung dieser Aktivit√§t, noch bevor die Tests n√ºtzlich werden. <br><br>  Aber √ºber welche Art von Effizienz sprechen wir?  Lassen Sie uns die Texte √ºber die Schwierigkeiten bei der Implementierung fallen und sehen, welche spezifischen M√∂glichkeiten zum Sparen von Zeit beim Testen er√∂ffnet werden. <br><br><a name="CodeRun"></a><h3>  Code an jedem Ort ausf√ºhren </h3><br>  Wenn das Projekt keine Tests enth√§lt, k√∂nnen Sie nur die gesamte Anwendung anheben.  Es ist gut, wenn es ungef√§hr 15 bis 20 Sekunden dauert, aber F√§lle von gro√üen Projekten, bei denen ein vollst√§ndiger Start mehrere Minuten dauern kann, sind alles andere als selten.  Was bedeutet das f√ºr Entwickler?  Ein wesentlicher Teil ihrer Arbeitszeit sind diese kurzen Wartesitzungen, in denen Sie nicht weiter an der aktuellen Aufgabe arbeiten k√∂nnen, aber gleichzeitig zu wenig Zeit bleibt, um zu etwas anderem zu wechseln.  Viele sind mindestens einmal auf solche Projekte gesto√üen, bei denen der in einer Stunde geschriebene Code aufgrund langer Neustarts zwischen den Korrekturen viele Stunden Debugging erfordert.  In Tests k√∂nnen Sie sich darauf beschr√§nken, kleine Teile der Anwendung auszuf√ºhren, was die Wartezeit erheblich verk√ºrzt und die Produktivit√§t bei der Arbeit an Code erh√∂ht. <br><br>  Dar√ºber hinaus f√ºhrt die M√∂glichkeit, Code an jedem Ort auszuf√ºhren, zu einem gr√ºndlicheren Debugging.  Oft erfordert das √úberpr√ºfen selbst der wichtigsten positiven Anwendungsf√§lle √ºber die Anwendungsoberfl√§che einen erheblichen Aufwand und Zeitaufwand.  Das Vorhandensein von Tests erm√∂glicht es, eine detaillierte √úberpr√ºfung einer bestimmten Funktion viel einfacher und schneller durchzuf√ºhren. <br><br>  Ein weiteres Plus ist die M√∂glichkeit, die Gr√∂√üe der getesteten Einheit zu regulieren.  Abh√§ngig von der Komplexit√§t der zu testenden Logik k√∂nnen Sie sich auf eine Methode, eine Klasse, eine Gruppe von Klassen, die bestimmte Funktionen implementieren, einen Dienst usw. bis hin zur Automatisierung des Testens der gesamten Anwendung beschr√§nken.  Diese Flexibilit√§t erm√∂glicht es Ihnen, Tests auf hoher Ebene von vielen Teilen zu entfernen, da diese auf niedrigeren Ebenen getestet werden. <br><br><a name="RepeatedRun"></a><h3>  Tests neu starten </h3><br>  Dieses Plus wird oft als die Essenz der Testautomatisierung bezeichnet, aber lassen Sie uns es aus einem weniger vertrauten Blickwinkel betrachten.  Welche neuen M√∂glichkeiten er√∂ffnen sich Entwicklern? <br><br>  Erstens kann jeder neue Entwickler, der zum Projekt gekommen ist, problemlos vorhandene Tests ausf√ºhren, um die Anwendungslogik anhand von Beispielen zu verstehen.  Leider wird die Bedeutung davon stark untersch√§tzt.  Unter modernen Bedingungen arbeiten dieselben Leute selten l√§nger als 1-2 Jahre an einem Projekt.  Und da die Teams aus mehreren Personen bestehen, ist das Erscheinen eines neuen Teilnehmers alle 2-3 Monate eine typische Situation f√ºr relativ gro√üe Projekte.  Besonders schwierige Projekte durchlaufen Schichten ganzer Entwicklergenerationen!  Die M√∂glichkeit, einen beliebigen Teil der Anwendung einfach zu starten und das Verhalten des Systems zu √ºberpr√ºfen, vereinfacht das Eintauchen neuer Programmierer in das Projekt.  Dar√ºber hinaus reduziert eine detailliertere Untersuchung der Codelogik die Anzahl der am Ausgang gemachten Fehler und die Zeit, um sie in Zukunft zu debuggen. <br><br>  Zweitens er√∂ffnet die M√∂glichkeit, auf einfache Weise zu √ºberpr√ºfen, ob die Anwendung ordnungsgem√§√ü funktioniert, den Weg f√ºr ein kontinuierliches Refactoring.  Dieser Begriff ist leider viel weniger beliebt als CI.  Dies bedeutet, dass das Refactoring jedes Mal durchgef√ºhrt werden kann und sollte, wenn der Code verfeinert wird.  Es ist die regelm√§√üige Einhaltung der ber√ºchtigten Pfadfinder-Regel ‚ÄûVerlassen Sie den Parkplatz sauberer als vor Ihrer Ankunft‚Äú, die eine Verschlechterung der Codebasis vermeidet und dem Projekt ein langes und gl√ºckliches Leben garantiert. <br><br><a name="Debugging"></a><h3>  Debuggen </h3><br>  Das Debuggen wurde bereits in den vorhergehenden Abs√§tzen erw√§hnt, aber dieser Punkt ist so wichtig, dass er n√§her betrachtet werden muss.  Leider gibt es keine zuverl√§ssige M√∂glichkeit, die Beziehung zwischen der Zeit, die f√ºr das Schreiben und Debuggen von Code aufgewendet wurde, zu messen, da diese Prozesse praktisch untrennbar miteinander verbunden sind.  Trotzdem reduziert das Vorhandensein von Qualit√§tstests im Projekt die Debugging-Zeit erheblich, bis fast kein Debugger mehr ausgef√ºhrt werden muss. <br><br><a name="Efficiency"></a><h3>  Wirksamkeit </h3><br>  All dies kann beim ersten Debuggen des Codes erheblich Zeit sparen.  Nur mit dem richtigen Ansatz werden alle zus√§tzlichen Entwicklungskosten bezahlt.  Die verbleibenden Testboni - Verbesserung der Qualit√§t der Codebasis (schlecht gestalteter Code ist schwer zu testen), Reduzierung der Anzahl von Fehlern, M√∂glichkeit, die Richtigkeit des Codes jederzeit zu √ºberpr√ºfen usw. - werden fast kostenlos. <br><br><a name="FromTheoryToPractice"></a><h2>  Von der Theorie zur Praxis </h2><br>  In Worten, alles sieht gut aus, aber kommen wir zur Sache.  Wie bereits erw√§hnt, gibt es mehr als genug Materialien f√ºr die anf√§ngliche Einrichtung der Testumgebung.  Deshalb fahren wir sofort mit dem fertigen Projekt fort.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellen hier.</a> <br><br><a name="Task"></a><h3>  Herausforderung </h3><br>  Betrachten Sie als Vorlagenaufgabe ein kleines Fragment des Backends eines Online-Shops.  Wir werden eine typische API f√ºr die Arbeit mit Produkten schreiben: Erstellen, Empfangen, Bearbeiten.  Sowie einige Methoden f√ºr die Arbeit mit Kunden: √Ñndern eines ‚ÄûLieblingsprodukts‚Äú und Berechnen von Bonuspunkten f√ºr eine Bestellung. <br><br><a name="DomainModel"></a><h3>  Dom√§nenmodell </h3><br>  Um das Beispiel nicht zu √ºberladen, beschr√§nken wir uns auf eine minimale Anzahl von Feldern und Klassen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wc/pn/pz/wcpnpz94fmrb-av0-wkkuu4l2wi.jpeg"></div><br><br>  Der Kunde hat einen Benutzernamen, einen Link zu einem Lieblingsprodukt und eine Flagge, die angibt, ob er ein Premium-Kunde ist. <br><br>  Produkt (Produkt) - Name, Preis, Rabatt und Flagge, die angeben, ob es derzeit beworben wird. <br><br><a name="ProjectStructure"></a><h3>  Projektstruktur </h3><br>  Die Struktur des Hauptprojektcodes ist wie folgt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ks/qa/m3/ksqam31c3vwkzdfwkmi8r7o3ggk.jpeg"></div><br><br>  Klassen sind geschichtet: <br><br><ul><li>  Modell - Dom√§nenmodell des Projekts; </li><li>  Jpa - Repositories f√ºr die Arbeit mit Datenbanken basierend auf Spring Data; </li><li>  Service - Gesch√§ftslogik der Anwendung; </li><li>  Controller - Controller, die die API implementieren. </li></ul><br>  Unit Test Struktur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i3/_1/mi/i3_1micxy4kvvlb6dlgihfmmng0.jpeg"></div><br><br>  Testklassen befinden sich in denselben Paketen wie der urspr√ºngliche Code.  Zus√§tzlich wurde ein Paket mit Buildern zur Aufbereitung von Testdaten erstellt, aber mehr dazu weiter unten. <br><br>  Es ist bequem, Unit-Tests und Integrationstests zu trennen.  Sie haben oft unterschiedliche Abh√§ngigkeiten, und f√ºr eine komfortable Entwicklung sollte es die M√∂glichkeit geben, entweder die eine oder die andere auszuf√ºhren.  Dies kann auf verschiedene Arten erreicht werden: Namenskonventionen, Module, Pakete, sourceSets.  Die Wahl einer bestimmten Methode ist ausschlie√ülich Geschmackssache.  In diesem Projekt liegen Integrationstests in einem separaten sourceSet - IntegrationTest. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qq/1w/z7/qq1wz7n9tq77_zromu01ofx9cns.jpeg"></div><br><br>  Klassen mit Integrationstests befinden sich wie Komponententests in denselben Paketen wie der urspr√ºngliche Code.  Dar√ºber hinaus gibt es Basisklassen, mit denen Konfigurationsduplikationen beseitigt werden k√∂nnen und die bei Bedarf n√ºtzliche universelle Methoden enthalten. <br><br><a name="IntegrationTests"></a><h3>  Integrationstests </h3><br>  Es gibt verschiedene Ans√§tze, mit welchen Tests es sich zu beginnen lohnt.  Wenn die getestete Logik nicht sehr kompliziert ist, k√∂nnen Sie sofort mit den Integrationslogiken fortfahren (sie werden manchmal auch als Akzeptanzlogiken bezeichnet).  Im Gegensatz zu Unit-Tests stellen sie sicher, dass die Anwendung insgesamt ordnungsgem√§√ü funktioniert. <br><br>  <b>Architektur</b> <br><br>  Zun√§chst m√ºssen Sie entscheiden, auf welcher Ebene Integrationspr√ºfungen durchgef√ºhrt werden sollen.  Spring Boot bietet vollst√§ndige Wahlfreiheit: Sie k√∂nnen einen Teil des Kontexts, den gesamten Kontext und sogar einen vollwertigen Server, auf den √ºber die Tests zugegriffen werden kann, aufrufen.  Mit zunehmender Gr√∂√üe der Anwendung wird dieses Problem immer komplexer.  Oft muss man verschiedene Tests auf verschiedenen Ebenen schreiben. <br><br>  Ein guter Ausgangspunkt w√§ren Controller-Tests ohne Start des Servers.  In relativ kleinen Anwendungen ist es durchaus akzeptabel, den gesamten Kontext zu erh√∂hen, da er standardm√§√üig zwischen den Tests wiederverwendet und nur einmal initialisiert wird.  Betrachten Sie die grundlegenden Methoden der <code>ProductController</code> Klasse: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@PostMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"new"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@RequestBody Product product)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productService.createProduct(product); } <span class="hljs-meta"><span class="hljs-meta">@GetMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"{productId}"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@PathVariable(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"productId"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> productId) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productService.getProduct(productId); } <span class="hljs-meta"><span class="hljs-meta">@PostMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"{productId}/edit"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@PathVariable(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"productId"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> productId, @RequestBody Product product) </span></span>{ productService.updateProduct(productId, product); }</code> </pre> <br>  Das Problem der Fehlerbehandlung bleibt unber√ºcksichtigt.  Angenommen, es wird extern implementiert, basierend auf einer Analyse der ausgel√∂sten Ausnahmen.  Der Code der Methoden ist sehr einfach, ihre Implementierung im <code>ProductService</code> nicht viel komplizierter: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span>(readOnly = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long productId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productRepository.findById(productId) .orElseThrow(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataNotFoundException(<span class="hljs-string"><span class="hljs-string">"Product"</span></span>, productId)); } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Product product)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productRepository.save(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Product(product)); } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long productId, Product product)</span></span></span><span class="hljs-function"> </span></span>{ Product dbProduct = productRepository.findById(productId) .orElseThrow(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataNotFoundException(<span class="hljs-string"><span class="hljs-string">"Product"</span></span>, productId)); dbProduct.setPrice(product.getPrice()); dbProduct.setDiscount(product.getDiscount()); dbProduct.setName(product.getName()); dbProduct.setIsAdvertised(product.isAdvertised()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productRepository.save(dbProduct); }</code> </pre> <br>  Das <code>ProductRepository</code> Repository enth√§lt √ºberhaupt keine eigenen Methoden: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Long</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre> <br>  Alles deutet darauf hin, dass diese Klassen keine Komponententests ben√∂tigen, nur weil die gesamte Kette durch mehrere Integrationstests einfach und effizient √ºberpr√ºft werden kann.  Das Duplizieren derselben Tests in verschiedenen Tests erschwert das Debuggen.  Im Falle eines Fehlers im Code f√§llt jetzt nicht ein Test, sondern 10-15 auf einmal.  Dies erfordert wiederum eine weitere Analyse.  Wenn es keine Duplizierung gibt, zeigt der einzige Test wahrscheinlich sofort einen Fehler an. <br><br>  <b>Konfiguration</b> <br><br>  Der <code>BaseControllerIT</code> markieren wir die Basisklasse <code>BaseControllerIT</code> , die die Spring-Konfiguration und einige Felder enth√§lt: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(SpringRunner.class) <span class="hljs-meta"><span class="hljs-meta">@SpringBootTest</span></span>(webEnvironment = SpringBootTest.WebEnvironment.NONE) <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseControllerIT</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> ProductRepository productRepository; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> CustomerRepository customerRepository; }</code> </pre> <br>  Repositorys werden in die Basisklasse verschoben, um die Testklassen nicht zu √ºberladen.  Ihre Rolle ist ausschlie√ülich eine Hilfsfunktion: Daten vorbereiten und den Status der Datenbank √ºberpr√ºfen, nachdem der Controller funktioniert.  Wenn Sie die Gr√∂√üe der Anwendung erh√∂hen, ist dies m√∂glicherweise nicht mehr praktisch, aber f√ºr den Anfang ist es durchaus geeignet. <br><br>  Die Hauptkonfiguration von Spring wird durch die folgenden Zeilen definiert: <br><br>  <code>@SpringBootTest</code> - wird verwendet, um den Kontext der Anwendung <code>@SpringBootTest</code> .  <code>WebEnvironment.NONE</code> bedeutet, dass kein <code>WebEnvironment.NONE</code> muss. <br><br>  <code>@Transactional</code> - <code>@Transactional</code> alle Klassentests in einer Transaktion mit automatischem Rollback, um den Status der Datenbank zu speichern. <br><br>  <b>Teststruktur</b> <br><br>  Kommen wir zu einer minimalistischen Reihe von Tests f√ºr die <code>ProductController</code> Klasse - <code>ProductControllerIT</code> . <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProduct_productSaved</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.01"</span></span>).discount(<span class="hljs-string"><span class="hljs-string">"0.1"</span></span>).advertised(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>).build(); Product createdProduct = productController.createProduct(product); Product dbProduct = productRepository.getOne(createdProduct.getId()); assertEquals(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>, dbProduct.getName()); assertEquals(number(<span class="hljs-string"><span class="hljs-string">"1.01"</span></span>), dbProduct.getPrice()); assertEquals(number(<span class="hljs-string"><span class="hljs-string">"0.1"</span></span>), dbProduct.getDiscount()); assertEquals(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, dbProduct.isAdvertised()); }</code> </pre> <br>  Der Testcode sollte auf einen Blick √§u√üerst einfach und verst√§ndlich sein.  Ist dies nicht der Fall, gehen die meisten Vorteile der im ersten Abschnitt des Artikels beschriebenen Tests verloren.  Es wird empfohlen, den Testk√∂rper in drei Teile zu unterteilen, die visuell voneinander getrennt werden k√∂nnen: Daten vorbereiten, Testmethode aufrufen, Ergebnisse validieren.  Gleichzeitig ist es sehr w√ºnschenswert, dass der Testcode auf den gesamten Bildschirm passt. <br><br>  Pers√∂nlich erscheint es mir offensichtlicher, wenn die Testwerte aus dem Abschnitt Datenaufbereitung sp√§ter in den Pr√ºfungen verwendet werden.  Alternativ k√∂nnen Sie Objekte explizit vergleichen, zum Beispiel wie folgt: <br><br><pre> <code class="java hljs">assertEquals(product, dbProduct);</code> </pre> <br>  In einem anderen Test zum Aktualisieren von Produktinformationen ( <code>updateProduct</code> ) wird deutlich, dass die Erstellung von Daten etwas komplizierter geworden ist. <code>updateProduct</code> die visuelle Integrit√§t der drei Teile des Tests zu <code>updateProduct</code> , werden sie durch zwei Zeilenvorsch√ºbe hintereinander getrennt: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateProduct_productUpdated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>).build(); productRepository.save(product); Product updatedProduct = product(<span class="hljs-string"><span class="hljs-string">"updatedName"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.1"</span></span>).discount(<span class="hljs-string"><span class="hljs-string">"0.5"</span></span>).advertised(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>).build(); updatedProduct.setId(product.getId()); productController.updateProduct(product.getId(), updatedProduct); Product dbProduct = productRepository.getOne(product.getId()); assertEquals(<span class="hljs-string"><span class="hljs-string">"updatedName"</span></span>, dbProduct.getName()); assertEquals(number(<span class="hljs-string"><span class="hljs-string">"1.1"</span></span>), dbProduct.getPrice()); assertEquals(number(<span class="hljs-string"><span class="hljs-string">"0.5"</span></span>), dbProduct.getDiscount()); assertEquals(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, dbProduct.isAdvertised()); }</code> </pre> <br>  Jeder der drei Teile des Teigs kann vereinfacht werden.  F√ºr die Datenaufbereitung eignen sich Testbuilder hervorragend, die die Logik zum Erstellen von Objekten enthalten, die f√ºr die Verwendung aus Tests geeignet ist.  Zu komplexe Methodenaufrufe k√∂nnen zu Hilfsmethoden in Testklassen gemacht werden, wodurch einige der Parameter ausgeblendet werden, die f√ºr diese Klasse irrelevant sind.  Um komplexe Pr√ºfungen zu vereinfachen, k√∂nnen Sie auch Hilfsfunktionen schreiben oder eigene Matcher implementieren.  Die Hauptsache bei all diesen Vereinfachungen ist, die Sichtbarkeit des Tests nicht zu verlieren: Alles sollte auf einen Blick auf die Hauptmethode klar sein, ohne tiefer gehen zu m√ºssen. <br><br>  <b>Testbauer</b> <br><br>  Testbauer verdienen besondere Aufmerksamkeit.  Das Einkapseln der Logik zum Erstellen von Objekten vereinfacht die Testwartung.  Insbesondere das Ausf√ºllen von Modellfeldern, die f√ºr diesen Test nicht relevant sind, kann im Builder ausgeblendet werden.  Dazu m√ºssen Sie es nicht direkt erstellen, sondern verwenden eine statische Methode, die die fehlenden Felder mit Standardwerten ausf√ºllt.  Wenn beispielsweise neue erforderliche Felder im Modell angezeigt werden, k√∂nnen sie dieser Methode problemlos hinzugef√ºgt werden.  In <code>ProductBuilder</code> sieht es so aus: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ProductBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">product</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProductBuilder() .name(name) .advertised(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) .price(<span class="hljs-string"><span class="hljs-string">"0.00"</span></span>); }</code> </pre> <br>  <b>Testname</b> <br><br>  Es ist unbedingt zu verstehen, was in diesem Test speziell getestet wird.  Aus Gr√ºnden der Klarheit ist es am besten, diese Frage im Titel zu beantworten.  Ber√ºcksichtigen Sie bei Verwendung der Beispieltests f√ºr die Methode <code>getProduct</code> die verwendete Namenskonvention: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProduct_oneProductInDb_productReturned</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>).build(); productRepository.save(product); Product result = productController.getProduct(product.getId()); assertEquals(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>, result.getName()); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProduct_twoProductsInDb_correctProductReturned</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product1 = product(<span class="hljs-string"><span class="hljs-string">"product1"</span></span>).build(); Product product2 = product(<span class="hljs-string"><span class="hljs-string">"product2"</span></span>).build(); productRepository.save(product1); productRepository.save(product2); Product result = productController.getProduct(product1.getId()); assertEquals(<span class="hljs-string"><span class="hljs-string">"product1"</span></span>, result.getName()); }</code> </pre> <br>  Im allgemeinen Fall besteht die √úberschrift der Testmethode aus drei Teilen, die durch Unterstreichung getrennt sind: dem Namen der zu testenden Methode, dem Skript und dem erwarteten Ergebnis.  Es hat jedoch niemand den gesunden Menschenverstand aufgehoben, und es kann gerechtfertigt sein, einige Teile des Namens wegzulassen, wenn sie in diesem Zusammenhang nicht ben√∂tigt werden (z. B. ein Skript in einem einzelnen Test zum Erstellen eines Produkts).  Mit dieser Benennung soll sichergestellt werden, dass die Essenz jedes Tests verst√§ndlich ist, ohne den Code zu lernen.  Dies macht das Fenster der Testergebnisse so klar wie m√∂glich und damit beginnt normalerweise die Arbeit mit Tests. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gu/0k/p9/gu0kp9p5hdbswo4i8d6ti2sy1qi.jpeg"></div><br><br>  <b>Schlussfolgerungen</b> <br><br>  Das ist alles.  Zum ersten Mal reicht ein minimaler Satz von vier Tests aus, um die Methoden der <code>ProductController</code> Klasse zu testen.  Im Falle der Erkennung von Fehlern k√∂nnen Sie die fehlenden Tests jederzeit hinzuf√ºgen.  Gleichzeitig reduziert die Mindestanzahl von Tests den Zeit- und Arbeitsaufwand f√ºr deren Unterst√ºtzung erheblich.  Dies ist wiederum f√ºr den Implementierungsprozess des Testens von entscheidender Bedeutung, da die ersten Tests normalerweise nicht von bester Qualit√§t sind und viele unerwartete Probleme verursachen.  Gleichzeitig reicht eine solche Testsuite v√∂llig aus, um die im ersten Teil des Artikels beschriebenen Boni zu erhalten. <br><br>  Es ist erw√§hnenswert, dass solche Tests die Webebene der Anwendung nicht √ºberpr√ºfen, dies ist jedoch h√§ufig nicht erforderlich.  Bei Bedarf k√∂nnen Sie separate Tests f√ºr die <code>@WebMvcTest</code> mit einem Stub anstelle der Basis ( <code>@WebMvcTest</code> , <code>MockMvc</code> , <code>@MockBean</code> ) <code>@MockBean</code> oder einen vollwertigen Server verwenden.  Letzteres kann das Debuggen und die Arbeit mit Transaktionen erschweren, da der Test die Transaktion des Servers nicht steuern kann.  Ein Beispiel f√ºr einen solchen Integrationstest finden Sie in der <code>CustomerControllerServerIT</code> Klasse. <br><br><a name="UnitTests"></a><h3>  Unit-Tests </h3><br>  Unit-Tests haben gegen√ºber Integrationstests mehrere Vorteile: <br><br><ul><li>  Der Start dauert Millisekunden. </li><li>  Kleine Gr√∂√üe der getesteten Einheit; </li><li>  Die √úberpr√ºfung einer gro√üen Anzahl von Optionen ist einfach zu implementieren, da beim direkten Aufruf der Methode die Datenaufbereitung erheblich vereinfacht wird. </li></ul><br>  Trotzdem k√∂nnen Unit-Tests aufgrund ihrer Natur die Funktionsf√§higkeit der gesamten Anwendung nicht garantieren und erm√∂glichen es Ihnen nicht, das Schreiben von Integrations-Tests zu vermeiden.  Wenn die Logik der zu testenden Einheit einfach ist, bringt das Duplizieren von Integrationstests mit Komponententests keine Vorteile, sondern f√ºgt nur mehr Code zur Unterst√ºtzung hinzu. <br><br>  Die einzige Klasse in diesem Beispiel, die Unit-Tests verdient, ist der <code>BonusPointCalculator</code> .  Sein Unterscheidungsmerkmal ist eine gro√üe Anzahl von Zweigen der Gesch√§ftslogik.  Beispielsweise wird angenommen, dass der K√§ufer einen Bonus von 10% der Produktkosten erh√§lt, multipliziert mit nicht mehr als 2 Multiplikatoren aus der folgenden Liste: <br><br><ul><li>  Das Produkt kostet mehr als 10.000 (√ó 4); </li><li>  Das Produkt nimmt an einer Werbekampagne teil (√ó 3); </li><li>  Das Produkt ist das ‚ÄûLieblingsprodukt‚Äú des Kunden (√ó 5); </li><li>  Der Kunde hat einen Premium-Status (√ó 2); </li><li>  Wenn der Kunde einen Premium-Status hat und ein ‚ÄûLieblingsprodukt‚Äú kauft, wird anstelle der beiden angegebenen Multiplikatoren einer (√ó 8) verwendet. </li></ul><br>  Im wirklichen Leben w√§re es nat√ºrlich sinnvoll, einen flexiblen universellen Mechanismus zur Berechnung dieser Boni zu entwickeln, aber um das Beispiel zu vereinfachen, beschr√§nken wir uns auf eine feste Implementierung.  Der Multiplikator-Berechnungscode sieht folgenderma√üen aus: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;BigDecimal&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateMultipliers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Customer customer, Product product)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;BigDecimal&gt; multipliers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (customer.getFavProduct() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; customer.getFavProduct().equals(product)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (customer.isPremium()) { multipliers.add(PREMIUM_FAVORITE_MULTIPLIER); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { multipliers.add(FAVORITE_MULTIPLIER); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (customer.isPremium()) { multipliers.add(PREMIUM_MULTIPLIER); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (product.isAdvertised()) { multipliers.add(ADVERTISED_MULTIPLIER); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (product.getPrice().compareTo(EXPENSIVE_THRESHOLD) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { multipliers.add(EXPENSIVE_MULTIPLIER); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> multipliers; }</code> </pre> <br>  Eine Vielzahl von Optionen f√ºhrt dazu, dass zwei oder drei Integrationstests hier nicht beschr√§nkt sind.  Ein minimalistischer Satz von Komponententests ist perfekt zum Debuggen solcher Funktionen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bk/jw/ai/bkjwai9dy1mrxxarxncx6jgfehq.jpeg"></div><br><br>  Die entsprechende Testsuite finden Sie in der Klasse <code>BonusPointCalculatorTest</code> .  Hier sind einige davon: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate_oneProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"product"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.00"</span></span>).build(); Customer customer = customer(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>).build(); Map&lt;Product, Long&gt; quantities = mapOf(product, <span class="hljs-number"><span class="hljs-number">1L</span></span>); BigDecimal bonus = bonusPointCalculator.calculate(customer, list(product), quantities::get); BigDecimal expectedBonus = bonusPoints(<span class="hljs-string"><span class="hljs-string">"0.10"</span></span>).build(); assertEquals(expectedBonus, bonus); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate_favProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"product"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.00"</span></span>).build(); Customer customer = customer(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>).favProduct(product).build(); Map&lt;Product, Long&gt; quantities = mapOf(product, <span class="hljs-number"><span class="hljs-number">1L</span></span>); BigDecimal bonus = bonusPointCalculator.calculate(customer, list(product), quantities::get); BigDecimal expectedBonus = bonusPoints(<span class="hljs-string"><span class="hljs-string">"0.10"</span></span>).addMultiplier(FAVORITE_MULTIPLIER).build(); assertEquals(expectedBonus, bonus); }</code> </pre> <br>  Es ist erw√§hnenswert, dass wir uns in den Tests speziell auf die √∂ffentliche API der Klasse beziehen - die <code>calculate</code> .  Durch das Testen eines Klassenvertrags anstelle seiner Implementierung werden Ausf√§lle von Tests aufgrund nicht funktionaler √Ñnderungen und Refactoring vermieden. <br><br>  Wenn wir schlie√ülich die interne Logik mit Komponententests √ºberpr√ºft haben, m√ºssen wir nicht mehr alle diese Details in die Integration einbeziehen.  In diesem Fall reicht ein mehr oder weniger repr√§sentativer Test aus, zum Beispiel: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateBonusPoints_twoProductTypes_correctValueCalculated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product1 = product(<span class="hljs-string"><span class="hljs-string">"product1"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.01"</span></span>).build(); Product product2 = product(<span class="hljs-string"><span class="hljs-string">"product2"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"10.00"</span></span>).build(); productRepository.save(product1); productRepository.save(product2); Customer customer = customer(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>).build(); customerRepository.save(customer); Map&lt;Long, Long&gt; quantities = mapOf(product1.getId(), <span class="hljs-number"><span class="hljs-number">1L</span></span>, product2.getId(), <span class="hljs-number"><span class="hljs-number">2L</span></span>); BigDecimal bonus = customerController.calculateBonusPoints( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CalculateBonusPointsRequest(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>, quantities) ); BigDecimal bonusPointsProduct1 = bonusPoints(<span class="hljs-string"><span class="hljs-string">"0.10"</span></span>).build(); BigDecimal bonusPointsProduct2 = bonusPoints(<span class="hljs-string"><span class="hljs-string">"1.00"</span></span>).quantity(<span class="hljs-number"><span class="hljs-number">2</span></span>).build(); BigDecimal expectedBonus = bonusPointsProduct1.add(bonusPointsProduct2); assertEquals(expectedBonus, bonus); }</code> </pre> <br>  Wie bei Integrationstests ist der verwendete Satz von Komponententests sehr klein und garantiert nicht die vollst√§ndige Richtigkeit der Anwendung.  Trotzdem erh√∂ht seine Pr√§senz das Vertrauen in den Code erheblich, erleichtert das Debuggen und gibt die anderen im ersten Teil des Artikels aufgef√ºhrten Boni. <br><br><a name="ImplementationConsiderations"></a><h2>  Implementierungsempfehlungen </h2><br>  Ich hoffe, die vorherigen Abschnitte haben ausgereicht, um mindestens einen Entwickler davon zu √ºberzeugen, Tests in seinem Projekt zu verwenden.  In diesem Kapitel werden kurz die wichtigsten Empfehlungen aufgef√ºhrt, die dazu beitragen, schwerwiegende Probleme zu vermeiden und die anf√§nglichen Implementierungskosten zu senken. <br><br>  <b>Versuchen Sie, die Tests f√ºr die neue Anwendung zu implementieren.</b>  Das Schreiben der ersten Tests in einem gro√üen Legacy-Projekt ist viel schwieriger und erfordert mehr Geschick als in einem frisch erstellten.  Daher ist es nach M√∂glichkeit besser, mit einer kleinen neuen Anwendung zu beginnen.  Wenn keine neuen vollwertigen Anwendungen erwartet werden, k√∂nnen Sie versuchen, ein n√ºtzliches Dienstprogramm f√ºr den internen Gebrauch zu entwickeln.  Die Hauptsache ist, dass die Aufgabe mehr oder weniger realistisch sein sollte - erfundene Beispiele geben keine vollst√§ndige Erfahrung. <br><br>  <b>Richten Sie regelm√§√üige Testl√§ufe ein.</b>  Wenn die Tests nicht regelm√§√üig ausgef√ºhrt werden, h√∂ren sie nicht nur auf, ihre Hauptfunktion auszuf√ºhren - die Richtigkeit des Codes zu √ºberpr√ºfen -, sondern sind auch schnell veraltet.  Daher ist es √§u√üerst wichtig, mindestens die minimale CI-Pipeline mit automatischem Teststart jedes Mal zu konfigurieren, wenn der Code im Repository aktualisiert wird. <br><br>  <b>Jagen Sie nicht die Abdeckung.</b>  Wie bei jeder anderen Technologie werden die Tests zun√§chst nicht in bester Qualit√§t durchgef√ºhrt.  Die einschl√§gige Literatur (Links am Ende des Artikels) oder ein kompetenter Mentor k√∂nnen hier helfen, aber dies macht die Notwendigkeit selbstf√ºllender Zapfen nicht zunichte.  Tests in dieser Hinsicht √§hneln dem Rest des Codes: Um zu verstehen, wie sie sich auf das Projekt auswirken, k√∂nnen Sie dies erst tun, nachdem Sie eine Weile mit ihnen gelebt haben.  Um den Schaden zu minimieren, ist es daher beim ersten Mal besser, die Anzahl und die sch√∂nen Zahlen nicht wie eine hundertprozentige Abdeckung zu verfolgen.  Stattdessen sollten Sie sich auf die wichtigsten positiven Szenarien f√ºr Ihre eigene Anwendungsfunktionalit√§t beschr√§nken. <br><br>  <b>Lassen Sie sich nicht von Unit-Tests mitrei√üen.</b>  In Fortsetzung des Themas ‚ÄûQuantit√§t gegen Qualit√§t‚Äú sollte beachtet werden, dass ehrliche Komponententests nicht zum ersten Mal durchgef√ºhrt werden sollten, da dies leicht zu einer √ºberm√§√üigen Spezifikation der Anwendung f√ºhren kann.  Dies wird wiederum zu einem schwerwiegenden Hemmfaktor f√ºr sp√§tere Refactoring- und Anwendungsverbesserungen.  Unit-Tests sollten nur verwendet werden, wenn in einer bestimmten Klasse oder Gruppe von Klassen eine komplexe Logik vorhanden ist, deren √úberpr√ºfung auf Integrationsebene unpraktisch ist. <br><br>  <b>Lassen Sie sich nicht von Stub-Klassen und Anwendungsmethoden mitrei√üen.</b>  Stubs (Stub, Mock) ist ein weiteres Werkzeug, das einen ausgewogenen Ansatz und die Aufrechterhaltung eines Gleichgewichts erfordert.  Einerseits k√∂nnen Sie sich durch die vollst√§ndige Isolierung des Ger√§ts auf die getestete Logik konzentrieren und nicht an den Rest des Systems denken.  Andererseits erfordert dies zus√§tzliche Entwicklungszeit und kann wie bei Unit-Tests zu einer √ºberm√§√üigen Spezifikation des Verhaltens f√ºhren. <br><br>  <b>L√∂sen Sie die Integrationstests von externen Systemen.</b>  Ein sehr h√§ufiger Fehler bei Integrationstests ist die Verwendung einer realen Datenbank, von Nachrichtenwarteschlangen und anderen Systemen au√üerhalb der Anwendung.  Nat√ºrlich ist die M√∂glichkeit, einen Test in einer realen Umgebung auszuf√ºhren, f√ºr das Debuggen und die Entwicklung hilfreich.  Solche Tests in kleinen Mengen k√∂nnen sinnvoll sein, insbesondere um interaktiv zu laufen.  Ihre weit verbreitete Verwendung f√ºhrt jedoch zu einer Reihe von Problemen: <br><br><ol><li>  Um die Tests auszuf√ºhren, m√ºssen Sie die externe Umgebung konfigurieren.  Installieren Sie beispielsweise eine Datenbank auf jedem Computer, auf dem die Anwendung zusammengestellt wird.  Dies erschwert es neuen Entwicklern, in das Projekt einzutreten und CI zu konfigurieren. </li><li>  Der Status externer Systeme kann auf verschiedenen Computern variieren, bevor die Tests ausgef√ºhrt werden.  Beispielsweise kann die Datenbank bereits die Tabellen enthalten, die die Anwendung mit Daten ben√∂tigt, die im Test nicht erwartet werden.  Dies f√ºhrt zu unvorhersehbaren Fehlern bei den Tests, und ihre Beseitigung erfordert einen erheblichen Zeitaufwand. </li><li>  Wenn an mehreren Projekten parallel gearbeitet wird, ist der nicht offensichtliche Einfluss einiger Projekte auf andere m√∂glich.  Beispielsweise k√∂nnen bestimmte Datenbankeinstellungen, die f√ºr eines der Projekte vorgenommen wurden, dazu beitragen, dass die Funktionalit√§t eines anderen Projekts ordnungsgem√§√ü funktioniert. Diese Funktion wird jedoch unterbrochen, wenn sie auf einer sauberen Datenbank auf einem anderen Computer gestartet wird. </li><li>  Tests werden √ºber einen langen Zeitraum durchgef√ºhrt: Ein vollst√§ndiger Lauf kann mehrere zehn Minuten dauern.  Dies f√ºhrt dazu, dass Entwickler die lokale Ausf√ºhrung von Tests beenden und ihre Ergebnisse erst nach dem Senden der √Ñnderungen an das Remote-Repository anzeigen.  Dieses Verhalten negiert die meisten Vorteile der Tests, die im ersten Teil des Artikels er√∂rtert wurden. </li></ol><br>  <b>L√∂schen Sie den Kontext zwischen Integrationstests.</b>  Um die Arbeit von Integrationstests zu beschleunigen, m√ºssen Sie h√§ufig denselben Kontext zwischen ihnen wiederverwenden.  Sogar die offizielle Fr√ºhlingsdokumentation gibt eine solche Empfehlung ab.  Gleichzeitig sollte der Einfluss von Tests aufeinander vermieden werden.  Da sie in beliebiger Reihenfolge gestartet werden, kann das Vorhandensein solcher Verbindungen zu zuf√§lligen, nicht reproduzierbaren Fehlern f√ºhren.  Um dies zu verhindern, sollten die Tests keine √Ñnderungen im Kontext hinterlassen.  Wenn Sie beispielsweise eine Datenbank verwenden, reicht es normalerweise zur Isolierung aus, alle im Test festgeschriebenen Transaktionen zur√ºckzusetzen.  Wenn √Ñnderungen am Kontext nicht vermieden werden k√∂nnen, k√∂nnen Sie die Neuerstellung mithilfe der Annotation <code>@DirtiesContext</code> konfigurieren. <br><br> <b>  ,      .</b>         ,       - .    ,            .  ,   , ‚Äî      ,           . <br><br> <b>      .</b>      ,    ,       . ,    ,       . <br><br> <b>   TDD (Test-Driven Development).</b> TDD    ,      ,     .  ,        ,     .   ,         ,        . <br><br><h2>   ,  ? </h2><br>              ,  : <br><br><ol><li>       (  )?             . </li><li>           ,      ( ,  CI)?    . </li><li>     ?                     . </li><li>     ?    .   ,      ,      . </li></ol><br>        ,      .     , , -   .   ‚Äî           . <br><br><a name="Conclusion"></a><h2>  Fazit </h2><br>       ,     .    -    ,    .  ,  -      .        ‚Äî         ,      ,    -.      ,                 . <br><br> ,    ,        ,            ! <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   GitHub</a> <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Growing Object-Oriented Software, Guided by Tests</a> , Steve Freeman, Nat Pryce <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The Art of Unit Testing</a> , Roy Osherove <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Test-driven Development: By Example</a> , Kent Beck <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Refactoring: Improving the Design of Existing Code</a> , Martin Fowler <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427603/">https://habr.com/ru/post/de427603/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427589/index.html">Wir schreiben einen Online-Chat auf Websockets mit Swoole</a></li>
<li><a href="../de427591/index.html">Architektur als Belastung</a></li>
<li><a href="../de427593/index.html">Schnellbefehlsmagie in Vivaldi 2.1</a></li>
<li><a href="../de427595/index.html">Versuchen Sie Micronaut oder Darling, ich habe das Framework reduziert</a></li>
<li><a href="../de427601/index.html">5 + 1 Fall, in dem die REST-API-Spezifikation eine gro√üe Rolle spielt</a></li>
<li><a href="../de427605/index.html">Wie die Crowdsourcing-Plattform von Yandex Drohnen trainiert und die Servicequalit√§t bewertet</a></li>
<li><a href="../de427607/index.html">Rechenzentrum in der Schweiz: wie am Schn√ºrchen arbeiten</a></li>
<li><a href="../de427609/index.html">L√∂sen der Gleichung mit ganzzahliger Division ohne rohe Gewalt</a></li>
<li><a href="../de427611/index.html">Die Geschichte, wie ich Yandex MapKit auf iOS oder Karten aktualisiert habe, Geld, 2 Mappits</a></li>
<li><a href="../de427613/index.html">10 n√ºtzliche Blogs f√ºr Programmierer in Englisch</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>