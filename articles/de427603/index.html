<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍗 🐙 👨🏾‍🏭 Wie man endlich anfängt, Tests zu schreiben und es nicht bereut 💨 🏛️ 🛁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn ich zu einem neuen Projekt komme, stoße ich regelmäßig auf eine der folgenden Situationen: 



1. Es gibt überhaupt keine Tests. 
2. Es gibt nur ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man endlich anfängt, Tests zu schreiben und es nicht bereut</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/custis/blog/427603/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/vr/v7/q_/vrv7q_kwfiqd5f7qx7jxwukv62g.jpeg"></a> <br><br>  Wenn ich zu einem neuen Projekt komme, stoße ich regelmäßig auf eine der folgenden Situationen: <br><br><ol><li>  Es gibt überhaupt keine Tests. </li><li>  Es gibt nur wenige Tests, sie werden selten geschrieben und nicht fortlaufend ausgeführt. </li><li>  Tests sind vorhanden und in CI (Continuous Integration) enthalten, schaden aber mehr als sie nützen. </li></ol><br>  Leider ist es das letztere Szenario, das häufig zu ernsthaften Versuchen führt, Tests durchzuführen, wenn keine geeigneten Fähigkeiten vorhanden sind. <br><br>  Was kann getan werden, um die aktuelle Situation zu ändern?  Die Idee, Tests zu verwenden, ist nicht neu.  Gleichzeitig ähneln die meisten Tutorials dem berühmten Bild, wie man eine Eule zeichnet: Verbinden Sie JUnit, schreiben Sie den ersten Test, verwenden Sie den ersten Mock - und los geht's!  Solche Artikel beantworten keine Fragen darüber, welche Tests geschrieben werden müssen, worauf es sich zu achten lohnt und wie man damit umgeht.  Von hier aus wurde die Idee dieses Artikels geboren.  Ich habe versucht, meine Erfahrungen bei der Implementierung von Tests in verschiedenen Projekten kurz zusammenzufassen, um diesen Weg für alle zu erleichtern. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ra/7v/m-/ra7vm-kgn__gsmaeg6xg7aud4ey.jpeg"></div><br>  Es gibt mehr als genug einführende Artikel zu diesem Thema, daher werden wir uns nicht wiederholen und versuchen, von der anderen Seite zu gehen.  Im ersten Teil werden wir den Mythos entlarven, dass das Testen ausschließlich zusätzliche Kosten verursacht.  Es wird gezeigt, wie die Erstellung von Qualitätstests wiederum den Entwicklungsprozess beschleunigen kann.  Am Beispiel eines kleinen Projekts werden dann die Grundprinzipien und Regeln berücksichtigt, die befolgt werden sollten, um diesen Vorteil zu realisieren.  Schließlich werden im letzten Abschnitt spezifische Implementierungsempfehlungen gegeben: Wie können typische Probleme vermieden werden, wenn Tests beginnen, im Gegenteil, die Entwicklung wird erheblich verlangsamt. <br><br>  Da meine Hauptspezialisierung das Java-Backend ist, wird in den Beispielen der folgende Technologie-Stack verwendet: Java, JUnit, H2, Mockito, Spring, Hibernate.  Gleichzeitig widmet sich ein wesentlicher Teil des Artikels allgemeinen Testproblemen, und die darin enthaltenen Tipps gelten für ein viel breiteres Aufgabenspektrum. <br><br>  Seien Sie jedoch vorsichtig!  Tests machen süchtig: Wenn Sie erst einmal gelernt haben, wie man sie benutzt, können Sie nicht mehr ohne sie leben. <br><br><div class="spoiler">  <b class="spoiler_title">Inhalt</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tests gegen Entwicklungsgeschwindigkeit</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code an jedem Ort ausführen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tests neu starten</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Debuggen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wirksamkeit</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Von der Theorie zur Praxis</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Herausforderung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Domänenmodell</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projektstruktur</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Integrationstests</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unit-Tests</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierungsempfehlungen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fazit</a> </div></div><br><a name="TestsVsSpeed"></a><h2>  Tests gegen Entwicklungsgeschwindigkeit </h2><br>  Die wichtigsten Fragen, die sich bei der Erörterung der Implementierung von Tests stellen: Wie lange dauert das Schreiben von Tests und welche Vorteile ergeben sich daraus?  Das Testen erfordert wie jede andere Technologie ernsthafte Anstrengungen für die Entwicklung und Implementierung, sodass zunächst keine signifikanten Vorteile zu erwarten sind.  Die Zeitkosten hängen stark vom jeweiligen Team ab.  Weniger als 20-30% der zusätzlichen Kosten für die Codierung sollten jedoch nicht genau berechnet werden.  Weniger ist einfach nicht genug, um zumindest ein Ergebnis zu erzielen.  Die Erwartung sofortiger Renditen ist häufig der Hauptgrund für die Einschränkung dieser Aktivität, noch bevor die Tests nützlich werden. <br><br>  Aber über welche Art von Effizienz sprechen wir?  Lassen Sie uns die Texte über die Schwierigkeiten bei der Implementierung fallen und sehen, welche spezifischen Möglichkeiten zum Sparen von Zeit beim Testen eröffnet werden. <br><br><a name="CodeRun"></a><h3>  Code an jedem Ort ausführen </h3><br>  Wenn das Projekt keine Tests enthält, können Sie nur die gesamte Anwendung anheben.  Es ist gut, wenn es ungefähr 15 bis 20 Sekunden dauert, aber Fälle von großen Projekten, bei denen ein vollständiger Start mehrere Minuten dauern kann, sind alles andere als selten.  Was bedeutet das für Entwickler?  Ein wesentlicher Teil ihrer Arbeitszeit sind diese kurzen Wartesitzungen, in denen Sie nicht weiter an der aktuellen Aufgabe arbeiten können, aber gleichzeitig zu wenig Zeit bleibt, um zu etwas anderem zu wechseln.  Viele sind mindestens einmal auf solche Projekte gestoßen, bei denen der in einer Stunde geschriebene Code aufgrund langer Neustarts zwischen den Korrekturen viele Stunden Debugging erfordert.  In Tests können Sie sich darauf beschränken, kleine Teile der Anwendung auszuführen, was die Wartezeit erheblich verkürzt und die Produktivität bei der Arbeit an Code erhöht. <br><br>  Darüber hinaus führt die Möglichkeit, Code an jedem Ort auszuführen, zu einem gründlicheren Debugging.  Oft erfordert das Überprüfen selbst der wichtigsten positiven Anwendungsfälle über die Anwendungsoberfläche einen erheblichen Aufwand und Zeitaufwand.  Das Vorhandensein von Tests ermöglicht es, eine detaillierte Überprüfung einer bestimmten Funktion viel einfacher und schneller durchzuführen. <br><br>  Ein weiteres Plus ist die Möglichkeit, die Größe der getesteten Einheit zu regulieren.  Abhängig von der Komplexität der zu testenden Logik können Sie sich auf eine Methode, eine Klasse, eine Gruppe von Klassen, die bestimmte Funktionen implementieren, einen Dienst usw. bis hin zur Automatisierung des Testens der gesamten Anwendung beschränken.  Diese Flexibilität ermöglicht es Ihnen, Tests auf hoher Ebene von vielen Teilen zu entfernen, da diese auf niedrigeren Ebenen getestet werden. <br><br><a name="RepeatedRun"></a><h3>  Tests neu starten </h3><br>  Dieses Plus wird oft als die Essenz der Testautomatisierung bezeichnet, aber lassen Sie uns es aus einem weniger vertrauten Blickwinkel betrachten.  Welche neuen Möglichkeiten eröffnen sich Entwicklern? <br><br>  Erstens kann jeder neue Entwickler, der zum Projekt gekommen ist, problemlos vorhandene Tests ausführen, um die Anwendungslogik anhand von Beispielen zu verstehen.  Leider wird die Bedeutung davon stark unterschätzt.  Unter modernen Bedingungen arbeiten dieselben Leute selten länger als 1-2 Jahre an einem Projekt.  Und da die Teams aus mehreren Personen bestehen, ist das Erscheinen eines neuen Teilnehmers alle 2-3 Monate eine typische Situation für relativ große Projekte.  Besonders schwierige Projekte durchlaufen Schichten ganzer Entwicklergenerationen!  Die Möglichkeit, einen beliebigen Teil der Anwendung einfach zu starten und das Verhalten des Systems zu überprüfen, vereinfacht das Eintauchen neuer Programmierer in das Projekt.  Darüber hinaus reduziert eine detailliertere Untersuchung der Codelogik die Anzahl der am Ausgang gemachten Fehler und die Zeit, um sie in Zukunft zu debuggen. <br><br>  Zweitens eröffnet die Möglichkeit, auf einfache Weise zu überprüfen, ob die Anwendung ordnungsgemäß funktioniert, den Weg für ein kontinuierliches Refactoring.  Dieser Begriff ist leider viel weniger beliebt als CI.  Dies bedeutet, dass das Refactoring jedes Mal durchgeführt werden kann und sollte, wenn der Code verfeinert wird.  Es ist die regelmäßige Einhaltung der berüchtigten Pfadfinder-Regel „Verlassen Sie den Parkplatz sauberer als vor Ihrer Ankunft“, die eine Verschlechterung der Codebasis vermeidet und dem Projekt ein langes und glückliches Leben garantiert. <br><br><a name="Debugging"></a><h3>  Debuggen </h3><br>  Das Debuggen wurde bereits in den vorhergehenden Absätzen erwähnt, aber dieser Punkt ist so wichtig, dass er näher betrachtet werden muss.  Leider gibt es keine zuverlässige Möglichkeit, die Beziehung zwischen der Zeit, die für das Schreiben und Debuggen von Code aufgewendet wurde, zu messen, da diese Prozesse praktisch untrennbar miteinander verbunden sind.  Trotzdem reduziert das Vorhandensein von Qualitätstests im Projekt die Debugging-Zeit erheblich, bis fast kein Debugger mehr ausgeführt werden muss. <br><br><a name="Efficiency"></a><h3>  Wirksamkeit </h3><br>  All dies kann beim ersten Debuggen des Codes erheblich Zeit sparen.  Nur mit dem richtigen Ansatz werden alle zusätzlichen Entwicklungskosten bezahlt.  Die verbleibenden Testboni - Verbesserung der Qualität der Codebasis (schlecht gestalteter Code ist schwer zu testen), Reduzierung der Anzahl von Fehlern, Möglichkeit, die Richtigkeit des Codes jederzeit zu überprüfen usw. - werden fast kostenlos. <br><br><a name="FromTheoryToPractice"></a><h2>  Von der Theorie zur Praxis </h2><br>  In Worten, alles sieht gut aus, aber kommen wir zur Sache.  Wie bereits erwähnt, gibt es mehr als genug Materialien für die anfängliche Einrichtung der Testumgebung.  Deshalb fahren wir sofort mit dem fertigen Projekt fort.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellen hier.</a> <br><br><a name="Task"></a><h3>  Herausforderung </h3><br>  Betrachten Sie als Vorlagenaufgabe ein kleines Fragment des Backends eines Online-Shops.  Wir werden eine typische API für die Arbeit mit Produkten schreiben: Erstellen, Empfangen, Bearbeiten.  Sowie einige Methoden für die Arbeit mit Kunden: Ändern eines „Lieblingsprodukts“ und Berechnen von Bonuspunkten für eine Bestellung. <br><br><a name="DomainModel"></a><h3>  Domänenmodell </h3><br>  Um das Beispiel nicht zu überladen, beschränken wir uns auf eine minimale Anzahl von Feldern und Klassen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wc/pn/pz/wcpnpz94fmrb-av0-wkkuu4l2wi.jpeg"></div><br><br>  Der Kunde hat einen Benutzernamen, einen Link zu einem Lieblingsprodukt und eine Flagge, die angibt, ob er ein Premium-Kunde ist. <br><br>  Produkt (Produkt) - Name, Preis, Rabatt und Flagge, die angeben, ob es derzeit beworben wird. <br><br><a name="ProjectStructure"></a><h3>  Projektstruktur </h3><br>  Die Struktur des Hauptprojektcodes ist wie folgt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ks/qa/m3/ksqam31c3vwkzdfwkmi8r7o3ggk.jpeg"></div><br><br>  Klassen sind geschichtet: <br><br><ul><li>  Modell - Domänenmodell des Projekts; </li><li>  Jpa - Repositories für die Arbeit mit Datenbanken basierend auf Spring Data; </li><li>  Service - Geschäftslogik der Anwendung; </li><li>  Controller - Controller, die die API implementieren. </li></ul><br>  Unit Test Struktur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i3/_1/mi/i3_1micxy4kvvlb6dlgihfmmng0.jpeg"></div><br><br>  Testklassen befinden sich in denselben Paketen wie der ursprüngliche Code.  Zusätzlich wurde ein Paket mit Buildern zur Aufbereitung von Testdaten erstellt, aber mehr dazu weiter unten. <br><br>  Es ist bequem, Unit-Tests und Integrationstests zu trennen.  Sie haben oft unterschiedliche Abhängigkeiten, und für eine komfortable Entwicklung sollte es die Möglichkeit geben, entweder die eine oder die andere auszuführen.  Dies kann auf verschiedene Arten erreicht werden: Namenskonventionen, Module, Pakete, sourceSets.  Die Wahl einer bestimmten Methode ist ausschließlich Geschmackssache.  In diesem Projekt liegen Integrationstests in einem separaten sourceSet - IntegrationTest. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qq/1w/z7/qq1wz7n9tq77_zromu01ofx9cns.jpeg"></div><br><br>  Klassen mit Integrationstests befinden sich wie Komponententests in denselben Paketen wie der ursprüngliche Code.  Darüber hinaus gibt es Basisklassen, mit denen Konfigurationsduplikationen beseitigt werden können und die bei Bedarf nützliche universelle Methoden enthalten. <br><br><a name="IntegrationTests"></a><h3>  Integrationstests </h3><br>  Es gibt verschiedene Ansätze, mit welchen Tests es sich zu beginnen lohnt.  Wenn die getestete Logik nicht sehr kompliziert ist, können Sie sofort mit den Integrationslogiken fortfahren (sie werden manchmal auch als Akzeptanzlogiken bezeichnet).  Im Gegensatz zu Unit-Tests stellen sie sicher, dass die Anwendung insgesamt ordnungsgemäß funktioniert. <br><br>  <b>Architektur</b> <br><br>  Zunächst müssen Sie entscheiden, auf welcher Ebene Integrationsprüfungen durchgeführt werden sollen.  Spring Boot bietet vollständige Wahlfreiheit: Sie können einen Teil des Kontexts, den gesamten Kontext und sogar einen vollwertigen Server, auf den über die Tests zugegriffen werden kann, aufrufen.  Mit zunehmender Größe der Anwendung wird dieses Problem immer komplexer.  Oft muss man verschiedene Tests auf verschiedenen Ebenen schreiben. <br><br>  Ein guter Ausgangspunkt wären Controller-Tests ohne Start des Servers.  In relativ kleinen Anwendungen ist es durchaus akzeptabel, den gesamten Kontext zu erhöhen, da er standardmäßig zwischen den Tests wiederverwendet und nur einmal initialisiert wird.  Betrachten Sie die grundlegenden Methoden der <code>ProductController</code> Klasse: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@PostMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"new"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@RequestBody Product product)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productService.createProduct(product); } <span class="hljs-meta"><span class="hljs-meta">@GetMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"{productId}"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@PathVariable(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"productId"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> productId) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productService.getProduct(productId); } <span class="hljs-meta"><span class="hljs-meta">@PostMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"{productId}/edit"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@PathVariable(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"productId"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> productId, @RequestBody Product product) </span></span>{ productService.updateProduct(productId, product); }</code> </pre> <br>  Das Problem der Fehlerbehandlung bleibt unberücksichtigt.  Angenommen, es wird extern implementiert, basierend auf einer Analyse der ausgelösten Ausnahmen.  Der Code der Methoden ist sehr einfach, ihre Implementierung im <code>ProductService</code> nicht viel komplizierter: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span>(readOnly = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long productId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productRepository.findById(productId) .orElseThrow(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataNotFoundException(<span class="hljs-string"><span class="hljs-string">"Product"</span></span>, productId)); } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Product product)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productRepository.save(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Product(product)); } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long productId, Product product)</span></span></span><span class="hljs-function"> </span></span>{ Product dbProduct = productRepository.findById(productId) .orElseThrow(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataNotFoundException(<span class="hljs-string"><span class="hljs-string">"Product"</span></span>, productId)); dbProduct.setPrice(product.getPrice()); dbProduct.setDiscount(product.getDiscount()); dbProduct.setName(product.getName()); dbProduct.setIsAdvertised(product.isAdvertised()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productRepository.save(dbProduct); }</code> </pre> <br>  Das <code>ProductRepository</code> Repository enthält überhaupt keine eigenen Methoden: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Long</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre> <br>  Alles deutet darauf hin, dass diese Klassen keine Komponententests benötigen, nur weil die gesamte Kette durch mehrere Integrationstests einfach und effizient überprüft werden kann.  Das Duplizieren derselben Tests in verschiedenen Tests erschwert das Debuggen.  Im Falle eines Fehlers im Code fällt jetzt nicht ein Test, sondern 10-15 auf einmal.  Dies erfordert wiederum eine weitere Analyse.  Wenn es keine Duplizierung gibt, zeigt der einzige Test wahrscheinlich sofort einen Fehler an. <br><br>  <b>Konfiguration</b> <br><br>  Der <code>BaseControllerIT</code> markieren wir die Basisklasse <code>BaseControllerIT</code> , die die Spring-Konfiguration und einige Felder enthält: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(SpringRunner.class) <span class="hljs-meta"><span class="hljs-meta">@SpringBootTest</span></span>(webEnvironment = SpringBootTest.WebEnvironment.NONE) <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseControllerIT</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> ProductRepository productRepository; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> CustomerRepository customerRepository; }</code> </pre> <br>  Repositorys werden in die Basisklasse verschoben, um die Testklassen nicht zu überladen.  Ihre Rolle ist ausschließlich eine Hilfsfunktion: Daten vorbereiten und den Status der Datenbank überprüfen, nachdem der Controller funktioniert.  Wenn Sie die Größe der Anwendung erhöhen, ist dies möglicherweise nicht mehr praktisch, aber für den Anfang ist es durchaus geeignet. <br><br>  Die Hauptkonfiguration von Spring wird durch die folgenden Zeilen definiert: <br><br>  <code>@SpringBootTest</code> - wird verwendet, um den Kontext der Anwendung <code>@SpringBootTest</code> .  <code>WebEnvironment.NONE</code> bedeutet, dass kein <code>WebEnvironment.NONE</code> muss. <br><br>  <code>@Transactional</code> - <code>@Transactional</code> alle Klassentests in einer Transaktion mit automatischem Rollback, um den Status der Datenbank zu speichern. <br><br>  <b>Teststruktur</b> <br><br>  Kommen wir zu einer minimalistischen Reihe von Tests für die <code>ProductController</code> Klasse - <code>ProductControllerIT</code> . <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProduct_productSaved</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.01"</span></span>).discount(<span class="hljs-string"><span class="hljs-string">"0.1"</span></span>).advertised(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>).build(); Product createdProduct = productController.createProduct(product); Product dbProduct = productRepository.getOne(createdProduct.getId()); assertEquals(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>, dbProduct.getName()); assertEquals(number(<span class="hljs-string"><span class="hljs-string">"1.01"</span></span>), dbProduct.getPrice()); assertEquals(number(<span class="hljs-string"><span class="hljs-string">"0.1"</span></span>), dbProduct.getDiscount()); assertEquals(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, dbProduct.isAdvertised()); }</code> </pre> <br>  Der Testcode sollte auf einen Blick äußerst einfach und verständlich sein.  Ist dies nicht der Fall, gehen die meisten Vorteile der im ersten Abschnitt des Artikels beschriebenen Tests verloren.  Es wird empfohlen, den Testkörper in drei Teile zu unterteilen, die visuell voneinander getrennt werden können: Daten vorbereiten, Testmethode aufrufen, Ergebnisse validieren.  Gleichzeitig ist es sehr wünschenswert, dass der Testcode auf den gesamten Bildschirm passt. <br><br>  Persönlich erscheint es mir offensichtlicher, wenn die Testwerte aus dem Abschnitt Datenaufbereitung später in den Prüfungen verwendet werden.  Alternativ können Sie Objekte explizit vergleichen, zum Beispiel wie folgt: <br><br><pre> <code class="java hljs">assertEquals(product, dbProduct);</code> </pre> <br>  In einem anderen Test zum Aktualisieren von Produktinformationen ( <code>updateProduct</code> ) wird deutlich, dass die Erstellung von Daten etwas komplizierter geworden ist. <code>updateProduct</code> die visuelle Integrität der drei Teile des Tests zu <code>updateProduct</code> , werden sie durch zwei Zeilenvorschübe hintereinander getrennt: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateProduct_productUpdated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>).build(); productRepository.save(product); Product updatedProduct = product(<span class="hljs-string"><span class="hljs-string">"updatedName"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.1"</span></span>).discount(<span class="hljs-string"><span class="hljs-string">"0.5"</span></span>).advertised(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>).build(); updatedProduct.setId(product.getId()); productController.updateProduct(product.getId(), updatedProduct); Product dbProduct = productRepository.getOne(product.getId()); assertEquals(<span class="hljs-string"><span class="hljs-string">"updatedName"</span></span>, dbProduct.getName()); assertEquals(number(<span class="hljs-string"><span class="hljs-string">"1.1"</span></span>), dbProduct.getPrice()); assertEquals(number(<span class="hljs-string"><span class="hljs-string">"0.5"</span></span>), dbProduct.getDiscount()); assertEquals(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, dbProduct.isAdvertised()); }</code> </pre> <br>  Jeder der drei Teile des Teigs kann vereinfacht werden.  Für die Datenaufbereitung eignen sich Testbuilder hervorragend, die die Logik zum Erstellen von Objekten enthalten, die für die Verwendung aus Tests geeignet ist.  Zu komplexe Methodenaufrufe können zu Hilfsmethoden in Testklassen gemacht werden, wodurch einige der Parameter ausgeblendet werden, die für diese Klasse irrelevant sind.  Um komplexe Prüfungen zu vereinfachen, können Sie auch Hilfsfunktionen schreiben oder eigene Matcher implementieren.  Die Hauptsache bei all diesen Vereinfachungen ist, die Sichtbarkeit des Tests nicht zu verlieren: Alles sollte auf einen Blick auf die Hauptmethode klar sein, ohne tiefer gehen zu müssen. <br><br>  <b>Testbauer</b> <br><br>  Testbauer verdienen besondere Aufmerksamkeit.  Das Einkapseln der Logik zum Erstellen von Objekten vereinfacht die Testwartung.  Insbesondere das Ausfüllen von Modellfeldern, die für diesen Test nicht relevant sind, kann im Builder ausgeblendet werden.  Dazu müssen Sie es nicht direkt erstellen, sondern verwenden eine statische Methode, die die fehlenden Felder mit Standardwerten ausfüllt.  Wenn beispielsweise neue erforderliche Felder im Modell angezeigt werden, können sie dieser Methode problemlos hinzugefügt werden.  In <code>ProductBuilder</code> sieht es so aus: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ProductBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">product</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProductBuilder() .name(name) .advertised(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) .price(<span class="hljs-string"><span class="hljs-string">"0.00"</span></span>); }</code> </pre> <br>  <b>Testname</b> <br><br>  Es ist unbedingt zu verstehen, was in diesem Test speziell getestet wird.  Aus Gründen der Klarheit ist es am besten, diese Frage im Titel zu beantworten.  Berücksichtigen Sie bei Verwendung der Beispieltests für die Methode <code>getProduct</code> die verwendete Namenskonvention: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProduct_oneProductInDb_productReturned</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>).build(); productRepository.save(product); Product result = productController.getProduct(product.getId()); assertEquals(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>, result.getName()); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProduct_twoProductsInDb_correctProductReturned</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product1 = product(<span class="hljs-string"><span class="hljs-string">"product1"</span></span>).build(); Product product2 = product(<span class="hljs-string"><span class="hljs-string">"product2"</span></span>).build(); productRepository.save(product1); productRepository.save(product2); Product result = productController.getProduct(product1.getId()); assertEquals(<span class="hljs-string"><span class="hljs-string">"product1"</span></span>, result.getName()); }</code> </pre> <br>  Im allgemeinen Fall besteht die Überschrift der Testmethode aus drei Teilen, die durch Unterstreichung getrennt sind: dem Namen der zu testenden Methode, dem Skript und dem erwarteten Ergebnis.  Es hat jedoch niemand den gesunden Menschenverstand aufgehoben, und es kann gerechtfertigt sein, einige Teile des Namens wegzulassen, wenn sie in diesem Zusammenhang nicht benötigt werden (z. B. ein Skript in einem einzelnen Test zum Erstellen eines Produkts).  Mit dieser Benennung soll sichergestellt werden, dass die Essenz jedes Tests verständlich ist, ohne den Code zu lernen.  Dies macht das Fenster der Testergebnisse so klar wie möglich und damit beginnt normalerweise die Arbeit mit Tests. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gu/0k/p9/gu0kp9p5hdbswo4i8d6ti2sy1qi.jpeg"></div><br><br>  <b>Schlussfolgerungen</b> <br><br>  Das ist alles.  Zum ersten Mal reicht ein minimaler Satz von vier Tests aus, um die Methoden der <code>ProductController</code> Klasse zu testen.  Im Falle der Erkennung von Fehlern können Sie die fehlenden Tests jederzeit hinzufügen.  Gleichzeitig reduziert die Mindestanzahl von Tests den Zeit- und Arbeitsaufwand für deren Unterstützung erheblich.  Dies ist wiederum für den Implementierungsprozess des Testens von entscheidender Bedeutung, da die ersten Tests normalerweise nicht von bester Qualität sind und viele unerwartete Probleme verursachen.  Gleichzeitig reicht eine solche Testsuite völlig aus, um die im ersten Teil des Artikels beschriebenen Boni zu erhalten. <br><br>  Es ist erwähnenswert, dass solche Tests die Webebene der Anwendung nicht überprüfen, dies ist jedoch häufig nicht erforderlich.  Bei Bedarf können Sie separate Tests für die <code>@WebMvcTest</code> mit einem Stub anstelle der Basis ( <code>@WebMvcTest</code> , <code>MockMvc</code> , <code>@MockBean</code> ) <code>@MockBean</code> oder einen vollwertigen Server verwenden.  Letzteres kann das Debuggen und die Arbeit mit Transaktionen erschweren, da der Test die Transaktion des Servers nicht steuern kann.  Ein Beispiel für einen solchen Integrationstest finden Sie in der <code>CustomerControllerServerIT</code> Klasse. <br><br><a name="UnitTests"></a><h3>  Unit-Tests </h3><br>  Unit-Tests haben gegenüber Integrationstests mehrere Vorteile: <br><br><ul><li>  Der Start dauert Millisekunden. </li><li>  Kleine Größe der getesteten Einheit; </li><li>  Die Überprüfung einer großen Anzahl von Optionen ist einfach zu implementieren, da beim direkten Aufruf der Methode die Datenaufbereitung erheblich vereinfacht wird. </li></ul><br>  Trotzdem können Unit-Tests aufgrund ihrer Natur die Funktionsfähigkeit der gesamten Anwendung nicht garantieren und ermöglichen es Ihnen nicht, das Schreiben von Integrations-Tests zu vermeiden.  Wenn die Logik der zu testenden Einheit einfach ist, bringt das Duplizieren von Integrationstests mit Komponententests keine Vorteile, sondern fügt nur mehr Code zur Unterstützung hinzu. <br><br>  Die einzige Klasse in diesem Beispiel, die Unit-Tests verdient, ist der <code>BonusPointCalculator</code> .  Sein Unterscheidungsmerkmal ist eine große Anzahl von Zweigen der Geschäftslogik.  Beispielsweise wird angenommen, dass der Käufer einen Bonus von 10% der Produktkosten erhält, multipliziert mit nicht mehr als 2 Multiplikatoren aus der folgenden Liste: <br><br><ul><li>  Das Produkt kostet mehr als 10.000 (× 4); </li><li>  Das Produkt nimmt an einer Werbekampagne teil (× 3); </li><li>  Das Produkt ist das „Lieblingsprodukt“ des Kunden (× 5); </li><li>  Der Kunde hat einen Premium-Status (× 2); </li><li>  Wenn der Kunde einen Premium-Status hat und ein „Lieblingsprodukt“ kauft, wird anstelle der beiden angegebenen Multiplikatoren einer (× 8) verwendet. </li></ul><br>  Im wirklichen Leben wäre es natürlich sinnvoll, einen flexiblen universellen Mechanismus zur Berechnung dieser Boni zu entwickeln, aber um das Beispiel zu vereinfachen, beschränken wir uns auf eine feste Implementierung.  Der Multiplikator-Berechnungscode sieht folgendermaßen aus: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;BigDecimal&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateMultipliers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Customer customer, Product product)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;BigDecimal&gt; multipliers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (customer.getFavProduct() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; customer.getFavProduct().equals(product)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (customer.isPremium()) { multipliers.add(PREMIUM_FAVORITE_MULTIPLIER); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { multipliers.add(FAVORITE_MULTIPLIER); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (customer.isPremium()) { multipliers.add(PREMIUM_MULTIPLIER); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (product.isAdvertised()) { multipliers.add(ADVERTISED_MULTIPLIER); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (product.getPrice().compareTo(EXPENSIVE_THRESHOLD) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { multipliers.add(EXPENSIVE_MULTIPLIER); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> multipliers; }</code> </pre> <br>  Eine Vielzahl von Optionen führt dazu, dass zwei oder drei Integrationstests hier nicht beschränkt sind.  Ein minimalistischer Satz von Komponententests ist perfekt zum Debuggen solcher Funktionen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bk/jw/ai/bkjwai9dy1mrxxarxncx6jgfehq.jpeg"></div><br><br>  Die entsprechende Testsuite finden Sie in der Klasse <code>BonusPointCalculatorTest</code> .  Hier sind einige davon: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate_oneProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"product"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.00"</span></span>).build(); Customer customer = customer(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>).build(); Map&lt;Product, Long&gt; quantities = mapOf(product, <span class="hljs-number"><span class="hljs-number">1L</span></span>); BigDecimal bonus = bonusPointCalculator.calculate(customer, list(product), quantities::get); BigDecimal expectedBonus = bonusPoints(<span class="hljs-string"><span class="hljs-string">"0.10"</span></span>).build(); assertEquals(expectedBonus, bonus); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate_favProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"product"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.00"</span></span>).build(); Customer customer = customer(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>).favProduct(product).build(); Map&lt;Product, Long&gt; quantities = mapOf(product, <span class="hljs-number"><span class="hljs-number">1L</span></span>); BigDecimal bonus = bonusPointCalculator.calculate(customer, list(product), quantities::get); BigDecimal expectedBonus = bonusPoints(<span class="hljs-string"><span class="hljs-string">"0.10"</span></span>).addMultiplier(FAVORITE_MULTIPLIER).build(); assertEquals(expectedBonus, bonus); }</code> </pre> <br>  Es ist erwähnenswert, dass wir uns in den Tests speziell auf die öffentliche API der Klasse beziehen - die <code>calculate</code> .  Durch das Testen eines Klassenvertrags anstelle seiner Implementierung werden Ausfälle von Tests aufgrund nicht funktionaler Änderungen und Refactoring vermieden. <br><br>  Wenn wir schließlich die interne Logik mit Komponententests überprüft haben, müssen wir nicht mehr alle diese Details in die Integration einbeziehen.  In diesem Fall reicht ein mehr oder weniger repräsentativer Test aus, zum Beispiel: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateBonusPoints_twoProductTypes_correctValueCalculated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product1 = product(<span class="hljs-string"><span class="hljs-string">"product1"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.01"</span></span>).build(); Product product2 = product(<span class="hljs-string"><span class="hljs-string">"product2"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"10.00"</span></span>).build(); productRepository.save(product1); productRepository.save(product2); Customer customer = customer(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>).build(); customerRepository.save(customer); Map&lt;Long, Long&gt; quantities = mapOf(product1.getId(), <span class="hljs-number"><span class="hljs-number">1L</span></span>, product2.getId(), <span class="hljs-number"><span class="hljs-number">2L</span></span>); BigDecimal bonus = customerController.calculateBonusPoints( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CalculateBonusPointsRequest(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>, quantities) ); BigDecimal bonusPointsProduct1 = bonusPoints(<span class="hljs-string"><span class="hljs-string">"0.10"</span></span>).build(); BigDecimal bonusPointsProduct2 = bonusPoints(<span class="hljs-string"><span class="hljs-string">"1.00"</span></span>).quantity(<span class="hljs-number"><span class="hljs-number">2</span></span>).build(); BigDecimal expectedBonus = bonusPointsProduct1.add(bonusPointsProduct2); assertEquals(expectedBonus, bonus); }</code> </pre> <br>  Wie bei Integrationstests ist der verwendete Satz von Komponententests sehr klein und garantiert nicht die vollständige Richtigkeit der Anwendung.  Trotzdem erhöht seine Präsenz das Vertrauen in den Code erheblich, erleichtert das Debuggen und gibt die anderen im ersten Teil des Artikels aufgeführten Boni. <br><br><a name="ImplementationConsiderations"></a><h2>  Implementierungsempfehlungen </h2><br>  Ich hoffe, die vorherigen Abschnitte haben ausgereicht, um mindestens einen Entwickler davon zu überzeugen, Tests in seinem Projekt zu verwenden.  In diesem Kapitel werden kurz die wichtigsten Empfehlungen aufgeführt, die dazu beitragen, schwerwiegende Probleme zu vermeiden und die anfänglichen Implementierungskosten zu senken. <br><br>  <b>Versuchen Sie, die Tests für die neue Anwendung zu implementieren.</b>  Das Schreiben der ersten Tests in einem großen Legacy-Projekt ist viel schwieriger und erfordert mehr Geschick als in einem frisch erstellten.  Daher ist es nach Möglichkeit besser, mit einer kleinen neuen Anwendung zu beginnen.  Wenn keine neuen vollwertigen Anwendungen erwartet werden, können Sie versuchen, ein nützliches Dienstprogramm für den internen Gebrauch zu entwickeln.  Die Hauptsache ist, dass die Aufgabe mehr oder weniger realistisch sein sollte - erfundene Beispiele geben keine vollständige Erfahrung. <br><br>  <b>Richten Sie regelmäßige Testläufe ein.</b>  Wenn die Tests nicht regelmäßig ausgeführt werden, hören sie nicht nur auf, ihre Hauptfunktion auszuführen - die Richtigkeit des Codes zu überprüfen -, sondern sind auch schnell veraltet.  Daher ist es äußerst wichtig, mindestens die minimale CI-Pipeline mit automatischem Teststart jedes Mal zu konfigurieren, wenn der Code im Repository aktualisiert wird. <br><br>  <b>Jagen Sie nicht die Abdeckung.</b>  Wie bei jeder anderen Technologie werden die Tests zunächst nicht in bester Qualität durchgeführt.  Die einschlägige Literatur (Links am Ende des Artikels) oder ein kompetenter Mentor können hier helfen, aber dies macht die Notwendigkeit selbstfüllender Zapfen nicht zunichte.  Tests in dieser Hinsicht ähneln dem Rest des Codes: Um zu verstehen, wie sie sich auf das Projekt auswirken, können Sie dies erst tun, nachdem Sie eine Weile mit ihnen gelebt haben.  Um den Schaden zu minimieren, ist es daher beim ersten Mal besser, die Anzahl und die schönen Zahlen nicht wie eine hundertprozentige Abdeckung zu verfolgen.  Stattdessen sollten Sie sich auf die wichtigsten positiven Szenarien für Ihre eigene Anwendungsfunktionalität beschränken. <br><br>  <b>Lassen Sie sich nicht von Unit-Tests mitreißen.</b>  In Fortsetzung des Themas „Quantität gegen Qualität“ sollte beachtet werden, dass ehrliche Komponententests nicht zum ersten Mal durchgeführt werden sollten, da dies leicht zu einer übermäßigen Spezifikation der Anwendung führen kann.  Dies wird wiederum zu einem schwerwiegenden Hemmfaktor für spätere Refactoring- und Anwendungsverbesserungen.  Unit-Tests sollten nur verwendet werden, wenn in einer bestimmten Klasse oder Gruppe von Klassen eine komplexe Logik vorhanden ist, deren Überprüfung auf Integrationsebene unpraktisch ist. <br><br>  <b>Lassen Sie sich nicht von Stub-Klassen und Anwendungsmethoden mitreißen.</b>  Stubs (Stub, Mock) ist ein weiteres Werkzeug, das einen ausgewogenen Ansatz und die Aufrechterhaltung eines Gleichgewichts erfordert.  Einerseits können Sie sich durch die vollständige Isolierung des Geräts auf die getestete Logik konzentrieren und nicht an den Rest des Systems denken.  Andererseits erfordert dies zusätzliche Entwicklungszeit und kann wie bei Unit-Tests zu einer übermäßigen Spezifikation des Verhaltens führen. <br><br>  <b>Lösen Sie die Integrationstests von externen Systemen.</b>  Ein sehr häufiger Fehler bei Integrationstests ist die Verwendung einer realen Datenbank, von Nachrichtenwarteschlangen und anderen Systemen außerhalb der Anwendung.  Natürlich ist die Möglichkeit, einen Test in einer realen Umgebung auszuführen, für das Debuggen und die Entwicklung hilfreich.  Solche Tests in kleinen Mengen können sinnvoll sein, insbesondere um interaktiv zu laufen.  Ihre weit verbreitete Verwendung führt jedoch zu einer Reihe von Problemen: <br><br><ol><li>  Um die Tests auszuführen, müssen Sie die externe Umgebung konfigurieren.  Installieren Sie beispielsweise eine Datenbank auf jedem Computer, auf dem die Anwendung zusammengestellt wird.  Dies erschwert es neuen Entwicklern, in das Projekt einzutreten und CI zu konfigurieren. </li><li>  Der Status externer Systeme kann auf verschiedenen Computern variieren, bevor die Tests ausgeführt werden.  Beispielsweise kann die Datenbank bereits die Tabellen enthalten, die die Anwendung mit Daten benötigt, die im Test nicht erwartet werden.  Dies führt zu unvorhersehbaren Fehlern bei den Tests, und ihre Beseitigung erfordert einen erheblichen Zeitaufwand. </li><li>  Wenn an mehreren Projekten parallel gearbeitet wird, ist der nicht offensichtliche Einfluss einiger Projekte auf andere möglich.  Beispielsweise können bestimmte Datenbankeinstellungen, die für eines der Projekte vorgenommen wurden, dazu beitragen, dass die Funktionalität eines anderen Projekts ordnungsgemäß funktioniert. Diese Funktion wird jedoch unterbrochen, wenn sie auf einer sauberen Datenbank auf einem anderen Computer gestartet wird. </li><li>  Tests werden über einen langen Zeitraum durchgeführt: Ein vollständiger Lauf kann mehrere zehn Minuten dauern.  Dies führt dazu, dass Entwickler die lokale Ausführung von Tests beenden und ihre Ergebnisse erst nach dem Senden der Änderungen an das Remote-Repository anzeigen.  Dieses Verhalten negiert die meisten Vorteile der Tests, die im ersten Teil des Artikels erörtert wurden. </li></ol><br>  <b>Löschen Sie den Kontext zwischen Integrationstests.</b>  Um die Arbeit von Integrationstests zu beschleunigen, müssen Sie häufig denselben Kontext zwischen ihnen wiederverwenden.  Sogar die offizielle Frühlingsdokumentation gibt eine solche Empfehlung ab.  Gleichzeitig sollte der Einfluss von Tests aufeinander vermieden werden.  Da sie in beliebiger Reihenfolge gestartet werden, kann das Vorhandensein solcher Verbindungen zu zufälligen, nicht reproduzierbaren Fehlern führen.  Um dies zu verhindern, sollten die Tests keine Änderungen im Kontext hinterlassen.  Wenn Sie beispielsweise eine Datenbank verwenden, reicht es normalerweise zur Isolierung aus, alle im Test festgeschriebenen Transaktionen zurückzusetzen.  Wenn Änderungen am Kontext nicht vermieden werden können, können Sie die Neuerstellung mithilfe der Annotation <code>@DirtiesContext</code> konfigurieren. <br><br> <b>  ,      .</b>         ,       - .    ,            .  ,   , —      ,           . <br><br> <b>      .</b>      ,    ,       . ,    ,       . <br><br> <b>   TDD (Test-Driven Development).</b> TDD    ,      ,     .  ,        ,     .   ,         ,        . <br><br><h2>   ,  ? </h2><br>              ,  : <br><br><ol><li>       (  )?             . </li><li>           ,      ( ,  CI)?    . </li><li>     ?                     . </li><li>     ?    .   ,      ,      . </li></ol><br>        ,      .     , , -   .   —           . <br><br><a name="Conclusion"></a><h2>  Fazit </h2><br>       ,     .    -    ,    .  ,  -      .        —         ,      ,    -.      ,                 . <br><br> ,    ,        ,            ! <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   GitHub</a> <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Growing Object-Oriented Software, Guided by Tests</a> , Steve Freeman, Nat Pryce <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The Art of Unit Testing</a> , Roy Osherove <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Test-driven Development: By Example</a> , Kent Beck <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Refactoring: Improving the Design of Existing Code</a> , Martin Fowler <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427603/">https://habr.com/ru/post/de427603/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427589/index.html">Wir schreiben einen Online-Chat auf Websockets mit Swoole</a></li>
<li><a href="../de427591/index.html">Architektur als Belastung</a></li>
<li><a href="../de427593/index.html">Schnellbefehlsmagie in Vivaldi 2.1</a></li>
<li><a href="../de427595/index.html">Versuchen Sie Micronaut oder Darling, ich habe das Framework reduziert</a></li>
<li><a href="../de427601/index.html">5 + 1 Fall, in dem die REST-API-Spezifikation eine große Rolle spielt</a></li>
<li><a href="../de427605/index.html">Wie die Crowdsourcing-Plattform von Yandex Drohnen trainiert und die Servicequalität bewertet</a></li>
<li><a href="../de427607/index.html">Rechenzentrum in der Schweiz: wie am Schnürchen arbeiten</a></li>
<li><a href="../de427609/index.html">Lösen der Gleichung mit ganzzahliger Division ohne rohe Gewalt</a></li>
<li><a href="../de427611/index.html">Die Geschichte, wie ich Yandex MapKit auf iOS oder Karten aktualisiert habe, Geld, 2 Mappits</a></li>
<li><a href="../de427613/index.html">10 nützliche Blogs für Programmierer in Englisch</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>