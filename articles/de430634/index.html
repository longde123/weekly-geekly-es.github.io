<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👆🏽 🐈 🚴🏽 Erstellen eines Softwaremoduls für den Programmierer XELTEK SuperPro 6100 😟 👨🏽‍🍳 🏠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vorwort 
 In einem früheren Artikel wurde der Schutzmechanismus des XELTEK SuperPro 6100-Programmiergeräts gegen Klonen in Betracht gezogen. 

 In die...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen eines Softwaremoduls für den Programmierer XELTEK SuperPro 6100</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430634/"><h4>  Vorwort </h4><br>  In einem früheren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> wurde der Schutzmechanismus des XELTEK SuperPro 6100-Programmiergeräts gegen Klonen in Betracht gezogen. <br><br>  In diesem Artikel wird die Erstellung eines eigenen Softwaremoduls für diesen Programmierer beschrieben, das durch eine bestimmte Änderung des Codes an alle anderen Arten von Mikroschaltungen angepasst werden kann - derzeit nicht unterstützt oder, wie in unserem Fall, nur formal angegeben. <br><br><h4>  Hintergrund </h4><br>  Wir hatten wieder einmal eine Aufgabe, die auf den ersten Blick ganz einfach gelöst wurde - es war notwendig, eine Kopie eines speziellen Flash-Speicherchips zu erstellen - mDOC H3 SDED5-512M. <br><br>  Dieser Chip wurde vor mehr als zehn Jahren entwickelt.  Hier ist das PDF <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(1)</a> mit seiner Beschreibung.  Unten finden Sie einen kurzen Auszug aus der russischsprachigen Ankündigung: <br><br>  <i>... msystems hat die mDOC-Familie für den Einsatz als Solid-State-Laufwerke vorbereitet ...</i> <i><br></i>  <i>Die integrierte TrueFFS-Software, die mit der Verwaltung des mDOC H3-Flash-Speichers beauftragt ist, verfügt über ein eigenes Controller-Modul, das es zu einer vollständigen, eigenständigen Einheit macht, die problemlos zu einer Vielzahl von Handheld-Geräten hinzugefügt werden kann. ...</i> <br><a name="habracut"></a><br>  In der vom Programmierer unterstützten Liste der SuperPro 6100 wurde ein solcher Chip aufgeführt und dafür sogar der entsprechende DX5057-Adapter gefunden.  Nachdem der gesamte Designer zusammengebaut und dieser Chip ausgewählt worden war, zeigte das Programm das folgende Bild mit dem mysteriösen Element „DimageMain“, dessen Beschreibung weder in der Dokumentation noch auf der Website des Entwicklers gefunden wurde. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0l/dy/hk/0ldyhknaorevv2x5mjq4cens0qw.jpeg"></div><br>  Nachdem versucht wurde, die "DimageMain" -Operation ohne Chip im Adapter auszuführen, wurde eine Warnung über das Fehlen des Chips empfangen, und nach Bestätigung dieser Tatsache zeigte das Programm die folgenden Informationen an: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kh/x4/hk/khx4hkhkb3uu2w5zbpguawdzhh4.jpeg"></div><br>  Gemessen an der Aufschrift „mDOC H3 Write Image“ ist „Image“ ein Bild, das mit diesem Programmierer auf einen Chip geschrieben werden kann.  Aber wie liest man dieses Bild aus einer bereits aufgenommenen Mikroschaltung, wie löscht man es usw.? <br><br>  Wenig später fand ich im Internet eine Datei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(2)</a> der Firma Dataman, die teilweise die Struktur des obigen Bildes zeigt und Software für deren Erstellung erwähnt. <br>  Daher waren weitere Anstrengungen darauf gerichtet, nach Dienstprogrammen von M-Systems zu suchen, die im Dokument Software Utilities for TrueFFS 7.1 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(3) beschrieben sind</a> . <br><br>  Die Anfrage nach technischem Support für die ehemaligen „M-Systems“, jetzt „SanDisk“, ergab kein Ergebnis - es gab einfach keine Antwort. <br><br>  Im Internet konnten nur alte Dienstprogramme gefunden werden, die die Version von H3-Chips nicht unterstützen.  Das vollständige SDK von SanDisk wurde ebenfalls nicht gefunden, nur seine „Fragmente“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(5)</a> im Hinblick auf die Implementierung eines Treibers für Linux. <br><br>  Während wir die gesammelten Informationen untersuchten, erregte die folgende Zeile die Aufmerksamkeit der Dataman-Datei: „Bilddateien können mit dem SanDisk Docshell-Dienstprogramm oder PG4UW erstellt werden.“ <br><br>  Die SanDisk Docshell-Dienstprogramme fanden sich in keiner Weise wieder, daher musste ich herausfinden, wie PG4UW <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(4)</a> mit diesem Chip funktioniert.  Sie haben nicht das gesamte SanDisk SDK in ihre Software eingebettet, sondern ein Plug-In mit exportierten Methoden erstellt, die für das Funktionieren der TrueFFS-Dienstprogramme erforderlich sind und dann von ihrem Programm aufgerufen werden. <br>  Wir werden den gleichen Weg gehen. <br><br><h4>  Erstellen Sie Ihr eigenes Softwaremodul </h4><br>  Hier ist ein Haftungsausschluss, nämlich dass der Autor keine Verantwortung für die Verwendung der Materialien in diesem Artikel durch Sie trägt. <br>  Mit anderen Worten - nur Sie selbst sind für Ihre Handlungen verantwortlich, die durch die Einarbeitung in dieses Material ausgelöst werden können. <br><br>  <em>Wir sind uns einig, wie im vorherigen Artikel, den Programmierer-Programmierer von SuperPro 6100 einfach "Software" zu nennen, und der Computer, auf dem dieses Programm arbeitet, ist "Host".</em>  <em>Jetzt haben wir ein anderes Programm, das im Programmierer selbst funktioniert.</em>  <em>Wir werden es das "Softwaremodul" nennen.</em> <br><br>  Das Handbuch Software Utilities for TrueFFS 7.1 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(3)</a> beschreibt die von den DOCSHELL-Dienstprogrammen implementierten Funktionen, die in die folgenden vier Kategorien fallen: <br><br><ul><li>  DFORMAT - Dienstprogramme zum Formatieren eines mDOC-Geräts. </li><li>  DINFO - Dienstprogramme zum Abrufen einer Vielzahl von Informationen über das mDOC-Gerät und die darauf vorhandenen Abschnitte. </li><li>  DIMAGE - Dienstprogramme zum Lesen, Schreiben und Vergleichen des Bild-mDOC-Geräts. </li><li>  SPLITIMAGE - Dienstprogramme zum Teilen des mDOC-Gerätebilds in Teile. </li></ul><br>  DOCSHELL-Dienstprogramme waren für die Befehlszeile vorgesehen, daher wurde die Schnittstelle für die Kommunikation mit dem Plugin DOCSHELL.dll unter Verwendung des gleichen Textbefehlsmechanismus implementiert. <br>  Bevor Sie mit der Kommunikation mit „DOCSHELL.dll“ beginnen, müssen Sie jede der exportierten Methoden aufrufen und ihnen Zeiger auf die in der Software implementierten Funktionen für den physischen Austausch mit dem mDOC-Chip übergeben.  Dies sind Schreiben und Lesen (in verschiedenen Modifikationen) sowie Methoden zum Empfangen von Textnachrichten über den Fortschritt der aktuellen Vorgänge und Methoden zum Arbeiten mit Bilddateien. <br><br>  Eine der exportierten mainEntry-Methoden als Eingabeargument <br>  akzeptiert eine ASCIIZ-Zeichenfolge - den Befehl, der im Handbuch Software Utilities for TrueFFS 7.1 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(3) beschrieben ist</a> . <br><br>  Der Parser in "DOCSHELL.dll" verarbeitet den empfangenen Befehl und ruft abhängig vom Befehl und seinen Argumenten die eine oder andere Methode von der Hauptprogrammiersoftware unter Verwendung des Zeigers auf, der während der anfänglichen Initialisierung empfangen wurde. <br><br>  Software für den Programmierer haben wir uns entschlossen, Ihre eigene zu schreiben.  Dieser Ansatz ersparte uns einerseits das „Graben“ in den Originaldateien, um die Vereinbarungen über den Informationsaustausch zwischen dem Host und dem Programmierer einzuhalten, und erleichterte andererseits den Debugging-Prozess erheblich, der es in einigen Aspekten unmöglich machte, wenn das Modul in die ursprüngliche Software integriert wurde oder extrem schwierig. <br><br>  Die native Benutzeroberfläche für den Programmierer wurde in C # in Visual Studio 2017 geschrieben. Quellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(6)</a> sind enthalten. <br><br>  Natürlich war die Funktionalität an erster Stelle, so dass von einem Einrasten des Erscheinungsbilds sowie des Textes des Quellcodes selbst keine Rede war.  Daher ist das minimalistische „Design“ des Programms wie folgt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oz/ki/8b/ozki8byinhgupo_k6hvfnzab-oc.jpeg"></div><br>  Oben im Hauptfenster (und nur im Fenster) befindet sich ein Menü, für dessen Schaltflächen Sie beliebige Funktionen zuweisen können.  Der Menüpunkt „XILINX“ wird später beschrieben. <br><br>  Unten sind zwei Fenster.  Der obere Teil zeigt Nachrichten an, die vom Programm an das Plugin "DOCSHELL.dll" gesendet und von diesem empfangen wurden. <br><br>  Im unteren Fenster können Sie die gewünschten Befehle eingeben und in der entsprechenden Zeile doppelklicken. <br><br>  Wenn das Programm gestartet wird, werden einige Befehle darin angezeigt. <br><br>  <em>Wenn Sie plötzlich mit einem echten Chip arbeiten, seien Sie vorsichtig, denn</em>  <em>Keine Warnungen, dass Sie beim Formatieren usw. alle Daten verlieren könnten.</em>  <em>Das Programm ist nicht implementiert.</em> <br><br>  Die Datei "DOCSHELL.dll" befindet sich im Verzeichnis mit dem installierten Programm PG4UW <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(4)</a> von "Dataman" (möglich von "Elnec"). <br><br>  Um eine DLL eines Drittanbieters in Ihrem Programm verwenden zu können, benötigen Sie eine Header-Datei mit einer Beschreibung der exportierten Methoden und ihrer Argumente.  Aufgrund seiner Abwesenheit musste ich diese Informationen selbst wiederherstellen.  Die Methoden für eine solche Wiederherstellung gehen über den Rahmen dieses Artikels hinaus, sodass die Argumente der exportierten Methoden in den angehängten Quellen zu finden sind. <br><br>  Mit der Benutzeroberfläche in Bezug auf die Interaktion mit dem Plugin ist die Sache etwas klarer geworden.  Jetzt können Sie mit der Implementierung der Kommunikation mit der Mikroschaltung auf physikalischer Ebene fortfahren, um die vom Plugin empfangenen Lese- / Schreibbefehle von / zu mDOC ausführen zu können. <br><br>  Das Programmmodul für den Programmierer wurde in der IDE "IAR Embedded Workbench for ARM" in C geschrieben.  Quellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(7)</a> sind beigefügt. <br><br>  Das Debuggen wurde mit dem JTAG J-Link-Debugger durchgeführt, der über einen an der Seite des Gehäuses angebrachten JTAG-Anschluss mit dem Programmierer verbunden und über ein Flachkabel mit dem Motherboard verbunden war. <br><br>  <em>Der JTAG-Debugger J-Link v9 wurde auf Aliexpress gekauft.</em>  <em>Die mit der „IAR Embedded Workbench for ARM“ installierten Treiber funktionieren hervorragend damit, und sogar das Aktualisieren der nativen Firmware von SEGGER war erfolgreich.</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/md/5e/vq/md5evqm8gj7khtrvdsucwhd5yac.jpeg"></div><br>  Strukturell besteht der Programmierer aus acht übereinander angeordneten und durch Verbinder miteinander verbundenen Karten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3v/1n/b6/3v1nb6ntkgimwtwtir0lcekdgmm.jpeg"></div><br>  Einstellbare DC-DC-Wandler befinden sich auf der untersten Platine, um mehrere Spannungen zu erzeugen, die für die Arbeit mit verschiedenen Speichermikroschaltungen erforderlich sind. <br>  Darüber befindet sich ein Motherboard, auf dem der ATMEL AT91SAM9G20 ARM-Mikrocontroller, SDRAM, SPI FLASH mit Firmware, ID-Chip AE801 mit Programmierermodell und Seriennummer, USB-Chip ISP1582, Digital-Analog-Wandler TLC7226 für das Spannungsmanagement von DC-DC-Wandlern, eine Reihe anderer Chips und externer Anschlüsse zum Anschließen eines Netzteils und ein USB-Kabel zum Anschließen an den Host. <br><br>  Auf der dritten unteren Platine befindet sich der XILINX XC2S50E-Chip, der die Beine des Chips auf dem Adapter steuert, der während des Lese- / Schreibvorgangs usw. mit dem Programmierer verbunden ist. <br>  Auf den anderen fünf Karten befinden sich nacheinander geladene Register und Baugruppen mit Transistorschaltern, die an ihre Ausgänge angeschlossen sind, über die es möglich ist, Mikroschaltungen an diesen durch Gleichspannungswandler gebildeten Zweigen des Adapters anzulegen. <br>  einschließlich der "Erde".  Da die Register, die die Transistorschlüssel steuern, nacheinander geladen werden und die Anzahl der gesteuerten Zweige im Adapter 144 erreichen kann, dauert das Laden aller Schlüsselblöcke eine beträchtliche Zeit.  Daher werden mit Hilfe von Transistorschaltern nur statische Pegel in die Mikroschaltung eingespeist: Masse, Leistung usw.  Und mit XILINX - dynamisch: Adressen, Daten, CS, OE, RD, WR usw. <br><br>  Um weiter voranzukommen, war mindestens ein Mittel zum Erstellen einer Firmware für den XILINX XC2S50E-Mikroschaltkreis und ein Schaltplan erforderlich, wenn nicht der gesamte Programmierer, dann zumindest ein Teil davon CPU-FPGA-Adapter-Sockel. <br><br>  Für die IDE für XILINX Spartan-IIE musste ich die alte Version von ISE 10.1 verwenden, weil  Alle nachfolgenden IDEs unterstützen das Spartan-II-FPGA-Modell nicht. <br><br>  Die Situation mit dem Schaltplan erwies sich als komplizierter.  Um die für uns interessanten Verbindungen zu identifizieren, mussten wir den U4- und XILINX U12-Prozessor von den Karten entfernen, um Zugang zu den Pads unter ihren BGA-Gehäusen zu erhalten, weil  Nicht alle haben einen Schalter auf der Rückseite. <br><table><tbody><tr><td><div style="text-align:center;"><img src="https://habrastorage.org/webt/em/i6/xz/emi6xzfj5g9ks4imtdzvrc9mqa0.jpeg"></div></td><td><div style="text-align:center;"><img src="https://habrastorage.org/webt/fl/rg/st/flrgstgrxvaicirr108z0ahlphs.jpeg"></div></td></tr></tbody></table>  Der Host kommuniziert mit dem Programmierer über USB über mehrere Endpunkte (Endpunkte).  Der Host fungiert immer als Host.  Über einen der Endpunkte sendet der Host einen Befehl an den Programmierer und erhält über diesen eine Bestätigung. <br>  durch einen anderen tauschen sie Daten miteinander aus. <br><br>  Das Parsen von Befehlen vom Host im Programmmodul wird in der Methode USB_ReceiveBuf_EP1RX_Parse () ausgeführt. <br><br>  Das Befehlspaket wird durch die CMD_PROG-Struktur beschrieben und besteht aus mehreren Feldern.  Wenn das Cmd-Feld 1 enthält, ist dies ein Befehl zum Arbeiten mit der Mikroschaltung, und das ProgProcNum-Feld ist in diesem Fall der Index im Array _progProcedures von PROG_PROC-Strukturen, in einem dieser Felder ist ein Zeiger auf den auszuführenden Befehl gespeichert. <br><br>  Im Verzeichnis mit dem installierten Programm "SUPERPRO 6100N" befindet sich ein Unterverzeichnis "\ lib".  Es mit der Erweiterung "* .bin" speichert XILINX-Firmware-Dateien für alle vom Programmierer unterstützten Arten von Chips.  Darunter befinden sich zwei universelle Firmware zur Überprüfung des Kontakts der Beine der Mikroschaltung mit den Kontakten der Buchsen im Adapter. <br><br>  Dies ist "GENERAL ~ .BIN" mit einem internen Pull-up für alle XILINX-Pull-up-Beine und "GENERAL_.BIN" mit einem internen Pull-down-Pull. <br><br>  Die Überprüfung des Kontakts der Mikroschaltungsbeine erfolgt in der SOCKET_CkeckInsertIC () -Methode des Softwaremoduls wie folgt. <br><br>  Zunächst wird die Firmware „GENERAL_.BIN“ in XILINX geladen und mit ihrer Hilfe werden alle an den Sockel angeschlossenen FPGA-Zweige für die Ausgabe konfiguriert und mit logischer „1“ versorgt.  Dann wird wiederum jeder FPGA-Zweig für die Eingabe neu konfiguriert, eine logische Ebene wird daraus gelesen und dann wird wieder "1" an diesen Zweig ausgegeben. <br><br>  Wenn das Mikroschaltungsbein elektrischen Kontakt mit dem entsprechenden Sockelbein hat, sollte „1“ daraus abgelesen werden (durch die internen Schutzdioden des Mikroschaltkreises von allen anderen Beinen).  Und wenn kein Kontakt besteht, wird aufgrund der Tatsache, dass alle FPGA-Pins in den Boden gezogen sind, „0“ von diesem Eingang gelesen.  Danach wird ein Array von auf diese Weise gelesenen logischen Ebenen an den Host gesendet und dort verarbeitet.  Als nächstes wird die Ausführung der angegebenen Operation fortgesetzt, oder es wird eine Meldung über die Nicht-VKontakte der entsprechenden Schenkel der Mikroschaltung in der Buchse angezeigt. <br>  Nach erfolgreichem Bestehen dieses Tests sendet der Host die Firmware für XILINX, die dem im Adapter installierten Chip entspricht, an den Programmierer. <br><br>  Durch das Kompilieren eines Programms für FPGA in ISE 10.1 (sequentielle Ausführung von Syntheseprozeduren (Synthesize), Implementierung eines Designs (Implement Design) und Generierung von Programmierdateien (Generate Programming File)) wird eine binäre Konfigurationsdatei „xeltek.bin“ mit 78756 Bytes im Projektverzeichnis erstellt.  <em>Dazu müssen in den Eigenschaften des Prozesses "Programmierdatei generieren" im Fenster "Prozesse" in der Kategorie "Allgemeine Optionen" zwei Optionen festgelegt werden: "Bitdatei erstellen" und "Bibary-Konfigurationsdatei erstellen".</em> <br><br>  Es ist nicht bekannt, aus welchen Gründen, aber XELTEK-Programmierer haben beschlossen, die so erhaltenen Dateien zu ändern, indem sie alle Bits in jedem Byte spiegeln. <br><br>  Wenn Sie aus irgendeinem Grund Ihre eigene Datei auf diese Weise "spiegeln" oder die Datei aus dem Verzeichnis "\ lib" zurück in die normale Ansicht "spiegeln" müssen, befindet sich in der Software im Menü "XILINX" zu diesem Zweck der Punkt "Bitstream Converter" (am Ende des Namens) Die resultierende Datei ist unterstrichen. <br><br>  Um mit dem SDED5-Chip auf physischer Ebene zu arbeiten, sind im Softwaremodul die folgenden vier Methoden implementiert: <br><br>  - PROGPROC_FLWRITE_IO_WORD () - Zeichnet ein Wort (16 Bit) an der angegebenen Adresse auf <br>  - PROGPROC_FLREAD_IO_WORD () - Lesen Sie das Wort (16 Bit) an der angegebenen Adresse <br>  - PROGPROC_hal_blk_write_nor () - Schreiben Sie einen oder mehrere Sektoren (jeweils 512 Byte) an die angegebene Adresse <br>  - PROGPROC_hal_blk_read_nor () - Liest einen oder mehrere Sektoren (jeweils 512 Byte) an der angegebenen Adresse <br><br>  Für die Interaktion mit dem FPGA XILINX in unserer Firmware haben wir vier Register identifiziert (E / A-Ports, beschrieben in der Datei common.h für ARM-Quellen). <br><br>  - _IC_ADDR (0x30000010) <br>  - _IC_DATA (0x30000012) <br>  - _IC_CTRL (0x30000014) // Out: 0 - WE, 1 - 0E, 2 - CE, 3 - RSTIN;  In: 0 - BESETZT <br>  - _IC_ENABLE (0x30000016) // In: 7 - Arbeitserlaubnis (0 - aktiv, 1 - alle Beine an der Steckdose in Z) <br><br>  _IC_ADDR und _IC_DATA sind 16-Bit-Adress- und Datenregister für den programmierbaren SDED5-Chip. <br>  _IC_CTRL - 8-Bit-Steuerregister, über das die WE-, OE-, CE- und RSTIN-Signale gesetzt und das BUSY-Signal von SDED5 gelesen werden. <br><br>  Die ursprünglichen Softwaremodule verwenden Adressen von 0x30000000 bis 0x3000000E, um mit FPGAs zu kommunizieren.  CPLD mit der XELTEK-Beschriftung ist als Adressdecoder im Programmierer installiert. Da wir die Firmware nicht kennen, haben wir Adressen von 0x30000010 verwendet, um die Wahrscheinlichkeit unerwarteter Konsequenzen zu verringern, die sich aus der Darstellung der Verhaltenslogik eines anderen bei Verwendung von „Standard“ -Adressen ergeben. <br><br>  Nach dem Laden der Firmware in das FPGA befinden sich alle FPGA-Ausgänge, die an die Schenkel der Mikroschaltung im Sockel angeschlossen sind, im Z-Zustand. Um damit arbeiten zu können, müssen Sie die Auflösung aktivieren, indem Sie Null in das siebte Bit des Registers _IC_ENABLE schreiben. <br><br>  Der Algorithmus des gesamten Systems kann wie folgt aussehen. <br><br><ol><li>  Nach dem Starten der Software auf dem Host wird geprüft, ob eine Verbindung zum Programmierer über USB besteht, und die entsprechende Meldung wird in der Statusleiste unten im Hauptfenster angezeigt <br>  (Der Programmierer kann nach dem Start des Programms angeschlossen werden). </li><li>  Der Benutzer wählt den Chip-Typ aus, mit dem er arbeiten möchte. </li><li>  In der Datenbank (im einfachsten Fall nur in der Datei) entspricht der ausgewählte Mikroschaltkreis dem erforderlichen Adaptertyp, und an den Programmierer wird eine Anfrage nach dem darin installierten Adaptertyp gesendet. </li><li>  Der Programmierer fragt den Adapter nach seinem Typ und sendet diese Informationen an den Host zurück, wo diese Informationen mit denen in der Datenbank verglichen werden. Wenn die Adaptertypen übereinstimmen, wird die Arbeit fortgesetzt. </li><li>  Für jeden in der Software ausgewählten Mikrokreistyp sollte ein entsprechendes Menü mit den für diesen Mikrokreis verfügbaren Befehlen angezeigt werden (Lesen, Schreiben, Überprüfen auf Sauberkeit, Vergleich usw.). </li><li>  Wenn Sie einen Menüpunkt für die Arbeit mit der Mikroschaltung auswählen, wird der entsprechende Befehl an den Programmierer gesendet. Danach überprüft der Programmierer zuerst den elektrischen Kontakt der Kontakte der Buchsen mit den Beinen der Mikroschaltung und führt diesen Befehl dann erfolgreich aus, wenn er erfolgreich ist. </li></ol><br>  <em>In den dem Artikel beigefügten Quellcodes werden zur Vereinfachung der Aufgabe keine Punkte vom zweiten bis zum fünften einschließlich implementiert.</em> <br><br><h4>  Zusammenfassung </h4><br>  Wir standen nicht vor der Aufgabe, das Softwaremodul in die ursprüngliche Software zu integrieren. <br>  Daher erhebt das in diesem Artikel beschriebene Material keinen Anspruch auf vollständige Lösung. <br>  Wir hoffen, dass die hier präsentierten Informationen für eine bestimmte Kategorie von Lesern nützlich sind. Nach bestem Wissen und Gewissen und Verfügbarkeit der Freizeit werden wir versuchen, Ihre Fragen zu beantworten. <br><br>  Vielen Dank für Ihr Interesse! <br><br><h4>  Ressourcen </h4><br>  1. <a name="ref1"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PDF - mDOC H3 Embedded Flash Drive (EFD) mit eingebetteter TrueFFS Flash Management Software</a> <br>  2. <a name="ref2"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PDF - Programmieren von mDOC H3-Flash-Speichern mit Dataman-Geräteprogrammierern</a> <br>  3. <a name="ref3"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PDF - Software_Utilities_TrueFFS_7.1</a> <br>  4. <a name="PG4UW"></a>  <a href="">Dataman Control Software - PG4UW</a> <br>  5. <a name="linux"></a>  <a href="">Implementierung des mDOC H3-Treibers für Linux (Leistung wurde nicht getestet)</a> <br>  6. <a name="refSrcHost"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Host-Programmierer-Quelldateien (Visual Studio 2017).</a> <br>  7. <a name="refSrcModule"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelldateien des Softwaremoduls (IAR Embedded Workbench für ARM v8.30.1).</a> <br>  8. <a name="refSrcFPGA"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelldateien für FPGA XILINX XC2S50E (XILINX ISE 10.1).</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430634/">https://habr.com/ru/post/de430634/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430622/index.html">Funktionales Denken. Teil 5</a></li>
<li><a href="../de430626/index.html">Ankündigung des Moscow GraphQL Meetup</a></li>
<li><a href="../de430628/index.html">Fortune-Algorithmus, Implementierungsdetails</a></li>
<li><a href="../de430630/index.html">Vergleich der Two Balls Sneakers aus den 60ern und 2016. Von der Sohle bis zu den Schnürsenkeln</a></li>
<li><a href="../de430632/index.html">Service in der Wirtschaft: Wie ausländische Einzelhändler schlüsselfertige Geschäfte in Russland eröffnen</a></li>
<li><a href="../de430636/index.html">Kleinhirn und Basalkerne anstelle der Kristallkugel: Wie das Gehirn die Zukunft vorhersagt</a></li>
<li><a href="../de430640/index.html">Rotes Meer: Warum die Aktien von Apple und anderen Technologieunternehmen fallen</a></li>
<li><a href="../de430642/index.html">Regie "Photonik" bei den Olympischen Spielen "Ich bin ein Profi" oder wie man sich ohne Prüfungen in eine Magistratur einschreibt</a></li>
<li><a href="../de430646/index.html">.Net Binäre Serialisierung ohne Bezugnahme auf die Assembly mit dem Quelltyp oder wie mit BinaryFormatter verhandelt wird</a></li>
<li><a href="../de430648/index.html">Geschichte von Pac-Man</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>