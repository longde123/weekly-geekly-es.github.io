<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÜüèΩ üêà üö¥üèΩ Erstellen eines Softwaremoduls f√ºr den Programmierer XELTEK SuperPro 6100 üòü üë®üèΩ‚Äçüç≥ üè†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vorwort 
 In einem fr√ºheren Artikel wurde der Schutzmechanismus des XELTEK SuperPro 6100-Programmierger√§ts gegen Klonen in Betracht gezogen. 

 In die...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen eines Softwaremoduls f√ºr den Programmierer XELTEK SuperPro 6100</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430634/"><h4>  Vorwort </h4><br>  In einem fr√ºheren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> wurde der Schutzmechanismus des XELTEK SuperPro 6100-Programmierger√§ts gegen Klonen in Betracht gezogen. <br><br>  In diesem Artikel wird die Erstellung eines eigenen Softwaremoduls f√ºr diesen Programmierer beschrieben, das durch eine bestimmte √Ñnderung des Codes an alle anderen Arten von Mikroschaltungen angepasst werden kann - derzeit nicht unterst√ºtzt oder, wie in unserem Fall, nur formal angegeben. <br><br><h4>  Hintergrund </h4><br>  Wir hatten wieder einmal eine Aufgabe, die auf den ersten Blick ganz einfach gel√∂st wurde - es war notwendig, eine Kopie eines speziellen Flash-Speicherchips zu erstellen - mDOC H3 SDED5-512M. <br><br>  Dieser Chip wurde vor mehr als zehn Jahren entwickelt.  Hier ist das PDF <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(1)</a> mit seiner Beschreibung.  Unten finden Sie einen kurzen Auszug aus der russischsprachigen Ank√ºndigung: <br><br>  <i>... msystems hat die mDOC-Familie f√ºr den Einsatz als Solid-State-Laufwerke vorbereitet ...</i> <i><br></i>  <i>Die integrierte TrueFFS-Software, die mit der Verwaltung des mDOC H3-Flash-Speichers beauftragt ist, verf√ºgt √ºber ein eigenes Controller-Modul, das es zu einer vollst√§ndigen, eigenst√§ndigen Einheit macht, die problemlos zu einer Vielzahl von Handheld-Ger√§ten hinzugef√ºgt werden kann. ...</i> <br><a name="habracut"></a><br>  In der vom Programmierer unterst√ºtzten Liste der SuperPro 6100 wurde ein solcher Chip aufgef√ºhrt und daf√ºr sogar der entsprechende DX5057-Adapter gefunden.  Nachdem der gesamte Designer zusammengebaut und dieser Chip ausgew√§hlt worden war, zeigte das Programm das folgende Bild mit dem mysteri√∂sen Element ‚ÄûDimageMain‚Äú, dessen Beschreibung weder in der Dokumentation noch auf der Website des Entwicklers gefunden wurde. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0l/dy/hk/0ldyhknaorevv2x5mjq4cens0qw.jpeg"></div><br>  Nachdem versucht wurde, die "DimageMain" -Operation ohne Chip im Adapter auszuf√ºhren, wurde eine Warnung √ºber das Fehlen des Chips empfangen, und nach Best√§tigung dieser Tatsache zeigte das Programm die folgenden Informationen an: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kh/x4/hk/khx4hkhkb3uu2w5zbpguawdzhh4.jpeg"></div><br>  Gemessen an der Aufschrift ‚ÄûmDOC H3 Write Image‚Äú ist ‚ÄûImage‚Äú ein Bild, das mit diesem Programmierer auf einen Chip geschrieben werden kann.  Aber wie liest man dieses Bild aus einer bereits aufgenommenen Mikroschaltung, wie l√∂scht man es usw.? <br><br>  Wenig sp√§ter fand ich im Internet eine Datei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(2)</a> der Firma Dataman, die teilweise die Struktur des obigen Bildes zeigt und Software f√ºr deren Erstellung erw√§hnt. <br>  Daher waren weitere Anstrengungen darauf gerichtet, nach Dienstprogrammen von M-Systems zu suchen, die im Dokument Software Utilities for TrueFFS 7.1 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(3) beschrieben sind</a> . <br><br>  Die Anfrage nach technischem Support f√ºr die ehemaligen ‚ÄûM-Systems‚Äú, jetzt ‚ÄûSanDisk‚Äú, ergab kein Ergebnis - es gab einfach keine Antwort. <br><br>  Im Internet konnten nur alte Dienstprogramme gefunden werden, die die Version von H3-Chips nicht unterst√ºtzen.  Das vollst√§ndige SDK von SanDisk wurde ebenfalls nicht gefunden, nur seine ‚ÄûFragmente‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(5)</a> im Hinblick auf die Implementierung eines Treibers f√ºr Linux. <br><br>  W√§hrend wir die gesammelten Informationen untersuchten, erregte die folgende Zeile die Aufmerksamkeit der Dataman-Datei: ‚ÄûBilddateien k√∂nnen mit dem SanDisk Docshell-Dienstprogramm oder PG4UW erstellt werden.‚Äú <br><br>  Die SanDisk Docshell-Dienstprogramme fanden sich in keiner Weise wieder, daher musste ich herausfinden, wie PG4UW <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(4)</a> mit diesem Chip funktioniert.  Sie haben nicht das gesamte SanDisk SDK in ihre Software eingebettet, sondern ein Plug-In mit exportierten Methoden erstellt, die f√ºr das Funktionieren der TrueFFS-Dienstprogramme erforderlich sind und dann von ihrem Programm aufgerufen werden. <br>  Wir werden den gleichen Weg gehen. <br><br><h4>  Erstellen Sie Ihr eigenes Softwaremodul </h4><br>  Hier ist ein Haftungsausschluss, n√§mlich dass der Autor keine Verantwortung f√ºr die Verwendung der Materialien in diesem Artikel durch Sie tr√§gt. <br>  Mit anderen Worten - nur Sie selbst sind f√ºr Ihre Handlungen verantwortlich, die durch die Einarbeitung in dieses Material ausgel√∂st werden k√∂nnen. <br><br>  <em>Wir sind uns einig, wie im vorherigen Artikel, den Programmierer-Programmierer von SuperPro 6100 einfach "Software" zu nennen, und der Computer, auf dem dieses Programm arbeitet, ist "Host".</em>  <em>Jetzt haben wir ein anderes Programm, das im Programmierer selbst funktioniert.</em>  <em>Wir werden es das "Softwaremodul" nennen.</em> <br><br>  Das Handbuch Software Utilities for TrueFFS 7.1 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(3)</a> beschreibt die von den DOCSHELL-Dienstprogrammen implementierten Funktionen, die in die folgenden vier Kategorien fallen: <br><br><ul><li>  DFORMAT - Dienstprogramme zum Formatieren eines mDOC-Ger√§ts. </li><li>  DINFO - Dienstprogramme zum Abrufen einer Vielzahl von Informationen √ºber das mDOC-Ger√§t und die darauf vorhandenen Abschnitte. </li><li>  DIMAGE - Dienstprogramme zum Lesen, Schreiben und Vergleichen des Bild-mDOC-Ger√§ts. </li><li>  SPLITIMAGE - Dienstprogramme zum Teilen des mDOC-Ger√§tebilds in Teile. </li></ul><br>  DOCSHELL-Dienstprogramme waren f√ºr die Befehlszeile vorgesehen, daher wurde die Schnittstelle f√ºr die Kommunikation mit dem Plugin DOCSHELL.dll unter Verwendung des gleichen Textbefehlsmechanismus implementiert. <br>  Bevor Sie mit der Kommunikation mit ‚ÄûDOCSHELL.dll‚Äú beginnen, m√ºssen Sie jede der exportierten Methoden aufrufen und ihnen Zeiger auf die in der Software implementierten Funktionen f√ºr den physischen Austausch mit dem mDOC-Chip √ºbergeben.  Dies sind Schreiben und Lesen (in verschiedenen Modifikationen) sowie Methoden zum Empfangen von Textnachrichten √ºber den Fortschritt der aktuellen Vorg√§nge und Methoden zum Arbeiten mit Bilddateien. <br><br>  Eine der exportierten mainEntry-Methoden als Eingabeargument <br>  akzeptiert eine ASCIIZ-Zeichenfolge - den Befehl, der im Handbuch Software Utilities for TrueFFS 7.1 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(3) beschrieben ist</a> . <br><br>  Der Parser in "DOCSHELL.dll" verarbeitet den empfangenen Befehl und ruft abh√§ngig vom Befehl und seinen Argumenten die eine oder andere Methode von der Hauptprogrammiersoftware unter Verwendung des Zeigers auf, der w√§hrend der anf√§nglichen Initialisierung empfangen wurde. <br><br>  Software f√ºr den Programmierer haben wir uns entschlossen, Ihre eigene zu schreiben.  Dieser Ansatz ersparte uns einerseits das ‚ÄûGraben‚Äú in den Originaldateien, um die Vereinbarungen √ºber den Informationsaustausch zwischen dem Host und dem Programmierer einzuhalten, und erleichterte andererseits den Debugging-Prozess erheblich, der es in einigen Aspekten unm√∂glich machte, wenn das Modul in die urspr√ºngliche Software integriert wurde oder extrem schwierig. <br><br>  Die native Benutzeroberfl√§che f√ºr den Programmierer wurde in C # in Visual Studio 2017 geschrieben. Quellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(6)</a> sind enthalten. <br><br>  Nat√ºrlich war die Funktionalit√§t an erster Stelle, so dass von einem Einrasten des Erscheinungsbilds sowie des Textes des Quellcodes selbst keine Rede war.  Daher ist das minimalistische ‚ÄûDesign‚Äú des Programms wie folgt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oz/ki/8b/ozki8byinhgupo_k6hvfnzab-oc.jpeg"></div><br>  Oben im Hauptfenster (und nur im Fenster) befindet sich ein Men√º, f√ºr dessen Schaltfl√§chen Sie beliebige Funktionen zuweisen k√∂nnen.  Der Men√ºpunkt ‚ÄûXILINX‚Äú wird sp√§ter beschrieben. <br><br>  Unten sind zwei Fenster.  Der obere Teil zeigt Nachrichten an, die vom Programm an das Plugin "DOCSHELL.dll" gesendet und von diesem empfangen wurden. <br><br>  Im unteren Fenster k√∂nnen Sie die gew√ºnschten Befehle eingeben und in der entsprechenden Zeile doppelklicken. <br><br>  Wenn das Programm gestartet wird, werden einige Befehle darin angezeigt. <br><br>  <em>Wenn Sie pl√∂tzlich mit einem echten Chip arbeiten, seien Sie vorsichtig, denn</em>  <em>Keine Warnungen, dass Sie beim Formatieren usw. alle Daten verlieren k√∂nnten.</em>  <em>Das Programm ist nicht implementiert.</em> <br><br>  Die Datei "DOCSHELL.dll" befindet sich im Verzeichnis mit dem installierten Programm PG4UW <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(4)</a> von "Dataman" (m√∂glich von "Elnec"). <br><br>  Um eine DLL eines Drittanbieters in Ihrem Programm verwenden zu k√∂nnen, ben√∂tigen Sie eine Header-Datei mit einer Beschreibung der exportierten Methoden und ihrer Argumente.  Aufgrund seiner Abwesenheit musste ich diese Informationen selbst wiederherstellen.  Die Methoden f√ºr eine solche Wiederherstellung gehen √ºber den Rahmen dieses Artikels hinaus, sodass die Argumente der exportierten Methoden in den angeh√§ngten Quellen zu finden sind. <br><br>  Mit der Benutzeroberfl√§che in Bezug auf die Interaktion mit dem Plugin ist die Sache etwas klarer geworden.  Jetzt k√∂nnen Sie mit der Implementierung der Kommunikation mit der Mikroschaltung auf physikalischer Ebene fortfahren, um die vom Plugin empfangenen Lese- / Schreibbefehle von / zu mDOC ausf√ºhren zu k√∂nnen. <br><br>  Das Programmmodul f√ºr den Programmierer wurde in der IDE "IAR Embedded Workbench for ARM" in C geschrieben.  Quellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(7)</a> sind beigef√ºgt. <br><br>  Das Debuggen wurde mit dem JTAG J-Link-Debugger durchgef√ºhrt, der √ºber einen an der Seite des Geh√§uses angebrachten JTAG-Anschluss mit dem Programmierer verbunden und √ºber ein Flachkabel mit dem Motherboard verbunden war. <br><br>  <em>Der JTAG-Debugger J-Link v9 wurde auf Aliexpress gekauft.</em>  <em>Die mit der ‚ÄûIAR Embedded Workbench for ARM‚Äú installierten Treiber funktionieren hervorragend damit, und sogar das Aktualisieren der nativen Firmware von SEGGER war erfolgreich.</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/md/5e/vq/md5evqm8gj7khtrvdsucwhd5yac.jpeg"></div><br>  Strukturell besteht der Programmierer aus acht √ºbereinander angeordneten und durch Verbinder miteinander verbundenen Karten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3v/1n/b6/3v1nb6ntkgimwtwtir0lcekdgmm.jpeg"></div><br>  Einstellbare DC-DC-Wandler befinden sich auf der untersten Platine, um mehrere Spannungen zu erzeugen, die f√ºr die Arbeit mit verschiedenen Speichermikroschaltungen erforderlich sind. <br>  Dar√ºber befindet sich ein Motherboard, auf dem der ATMEL AT91SAM9G20 ARM-Mikrocontroller, SDRAM, SPI FLASH mit Firmware, ID-Chip AE801 mit Programmierermodell und Seriennummer, USB-Chip ISP1582, Digital-Analog-Wandler TLC7226 f√ºr das Spannungsmanagement von DC-DC-Wandlern, eine Reihe anderer Chips und externer Anschl√ºsse zum Anschlie√üen eines Netzteils und ein USB-Kabel zum Anschlie√üen an den Host. <br><br>  Auf der dritten unteren Platine befindet sich der XILINX XC2S50E-Chip, der die Beine des Chips auf dem Adapter steuert, der w√§hrend des Lese- / Schreibvorgangs usw. mit dem Programmierer verbunden ist. <br>  Auf den anderen f√ºnf Karten befinden sich nacheinander geladene Register und Baugruppen mit Transistorschaltern, die an ihre Ausg√§nge angeschlossen sind, √ºber die es m√∂glich ist, Mikroschaltungen an diesen durch Gleichspannungswandler gebildeten Zweigen des Adapters anzulegen. <br>  einschlie√ülich der "Erde".  Da die Register, die die Transistorschl√ºssel steuern, nacheinander geladen werden und die Anzahl der gesteuerten Zweige im Adapter 144 erreichen kann, dauert das Laden aller Schl√ºsselbl√∂cke eine betr√§chtliche Zeit.  Daher werden mit Hilfe von Transistorschaltern nur statische Pegel in die Mikroschaltung eingespeist: Masse, Leistung usw.  Und mit XILINX - dynamisch: Adressen, Daten, CS, OE, RD, WR usw. <br><br>  Um weiter voranzukommen, war mindestens ein Mittel zum Erstellen einer Firmware f√ºr den XILINX XC2S50E-Mikroschaltkreis und ein Schaltplan erforderlich, wenn nicht der gesamte Programmierer, dann zumindest ein Teil davon CPU-FPGA-Adapter-Sockel. <br><br>  F√ºr die IDE f√ºr XILINX Spartan-IIE musste ich die alte Version von ISE 10.1 verwenden, weil  Alle nachfolgenden IDEs unterst√ºtzen das Spartan-II-FPGA-Modell nicht. <br><br>  Die Situation mit dem Schaltplan erwies sich als komplizierter.  Um die f√ºr uns interessanten Verbindungen zu identifizieren, mussten wir den U4- und XILINX U12-Prozessor von den Karten entfernen, um Zugang zu den Pads unter ihren BGA-Geh√§usen zu erhalten, weil  Nicht alle haben einen Schalter auf der R√ºckseite. <br><table><tbody><tr><td><div style="text-align:center;"><img src="https://habrastorage.org/webt/em/i6/xz/emi6xzfj5g9ks4imtdzvrc9mqa0.jpeg"></div></td><td><div style="text-align:center;"><img src="https://habrastorage.org/webt/fl/rg/st/flrgstgrxvaicirr108z0ahlphs.jpeg"></div></td></tr></tbody></table>  Der Host kommuniziert mit dem Programmierer √ºber USB √ºber mehrere Endpunkte (Endpunkte).  Der Host fungiert immer als Host.  √úber einen der Endpunkte sendet der Host einen Befehl an den Programmierer und erh√§lt √ºber diesen eine Best√§tigung. <br>  durch einen anderen tauschen sie Daten miteinander aus. <br><br>  Das Parsen von Befehlen vom Host im Programmmodul wird in der Methode USB_ReceiveBuf_EP1RX_Parse () ausgef√ºhrt. <br><br>  Das Befehlspaket wird durch die CMD_PROG-Struktur beschrieben und besteht aus mehreren Feldern.  Wenn das Cmd-Feld 1 enth√§lt, ist dies ein Befehl zum Arbeiten mit der Mikroschaltung, und das ProgProcNum-Feld ist in diesem Fall der Index im Array _progProcedures von PROG_PROC-Strukturen, in einem dieser Felder ist ein Zeiger auf den auszuf√ºhrenden Befehl gespeichert. <br><br>  Im Verzeichnis mit dem installierten Programm "SUPERPRO 6100N" befindet sich ein Unterverzeichnis "\ lib".  Es mit der Erweiterung "* .bin" speichert XILINX-Firmware-Dateien f√ºr alle vom Programmierer unterst√ºtzten Arten von Chips.  Darunter befinden sich zwei universelle Firmware zur √úberpr√ºfung des Kontakts der Beine der Mikroschaltung mit den Kontakten der Buchsen im Adapter. <br><br>  Dies ist "GENERAL ~ .BIN" mit einem internen Pull-up f√ºr alle XILINX-Pull-up-Beine und "GENERAL_.BIN" mit einem internen Pull-down-Pull. <br><br>  Die √úberpr√ºfung des Kontakts der Mikroschaltungsbeine erfolgt in der SOCKET_CkeckInsertIC () -Methode des Softwaremoduls wie folgt. <br><br>  Zun√§chst wird die Firmware ‚ÄûGENERAL_.BIN‚Äú in XILINX geladen und mit ihrer Hilfe werden alle an den Sockel angeschlossenen FPGA-Zweige f√ºr die Ausgabe konfiguriert und mit logischer ‚Äû1‚Äú versorgt.  Dann wird wiederum jeder FPGA-Zweig f√ºr die Eingabe neu konfiguriert, eine logische Ebene wird daraus gelesen und dann wird wieder "1" an diesen Zweig ausgegeben. <br><br>  Wenn das Mikroschaltungsbein elektrischen Kontakt mit dem entsprechenden Sockelbein hat, sollte ‚Äû1‚Äú daraus abgelesen werden (durch die internen Schutzdioden des Mikroschaltkreises von allen anderen Beinen).  Und wenn kein Kontakt besteht, wird aufgrund der Tatsache, dass alle FPGA-Pins in den Boden gezogen sind, ‚Äû0‚Äú von diesem Eingang gelesen.  Danach wird ein Array von auf diese Weise gelesenen logischen Ebenen an den Host gesendet und dort verarbeitet.  Als n√§chstes wird die Ausf√ºhrung der angegebenen Operation fortgesetzt, oder es wird eine Meldung √ºber die Nicht-VKontakte der entsprechenden Schenkel der Mikroschaltung in der Buchse angezeigt. <br>  Nach erfolgreichem Bestehen dieses Tests sendet der Host die Firmware f√ºr XILINX, die dem im Adapter installierten Chip entspricht, an den Programmierer. <br><br>  Durch das Kompilieren eines Programms f√ºr FPGA in ISE 10.1 (sequentielle Ausf√ºhrung von Syntheseprozeduren (Synthesize), Implementierung eines Designs (Implement Design) und Generierung von Programmierdateien (Generate Programming File)) wird eine bin√§re Konfigurationsdatei ‚Äûxeltek.bin‚Äú mit 78756 Bytes im Projektverzeichnis erstellt.  <em>Dazu m√ºssen in den Eigenschaften des Prozesses "Programmierdatei generieren" im Fenster "Prozesse" in der Kategorie "Allgemeine Optionen" zwei Optionen festgelegt werden: "Bitdatei erstellen" und "Bibary-Konfigurationsdatei erstellen".</em> <br><br>  Es ist nicht bekannt, aus welchen Gr√ºnden, aber XELTEK-Programmierer haben beschlossen, die so erhaltenen Dateien zu √§ndern, indem sie alle Bits in jedem Byte spiegeln. <br><br>  Wenn Sie aus irgendeinem Grund Ihre eigene Datei auf diese Weise "spiegeln" oder die Datei aus dem Verzeichnis "\ lib" zur√ºck in die normale Ansicht "spiegeln" m√ºssen, befindet sich in der Software im Men√º "XILINX" zu diesem Zweck der Punkt "Bitstream Converter" (am Ende des Namens) Die resultierende Datei ist unterstrichen. <br><br>  Um mit dem SDED5-Chip auf physischer Ebene zu arbeiten, sind im Softwaremodul die folgenden vier Methoden implementiert: <br><br>  - PROGPROC_FLWRITE_IO_WORD () - Zeichnet ein Wort (16 Bit) an der angegebenen Adresse auf <br>  - PROGPROC_FLREAD_IO_WORD () - Lesen Sie das Wort (16 Bit) an der angegebenen Adresse <br>  - PROGPROC_hal_blk_write_nor () - Schreiben Sie einen oder mehrere Sektoren (jeweils 512 Byte) an die angegebene Adresse <br>  - PROGPROC_hal_blk_read_nor () - Liest einen oder mehrere Sektoren (jeweils 512 Byte) an der angegebenen Adresse <br><br>  F√ºr die Interaktion mit dem FPGA XILINX in unserer Firmware haben wir vier Register identifiziert (E / A-Ports, beschrieben in der Datei common.h f√ºr ARM-Quellen). <br><br>  - _IC_ADDR (0x30000010) <br>  - _IC_DATA (0x30000012) <br>  - _IC_CTRL (0x30000014) // Out: 0 - WE, 1 - 0E, 2 - CE, 3 - RSTIN;  In: 0 - BESETZT <br>  - _IC_ENABLE (0x30000016) // In: 7 - Arbeitserlaubnis (0 - aktiv, 1 - alle Beine an der Steckdose in Z) <br><br>  _IC_ADDR und _IC_DATA sind 16-Bit-Adress- und Datenregister f√ºr den programmierbaren SDED5-Chip. <br>  _IC_CTRL - 8-Bit-Steuerregister, √ºber das die WE-, OE-, CE- und RSTIN-Signale gesetzt und das BUSY-Signal von SDED5 gelesen werden. <br><br>  Die urspr√ºnglichen Softwaremodule verwenden Adressen von 0x30000000 bis 0x3000000E, um mit FPGAs zu kommunizieren.  CPLD mit der XELTEK-Beschriftung ist als Adressdecoder im Programmierer installiert. Da wir die Firmware nicht kennen, haben wir Adressen von 0x30000010 verwendet, um die Wahrscheinlichkeit unerwarteter Konsequenzen zu verringern, die sich aus der Darstellung der Verhaltenslogik eines anderen bei Verwendung von ‚ÄûStandard‚Äú -Adressen ergeben. <br><br>  Nach dem Laden der Firmware in das FPGA befinden sich alle FPGA-Ausg√§nge, die an die Schenkel der Mikroschaltung im Sockel angeschlossen sind, im Z-Zustand. Um damit arbeiten zu k√∂nnen, m√ºssen Sie die Aufl√∂sung aktivieren, indem Sie Null in das siebte Bit des Registers _IC_ENABLE schreiben. <br><br>  Der Algorithmus des gesamten Systems kann wie folgt aussehen. <br><br><ol><li>  Nach dem Starten der Software auf dem Host wird gepr√ºft, ob eine Verbindung zum Programmierer √ºber USB besteht, und die entsprechende Meldung wird in der Statusleiste unten im Hauptfenster angezeigt <br>  (Der Programmierer kann nach dem Start des Programms angeschlossen werden). </li><li>  Der Benutzer w√§hlt den Chip-Typ aus, mit dem er arbeiten m√∂chte. </li><li>  In der Datenbank (im einfachsten Fall nur in der Datei) entspricht der ausgew√§hlte Mikroschaltkreis dem erforderlichen Adaptertyp, und an den Programmierer wird eine Anfrage nach dem darin installierten Adaptertyp gesendet. </li><li>  Der Programmierer fragt den Adapter nach seinem Typ und sendet diese Informationen an den Host zur√ºck, wo diese Informationen mit denen in der Datenbank verglichen werden. Wenn die Adaptertypen √ºbereinstimmen, wird die Arbeit fortgesetzt. </li><li>  F√ºr jeden in der Software ausgew√§hlten Mikrokreistyp sollte ein entsprechendes Men√º mit den f√ºr diesen Mikrokreis verf√ºgbaren Befehlen angezeigt werden (Lesen, Schreiben, √úberpr√ºfen auf Sauberkeit, Vergleich usw.). </li><li>  Wenn Sie einen Men√ºpunkt f√ºr die Arbeit mit der Mikroschaltung ausw√§hlen, wird der entsprechende Befehl an den Programmierer gesendet. Danach √ºberpr√ºft der Programmierer zuerst den elektrischen Kontakt der Kontakte der Buchsen mit den Beinen der Mikroschaltung und f√ºhrt diesen Befehl dann erfolgreich aus, wenn er erfolgreich ist. </li></ol><br>  <em>In den dem Artikel beigef√ºgten Quellcodes werden zur Vereinfachung der Aufgabe keine Punkte vom zweiten bis zum f√ºnften einschlie√ülich implementiert.</em> <br><br><h4>  Zusammenfassung </h4><br>  Wir standen nicht vor der Aufgabe, das Softwaremodul in die urspr√ºngliche Software zu integrieren. <br>  Daher erhebt das in diesem Artikel beschriebene Material keinen Anspruch auf vollst√§ndige L√∂sung. <br>  Wir hoffen, dass die hier pr√§sentierten Informationen f√ºr eine bestimmte Kategorie von Lesern n√ºtzlich sind. Nach bestem Wissen und Gewissen und Verf√ºgbarkeit der Freizeit werden wir versuchen, Ihre Fragen zu beantworten. <br><br>  Vielen Dank f√ºr Ihr Interesse! <br><br><h4>  Ressourcen </h4><br>  1. <a name="ref1"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PDF - mDOC H3 Embedded Flash Drive (EFD) mit eingebetteter TrueFFS Flash Management Software</a> <br>  2. <a name="ref2"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PDF - Programmieren von mDOC H3-Flash-Speichern mit Dataman-Ger√§teprogrammierern</a> <br>  3. <a name="ref3"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PDF - Software_Utilities_TrueFFS_7.1</a> <br>  4. <a name="PG4UW"></a>  <a href="">Dataman Control Software - PG4UW</a> <br>  5. <a name="linux"></a>  <a href="">Implementierung des mDOC H3-Treibers f√ºr Linux (Leistung wurde nicht getestet)</a> <br>  6. <a name="refSrcHost"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Host-Programmierer-Quelldateien (Visual Studio 2017).</a> <br>  7. <a name="refSrcModule"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelldateien des Softwaremoduls (IAR Embedded Workbench f√ºr ARM v8.30.1).</a> <br>  8. <a name="refSrcFPGA"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelldateien f√ºr FPGA XILINX XC2S50E (XILINX ISE 10.1).</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430634/">https://habr.com/ru/post/de430634/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430622/index.html">Funktionales Denken. Teil 5</a></li>
<li><a href="../de430626/index.html">Ank√ºndigung des Moscow GraphQL Meetup</a></li>
<li><a href="../de430628/index.html">Fortune-Algorithmus, Implementierungsdetails</a></li>
<li><a href="../de430630/index.html">Vergleich der Two Balls Sneakers aus den 60ern und 2016. Von der Sohle bis zu den Schn√ºrsenkeln</a></li>
<li><a href="../de430632/index.html">Service in der Wirtschaft: Wie ausl√§ndische Einzelh√§ndler schl√ºsselfertige Gesch√§fte in Russland er√∂ffnen</a></li>
<li><a href="../de430636/index.html">Kleinhirn und Basalkerne anstelle der Kristallkugel: Wie das Gehirn die Zukunft vorhersagt</a></li>
<li><a href="../de430640/index.html">Rotes Meer: Warum die Aktien von Apple und anderen Technologieunternehmen fallen</a></li>
<li><a href="../de430642/index.html">Regie "Photonik" bei den Olympischen Spielen "Ich bin ein Profi" oder wie man sich ohne Pr√ºfungen in eine Magistratur einschreibt</a></li>
<li><a href="../de430646/index.html">.Net Bin√§re Serialisierung ohne Bezugnahme auf die Assembly mit dem Quelltyp oder wie mit BinaryFormatter verhandelt wird</a></li>
<li><a href="../de430648/index.html">Geschichte von Pac-Man</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>