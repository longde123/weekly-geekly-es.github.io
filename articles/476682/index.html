<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ì üíáüèΩ üßìüèø C√≥mo escribir un zapador en Phaser y ejecutar una tarea de prueba de desarrollador HTML5 ‚ÑπÔ∏è ü§¶üèø üßöüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Buenas tardes, queridos colegas! 

 Mi nombre es Alexander, soy desarrollador de juegos HTML5. 

 En una de las compa√±√≠as donde envi√© mi curr√≠culum, m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo escribir un zapador en Phaser y ejecutar una tarea de prueba de desarrollador HTML5</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476682/">  Buenas tardes, queridos colegas! <br><br>  Mi nombre es Alexander, soy desarrollador de juegos HTML5. <br><br>  En una de las compa√±√≠as donde envi√© mi curr√≠culum, me pidieron que completara una tarea de prueba.  Acept√© y, despu√©s de 1 d√≠a, envi√© como resultado el juego desarrollado de acuerdo con TOR HTML5. <br><br><img src="https://habrastorage.org/webt/4t/ng/dn/4tngdnvlxq3izqrpk2nykww2dvs.png"><br><br>  Como estoy entrenando en programaci√≥n de juegos, as√≠ como para un uso m√°s eficiente de mi c√≥digo, decid√≠ que ser√≠a √∫til escribir un art√≠culo de capacitaci√≥n sobre el proyecto completado.  Y dado que la prueba completa recibi√≥ una evaluaci√≥n positiva y condujo a una invitaci√≥n a una entrevista, probablemente mi decisi√≥n tiene derecho a existir y, posiblemente, ayudar√° a alguien en el futuro. <br><br>  Este art√≠culo dar√° una idea de la cantidad de trabajo suficiente para completar con √©xito la tarea de prueba promedio para la posici√≥n HTML5 del desarrollador.  El material tambi√©n puede ser de inter√©s para cualquiera que quiera familiarizarse con el marco Phaser.  Y si ya est√° trabajando con Phaser y escribiendo en JS, vea c√≥mo desarrollar un proyecto en TypeScript. <br><br>  Entonces, ¬°debajo de cat hay mucho c√≥digo TypeScript! <br><a name="habracut"></a><br><h2>  Introduccion </h2><br>  Damos una breve declaraci√≥n del problema. <br><br><ol><li>  Desarrollaremos un juego HTML5 simple: un zapador cl√°sico. </li><li>  Como herramientas principales usaremos phaser 3, mecanografiado y webpack. </li><li>  El juego estar√° dise√±ado para el escritorio y se ejecutar√° en el navegador. </li></ol><br>  Proporcionamos enlaces al proyecto final. <br><br><div class="spoiler">  <b class="spoiler_title">Enlaces a la demostraci√≥n y fuente</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Demo jugable</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥digo fuente de GitHub</a> <br></div></div><br>  Y recuerda la mec√°nica del zapador, si de repente alguien olvida las reglas del juego.  Pero dado que este es un caso poco probable, las reglas se colocan bajo el spoiler :) <br><br><div class="spoiler">  <b class="spoiler_title">Reglas de zapador</b> <div class="spoiler_text">  El campo de juego consiste en celdas dispuestas en una mesa.  Por defecto, cuando comienza el juego, todas las celdas est√°n cerradas.  Se colocan bombas en algunas de las celdas. <br><br>  Al hacer clic izquierdo en una celda cerrada, se abre.  Si hubo una bomba en una celda abierta, entonces el juego termina en derrota. <br><br>  Si no hab√≠a una bomba en la celda, se muestra un n√∫mero dentro de ella, que indica la cantidad de bombas que hay en las celdas vecinas en relaci√≥n con la apertura actual.  Si no hay bombas cerca, entonces la celda se ve vac√≠a. <br><br>  Al hacer clic con el bot√≥n derecho en una celda cerrada, se marca una bandera.  La tarea del jugador es organizar todas las banderas disponibles para que marquen todas las celdas minadas.  Despu√©s de colocar todas las banderas, el jugador presiona el bot√≥n izquierdo del mouse en una de las celdas abiertas para verificar si gan√≥. <br></div></div><br>  A continuaci√≥n, vamos directamente al manual en s√≠.  Todo el material se divide en peque√±os pasos, cada uno de los cuales describe la implementaci√≥n de una tarea espec√≠fica en poco tiempo.  Entonces, realizando peque√±os objetivos paso a paso, al final crearemos un juego completo.  Use la tabla de contenido si decide ir r√°pidamente a un paso espec√≠fico. <br><br><div class="spoiler">  <b class="spoiler_title">Tabla de contenidos</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1. Preparaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.1 Plantilla de proyecto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.2 Configuraci√≥n de compilaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.3 Instalaci√≥n de m√≥dulos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.4 Preparaci√≥n de activos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2. Creando escenas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.1 Punto de entrada</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.2 Escena de inicio</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.3 Textos de la escena inicial</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.4 Transici√≥n al nivel del juego</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Escena de 2.5 niveles</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.6 Configuraci√≥n de escenas en el punto de entrada</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3. objetos del juego</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.1 Tablero de juego</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.2 Modelo de celda</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.3 Vista de celda</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.4 Crear un sprite en una clase de vista</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.5 Posicionamiento de sprites</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.6 Crear una instancia de FieldView</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.7 Mostrar los campos del tablero.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.8 Fabricando bombas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.9 Configuraci√≥n de valores</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4. Manejo de eventos de entrada</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.1 Seguimiento de eventos de clic del mouse</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Procesamiento de clic izquierdo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.4 Procesamiento de clic derecho</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.5 Objeto GameSceneView</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5. Animaciones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5.1 Animaci√≥n de relleno de tablero</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5.2 Animaciones de volteo de celda</a> <br></div></div><br><a name="section-1"></a><h2>  <font color="#008080">1. Preparaci√≥n</font> </h2><br><a name="section-1-1"></a><h3>  <font color="#008080">1.1 Plantilla de proyecto</font> </h3><br>  Descargue la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">plantilla de proyecto phaser predeterminada</a> .  Esta es la plantilla recomendada por el autor del marco y nos ofrece la siguiente estructura de directorios: <br><div class="scrollable-table"><table><tbody><tr><td>  index.html </td><td colspan="2">  P√°gina HTML que inicia el juego </td></tr><tr><td rowspan="2">  paquete web / </td><td>  base.js </td><td>  configuraci√≥n de compilaci√≥n para entorno de prueba </td></tr><tr><td>  prod.js </td><td>  configuraci√≥n de compilaci√≥n para producci√≥n </td></tr><tr><td rowspan="2">  src / </td><td>  activos / </td><td>  activos del juego (sprites, sonidos, fuentes) </td></tr><tr><td>  index.js </td><td>  punto de entrada </td></tr></tbody></table></div> Para nuestro proyecto, no necesitamos el archivo <code>index.js</code> actual, as√≠ que elim√≠nelo.  Luego cree el directorio <code>/src/scripts/</code> y coloque el archivo vac√≠o <code>index.ts</code> en √©l.  Agregaremos todos nuestros scripts a esta carpeta. <br>  Tambi√©n vale la pena tener en cuenta que al crear un proyecto para producci√≥n, se crear√° un directorio <code>dist</code> en la ra√≠z, en el que se colocar√° la versi√≥n de lanzamiento. <br><br><a name="section-1-2"></a><h3>  <font color="#008080">1.2 Configuraci√≥n de compilaci√≥n</font> </h3><br>  Utilizaremos webpack para el montaje.  Como nuestra plantilla se prepar√≥ originalmente para trabajar con JavaScript, y escribimos en TypeScript, necesitamos realizar peque√±os cambios en la configuraci√≥n del recopilador. <br><br>  En el <code>webpack/base.js</code> agregue la clave de <code>entry</code> , que indica el punto de entrada al construir nuestro proyecto, as√≠ como la configuraci√≥n de <code>ts-loader</code> que describe las reglas para construir scripts TS: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// webpack/base.js //... module.exports = { entry: './src/scripts/index.ts', // ... resolve: { extensions: [ '.ts', '.tsx', '.js' ] }, module: { rules: [{ test: /\.tsx?$/, use: 'ts-loader', exclude: /node_modules/ }, //...</span></span></code> </pre><br>  Tambi√©n necesitaremos crear el archivo tsconfig.json en la ra√≠z del proyecto.  Para m√≠ tiene el siguiente contenido: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"compilerOptions"</span></span>: { <span class="hljs-string"><span class="hljs-string">"module"</span></span>: <span class="hljs-string"><span class="hljs-string">"commonjs"</span></span>, <span class="hljs-string"><span class="hljs-string">"lib"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"dom"</span></span>, <span class="hljs-string"><span class="hljs-string">"es5"</span></span>, <span class="hljs-string"><span class="hljs-string">"es6"</span></span>, <span class="hljs-string"><span class="hljs-string">"es2015"</span></span>, <span class="hljs-string"><span class="hljs-string">"es2017"</span></span>, <span class="hljs-string"><span class="hljs-string">"es2015.promise"</span></span> ], <span class="hljs-string"><span class="hljs-string">"target"</span></span>: <span class="hljs-string"><span class="hljs-string">"es5"</span></span>, <span class="hljs-string"><span class="hljs-string">"skipLibCheck"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"exclude"</span></span>: [<span class="hljs-string"><span class="hljs-string">"node_modules"</span></span>, <span class="hljs-string"><span class="hljs-string">"dist"</span></span>] }</code> </pre> <br><a name="section-1-3"></a><h3>  <font color="#008080">1.3 Instalaci√≥n de m√≥dulos</font> </h3><br>  Instale todas las dependencias de package.json y agregue los m√≥dulos mecanografiado y ts-loader: <br><br><pre> <code class="plaintext hljs">npm i npm i typescript --save-dev npm i ts-loader --save-dev</code> </pre><br>  Ahora el proyecto est√° listo para comenzar el desarrollo.  Tenemos 2 comandos a nuestra disposici√≥n que ya est√°n definidos en la propiedad de <code>scripts</code> en el archivo <code>package.json</code> . <br><br><ol><li>  Cree un proyecto para la depuraci√≥n y √°bralo en un navegador a trav√©s de un servidor local <br><br><pre> <code class="plaintext hljs">npm start</code> </pre> </li><li>  Ejecute la compilaci√≥n para la venta y coloque la compilaci√≥n de lanzamiento en la carpeta dist / <br><br><pre> <code class="plaintext hljs">npm run build</code> </pre> </li></ol><br><a name="section-1-4"></a><h3>  <font color="#008080">1.4 Preparaci√≥n de activos</font> </h3><br>  Todos los recursos para este juego se descargan honestamente de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OpenGameArt</a> (versi√≥n 61x61) y tienen la m√°s amigable de las licencias llamadas <i>Feel free to use</i> , que la p√°gina con el paquete nos dice cuidadosamente).  Por cierto, ¬°el c√≥digo presentado en el art√≠culo tiene la misma licencia!  ;) <br><br>  Elimin√© la imagen del reloj del conjunto descargado y cambi√© el nombre del resto de los archivos para obtener nombres de cuadros que sean f√°ciles de usar.  La lista de nombres y los archivos correspondientes se muestran en la pantalla a continuaci√≥n. <br><br>  A partir de los sprites resultantes, crearemos un atlas de formato <code>Phaser JSONArray</code> en el programa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TexturePacker</a> (hay una versi√≥n gratuita m√°s que suficiente, todav√≠a no he conseguido trabajo) y <code>spritesheet.json</code> archivos <code>spritesheet.png</code> y <code>spritesheet.json</code> generados en el directorio <code>src/assets/</code> project. <br><br><img src="https://habrastorage.org/webt/ms/ki/z9/mskiz9zmuidbxk8hhcbksfmny4k.png"><br><br><a name="section-2"></a><h2>  <font color="#008080">2. Creando escenas</font> </h2><br><a name="section-2-1"></a><h3>  <font color="#008080">2.1 Punto de entrada</font> </h3><br>  Comenzamos el desarrollo creando el punto de entrada descrito en la configuraci√≥n del paquete web. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// src/scripts/index.ts import * as Phaser from "phaser"; new Phaser.Game({ type: Phaser.AUTO, parent: "minesweeper", width: window.innerWidth, height: window.innerHeight, backgroundColor: "#F0FFFF", scene: [] });</span></span></code> </pre><br>  Dado que el juego que tenemos est√° dise√±ado para el escritorio y ocupar√° toda la pantalla, utilizamos audazmente todo el ancho y alto del navegador para los campos de <code>width</code> y <code>height</code> . <br>  El campo de <code>scene</code> es actualmente una matriz vac√≠a y lo arreglaremos. <br><br><a name="section-2-2"></a><h3>  <font color="#008080">2.2 Escena de inicio</font> </h3><br>  Cree la clase de la primera escena en el <code>src/scripts/scenes/StartScene.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StartScene</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Scene</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">'Start'</span></span>); } public preload(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } public create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } }</code> </pre><br>  Para una herencia v√°lida de <code>Phaser.Scene</code> pasamos el nombre de la escena como par√°metro al constructor de la clase padre. <br><br>  Esta escena combinar√° la funcionalidad de precarga de recursos y la pantalla de inicio, invitando al usuario al juego. <br><br>  Por lo general, en mis proyectos, un jugador pasa por dos escenas antes de llegar a la inicial, en este orden: <br><br><pre> <code class="plaintext hljs">Boot =&gt; Preload =&gt; Start</code> </pre><br>  Pero en este caso, el juego es tan simple, y hay tan pocos recursos que no hay raz√≥n para colocar la precarga en una escena separada y a√∫n m√°s lo hace el cargador de <code>Boot</code> inicial separado. <br><br>  Cargaremos todos los activos en el m√©todo de <code>preload</code> .  Para poder trabajar con el atlas creado en el futuro, debemos realizar 2 pasos: <br><br><ol><li>  obtener archivos <code>png</code> y <code>json</code> atlas usando <code>require</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.ts const spritesheetPng = require("./../../assets/spritesheet.png"); const spritesheetJson = require("./../../assets/spritesheet.json"); // ...</span></span></code> </pre><br></li><li>  c√°rguelos en el m√©todo de <code>preload</code> de la escena de inicio: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.ts // ... public preload(): void { this.load.atlas("spritesheet", spritesheetPng, spritesheetJson); } // ...</span></span></code> </pre><br></li></ol><br><a name="section-2-3"></a><h3>  <font color="#008080">2.3 Textos de la escena inicial</font> </h3><br>  En la escena inicial, quedan 2 cosas por hacer: <br><br><ol><li>  dile al jugador c√≥mo comenzar el juego </li><li>  iniciar el juego por iniciativa del jugador </li></ol><br>  Para cumplir con el primer punto, primero creamos dos enumeraciones al comienzo del archivo de escena para describir los textos y sus estilos: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.js enum Texts { Title = 'Minesweeper HTML5', Message = 'Click anywhere to start' } enum Styles { Color = '#008080', Font = 'Arial' } //...</span></span></code> </pre><br>  Y luego cree ambos textos como objetos en el m√©todo de <code>create</code> .  Perm√≠tame recordarle que el m√©todo de <code>create</code> de escenas en <code>Phaser</code> se llamar√° solo despu√©s de cargar todos los recursos en el m√©todo de <code>preload</code> y esto es bastante adecuado para nosotros. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.js //... public create(): void { this.add.text( this.cameras.main.centerX, this.cameras.main.centerY - 100, Texts.Title, {font: `52px ${Styles.Font}`, fill: Styles.Color}) .setOrigin(0.5); this.add.text( this.cameras.main.centerX, this.cameras.main.centerY + 100, Texts.Message, {font: `28px ${Styles.Font}`, fill: Styles.Color}) .setOrigin(0.5); } //...</span></span></code> </pre><br>  En otro proyecto m√°s grande, podr√≠amos poner los textos y estilos en archivos locales de json o en configuraciones separadas, pero dado que ahora solo tenemos 2 l√≠neas, considero que este paso es redundante y en este caso sugiero no complicar nuestras vidas, limit√°ndonos a los listados al comienzo del archivo de escena. <br><br><a name="section-2-4"></a><h3>  <font color="#008080">2.4 Transici√≥n al nivel del juego</font> </h3><br>  Lo √∫ltimo que haremos en esta escena antes de continuar es rastrear el evento de clic del mouse para lanzar al jugador al juego: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.js //... public create(): void { //... this.input.once('pointerdown', () =&gt; { this.scene.start('Game'); }); } //...</span></span></code> </pre> <br><a name="section-2-5"></a><h3>  <font color="#008080">Escena de 2.5 niveles</font> </h3><br>  A juzgar por el par√°metro <code>"Game"</code> pasado al m√©todo <code>this.scene.start</code> ya <code>this.scene.start</code> que era hora de crear una segunda escena, que procesar√≠a la l√≥gica principal del juego.  Cree el archivo <code>src/scripts/scenes/GameScene.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameScene</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Scene</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">'Game'</span></span>); } public create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } }</code> </pre><br>  En esta escena, no necesitamos el m√©todo de <code>preload</code> , porque  Ya hemos cargado todos los recursos necesarios en la escena anterior. <br><br><a name="section-2-6"></a><h3>  <font color="#008080">2.6 Configuraci√≥n de escenas en el punto de entrada</font> </h3><br>  Ahora que ambas escenas est√°n creadas, agr√©guelas a nuestro punto de entrada <br>  <code>src/scripts/index.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//... import { StartScene } from "./scenes/StartScene"; import { GameScene } from "./scenes/GameScene"; //... new Phaser.Game({ // ... scene: [StartScene, GameScene] });</span></span></code> </pre><br><a name="section-3"></a><h2>  <font color="#008080">3. objetos del juego</font> </h2><br>  Entonces, la clase <code>GameScene</code> implementar√° la l√≥gica de nivel de juego.  ¬øY qu√© esperamos del nivel de juego zapador?  Visualmente, esperamos ver un campo de juego con celdas cerradas.  Sabemos que el campo es una tabla, lo que significa que tiene un n√∫mero dado de filas y columnas, en varias de las cuales se colocan c√≥modamente bombas.  Por lo tanto, tenemos suficiente informaci√≥n para crear una entidad separada que describa el campo de juego. <br><br><a name="section-3-1"></a><h3>  <font color="#008080">3.1 Tablero de juego</font> </h3><br>  Cree el archivo <code>src/scripts/models/Board.ts</code> en el que <code>src/scripts/models/Board.ts</code> la clase <code>Board</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Field } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./Field"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Board</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Events</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventEmitter</span></span></span><span class="hljs-class"> </span></span>{ private _scene: Phaser.Scene = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _rows: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _cols: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _bombs: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _fields: Field[] = []; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene, rows: number, cols: number, bombs: number) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._rows = rows; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._cols = cols; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._bombs = bombs; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._fields = []; } public get cols(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._cols; } public get rows(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._rows; } }</code> </pre> <br>  Hagamos que la clase sea la sucesora de Phaser.Events.EventEmitter para acceder a la interfaz para registrar y llamar a eventos, que necesitaremos en el futuro. <br><br>  Una matriz de objetos de la clase <code>Field</code> se almacenar√° en la propiedad privada <code>_fields</code> .  Implementaremos este modelo m√°s tarde. <br><br>  Configuramos propiedades num√©ricas privadas <code>_rows</code> y <code>_cols</code> para indicar el n√∫mero de filas y columnas del campo de juego.  Crea <code>_rows</code> p√∫blicos para leer <code>_rows</code> y <code>_cols</code> . <br><br>  El campo <code>_bombs</code> nos dice la cantidad de bombas que deber√°n generarse para el nivel.  Y en el par√°metro <code>_scene</code> pasamos una referencia al objeto de la escena del juego <code>GameScene</code> , en el que crearemos una instancia de la clase <code>Board</code> . <br><br>  Vale la pena se√±alar que transferimos el objeto de escena al modelo solo para su posterior transmisi√≥n a las vistas, donde lo usaremos solo para mostrar la vista.  El hecho es que el phaser usa directamente el objeto de escena para renderizar sprites y, por lo tanto, nos obliga a proporcionar un enlace a la escena actual al crear prefabricados de sprites, que desarrollaremos en el futuro.  Y por nosotros mismos, aceptaremos el acuerdo de que transferimos el enlace a la escena solo para su uso posterior como motor de visualizaci√≥n y aceptaremos que no llamaremos directamente a los m√©todos personalizados de la escena en modelos y vistas. <br><br>  Una vez que hayamos decidido la interfaz de creaci√≥n del tablero, propongo inicializarla en la escena de nivel, finalizando la clase <code>GameScene</code> : <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// GameScene.ts import { Board } from "../models/Board"; const Rows = 8; const Cols = 8; const Bombs = 8; export class GameScene extends Phaser.Scene { private _board: Board = null; //... public create(): void { this._board = new Board(this, Rows, Cols, Bombs); } }</span></span></code> </pre> <br>  Llevamos los par√°metros del tablero a constantes al comienzo del archivo de escena y los pasamos al constructor del <code>Board</code> al crear una instancia de esta clase. <br><br><a name="section-3-2"></a><h3>  <font color="#008080">3.2 Modelo de celda</font> </h3><br>  El tablero consta de celdas, que desea mostrar en la pantalla.  Cada celda debe colocarse en la posici√≥n correspondiente, determinada por la fila y la columna. <br><br>  Las celdas tambi√©n se seleccionan como una entidad separada.  Cree el archivo <code>src/scripts/models/Field.ts</code> en el que <code>src/scripts/models/Field.ts</code> la clase que describe la celda: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Board } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./Board"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Field</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Events</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventEmitter</span></span></span><span class="hljs-class"> </span></span>{ private _scene: Phaser.Scene = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _board: Board = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _row: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _col: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene, board: Board, row: number, col: number) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._init(scene, board, row, col); } public get col(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._col; } public get row(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._row; } public get board(): Board { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._board; } private _init(scene: Phaser.Scene, <span class="hljs-attr"><span class="hljs-attr">board</span></span>: Board, <span class="hljs-attr"><span class="hljs-attr">row</span></span>: number, <span class="hljs-attr"><span class="hljs-attr">col</span></span>: number): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._board = board; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._row = row; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._col = col; } }</code> </pre><br>  Cada celda debe tener m√©tricas de fila y columna en las que se encuentra.  Configuramos los par√°metros <code>_board</code> y <code>_scene</code> para establecer enlaces a los objetos del tablero y la escena.  Implementamos getters para leer los <code>_row</code> , <code>_col</code> y <code>_board</code> . <br><br><a name="section-3-3"></a><h3>  <font color="#008080">3.3 Vista de celda</font> </h3><br>  Se crea la celda abstracta y ahora queremos visualizarla.  Para mostrar una celda en la pantalla, debe crear su vista.  Cree el archivo <code>src/scripts/views/FieldView.ts</code> y coloque la clase de vista en √©l: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Field } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../models/Field"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FieldView</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameObjects</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sprite</span></span></span><span class="hljs-class"> </span></span>{ private _model: Field = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene, model: Field) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(scene, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'spritesheet'</span></span>, <span class="hljs-string"><span class="hljs-string">'closed'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._model = model; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._init(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._create(); } private _init(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } private _create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } }</code> </pre><br>  Tenga en cuenta que convertimos esta clase en descendiente de <code>Phaser.GameObjects.Sprite</code> .  En t√©rminos de fase, esta clase se ha convertido en un sprite prefabricado.  Es decir, obtuve la funcionalidad del objeto de juego del sprite, que ampliaremos a√∫n m√°s con nuestros propios m√©todos. <br><br>  Veamos el constructor de esta clase.  Aqu√≠, en primer lugar, debemos llamar al constructor de la clase padre con los siguientes conjuntos de par√°metros: <br><br><ul><li>  enlace al objeto de la escena (como advert√≠ en la secci√≥n 3.1: el phaser requiere que nos vinculemos a la escena actual para renderizar sprites) </li><li>  coordenadas <code>y</code> en lienzo </li><li>  la clave de cadena para la que est√° disponible el atlas, que cargamos en el m√©todo de <code>preload</code> de la escena de inicio </li><li>  la clave de cadena de fotograma en este atlas que desea seleccionar para mostrar el sprite </li></ul><br>  Establezca una referencia al modelo (es decir, una instancia de la clase <code>Field</code> ) en la propiedad privada <code>_model</code> . <br><br>  Tambi√©n iniciamos prudentemente 2 <code>_create</code> <code>_init</code> y <code>_create</code> actualmente vac√≠os, que implementaremos un poco m√°s tarde. <br><br><a name="section-3-4"></a><h3>  <font color="#008080">3.4 Crear un sprite en una clase de vista</font> </h3><br>  Entonces, se cre√≥ la vista, pero ella todav√≠a no sabe c√≥mo dibujar un sprite.  Para colocar el sprite con el marco que necesitamos en el lienzo, deber√° modificar nuestro propio m√©todo privado <code>_create</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.js //... private _create(): void { this.scene.add.existing(this); //      this.setOrigin(0.5); //  pivot point    } //...</span></span></code> </pre><br><a name="section-3-5"></a><h3>  <font color="#008080">3.5 Posicionamiento de sprites</font> </h3><br>  Por el momento, todos los sprites creados se colocar√°n en las coordenadas (0, 0) del lienzo.  Tambi√©n necesitamos colocar cada celda en su posici√≥n correspondiente en el tablero.  Es decir, al lugar que corresponde a la fila y columna de esta celda.  Para hacer esto, necesitamos escribir un c√≥digo para calcular las coordenadas de cada instancia de la clase <code>FieldView</code> . <br><br>  Agregue la propiedad <code>_position</code> a la clase, que es responsable de las coordenadas finales de la celda en el campo de juego: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... interface Vec2 {x: number, y: number}; export class FieldView extends Phaser.GameObjects.Sprite { private _position: Vec2 = {x: 0, y: 0}; //...</span></span></code> </pre><br>  Dado que queremos alinear el tablero y, en consecuencia, las celdas en √©l, en relaci√≥n con el centro de la pantalla, tambi√©n necesitamos la propiedad <code>_offset</code> , que indica el desplazamiento de esta celda en particular en relaci√≥n con los bordes izquierdo y superior de la pantalla.  Agr√©guelo con un captador privado: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private get _offset(): Vec2 { return { x: (this.scene.cameras.main.width - this._model.board.cols * this.width) / 2, y: (this.scene.cameras.main.height - this._model.board.rows * this.height) / 2 }; } //...</span></span></code> </pre><br>  Por lo tanto, nosotros: <br><br><ol><li>  <code>this._scene.cameras.main.width</code> ancho total de la pantalla en <code>this._scene.cameras.main.width</code> . </li><li>  Obtuvimos el ancho total de la placa multiplicando el n√∫mero de celdas por el ancho de una celda: <code>this._board.cols * this.width</code> . </li><li>  Quitando el ancho del tablero del ancho de la pantalla, obtuvimos un lugar en la pantalla, no ocupado por el tablero. </li><li>  Dividiendo el n√∫mero resultante por 2, obtuvimos el valor de sangr√≠a a la izquierda y a la derecha del tablero. </li><li>  Al cambiar cada celda por el valor de esta sangr√≠a, garantizamos la alineaci√≥n de toda la placa a lo largo del eje <code>x</code> . </li></ol><br>  Realizamos acciones absolutamente similares para obtener desplazamiento vertical. <br><br>  Queda por agregar el c√≥digo necesario en el m√©todo <code>_init</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts // ... private _init(): void { const offset = this._offset; this.x = this._position.x = offset.x + this.width * this._model.col + this.width / 2; this.y = this._position.y = offset.y + this.height * this._model.row + this.height / 2; } // ...</span></span></code> </pre><br>  Las propiedades <code>this.x</code> , <code>this.y</code> , <code>this.width</code> y <code>this.height</code> aqu√≠ son las propiedades heredadas de la clase <code>Phaser.GameObjects.Sprite</code> .  Cambiar las propiedades de <code>this.x</code> <code>this.y</code> conduce a la correcta colocaci√≥n del sprite en el lienzo. <br><br><a name="section-3-6"></a><h3>  <font color="#008080">3.6 Crear una instancia de FieldView</font> </h3><br>  Cree una vista en la clase <code>Field</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts // ... private _view: FieldView = null; public get view(): FieldView { return this._view; } private _init(scene: Phaser.Scene, board: Board, row: number, col: number): void { //... this._view = new FieldView(this._scene, this); } // ...</span></span></code> </pre><br><a name="section-3-7"></a><h3>  <font color="#008080">3.7 Mostrar los campos del tablero.</font> </h3><br>  Volvamos a la clase <code>Board</code> , que es esencialmente una colecci√≥n de objetos <code>Field</code> y crear√° celdas. <br><br>  <code>_create</code> c√≥digo de creaci√≥n de la placa en un m√©todo <code>_create</code> separado y llamaremos a este m√©todo desde el constructor.  Sabiendo que en el m√©todo <code>_create</code> no solo crearemos celdas, <code>_createFields</code> el c√≥digo para crear celdas en un m√©todo <code>_createFields</code> separado. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts constructor(scene: Phaser.Scene, rows: number, cols: number, bombs: number) { // ... this._create(); } private _create(): void { this._createFields(); } private _createFields(): void { }</span></span></code> </pre><br>  Es en este m√©todo que crearemos el n√∫mero deseado de celdas en un bucle anidado: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts // ... private _createFields(): void { for (let row = 0; row &lt; this._rows; row++) { for (let col = 0; col &lt; this._cols; col++) { this._fields.push(new Field(this._scene, this, row, col)); } } } //...</span></span></code> </pre><br>  Es la primera vez que se ejecuta el ensamblado para la depuraci√≥n con el comando <br><br><pre> <code class="plaintext hljs">npm start</code> </pre> <br>  Aseg√∫rese de que en el centro de la pantalla se espera que veamos 64 celdas en 8 filas. <br><br><a name="section-3-8"></a><h3>  <font color="#008080">3.8 Fabricando bombas</font> </h3><br>  Anteriormente, inform√© que en el m√©todo <code>_create</code> de la clase <code>Board</code> , no solo crearemos campos.  Que mas  Tambi√©n habr√° la creaci√≥n de bombas y la configuraci√≥n de las c√©lulas creadas para el n√∫mero de bombas vecinas.  Comencemos con las bombas mismas. <br><br>  Necesitamos colocar N bombas en el tablero en celdas aleatorias.  Describimos el proceso de creaci√≥n de bombas con un algoritmo aproximado: <br><br><pre> <code class="plaintext hljs">                        </code> </pre><br>  En cada iteraci√≥n del bucle, obtendremos una celda aleatoria de la propiedad <code>this._fields</code> hasta que creemos tantas bombas como se especifica en el campo <code>this._bombs</code> .  Si la celda recibida est√° vac√≠a, instalaremos una bomba en ella y actualizaremos el contador de las bombas necesarias para la generaci√≥n. <br><br>  Para generar un n√∫mero aleatorio, utilizamos el m√©todo est√°tico <code>Phaser.Math.Between</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _createBombs(): void { let count = this._bombs; //      while (count &gt; 0) { //       let field = this._fields[Phaser.Math.Between(0, this._fields.length - 1)]; //    if (field.empty) { //     field.setBomb(); //     --count; //    } } }</span></span></code> </pre><br>  No olvides escribir la llamada a <code>this._createBombs();</code> en el archivo <code>Board.ts</code> <code>this._createBombs();</code>  al final del m√©todo <code>_create</code> <br><br>  Como ya not√≥, para que este c√≥digo funcione correctamente, debe refinar la clase <code>Field</code> agregando el getter <code>empty</code> y el m√©todo <code>setBomb</code> . <br><br>  Agregue un campo privado <code>_value</code> a la <code>_value</code> Field, que regular√° el contenido de la celda.  Aceptamos los siguientes acuerdos. <br><div class="scrollable-table"><table><tbody><tr><td>  <code>_value</code> === 0 </td><td>  la celda est√° vac√≠a y no hay minas ni valores en ella </td></tr><tr><td>  <code>_value</code> === -1 </td><td>  hay una mina en la celda </td></tr><tr><td>  <code>_value</code> &gt; 0 </td><td>  en la celda es el n√∫mero de minas ubicadas al lado de la celda actual </td></tr></tbody></table></div><br>  Siguiendo estas reglas, desarrollaremos m√©todos en la clase <code>Field</code> que funcionen con la propiedad <code>_value</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts // ... private _value: number = 0; // ... public get value(): number { return this._value; } public set value(value) { this._value = value; } public get empty(): boolean { return this._value === 0; } public get mined(): boolean { return this._value === -1; } public get filled(): boolean { return this._value &gt; 0; } public setBomb(): void { this._value = -1; } // ...</span></span></code> </pre><br><a name="section-3-9"></a><h3>  <font color="#008080">3.9 Configuraci√≥n de valores</font> </h3><br>  Las bombas est√°n ordenadas y ahora tenemos todos los datos para establecer los valores num√©ricos en todas las celdas que lo requieren. <br><br>  Perm√≠tame recordarle que de acuerdo con las reglas del zapador, la celda debe tener el n√∫mero que corresponde al n√∫mero de bombas ubicadas al lado de esta celda.  En base a esta regla, escribimos el pseudoc√≥digo correspondiente. <br><br><pre> <code class="plaintext hljs">                  </code> </pre><br>  En la clase <code>Board</code> , cree un nuevo m√©todo y traduzca el pseudoc√≥digo especificado en c√≥digo real: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _createValues() { //      this._fields.forEach(field =&gt; { //      if (field.mined) { //     field.getClosestFields().forEach(item =&gt; { //      if (item.value &gt;= 0) { ++item.value; } }); } }); } //...</span></span></code> </pre><br>  Veamos cu√°l de las interfaces que utilizamos no est√° implementada.  <code>getClosestFields</code> agregar el m√©todo <code>getClosestFields</code> para obtener las celdas vecinas. <br><br>  ¬øC√≥mo identificar las c√©lulas vecinas? <br><br>  Por ejemplo, considere cualquier celda del tablero que no est√© en el borde, es decir, no en la fila extrema y no en la columna extrema.  Dichas celdas tienen un n√∫mero m√°ximo de vecinos: 1 en la parte superior, 1 en la parte inferior, 3 a la izquierda y 3 a la derecha (incluidas las celdas en diagonal). <br><br>  Por lo tanto, en cada una de las celdas vecinas, los indicadores <code>_row</code> y <code>_col</code> no difieren en m√°s de 1. Esto significa que podemos especificar de antemano la diferencia entre los par√°metros <code>_row</code> y <code>_col</code> con el campo actual.  Agregue una constante al comienzo del archivo a la descripci√≥n de la clase: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts const Positions = [ {row : 0, col : 1}, //  {row : 0, col : -1}, //  {row : 1, col : 0}, //  {row : 1, col : 1}, //   {row : 1, col : -1}, //   {row : -1, col : 0}, //  {row : -1, col : 1}, //   {row : -1, col : -1} //   ]; //...</span></span></code> </pre><br>  Y ahora podemos agregar el m√©todo faltante, en el que recorreremos esta matriz: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public getClosestFields(): Field[] { let results = []; //      Positions.forEach(position =&gt; { //      let field = this._board.getField(this._row + position.row, this._col + position.col); //       if (field) { //     results.push(field); } }); return results; }; //...</span></span></code> </pre><br>  No olvide verificar la variable de <code>field</code> en cada iteraci√≥n, ya que no todas las celdas en el tablero tienen 8 vecinos.  Por ejemplo, la celda superior izquierda no tendr√° vecinos a su izquierda, y as√≠ sucesivamente. <br><br>  Queda por implementar el m√©todo <code>getField</code> y agregar todas las llamadas necesarias al m√©todo <code>_create</code> en la clase <code>Board</code> <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public getField(row: number, col: number): Field { return this._fields.find(field =&gt; field.row === row &amp;&amp; field.col === col); } //... private _create(): void { this._createFields(); this._createBombs(); this._createValues(); } //...</span></span></code> </pre><br><a name="section-4"></a><h2> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Manejo de eventos de entrada</font></font></font> </h2><br><a name="section-4-1"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1 Seguimiento de eventos de clic del mouse</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por el momento, el tablero est√° completamente inicializado, tiene bombas y hay celdas con n√∫meros, pero todas est√°n cerradas y no hay forma de abrirlas. </font><font style="vertical-align: inherit;">Corregiremos esto e implementaremos la apertura de celdas haciendo clic en el bot√≥n izquierdo del mouse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero, necesitamos rastrear este mismo clic. </font><font style="vertical-align: inherit;">En la clase, </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agregue el </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siguiente c√≥digo </font><font style="vertical-align: inherit;">al final del m√©todo </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FielView.ts //... private _create(): void { // ... this.setInteractive(); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En phaser, puede suscribirse a objetos del espacio de nombres para diferentes eventos </font></font><code>Phaser.GameObjects</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. En particular, suscribiremos al evento click ( </font></font><code>pointerdown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) el prefabricado del propio sprite, es decir, un objeto de una clase </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">heredada de </font></font><code>Phaser.GameObjects.Sprite</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero antes de hacer esto, debemos indicar expl√≠citamente que el sprite es potencialmente interactivo, es decir, generalmente necesita escuchar la entrada del usuario sobre √©l. Debe hacer esto llamando al m√©todo </font></font><code>setInteractive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sin par√°metros en el propio sprite, lo que hicimos en el ejemplo anterior. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que nuestro sprite se ha vuelto interactivo, volvamos a la clase </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el lugar donde se crean los nuevos objetos modelo </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, es decir, al m√©todo </font></font><code>_createFields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y registremos la devoluci√≥n de llamada para los eventos de entrada para la vista:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _createFields(): void { for (let row = 0; row &lt; this._rows; row++) { for (let col = 0; col &lt; this._cols; col++) { const field = new Field(this._scene, this, row, col) field.view.on('pointerdown', this._onFieldClick.bind(this, field)); this._fields.push(field); } } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una vez que hayamos establecido que al hacer clic en el sprite queremos ejecutar el m√©todo </font></font><code>_onFieldClick</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, necesitamos implementarlo. Pero eliminaremos la l√≥gica de procesar el clic de la clase </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Se cree que es mejor procesar el modelo seg√∫n la entrada y, en consecuencia, cambiar sus datos en un controlador separado, cuya similitud es la clase de la escena del juego </font></font><code>GameScene</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Por lo tanto, debemos reenviar el evento de clic m√°s lejos, desde la clase </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a la escena misma. Entonces haremos:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _onFieldClick(field: Field, pointer: Phaser.Input.Pointer): void { if (pointer.leftButtonDown()) { this.emit(`left-click`, field); } else if (pointer.rightButtonDown()) { this.emit(`right-click`, field); } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ no solo lanzamos el evento de clic como lo fue, sino que tambi√©n especificamos qu√© clic fue. </font><font style="vertical-align: inherit;">Esto ser√° √∫til en el futuro, cuando en la clase de escena procesaremos cada opci√≥n de manera diferente. </font><font style="vertical-align: inherit;">Por supuesto, ser√≠a posible enviar el evento de clic tal como est√°, pero simplificaremos el c√≥digo de escena, dejando parte de la l√≥gica con respecto al evento en s√≠ en la clase </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bueno, ahora volvamos a la clase de la escena del juego </font></font><code>GameScene</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y agreguemos un </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c√≥digo </font><font style="vertical-align: inherit;">al final del m√©todo </font><font style="vertical-align: inherit;">que rastrea los eventos de un clic en las celdas:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... import { Field } from "../models/Field"; //... public create(): void { this._board = new Board(this, Rows, Cols, Bombs); this._board.on('left-click', this._onFieldClickLeft, this); this._board.on('right-click', this._onFieldClickRight, this); } private _onFieldClickLeft(field: Field): void { } private _onFieldClickRight(field: Field): void { } //...</span></span></code> </pre><br><a name="section-4-2"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.2. </font><font style="vertical-align: inherit;">Procesamiento de clic izquierdo</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Procedemos a implementar el procesamiento de eventos de clic del mouse. </font><font style="vertical-align: inherit;">Y comience abriendo las celdas. </font><font style="vertical-align: inherit;">Las celdas deben abrirse presionando el bot√≥n izquierdo. </font><font style="vertical-align: inherit;">Y antes de comenzar a programar, expresemos las condiciones que deben cumplirse:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Al hacer clic en una celda cerrada, debe abrirse </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> si hay una mina en una celda abierta, el juego se pierde </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> si no hay minas o valores en la celda abierta, entonces min no est√° en las celdas vecinas, en este caso necesita abrir todas las celdas vecinas y continuar as√≠ hasta que el valor aparezca en la celda abierta </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cuando haces clic en una celda abierta, debes verificar si todas las banderas est√°n configuradas correctamente y, de ser as√≠, finalizar el juego con una victoria </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y ahora, para simplificar la comprensi√≥n de la funcionalidad requerida, traducimos la l√≥gica anterior en pseudoc√≥digo: </font></font><br><br><pre> <code class="plaintext hljs">                         </code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora tenemos una comprensi√≥n de lo que necesita ser programado. </font><font style="vertical-align: inherit;">Implementamos el m√©todo </font></font><code>_onFieldClickLeft</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... private _onFieldClickLeft(field: Field): void { if (field.closed) { //    field.open(); //   if (field.mined) { //    field.exploded = true; this._onGameOver(false); //   } else if (field.empty) { //    this._board.openClosestFields(field); //   } } else if (field.opened) { //    if (this._board.completed) { //       this._onGameOver(true); //   } } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y luego, como siempre, finalizaremos las clases </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementaremos los m√©todos que llamamos en el controlador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indicamos 3 estados posibles de la celda en la enumeraci√≥n </font></font><code>States</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, agregamos un campo </font></font><code>_state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e implementamos un captador para cada estado posible:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts enum States { Closed = 'closed', Opened = 'opened', Marked = 'flag' }; export class Field extends Phaser.Events.EventEmitter { private _state: string = States.Closed; //... public get marked(): boolean { return this._state === States.Marked; } public get closed(): boolean { return this._state === States.Closed; } public get opened(): boolean { return this._state === States.Opened; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que tenemos estados que indican si la celda est√° cerrada o no, podemos agregar un m√©todo </font></font><code>open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que cambiar√° el estado:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public open(): void { this._setState(States.Opened); } private _setState(state: string): void { if (this._state !== state) { this._state = state; this.emit('change'); } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada cambio en el estado del modelo debe desencadenar un evento que informa esto. </font><font style="vertical-align: inherit;">Por lo tanto, presentamos un m√©todo privado adicional </font></font><code>_setState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el que se implementar√° toda la l√≥gica del cambio de estado. </font><font style="vertical-align: inherit;">Este m√©todo se llamar√° en todos los m√©todos p√∫blicos del modelo, que deber√≠an cambiar su estado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue una bandera booleana </font></font><code>_exploded</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para indicar expl√≠citamente exactamente el objeto Field que se hizo explotar:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts private _exploded: boolean = false; //... public set exploded(exploded: boolean) { this._exploded = exploded; this.emit('change'); } public get exploded(): boolean { return this._exploded; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora abra la clase </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e implemente el m√©todo en ella </font></font><code>openClosestFields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este m√©todo es recursivo y su tarea ser√° abrir todos los campos vecinos vac√≠os en relaci√≥n con la celda aceptada en el par√°metro. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El algoritmo ser√° el siguiente:</font></font><br><br><pre> <code class="plaintext hljs"> :                </code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y esta vez ya tenemos todas las interfaces necesarias para la implementaci√≥n completa de este m√©todo: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public openClosestFields(field: Field): void { field.getClosestFields().forEach(item =&gt; {//     if (item.closed) {//    item.open();//   if (item.empty) {//    this.openClosestFields(item);//     } } }); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue un captador </font></font><code>completed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a la clase </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para indicar la colocaci√≥n correcta de banderas en el tablero. </font><font style="vertical-align: inherit;">¬øC√≥mo podemos determinar si un tablero se ha limpiado con √©xito? </font><font style="vertical-align: inherit;">El n√∫mero de campos marcados correctamente debe ser igual al n√∫mero total de bombas en el tablero.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public get completed(): boolean { return this._fields.filter(field =&gt; field.completed).length === this._bombs; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este m√©todo filtra la matriz </font></font><code>_fields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por getter </font></font><code>completed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que debe indicar la validez de la marca de campo. </font><font style="vertical-align: inherit;">Si la longitud de la matriz filtrada (en la que solo caen correctamente los campos marcados, de los cuales el captador </font></font><code>completed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ya </font><font style="vertical-align: inherit;">es responsable </font><font style="vertical-align: inherit;">de la clase </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) es igual al valor del campo </font></font><code>_bombs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(es decir, el n√∫mero de bombas en el tablero), entonces volvemos </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en otras palabras, consideramos que el juego gan√≥. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tampoco nos importa la oportunidad de abrir todo el tablero con una sola llamada, lo que tenemos que hacer al final del nivel. </font><font style="vertical-align: inherit;">Tambi√©n agregaremos esta caracter√≠stica a la clase </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public open(): void { this._fields.forEach(field =&gt; field.open()); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Queda por agregar un captador </font></font><code>completed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a la clase misma </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">¬øEn qu√© caso el campo se considerar√° borrado con √©xito? </font><font style="vertical-align: inherit;">Si est√° minado y marcado. </font><font style="vertical-align: inherit;">Ambos captadores necesarios ya est√°n all√≠ y podemos agregar este m√©todo:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public get completed(): boolean { return this.marked &amp;&amp; this.mined; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para completar el procesamiento del clic izquierdo del mouse, crearemos un m√©todo </font></font><code>_onGameOver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el que deshabilitemos el seguimiento de los eventos del tablero y le mostraremos al jugador todo el tablero. </font><font style="vertical-align: inherit;">M√°s adelante tambi√©n agregaremos un c√≥digo de representaci√≥n del informe de finalizaci√≥n de estado basado en el par√°metro </font></font><code>status</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... private _onGameOver(status: boolean) { this._board.off('left-click', this._onFieldClickLeft, this); this._board.off('right-click', this._onFieldClickRight, this); this._board.open(); } //...</span></span></code> </pre><br><a name="section-4-3"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3 Visualizaci√≥n de campo</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de comenzar a procesar el clic derecho, aprenderemos a volver a dibujar las celdas reci√©n abiertas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anteriormente en la clase, </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desarrollamos un m√©todo </font></font><code>_setState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que dispara un evento </font></font><code>change</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuando cambia el estado del modelo. Usaremos esto y en la clase </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rastrearemos este evento:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _init(): void { //... this._model.on('change', this._onStateChange, this); } private _onStateChange(): void { this._render(); } private _render(): void { this.setFrame(this._frameName); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espec√≠ficamente convertimos el m√©todo intermedio en una </font></font><code>_onStateChange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devoluci√≥n de llamada del evento de cambio de modelo. </font><font style="vertical-align: inherit;">En el futuro, necesitaremos verificar c√≥mo se cambi√≥ el modelo para comprender si es necesario realizarlo </font></font><code>_render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para mostrar el sprite actual de una celda en un nuevo estado, debe cambiar su marco. </font><font style="vertical-align: inherit;">Como cargamos el atlas como activos, podemos llamar al m√©todo </font></font><code>setFrame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para cambiar el marco actual a uno nuevo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para obtener el marco en una l√≠nea, utilizamos astutamente el getter </font></font><code>_frameName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que ahora debe implementarse. </font><font style="vertical-align: inherit;">Primero, describimos todos los valores posibles que puede tomar un marco de celda.</font></font><br><div class="scrollable-table"><table><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Marco </font></font></td><td>  Condici√≥n </td></tr><tr><td> <code>closed</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El campo esta cerrado </font></font><br></td></tr><tr><td> <code>flag</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Campo marcado </font></font><br></td></tr><tr><td> <code>empty</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El campo est√° abierto, no extra√≠do o lleno de valor. </font></font><br></td></tr><tr><td> <code>exploded</code> <br> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> el campo est√° abierto, explotado y explotado </font></font><br></td></tr><tr><td> <code>mined</code> <br> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> el campo est√° abierto, minado, pero no explotado </font></font><br></td></tr><tr><td> <code>1...9</code> <br> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> el campo est√° abierto y muestra un valor del 1 al 9, que indica el n√∫mero de bombas al lado de este campo </font></font><br></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtuvimos una descripci√≥n de todos los estados y ya tenemos todos los m√©todos del modelo, gracias a los cuales se pueden obtener estos estados. </font><font style="vertical-align: inherit;">Vamos a obtener una peque√±a configuraci√≥n al comienzo del archivo:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts const States = { 'closed': field =&gt; field.closed, 'flag': field =&gt; field.marked, 'empty': field =&gt; field.opened &amp;&amp; !field.mined &amp;&amp; !field.filled, 'exploded': field =&gt; field.opened &amp;&amp; field.mined &amp;&amp; field.exploded, 'mined': field =&gt; field.opened &amp;&amp; field.mined &amp;&amp; !field.exploded } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las claves en este objeto ser√°n los valores de los marcos, y los valores de estas claves son las devoluciones de llamada que devuelven un resultado booleano. </font><font style="vertical-align: inherit;">En base a esta configuraci√≥n, podemos desarrollar un m√©todo para obtener el marco deseado (es decir, la clave de la configuraci√≥n):</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private get _frameName(): string { for (let key in States) { if (States[key](this._model)) { return key; } } return this._model.value.toString(); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, mediante una simple enumeraci√≥n en un bucle, revisamos todas las claves del objeto de configuraci√≥n y llamamos a cada devoluci√≥n de llamada a su vez. </font><font style="vertical-align: inherit;">La funci√≥n que nos devuelve primero </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indicar√° que la clave </font></font><code>key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en la iteraci√≥n actual es el marco correcto para el estado actual del modelo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si ninguna clave es adecuada, entonces para el estado predeterminado consideraremos un campo abierto con un valor </font></font><code>_value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ya </font></font><code>States</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que no configuramos </font><font style="vertical-align: inherit;">este estado en la configuraci√≥n </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos probar completamente el clic izquierdo en los campos del tablero y verificar c√≥mo se abren las celdas y qu√© se muestra despu√©s de abrirlas.</font></font><br><br><a name="section-4-4"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.4 Procesamiento de clic derecho</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como en el caso de crear el controlador de clic izquierdo, primero definimos claramente la funcionalidad esperada. </font><font style="vertical-align: inherit;">Al hacer clic derecho, debemos marcar la celda seleccionada con una bandera. </font><font style="vertical-align: inherit;">Pero hay ciertas condiciones.</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Solo se puede marcar un campo cerrado que no est√° marcado actualmente </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si el campo est√° marcado, entonces un clic derecho nuevamente eliminar√° la bandera del campo </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Al configurar / eliminar una bandera, es necesario actualizar el n√∫mero de banderas disponibles en el nivel y mostrar el texto con el n√∫mero actual </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Traduciendo estas condiciones en pseudoc√≥digo, obtenemos las siguientes l√≠neas de comentarios: </font></font><br><br><pre> <code class="plaintext hljs">                              </code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora podemos traducir este algoritmo en llamadas a los m√©todos que necesitamos, incluso si a√∫n no se han desarrollado: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts private _flags: number = 0; //... private _onFieldClickRight(field: Field): void { if (field.closed &amp;&amp; this._flags &gt; 0) { //        field.addFlag(); //     } else if (field.marked) { //     field.removeFlag(); //   } this._flags = Bombs - this._board.countMarked; } //... public create(): void { this._flags = Bombs; //... } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ tambi√©n comenzamos un nuevo campo </font></font><code>_flags</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que al comienzo del nivel del juego es igual al n√∫mero de bombas en el tablero, ya que al comienzo del juego no se ha establecido una sola bandera. </font><font style="vertical-align: inherit;">Este campo est√° obligado a actualizarse con cada clic derecho, ya que en este caso la bandera se agrega o se elimina del tablero. </font><font style="vertical-align: inherit;">Agrega un </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">captador </font><font style="vertical-align: inherit;">a la clase </font></font><code>countMarked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public get countMarked(): number { return this._fields.filter(field =&gt; field.marked).length; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Establecer y eliminar el indicador es un cambio en el estado del modelo </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por lo que implementamos estos m√©todos en la clase correspondiente de manera similar al m√©todo </font></font><code>open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public addFlag(): void { this._setState(States.Marked); } public removeFlag(): void { this._setState(States.Closed); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perm√≠tame recordarle que </font></font><code>_setState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">activar√° un evento </font></font><code>change</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que se rastrea en la vista y, por lo tanto, el sprite se volver√° a dibujar autom√°ticamente esta vez cuando cambie el modelo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al probar la funcionalidad desarrollada, seguramente encontrar√° que cada vez que hace clic con el bot√≥n derecho del mouse, se abre un men√∫ contextual. </font><font style="vertical-align: inherit;">Agregue el c√≥digo que deshabilita este comportamiento al constructor de la escena del juego:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... constructor() { super('Game'); //        document.querySelector("canvas").oncontextmenu = e =&gt; e.preventDefault(); } //...</span></span></code> </pre><br><a name="section-4-5"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.5 Objeto GameSceneView</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para mostrar la interfaz de usuario en la escena del juego, crearemos una clase </font></font><code>GameSceneView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y la colocaremos </font></font><code>src/scripts/views/GameSceneView.ts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este caso, actuaremos de una manera diferente a la creaci√≥n </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y no haremos de esta clase un prefabricado y un heredero </font></font><code>GameObjects</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este caso, necesitamos generar los siguientes elementos desde la vista de escena:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> texto en el n√∫mero de banderas </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bot√≥n de salida </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mensaje de estado de finalizaci√≥n del juego (ganar / perder) </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hagamos que cada elemento de la IU sea un campo separado en la clase </font></font><code>GameSceneView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos a preparar un trozo.</font></font><br><br><pre> <code class="javascript hljs">enum Styles { Color = <span class="hljs-string"><span class="hljs-string">'#008080'</span></span>, Font = <span class="hljs-string"><span class="hljs-string">'Arial'</span></span> } enum Texts { Flags = <span class="hljs-string"><span class="hljs-string">'FLAGS: '</span></span>, Exit = <span class="hljs-string"><span class="hljs-string">'EXIT'</span></span>, Success = <span class="hljs-string"><span class="hljs-string">'YOU WIN!'</span></span>, Failure = <span class="hljs-string"><span class="hljs-string">'YOU LOOSE'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameSceneView</span></span></span><span class="hljs-class"> </span></span>{ private _scene: Phaser.Scene = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _style: {<span class="hljs-attr"><span class="hljs-attr">font</span></span>: string, <span class="hljs-attr"><span class="hljs-attr">fill</span></span>: string}; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._style = {<span class="hljs-attr"><span class="hljs-attr">font</span></span>: <span class="hljs-string"><span class="hljs-string">`28px </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${Styles.Font}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-attr"><span class="hljs-attr">fill</span></span>: Styles.Color}; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._create(); } private _create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } public render() { } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agregue texto con el n√∫mero de banderas. </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _txtFlags: Phaser.GameObjects.Text = null; //... private _createTxtFlags(): void { this._txtFlags = this._scene.add.text( 50, 50, Texts.Flags, this._style ).setOrigin(0, 1); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este c√≥digo colocar√° el texto que necesitamos en una posici√≥n con sangr√≠a de 50 px desde los lados superior e izquierdo y lo configurar√° al estilo especificado. </font><font style="vertical-align: inherit;">Adem√°s, el m√©todo </font></font><code>setOrigin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">establece el punto de pivote del texto en las coordenadas (0, 1). </font><font style="vertical-align: inherit;">Esto significa que el texto se alinear√° con su borde izquierdo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agrega un mensaje de estado.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _txtStatus: Phaser.GameObjects.Text = null; //... private _createTxtStatus(): void { this._txtStatus = this._scene.add.text( this._scene.cameras.main.centerX, 50, Texts.Success, this._style ).setOrigin(0.5, 1); this._txtStatus.visible = false; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colocamos el texto de estado en el centro de la pantalla y lo alineamos con el centro de la l√≠nea llamando </font></font><code>setOrigin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al par√°metro 0.5 para la coordenada x. </font><font style="vertical-align: inherit;">Adem√°s, de manera predeterminada, este texto debe estar oculto, ya que solo lo mostraremos al finalizar el juego. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cree un bot√≥n de salida, que en esencia es tambi√©n un objeto de texto.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _btnExit: Phaser.GameObjects.Text = null; //... private _createBtnExit(): void { this._btnExit = this._scene.add.text( this._scene.cameras.main.width - 50, 50, Texts.Exit, this._style ).setOrigin(1); this._btnExit.setInteractive(); this._btnExit.once('pointerdown', () =&gt; { this._scene.scene.start('Start'); }); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ponemos el bot√≥n en la esquina superior derecha de la pantalla y lo usamos nuevamente </font></font><code>setOrigin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para alinear el texto esta vez con su borde derecho. </font><font style="vertical-align: inherit;">Hacemos que el bot√≥n sea interactivo y agregamos una devoluci√≥n de llamada al evento de clic, que env√≠a al jugador a la escena inicial. </font><font style="vertical-align: inherit;">Por lo tanto, le damos al jugador la oportunidad de salir del nivel en cualquier momento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Queda por desarrollar un m√©todo </font></font><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para actualizar correctamente todos los elementos de la interfaz de usuario y agregar llamadas a todos los m√©todos creados en </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _create(): void { this._createTxtFlags(); this._createTxtStatus(); this._createBtnExit(); } public render(data: {flags?: number, status?: boolean}) { if (typeof data.flags !== 'undefined') { this._txtFlags.text = Texts.Flags + data.flags.toString(); } if (typeof data.status !== 'undefined') { this._txtStatus.text = data.status ? Texts.Success : Texts.Failure; this._txtStatus.visible = true; } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dependiendo de la propiedad pasada en el par√°metro, actualizamos la IU, mostrando los cambios necesarios. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cree una representaci√≥n en la escena del juego en la clase GameScene y escriba la llamada al m√©todo _render siempre que sea necesario con el significado:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... import { GameSceneView } from "../views/GameSceneView"; //... export class GameScene extends Phaser.Scene { private _view: GameSceneView = null; //... private _onGameOver(status: boolean) { //... this._view.render({status}); } //... private _onFieldClickRight(field: Field): void { //... this._flags = Bombs - this._board.countMarked; this._view.render({flags: this._flags}); } //... public create(): void { //... this._view = new GameSceneView(this); this._view.render({flags: this._flags}); } //... }</span></span></code> </pre><br><a name="section-5"></a><h2> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Animaciones</font></font></font> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© tipo de fan√°tico de crear un juego, incluso tan simple como el nuestro, si no hay animaciones en √©l? </font><font style="vertical-align: inherit;">Adem√°s, desde que comenzamos a estudiar el phaser, conozcamos las caracter√≠sticas m√°s b√°sicas de las animaciones y consideremos la funcionalidad de los gemelos. </font><font style="vertical-align: inherit;">Los gemelos se implementan en el marco mismo y no se requieren bibliotecas de terceros. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue 2 animaciones al juego: llenando el tablero con celdas al comienzo y volteando la celda en la apertura. </font><font style="vertical-align: inherit;">Comencemos con el primero de estos.</font></font><br><br><a name="section-5-1"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.1 Animaci√≥n de relleno de tablero</font></font></font> </h3><br><img src="https://habrastorage.org/webt/7r/uu/1v/7ruu1vtppaw26sp-fapxbahgm9q.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos aseguramos de que todas las celdas del tablero vuelen en su lugar desde el borde superior izquierdo de la pantalla. </font><font style="vertical-align: inherit;">Al comenzar el nivel del juego, debemos mover todas las celdas a la esquina superior izquierda de la pantalla y para que cada celda comience la animaci√≥n del movimiento a sus coordenadas correspondientes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la clase, </font></font><code>FiledView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agregue la </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">llamada </font><font style="vertical-align: inherit;">al final de los m√©todos </font></font><code>_animateShow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _create(): void { //... this._animateShow(); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B implementamos el nuevo m√©todo que necesitamos. </font><font style="vertical-align: inherit;">En √©l, como acordamos anteriormente, es necesario realizar 2 cosas:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mueva la celda detr√°s de la esquina superior izquierda para que no sea visible en la pantalla </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> iniciar el movimiento gemelo a las coordenadas deseadas con el retraso correcto </font></font></li></ol><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _animateShow(): Promise&lt;void&gt; { this.x = -this.width; this.y = -this.height; const delay = this._model.row * 50 + this._model.col * 10; return this._moveTo(this._position, delay); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que la esquina superior izquierda del lienzo tiene coordenadas (0, 0), si configuramos la celda con las coordenadas iguales a sus valores negativos de ancho y alto, esto colocar√° la celda detr√°s de la esquina superior izquierda y la ocultar√° de la pantalla. </font><font style="vertical-align: inherit;">Por lo tanto, completamos nuestra primera tarea. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alcanzar√°s el segundo objetivo llamando al m√©todo </font></font><code>_moveTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _moveTo(position: Vec2, delay: number): Promise&lt;void&gt; { return new Promise(resolve =&gt; { this.scene.tweens.add({ targets: this, x: position.x, y: position.y, duration: 600, ease: 'Elastic', easeParams: [1, 1], delay, onComplete: () =&gt; { resolve(); } }); }); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para crear una animaci√≥n, usamos la propiedad de escena </font></font><code>tweens</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En su m√©todo, </font></font><code>add</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pasamos el objeto de configuraci√≥n con la configuraci√≥n:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La propiedad </font></font><code>targets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠ debe contener como valor aquellos objetos del juego a los que desea aplicar efectos de animaci√≥n. </font><font style="vertical-align: inherit;">En nuestro caso, este es un enlace </font></font><code>this</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al objeto actual, ya que es un prefabricado del sprite.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El segundo y tercer par√°metro pasamos las coordenadas del destino. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La propiedad </font></font><code>duration</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es responsable de la duraci√≥n de la animaci√≥n, en nuestro caso, 600 ms.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par√°metros </font></font><code>ease</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>easeParams</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">establecer la funci√≥n de relajaci√≥n.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el campo de retraso, sustituimos el valor del segundo argumento, que se genera para cada celda individual, teniendo en cuenta su posici√≥n en el tablero. </font><font style="vertical-align: inherit;">Esto se hace para que las c√©lulas no salgan volando al mismo tiempo. </font><font style="vertical-align: inherit;">En cambio, cada celda aparecer√° con un ligero retraso en relaci√≥n con la anterior.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, </font></font><code>onComplete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">colocamos una devoluci√≥n </font><font style="vertical-align: inherit;">de </font><font style="vertical-align: inherit;">llamada </font><font style="vertical-align: inherit;">en la propiedad </font><font style="vertical-align: inherit;">, que se llamar√° al final de la acci√≥n de interpolaci√≥n.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es razonable envolver al gemelo en una promesa para que en el futuro pueda acoplar maravillosamente diferentes animaciones, por lo que colocaremos una llamada a la funci√≥n en la devoluci√≥n de llamada que </font></font><code>resolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indica la ejecuci√≥n exitosa de la animaci√≥n.</font></font><br><br><a name="section-5-2"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2 Animaciones de volteo de celda</font></font></font> </h3><br><img src="https://habrastorage.org/webt/uc/d-/yw/ucd-yw-nq6a4veixb-npp0mdyqy.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ser√° genial si, cuando se abri√≥ la celda, se reprodujo el efecto de su inversi√≥n. ¬øC√≥mo podemos lograr esto? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La apertura de una celda se realiza actualmente cambiando el marco cuando se llama al m√©todo </font></font><code>_render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en la vista. Si verificamos el estado del modelo en este m√©todo, veremos si la celda estaba abierta. Si la celda estaba abierta, inicie la animaci√≥n en lugar de mostrar instant√°neamente un nuevo marco de inversi√≥n.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _onStateChange(): void { if (this._model.opened) { this._animateFlip(); } else { this._render(); } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para obtener el efecto deseado, utilizaremos la transformaci√≥n del sprite a trav√©s de la propiedad </font></font><code>scale</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si escalamos el sprite a lo largo del eje </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a cero </font><font style="vertical-align: inherit;">con el tiempo </font><font style="vertical-align: inherit;">, eventualmente se reducir√°, conectando los lados izquierdo y derecho. </font><font style="vertical-align: inherit;">Y viceversa, si escala el sprite a lo largo del eje </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de cero a su ancho completo, lo estiramos a su tama√±o completo. </font><font style="vertical-align: inherit;">Implementamos esta l√≥gica en el m√©todo </font></font><code>_animateFlip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _animateFlip(): void { this._scaleXTo(0).then(() =&gt; { this._render(); this._scaleXTo(1); }) } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por analog√≠a con el m√©todo, </font></font><code>_moveTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementamos </font></font><code>_scaleTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _scaleXTo(scaleX: number): Promise&lt;void&gt; { return new Promise(resolve =&gt; { this.scene.tweens.add({ targets: this, scaleX, ease: 'Elastic.easeInOut', easeParams: [1, 1], duration: 150, onComplete: () =&gt; { resolve() } }); }); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este m√©todo, como par√°metro, tomamos el valor de la escala, que usaremos para cambiar el tama√±o del sprite en ambas direcciones y pasarlo como un segundo par√°metro al objeto de configuraci√≥n de animaci√≥n. </font><font style="vertical-align: inherit;">Todos los dem√°s par√°metros de configuraci√≥n ya nos son familiares de la animaci√≥n anterior. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Ahora comenzaremos el proyecto para probar y despu√©s de la depuraci√≥n consideraremos que nuestro juego est√° completo y la tarea de prueba completada!</font></font> :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬°Agradezco sinceramente a todos por haber llegado a este momento conmigo! </font></font><br><br><h2>  Conclusi√≥n </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colegas, me alegrar√≠a mucho si el material presentado en el art√≠culo les resulta √∫til y pueden utilizar estos o los enfoques descritos en sus propios proyectos. Siempre puede recurrir a m√≠ con cualquier pregunta, tanto en este art√≠culo como en la programaci√≥n por fases o trabajar en gamedev en general. ¬°Agradezco la comunicaci√≥n y me alegrar√° hacer nuevos conocidos e intercambiar experiencias! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y tengo una pregunta para ti ahora mismo. Como estoy creando video tutoriales sobre el desarrollo de juegos, naturalmente acumul√© una docena de estos peque√±os juegos. Cada juego abre el marco a su manera. Por ejemplo, en este juego tocamos el tema de los gemelos, pero hay muchas otras caracter√≠sticas, como f√≠sica, mapa de mosaicos, columna vertebral, etc.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A este respecto, la pregunta es: ¬øte gust√≥ este art√≠culo y, de ser as√≠, te interesar√≠a seguir leyendo art√≠culos como este, pero sobre otros peque√±os juegos cl√°sicos? </font><font style="vertical-align: inherit;">Si la respuesta es s√≠, con mucho gusto traducir√© los materiales de mis videos tutoriales a formato de texto y continuar√© publicando nuevos manuales con el tiempo, pero para otros juegos. </font><font style="vertical-align: inherit;">Traigo la encuesta correspondiente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Gracias a todos por su atenci√≥n! </font><font style="vertical-align: inherit;">Estar√© encantado de recibir comentarios y hasta pronto!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/476682/">https://habr.com/ru/post/476682/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../476670/index.html">Descripci√≥n general de CAD en el n√∫cleo geom√©trico C3D - 2</a></li>
<li><a href="../476674/index.html">Implementaci√≥n r√°pida de ReportPortal para familiarizaci√≥n</a></li>
<li><a href="../476676/index.html">48 recursos de c√≥digo abierto para JavaScript (2019)</a></li>
<li><a href="../476678/index.html">API para recuperaci√≥n as√≠ncrona remota utilizando Apple Combine</a></li>
<li><a href="../476680/index.html">El sistema de planificaci√≥n de producci√≥n continua de Rodov es el Lean / MRP sovi√©tico de 1961. Despegue, puesta de sol y nuevo nacimiento</a></li>
<li><a href="../476686/index.html">Desarrollo de una puerta de enlace IoT basada en Raspberry CM3 +</a></li>
<li><a href="../476688/index.html">Nuevo curso de OTUS. "Desarrollador IOS. Curso avanzado V 2.0 ¬ª</a></li>
<li><a href="../476692/index.html">Principios de marketing de contenidos</a></li>
<li><a href="../476694/index.html">Sobre la robotizaci√≥n empresarial con Farida Roslovets y directora de la empresa RPA electroNeek</a></li>
<li><a href="../476696/index.html">C√≥mo crear e implementar una aplicaci√≥n Full-Stack React</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>