<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤓 💇🏽 🧓🏿 Cómo escribir un zapador en Phaser y ejecutar una tarea de prueba de desarrollador HTML5 ℹ️ 🤦🏿 🧚🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Buenas tardes, queridos colegas! 

 Mi nombre es Alexander, soy desarrollador de juegos HTML5. 

 En una de las compañías donde envié mi currículum, m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cómo escribir un zapador en Phaser y ejecutar una tarea de prueba de desarrollador HTML5</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476682/">  Buenas tardes, queridos colegas! <br><br>  Mi nombre es Alexander, soy desarrollador de juegos HTML5. <br><br>  En una de las compañías donde envié mi currículum, me pidieron que completara una tarea de prueba.  Acepté y, después de 1 día, envié como resultado el juego desarrollado de acuerdo con TOR HTML5. <br><br><img src="https://habrastorage.org/webt/4t/ng/dn/4tngdnvlxq3izqrpk2nykww2dvs.png"><br><br>  Como estoy entrenando en programación de juegos, así como para un uso más eficiente de mi código, decidí que sería útil escribir un artículo de capacitación sobre el proyecto completado.  Y dado que la prueba completa recibió una evaluación positiva y condujo a una invitación a una entrevista, probablemente mi decisión tiene derecho a existir y, posiblemente, ayudará a alguien en el futuro. <br><br>  Este artículo dará una idea de la cantidad de trabajo suficiente para completar con éxito la tarea de prueba promedio para la posición HTML5 del desarrollador.  El material también puede ser de interés para cualquiera que quiera familiarizarse con el marco Phaser.  Y si ya está trabajando con Phaser y escribiendo en JS, vea cómo desarrollar un proyecto en TypeScript. <br><br>  Entonces, ¡debajo de cat hay mucho código TypeScript! <br><a name="habracut"></a><br><h2>  Introduccion </h2><br>  Damos una breve declaración del problema. <br><br><ol><li>  Desarrollaremos un juego HTML5 simple: un zapador clásico. </li><li>  Como herramientas principales usaremos phaser 3, mecanografiado y webpack. </li><li>  El juego estará diseñado para el escritorio y se ejecutará en el navegador. </li></ol><br>  Proporcionamos enlaces al proyecto final. <br><br><div class="spoiler">  <b class="spoiler_title">Enlaces a la demostración y fuente</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Demo jugable</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Código fuente de GitHub</a> <br></div></div><br>  Y recuerda la mecánica del zapador, si de repente alguien olvida las reglas del juego.  Pero dado que este es un caso poco probable, las reglas se colocan bajo el spoiler :) <br><br><div class="spoiler">  <b class="spoiler_title">Reglas de zapador</b> <div class="spoiler_text">  El campo de juego consiste en celdas dispuestas en una mesa.  Por defecto, cuando comienza el juego, todas las celdas están cerradas.  Se colocan bombas en algunas de las celdas. <br><br>  Al hacer clic izquierdo en una celda cerrada, se abre.  Si hubo una bomba en una celda abierta, entonces el juego termina en derrota. <br><br>  Si no había una bomba en la celda, se muestra un número dentro de ella, que indica la cantidad de bombas que hay en las celdas vecinas en relación con la apertura actual.  Si no hay bombas cerca, entonces la celda se ve vacía. <br><br>  Al hacer clic con el botón derecho en una celda cerrada, se marca una bandera.  La tarea del jugador es organizar todas las banderas disponibles para que marquen todas las celdas minadas.  Después de colocar todas las banderas, el jugador presiona el botón izquierdo del mouse en una de las celdas abiertas para verificar si ganó. <br></div></div><br>  A continuación, vamos directamente al manual en sí.  Todo el material se divide en pequeños pasos, cada uno de los cuales describe la implementación de una tarea específica en poco tiempo.  Entonces, realizando pequeños objetivos paso a paso, al final crearemos un juego completo.  Use la tabla de contenido si decide ir rápidamente a un paso específico. <br><br><div class="spoiler">  <b class="spoiler_title">Tabla de contenidos</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1. Preparación</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.1 Plantilla de proyecto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.2 Configuración de compilación</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.3 Instalación de módulos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.4 Preparación de activos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2. Creando escenas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.1 Punto de entrada</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.2 Escena de inicio</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.3 Textos de la escena inicial</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.4 Transición al nivel del juego</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Escena de 2.5 niveles</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.6 Configuración de escenas en el punto de entrada</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3. objetos del juego</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.1 Tablero de juego</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.2 Modelo de celda</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.3 Vista de celda</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.4 Crear un sprite en una clase de vista</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.5 Posicionamiento de sprites</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.6 Crear una instancia de FieldView</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.7 Mostrar los campos del tablero.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.8 Fabricando bombas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.9 Configuración de valores</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4. Manejo de eventos de entrada</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.1 Seguimiento de eventos de clic del mouse</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Procesamiento de clic izquierdo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.4 Procesamiento de clic derecho</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.5 Objeto GameSceneView</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5. Animaciones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5.1 Animación de relleno de tablero</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5.2 Animaciones de volteo de celda</a> <br></div></div><br><a name="section-1"></a><h2>  <font color="#008080">1. Preparación</font> </h2><br><a name="section-1-1"></a><h3>  <font color="#008080">1.1 Plantilla de proyecto</font> </h3><br>  Descargue la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">plantilla de proyecto phaser predeterminada</a> .  Esta es la plantilla recomendada por el autor del marco y nos ofrece la siguiente estructura de directorios: <br><div class="scrollable-table"><table><tbody><tr><td>  index.html </td><td colspan="2">  Página HTML que inicia el juego </td></tr><tr><td rowspan="2">  paquete web / </td><td>  base.js </td><td>  configuración de compilación para entorno de prueba </td></tr><tr><td>  prod.js </td><td>  configuración de compilación para producción </td></tr><tr><td rowspan="2">  src / </td><td>  activos / </td><td>  activos del juego (sprites, sonidos, fuentes) </td></tr><tr><td>  index.js </td><td>  punto de entrada </td></tr></tbody></table></div> Para nuestro proyecto, no necesitamos el archivo <code>index.js</code> actual, así que elimínelo.  Luego cree el directorio <code>/src/scripts/</code> y coloque el archivo vacío <code>index.ts</code> en él.  Agregaremos todos nuestros scripts a esta carpeta. <br>  También vale la pena tener en cuenta que al crear un proyecto para producción, se creará un directorio <code>dist</code> en la raíz, en el que se colocará la versión de lanzamiento. <br><br><a name="section-1-2"></a><h3>  <font color="#008080">1.2 Configuración de compilación</font> </h3><br>  Utilizaremos webpack para el montaje.  Como nuestra plantilla se preparó originalmente para trabajar con JavaScript, y escribimos en TypeScript, necesitamos realizar pequeños cambios en la configuración del recopilador. <br><br>  En el <code>webpack/base.js</code> agregue la clave de <code>entry</code> , que indica el punto de entrada al construir nuestro proyecto, así como la configuración de <code>ts-loader</code> que describe las reglas para construir scripts TS: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// webpack/base.js //... module.exports = { entry: './src/scripts/index.ts', // ... resolve: { extensions: [ '.ts', '.tsx', '.js' ] }, module: { rules: [{ test: /\.tsx?$/, use: 'ts-loader', exclude: /node_modules/ }, //...</span></span></code> </pre><br>  También necesitaremos crear el archivo tsconfig.json en la raíz del proyecto.  Para mí tiene el siguiente contenido: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"compilerOptions"</span></span>: { <span class="hljs-string"><span class="hljs-string">"module"</span></span>: <span class="hljs-string"><span class="hljs-string">"commonjs"</span></span>, <span class="hljs-string"><span class="hljs-string">"lib"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"dom"</span></span>, <span class="hljs-string"><span class="hljs-string">"es5"</span></span>, <span class="hljs-string"><span class="hljs-string">"es6"</span></span>, <span class="hljs-string"><span class="hljs-string">"es2015"</span></span>, <span class="hljs-string"><span class="hljs-string">"es2017"</span></span>, <span class="hljs-string"><span class="hljs-string">"es2015.promise"</span></span> ], <span class="hljs-string"><span class="hljs-string">"target"</span></span>: <span class="hljs-string"><span class="hljs-string">"es5"</span></span>, <span class="hljs-string"><span class="hljs-string">"skipLibCheck"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"exclude"</span></span>: [<span class="hljs-string"><span class="hljs-string">"node_modules"</span></span>, <span class="hljs-string"><span class="hljs-string">"dist"</span></span>] }</code> </pre> <br><a name="section-1-3"></a><h3>  <font color="#008080">1.3 Instalación de módulos</font> </h3><br>  Instale todas las dependencias de package.json y agregue los módulos mecanografiado y ts-loader: <br><br><pre> <code class="plaintext hljs">npm i npm i typescript --save-dev npm i ts-loader --save-dev</code> </pre><br>  Ahora el proyecto está listo para comenzar el desarrollo.  Tenemos 2 comandos a nuestra disposición que ya están definidos en la propiedad de <code>scripts</code> en el archivo <code>package.json</code> . <br><br><ol><li>  Cree un proyecto para la depuración y ábralo en un navegador a través de un servidor local <br><br><pre> <code class="plaintext hljs">npm start</code> </pre> </li><li>  Ejecute la compilación para la venta y coloque la compilación de lanzamiento en la carpeta dist / <br><br><pre> <code class="plaintext hljs">npm run build</code> </pre> </li></ol><br><a name="section-1-4"></a><h3>  <font color="#008080">1.4 Preparación de activos</font> </h3><br>  Todos los recursos para este juego se descargan honestamente de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OpenGameArt</a> (versión 61x61) y tienen la más amigable de las licencias llamadas <i>Feel free to use</i> , que la página con el paquete nos dice cuidadosamente).  Por cierto, ¡el código presentado en el artículo tiene la misma licencia!  ;) <br><br>  Eliminé la imagen del reloj del conjunto descargado y cambié el nombre del resto de los archivos para obtener nombres de cuadros que sean fáciles de usar.  La lista de nombres y los archivos correspondientes se muestran en la pantalla a continuación. <br><br>  A partir de los sprites resultantes, crearemos un atlas de formato <code>Phaser JSONArray</code> en el programa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TexturePacker</a> (hay una versión gratuita más que suficiente, todavía no he conseguido trabajo) y <code>spritesheet.json</code> archivos <code>spritesheet.png</code> y <code>spritesheet.json</code> generados en el directorio <code>src/assets/</code> project. <br><br><img src="https://habrastorage.org/webt/ms/ki/z9/mskiz9zmuidbxk8hhcbksfmny4k.png"><br><br><a name="section-2"></a><h2>  <font color="#008080">2. Creando escenas</font> </h2><br><a name="section-2-1"></a><h3>  <font color="#008080">2.1 Punto de entrada</font> </h3><br>  Comenzamos el desarrollo creando el punto de entrada descrito en la configuración del paquete web. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// src/scripts/index.ts import * as Phaser from "phaser"; new Phaser.Game({ type: Phaser.AUTO, parent: "minesweeper", width: window.innerWidth, height: window.innerHeight, backgroundColor: "#F0FFFF", scene: [] });</span></span></code> </pre><br>  Dado que el juego que tenemos está diseñado para el escritorio y ocupará toda la pantalla, utilizamos audazmente todo el ancho y alto del navegador para los campos de <code>width</code> y <code>height</code> . <br>  El campo de <code>scene</code> es actualmente una matriz vacía y lo arreglaremos. <br><br><a name="section-2-2"></a><h3>  <font color="#008080">2.2 Escena de inicio</font> </h3><br>  Cree la clase de la primera escena en el <code>src/scripts/scenes/StartScene.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StartScene</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Scene</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">'Start'</span></span>); } public preload(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } public create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } }</code> </pre><br>  Para una herencia válida de <code>Phaser.Scene</code> pasamos el nombre de la escena como parámetro al constructor de la clase padre. <br><br>  Esta escena combinará la funcionalidad de precarga de recursos y la pantalla de inicio, invitando al usuario al juego. <br><br>  Por lo general, en mis proyectos, un jugador pasa por dos escenas antes de llegar a la inicial, en este orden: <br><br><pre> <code class="plaintext hljs">Boot =&gt; Preload =&gt; Start</code> </pre><br>  Pero en este caso, el juego es tan simple, y hay tan pocos recursos que no hay razón para colocar la precarga en una escena separada y aún más lo hace el cargador de <code>Boot</code> inicial separado. <br><br>  Cargaremos todos los activos en el método de <code>preload</code> .  Para poder trabajar con el atlas creado en el futuro, debemos realizar 2 pasos: <br><br><ol><li>  obtener archivos <code>png</code> y <code>json</code> atlas usando <code>require</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.ts const spritesheetPng = require("./../../assets/spritesheet.png"); const spritesheetJson = require("./../../assets/spritesheet.json"); // ...</span></span></code> </pre><br></li><li>  cárguelos en el método de <code>preload</code> de la escena de inicio: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.ts // ... public preload(): void { this.load.atlas("spritesheet", spritesheetPng, spritesheetJson); } // ...</span></span></code> </pre><br></li></ol><br><a name="section-2-3"></a><h3>  <font color="#008080">2.3 Textos de la escena inicial</font> </h3><br>  En la escena inicial, quedan 2 cosas por hacer: <br><br><ol><li>  dile al jugador cómo comenzar el juego </li><li>  iniciar el juego por iniciativa del jugador </li></ol><br>  Para cumplir con el primer punto, primero creamos dos enumeraciones al comienzo del archivo de escena para describir los textos y sus estilos: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.js enum Texts { Title = 'Minesweeper HTML5', Message = 'Click anywhere to start' } enum Styles { Color = '#008080', Font = 'Arial' } //...</span></span></code> </pre><br>  Y luego cree ambos textos como objetos en el método de <code>create</code> .  Permítame recordarle que el método de <code>create</code> de escenas en <code>Phaser</code> se llamará solo después de cargar todos los recursos en el método de <code>preload</code> y esto es bastante adecuado para nosotros. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.js //... public create(): void { this.add.text( this.cameras.main.centerX, this.cameras.main.centerY - 100, Texts.Title, {font: `52px ${Styles.Font}`, fill: Styles.Color}) .setOrigin(0.5); this.add.text( this.cameras.main.centerX, this.cameras.main.centerY + 100, Texts.Message, {font: `28px ${Styles.Font}`, fill: Styles.Color}) .setOrigin(0.5); } //...</span></span></code> </pre><br>  En otro proyecto más grande, podríamos poner los textos y estilos en archivos locales de json o en configuraciones separadas, pero dado que ahora solo tenemos 2 líneas, considero que este paso es redundante y en este caso sugiero no complicar nuestras vidas, limitándonos a los listados al comienzo del archivo de escena. <br><br><a name="section-2-4"></a><h3>  <font color="#008080">2.4 Transición al nivel del juego</font> </h3><br>  Lo último que haremos en esta escena antes de continuar es rastrear el evento de clic del mouse para lanzar al jugador al juego: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.js //... public create(): void { //... this.input.once('pointerdown', () =&gt; { this.scene.start('Game'); }); } //...</span></span></code> </pre> <br><a name="section-2-5"></a><h3>  <font color="#008080">Escena de 2.5 niveles</font> </h3><br>  A juzgar por el parámetro <code>"Game"</code> pasado al método <code>this.scene.start</code> ya <code>this.scene.start</code> que era hora de crear una segunda escena, que procesaría la lógica principal del juego.  Cree el archivo <code>src/scripts/scenes/GameScene.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameScene</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Scene</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">'Game'</span></span>); } public create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } }</code> </pre><br>  En esta escena, no necesitamos el método de <code>preload</code> , porque  Ya hemos cargado todos los recursos necesarios en la escena anterior. <br><br><a name="section-2-6"></a><h3>  <font color="#008080">2.6 Configuración de escenas en el punto de entrada</font> </h3><br>  Ahora que ambas escenas están creadas, agréguelas a nuestro punto de entrada <br>  <code>src/scripts/index.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//... import { StartScene } from "./scenes/StartScene"; import { GameScene } from "./scenes/GameScene"; //... new Phaser.Game({ // ... scene: [StartScene, GameScene] });</span></span></code> </pre><br><a name="section-3"></a><h2>  <font color="#008080">3. objetos del juego</font> </h2><br>  Entonces, la clase <code>GameScene</code> implementará la lógica de nivel de juego.  ¿Y qué esperamos del nivel de juego zapador?  Visualmente, esperamos ver un campo de juego con celdas cerradas.  Sabemos que el campo es una tabla, lo que significa que tiene un número dado de filas y columnas, en varias de las cuales se colocan cómodamente bombas.  Por lo tanto, tenemos suficiente información para crear una entidad separada que describa el campo de juego. <br><br><a name="section-3-1"></a><h3>  <font color="#008080">3.1 Tablero de juego</font> </h3><br>  Cree el archivo <code>src/scripts/models/Board.ts</code> en el que <code>src/scripts/models/Board.ts</code> la clase <code>Board</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Field } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./Field"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Board</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Events</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventEmitter</span></span></span><span class="hljs-class"> </span></span>{ private _scene: Phaser.Scene = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _rows: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _cols: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _bombs: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _fields: Field[] = []; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene, rows: number, cols: number, bombs: number) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._rows = rows; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._cols = cols; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._bombs = bombs; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._fields = []; } public get cols(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._cols; } public get rows(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._rows; } }</code> </pre> <br>  Hagamos que la clase sea la sucesora de Phaser.Events.EventEmitter para acceder a la interfaz para registrar y llamar a eventos, que necesitaremos en el futuro. <br><br>  Una matriz de objetos de la clase <code>Field</code> se almacenará en la propiedad privada <code>_fields</code> .  Implementaremos este modelo más tarde. <br><br>  Configuramos propiedades numéricas privadas <code>_rows</code> y <code>_cols</code> para indicar el número de filas y columnas del campo de juego.  Crea <code>_rows</code> públicos para leer <code>_rows</code> y <code>_cols</code> . <br><br>  El campo <code>_bombs</code> nos dice la cantidad de bombas que deberán generarse para el nivel.  Y en el parámetro <code>_scene</code> pasamos una referencia al objeto de la escena del juego <code>GameScene</code> , en el que crearemos una instancia de la clase <code>Board</code> . <br><br>  Vale la pena señalar que transferimos el objeto de escena al modelo solo para su posterior transmisión a las vistas, donde lo usaremos solo para mostrar la vista.  El hecho es que el phaser usa directamente el objeto de escena para renderizar sprites y, por lo tanto, nos obliga a proporcionar un enlace a la escena actual al crear prefabricados de sprites, que desarrollaremos en el futuro.  Y por nosotros mismos, aceptaremos el acuerdo de que transferimos el enlace a la escena solo para su uso posterior como motor de visualización y aceptaremos que no llamaremos directamente a los métodos personalizados de la escena en modelos y vistas. <br><br>  Una vez que hayamos decidido la interfaz de creación del tablero, propongo inicializarla en la escena de nivel, finalizando la clase <code>GameScene</code> : <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// GameScene.ts import { Board } from "../models/Board"; const Rows = 8; const Cols = 8; const Bombs = 8; export class GameScene extends Phaser.Scene { private _board: Board = null; //... public create(): void { this._board = new Board(this, Rows, Cols, Bombs); } }</span></span></code> </pre> <br>  Llevamos los parámetros del tablero a constantes al comienzo del archivo de escena y los pasamos al constructor del <code>Board</code> al crear una instancia de esta clase. <br><br><a name="section-3-2"></a><h3>  <font color="#008080">3.2 Modelo de celda</font> </h3><br>  El tablero consta de celdas, que desea mostrar en la pantalla.  Cada celda debe colocarse en la posición correspondiente, determinada por la fila y la columna. <br><br>  Las celdas también se seleccionan como una entidad separada.  Cree el archivo <code>src/scripts/models/Field.ts</code> en el que <code>src/scripts/models/Field.ts</code> la clase que describe la celda: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Board } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./Board"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Field</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Events</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventEmitter</span></span></span><span class="hljs-class"> </span></span>{ private _scene: Phaser.Scene = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _board: Board = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _row: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _col: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene, board: Board, row: number, col: number) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._init(scene, board, row, col); } public get col(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._col; } public get row(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._row; } public get board(): Board { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._board; } private _init(scene: Phaser.Scene, <span class="hljs-attr"><span class="hljs-attr">board</span></span>: Board, <span class="hljs-attr"><span class="hljs-attr">row</span></span>: number, <span class="hljs-attr"><span class="hljs-attr">col</span></span>: number): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._board = board; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._row = row; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._col = col; } }</code> </pre><br>  Cada celda debe tener métricas de fila y columna en las que se encuentra.  Configuramos los parámetros <code>_board</code> y <code>_scene</code> para establecer enlaces a los objetos del tablero y la escena.  Implementamos getters para leer los <code>_row</code> , <code>_col</code> y <code>_board</code> . <br><br><a name="section-3-3"></a><h3>  <font color="#008080">3.3 Vista de celda</font> </h3><br>  Se crea la celda abstracta y ahora queremos visualizarla.  Para mostrar una celda en la pantalla, debe crear su vista.  Cree el archivo <code>src/scripts/views/FieldView.ts</code> y coloque la clase de vista en él: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Field } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../models/Field"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FieldView</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameObjects</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sprite</span></span></span><span class="hljs-class"> </span></span>{ private _model: Field = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene, model: Field) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(scene, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'spritesheet'</span></span>, <span class="hljs-string"><span class="hljs-string">'closed'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._model = model; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._init(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._create(); } private _init(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } private _create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } }</code> </pre><br>  Tenga en cuenta que convertimos esta clase en descendiente de <code>Phaser.GameObjects.Sprite</code> .  En términos de fase, esta clase se ha convertido en un sprite prefabricado.  Es decir, obtuve la funcionalidad del objeto de juego del sprite, que ampliaremos aún más con nuestros propios métodos. <br><br>  Veamos el constructor de esta clase.  Aquí, en primer lugar, debemos llamar al constructor de la clase padre con los siguientes conjuntos de parámetros: <br><br><ul><li>  enlace al objeto de la escena (como advertí en la sección 3.1: el phaser requiere que nos vinculemos a la escena actual para renderizar sprites) </li><li>  coordenadas <code>y</code> en lienzo </li><li>  la clave de cadena para la que está disponible el atlas, que cargamos en el método de <code>preload</code> de la escena de inicio </li><li>  la clave de cadena de fotograma en este atlas que desea seleccionar para mostrar el sprite </li></ul><br>  Establezca una referencia al modelo (es decir, una instancia de la clase <code>Field</code> ) en la propiedad privada <code>_model</code> . <br><br>  También iniciamos prudentemente 2 <code>_create</code> <code>_init</code> y <code>_create</code> actualmente vacíos, que implementaremos un poco más tarde. <br><br><a name="section-3-4"></a><h3>  <font color="#008080">3.4 Crear un sprite en una clase de vista</font> </h3><br>  Entonces, se creó la vista, pero ella todavía no sabe cómo dibujar un sprite.  Para colocar el sprite con el marco que necesitamos en el lienzo, deberá modificar nuestro propio método privado <code>_create</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.js //... private _create(): void { this.scene.add.existing(this); //      this.setOrigin(0.5); //  pivot point    } //...</span></span></code> </pre><br><a name="section-3-5"></a><h3>  <font color="#008080">3.5 Posicionamiento de sprites</font> </h3><br>  Por el momento, todos los sprites creados se colocarán en las coordenadas (0, 0) del lienzo.  También necesitamos colocar cada celda en su posición correspondiente en el tablero.  Es decir, al lugar que corresponde a la fila y columna de esta celda.  Para hacer esto, necesitamos escribir un código para calcular las coordenadas de cada instancia de la clase <code>FieldView</code> . <br><br>  Agregue la propiedad <code>_position</code> a la clase, que es responsable de las coordenadas finales de la celda en el campo de juego: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... interface Vec2 {x: number, y: number}; export class FieldView extends Phaser.GameObjects.Sprite { private _position: Vec2 = {x: 0, y: 0}; //...</span></span></code> </pre><br>  Dado que queremos alinear el tablero y, en consecuencia, las celdas en él, en relación con el centro de la pantalla, también necesitamos la propiedad <code>_offset</code> , que indica el desplazamiento de esta celda en particular en relación con los bordes izquierdo y superior de la pantalla.  Agréguelo con un captador privado: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private get _offset(): Vec2 { return { x: (this.scene.cameras.main.width - this._model.board.cols * this.width) / 2, y: (this.scene.cameras.main.height - this._model.board.rows * this.height) / 2 }; } //...</span></span></code> </pre><br>  Por lo tanto, nosotros: <br><br><ol><li>  <code>this._scene.cameras.main.width</code> ancho total de la pantalla en <code>this._scene.cameras.main.width</code> . </li><li>  Obtuvimos el ancho total de la placa multiplicando el número de celdas por el ancho de una celda: <code>this._board.cols * this.width</code> . </li><li>  Quitando el ancho del tablero del ancho de la pantalla, obtuvimos un lugar en la pantalla, no ocupado por el tablero. </li><li>  Dividiendo el número resultante por 2, obtuvimos el valor de sangría a la izquierda y a la derecha del tablero. </li><li>  Al cambiar cada celda por el valor de esta sangría, garantizamos la alineación de toda la placa a lo largo del eje <code>x</code> . </li></ol><br>  Realizamos acciones absolutamente similares para obtener desplazamiento vertical. <br><br>  Queda por agregar el código necesario en el método <code>_init</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts // ... private _init(): void { const offset = this._offset; this.x = this._position.x = offset.x + this.width * this._model.col + this.width / 2; this.y = this._position.y = offset.y + this.height * this._model.row + this.height / 2; } // ...</span></span></code> </pre><br>  Las propiedades <code>this.x</code> , <code>this.y</code> , <code>this.width</code> y <code>this.height</code> aquí son las propiedades heredadas de la clase <code>Phaser.GameObjects.Sprite</code> .  Cambiar las propiedades de <code>this.x</code> <code>this.y</code> conduce a la correcta colocación del sprite en el lienzo. <br><br><a name="section-3-6"></a><h3>  <font color="#008080">3.6 Crear una instancia de FieldView</font> </h3><br>  Cree una vista en la clase <code>Field</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts // ... private _view: FieldView = null; public get view(): FieldView { return this._view; } private _init(scene: Phaser.Scene, board: Board, row: number, col: number): void { //... this._view = new FieldView(this._scene, this); } // ...</span></span></code> </pre><br><a name="section-3-7"></a><h3>  <font color="#008080">3.7 Mostrar los campos del tablero.</font> </h3><br>  Volvamos a la clase <code>Board</code> , que es esencialmente una colección de objetos <code>Field</code> y creará celdas. <br><br>  <code>_create</code> código de creación de la placa en un método <code>_create</code> separado y llamaremos a este método desde el constructor.  Sabiendo que en el método <code>_create</code> no solo crearemos celdas, <code>_createFields</code> el código para crear celdas en un método <code>_createFields</code> separado. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts constructor(scene: Phaser.Scene, rows: number, cols: number, bombs: number) { // ... this._create(); } private _create(): void { this._createFields(); } private _createFields(): void { }</span></span></code> </pre><br>  Es en este método que crearemos el número deseado de celdas en un bucle anidado: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts // ... private _createFields(): void { for (let row = 0; row &lt; this._rows; row++) { for (let col = 0; col &lt; this._cols; col++) { this._fields.push(new Field(this._scene, this, row, col)); } } } //...</span></span></code> </pre><br>  Es la primera vez que se ejecuta el ensamblado para la depuración con el comando <br><br><pre> <code class="plaintext hljs">npm start</code> </pre> <br>  Asegúrese de que en el centro de la pantalla se espera que veamos 64 celdas en 8 filas. <br><br><a name="section-3-8"></a><h3>  <font color="#008080">3.8 Fabricando bombas</font> </h3><br>  Anteriormente, informé que en el método <code>_create</code> de la clase <code>Board</code> , no solo crearemos campos.  Que mas  También habrá la creación de bombas y la configuración de las células creadas para el número de bombas vecinas.  Comencemos con las bombas mismas. <br><br>  Necesitamos colocar N bombas en el tablero en celdas aleatorias.  Describimos el proceso de creación de bombas con un algoritmo aproximado: <br><br><pre> <code class="plaintext hljs">                        </code> </pre><br>  En cada iteración del bucle, obtendremos una celda aleatoria de la propiedad <code>this._fields</code> hasta que creemos tantas bombas como se especifica en el campo <code>this._bombs</code> .  Si la celda recibida está vacía, instalaremos una bomba en ella y actualizaremos el contador de las bombas necesarias para la generación. <br><br>  Para generar un número aleatorio, utilizamos el método estático <code>Phaser.Math.Between</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _createBombs(): void { let count = this._bombs; //      while (count &gt; 0) { //       let field = this._fields[Phaser.Math.Between(0, this._fields.length - 1)]; //    if (field.empty) { //     field.setBomb(); //     --count; //    } } }</span></span></code> </pre><br>  No olvides escribir la llamada a <code>this._createBombs();</code> en el archivo <code>Board.ts</code> <code>this._createBombs();</code>  al final del método <code>_create</code> <br><br>  Como ya notó, para que este código funcione correctamente, debe refinar la clase <code>Field</code> agregando el getter <code>empty</code> y el método <code>setBomb</code> . <br><br>  Agregue un campo privado <code>_value</code> a la <code>_value</code> Field, que regulará el contenido de la celda.  Aceptamos los siguientes acuerdos. <br><div class="scrollable-table"><table><tbody><tr><td>  <code>_value</code> === 0 </td><td>  la celda está vacía y no hay minas ni valores en ella </td></tr><tr><td>  <code>_value</code> === -1 </td><td>  hay una mina en la celda </td></tr><tr><td>  <code>_value</code> &gt; 0 </td><td>  en la celda es el número de minas ubicadas al lado de la celda actual </td></tr></tbody></table></div><br>  Siguiendo estas reglas, desarrollaremos métodos en la clase <code>Field</code> que funcionen con la propiedad <code>_value</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts // ... private _value: number = 0; // ... public get value(): number { return this._value; } public set value(value) { this._value = value; } public get empty(): boolean { return this._value === 0; } public get mined(): boolean { return this._value === -1; } public get filled(): boolean { return this._value &gt; 0; } public setBomb(): void { this._value = -1; } // ...</span></span></code> </pre><br><a name="section-3-9"></a><h3>  <font color="#008080">3.9 Configuración de valores</font> </h3><br>  Las bombas están ordenadas y ahora tenemos todos los datos para establecer los valores numéricos en todas las celdas que lo requieren. <br><br>  Permítame recordarle que de acuerdo con las reglas del zapador, la celda debe tener el número que corresponde al número de bombas ubicadas al lado de esta celda.  En base a esta regla, escribimos el pseudocódigo correspondiente. <br><br><pre> <code class="plaintext hljs">                  </code> </pre><br>  En la clase <code>Board</code> , cree un nuevo método y traduzca el pseudocódigo especificado en código real: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _createValues() { //      this._fields.forEach(field =&gt; { //      if (field.mined) { //     field.getClosestFields().forEach(item =&gt; { //      if (item.value &gt;= 0) { ++item.value; } }); } }); } //...</span></span></code> </pre><br>  Veamos cuál de las interfaces que utilizamos no está implementada.  <code>getClosestFields</code> agregar el método <code>getClosestFields</code> para obtener las celdas vecinas. <br><br>  ¿Cómo identificar las células vecinas? <br><br>  Por ejemplo, considere cualquier celda del tablero que no esté en el borde, es decir, no en la fila extrema y no en la columna extrema.  Dichas celdas tienen un número máximo de vecinos: 1 en la parte superior, 1 en la parte inferior, 3 a la izquierda y 3 a la derecha (incluidas las celdas en diagonal). <br><br>  Por lo tanto, en cada una de las celdas vecinas, los indicadores <code>_row</code> y <code>_col</code> no difieren en más de 1. Esto significa que podemos especificar de antemano la diferencia entre los parámetros <code>_row</code> y <code>_col</code> con el campo actual.  Agregue una constante al comienzo del archivo a la descripción de la clase: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts const Positions = [ {row : 0, col : 1}, //  {row : 0, col : -1}, //  {row : 1, col : 0}, //  {row : 1, col : 1}, //   {row : 1, col : -1}, //   {row : -1, col : 0}, //  {row : -1, col : 1}, //   {row : -1, col : -1} //   ]; //...</span></span></code> </pre><br>  Y ahora podemos agregar el método faltante, en el que recorreremos esta matriz: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public getClosestFields(): Field[] { let results = []; //      Positions.forEach(position =&gt; { //      let field = this._board.getField(this._row + position.row, this._col + position.col); //       if (field) { //     results.push(field); } }); return results; }; //...</span></span></code> </pre><br>  No olvide verificar la variable de <code>field</code> en cada iteración, ya que no todas las celdas en el tablero tienen 8 vecinos.  Por ejemplo, la celda superior izquierda no tendrá vecinos a su izquierda, y así sucesivamente. <br><br>  Queda por implementar el método <code>getField</code> y agregar todas las llamadas necesarias al método <code>_create</code> en la clase <code>Board</code> <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public getField(row: number, col: number): Field { return this._fields.find(field =&gt; field.row === row &amp;&amp; field.col === col); } //... private _create(): void { this._createFields(); this._createBombs(); this._createValues(); } //...</span></span></code> </pre><br><a name="section-4"></a><h2> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Manejo de eventos de entrada</font></font></font> </h2><br><a name="section-4-1"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1 Seguimiento de eventos de clic del mouse</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por el momento, el tablero está completamente inicializado, tiene bombas y hay celdas con números, pero todas están cerradas y no hay forma de abrirlas. </font><font style="vertical-align: inherit;">Corregiremos esto e implementaremos la apertura de celdas haciendo clic en el botón izquierdo del mouse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero, necesitamos rastrear este mismo clic. </font><font style="vertical-align: inherit;">En la clase, </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agregue el </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siguiente código </font><font style="vertical-align: inherit;">al final del método </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FielView.ts //... private _create(): void { // ... this.setInteractive(); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En phaser, puede suscribirse a objetos del espacio de nombres para diferentes eventos </font></font><code>Phaser.GameObjects</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. En particular, suscribiremos al evento click ( </font></font><code>pointerdown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) el prefabricado del propio sprite, es decir, un objeto de una clase </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">heredada de </font></font><code>Phaser.GameObjects.Sprite</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero antes de hacer esto, debemos indicar explícitamente que el sprite es potencialmente interactivo, es decir, generalmente necesita escuchar la entrada del usuario sobre él. Debe hacer esto llamando al método </font></font><code>setInteractive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sin parámetros en el propio sprite, lo que hicimos en el ejemplo anterior. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que nuestro sprite se ha vuelto interactivo, volvamos a la clase </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el lugar donde se crean los nuevos objetos modelo </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, es decir, al método </font></font><code>_createFields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y registremos la devolución de llamada para los eventos de entrada para la vista:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _createFields(): void { for (let row = 0; row &lt; this._rows; row++) { for (let col = 0; col &lt; this._cols; col++) { const field = new Field(this._scene, this, row, col) field.view.on('pointerdown', this._onFieldClick.bind(this, field)); this._fields.push(field); } } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una vez que hayamos establecido que al hacer clic en el sprite queremos ejecutar el método </font></font><code>_onFieldClick</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, necesitamos implementarlo. Pero eliminaremos la lógica de procesar el clic de la clase </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Se cree que es mejor procesar el modelo según la entrada y, en consecuencia, cambiar sus datos en un controlador separado, cuya similitud es la clase de la escena del juego </font></font><code>GameScene</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Por lo tanto, debemos reenviar el evento de clic más lejos, desde la clase </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a la escena misma. Entonces haremos:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _onFieldClick(field: Field, pointer: Phaser.Input.Pointer): void { if (pointer.leftButtonDown()) { this.emit(`left-click`, field); } else if (pointer.rightButtonDown()) { this.emit(`right-click`, field); } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquí no solo lanzamos el evento de clic como lo fue, sino que también especificamos qué clic fue. </font><font style="vertical-align: inherit;">Esto será útil en el futuro, cuando en la clase de escena procesaremos cada opción de manera diferente. </font><font style="vertical-align: inherit;">Por supuesto, sería posible enviar el evento de clic tal como está, pero simplificaremos el código de escena, dejando parte de la lógica con respecto al evento en sí en la clase </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bueno, ahora volvamos a la clase de la escena del juego </font></font><code>GameScene</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y agreguemos un </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">código </font><font style="vertical-align: inherit;">al final del método </font><font style="vertical-align: inherit;">que rastrea los eventos de un clic en las celdas:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... import { Field } from "../models/Field"; //... public create(): void { this._board = new Board(this, Rows, Cols, Bombs); this._board.on('left-click', this._onFieldClickLeft, this); this._board.on('right-click', this._onFieldClickRight, this); } private _onFieldClickLeft(field: Field): void { } private _onFieldClickRight(field: Field): void { } //...</span></span></code> </pre><br><a name="section-4-2"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.2. </font><font style="vertical-align: inherit;">Procesamiento de clic izquierdo</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Procedemos a implementar el procesamiento de eventos de clic del mouse. </font><font style="vertical-align: inherit;">Y comience abriendo las celdas. </font><font style="vertical-align: inherit;">Las celdas deben abrirse presionando el botón izquierdo. </font><font style="vertical-align: inherit;">Y antes de comenzar a programar, expresemos las condiciones que deben cumplirse:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Al hacer clic en una celda cerrada, debe abrirse </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> si hay una mina en una celda abierta, el juego se pierde </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> si no hay minas o valores en la celda abierta, entonces min no está en las celdas vecinas, en este caso necesita abrir todas las celdas vecinas y continuar así hasta que el valor aparezca en la celda abierta </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cuando haces clic en una celda abierta, debes verificar si todas las banderas están configuradas correctamente y, de ser así, finalizar el juego con una victoria </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y ahora, para simplificar la comprensión de la funcionalidad requerida, traducimos la lógica anterior en pseudocódigo: </font></font><br><br><pre> <code class="plaintext hljs">                         </code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora tenemos una comprensión de lo que necesita ser programado. </font><font style="vertical-align: inherit;">Implementamos el método </font></font><code>_onFieldClickLeft</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... private _onFieldClickLeft(field: Field): void { if (field.closed) { //    field.open(); //   if (field.mined) { //    field.exploded = true; this._onGameOver(false); //   } else if (field.empty) { //    this._board.openClosestFields(field); //   } } else if (field.opened) { //    if (this._board.completed) { //       this._onGameOver(true); //   } } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y luego, como siempre, finalizaremos las clases </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementaremos los métodos que llamamos en el controlador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indicamos 3 estados posibles de la celda en la enumeración </font></font><code>States</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, agregamos un campo </font></font><code>_state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e implementamos un captador para cada estado posible:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts enum States { Closed = 'closed', Opened = 'opened', Marked = 'flag' }; export class Field extends Phaser.Events.EventEmitter { private _state: string = States.Closed; //... public get marked(): boolean { return this._state === States.Marked; } public get closed(): boolean { return this._state === States.Closed; } public get opened(): boolean { return this._state === States.Opened; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que tenemos estados que indican si la celda está cerrada o no, podemos agregar un método </font></font><code>open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que cambiará el estado:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public open(): void { this._setState(States.Opened); } private _setState(state: string): void { if (this._state !== state) { this._state = state; this.emit('change'); } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada cambio en el estado del modelo debe desencadenar un evento que informa esto. </font><font style="vertical-align: inherit;">Por lo tanto, presentamos un método privado adicional </font></font><code>_setState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el que se implementará toda la lógica del cambio de estado. </font><font style="vertical-align: inherit;">Este método se llamará en todos los métodos públicos del modelo, que deberían cambiar su estado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue una bandera booleana </font></font><code>_exploded</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para indicar explícitamente exactamente el objeto Field que se hizo explotar:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts private _exploded: boolean = false; //... public set exploded(exploded: boolean) { this._exploded = exploded; this.emit('change'); } public get exploded(): boolean { return this._exploded; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora abra la clase </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e implemente el método en ella </font></font><code>openClosestFields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este método es recursivo y su tarea será abrir todos los campos vecinos vacíos en relación con la celda aceptada en el parámetro. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El algoritmo será el siguiente:</font></font><br><br><pre> <code class="plaintext hljs"> :                </code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y esta vez ya tenemos todas las interfaces necesarias para la implementación completa de este método: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public openClosestFields(field: Field): void { field.getClosestFields().forEach(item =&gt; {//     if (item.closed) {//    item.open();//   if (item.empty) {//    this.openClosestFields(item);//     } } }); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue un captador </font></font><code>completed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a la clase </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para indicar la colocación correcta de banderas en el tablero. </font><font style="vertical-align: inherit;">¿Cómo podemos determinar si un tablero se ha limpiado con éxito? </font><font style="vertical-align: inherit;">El número de campos marcados correctamente debe ser igual al número total de bombas en el tablero.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public get completed(): boolean { return this._fields.filter(field =&gt; field.completed).length === this._bombs; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este método filtra la matriz </font></font><code>_fields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por getter </font></font><code>completed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que debe indicar la validez de la marca de campo. </font><font style="vertical-align: inherit;">Si la longitud de la matriz filtrada (en la que solo caen correctamente los campos marcados, de los cuales el captador </font></font><code>completed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ya </font><font style="vertical-align: inherit;">es responsable </font><font style="vertical-align: inherit;">de la clase </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) es igual al valor del campo </font></font><code>_bombs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(es decir, el número de bombas en el tablero), entonces volvemos </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en otras palabras, consideramos que el juego ganó. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tampoco nos importa la oportunidad de abrir todo el tablero con una sola llamada, lo que tenemos que hacer al final del nivel. </font><font style="vertical-align: inherit;">También agregaremos esta característica a la clase </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public open(): void { this._fields.forEach(field =&gt; field.open()); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Queda por agregar un captador </font></font><code>completed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a la clase misma </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">¿En qué caso el campo se considerará borrado con éxito? </font><font style="vertical-align: inherit;">Si está minado y marcado. </font><font style="vertical-align: inherit;">Ambos captadores necesarios ya están allí y podemos agregar este método:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public get completed(): boolean { return this.marked &amp;&amp; this.mined; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para completar el procesamiento del clic izquierdo del mouse, crearemos un método </font></font><code>_onGameOver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el que deshabilitemos el seguimiento de los eventos del tablero y le mostraremos al jugador todo el tablero. </font><font style="vertical-align: inherit;">Más adelante también agregaremos un código de representación del informe de finalización de estado basado en el parámetro </font></font><code>status</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... private _onGameOver(status: boolean) { this._board.off('left-click', this._onFieldClickLeft, this); this._board.off('right-click', this._onFieldClickRight, this); this._board.open(); } //...</span></span></code> </pre><br><a name="section-4-3"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3 Visualización de campo</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de comenzar a procesar el clic derecho, aprenderemos a volver a dibujar las celdas recién abiertas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anteriormente en la clase, </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desarrollamos un método </font></font><code>_setState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que dispara un evento </font></font><code>change</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuando cambia el estado del modelo. Usaremos esto y en la clase </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rastrearemos este evento:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _init(): void { //... this._model.on('change', this._onStateChange, this); } private _onStateChange(): void { this._render(); } private _render(): void { this.setFrame(this._frameName); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Específicamente convertimos el método intermedio en una </font></font><code>_onStateChange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devolución de llamada del evento de cambio de modelo. </font><font style="vertical-align: inherit;">En el futuro, necesitaremos verificar cómo se cambió el modelo para comprender si es necesario realizarlo </font></font><code>_render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para mostrar el sprite actual de una celda en un nuevo estado, debe cambiar su marco. </font><font style="vertical-align: inherit;">Como cargamos el atlas como activos, podemos llamar al método </font></font><code>setFrame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para cambiar el marco actual a uno nuevo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para obtener el marco en una línea, utilizamos astutamente el getter </font></font><code>_frameName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que ahora debe implementarse. </font><font style="vertical-align: inherit;">Primero, describimos todos los valores posibles que puede tomar un marco de celda.</font></font><br><div class="scrollable-table"><table><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Marco </font></font></td><td>  Condición </td></tr><tr><td> <code>closed</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El campo esta cerrado </font></font><br></td></tr><tr><td> <code>flag</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Campo marcado </font></font><br></td></tr><tr><td> <code>empty</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El campo está abierto, no extraído o lleno de valor. </font></font><br></td></tr><tr><td> <code>exploded</code> <br> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> el campo está abierto, explotado y explotado </font></font><br></td></tr><tr><td> <code>mined</code> <br> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> el campo está abierto, minado, pero no explotado </font></font><br></td></tr><tr><td> <code>1...9</code> <br> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> el campo está abierto y muestra un valor del 1 al 9, que indica el número de bombas al lado de este campo </font></font><br></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtuvimos una descripción de todos los estados y ya tenemos todos los métodos del modelo, gracias a los cuales se pueden obtener estos estados. </font><font style="vertical-align: inherit;">Vamos a obtener una pequeña configuración al comienzo del archivo:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts const States = { 'closed': field =&gt; field.closed, 'flag': field =&gt; field.marked, 'empty': field =&gt; field.opened &amp;&amp; !field.mined &amp;&amp; !field.filled, 'exploded': field =&gt; field.opened &amp;&amp; field.mined &amp;&amp; field.exploded, 'mined': field =&gt; field.opened &amp;&amp; field.mined &amp;&amp; !field.exploded } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las claves en este objeto serán los valores de los marcos, y los valores de estas claves son las devoluciones de llamada que devuelven un resultado booleano. </font><font style="vertical-align: inherit;">En base a esta configuración, podemos desarrollar un método para obtener el marco deseado (es decir, la clave de la configuración):</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private get _frameName(): string { for (let key in States) { if (States[key](this._model)) { return key; } } return this._model.value.toString(); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, mediante una simple enumeración en un bucle, revisamos todas las claves del objeto de configuración y llamamos a cada devolución de llamada a su vez. </font><font style="vertical-align: inherit;">La función que nos devuelve primero </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indicará que la clave </font></font><code>key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en la iteración actual es el marco correcto para el estado actual del modelo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si ninguna clave es adecuada, entonces para el estado predeterminado consideraremos un campo abierto con un valor </font></font><code>_value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ya </font></font><code>States</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que no configuramos </font><font style="vertical-align: inherit;">este estado en la configuración </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos probar completamente el clic izquierdo en los campos del tablero y verificar cómo se abren las celdas y qué se muestra después de abrirlas.</font></font><br><br><a name="section-4-4"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.4 Procesamiento de clic derecho</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como en el caso de crear el controlador de clic izquierdo, primero definimos claramente la funcionalidad esperada. </font><font style="vertical-align: inherit;">Al hacer clic derecho, debemos marcar la celda seleccionada con una bandera. </font><font style="vertical-align: inherit;">Pero hay ciertas condiciones.</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Solo se puede marcar un campo cerrado que no está marcado actualmente </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si el campo está marcado, entonces un clic derecho nuevamente eliminará la bandera del campo </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Al configurar / eliminar una bandera, es necesario actualizar el número de banderas disponibles en el nivel y mostrar el texto con el número actual </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Traduciendo estas condiciones en pseudocódigo, obtenemos las siguientes líneas de comentarios: </font></font><br><br><pre> <code class="plaintext hljs">                              </code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora podemos traducir este algoritmo en llamadas a los métodos que necesitamos, incluso si aún no se han desarrollado: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts private _flags: number = 0; //... private _onFieldClickRight(field: Field): void { if (field.closed &amp;&amp; this._flags &gt; 0) { //        field.addFlag(); //     } else if (field.marked) { //     field.removeFlag(); //   } this._flags = Bombs - this._board.countMarked; } //... public create(): void { this._flags = Bombs; //... } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquí también comenzamos un nuevo campo </font></font><code>_flags</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que al comienzo del nivel del juego es igual al número de bombas en el tablero, ya que al comienzo del juego no se ha establecido una sola bandera. </font><font style="vertical-align: inherit;">Este campo está obligado a actualizarse con cada clic derecho, ya que en este caso la bandera se agrega o se elimina del tablero. </font><font style="vertical-align: inherit;">Agrega un </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">captador </font><font style="vertical-align: inherit;">a la clase </font></font><code>countMarked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public get countMarked(): number { return this._fields.filter(field =&gt; field.marked).length; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Establecer y eliminar el indicador es un cambio en el estado del modelo </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por lo que implementamos estos métodos en la clase correspondiente de manera similar al método </font></font><code>open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public addFlag(): void { this._setState(States.Marked); } public removeFlag(): void { this._setState(States.Closed); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Permítame recordarle que </font></font><code>_setState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">activará un evento </font></font><code>change</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que se rastrea en la vista y, por lo tanto, el sprite se volverá a dibujar automáticamente esta vez cuando cambie el modelo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al probar la funcionalidad desarrollada, seguramente encontrará que cada vez que hace clic con el botón derecho del mouse, se abre un menú contextual. </font><font style="vertical-align: inherit;">Agregue el código que deshabilita este comportamiento al constructor de la escena del juego:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... constructor() { super('Game'); //        document.querySelector("canvas").oncontextmenu = e =&gt; e.preventDefault(); } //...</span></span></code> </pre><br><a name="section-4-5"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.5 Objeto GameSceneView</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para mostrar la interfaz de usuario en la escena del juego, crearemos una clase </font></font><code>GameSceneView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y la colocaremos </font></font><code>src/scripts/views/GameSceneView.ts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este caso, actuaremos de una manera diferente a la creación </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y no haremos de esta clase un prefabricado y un heredero </font></font><code>GameObjects</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este caso, necesitamos generar los siguientes elementos desde la vista de escena:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> texto en el número de banderas </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> botón de salida </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mensaje de estado de finalización del juego (ganar / perder) </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hagamos que cada elemento de la IU sea un campo separado en la clase </font></font><code>GameSceneView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos a preparar un trozo.</font></font><br><br><pre> <code class="javascript hljs">enum Styles { Color = <span class="hljs-string"><span class="hljs-string">'#008080'</span></span>, Font = <span class="hljs-string"><span class="hljs-string">'Arial'</span></span> } enum Texts { Flags = <span class="hljs-string"><span class="hljs-string">'FLAGS: '</span></span>, Exit = <span class="hljs-string"><span class="hljs-string">'EXIT'</span></span>, Success = <span class="hljs-string"><span class="hljs-string">'YOU WIN!'</span></span>, Failure = <span class="hljs-string"><span class="hljs-string">'YOU LOOSE'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameSceneView</span></span></span><span class="hljs-class"> </span></span>{ private _scene: Phaser.Scene = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _style: {<span class="hljs-attr"><span class="hljs-attr">font</span></span>: string, <span class="hljs-attr"><span class="hljs-attr">fill</span></span>: string}; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._style = {<span class="hljs-attr"><span class="hljs-attr">font</span></span>: <span class="hljs-string"><span class="hljs-string">`28px </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${Styles.Font}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-attr"><span class="hljs-attr">fill</span></span>: Styles.Color}; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._create(); } private _create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } public render() { } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agregue texto con el número de banderas. </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _txtFlags: Phaser.GameObjects.Text = null; //... private _createTxtFlags(): void { this._txtFlags = this._scene.add.text( 50, 50, Texts.Flags, this._style ).setOrigin(0, 1); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este código colocará el texto que necesitamos en una posición con sangría de 50 px desde los lados superior e izquierdo y lo configurará al estilo especificado. </font><font style="vertical-align: inherit;">Además, el método </font></font><code>setOrigin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">establece el punto de pivote del texto en las coordenadas (0, 1). </font><font style="vertical-align: inherit;">Esto significa que el texto se alineará con su borde izquierdo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agrega un mensaje de estado.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _txtStatus: Phaser.GameObjects.Text = null; //... private _createTxtStatus(): void { this._txtStatus = this._scene.add.text( this._scene.cameras.main.centerX, 50, Texts.Success, this._style ).setOrigin(0.5, 1); this._txtStatus.visible = false; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colocamos el texto de estado en el centro de la pantalla y lo alineamos con el centro de la línea llamando </font></font><code>setOrigin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al parámetro 0.5 para la coordenada x. </font><font style="vertical-align: inherit;">Además, de manera predeterminada, este texto debe estar oculto, ya que solo lo mostraremos al finalizar el juego. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cree un botón de salida, que en esencia es también un objeto de texto.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _btnExit: Phaser.GameObjects.Text = null; //... private _createBtnExit(): void { this._btnExit = this._scene.add.text( this._scene.cameras.main.width - 50, 50, Texts.Exit, this._style ).setOrigin(1); this._btnExit.setInteractive(); this._btnExit.once('pointerdown', () =&gt; { this._scene.scene.start('Start'); }); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ponemos el botón en la esquina superior derecha de la pantalla y lo usamos nuevamente </font></font><code>setOrigin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para alinear el texto esta vez con su borde derecho. </font><font style="vertical-align: inherit;">Hacemos que el botón sea interactivo y agregamos una devolución de llamada al evento de clic, que envía al jugador a la escena inicial. </font><font style="vertical-align: inherit;">Por lo tanto, le damos al jugador la oportunidad de salir del nivel en cualquier momento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Queda por desarrollar un método </font></font><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para actualizar correctamente todos los elementos de la interfaz de usuario y agregar llamadas a todos los métodos creados en </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _create(): void { this._createTxtFlags(); this._createTxtStatus(); this._createBtnExit(); } public render(data: {flags?: number, status?: boolean}) { if (typeof data.flags !== 'undefined') { this._txtFlags.text = Texts.Flags + data.flags.toString(); } if (typeof data.status !== 'undefined') { this._txtStatus.text = data.status ? Texts.Success : Texts.Failure; this._txtStatus.visible = true; } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dependiendo de la propiedad pasada en el parámetro, actualizamos la IU, mostrando los cambios necesarios. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cree una representación en la escena del juego en la clase GameScene y escriba la llamada al método _render siempre que sea necesario con el significado:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... import { GameSceneView } from "../views/GameSceneView"; //... export class GameScene extends Phaser.Scene { private _view: GameSceneView = null; //... private _onGameOver(status: boolean) { //... this._view.render({status}); } //... private _onFieldClickRight(field: Field): void { //... this._flags = Bombs - this._board.countMarked; this._view.render({flags: this._flags}); } //... public create(): void { //... this._view = new GameSceneView(this); this._view.render({flags: this._flags}); } //... }</span></span></code> </pre><br><a name="section-5"></a><h2> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Animaciones</font></font></font> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué tipo de fanático de crear un juego, incluso tan simple como el nuestro, si no hay animaciones en él? </font><font style="vertical-align: inherit;">Además, desde que comenzamos a estudiar el phaser, conozcamos las características más básicas de las animaciones y consideremos la funcionalidad de los gemelos. </font><font style="vertical-align: inherit;">Los gemelos se implementan en el marco mismo y no se requieren bibliotecas de terceros. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue 2 animaciones al juego: llenando el tablero con celdas al comienzo y volteando la celda en la apertura. </font><font style="vertical-align: inherit;">Comencemos con el primero de estos.</font></font><br><br><a name="section-5-1"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.1 Animación de relleno de tablero</font></font></font> </h3><br><img src="https://habrastorage.org/webt/7r/uu/1v/7ruu1vtppaw26sp-fapxbahgm9q.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos aseguramos de que todas las celdas del tablero vuelen en su lugar desde el borde superior izquierdo de la pantalla. </font><font style="vertical-align: inherit;">Al comenzar el nivel del juego, debemos mover todas las celdas a la esquina superior izquierda de la pantalla y para que cada celda comience la animación del movimiento a sus coordenadas correspondientes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la clase, </font></font><code>FiledView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agregue la </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">llamada </font><font style="vertical-align: inherit;">al final de los métodos </font></font><code>_animateShow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _create(): void { //... this._animateShow(); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B implementamos el nuevo método que necesitamos. </font><font style="vertical-align: inherit;">En él, como acordamos anteriormente, es necesario realizar 2 cosas:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mueva la celda detrás de la esquina superior izquierda para que no sea visible en la pantalla </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> iniciar el movimiento gemelo a las coordenadas deseadas con el retraso correcto </font></font></li></ol><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _animateShow(): Promise&lt;void&gt; { this.x = -this.width; this.y = -this.height; const delay = this._model.row * 50 + this._model.col * 10; return this._moveTo(this._position, delay); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que la esquina superior izquierda del lienzo tiene coordenadas (0, 0), si configuramos la celda con las coordenadas iguales a sus valores negativos de ancho y alto, esto colocará la celda detrás de la esquina superior izquierda y la ocultará de la pantalla. </font><font style="vertical-align: inherit;">Por lo tanto, completamos nuestra primera tarea. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alcanzarás el segundo objetivo llamando al método </font></font><code>_moveTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _moveTo(position: Vec2, delay: number): Promise&lt;void&gt; { return new Promise(resolve =&gt; { this.scene.tweens.add({ targets: this, x: position.x, y: position.y, duration: 600, ease: 'Elastic', easeParams: [1, 1], delay, onComplete: () =&gt; { resolve(); } }); }); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para crear una animación, usamos la propiedad de escena </font></font><code>tweens</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En su método, </font></font><code>add</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pasamos el objeto de configuración con la configuración:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La propiedad </font></font><code>targets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí debe contener como valor aquellos objetos del juego a los que desea aplicar efectos de animación. </font><font style="vertical-align: inherit;">En nuestro caso, este es un enlace </font></font><code>this</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al objeto actual, ya que es un prefabricado del sprite.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El segundo y tercer parámetro pasamos las coordenadas del destino. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La propiedad </font></font><code>duration</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es responsable de la duración de la animación, en nuestro caso, 600 ms.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parámetros </font></font><code>ease</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>easeParams</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">establecer la función de relajación.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el campo de retraso, sustituimos el valor del segundo argumento, que se genera para cada celda individual, teniendo en cuenta su posición en el tablero. </font><font style="vertical-align: inherit;">Esto se hace para que las células no salgan volando al mismo tiempo. </font><font style="vertical-align: inherit;">En cambio, cada celda aparecerá con un ligero retraso en relación con la anterior.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, </font></font><code>onComplete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">colocamos una devolución </font><font style="vertical-align: inherit;">de </font><font style="vertical-align: inherit;">llamada </font><font style="vertical-align: inherit;">en la propiedad </font><font style="vertical-align: inherit;">, que se llamará al final de la acción de interpolación.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es razonable envolver al gemelo en una promesa para que en el futuro pueda acoplar maravillosamente diferentes animaciones, por lo que colocaremos una llamada a la función en la devolución de llamada que </font></font><code>resolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indica la ejecución exitosa de la animación.</font></font><br><br><a name="section-5-2"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2 Animaciones de volteo de celda</font></font></font> </h3><br><img src="https://habrastorage.org/webt/uc/d-/yw/ucd-yw-nq6a4veixb-npp0mdyqy.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Será genial si, cuando se abrió la celda, se reprodujo el efecto de su inversión. ¿Cómo podemos lograr esto? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La apertura de una celda se realiza actualmente cambiando el marco cuando se llama al método </font></font><code>_render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en la vista. Si verificamos el estado del modelo en este método, veremos si la celda estaba abierta. Si la celda estaba abierta, inicie la animación en lugar de mostrar instantáneamente un nuevo marco de inversión.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _onStateChange(): void { if (this._model.opened) { this._animateFlip(); } else { this._render(); } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para obtener el efecto deseado, utilizaremos la transformación del sprite a través de la propiedad </font></font><code>scale</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si escalamos el sprite a lo largo del eje </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a cero </font><font style="vertical-align: inherit;">con el tiempo </font><font style="vertical-align: inherit;">, eventualmente se reducirá, conectando los lados izquierdo y derecho. </font><font style="vertical-align: inherit;">Y viceversa, si escala el sprite a lo largo del eje </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de cero a su ancho completo, lo estiramos a su tamaño completo. </font><font style="vertical-align: inherit;">Implementamos esta lógica en el método </font></font><code>_animateFlip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _animateFlip(): void { this._scaleXTo(0).then(() =&gt; { this._render(); this._scaleXTo(1); }) } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por analogía con el método, </font></font><code>_moveTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementamos </font></font><code>_scaleTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _scaleXTo(scaleX: number): Promise&lt;void&gt; { return new Promise(resolve =&gt; { this.scene.tweens.add({ targets: this, scaleX, ease: 'Elastic.easeInOut', easeParams: [1, 1], duration: 150, onComplete: () =&gt; { resolve() } }); }); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este método, como parámetro, tomamos el valor de la escala, que usaremos para cambiar el tamaño del sprite en ambas direcciones y pasarlo como un segundo parámetro al objeto de configuración de animación. </font><font style="vertical-align: inherit;">Todos los demás parámetros de configuración ya nos son familiares de la animación anterior. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¡Ahora comenzaremos el proyecto para probar y después de la depuración consideraremos que nuestro juego está completo y la tarea de prueba completada!</font></font> :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¡Agradezco sinceramente a todos por haber llegado a este momento conmigo! </font></font><br><br><h2>  Conclusión </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colegas, me alegraría mucho si el material presentado en el artículo les resulta útil y pueden utilizar estos o los enfoques descritos en sus propios proyectos. Siempre puede recurrir a mí con cualquier pregunta, tanto en este artículo como en la programación por fases o trabajar en gamedev en general. ¡Agradezco la comunicación y me alegrará hacer nuevos conocidos e intercambiar experiencias! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y tengo una pregunta para ti ahora mismo. Como estoy creando video tutoriales sobre el desarrollo de juegos, naturalmente acumulé una docena de estos pequeños juegos. Cada juego abre el marco a su manera. Por ejemplo, en este juego tocamos el tema de los gemelos, pero hay muchas otras características, como física, mapa de mosaicos, columna vertebral, etc.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A este respecto, la pregunta es: ¿te gustó este artículo y, de ser así, te interesaría seguir leyendo artículos como este, pero sobre otros pequeños juegos clásicos? </font><font style="vertical-align: inherit;">Si la respuesta es sí, con mucho gusto traduciré los materiales de mis videos tutoriales a formato de texto y continuaré publicando nuevos manuales con el tiempo, pero para otros juegos. </font><font style="vertical-align: inherit;">Traigo la encuesta correspondiente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¡Gracias a todos por su atención! </font><font style="vertical-align: inherit;">Estaré encantado de recibir comentarios y hasta pronto!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/476682/">https://habr.com/ru/post/476682/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../476670/index.html">Descripción general de CAD en el núcleo geométrico C3D - 2</a></li>
<li><a href="../476674/index.html">Implementación rápida de ReportPortal para familiarización</a></li>
<li><a href="../476676/index.html">48 recursos de código abierto para JavaScript (2019)</a></li>
<li><a href="../476678/index.html">API para recuperación asíncrona remota utilizando Apple Combine</a></li>
<li><a href="../476680/index.html">El sistema de planificación de producción continua de Rodov es el Lean / MRP soviético de 1961. Despegue, puesta de sol y nuevo nacimiento</a></li>
<li><a href="../476686/index.html">Desarrollo de una puerta de enlace IoT basada en Raspberry CM3 +</a></li>
<li><a href="../476688/index.html">Nuevo curso de OTUS. "Desarrollador IOS. Curso avanzado V 2.0 »</a></li>
<li><a href="../476692/index.html">Principios de marketing de contenidos</a></li>
<li><a href="../476694/index.html">Sobre la robotización empresarial con Farida Roslovets y directora de la empresa RPA electroNeek</a></li>
<li><a href="../476696/index.html">Cómo crear e implementar una aplicación Full-Stack React</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>