<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÆ üòµ üö§ Exibi√ß√µes do modo gr√°fico e de texto Winstar ü•• ü§π üõ∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Os displays gr√°ficos, incluindo os do tipo OLED, mais representados em nosso mercado pela Winstar, t√™m uma demanda muito menor em rela√ß√£o √†s min√∫scula...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Exibi√ß√µes do modo gr√°fico e de texto Winstar</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/402517/"> Os displays gr√°ficos, incluindo os do tipo OLED, mais representados em nosso mercado pela Winstar, t√™m uma demanda muito menor em rela√ß√£o √†s min√∫sculas e as publica√ß√µes sobre seu uso tamb√©m s√£o muito menores.  Enquanto isso, s√£o os displays gr√°ficos OLED que, devido √† falta de liga√ß√£o √†s tabelas de fontes de um padr√£o predefinido, fornecem a melhor maneira de obter dispositivos de exibi√ß√£o ergon√¥micos para uma ampla variedade de necessidades.  Al√©m disso, o modo gr√°fico no controlador WS0010 √© mais f√°cil de iniciar e funciona mais est√°vel que o modo texto. <br><br>  Antes de prosseguirmos com a considera√ß√£o das exibi√ß√µes gr√°ficas reais, consideraremos o problema permanente com os problemas de ativa√ß√£o do modo de texto do controlador WS0010, que recebeu uma solu√ß√£o inesperada e √≥bvia (ah, onde estavam meus olhos!). <br><a name="habracut"></a><br><h3>  Resolvendo problemas do modo de texto WS0010 </h3><br>  √â sabido que os displays da linha Winstar apresentam problemas de estabilidade durante a inicializa√ß√£o.  A prop√≥sito, descobriu-se que isso n√£o era exclusivo dos ‚Äúmalditos chineses‚Äù: as amostras do Newhaven Display 16x2, que obtive com grande dificuldade, localizadas no outro lado do globo, s√£o externamente uma c√≥pia completa do Winstar, exceto a localiza√ß√£o de algumas inscri√ß√µes e o nome da empresa na mancha ( a mesma forma e fonte): <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/5c4/0e4/db8/5c40e4db8577cfcdacad5ecdf2652606.jpg" width="600" alt="imagem"><br><br>  Contendo, como est√° escrito nas fichas t√©cnicas, um determinado controlador "compar√°vel ao LCD", esses monitores se comportam completamente id√™nticos aos chineses e t√™m as mesmas desvantagens.  Obviamente, voc√™ n√£o deve perder tempo verificando outras empresas, como a Midas: a julgar por esta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">publica√ß√£o</a> , n√£o poderia prescindir da coopera√ß√£o internacional.  A economia globalizada rulez! <br><br>  As dificuldades do modo de texto s√£o expressas no fato de que, quando voc√™ inicia (por exemplo, quando voc√™ reinicia ou reinicia manualmente o programa do controlador de controle), o lixo pode aparecer nos visores e as linhas 0 e 1 mudam de lugar aleatoriamente.  Os experimentos mostraram que ele n√£o depende do m√©todo de inclus√£o (8 ou 4 bits).  Esse problema √© especialmente grave quando reinicializa√ß√µes peri√≥dicas de software s√£o necess√°rias, por exemplo, pelo Watchdog-timer. <br><br>  Parte do problema √© uma atitude clara em rela√ß√£o √† energia (de uma fonte separada e de maneira alguma do USB Arduino) e uma reinicializa√ß√£o separada, desligando e ligando a tela depois de iniciar o programa de controle (consulte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">publica√ß√£o anterior</a> do autor).  Como se viu, o autor dessas linhas n√£o foi o √∫nico que prop√¥s uma solu√ß√£o semelhante para o problema: o autor do complemento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LuquidCrystal</a> chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">WinstarOLED</a> tamb√©m incluiu um pw_pin especial nele, com o qual a pot√™ncia da tela √© distorcida no momento em que o programa √© iniciado. <br><br>  Mas isso √© tudo, √© claro, iniciativa e meias medidas.  Algu√©m SeregaB se deparou com um caminho radical (veja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sua publica√ß√£o</a> em easyelectronics.ru - obrigado a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tomasina</a> pela dica).  De fato, ele colocou uma tarefa completamente diferente: aprender a trabalhar apenas com o modo gr√°fico, em vez de texto.  Tentando alternar entre os modos, ele rapidamente descobriu que " <i>mudar para o modo gr√°fico era normal e do gr√°fico para o" texto "- muito desajeitado</i> ".  Ent√£o ele lembrou que ‚Äú <i>uma vez, h√° muito tempo, quando DShs ainda eram impressos em papel, em alguns DShs no HD44780 eu li que os modos de altern√¢ncia s√≥ deveriam ser feitos quando a tela estava desligada</i> ‚Äù.  E funcionou. <br><br>  A partir da publica√ß√£o citada, simplesmente reproduzirei dois procedimentos de comuta√ß√£o aqui, adaptando-os levemente para uso com LuquidCrystal (a inst√¢ncia de classe √© chamada OLED1 aqui). <br><br>  Alterne para o modo gr√°fico: <br><pre><code class="hljs cmake">OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x08);//  OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x1F);//   OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x01);//    (..  clear()) OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x08|<span class="hljs-number"><span class="hljs-number">0</span></span>x04);// </code> </pre> <br>  Alterne para o modo de texto: <br><pre> <code class="hljs cmake"> OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x08);//  OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x17);//    OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x01);//    (..  clear()) OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x04 | <span class="hljs-number"><span class="hljs-number">0</span></span>x08);// </code> </pre> <br>  Como veremos mais adiante, o primeiro procedimento n√£o √© realmente necess√°rio: o WS0010 alterna para o modo gr√°fico a partir de um meio chute, basta enviar o comando 0x1F para ele.  Mas a segunda sequ√™ncia de comandos foi bem o caso.  Para a amostra, ela foi inclu√≠da diretamente no esbo√ßo usando o LuquidCrystal neste formul√°rio: <br><pre> <code class="hljs ruby">void reset_textmode() /<span class="hljs-regexp"><span class="hljs-regexp">/     { OLED1.command(0x08);/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  OLED1.command(0x17);/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    OLED1.command(0x01);/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    OLED1.command(0x04 | 0x08);/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  }</span></span></code> </pre> <br>  Em seguida, essa fun√ß√£o foi chamada na configura√ß√£o logo ap√≥s o in√≠cio da biblioteca: <br><br><pre> <code class="hljs ruby"> . . . . . OLED1.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">16</span></span>  <span class="hljs-number"><span class="hljs-number">2</span></span>  reset_textmode(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  clear() . . . . .</code> </pre> <br>  Se voc√™ inserir algum atraso (500) antes disso, a demonstra√ß√£o ser√° muito √≥bvia: depois de pressionar o bot√£o de reset da placa Arduino na tela, como de costume, o lixo aparece, mas apenas por um momento: depois que a fun√ß√£o √© acionada, a tela √© limpa e todas as linhas voltam ao lugar . <br><br>  A fun√ß√£o funciona assim, mas por conveni√™ncia, substitu√≠ o conte√∫do da fun√ß√£o LiquidCrystalRus :: clear () no arquivo da biblioteca LiquidCrystalRus_OLED.cpp atualizada que foi discutida anteriormente com esta sequ√™ncia de comandos (lembre-se de que <a href="">voc√™ pode baix√°-lo</a> no site do autor).  N√£o h√° espera para que o comando seja executado na biblioteca, portanto, para confiabilidade, ap√≥s cada comando, existem atrasos de 100 ¬µs inseridos no estilo geral da biblioteca.  Nos esbo√ßos que usam esta variante do LiquidCrystalRus_OLED, no in√≠cio da instala√ß√£o, √© necess√°rio chamar a fun√ß√£o clear () e, ao mesmo tempo, limpar a tela. <br><div class="spoiler">  <b class="spoiler_title">Nota</b> <div class="spoiler_text">  H√° um problema com a limpeza da tela: na folha de dados da tabela de comandos, observe que o comando 0x01 pode durar at√© 6,2 ms ‚Äúquando fsp ou fosc = 250KHz‚Äù.  Que tipo de ‚Äúfsp ou fosc‚Äù √© realmente em controladores espec√≠ficos, eles eram muito pregui√ßosos para escrever, mas em qualquer caso, mesmo que seja megahertz, o atraso para esse comando deve ser significativo (e o autor do LiquidCrystal menciona isso).  No entanto, na pr√°tica, verifica-se que a equipe de limpeza trabalha por conta pr√≥pria se n√£o houver atraso algum.  Ent√£o eu n√£o entendi, mas agi de acordo com a conhecida regra de programa√ß√£o: "funciona - n√£o toque!". <br></div></div><br>  Agora vamos finalmente lidar com o modo gr√°fico. <br><br><h3>  O modo gr√°fico em texto exibe WEH001602 </h3><br>  Para come√ßar, tentei mudar a exibi√ß√£o de texto que tinha WEH001602BG para o modo gr√°fico.  Observe que as telas gr√°ficas de 100x16 e texto (configura√ß√£o 20x2, 16x2 possuem menos pontos horizontais) t√™m matrizes id√™nticas, apenas as exibi√ß√µes de texto s√£o separadas por intervalos de familiaridade.  Isso limita severamente o uso do modo de gr√°ficos nas exibi√ß√µes de texto e ainda mais no modo de texto nos gr√°ficos.  Mas para testar como funciona, voc√™ pode usar qualquer um deles. <br><br>  O monitor, juntamente com o DS1307, foi conectado ao Arduino Nano, de acordo com o seguinte esquema: <br><img src="https://habrastorage.org/getpro/geektimes/post_images/606/8e2/216/6068e2216b082857a72cd76f322628e3.png" width="600" alt="imagem"><br><br>  De acordo com o mesmo esquema, conectaremos displays gr√°ficos no futuro.  A cor cinza no diagrama mostra a conex√£o do segundo monitor, se necess√°rio. <br><br>  Para alternar para o modo gr√°fico, voc√™ pode usar o procedimento aprimorado da se√ß√£o anterior, mas uma fun√ß√£o simples de um √∫nico comando funciona: <br><pre> <code class="hljs cs">. . . . . <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LCD_SETGRAPHICMODE 0x1f LiquidCrystal lcd(9, 4, 8, 7, 6, 5); void setGraphicMode(){ lcd.command(LCD_SETGRAPHICMODE); } . . . . .</span></span></code> </pre> <br>  N√£o precisamos de nenhuma tabela russa aqui; portanto, √© usado o LiquidCrystal padr√£o (n√£o endireitado), que funciona perfeitamente no modo gr√°fico.  Para n√£o mexer na depura√ß√£o de todas as op√ß√µes da biblioteca, no caso em que as exibi√ß√µes gr√°fica e de texto s√£o inclu√≠das em paralelo, ent√£o para cada uma delas eu uso minha pr√≥pria biblioteca (para texto atualizado Rus_OLED, para normal gr√°fica).  Nesse caso, a conex√£o ainda pode ser feita nas mesmas pernas do controlador, com exce√ß√£o dos pinos de sa√≠da E, de acordo com o diagrama acima. <br><br>  Al√©m disso, usei parcialmente as conquistas do autor da biblioteca WinstarOLED mencionada (por si s√≥, este complemento para LuquidCrystal √©, na minha opini√£o, incompleto e n√£o √© pr√°tico us√°-lo como).  Ele introduziu uma fun√ß√£o conveniente para definir o cursor gr√°fico (o erro original referente ao valor m√°ximo de <i>x</i> foi corrigido aqui): <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setGraphicCursor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= x &amp;&amp; x &lt;= <span class="hljs-number"><span class="hljs-number">99</span></span> ){ lcd.command(LCD_SETDDRAMADDR | x); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= y &amp;&amp; y &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ){ lcd.command(LCD_SETCGRAMADDR | y); } }</code> </pre> <br>  A constante LCD_SETDDRAMADDR √© definida na biblioteca LiquidCrystal.  Uma exibi√ß√£o de 100x16, como uma exibi√ß√£o de texto, √© dividida em duas linhas, 0 e 1, porque <i>y</i> pode receber apenas dois valores aqui.  E a coordenada horizontal <i>x</i> varia de 0 a 99. Um byte √© enviado com o comando lcd.write (), cujos bits individuais determinam as posi√ß√µes luminosas da linha vertical com um comprimento de 8 pontos.  A posi√ß√£o mais √† esquerda na linha superior tem coordenadas 0,0, a mais √† direita na parte inferior - 99,1.  Al√©m disso, o ponto mais baixo corresponder√° ao bit menos significativo e o ponto mais baixo - o mais alto. <br><br>  Para a conveni√™ncia de codificar imagens, desenhei uma placa na qual voc√™ pode criar rapidamente o c√≥digo desejado manualmente.  Para tabelas de fontes completas, √© claro, √© aconselh√°vel usar editores especiais (dos quais existem pelo menos um milh√£o de graus diferentes de atividade amadora), mas 10 d√≠gitos com a ordem de bits desejada s√£o mais r√°pidos para processar manualmente, especialmente porque as fontes criadas automaticamente ainda precisam ser finalizadas manualmente.  De acordo com o acima, um glifo, por exemplo, a fonte n√∫mero 2 10x16 ser√° codificado da seguinte maneira: <br><br><img src="http://revich.lib.ru/AVR/TableCod2.png" width="400" alt="imagem"><br><br>  Tudo isso √© escrito em uma matriz bidimensional do formul√°rio: <br><pre> <code class="hljs markdown">const byte Data2[<span class="hljs-string"><span class="hljs-string">2</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">10</span></span>]={{0x06,0x07,0x03,0x03,0x03,0x83,0xc3,0x63,0x3f,0x1e}, {0xf0,0xf8,0xcc,0xc6,0xc3,0xc1,0xc0,0xc0,0xc0,0xc0}};</code> </pre> <br>  Para cada d√≠gito de 0 a 9, √© criada uma matriz separada: Dados0, Dados1, Dados2 e assim por diante.  Para rel√≥gios, al√©m de n√∫meros, voc√™ tamb√©m precisar√° de um ponto duplo.  Pode ser reduzido: <br><pre> <code class="hljs markdown">const byte DataDP[<span class="hljs-string"><span class="hljs-string">2</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">2</span></span>]={{0x70,0x70}, {0x1c,0x1c}};// </code> </pre> <br>  Como o controlador n√£o sabe "piscar" no modo gr√°fico, √© necess√°rio piscar programaticamente os dois pontos.  Voc√™ pode extinguir um ponto duplo simplesmente exibindo zeros nas posi√ß√µes correspondentes, mas por uniformidade, criei uma matriz separada <br><pre> <code class="hljs markdown">const byte DataDPclr[<span class="hljs-string"><span class="hljs-string">2</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">2</span></span>]={{0x00,0x00}, {0x00,0x00}};// . </code> </pre> <br>  Para exibir cada d√≠gito e separadamente para um ponto duplo, uma fun√ß√£o separada √© gravada: <br><pre> <code class="hljs powershell">void draw2 (byte x/* */) // ‚Äú<span class="hljs-number"><span class="hljs-number">2</span></span>‚Äù { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">10</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); lcd.write(<span class="hljs-keyword"><span class="hljs-keyword">Data</span></span>2[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); lcd.write(<span class="hljs-keyword"><span class="hljs-keyword">Data</span></span>2[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]);} }</code> </pre> <br>  Todas as fun√ß√µes s√£o iguais, mas usam matrizes diferentes e, para um ponto duplo, outros limites do loop tamb√©m s√£o usados.  Acabou n√£o sendo muito econ√¥mico em termos de quantidade de c√≥digo (veja mais sobre isso mais adiante), mas √© claro e f√°cil corrigir erros.  As lacunas entre os caracteres s√£o levadas em considera√ß√£o no est√°gio de sa√≠da, indicando a posi√ß√£o correspondente (a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">biblioteca RTClib</a> √© usada para ler o rel√≥gio): <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>() { DateTime clock = RTC.now(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clock.second()!=old_second) { uint8_t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>=clock.hour()/<span class="hljs-number"><span class="hljs-number">10</span></span>; //  drawValPos(<span class="hljs-keyword"><span class="hljs-keyword">values</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>=clock.hour()%<span class="hljs-number"><span class="hljs-number">10</span></span>; //  drawValPos(<span class="hljs-keyword"><span class="hljs-keyword">values</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>=clock.minute()/<span class="hljs-number"><span class="hljs-number">10</span></span>; //  drawValPos(<span class="hljs-keyword"><span class="hljs-keyword">values</span></span>,<span class="hljs-number"><span class="hljs-number">28</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>=clock.minute()%<span class="hljs-number"><span class="hljs-number">10</span></span>; //<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>   drawValPos(<span class="hljs-keyword"><span class="hljs-keyword">values</span></span>,<span class="hljs-number"><span class="hljs-number">40</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clock.second()%<span class="hljs-number"><span class="hljs-number">2</span></span>) drawDP(<span class="hljs-number"><span class="hljs-number">24</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> drawDPclr(<span class="hljs-number"><span class="hljs-number">24</span></span>); old_second=clock.second(); }//<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> clocksecond }</code> </pre> <br>  Dez d√≠gitos de 20 bytes cada ocupar√£o 200 bytes na mem√≥ria - cerca de 10% do seu volume (e a fonte larga √© 16x16, como no exemplo abaixo, e todos os 16%).  Uma fonte monol√≠ngue completa desse tamanho, juntamente com n√∫meros, sem levar em considera√ß√£o todos os tipos de sinais de pontua√ß√£o e especiais.  caracteres, cont√©m 62 (ingl√™s) a 74 (russo sem E), o valor ocupar√° quase metade da RAM do ATmega328.  Portanto, truques com matrizes e fun√ß√µes de sa√≠da separadamente para cada caractere ter√£o que ser cancelados e fazer conforme o esperado.  Ou seja, as fontes devem ser deixadas na mem√≥ria do programa e baixadas via PROGMEM, e todos os padr√µes de glifos devem ser organizados como uma √∫nica matriz de fontes e carregados para sa√≠da pelo n√∫mero de s√≠mbolo em uma √∫nica tabela.  Caso contr√°rio, n√£o haver√° mem√≥ria suficiente e o c√≥digo do programa aumentar√° para um volume incontrol√°vel.  Aqui n√£o vamos nos debru√ßar sobre isso, porque em nossos exemplos simples tudo isso n√£o √© necess√°rio - a cada vez estaremos limitados a um pequeno n√∫mero estritamente necess√°rio de caracteres. <br><br>  Devido ao tamanho grande do texto completo do esbo√ßo GraphicOLED_DC1307, n√£o o trago; voc√™ pode fazer o download <a href="">aqui</a> .  A fun√ß√£o resetOLED √© salva no texto, o que distorce a energia da tela quando o controlador √© reinicializado (via pwrPin D2), mas nunca foi necess√°rio, para que possa ser removido com seguran√ßa.  O resultado do programa √© mostrado na foto: <br><br><img src="http://revich.lib.ru/AVR/WEH1602_clock.jpg" width="600" alt="imagem"><br><br>  Infelizmente, a perman√™ncia simult√¢nea no modo de texto e gr√°fico √© exclu√≠da; portanto, se voc√™ quiser usar o espa√ßo restante, precisar√° desenhar suas pr√≥prias fontes (resta espa√ßo para cerca de 7 caracteres da fonte 5x7 em cada linha). <br><br><h3>  Tela gr√°fica WEG010016A </h3><br>  Quando finalmente chegaram as telas gr√°ficas ordenadas WEG010016AL, comecei tentando inseri-las no modo de texto para ver o que acontecia. <br><br>  Para verificar o modo de texto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">,</a> foi baixado um programa para simular um mostrador de rel√≥gio do calend√°rio com um sensor de temperatura externo, descrito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em uma publica√ß√£o anterior</a> .  O resultado me fez lembrar que diferentes telas do Winstar podem ser orientadas de maneira diferente em rela√ß√£o ao conector (neste caso, o WEG010016A possui um conector na parte superior, para o texto WEH001602B, que usamos acima, na parte inferior, e para o tipo C ao lado): <br><br><img src="http://revich.lib.ru/AVR/WEG10016_test.jpg" width="600" alt="imagem"><br><br>  Abordaremos ainda mais a orienta√ß√£o da exibi√ß√£o, mas, por enquanto, veremos o que aconteceu.  Mas acabou nada de bom: o modo de texto (√© claro, equipado com uma muleta, que foi discutida no come√ßo do artigo) funciona perfeitamente, mas na pr√°tica n√£o faz sentido devido √† falta de espa√ßo entre os personagens.  Portanto, n√£o vamos nos demorar, mas proceda √† considera√ß√£o do modo gr√°fico. <br><br>  Os procedimentos de instala√ß√£o no modo gr√°fico s√£o os mesmos que foram discutidos acima para a vers√£o em texto.  Resta lidar com a invers√£o da tela, se houver um conector na parte superior da tela.  Claro, voc√™ pode simplesmente virar a tela, mas a posi√ß√£o com o conector voltado para baixo me parece mais natural e conveniente.  Al√©m disso, ao usar um tipo com um conector na lateral, pode ser necess√°rio orientar o conector para a direita e n√£o para a esquerda.  Para a orienta√ß√£o ‚Äúde cabe√ßa para baixo‚Äù, √© necess√°rio transformar a imagem - isto √©, trocar a primeira e a √∫ltima posi√ß√£o horizontal, linhas e tamb√©m inverter a ordem dos bits nos bytes que comp√µem a matriz (o bit menos significativo corresponder√° ao ponto inferior). <br><br>  Como eu j√° havia pintado dez d√≠gitos no caso anterior, para a √∫ltima tarefa, restava introduzir o procedimento de revers√£o do programa: <br><pre> <code class="hljs matlab">byte reverse(byte x) { byte result=<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>)) { result |= <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">7</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  Voc√™ pode alterar a ordem das coordenadas horizontais e das linhas verticais fazendo altera√ß√µes na fun√ß√£o setGraphicCursor: <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setGraphicCursor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= x &amp;&amp; x &lt;= <span class="hljs-number"><span class="hljs-number">99</span></span> ){ lcd.command(LCD_SETDDRAMADDR | (<span class="hljs-number"><span class="hljs-number">99</span></span>-x)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= y &amp;&amp; y &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ){ lcd.command(LCD_SETCGRAMADDR | (<span class="hljs-number"><span class="hljs-number">1</span></span>-y)); } }</code> </pre> <br>  As fun√ß√µes de sa√≠da da matriz de cada d√≠gito permanecem as mesmas, apenas a invers√£o de bits √© adicionada: <br><pre> <code class="hljs powershell">void draw2 (byte x/* */) // <span class="hljs-number"><span class="hljs-number">2</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">10</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); byte b=reverse(<span class="hljs-keyword"><span class="hljs-keyword">Data</span></span>2[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]); lcd.write(b); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); b=reverse(<span class="hljs-keyword"><span class="hljs-keyword">Data</span></span>2[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]); lcd.write(b);} }</code> </pre> <br>  O esbo√ßo completo da sa√≠da do rel√≥gio GraphicOLED_DC1307_100x16 pode ser baixado <a href="">aqui</a> , e o resultado para o visor WEG010016AL √© mostrado na foto: <br><br><img src="http://revich.lib.ru/AVR/WEG10016_clock.jpg" width="600" alt="imagem"><br><br>  Mas nesta foto, uma fonte de um tipo diferente (16x16) na tela WEG010016CG (a tela tamb√©m est√° de cabe√ßa para baixo): <br><br><img src="http://revich.lib.ru/AVR/WEG10016CG_clock.jpg" width="600" alt="imagem"><br><br>  Se voc√™ recriar a fonte alterando a ordem dos bits manualmente, n√£o ser√° necess√°rio fazer o inverso e o programa ser√° executado mais rapidamente (embora n√£o haja atrasos vis√≠veis nos olhos).  Mas o procedimento de invers√£o de bits fornecido √© √∫til em qualquer caso - para exibir v√°rias imagens.  Por exemplo, de uma seta apontando para cima e para a direita, voc√™ pode obter programaticamente quatro dire√ß√µes ao mesmo tempo. <br><div class="spoiler">  <b class="spoiler_title">Desenho de seta</b> <div class="spoiler_text">  Imagem e c√≥digo de seta (as coordenadas e os bits na tabela s√£o invertidos de acordo com a posi√ß√£o inferior do conector para o visor WEG010016AL, veja acima): <br><br><img src="http://revich.lib.ru/AVR/TableCodArray.png" alt="imagem"><br><pre> <code class="hljs markdown">const byte DataATR[<span class="hljs-string"><span class="hljs-string">2</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">8</span></span>]={{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, {0x01,0x02,0x04,0x28,0x30,0x78,0x60,0x80}};</code> </pre> <br>  Fun√ß√µes para sa√≠da de setas multidirecionais: <br><pre> <code class="hljs powershell">. . . . . void drawSW (byte x) //   (  ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">8</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); lcd.write(DataATR[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); lcd.write(DataATR[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]);} } void drawNW (byte x) //   (  ) {//   : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">8</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); byte b=reverse(DataATR[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]); lcd.write(b); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); b=reverse(DataATR[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-type"><span class="hljs-type">ix</span></span>]); lcd.write(b);} } void drawNE (byte x) //   (  ) {//  ,    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">8</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); byte b=reverse(DataATR[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">7</span></span>-(<span class="hljs-type"><span class="hljs-type">ix</span></span>)]); lcd.write(b); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); b=reverse(DataATR[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">7</span></span>-(<span class="hljs-type"><span class="hljs-type">ix</span></span>)]); lcd.write(b);} } void drawSE (byte x) //   (  ) {//   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">8</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); lcd.write(DataATR[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">7</span></span>-(<span class="hljs-type"><span class="hljs-type">ix</span></span>)]); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); lcd.write(DataATR[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">7</span></span>-(<span class="hljs-type"><span class="hljs-type">ix</span></span>)]);} } . . . . .</code> </pre> </div></div><br>  A foto abaixo mostra o resultado de um programa em branco para exibir o sensor de velocidade e dire√ß√£o do vento.  Como voc√™ pode ver, acabou sendo muito simples implementar fontes de tamanhos diferentes em uma linha, juntamente com imagens: <br><br><img src="http://revich.lib.ru/AVR/WEG10016_wind.jpg" width="600" alt="imagem"><br><br>  Concluindo, acrescentarei que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> est√° uma biblioteca muito interessante para trabalhar com o WS0010 nos modos gr√°fico e de texto usando o SPI.  No texto, ele copia principalmente o Liquid Crystal (e o que mais voc√™ consegue imaginar?). E no gr√°fico, ele tem as fun√ß√µes de desenhar primitivas gr√°ficas, fontes internas (grossas, como a minha e o usual 5x7) e muito mais. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt402517/">https://habr.com/ru/post/pt402517/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt402505/index.html">A realidade aumentada come√ßou a ser aplicada massivamente na ind√∫stria americana.</a></li>
<li><a href="../pt402507/index.html">Gest√£o de patrim√¥nio pessoal como direito humano fundamental</a></li>
<li><a href="../pt402509/index.html">Navega√ß√£o por sat√©lite desativa o roteamento</a></li>
<li><a href="../pt402511/index.html">Como nasceu a vida</a></li>
<li><a href="../pt402515/index.html">Braun Oral-B Genius 9000: quando o pincel d√° dicas atrav√©s de um smartphone</a></li>
<li><a href="../pt402521/index.html">O WiFi infravermelho √© 17 vezes mais r√°pido que o normal, mas unidirecional</a></li>
<li><a href="../pt402523/index.html">"Mundo magro". Cap√≠tulo 9</a></li>
<li><a href="../pt402525/index.html">Por que o OneDrive diminuiu a velocidade no Linux</a></li>
<li><a href="../pt402527/index.html">Quatro para trinta e dois</a></li>
<li><a href="../pt402529/index.html">Por que √© melhor com uma camiseta cardio do que sem ela: algumas palavras sobre roupas inteligentes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>