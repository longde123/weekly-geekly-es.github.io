<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👨🏾 👩🏽‍🤝‍👩🏼 🤖 Apprentissage automatique pour trouver des erreurs dans le code: comment j'ai effectué un stage chez JetBrains Research ❣️ 🎊 🙌🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Récemment, nous avons expliqué comment obtenir un stage chez Google. En plus de Google, nos étudiants s'essaient à JetBrains, Yandex, Acronis et à d'a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apprentissage automatique pour trouver des erreurs dans le code: comment j'ai effectué un stage chez JetBrains Research</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hsespb/blog/434368/">  Récemment, nous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">avons</a> expliqué comment obtenir un stage chez Google.  En plus de Google, nos étudiants s'essaient à JetBrains, Yandex, Acronis et à d'autres entreprises. <br><br>  Dans cet article, je vais partager mon expérience de stage chez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JetBrains Research</a> , parler des tâches qu'ils y résolvent et m'attarder sur la façon dont l'apprentissage automatique peut rechercher des bogues dans le code du programme. <br><br><img src="https://habrastorage.org/webt/gf/xa/bh/gfxabh9xemshdpmkrr48vind45a.jpeg"><br><a name="habracut"></a><br><h2>  À propos de moi </h2><br>  Je m'appelle Yegor Bogomolov, je suis un étudiant de 4e année du diplôme de premier cycle HSE de Saint-Pétersbourg en mathématiques appliquées et en informatique.  Pendant les 3 premières années, comme mes camarades de classe, j'ai étudié à l'Université académique et depuis septembre, nous avons déménagé à l'École supérieure d'économie avec tout le département. <br><br>  Après la 2e année, j'ai effectué un stage d'été chez Google Zurich.  Là, j'ai passé trois mois à travailler dans l'équipe Android Calendar, la plupart du temps à faire du frontend'om et un peu de recherche UX.  La partie la plus intéressante de mon travail était la recherche sur l'apparence future des interfaces de calendrier.  Il s'est avéré agréable que presque tout le travail que j'ai fait à la fin du stage se soit retrouvé dans la version principale de l'application.  Mais le sujet des stages chez Google est très bien traité dans un article précédent, je vais donc parler de ce que j'ai fait cet été. <br><br><h2>  Qu'est-ce que JB Research? </h2><br>  JetBrains Research est un ensemble de laboratoires travaillant dans divers domaines: langages de programmation, mathématiques appliquées, apprentissage automatique, robotique et autres.  Dans chaque domaine, il existe plusieurs groupes scientifiques.  Grâce à ma direction, je connais le mieux les activités des groupes dans le domaine de l'apprentissage automatique.  Chacun d'eux organise des séminaires hebdomadaires au cours desquels des membres du groupe ou des invités invitent à parler de leur travail ou d'articles intéressants dans leur domaine.  De nombreux étudiants du HSE viennent à ces séminaires, car ils traversent la route du bâtiment principal du campus HSE à Saint-Pétersbourg. <br><br>  Dans notre programme de licence, nous sommes obligatoirement engagés dans des travaux de recherche (R&amp;D) et présentons les résultats de la recherche deux fois par an.  Souvent, ce travail se transforme progressivement en stages d'été.  C'est ce qui est arrivé avec mon travail de recherche: cet été, j'ai effectué un stage au laboratoire "Méthodes d'Apprentissage Machine en Génie Logiciel" avec mon superviseur Timofey Bryksin.  Les tâches en cours dans ce laboratoire comprennent des suggestions de refactorisation automatique, l'analyse du style de code pour les programmeurs, l'achèvement du code et la recherche d'erreurs dans le code du programme. <br><br>  Mon stage a duré deux mois (juillet et août), et à l'automne j'ai continué à m'engager dans des tâches assignées dans le cadre de la recherche.  J'ai travaillé dans plusieurs domaines, le plus intéressant d'entre eux, à mon avis, était la recherche automatique de bugs dans le code, et je veux en parler.  Le point de départ était <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article de Michael Pradel</a> . <br><br><h2>  Recherche automatique de bogues </h2><br><h3>  Comment les bogues sont-ils recherchés maintenant? </h3><br>  Pourquoi chercher des bugs est plus ou moins clair.  Voyons comment ils vont maintenant.  Les détecteurs de bogues modernes sont principalement basés sur une analyse de code statique.  Pour chaque type d'erreur, recherchez les modèles précédemment remarqués par lesquels elle peut être déterminée.  Ensuite, pour réduire le nombre de faux positifs, des heuristiques sont inventées, inventées pour chaque cas individuel.  Les modèles peuvent être recherchés à la fois dans un arbre de syntaxe abstraite (AST) construit par code et dans les graphiques d'un flux de contrôle ou de données. <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) || x &gt; MAX) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = bar(x); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><img src="https://habrastorage.org/webt/76/8t/wn/768twn22o7j83mwak6x-n9kw5d4.png"><br><br>  Le code et l'arborescence qui a été construit dessus. <br><br>  Pour comprendre comment cela fonctionne, considérons un exemple.  Le type de bogues peut être l'utilisation de = au lieu de == en C ++.  Regardons le morceau de code suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">0</span></span>; … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value = <span class="hljs-number"><span class="hljs-number">1</span></span>) { ... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { … }</code> </pre><br>  Il y avait une erreur dans l'expression conditionnelle, tandis que le premier = dans l'affectation de la valeur à la variable est correct.  Le modèle vient d'ici: si l'affectation est utilisée à l'intérieur de la condition dans if, c'est un bug potentiel.  En recherchant un tel modèle dans AST, nous pouvons détecter l'erreur et la corriger. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">0</span></span>; … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == <span class="hljs-number"><span class="hljs-number">1</span></span>) { ... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { … }</code> </pre><br>  Dans un cas plus général, nous ne pourrons pas trouver si facilement un moyen de décrire l'erreur.  Supposons que nous voulons déterminer l'ordre correct des opérandes.  Encore une fois, regardez les fragments de code: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; n; i++) { a[i] = a[<span class="hljs-number"><span class="hljs-number">1</span></span> - i] + a[i - <span class="hljs-number"><span class="hljs-number">2</span></span>]; }</code> </pre><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitReverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> - i; }</code> </pre><br>  Dans le premier cas, l'utilisation de 1-i était erronée et dans le second, elle était tout à fait correcte, ce qui ressort clairement du contexte.  Mais comment le décrire sous la forme d'un motif?  Avec la complication du type d'erreurs, nous devons considérer une plus grande section de code et analyser de plus en plus de cas individuels. <br><br>  Dernier exemple motivant: des informations utiles sont également contenues dans les noms des méthodes et des variables.  Il est encore plus difficile à exprimer par certaines conditions spécifiées manuellement. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSquare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDim, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> yDim)</span></span></span><span class="hljs-function"> </span></span>{ … } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">3</span></span>, y = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s = getSquare(y, x);</code> </pre><br>  Une personne comprend que, très probablement, les arguments de l'appel de fonction sont mélangés, car nous comprenons que x ressemble plus à xDim qu'à yDim.  Mais comment signaler cela au détecteur?  Vous pouvez ajouter quelques heuristiques de la forme «le nom de la variable est le préfixe du nom de l'argument», mais supposez que x est plus souvent une largeur qu'une hauteur, donc n'exprimez plus. <br><br>  Conclusion: le problème de l'approche moderne de recherche d'erreurs est que beaucoup de travail doit être fait avec vos mains: pour déterminer les modèles, ajouter des heuristiques, à cause de cela, l'ajout d'un support pour un nouveau type d'erreur dans le détecteur prend du temps.  De plus, il est difficile d'utiliser une partie importante des informations que le développeur a laissées dans le code: les noms des variables et des méthodes. <br><br><h3>  Comment l'apprentissage automatique peut-il aider? </h3><br>  Comme vous l'avez peut-être remarqué, dans de nombreux exemples, les erreurs sont visibles pour les humains, mais elles sont difficiles à décrire formellement.  Dans de telles situations, les méthodes d'apprentissage automatique peuvent souvent aider.  Arrêtons-nous sur la recherche d'arguments réarrangés dans un appel de fonction et comprenons ce dont nous avons besoin pour les rechercher à l'aide de l'apprentissage automatique: <br><br><ol><li>  Un grand nombre d'exemples de code sans bugs </li><li>  Une grande quantité de code avec des erreurs d'un type donné </li><li>  Méthode de vectorisation de fragments de code </li><li>  Le modèle que nous allons enseigner pour distinguer le code avec et sans erreurs </li></ol><br>  Nous pouvons espérer que dans la plupart du code présenté dans le domaine public, les arguments dans les appels de fonction sont dans le bon ordre.  Par conséquent, pour un exemple de code sans bogues, vous pouvez prendre un ensemble de données volumineux.  Dans le cas de l'auteur de l'article original, il s'agissait de JS 150K (150 000 fichiers en Javascript), dans notre cas, un jeu de données similaire pour Python. <br><br>  Trouver du code avec des bogues est beaucoup plus difficile.  Mais nous ne pouvons pas rechercher les erreurs de quelqu'un d'autre, mais faites-les vous-même!  Pour le type d'erreurs, vous devez spécifier une fonction qui, selon le bon morceau de code, la rendra corrompue.  Dans notre cas, réorganisez les arguments dans l'appel de fonction. <br><br><h3>  Comment vectoriser le code? </h3><br>  Armés de beaucoup de bons et de mauvais codes, nous sommes presque prêts à enseigner quelque chose.  Avant cela, nous devons encore répondre à la question: comment présenter les fragments de code? <br><br>  Un appel de fonction peut être représenté comme un tuple du nom d'une méthode, du nom de la méthode dont il s'agit, des noms et des types d'arguments passés aux variables.  Si nous apprenons à vectoriser des jetons individuels (noms de variables et méthodes, tous les «mots» trouvés dans le code), nous pouvons prendre la concaténation de vecteurs de jetons qui nous intéressent et obtenir le vecteur souhaité pour le fragment. <br><br>  Pour vectoriser des jetons, regardons comment les mots dans les textes ordinaires vectorisent.  L'un des moyens les plus réussis et les plus populaires est le word2vec proposé en 2013. <br><br><img src="https://habrastorage.org/webt/kj/0o/pp/kj0opp-scftpuqr16t5c9fj1uv0.png"><br><br>  Cela fonctionne comme suit: nous apprenons au réseau à prédire par mot d'autres mots qui apparaissent à côté de lui dans les textes.  Dans ce cas, le réseau ressemble à une couche d'entrée de la taille d'un dictionnaire, une couche cachée de la taille de la vectorisation que nous voulons recevoir et une couche de sortie, également de la taille d'un dictionnaire.  Pendant la formation, les réseaux sont alimentés par un vecteur d'unité d'entrée avec une unité à la place du mot en question (renard), et en sortie nous voulons obtenir des mots qui apparaissent dans la fenêtre autour de ce mot (rapide, marron, sauts, par dessus).  Dans ce cas, le réseau traduit d'abord tous les mots en un vecteur sur une couche cachée, puis fait une prédiction. <br><br>  Les vecteurs résultants pour des mots individuels ont de bonnes propriétés.  Par exemple, les vecteurs de mots ayant une signification similaire sont proches les uns des autres, et la somme et la différence des vecteurs sont l'addition et la différence des «significations» des mots. <br><br>  Pour effectuer une vectorisation similaire des jetons dans le code, vous devez en quelque sorte définir l'environnement qui sera prédit.  Il peut s'agir d'informations issues d'AST: types de sommets autour, jetons rencontrés, position dans un arbre. <br><br>  Après avoir reçu une vectorisation, vous pouvez voir quels jetons sont similaires les uns aux autres.  Pour ce faire, calculez la distance cosinus entre eux.  En conséquence, les vecteurs voisins suivants sont obtenus pour Javascript (le nombre est la distance cosinus): <br><br><img src="https://habrastorage.org/webt/lf/q0/4q/lfq04qjp4fcygqjikgy0zq9av8y.png"><br><br>  L'ID et le LIT ajoutés au début indiquent si le jeton est un identifiant (nom d'une variable, méthode) ou un littéral (constante).  On peut voir que la proximité est significative. <br><br><h3>  Formation de classificateur </h3><br>  Après avoir reçu une vectorisation pour des jetons individuels, obtenir une vue pour un morceau de code avec une erreur potentielle est assez simple: il s'agit d'une concaténation de vecteurs importants pour la classification des jetons.  Un perceptron à deux couches est formé à des morceaux de code avec ReLU comme fonction d'activation et d'abandon pour réduire le sur-ajustement.  L'apprentissage converge rapidement, le modèle résultant est petit et peut faire des prédictions pour des centaines d'exemples par seconde.  Cela vous permet de l'utiliser en temps réel, ce qui sera discuté plus tard. <br><br><h3>  Résultats </h3><br>  L'évaluation de la qualité du classificateur résultant a été divisée en deux parties: une évaluation sur un grand nombre d'exemples générés artificiellement et une vérification manuelle sur un petit nombre (50 pour chaque détecteur) d'exemples avec la probabilité prédite la plus élevée.  Les résultats pour les trois détecteurs (arguments réarrangés, exactitude de l'opérateur binaire et de l'opérande binaire) étaient les suivants: <br><br><img src="https://habrastorage.org/webt/n9/f5/sm/n9f5smfdvj55bw3qeb-l_y9jub0.png"><br><br>  Certaines des erreurs prédites seraient difficiles à trouver avec les méthodes de recherche classiques.  Un exemple avec res réarrangé et err dans un appel à p.done: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> (); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( promises === <span class="hljs-literal"><span class="hljs-literal">null</span></span> || promises . length === <span class="hljs-number"><span class="hljs-number">0</span></span>) { p. done (error , result ) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { promises [<span class="hljs-number"><span class="hljs-number">0</span></span>](error, result).then( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res, err</span></span></span><span class="hljs-function">) </span></span>{ p.done(res, err); }); }</code> </pre><br>  Il y avait aussi des exemples dans lesquels il n'y avait pas d'erreur, mais les variables devaient être renommées afin de ne pas induire en erreur la personne essayant de comprendre le code.  Par exemple, ajouter de la largeur et chacun ne semble pas être une bonne idée, même si cela ne s'est pas avéré être un bug: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cw = cs[i].width + each;</code> </pre><br><h3>  Portage Python </h3><br>  J'ai participé au portage du travail de Michael Pradel de js à python, puis à la création d'un plug-in pour PyCharm qui implémente des inspections basées sur la méthode décrite ci-dessus.  Nous avons utilisé l'ensemble de données <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Python 150K</a> (150 000 fichiers Python disponibles sur GitHub). <br><br>  Tout d'abord, il s'est avéré qu'en Python, il y a plus de jetons différents qu'en javascript.  Pour js, les 10 000 jetons les plus populaires représentaient plus de 90% de tous les problèmes rencontrés, tandis que pour Python, il fallait en utiliser environ 40 000. Cela a entraîné une augmentation de la taille des jetons dans les vecteurs, ce qui a rendu le portage vers le plugin difficile. <br><br>  Deuxièmement, après avoir implémenté pour Python une recherche d'arguments incorrects dans les appels de fonction et en regardant les résultats manuellement, j'ai obtenu un taux d'erreur de plus de 90%, ce qui était en désaccord avec les résultats pour js.  Après avoir compris les raisons, il s'est avéré qu'en javascript, plus de fonctions étaient déclarées dans le même fichier que leurs appels.  Moi, suivant l'exemple de l'auteur de l'article, dans un premier temps, je n'ai pas autorisé la déclaration de fonctions à partir d'autres fichiers, ce qui a conduit à de mauvais résultats. <br><br>  Vers la fin août, j'ai terminé l'implémentation de Python et écrit la base du plugin.  Le plugin continue d'être développé, maintenant l'étudiante Anastasia Tuchina de notre laboratoire est engagée dans ce domaine. <br><br>  Vous pouvez trouver les étapes pour essayer le fonctionnement du plugin sur le wiki du référentiel. <br><br>  Liens sur github: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Référentiel avec implémentation python</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Référentiel avec plugin</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr434368/">https://habr.com/ru/post/fr434368/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr434356/index.html">Python Stiller avec e-mail</a></li>
<li><a href="../fr434358/index.html">Substitution d'importation de systèmes d'exploitation. Comment puis-je voir le système d'exploitation national</a></li>
<li><a href="../fr434360/index.html">Discussion expliquée sur la programmation asynchrone en Javascript</a></li>
<li><a href="../fr434362/index.html">PAS prévu pour 2019</a></li>
<li><a href="../fr434364/index.html">Prise en charge de la file d'attente Hangfire</a></li>
<li><a href="../fr434370/index.html">Un autre conquérant de l'ombre à Phaser, ou l'utilisation de vélos</a></li>
<li><a href="../fr434374/index.html">Vérification de RBAC dans Kubernetes</a></li>
<li><a href="../fr434380/index.html">Bases de l'injection de dépendance</a></li>
<li><a href="../fr434382/index.html">Portage d'Alpine Linux vers RISC-V</a></li>
<li><a href="../fr434384/index.html">Sous la responsabilité des artistes interprètes ou exécutants</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>