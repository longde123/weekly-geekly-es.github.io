<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👵🏾 🖖🏾 👩🏿‍🤝‍👩🏻 Tipo Perguntas frequentes do sistema 🙋🏻 🤾🏿 👩🏾‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O autor do artigo, cuja tradução publicamos hoje, diz que este post e comentários serviram como fonte de inspiração para a redação. Segundo ele, os es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tipo Perguntas frequentes do sistema</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/462481/">  O autor do artigo, cuja tradução publicamos hoje, diz que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este</a> post e comentários serviram como fonte de inspiração para a redação.  Segundo ele, os especialistas em TI têm conceitos errados sobre tipos, usam terminologia incorreta e, discutindo questões relacionadas a tipos, chegam a conclusões errôneas.  Ele observa que não é defensor do sistema de tipos estáticos.  A única coisa que o incomoda é o uso correto dos termos.  Isso permite discussões construtivas.  O autor diz que escreveu este material espontaneamente, mas espera que não haja erros nele.  Se ele confundiu alguma coisa, ele pede que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ele</a> soubesse. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/5h/v0/_9/5hv0_9iyqwfr7itow5ihgjdpdio.jpeg"></a> <br><br>  Vamos entender de uma vez por todas o que causa confusão quando se fala em sistemas de tipos. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Digitação dinâmica e falta de digitação</font> </h2><br>  Algumas pessoas pensam que um sistema de tipos dinâmicos é o mesmo que um sistema de tipos não tipados.  A falta de digitação significa que, em um determinado sistema de tipos, não faz sentido distinguir entre tipos.  Não faz sentido distinguir tipos, mesmo que apenas um tipo esteja presente no sistema de tipos.  Por exemplo: <br><br><ul><li>  No assembler, o único tipo é uma sequência de bits. </li><li>  No cálculo lambda, o único tipo é função. </li></ul><br>  Alguém pode dizer isso nesta ocasião: "Mas que diferença faz - digitação dinâmica ou falta de digitação - também é uma pergunta para mim."  Mas isso, de fato, é uma questão grande e importante.  O fato é que, se você equiparar digitação dinâmica à falta de digitação, significa a adoção automática do fato de que um sistema de tipo dinâmico é o oposto de um sistema de tipo estático.  Como resultado, dois campos opostos de programadores são formados - o campo de tipagem dinâmica e o campo de tipagem estática (e isso, como veremos na seção correspondente, está errado). <br><br>  <i><font color="#999999">Os idiomas que não limitam o intervalo de valores das variáveis ​​são chamados de idiomas não tipados: eles não têm tipos ou, o que é a mesma coisa, eles têm apenas um tipo universal que contém todos os valores.</font></i> <br>  <sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Type Systems, Luca Cardelli</a></sub> <br><br>  <i><font color="#999999">As linguagens de programação têm um recurso interessante que permite dividir aproximadamente o mundo deles em dois grupos:</font></i> <i><font color="#999999"><br><br></font></i> <ul><li>  Linguagens sem tipo - programas simplesmente executados.  Isso acontece rapidamente, sem tentar verificar a "uniformidade de formas". </li><li>  Linguagens digitadas - é feita uma tentativa de verificar a “uniformidade da forma” - durante a compilação ou durante a execução do programa. </li></ul><br>  <sub>“Sistemas de tipos para linguagens de programação”, Benjamin Pearce</sub> <br><br><h2>  <font color="#3AC1EF">Digitação dinâmica e estática</font> </h2><br>  Um sistema de tipo dinâmico é um sistema no qual os tipos são verificados dinamicamente (durante a execução do programa).  Um sistema de tipo estático é um sistema no qual os tipos são verificados estaticamente (durante a compilação ou tradução de código). <br><br>  Um desses sistemas é o oposto do outro?  Não é não.  Os dois tipos de sistemas podem ser usados ​​no mesmo idioma.  De fato, a maioria dos sistemas de tipo estático também possui verificações de tipo dinâmico.  Como exemplo, considere a validação das operações de entrada e saída (IO).  Imagine que você precise ler os dados fornecidos por um usuário que deve inserir um número.  Você verificará, durante a execução do programa, se o número é o resultado da análise da linha correspondente (como resultado da análise, uma exceção pode ser lançada ou algo como <code>NaN</code> será retornado).  Quando você verifica os dados inseridos pelo usuário, descobrindo se eles podem ser considerados como um número - você executa uma verificação de tipo dinâmico. <br><br>  Como resultado, podemos observar a ausência de confronto entre os tipos estático e dinâmico.  Você pode usar, no mesmo idioma, esses e outros. <br><br>  Além disso, deve-se notar que a verificação de tipo estático é um processo complexo.  Às vezes, é muito difícil verificar estaticamente algumas partes de um programa.  Como resultado, em vez de aplicar verificações de tipo estático, você pode recorrer a verificações dinâmicas. <br><br>  É recomendável considerar um sistema de tipo estático como tipos que são verificados estaticamente.  Um sistema de tipos dinâmicos é como tipos verificados dinamicamente. <br><br><h2>  <font color="#3AC1EF">Usar tipos estáticos significa conhecer tipos em tempo de compilação?</font> </h2><br>  A pergunta colocada no título desta seção pode ser respondida em negativo.  Se você abrir o código-fonte de qualquer analisador (incluindo o analisador JavaScript), poderá ver que o analisador conhece os tipos de valores durante a análise (isso faz parte do processo de compilação). <br><br><pre> <code class="plaintext hljs">let x = "test";</code> </pre> <br>  Acontece que o analisador sabe que <code>"test"</code> é uma sequência.  Isso faz do JavaScript uma linguagem estática de tipo?  Não, não é. <br><br><h2>  <font color="#3AC1EF">Digitação gradual</font> </h2><br>  Um sistema de tipo gradual é um sistema de tipo estático que permite ignorar as verificações de tipo de algumas partes de um programa.  Por exemplo, no TypeScript, isso é implementado usando <code>any</code> ou <code>@ts-ignore</code> . <br><br>  Por um lado, isso torna o sistema de tipos menos seguro.  Por outro lado, um sistema de tipos com digitação gradual permite adicionar gradualmente descrições de tipos a idiomas com digitação dinâmica. <br><br><h2>  <font color="#3AC1EF">Sistemas de tipo confiáveis ​​e não confiáveis</font> </h2><br>  Se você usar um sistema de tipos confiável (sistema de tipos de som), o programa, durante a verificação de tipo, não será "aprovado" se houver erros relacionados aos tipos neste programa.  O uso de um sistema de tipo não sólido leva à possibilidade de erros de tipo no programa.  É verdade que você não deve entrar em pânico depois de descobrir.  Na prática, isso pode não afetá-lo.  Confiabilidade ou solidez são propriedades matemáticas de um algoritmo de verificação de tipo que precisa de prova.  Muitos compiladores existentes (internamente, sistemas de verificação de tipo) não são confiáveis. <br><br>  Se você deseja trabalhar com sistemas de tipos confiáveis, dê uma olhada nas linguagens de programação da família ML, que usam o sistema do tipo Hindley-Milner. <br><br>  Além disso, deve-se entender que um sistema do tipo confiável não ignora o programa errado (não fornece resultados de testes falsos positivos, considerando que os programas errados estão corretos), mas pode não faltar ao programa correto (pode dar resultados falsos negativos). <br><br>  Um sistema de tipos que nunca rejeita o programa certo é chamado de completo. <br><br>  Acontece que um sistema de tipos é confiável e completo?  Até onde eu sei, esses sistemas de tipos não existem.  Não tenho certeza disso até o fim, mas parece-me que a existência de tais sistemas de tipos, se baseada no teorema da incompletude de Gödel, é fundamentalmente impossível (embora eu possa estar errado). <br><br><h2>  <font color="#3AC1EF">Digitação fraca e forte</font> </h2><br>  Acho inapropriado usar os termos "digitação fraca" e "digitação forte".  Esses termos são ambíguos, seu uso pode dar mais confusão do que clareza.  Deixe-me fazer algumas citações. <br><br>  <i><font color="#999999">Esses idiomas podem ser chamados, figurativamente falando, idiomas com verificação de tipo fraco (ou idiomas com tipos fracos, como geralmente são chamados em várias publicações).</font></i>  <i><font color="#999999">O uso da verificação de tipo fraco no idioma significa que algumas operações inseguras são detectadas estaticamente e outras não.</font></i>  <i><font color="#999999">A "fraqueza" das verificações de tipo nos idiomas desta classe varia muito.</font></i> <br>  <sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Type Systems, Luca Cardelli</a></sub> <br><br>  <i><font color="#999999">Provavelmente, a maneira mais comum de classificar sistemas de tipos é dividi-los em sistemas com digitação "fraca" e "forte".</font></i>  <i><font color="#999999">Isso só pode ser lamentado, pois essas palavras não têm praticamente nenhum significado em si mesmas.</font></i>  <i><font color="#999999">É possível, até certo ponto, comparar dois idiomas que possuem sistemas de tipos muito semelhantes e selecionar um deles como tendo um sistema de tipos mais forte que o segundo.</font></i>  <i><font color="#999999">Em outros casos, os termos "digitação forte" e "digitação fraca" são completamente sem sentido.</font></i> <i><font color="#999999"><br></font></i>  <i><font color="#999999"><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Coisas a saber antes de discutir os sistemas de tipos", Steve Klabnik</a></sub></font></i> <i><font color="#999999"><br><br></font></i>  <i><font color="#999999">Os termos "digitação forte" e "digitação fraca" são extremamente ambíguos.</font></i>  <i><font color="#999999">Aqui estão alguns exemplos de seu uso:</font></i> <i><font color="#999999"><br><br></font></i> <ul><li>  <i><font color="#999999">Às vezes, “digitação forte” é entendida como “digitação estática”.</font></i>  <i><font color="#999999">Não é difícil fazer essa "substituição", mas é melhor, falando em digitação estática, simplesmente chamá-la de "estática".</font></i>  <i><font color="#999999">O fato é que a maioria dos programadores entende claramente esse termo.</font></i> </li><li>  <i><font color="#999999">Às vezes, quando dizem "digitação forte", significam "a ausência de uma conversão implícita de tipo".</font></i>  <i><font color="#999999">Por exemplo, em JavaScript, você pode usar expressões como <code>"a" - 1</code> .</font></i>  <i><font color="#999999">Isso pode ser chamado de modelo de "digitação fraca".</font></i>  <i><font color="#999999">Mas quase todas as linguagens oferecem ao programador algumas oportunidades para conversão implícita de tipos, por exemplo, suportando a conversão automática de números inteiros em números de ponto flutuante em expressões como <code>1 - 1.1</code> .</font></i>  <i><font color="#999999">Na prática, a maioria dos profissionais que usam o termo "digitação forte" dessa maneira faz distinção entre conversões do tipo "aceitável" e "inaceitável".</font></i>  <i><font color="#999999">Mas não existe um limite geralmente aceito entre essas conversões de tipo.</font></i>  <i><font color="#999999">A "aceitabilidade" e "inaceitável" das transformações é uma avaliação subjetiva, dependendo da opinião de uma pessoa em particular.</font></i> </li><li>  <i><font color="#999999">Às vezes, idiomas com "digitação forte" são chamados de idiomas nos quais é impossível contornar as regras do sistema de tipos que eles possuem.</font></i> </li><li>  <i><font color="#999999">Às vezes, "digitação forte" significa ter um sistema de tipos que permite trabalhar com segurança na memória.</font></i>  <i><font color="#999999">A linguagem C é um exemplo notável de uma linguagem que não é segura na memória.</font></i>  <i><font color="#999999">Por exemplo, se <code>xs</code> é uma matriz de quatro números, C aprovará um código que usa construções como <code>xs[5]</code> ou <code>xs[1000]</code> sem problemas.</font></i>  <i><font color="#999999">Eles permitirão que você acesse a memória localizada após os endereços alocados para armazenar o conteúdo da matriz <code>xs</code> .</font></i> </li></ul><br>  <sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Os tipos, Gary Bernard</a></sub> <br><br><h2>  <font color="#3AC1EF">As linguagens estáticas digitadas precisam de declarações de tipo?</font> </h2><br>  Linguagens de tipo estático nem sempre precisam de declarações de tipo.  Às vezes, um sistema de tipos pode inferir tipos (fazendo suposições com base na estrutura do código).  Aqui está um exemplo (TypeScript): <br><br><pre> <code class="plaintext hljs">const x = "test";</code> </pre> <br>  O sistema de tipos sabe que <code>"test"</code> é uma string (esse conhecimento é baseado nas regras de análise de código).  O sistema de tipos também sabe que <code>x</code> é uma constante, ou seja, o valor de <code>x</code> não pode ser reatribuído.  Como resultado, pode-se concluir que <code>x</code> é do tipo string. <br>  Aqui está outro exemplo (Flow): <br><br><pre> <code class="plaintext hljs">const add = (x, y) =&gt; x / y //            ^        [1]   . add(1, "2")</code> </pre> <br>  O sistema de verificação de tipo vê que chamamos a função <code>add</code> , passando um número e uma string.  Isso analisa a declaração da função.  O sistema de verificação de tipo sabe que, para executar a operação de divisão, os números devem estar à direita e esquerda do operador correspondente.  Um dos operandos envolvidos na operação de divisão não é um número.  Como resultado, somos informados sobre o erro. <br><br>  Não há declarações de tipo aqui, mas isso não impede uma verificação de tipo estático do programa acima.  Se você encontrar situações semelhantes no mundo real, mais cedo ou mais tarde precisará declarar alguns tipos.  O sistema de tipos não pode deduzir absolutamente todos os tipos.  Mas você precisa entender que um idioma pode ser chamado de "estático" não porque usa declarações de tipo, mas porque os tipos são verificados antes do início do programa. <br><br><h2>  <font color="#3AC1EF">O TypeScript é uma linguagem insegura porque o código escrito nele é compilado no código JavaScript?</font> </h2><br>  TypeScript é uma linguagem doentia.  Portanto, o código escrito nele pode se transformar em aplicativos não seguros.  Mas isso não tem nada a ver com o que compila. <br><br>  A maioria dos compiladores de desktop converte programas em algo que se parece com a linguagem assembly.  E assembler é uma linguagem ainda menos segura que JS. <br><br>  Aqui, se você voltar à ideia de que o TS é inseguro devido à compilação em JS, você pode ter o seguinte pensamento: “O código compilado é executado no navegador, o JS é uma linguagem insegura e pode substituir <code>null</code> ao local em que a linha é esperada "  O pensamento é sensato.  Mas isso, novamente, não dá uma razão para chamar o TS de uma linguagem insegura.  Para que o TS garanta segurança dentro do aplicativo, é necessário colocar os "mecanismos de defesa" nos locais em que o código do TS interage com o mundo externo.  Ou seja, por exemplo, é necessário verificar a correção dos dados que entram no programa através dos mecanismos de entrada e saída.  Digamos que isso possa estar verificando o que o usuário digita, verificando respostas do servidor, verificando dados lidos no armazenamento do navegador e assim por diante. <br><br>  Por exemplo, o papel desses "mecanismos de defesa" no Elm é desempenhado por " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">portos</a> ".  No TS, você pode usar algo como io-ts para isso. <br><br>  O correspondente “mecanismo de proteção” cria uma ponte entre os sistemas do tipo estático e dinâmico. <br><br>  Aqui está um exemplo simplificado: <br><br><pre> <code class="plaintext hljs">const makeSureIsNumber = (x: any) =&gt; {  const result = parseFloat(x);  if (isNaN(result)) {    throw Error("Not a number");  }  return result; } const read = (input: any) =&gt; {  try {    const n = makeSureIsNumber(input);    //     n, ,      //              // makeSureIsNumber "" , n    } catch (e) { } }</code> </pre> <br><h2>  <font color="#3AC1EF">É verdade que os tipos são necessários apenas para compiladores?</font> </h2><br>  <i><font color="#999999">Os tipos são apenas o hack necessário para dar dicas ao compilador.</font></i> <br>  <sub>Waut Mertens</sub> <br><br>  Os tipos são necessários apenas pelos compiladores?  Esta é uma questão filosófica.  Tipos são necessários para pessoas, não para carros.  Compiladores precisam de tipos porque são programas criados por pessoas. <br><br>  O fenômeno dos tipos existe por causa das pessoas.  Os tipos não existem até que uma pessoa perceba algo na forma de um "tipo de dados".  A mente humana divide diferentes entidades em diferentes categorias.  Tipos não fazem sentido sem um observador. <br><br>  Vamos organizar um experimento mental.  Pense no jogo da vida.  Você tem uma grade bidimensional que consiste em células quadradas.  Cada uma das células pode estar em dois estados possíveis.  Pode estar "vivo" ou "morto".  Cada célula pode interagir com seus oito vizinhos.  São células que o limitam verticalmente, horizontalmente ou diagonalmente.  No processo de localização do próximo estado do sistema, as seguintes regras se aplicam: <br><br><ul><li>  Uma célula “viva” com menos de dois vizinhos “vivos” “morre”, como em uma baixa densidade populacional. </li><li>  Uma célula “viva” com dois ou três vizinhos “vivos” sobrevive e cai na próxima geração. </li><li>  Uma célula "viva", com mais de três vizinhos "vivos", "morre", como na superpopulação. </li><li>  A célula “morta”, que possui exatamente três vizinhos “vivos”, torna-se “viva”, como na reprodução da população. </li></ul><br>  Externamente, parece um campo dividido em células quadradas, que são constantemente "ativadas" e "desativadas".  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aqui</a> você pode dar uma olhada nisso. <br><br>  Se você observar a Vida por algum tempo, estruturas estáveis ​​como "planador" podem aparecer no campo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04f/710/310/04f710310ef2d132545b15df0e19e601.gif"></div><br>  <i><font color="#999999">Planador</font></i> <br><br>  Viu ele?  Um planador se move pela tela.  Certo?  Agora vamos desacelerar um pouco.  Este planador realmente existe?  Estes são apenas quadrados individuais que aparecem e desaparecem.  Mas nosso cérebro pode perceber essa estrutura como algo objetivamente existente. <br><br>  Além disso, podemos dizer que o “planador” existe porque os quadrados não são independentes (eles dependem dos vizinhos) e, mesmo que o próprio “planador” não exista, existe um “planador” na forma idéias platônicas. <br><br><h2>  <font color="#3AC1EF">Sumário</font> </h2><br>  Considere qualquer programa escrito em uma linguagem de programação digitada.  Podemos observar os tipos.  Certo?  Mas o programa é compilado em códigos de máquina.  Nesses códigos, o mesmo é expresso no programa original (embora seja difícil para uma pessoa ler representações de programas de máquinas).  Do ponto de vista do computador, não há tipos.  Ele vê apenas a sequência de bits - conjuntos de zeros e uns (células "mortas" e "vivas").  Existem tipos para pessoas, não para carros. <br><br>  <b>Caros leitores!</b>  Que tipo de sistema você considera ideal para o desenvolvimento da web? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt462481/">https://habr.com/ru/post/pt462481/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt462471/index.html">Resolvendo um trabalho com pwnable.kr 16 - uaf. Usar após vulnerabilidade gratuita</a></li>
<li><a href="../pt462473/index.html">Estamos desenvolvendo um ambiente para trabalhar com microsserviços. Parte 1 instalando o Kubernetes HA no bare metal (Debian)</a></li>
<li><a href="../pt462475/index.html">Alexey Savvateev: Como combater a corrupção com a ajuda da matemática (Prêmio Nobel de Economia para 2016)</a></li>
<li><a href="../pt462477/index.html">Cientistas afirmam que a IA é o autor de uma nova patente e estão tentando mudar a lei de patentes</a></li>
<li><a href="../pt462479/index.html">Encaminhamento de privilégio local do cliente Windows do Steam 0 dia</a></li>
<li><a href="../pt462483/index.html">Programação funcional: um brinquedo maluco que mata a produtividade do trabalho. Parte 1</a></li>
<li><a href="../pt462485/index.html">Programação funcional: um brinquedo maluco que mata a produtividade do trabalho. Parte 2</a></li>
<li><a href="../pt462487/index.html">Cython: Aceleração de código Python acima de 30x</a></li>
<li><a href="../pt462489/index.html">O resumo de materiais frescos do mundo do front-end da última semana n ° 374 (29 de julho a 4 de agosto de 2019)</a></li>
<li><a href="../pt462493/index.html">DBMS multimodal - a base dos sistemas de informação modernos?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>