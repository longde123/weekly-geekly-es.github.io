<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öΩÔ∏è üêë üêç CI-Entwicklung im mobilen Entwicklungsteam üóæ üßëüèΩ‚Äçü§ù‚Äçüßëüèª üï∞Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heutzutage werden die meisten Softwareprodukte in Teams entwickelt. Erfolgsbedingungen f√ºr die Teamentwicklung k√∂nnen in Form eines einfachen Schemas ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CI-Entwicklung im mobilen Entwicklungsteam</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/447608/">  Heutzutage werden die meisten Softwareprodukte in Teams entwickelt.  Erfolgsbedingungen f√ºr die Teamentwicklung k√∂nnen in Form eines einfachen Schemas dargestellt werden. <br><br><img src="https://habrastorage.org/webt/wd/yv/we/wdyvwe6jcuq9yygmffhk5-eqnlo.png"><br><br>  Nachdem Sie den Code geschrieben haben, m√ºssen Sie sicherstellen, dass: <br><br><ol><li>  Es funktioniert. </li><li>  Es wird nichts kaputt gemacht, einschlie√ülich des Codes, den Ihre Kollegen geschrieben haben. </li></ol><br>  Wenn beide Bedingungen erf√ºllt sind, sind Sie auf dem Weg zum Erfolg.  Um diese Bedingungen einfach zu √ºberpr√ºfen und einen profitablen Weg nicht auszuschalten, wurde eine kontinuierliche Integration entwickelt. <br><br>  CI ist ein Workflow, in dem Sie Ihren Code so oft wie m√∂glich in den allgemeinen Produktcode integrieren.  Und nicht nur integrieren, sondern auch st√§ndig √ºberpr√ºfen, ob alles funktioniert.  Da Sie h√§ufig und h√§ufig nachsehen m√ºssen, sollten Sie √ºber Automatisierung nachdenken.  Sie k√∂nnen alles auf manuelle Traktion √ºberpr√ºfen, aber es lohnt sich nicht, und deshalb. <br><a name="habracut"></a><br><ul><li>  <strong>Leute sind teuer</strong> .  Eine Arbeitsstunde eines Programmierers ist teurer als eine Arbeitsstunde eines Servers. </li><li>  <strong>Die Leute liegen falsch</strong> .  Daher k√∂nnen Situationen auftreten, in denen Tests auf dem falschen Zweig ausgef√ºhrt oder das falsche Commit f√ºr Tester erfasst wurden. </li><li>  <strong>Die Leute sind faul</strong> .  Wenn ich eine Aufgabe erledige, habe ich regelm√§√üig den Gedanken: ‚ÄûAber was gibt es zu √ºberpr√ºfen?  Ich habe zwei Zeilen geschrieben - stopudovo alles funktioniert! ‚Äú  Ich denke, f√ºr einige von Ihnen kommen solche Gedanken manchmal in den Sinn.  Aber Sie m√ºssen immer √ºberpr√ºfen. </li></ul><br>  Laut Nikolay Nesterov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">nnesterov</a> ), der an allen evolution√§ren √Ñnderungen der CI / CD-Android-Anwendung teilnimmt, hat Continuous Integration im Avito Mobile-Entwicklungsteam eingef√ºhrt und entwickelt, wie es von 0 auf 450 Baugruppen pro Tag kam und dass Maschinen 200 Stunden am Tag sammeln . <br><br>  Die Geschichte basiert auf dem Beispiel des Android-Teams, aber die meisten Ans√§tze gelten auch f√ºr iOS. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/lz8MNATTUCU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Es war einmal eine Person im Avito Android-Team.  Per Definition brauchte er nichts von Continuous Integration: Es gab niemanden, in den er sich integrieren konnte. <br><br>  Aber die Anwendung wuchs, es tauchten immer mehr neue Aufgaben auf, und das Team wuchs.  Irgendwann war es an der Zeit, den Prozess der Code-Integration formeller zu gestalten.  Es wurde beschlossen, Git Flow zu verwenden. <br><br><img src="https://habrastorage.org/webt/rv/qa/jd/rvqajd0kgcao3w0-vw6lnomjpc8.png"><br><br>  Das Konzept des Git-Flows ist bekannt: Es gibt einen gemeinsamen Entwicklungszweig im Projekt, und f√ºr jede neue Funktion schneiden Entwickler einen separaten Zweig ab, schreiben ihn fest, pushen ihn, und wenn sie ihren Code in den Entwicklungszweig einf√ºgen m√∂chten, √∂ffnen Sie die Pull-Anforderung.  Um Wissen auszutauschen und Ans√§tze zu diskutieren, haben wir eine Code√ºberpr√ºfung eingef√ºhrt. Das hei√üt, Kollegen m√ºssen den Code des anderen √ºberpr√ºfen und best√§tigen. <br><br><h2>  Schecks </h2><br>  Den Code mit den Augen zu sehen ist cool, aber nicht genug.  Daher werden automatische √úberpr√ºfungen eingef√ºhrt. <br><br><ul><li>  Zun√§chst √ºberpr√ºfen wir die <strong>Montage des ARC</strong> . </li><li>  Viele <strong>Junit-Tests</strong> . </li><li>  <strong>Wir ber√ºcksichtigen die Codeabdeckung</strong> , da wir die Tests ausf√ºhren. </li></ul><br>  Um zu verstehen, wie diese √úberpr√ºfungen ausgef√ºhrt werden sollen, schauen wir uns den Entwicklungsprozess in Avito an. <br><br>  Schematisch kann es wie folgt dargestellt werden: <br><br><ul><li>  Der Entwickler schreibt den Code auf seinen Laptop.  Hier k√∂nnen Sie Integrationspr√ºfungen ausf√ºhren - entweder mit einem Commit-Hook oder einfach √úberpr√ºfungen im Hintergrund. </li><li>  Nachdem der Entwickler den Code ausgef√ºhrt hat, √∂ffnet er die Pull-Anforderung.  Damit sein Code in den Entwicklungszweig gelangt, m√ºssen Sie eine Code√ºberpr√ºfung durchf√ºhren und die erforderliche Anzahl von Best√§tigungen sammeln.  Hier k√∂nnen Sie Pr√ºfungen und Builds aktivieren: Bis alle Builds erfolgreich sind, kann die Pull-Anforderung nicht zusammengef√ºhrt werden. </li><li>  Nachdem die Pull-Anforderung zusammengef√ºhrt und der Code entwickelt wurde, k√∂nnen Sie einen geeigneten Zeitpunkt ausw√§hlen: Zum Beispiel nachts, wenn alle Server frei sind, und Laufwerkspr√ºfungen nach Ihren W√ºnschen. </li></ul><br>  Niemand mochte es, Tests auf seinem Laptop durchzuf√ºhren.  Wenn der Entwickler die Funktion beendet hat, m√∂chte er sie schnell starten und die Pull-Anforderung √∂ffnen.  Wenn in diesem Moment einige lange √úberpr√ºfungen gestartet werden, ist dies nicht nur nicht sehr angenehm, sondern verlangsamt auch die Entwicklung: W√§hrend der Laptop etwas √ºberpr√ºft, ist es unm√∂glich, normal daran zu arbeiten. <br><br>  Wir haben es wirklich gemocht, nachts Kontrollen durchzuf√ºhren, da es viel Zeit und Server gibt, k√∂nnen Sie einen Spaziergang machen.  Leider hat der Entwickler zu Beginn der Entwicklung des Feature-Codes bereits viel weniger Motivation, die von CI gefundenen Fehler zu beheben.  Ich fing regelm√§√üig an zu denken, als ich im Morgenbericht √ºber alle gefundenen Fehler nachdachte, dass ich sie irgendwann sp√§ter beheben w√ºrde, denn jetzt liegt in Jira eine coole neue Aufgabe, mit der ich gerade anfangen m√∂chte. <br><br>  Wenn die √úberpr√ºfungen die Pull-Anforderung blockieren, gibt es gen√ºgend Motivation, da der Code erst entwickelt wird, wenn die Builds gr√ºn werden, was bedeutet, dass die Aufgabe nicht abgeschlossen wird. <br><br>  Aus diesem Grund haben wir uns f√ºr diese Strategie entschieden: Nachts fahren wir die maximal m√∂glichen und kritischsten √úberpr√ºfungen und f√ºhren vor allem eine Pull-Anforderung aus.  Aber wir h√∂ren hier nicht auf - wir optimieren gleichzeitig die Geschwindigkeit, mit der Schecks bestanden werden, damit sie auf Pull-Anfrage vom Nachtmodus auf Schecks umschalten. <br><br>  Zu diesem Zeitpunkt waren alle unsere Assemblys schnell genug, sodass wir nur die ARC-Assembly, Junit-Tests und die Berechnung der Codeabdeckung in den Pull-Request-Blocker aufgenommen haben.  Sie schalteten es ein, √ºberlegten es sich und gaben die Codeabdeckung auf, weil sie dachten, wir brauchten es nicht. <br><br>  <strong><em>Wir haben zwei Tage gebraucht, um die grundlegende CI-Einrichtung abzuschlie√üen (im Folgenden ist eine vor√ºbergehende Sch√§tzung ungef√§hr, die f√ºr die Skalierung erforderlich ist).</em></strong> <br><br>  Danach begannen sie weiter zu √ºberlegen - √ºberpr√ºfen wir es richtig?  Starten wir Builds auf Pull-Anfrage korrekt? <br><br>  Wir haben den Build f√ºr das letzte Commit des Zweigs gestartet, mit dem die Pull-Anforderung ge√∂ffnet ist.  √úberpr√ºfungen dieses Commits k√∂nnen jedoch nur zeigen, dass der vom Entwickler geschriebene Code funktioniert.  Aber sie beweisen nicht, dass er nichts gebrochen hat.  Tats√§chlich m√ºssen Sie den Status des Entwicklungszweigs √ºberpr√ºfen, nachdem das Feature in ihn eingef√ºgt wurde. <br><br><img src="https://habrastorage.org/webt/g7/sw/gn/g7swgnopkxqajjm-73mz9oxwbng.png"><br><br>  Zu diesem <strong>Zweck haben</strong> wir ein einfaches Bash-Skript <strong>premerge.sh geschrieben:</strong> <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash set -e git fetch origin develop git merge origin/develop</span></span></code> </pre> <br>  Hier werden die neuesten √Ñnderungen aus der Entwicklung einfach abgerufen und in der aktuellen Branche zusammengef√ºhrt.  Wir haben das Skript premerge.sh als ersten Schritt aller Builds hinzugef√ºgt und begonnen, genau zu √ºberpr√ºfen, was wir wollen, dh <strong>Integration</strong> . <br><br>  <strong><em>Es dauerte drei Tage, um das Problem zu lokalisieren, eine L√∂sung zu finden und dieses Skript zu schreiben.</em></strong> <br><br>  Die Anwendung entwickelte sich, es tauchten immer mehr Aufgaben auf, das Team wuchs und premerge.sh lie√ü uns manchmal im Stich.  In der Entwicklung drangen widerspr√ºchliche Ver√§nderungen ein, die die Versammlung brachen. <br><br>  Ein Beispiel daf√ºr: <br><br><img src="https://habrastorage.org/webt/xc/dm/e-/xcdme-bg7rwxkmgip5pgh4hlc8u.png"><br><br>  Zwei Entwickler beginnen gleichzeitig mit dem S√§gen der Features A und B. Der Entwickler von Feature A entdeckt die nicht verwendete <code>answer()</code> Funktion im Projekt und entfernt sie wie ein guter Scout.  Gleichzeitig f√ºgt der Entwickler von Feature B dieser Funktion in seiner Filiale einen neuen Aufruf hinzu. <br><br>  Entwickler beenden die Arbeit und √∂ffnen gleichzeitig die Pull-Anfrage.  Builds starten, premerge.sh pr√ºft beide Pull-Anforderungen auf einen neuen Entwicklungsstatus - alle Pr√ºfungen sind gr√ºn.  Nachdem diese Pull-Anforderungsfunktionen A zusammengef√ºhrt wurden, werden die Pull-Anforderungsfunktionen B zusammengef√ºhrt ... Boom!  Entwicklungspausen, da im Entwicklungscode eine nicht vorhandene Funktion aufgerufen wird. <br><br><img src="https://habrastorage.org/webt/zk/im/_r/zkim_rji20ahq4fyztlnc-twxwi.png"><br><br>  Wenn Sie sich nicht entwickeln, ist dies eine <strong>lokale Katastrophe</strong> .  Das gesamte Team kann nichts sammeln und zum Testen geben. <br><br>  So kam es, dass ich am h√§ufigsten an Infrastrukturaufgaben beteiligt war: Analyse, Netzwerk, Datenbanken.  Das hei√üt, ich habe die Funktionen und Klassen geschrieben, die andere Entwickler verwenden.  Aus diesem Grund bin ich sehr oft in solche Situationen geraten.  Ich hatte sogar einmal so ein Bild. <br><br><img src="https://habrastorage.org/webt/xo/vj/6e/xovj6ea0xjjvuoxfgnrrhbskxta.jpeg"><br><br>  Da dies nicht zu uns passte, begannen wir Optionen zu erarbeiten, wie dies verhindert werden kann. <br><br><h2>  Wie man nicht bricht, entwickelt sich </h2><br>  Erste Option: <strong>Erstellen Sie alle Pull-Anforderungen neu, wenn Sie ein Upgrade entwickeln.</strong>  Wenn in unserem Beispiel eine Pull-Anforderung mit Feature A zum ersten Mal entwickelt wird, wird die Pull-Anforderung von Feature B neu erstellt, und dementsprechend schlagen √úberpr√ºfungen aufgrund eines Kompilierungsfehlers fehl. <br><br>  Um zu verstehen, wie lange es dauern wird, betrachten Sie ein Beispiel mit zwei PRs.  Wir √∂ffnen zwei PRs: zwei Builds, zwei Teststarts.  Nachdem die erste PR in die Entwicklung gegossen wurde, muss die zweite wieder aufgebaut werden.  Insgesamt erfordern zwei PR-Starts von Pr√ºfungen drei PRs: 2 + 1 = 3. <br><br>  Im Prinzip ist es normal.  Aber wir haben uns die Statistiken angesehen, und eine typische Situation in unserem Team waren 10 offene PRs. Die Anzahl der √úberpr√ºfungen ist die Summe der Fortschritte: 10 + 9 + ... + 1 = 55. Das hei√üt, um 10 PRs zu akzeptieren, m√ºssen Sie 55 Mal neu erstellen.  Und dies ist eine ideale Situation, wenn alle Pr√ºfungen beim ersten Mal bestanden werden und niemand eine zus√§tzliche Pull-Anforderung √∂ffnet, w√§hrend diese zehn verarbeitet werden. <br><br>  Stellen Sie sich einen Entwickler vor, der Zeit haben muss, um zuerst auf die Schaltfl√§che "Zusammenf√ºhren" zu klicken. Wenn dies von einem Nachbarn durchgef√ºhrt wird, m√ºssen Sie warten, bis alle Baugruppen erneut durchlaufen werden ... Nein, dies wird die Entwicklung nicht ernsthaft verlangsamen. <br><br>  Der zweite m√∂gliche Weg: <strong>Pull-Anfrage nach Code√ºberpr√ºfung sammeln.</strong>  √ñffnen Sie also die Pull-Anforderung, sammeln Sie die erforderliche Anzahl von Updates von Kollegen, korrigieren Sie die erforderlichen √Ñnderungen und f√ºhren Sie die Builds aus.  Wenn sie erfolgreich sind, wird die Pull-Anforderung mit der Entwicklung zusammengef√ºhrt.  In diesem Fall gibt es keine zus√§tzlichen Neustarts, aber das Feedback verlangsamt sich erheblich.  Wenn ich als Entwickler eine Pull-Anfrage √∂ffne, m√∂chte ich sofort sehen, ob er dies tun wird.  Wenn beispielsweise ein Test abst√ºrzt, m√ºssen Sie ihn schnell beheben.  Bei einem verz√∂gerten Build verlangsamt sich das Feedback, was die gesamte Entwicklung bedeutet.  Das passte auch nicht zu uns. <br><br>  Infolgedessen blieb nur die dritte Option √ºbrig - das <strong>Radfahren</strong> .  Unser gesamter Code und alle unsere Quellen werden im Repository des Bitbucket-Servers gespeichert.  Dementsprechend mussten wir ein Plugin f√ºr Bitbucket entwickeln. <br><br><img src="https://habrastorage.org/webt/kf/ye/yx/kfyeyxalmkommukvjics9uvinn4.png"><br><br>  Dieses Plugin √ºberschreibt den Pull-Request-Merge-Mechanismus.  Der Anfang ist Standard: PR wird ge√∂ffnet, alle Assemblys werden gestartet, die Code√ºberpr√ºfung wird bestanden.  Nachdem die Code√ºberpr√ºfung abgeschlossen ist und der Entwickler auf "Zusammenf√ºhren" klickt, √ºberpr√ºft das Plugin, auf welchen Status die Entwicklungspr√ºfungen ausgef√ºhrt wurden.  Wenn die Entwicklung nach dem Erstellen der Aktualisierung erfolgreich war, k√∂nnen Sie mit dem Plugin eine solche Pull-Anforderung nicht in den Hauptzweig einbinden.  Die Builds werden einfach relativ zur Neuentwicklung neu gestartet. <br><br><img src="https://habrastorage.org/webt/_v/_s/0z/_v_s0zaf1bjvxn8oiwekagtj37a.png"><br><br>  In unserem Beispiel mit widerspr√ºchlichen √Ñnderungen schlagen solche Builds aufgrund eines Kompilierungsfehlers fehl.  Dementsprechend muss der Entwickler von Feature B den Code korrigieren, die √úberpr√ºfungen neu starten, und das Plugin wendet die Pull-Anforderung automatisch an. <br><br>  Vor der Implementierung dieses Plugins hatten wir durchschnittlich 2,7 Testl√§ufe pro Pull-Anfrage.  Mit dem Plugin gab es 3.6 Starts.  Es hat uns gepasst. <br><br>  Es ist erw√§hnenswert, dass dieses Plugin einen Nachteil hat: Es startet den Build nur einmal neu.  Das hei√üt, es bleibt ein kleines Fenster, durch das sich widerspr√ºchliche √Ñnderungen entwickeln k√∂nnen.  Die Wahrscheinlichkeit daf√ºr ist jedoch nicht hoch, und wir haben diesen Kompromiss zwischen der Anzahl der Starts und der Wahrscheinlichkeit eines Ausfalls geschlossen.  Zwei Jahre lang schoss es nur einmal, daher wahrscheinlich nicht umsonst. <br><br>  <strong><em>Wir haben zwei Wochen gebraucht, um die erste Version des Plugins f√ºr Bitbucket zu schreiben.</em></strong> <br><br><h3>  Neue Schecks </h3><br>  Inzwischen ist unser Team weiter gewachsen.  Neue Schecks wurden hinzugef√ºgt. <br><br>  Wir dachten: Warum Fehler reparieren, wenn sie verhindert werden k√∂nnen?  Und so f√ºhrten sie eine <strong>statische Code-Analyse ein</strong> .  Wir haben mit Flusen begonnen, die im Android SDK enthalten sind.  Zu diesem Zeitpunkt wusste er jedoch √ºberhaupt nicht, wie man mit Kotlin-Code arbeitet, und wir haben bereits 75% der Anwendung in Kotlin geschrieben.  Daher wurden Flusen integrierte <strong>Android Studio-√úberpr√ºfungen</strong> hinzugef√ºgt <strong>.</strong> <br><br>  Dazu musste ich sehr pervers sein: Nehmen Sie Android Studio, packen Sie es in Docker und f√ºhren Sie es auf CI mit einem virtuellen Monitor aus, sodass es glaubte, auf einem realen Laptop zu laufen.  Aber es hat funktioniert. <br><br>  Zu dieser Zeit haben wir auch begonnen, viele <strong>Instrumentierungstests</strong> zu schreiben und <strong>Screenshot-</strong> <strong>Tests</strong> durchzuf√ºhren.  In diesem Fall wird ein Referenz-Screenshot f√ºr eine separate kleine Ansicht generiert, und der Test besteht darin, dass ein Screenshot aus der Ansicht entnommen und Pixel f√ºr Pixel direkt mit der Referenz verglichen wird.  Wenn es eine Diskrepanz gibt, bedeutet dies, dass ein Layout irgendwohin gegangen ist oder etwas in den Stilen nicht stimmt. <br><br>  Instrumentierungstests und Screenshot-Tests m√ºssen jedoch auf Ger√§ten ausgef√ºhrt werden: auf Emulatoren oder auf realen Ger√§ten.  Angesichts der Tatsache, dass es viele Tests gibt und diese h√§ufig durchgef√ºhrt werden, ben√∂tigen Sie eine ganze Farm.  Es ist zu m√ºhsam, eine eigene Farm zu gr√ºnden. Deshalb haben wir eine vorgefertigte Option gefunden - Firebase Test Lab. <br><br><h3>  Firebase-Testlabor </h3><br>  Es wurde ausgew√§hlt, weil Firebase ein Google-Produkt ist, das hei√üt, es muss zuverl√§ssig sein und es ist unwahrscheinlich, dass es jemals stirbt.  Die Preise sind erschwinglich: 5 USD pro Stunde f√ºr ein echtes Ger√§t, 1 USD pro Stunde f√ºr einen Emulator. <br><br>  <strong><em>Die Implementierung des Firebase-Testlabors in unserem CI dauerte ungef√§hr drei Wochen.</em></strong> <br><br>  Aber das Team wuchs weiter und Firebase begann uns leider im Stich zu lassen.  Zu diesem Zeitpunkt hatte er keine SLA.  Manchmal lie√ü uns Firebase warten, bis die erforderliche Anzahl von Ger√§ten f√ºr Tests frei wurde, und begann nicht sofort, sie auszuf√ºhren, wie wir es wollten.  Das Warten in der Schlange dauerte bis zu einer halben Stunde, und das ist eine sehr lange Zeit.  Instrumentierungstests wurden bei jeder PR durchgef√ºhrt, Verz√∂gerungen verlangsamten die Entwicklung erheblich, und dann kam eine monatliche Rechnung mit einer runden Summe.  Im Allgemeinen wurde beschlossen, Firebase aufzugeben und im eigenen Haus zu sehen, da das Team genug gewachsen ist. <br><br><h3>  Docker + Python + Bash </h3><br>  Wir haben Docker genommen, Emulatoren hineingestopft, ein einfaches Python-Programm geschrieben, das zur richtigen Zeit die richtige Anzahl von Emulatoren in der richtigen Version erh√∂ht und sie bei Bedarf stoppt.  Und nat√ºrlich ein paar Bash-Skripte - wo ohne sie? <br><br>  <strong><em>Die Erstellung unserer eigenen Testumgebung dauerte f√ºnf Wochen.</em></strong> <br><br>  Infolgedessen verf√ºgte jede Pull-Anforderung √ºber eine umfangreiche, blockierende Zusammenf√ºhrungsliste von √úberpr√ºfungen: <br><br><ul><li>  Versammlung des ARC; </li><li>  Junit-Tests </li><li>  Fussel; </li><li>  Android Studio pr√ºft; </li><li>  Instrumentierungstests; </li><li>  Screenshot-Tests. </li></ul><br>  Dies verhinderte viele m√∂gliche Ausf√§lle.  Technisch hat alles funktioniert, aber die Entwickler haben sich beschwert, dass das Warten auf die Ergebnisse zu lang war. <br><br>  Zu viel ist wie viel?  Wir haben die Daten von Bitbucket und TeamCity in das Analysesystem hochgeladen und festgestellt, dass die <strong>durchschnittliche Wartezeit 45 Minuten betr√§gt</strong> .  Das hei√üt, ein Entwickler, der eine Pull-Anfrage √∂ffnet, erwartet im Durchschnitt Build-Ergebnisse von 45 Minuten.  Meiner Meinung nach ist das eine Menge, und so kann man nicht arbeiten. <br><br>  Nat√ºrlich haben wir uns entschlossen, alle unsere Builds zu beschleunigen. <br><br><h2>  Beschleunigen Sie </h2><br>  Angesichts der Tatsache, dass h√§ufig Builds im Einklang stehen, haben wir als erstes <strong>Eisen gekauft</strong> - eine umfassende Entwicklung ist am einfachsten.  Builds standen nicht mehr in der Schlange, aber die Wartezeit verk√ºrzte sich nur geringf√ºgig, da einige Schecks f√ºr sich selbst sehr lange nachjagten. <br><br><h3>  Wir entfernen zu lange Schecks </h3><br>  Unsere kontinuierliche Integration k√∂nnte diese Art von Fehlern und Problemen erkennen. <br><br><ul><li>  <strong>Ich werde nicht gehen</strong> .  CI kann einen Kompilierungsfehler abfangen, wenn aufgrund widerspr√ºchlicher √Ñnderungen etwas nicht funktioniert.  Wie gesagt, dann kann niemand etwas sammeln, die Entwicklung steigt und jeder wird nerv√∂s. </li><li>  <strong>Ein Fehler im Verhalten</strong> .  Zum Beispiel, wenn die Anwendung erstellt wird, aber wenn Sie auf die Schaltfl√§che klicken, st√ºrzt sie ab oder die Schaltfl√§che wird √ºberhaupt nicht gedr√ºckt.  Dies ist schlecht, da ein solcher Fehler den Benutzer erreichen kann. </li><li>  <strong>Fehler im Layout</strong> .  Beispielsweise wird eine Taste gedr√ºckt, aber 10 Pixel nach links verschoben. </li><li>  <strong>Zunahme der technischen Verschuldung</strong> . </li></ul><br>  Bei Betrachtung dieser Liste haben wir festgestellt, dass nur die ersten beiden Punkte kritisch sind.  Wir wollen solche Probleme zuallererst auffangen.  Fehler im Layout werden in der Entwurfs√ºberpr√ºfungsphase erkannt und dann einfach behoben.  Die Arbeit mit technischen Schulden erfordert einen separaten Prozess und eine separate Planung. Daher haben wir beschlossen, diese nicht auf Pull-Anforderungen zu √ºberpr√ºfen. <br><br>  Basierend auf dieser Klassifizierung haben wir die gesamte Liste der Schecks durcheinander gebracht.  <strong>Lint durchgestrichen</strong> und der Start f√ºr die Nacht verschoben: Nur damit ein Bericht dar√ºber ver√∂ffentlicht wird, wie viele Probleme das Projekt hat.  Wir waren uns einig, separat mit den technischen Schulden zu arbeiten, <strong>lehnten jedoch Android Studio-Pr√ºfungen vollst√§ndig ab</strong> .  Das Android Studio von Docker zum Starten von Inspektionen klingt interessant, bringt jedoch gro√üe Probleme bei der Unterst√ºtzung mit sich.  Jedes Update auf Android Studio-Versionen ist ein Kampf gegen obskure Fehler.  Es war auch schwierig, Screenshot-Tests durchzuf√ºhren, da die Bibliothek nicht sehr stabil funktionierte und es falsch positive Ergebnisse gab.  <strong>Screenshot-Tests wurden aus der Liste der Pr√ºfungen entfernt</strong> . <br><br>  Als Ergebnis haben wir verlassen: <br><br><ul><li>  Versammlung des ARC; </li><li>  Junit-Tests </li><li>  Instrumentierungstests. </li></ul><br><br><h3>  Gradle Remote-Cache </h3><br>  Ohne schwere Kontrollen wurde es besser.  Der Perfektion sind jedoch keine Grenzen gesetzt! <br><br>  Unsere Anwendung wurde bereits in ca. 150 Gradle-Module aufgeteilt.  In diesem Fall funktioniert der Gradle-Remote-Cache normalerweise gut, und wir haben uns entschlossen, es zu versuchen. <br><br>  Gradle Remote Cache ist ein Dienst, der Build-Artefakte f√ºr einzelne Aufgaben in separaten Modulen zwischenspeichern kann.  Anstatt den Code tats√§chlich zu kompilieren, st√∂√üt Gradle den Remote-Cache √ºber HTTP um und fragt, ob jemand diese Aufgabe bereits ausgef√ºhrt hat.  Wenn ja, laden Sie einfach das Ergebnis herunter. <br><br>  <strong><em>Das Starten des Remote-Cache von Gradle ist einfach, da Gradle ein Docker-Image bereitstellt.</em></strong>  <strong><em>Das haben wir in drei Stunden geschafft.</em></strong> <br><br>  Sie mussten lediglich Docker starten und eine Zeile im Projekt registrieren.  Obwohl Sie es schnell starten k√∂nnen, damit alles gut funktioniert, wird es viel Zeit in Anspruch nehmen. <br><br>  Unten sehen Sie eine Grafik mit Cache-Fehlern. <br><br><img src="https://habrastorage.org/webt/je/0j/an/je0jansmt1nkhgiqhwybnmc2_fs.png"><br><br>  Zu Beginn betrug der Prozentsatz der Fehler nach dem Cache etwa 65. Drei Wochen sp√§ter gelang es uns, diesen Wert auf 20% zu bringen.  Es stellte sich heraus, dass die Aufgaben, die die Android-Anwendung sammelt, seltsame transitive Abh√§ngigkeiten aufweisen, aufgrund derer Gradle den Cache √ºbersehen hat. <br><br>  Durch das Verbinden des Caches haben wir die Assembly erheblich beschleunigt.  Aber abgesehen von der Montage jagen Instrumentierungstests immer noch und sie jagen lange.  M√∂glicherweise m√ºssen nicht alle Tests f√ºr jede Pull-Anforderung verfolgt werden.  Um dies herauszufinden, verwenden wir eine Wirkungsanalyse. <br><br><h3>  Wirkungsanalyse </h3><br>  Auf Pull-Anfrage bauen wir Git Diff und finden die modifizierten Gradle-Module. <br><br><img src="https://habrastorage.org/webt/yg/xn/ki/ygxnkisjdskb-qkqxoccaywcu5a.png"><br><br>  Es ist sinnvoll, nur die Instrumentierungstests durchzuf√ºhren, die modifizierte Module und alle davon abh√§ngigen Module testen.  Es macht keinen Sinn, Tests f√ºr benachbarte Module durchzuf√ºhren: Der Code hat sich dort nicht ge√§ndert, und nichts kann kaputt gehen. <br><br>  Instrumentierungstests sind nicht so einfach, da sie sich im Anwendungsmodul der obersten Ebene befinden m√ºssen.  Wir haben eine Heuristik zur Bytecode-Analyse angewendet, um zu verstehen, zu welchem ‚Äã‚ÄãModul jeder Test geh√∂rt. <br><br>  <strong><em>Das Upgrade der Instrumentierungstests dauerte ungef√§hr acht Wochen, um nur die beteiligten Module zu testen.</em></strong> <br><br>  Ma√ünahmen zur Beschleunigung der √úberpr√ºfung haben erfolgreich funktioniert.  Ab 45 Minuten erreichten wir ungef√§hr 15. Eine Viertelstunde, um auf den Bau zu warten, ist bereits normal. <br><br>  Aber jetzt haben die Entwickler angefangen sich zu beschweren, dass ihnen nicht klar ist, welche Builds gestartet werden, wo das Protokoll aussehen wird, warum der Build rot ist, welcher Test gefallen ist usw. <br><br><img height="487" src="https://habrastorage.org/webt/ez/ev/wl/ezevwlalp50tf9bcret2aff7fte.png"><br><br>  Feedback-Probleme verlangsamen die Entwicklung, daher haben wir versucht, die verst√§ndlichsten und detailliertesten Informationen zu jedem PR und Build bereitzustellen.  Wir haben mit Kommentaren zu Bitbucket f√ºr PR begonnen, die angeben, welcher Build gefallen ist und warum, und gezielte Nachrichten in Slack geschrieben haben.  Am Ende erstellten sie ein Dashboard f√ºr die PR-Seite mit einer Liste aller derzeit ausgef√ºhrten Builds und ihrem Status: In Linie, Start, Absturz oder Ende.  Sie k√∂nnen auf den Build klicken und zu dessen Protokoll gelangen. <br><br><img src="https://habrastorage.org/webt/d5/hu/fr/d5hufrypmfupj3g8k4snhrksy9w.png"><br><br>  <strong><em>Sechs Wochen wurden f√ºr detailliertes Feedback aufgewendet.</em></strong> <br><br><h2>  Pl√§ne </h2><br>  Wir gehen zur neuesten Geschichte √ºber.  Nachdem wir die Frage des Feedbacks gel√∂st hatten, gingen wir auf eine neue Ebene - wir beschlossen, eine eigene Farm von Emulatoren zu bauen.  Wenn es viele Tests und Emulatoren gibt, sind sie schwer zu verwalten.  Infolgedessen sind alle unsere Emulatoren in einen k8s-Cluster mit flexiblem Ressourcenmanagement umgezogen. <br><br>  Dar√ºber hinaus gibt es weitere Pl√§ne. <br><br><ul><li>  <strong>Return Lint</strong> (und andere statische Analysen).  Wir arbeiten bereits in diese Richtung. </li><li>  F√ºhren Sie alle <strong>End-to-End-Tests</strong> auf dem PR-Blocker in allen Versionen des SDK aus. </li></ul><br>  Wir haben also die Geschichte der Entwicklung der kontinuierlichen Integration in Avito nachverfolgt.  Jetzt m√∂chte ich einige Ratschl√§ge aus der Sicht der Erfahrenen geben. <br><br><h1>  Tipps </h1><br>  Wenn ich nur einen Rat geben k√∂nnte, w√§re dies folgender: <br><br><blockquote>  Bitte seien Sie vorsichtig mit Shell-Skripten! </blockquote><br>  Bash ist ein sehr flexibles und leistungsstarkes Tool. Es ist sehr bequem und schnell, Skripte darauf zu schreiben.  Aber mit ihm kann man in die Falle tappen, und wir sind leider hineingefallen. <br><br>  Alles begann mit einfachen Skripten, die auf unseren Build-Maschinen ausgef√ºhrt wurden: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash ./gradlew assembleDebug</span></span></code> </pre> <br>  Aber wie Sie wissen, entwickelt sich alles und wird mit der Zeit kompliziert - lassen Sie uns ein Skript von einem anderen ausf√ºhren, lassen Sie uns dort einige Parameter √ºbergeben - am Ende musste ich eine Funktion schreiben, die bestimmt, auf welcher Ebene der Verschachtelung wir jetzt sind, um die erforderlichen Anf√ºhrungszeichen zu ersetzen. damit alles beginnt. <br><br><img src="https://habrastorage.org/webt/rt/o6/vp/rto6vp4hs-ucbefd_3pbzehvx0a.png"><br><br>  Sie k√∂nnen sich vorstellen, wie viel Arbeit mit der Entwicklung solcher Skripte verbunden ist.  Ich rate Ihnen, nicht in diese Falle zu tappen. <br><br>  Was kann ersetzt werden? <br><br><ul><li>  Beliebige Skriptsprache.  Das Schreiben in <strong>Python- oder Kotlin-</strong> Skripten <strong>ist</strong> bequemer, da es sich um Programmierung und nicht um Skripte handelt. </li><li>  Oder beschreiben Sie die gesamte Erstellungslogik in Form von <strong>benutzerdefinierten Gradle-Aufgaben</strong> f√ºr Ihr Projekt. </li></ul><br>  Wir haben uns f√ºr die zweite Option entschieden und l√∂schen nun systematisch alle Bash-Skripte und schreiben viele benutzerdefinierte Gradle-Shuffles. <br><br>  <strong>Tipp 2: Halten Sie Ihre Infrastruktur im Code.</strong> <br><br>  Dies ist praktisch, wenn die Continuous Integration-Konfiguration nicht in der Jenkins- oder TeamCity-Benutzeroberfl√§che usw., sondern als Textdateien direkt im Projekt-Repository gespeichert wird.  Dies gibt die Versionsf√§higkeit.  Es wird nicht schwierig sein, Code in einem anderen Zweig zur√ºckzusetzen oder zu sammeln. <br><br>  Skripte k√∂nnen im Projekt gespeichert werden.  Und was tun mit der Umwelt? <br><br>  <strong>Tipp 3: Docker kann der Umwelt helfen.</strong> <br><br>  Es wird definitiv Android-Entwicklern helfen, iOS leider noch nicht. <br><br>  Dies ist ein Beispiel f√ºr eine einfache Docker-Datei, die jdk und android-sdk enth√§lt: <br><br><pre> <code class="plaintext hljs">FROM openjdk:8 ENV SDK_URL="https://dl.google.com/android/repository/sdk-tools-linux-3859397.zip" \ ANDROID_HOME="/usr/local/android-sdk" \ ANDROID_VERSION=26 \ ANDROID_BUILD_TOOLS_VERSION=26.0.2 # Download Android SDK RUN mkdir "$ANDROID_HOME" .android \ &amp;&amp; cd "$ANDROID_HOME" \ &amp;&amp; curl -o sdk.zip $SDK_URL \ &amp;&amp; unzip sdk.zip \ &amp;&amp; rm sdk.zip \ &amp;&amp; yes | $ANDROID_HOME/tools/bin/sdkmanager --licenses # Install Android Build Tool and Libraries RUN $ANDROID_HOME/tools/bin/sdkmanager --update RUN $ANDROID_HOME/tools/bin/sdkmanager "build-tools;${ANDROID_BUILD_TOOLS_VERSION}" \ "platforms;android-${ANDROID_VERSION}" \ "platform-tools" RUN mkdir /application WORKDIR /application</code> </pre><br>  Nachdem Sie diese Docker-Datei geschrieben haben (ich werde Ihnen ein Geheimnis verraten, Sie k√∂nnen sie nicht schreiben, sondern aus GitHub herausholen) und das Image sammeln, erhalten Sie eine virtuelle Maschine, auf der Sie die Anwendung erstellen und Junit-Tests ausf√ºhren k√∂nnen. <br><br>  Die beiden Hauptargumente, warum dies sinnvoll ist, sind Skalierbarkeit und Wiederholbarkeit.  Mit Docker k√∂nnen Sie schnell ein Dutzend Build-Agenten aufrufen, die genau dieselbe Umgebung wie die alte haben.  Dies erleichtert CI-Ingenieuren das Leben.  Android-SDK in Docker zu schieben ist ganz einfach, mit Emulatoren etwas komplizierter: Sie m√ºssen ein wenig trainieren (naja, oder laden Sie das fertige erneut von GitHub herunter). <br><br>  <strong>Tipp Nummer 4: Vergessen Sie nicht, dass die √úberpr√ºfungen nicht zum Zwecke der √úberpr√ºfung, sondern f√ºr Personen durchgef√ºhrt werden.</strong> <br><br>  Schnelles und vor allem klares Feedback ist f√ºr Entwickler sehr wichtig: Was sie kaputt gemacht haben, welcher Test gefallen ist, wo das Build-Protokoll. <br><br>  <strong>Tipp 5: Seien Sie pragmatisch bei der kontinuierlichen Integration.</strong> <br><br>  Verstehen Sie genau, welche Arten von Fehlern Sie verhindern m√∂chten, wie viel Sie bereit sind, Ressourcen, Zeit und Computerzeit aufzuwenden.  Zu lange Schecks k√∂nnen beispielsweise √ºber Nacht verschoben werden.  Und diejenigen, die nicht sehr wichtige Fehler fangen, sollten v√∂llig aufgegeben werden. <br><br>  <strong>Tipp 6: Verwenden Sie vorgefertigte Werkzeuge.</strong> <br><br>  Mittlerweile gibt es viele Unternehmen, die Cloud-CI anbieten. <br><br><img src="https://habrastorage.org/webt/7a/dr/k3/7adrk3z_1xnccybehwal8sfi-pi.png"><br><br>  F√ºr kleine Teams ist dies ein guter Ausweg.  Sie m√ºssen nichts warten, nur etwas Geld bezahlen, Ihre Bewerbung abholen und sogar Instrumentierungstests durchf√ºhren. <br><br>  <strong>Tipp 7: In einem gro√üen Team sind interne L√∂sungen rentabler.</strong> <br><br>  Aber fr√ºher oder sp√§ter werden mit dem Wachstum des Teams rentablere interne L√∂sungen.  Bei diesen Entscheidungen gibt es einen Punkt.  In der Wirtschaft gibt es ein Gesetz zur Verringerung der Rendite: In jedem Projekt wird jede nachfolgende Verbesserung immer schwieriger, erfordert immer mehr Investitionen. <br><br>  Die Wirtschaft beschreibt unser ganzes Leben, einschlie√ülich der kontinuierlichen Integration.  Ich habe f√ºr jede Phase unserer kontinuierlichen Integrationsentwicklung einen Arbeitsplan erstellt. <br><br><img src="https://habrastorage.org/webt/es/za/8w/esza8woeimanj5auez2iz9js7di.png"><br><br>  Es ist ersichtlich, dass jede Verbesserung immer schwieriger wird.  Wenn wir uns dieses Diagramm ansehen, k√∂nnen wir verstehen, dass die Entwicklung der kontinuierlichen Integration mit dem Wachstum der Teamgr√∂√üe vereinbar sein muss.  F√ºr ein Zwei-Personen-Team ist es eine mittelm√§√üige Idee, 50 Tage lang eine interne Emulatorfarm zu entwickeln.  Gleichzeitig ist es f√ºr ein gro√ües Team jedoch auch eine schlechte Idee, die kontinuierliche Integration √ºberhaupt nicht durchzuf√ºhren, da Integrationsprobleme auftreten, die Kommunikation repariert wird usw.  es wird noch l√§nger dauern. <br><br>  Wir haben mit der Tatsache begonnen, dass Automatisierung erforderlich ist, weil Menschen teuer, falsch und faul sind.  Menschen automatisieren aber auch.  Daher gelten alle diese Probleme auch f√ºr die Automatisierung. <br><br><ul><li>  Automatisieren ist teuer.  Denken Sie an den Arbeitsplan. </li><li>  In der Automatisierung machen Menschen Fehler. </li><li>  Automatisierung ist manchmal sehr faul, weil alles so funktioniert.  Warum noch verbessern, warum all diese kontinuierliche Integration? </li></ul><br>     :  20%   .     ,      .  ,   , ,    - ,     develop,    . ,           ,    -   . <br><br> <strong> Continuous Integration.   .</strong> <br><br><blockquote> ,        ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AppsConf</a>        .            <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> .     22-23   . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447608/">https://habr.com/ru/post/de447608/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447592/index.html">WhatsApp in Ihrer Handfl√§che: Wo und wie k√∂nnen Sie forensische Artefakte erkennen?</a></li>
<li><a href="../de447594/index.html">Kundenspezifische Instrumente: Wenn der Wegweiser nicht ausreicht</a></li>
<li><a href="../de447598/index.html">Schreiben eines Speicherkartenspiels auf Swift</a></li>
<li><a href="../de447604/index.html">Glatte Z√§hne, C ++ und Mathematik - wie h√§ngen sie zusammen? Gespr√§ch mit Align</a></li>
<li><a href="../de447606/index.html">CLRium # 5 Garbage Collector: Peter - Ausverkauft</a></li>
<li><a href="../de447610/index.html">So √ºbernehmen Sie die Kontrolle √ºber Ihre Netzwerkinfrastruktur. Kapitel Drei Netzwerksicherheit. Teil drei</a></li>
<li><a href="../de447612/index.html">Weltraum-Rechenzentrum. Text√ºbersetzung des Serverstarts in die Stratosph√§re</a></li>
<li><a href="../de447614/index.html">Sie k√∂nnen dieses Problem im Interview nicht l√∂sen</a></li>
<li><a href="../de447616/index.html">Anschlie√üen von Aquastorozh an Smart Home auf Z-Wave</a></li>
<li><a href="../de447618/index.html">In der Kanopy-Streaming-Service-Datenbank wurden bis zu 40 Millionen Protokolleintr√§ge zu Filmen ver√∂ffentlicht, die von Benutzern angesehen wurden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>