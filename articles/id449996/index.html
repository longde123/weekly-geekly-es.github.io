<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎿 👩‍🏫 🖖🏾 Memahami Algoritma FFT 🥑 ⏳ 🤟🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo teman-teman. Kursus Algoritma untuk Pengembang dimulai besok, dan kami masih memiliki satu terjemahan yang tidak diterbitkan. Sebenarnya kami mem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memahami Algoritma FFT</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/449996/"> Halo teman-teman.  Kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Algoritma untuk Pengembang</a> dimulai besok, dan kami masih memiliki satu terjemahan yang tidak diterbitkan.  Sebenarnya kami memperbaiki dan berbagi materi dengan Anda.  Ayo pergi. <br><br>  Fast Fourier Transform (FFT) adalah salah satu algoritma pemrosesan sinyal dan analisis data yang paling penting.  Saya menggunakannya selama bertahun-tahun tanpa pengetahuan formal dalam ilmu komputer.  Tapi minggu ini terpikir oleh saya bahwa saya tidak pernah bertanya-tanya bagaimana FFT menghitung transformasi Fourier diskrit begitu cepat.  Saya menyingkirkan debu dari sebuah buku tua tentang algoritma, membukanya, dan membaca dengan senang hati trik komputasi yang tampak sederhana yang dijelaskan oleh J.V. Cooley dan John Tukey dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">karya</a> klasik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1965</a> mereka tentang topik ini. <br><br><img src="https://habrastorage.org/webt/n4/54/6k/n4546kuwmamg91yhazlpndgglh4.png"><br><br>  Tujuan dari posting ini adalah untuk terjun ke dalam algoritma FFT Cooley-Tukey, menjelaskan simetri yang mengarah padanya, dan menunjukkan beberapa implementasi Python sederhana yang menerapkan teori dalam praktek.  Saya berharap bahwa penelitian ini akan memberikan spesialis analisis data, seperti saya, gambaran yang lebih lengkap tentang apa yang terjadi di bawah kap algoritma yang kami gunakan. <a name="habracut"></a><br><br>  <b>Discrete Fourier Transform</b> <br><br>  FFT cepat <img src="https://habrastorage.org/webt/bq/s0/ah/bqs0ahni9guseo62jp5hvz3e4x8.png">  sebuah algoritma untuk menghitung transformasi Fourier diskrit (DFT), yang dihitung secara langsung untuk <img src="https://habrastorage.org/webt/ys/jt/e9/ysjte98k7mfch0w1mttpu5fqnbg.png">  .  DFT, seperti versi berkelanjutan dari transformasi Fourier yang lebih akrab, memiliki bentuk langsung dan terbalik, yang didefinisikan sebagai berikut: <br><br>  <i><b>Direct Discrete Fourier Transform (DFT):</b></i> <br><br><img src="https://habrastorage.org/webt/uj/sh/qc/ujshqcnsbasvypykupwcjocfbcg.png"><br><br>  <i><b>Invers Discrete Fourier Transform (ODPF):</b></i> <br><br><img src="https://habrastorage.org/webt/zg/dp/0t/zgdp0tdylocjv_ck6a0y6m97ac8.png"><br><br>  Konversi dari <code>xn → Xk</code> adalah terjemahan dari ruang konfigurasi ke ruang frekuensi dan dapat sangat berguna untuk mempelajari spektrum daya sinyal dan untuk mengkonversi tugas-tugas tertentu untuk perhitungan yang lebih efisien.  Anda dapat menemukan beberapa contoh dari tindakan ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bab 10 buku masa depan kami</a> tentang astronomi dan statistik, di mana Anda juga dapat menemukan gambar dan kode sumber Python.  Untuk contoh menggunakan FFT untuk menyederhanakan integrasi persamaan diferensial yang rumit, lihat posting saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Memecahkan persamaan Schrödinger dengan Python"</a> . <br><br>  Karena pentingnya FFT (selanjutnya FFT setara - Fast Fourier Transform dapat digunakan) di banyak area Python berisi banyak alat standar dan cangkang untuk menghitungnya.  Baik NumPy dan SciPy memiliki cangkang dari pustaka FFTPACK yang teruji sangat baik, yang masing-masing terletak di <code>scipy.fftpack</code> dan <code>scipy.fftpack</code> .  FFT tercepat yang saya tahu adalah dalam paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FFTW</a> , yang juga tersedia dalam Python melalui paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PyFFTW</a> . <br><br>  Untuk saat ini, mari kita tinggalkan implementasi ini dan bertanya-tanya bagaimana kita dapat menghitung FFT dengan Python dari awal. <br><br>  <b>Perhitungan Transformasi Fourier Diskrit</b> <br><br>  Untuk kesederhanaan, kami hanya akan berurusan dengan konversi langsung, karena transformasi terbalik dapat diimplementasikan dengan cara yang sangat mirip.  Melihat ekspresi DFT di atas, kita melihat bahwa ini tidak lebih dari operasi linear langsung: mengalikan matriks dengan vektor <br><br><img src="https://habrastorage.org/webt/mg/qb/es/mgqbesmhfu6rqoztm33y2o6dpd0.png"><br><br><img src="https://habrastorage.org/webt/zi/1a/t2/zi1at2pha9pp2xtnu_if6cps-xe.png"><br><br>  dengan matriks M diberikan <br><br><img src="https://habrastorage.org/webt/ox/ka/mc/oxkamcki5i2fn5nqafbue7phkki.png"><br><br>  Dengan mengingat hal ini, kita dapat menghitung DFT menggunakan perkalian matriks sederhana sebagai berikut: <br><br>  Dalam [1]: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DFT_slow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Compute the discrete Fourier Transform of the 1D array x"""</span></span> x = np.asarray(x, dtype=float) N = x.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>] n = np.arange(N) k = n.reshape((N, <span class="hljs-number"><span class="hljs-number">1</span></span>)) M = np.exp(<span class="hljs-number"><span class="hljs-number">-2j</span></span> * np.pi * k * n / N) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> np.dot(M, x)</code> </pre> <br>  Kami dapat memeriksa hasilnya dengan membandingkannya dengan fungsi FFT yang dibangun di numpy: <br><br>  Dalam [2]: <br><br><pre> <code class="python hljs">x = np.random.random(<span class="hljs-number"><span class="hljs-number">1024</span></span>) np.allclose(DFT_slow(x), np.fft.fft(x))</code> </pre> <br>  0ut [2]: <br><br> <code>True</code> <br> <br>  Hanya untuk mengkonfirmasi lambatnya algoritme kami, kami dapat membandingkan waktu eksekusi dari dua pendekatan ini: <br><br>  Dalam [3]: <br><br><pre> <code class="python hljs">%timeit DFT_slow(x) %timeit np.fft.fft(x)</code> </pre> <br><pre> <code class="plaintext hljs">10 loops, best of 3: 75.4 ms per loop 10000 loops, best of 3: 25.5 µs per loop</code> </pre> <br>  Kami lebih dari 1000 kali lebih lambat, yang diharapkan untuk implementasi yang disederhanakan.  Tapi ini bukan yang terburuk.  Untuk vektor input dengan panjang N, algoritma FFT berskala sebagai <img src="https://habrastorage.org/webt/ee/qz/zq/eeqzzqrjiwlvtmh8qgpmsa5g_lm.png">  sedangkan algoritma lambat kami seperti skala <img src="https://habrastorage.org/webt/qk/or/aw/qkoraw_lw5tjqyhr1ubbvmvx0i4.png">  .  Ini berarti untuk <img src="https://habrastorage.org/webt/8s/bu/zi/8sbuziwl0cyxjezr0qezsvibrpo.png">  elemen, kami berharap FFT selesai dalam waktu sekitar 50 ms, sementara algoritma lambat kami akan memakan waktu sekitar 20 jam! <br><br>  Jadi bagaimana FFT mencapai akselerasi seperti itu?  Jawabannya adalah menggunakan simetri. <br><br>  <b>Simetri dalam transformasi Fourier diskrit</b> <br><br>  Salah satu alat paling penting dalam membangun algoritma adalah penggunaan simetri tugas.  Jika Anda dapat menunjukkan secara analitis bahwa satu bagian dari masalah hanya terkait dengan yang lain, Anda dapat menghitung hanya hasil satu kali dan menghemat biaya komputasi ini.  Cooley dan Tukey menggunakan pendekatan ini untuk mendapatkan FFT. <br>  Kita mulai dengan pertanyaan tentang makna <img src="https://habrastorage.org/webt/wv/vq/0t/wvvq0twerwsciysi5sgxfsnfooo.png">  .  Dari ungkapan kami di atas: <br><br><img src="https://habrastorage.org/webt/hd/el/f3/hdelf3dxco-xuar0bgic_ha89lu.png"><br><br>  di mana kami menggunakan exp identitas [2π dalam] = 1, yang berlaku untuk bilangan bulat apa pun n. <br><br>  Baris terakhir menunjukkan dengan baik properti simetri DFT: <br><br><img src="https://habrastorage.org/webt/ac/dz/wq/acdzwq4jwn4vizgzdafg3as6ila.png"><br><br>  Ekstensi sederhana <br><br><img src="https://habrastorage.org/webt/su/bl/c_/sublc_wuerprr4ppl_bqln89c24.png"><br><br>  untuk bilangan bulat apa pun i.  Seperti yang akan kita lihat di bawah, simetri ini dapat digunakan untuk menghitung DFT lebih cepat. <br><br>  <b>DFT di FFT: menggunakan simetri</b> <br><br>  Cooley dan Tukey menunjukkan bahwa perhitungan FFT dapat dibagi menjadi dua bagian yang lebih kecil.  Dari definisi DFT kami memiliki: <br><br><img src="https://habrastorage.org/webt/dg/lz/lm/dglzlmmd1oue7oqyn39gwavofva.png"><br><br>  Kami membagi satu transformasi Fourier diskrit menjadi dua istilah, yang dalam dirinya sendiri sangat mirip dengan transformasi Fourier diskrit yang lebih kecil, satu untuk nilai dengan angka ganjil dan satu untuk nilai dengan angka genap.  Namun, sejauh ini kami belum menyimpan siklus komputasi apa pun.  Setiap istilah terdiri dari (N / 2) ∗ N perhitungan, total <img src="https://habrastorage.org/webt/bg/lz/we/bglzwecwics3t1gful-oe5auipc.png">  . <br><br>  Caranya adalah dengan menggunakan simetri di setiap kondisi ini.  Karena rentang k adalah 0≤k &lt;N, dan kisaran n adalah 0≤n &lt;M≡N / 2, kita melihat dari properti simetri di atas bahwa kita perlu melakukan hanya setengah perhitungan untuk setiap subtugas.  Perhitungan kami <img src="https://habrastorage.org/webt/my/tx/pq/mytxpqv7swzpsqfbq5manbp7kme.png">  telah menjadi <img src="https://habrastorage.org/webt/6l/lv/ln/6llvlnumnlnndoir0whpg7qf_gc.png">  di mana M dua kali lebih kecil dari N. <br><br>  Tetapi tidak ada alasan untuk memikirkan hal ini: selama transformasi Fourier kami yang lebih kecil memiliki M yang genap, kami dapat menerapkan kembali pendekatan pembagian dan menaklukkan ini, setiap kali mengurangi separuh biaya komputasi, sampai array kami cukup kecil sehingga strategi tidak lagi menguntungkan.  Dalam batas asimptotik, pendekatan rekursif ini berskala sebagai O [NlogN]. <br><br>  Algoritma rekursif ini dapat diimplementasikan dengan sangat cepat dalam Python, mulai dari kode DFT kami yang lambat, ketika ukuran subtugas menjadi sangat kecil: <br><br>  Dalam [4]: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FFT</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""A recursive implementation of the 1D Cooley-Tukey FFT"""</span></span> x = np.asarray(x, dtype=float) N = x.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> N % <span class="hljs-number"><span class="hljs-number">2</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-string"><span class="hljs-string">"size of x must be a power of 2"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> N &lt;= <span class="hljs-number"><span class="hljs-number">32</span></span>: <span class="hljs-comment"><span class="hljs-comment"># this cutoff should be optimized return DFT_slow(x) else: X_even = FFT(x[::2]) X_odd = FFT(x[1::2]) factor = np.exp(-2j * np.pi * np.arange(N) / N) return np.concatenate([X_even + factor[:N / 2] * X_odd, X_even + factor[N / 2:] * X_odd])</span></span></code> </pre> <br><br>  Di sini kita akan melakukan pemeriksaan cepat bahwa algoritma kami memberikan hasil yang benar: <br>  Dalam [5]: <br><br><pre> <code class="python hljs">x = np.random.random(<span class="hljs-number"><span class="hljs-number">1024</span></span>) np.allclose(FFT(x), np.fft.fft(x))</code> </pre> <br><br>  Keluar [5]: <br> <code>True</code> <br> <br>  Bandingkan algoritma ini dengan versi lambat kami: <br>  -Dalam [6]: <br><br><pre> <code class="python hljs">%timeit DFT_slow(x) %timeit FFT(x) %timeit np.fft.fft(x)</code> </pre> <br><br><pre> <code class="plaintext hljs">10 loops, best of 3: 77.6 ms per loop 100 loops, best of 3: 4.07 ms per loop 10000 loops, best of 3: 24.7 µs per loop</code> </pre> <br>  Perhitungan kami lebih cepat daripada versi langsung!  Selain itu, algoritma rekursif kami asimtotik <img src="https://habrastorage.org/webt/ee/qz/zq/eeqzzqrjiwlvtmh8qgpmsa5g_lm.png">  : kami menerapkan transformasi Fourier cepat. <br><br>  Perhatikan bahwa kita masih tidak dekat dengan kecepatan algoritma FFT built-in numpy, dan ini harus diharapkan.  Algoritma FFTPACK di belakang <code>fft</code> numpy adalah implementasi Fortran yang telah menerima perbaikan dan optimasi selama bertahun-tahun.  Selain itu, solusi NumPy kami mencakup rekursi tumpukan Python dan alokasi banyak array sementara, yang meningkatkan waktu komputasi. <br><br>  Strategi yang baik untuk mempercepat kode ketika bekerja dengan Python / NumPy adalah membuat vektor kalkulasi berulang jika memungkinkan.  Kita bisa melakukan ini - dalam prosesnya, hapus panggilan fungsi rekursif kami, yang akan membuat FFT Python kami semakin efisien. <br><br>  <b>Versi Numpy Vektor</b> <br><br>  Harap dicatat bahwa dalam penerapan FFT rekursif di atas, pada tingkat rekursi terendah, kami melakukan produk vektor-matriks identik <b>N / 32</b> .  Efektivitas algoritma kami akan menang jika kami secara bersamaan menghitung produk-produk matriks-vektor ini sebagai produk matriks-matriks tunggal.  Pada setiap tingkat rekursi berikutnya, kami juga melakukan operasi berulang yang dapat di-vektor.  NumPy melakukan pekerjaan yang sangat baik untuk operasi semacam itu, dan kita dapat menggunakan fakta ini untuk membuat versi vektor dari transformasi Fourier cepat ini: <br><br>  Dalam [7]: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FFT_vectorized</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""A vectorized, non-recursive version of the Cooley-Tukey FFT"""</span></span> x = np.asarray(x, dtype=float) N = x.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> np.log2(N) % <span class="hljs-number"><span class="hljs-number">1</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-string"><span class="hljs-string">"size of x must be a power of 2"</span></span>) <span class="hljs-comment"><span class="hljs-comment"># N_min here is equivalent to the stopping condition above, # and should be a power of 2 N_min = min(N, 32) # Perform an O[N^2] DFT on all length-N_min sub-problems at once n = np.arange(N_min) k = n[:, None] M = np.exp(-2j * np.pi * n * k / N_min) X = np.dot(M, x.reshape((N_min, -1))) # build-up each level of the recursive calculation all at once while X.shape[0] &lt; N: X_even = X[:, :X.shape[1] / 2] X_odd = X[:, X.shape[1] / 2:] factor = np.exp(-1j * np.pi * np.arange(X.shape[0]) / X.shape[0])[:, None] X = np.vstack([X_even + factor * X_odd, X_even - factor * X_odd]) return X.ravel()</span></span></code> </pre> <br>  Meskipun algoritmanya sedikit lebih buram, itu hanyalah penataan ulang operasi yang digunakan dalam versi rekursif, dengan satu pengecualian: kami menggunakan simetri dalam perhitungan koefisien dan membangun hanya setengah dari array.  Sekali lagi, kami mengkonfirmasi bahwa fungsi kami memberikan hasil yang benar: <br><br>  Dalam [8]: <br><br><pre> <code class="python hljs">x = np.random.random(<span class="hljs-number"><span class="hljs-number">1024</span></span>) np.allclose(FFT_vectorized(x), np.fft.fft(x))</code> </pre> <br><br>  Keluar [8]: <br> <code>True</code> <br> <br>  Karena algoritme kami menjadi jauh lebih efisien, kami dapat menggunakan array yang lebih besar untuk membandingkan waktu, meninggalkan <code>DFT_slow</code> : <br>  Dalam [9]: <br><br><pre> <code class="python hljs">x = np.random.random(<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">16</span></span>) %timeit FFT(x) %timeit FFT_vectorized(x) %timeit np.fft.fft(x)</code> </pre> <br><pre> <code class="plaintext hljs">10 loops, best of 3: 72.8 ms per loop 100 loops, best of 3: 4.11 ms per loop 1000 loops, best of 3: 505 µs per loop</code> </pre> <br>  Kami telah meningkatkan implementasi kami dengan urutan besarnya!  Sekarang kita berada sekitar 10 kali dari patokan FFTPACK, hanya menggunakan beberapa lusin baris Python + NumPy murni.  Meskipun ini masih belum konsisten secara komputasi, dalam hal keterbacaan, versi Python jauh lebih unggul dari kode sumber FFTPACK, yang dapat Anda lihat di <a href="">sini</a> . <br><br>  Jadi bagaimana FFTPACK mencapai akselerasi terakhir ini?  Yah, pada dasarnya, ini hanya masalah pembukuan yang terperinci.  FFTPACK menghabiskan banyak waktu untuk menggunakan kembali kalkulasi antara yang dapat digunakan kembali.  Versi kasar kami masih mencakup alokasi memori berlebihan dan penyalinan;  dalam bahasa tingkat rendah seperti Fortran, lebih mudah untuk mengontrol dan meminimalkan penggunaan memori.  Selain itu, algoritma Cooley-Tukey dapat diperluas untuk menggunakan partisi dengan ukuran selain 2 (apa yang telah kami terapkan di sini dikenal sebagai Cooley-Tukey Radix FFT berdasarkan 2).  Algoritma FFT lain yang lebih kompleks juga dapat digunakan, termasuk pendekatan yang berbeda secara mendasar berdasarkan data konvolusi (lihat, misalnya, algoritma Blueshtein dan algoritma Raider).  Kombinasi dari ekstensi dan metode di atas dapat menyebabkan FFT yang sangat cepat bahkan pada array yang ukurannya bukan kekuatan dua. <br><br>  Meskipun fungsi dalam Python murni mungkin tidak berguna dalam praktiknya, saya berharap mereka memberikan beberapa wawasan tentang apa yang terjadi di latar belakang analisis data berbasis FFT.  Sebagai ahli data, kita dapat mengatasi implementasi "kotak hitam" dari alat fundamental yang dibuat oleh kolega kita yang lebih berpikiran algoritmik, tetapi saya yakin bahwa semakin banyak pemahaman yang kita miliki tentang algoritma tingkat rendah yang kita terapkan pada data kita, praktik yang lebih baik kami akan. <br><br>  Posting ini ditulis seluruhnya dalam Notepad IPython.  Notebook lengkap dapat diunduh di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> atau dilihat secara statis di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Banyak yang mungkin memperhatikan bahwa materi itu jauh dari baru, tetapi, seperti yang terlihat bagi kita, cukup relevan.  Secara umum, tulis apakah artikel itu bermanfaat.  Menunggu komentar Anda. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id449996/">https://habr.com/ru/post/id449996/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id449984/index.html">Google News dan Leo Tolstoy: memvisualisasikan Word2Vec embeddings menggunakan t-SNE</a></li>
<li><a href="../id449986/index.html">Blockchain: apa yang harus kita bangun kasing?</a></li>
<li><a href="../id449990/index.html">Bagaimana cara berteman lateks, formula dan Habr?</a></li>
<li><a href="../id449992/index.html">Showcase model driver sederhana (SDM) NodeMCU: antarmuka pengguna yang dinamis</a></li>
<li><a href="../id449994/index.html">Delapan aturan emas Schneiderman akan membantu Anda membuat antarmuka yang lebih baik</a></li>
<li><a href="../id449998/index.html">FAQ: apa yang perlu diketahui oleh seorang pelancong tentang vaksinasi sebelum bepergian</a></li>
<li><a href="../id450000/index.html">(Kanan ke kiri (Melalui Kaca Mencari</a></li>
<li><a href="../id450002/index.html">Menemukan Bug di LLVM 8 dengan PVS-Studio</a></li>
<li><a href="../id450004/index.html">Fast C / C ++ Cache, Thread Safety</a></li>
<li><a href="../id450006/index.html">Pendinginan pusat data chiller: pendingin mana yang harus dipilih?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>