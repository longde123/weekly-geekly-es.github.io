<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>↖️ 🦇 🌕 Daño macro para el código C ++ 🧖🏿 👈🏼 🧑🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El lenguaje C ++ ofrece amplias posibilidades para prescindir de macros. ¡Intentemos usar macros lo menos posible! 

 Inmediatamente haga una reserva ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Daño macro para el código C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/444612/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ab/6o/dn/ab6odnv29jcjsh1_qrqsawoj5ii.png" alt="definir"></div><br>  El lenguaje C ++ ofrece amplias posibilidades para prescindir de macros.  ¡Intentemos usar macros lo menos posible! <br><br>  Inmediatamente haga una reserva de que no soy un fanático y no insto a abandonar las macros por razones idealistas.  Por ejemplo, cuando se trata de generar manualmente el mismo tipo de código, puedo reconocer los beneficios de las macros y aceptarlas.  Por ejemplo, me relaciono tranquilamente con las macros en programas antiguos escritos con MFC.  No tiene sentido luchar con algo como esto: <br><br><pre><code class="cpp hljs">BEGIN_MESSAGE_MAP(efcDialog, EFCDIALOG_PARENT ) <span class="hljs-comment"><span class="hljs-comment">//{{AFX_MSG_MAP(efcDialog) ON_WM_CREATE() ON_WM_DESTROY() //}}AFX_MSG_MAP END_MESSAGE_MAP()</span></span></code> </pre> <br>  Hay tales macros, y está bien.  Realmente fueron creados para simplificar la programación. <br><br>  Estoy hablando de otras macros con las que intentan evitar la implementación de una función completa o intentan reducir el tamaño de una función.  Considere varios motivos para evitar tales macros. <br><a name="habracut"></a><br>  <i>Nota</i>  <i>Este texto fue escrito como una publicación invitada para el blog Simplify C ++.</i>  <i>Decidí publicar la versión rusa del artículo aquí.</i>  <i>En realidad, estoy escribiendo esta nota para evitar una pregunta de lectores desatentos por qué el artículo no está marcado como "traducción" :).</i>  <i>Y aquí, en realidad, una publicación invitada en inglés: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i>Macro Evil in C ++ Code</i></a> ".</i> <br><br><h2>  Primero: el código macro atrae errores </h2><br>  No sé cómo explicar las razones de este fenómeno desde un punto de vista filosófico, pero lo es.  Además, los errores relacionados con macro a menudo son muy difíciles de detectar cuando se realiza una revisión de código. <br><br>  He descrito repetidamente tales casos en mis artículos.  Por ejemplo, <i>reemplazando la</i> función <i>isspace</i> con esta macro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> isspace(c) ((c)==</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">' '</span></span></span><span class="hljs-meta"> || (c) == </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'\t'</span></span></span><span class="hljs-meta">)</span></span></code> </pre> <br>  El programador que usó <i>isspace</i> creía que estaba usando una función real que considera no solo espacios y tabulaciones como espacios en blanco, sino también LF, CR, etc.  El resultado es que una de las condiciones siempre es verdadera y el código no funciona según lo previsto.  Este error de Midnight Commander se describe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br>  ¿O qué le parece esta taquigrafía para escribir la función <i>std :: printf</i> ? <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> sprintf std::printf</span></span></code> </pre> <br>  Creo que el lector adivina que fue una macro muy infructuosa.  Se encontró, por cierto, en el proyecto StarEngine.  Lea más sobre esto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br>  Se podría argumentar que los programadores tienen la culpa de estos errores, no de las macros.  Eso es asi.  Naturalmente, los programadores siempre tienen la culpa de los errores :). <br><br>  Es importante que las macros causen errores.  Resulta que las macros se deben usar con mayor precisión o nada. <br><br>  Puedo dar ejemplos de defectos asociados con el uso de macros durante mucho tiempo, y esta nota agradable se convertirá en un documento de varias páginas pesado.  Por supuesto, no haré esto, pero mostraré algunos otros casos para convencer. <br><br>  La biblioteca ATL <a href="">proporciona</a> macros como A2W, T2W, etc. para convertir cadenas.  Sin embargo, pocas personas saben que estas macros son muy peligrosas de usar dentro de los bucles.  Dentro de la macro, se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i>llama a la</i></a> función <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><i>alloca</i></a> , que asignará memoria en la pila una y otra vez en cada iteración del bucle.  Un programa puede pretender funcionar correctamente.  Tan pronto como el programa comienza a procesar largas filas o aumenta el número de iteraciones en el bucle, la pila puede tomar y finalizar en el momento más inesperado.  Puede leer más sobre esto en este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mini libro</a> (consulte el capítulo "No llame a la función alloca () dentro de los bucles"). <br><br>  Macros como A2W esconden el mal.  Parecen funciones, pero, de hecho, tienen efectos secundarios que son difíciles de notar. <br><br>  No puedo superar intentos similares de reducir el código usando macros: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize_sanitizer_builtins</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEF_SANITIZER_BUILTIN(ENUM, NAME, TYPE, ATTRS) \ decl = add_builtin_function (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"__builtin_"</span></span></span><span class="hljs-meta"> NAME, TYPE, ENUM, \ BUILT_IN_NORMAL, NAME, NULL_TREE); \ set_call_expr_flags (decl, ATTRS); \ set_builtin_decl (ENUM, decl, true); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sanitizer.def"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((flag_sanitize &amp; SANITIZE_OBJECT_SIZE) &amp;&amp; !builtin_decl_implicit_p (BUILT_IN_OBJECT_SIZE)) DEF_SANITIZER_BUILTIN (BUILT_IN_OBJECT_SIZE, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"object_size"</span></span></span><span class="hljs-meta">, BT_FN_SIZE_CONST_PTR_INT, ATTR_PURE_NOTHROW_LEAF_LIST) .... }</span></span></code> </pre> <br>  Solo la primera línea de la macro se refiere a la <i>declaración if</i> .  Las líneas restantes se ejecutarán independientemente de la condición.  Podemos decir que este error es del mundo C, ya que lo encontré usando los diagnósticos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V640</a> dentro del compilador GCC.  El código GCC está escrito principalmente en C, y en este lenguaje las macros son difíciles de hacer.  Sin embargo, debe admitir que este no es el caso.  Aquí era bastante posible hacer una función real. <br><br><h2>  Segundo: la lectura del código se vuelve más complicada </h2><br>  Si se encuentra con un proyecto que está lleno de macros que consisten en otras macros, entonces comprende qué demonios es comprender dicho proyecto.  Si no se ha encontrado, entonces tome una palabra, esto es triste.  Como ejemplo de código que es difícil de leer, puedo citar el compilador GCC mencionado anteriormente. <br><br>  Según la leyenda, Apple ha invertido en el desarrollo del proyecto LLVM como una alternativa a GCC debido a la complejidad del código GCC debido a estas macros.  No recuerdo dónde lo leí, así que no habrá pruebas. <br><br><h2>  Tercero: escribir macros es difícil </h2><br>  Es fácil escribir una mala macro.  Los encuentro en todas partes con las correspondientes consecuencias.  Pero escribir una macro buena y confiable a menudo es más difícil que escribir una función similar. <br><br>  Escribir una buena macro es difícil porque, a diferencia de una función, no puede considerarse como una entidad independiente.  Se requiere considerar inmediatamente la macro en el contexto de todas las opciones posibles para su uso, de lo contrario es muy fácil identificar un problema de la forma: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MIN(X, Y) (((X) &lt; (Y)) ? (X) : (Y)) m = MIN(ArrayA[i++], ArrayB[j++]);</span></span></code> </pre> <br>  Por supuesto, para tales casos, se han inventado soluciones temporales y la macro se puede implementar de manera segura: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX(a,b) \ ({ __typeof__ (a) _a = (a); \ __typeof__ (b) _b = (b); \ _a &gt; _b ? _a : _b; })</span></span></code> </pre> <br>  La única pregunta es, ¿necesitamos todo esto en C ++?  No, en C ++ hay plantillas y otras formas de construir código eficiente.  Entonces, ¿por qué sigo encontrando macros similares en los programas de C ++? <br><br><h2>  Cuarto: la depuración es complicada </h2><br>  Existe la opinión de que la depuración es para los débiles :).  Esto, por supuesto, es interesante para discutir, pero desde un punto de vista práctico, la depuración es útil y ayuda a encontrar errores.  Las macros complican este proceso y definitivamente ralentizan la búsqueda de errores. <br><br><h2>  Quinto: falsos positivos de los analizadores estáticos. </h2><br>  Muchas macros, debido a las características específicas de su dispositivo, generan múltiples falsos positivos a partir de analizadores de código estático.  Puedo decir con seguridad que la mayoría de los falsos positivos al verificar el código C y C ++ están asociados con macros. <br><br>  El problema con las macros es que los analizadores simplemente no pueden distinguir el código complicado correcto del código erróneo.  El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo</a> sobre la comprobación de Chromium describe una de estas macros. <br><br><h2>  Que hacer </h2><br>  ¡No usemos macros en programas C ++ a menos que sea absolutamente necesario! <br><br>  C ++ proporciona herramientas ricas como funciones de plantilla, inferencia de tipo automática (auto, decltype), funciones constexpr. <br><br>  Casi siempre, en lugar de una macro, puede escribir una función ordinaria.  A menudo esto no se hace debido a la pereza ordinaria.  Esta pereza es perjudicial, y debemos luchar contra ella.  Un pequeño tiempo adicional dedicado a escribir una función completa dará sus frutos con intereses.  El código será más fácil de leer y mantener.  La probabilidad de disparar su propia pierna disminuirá, y los compiladores y analizadores estáticos producirán menos falsos positivos. <br><br>  Algunos podrían argumentar que el código con una función es menos eficiente.  Esto también es solo una "excusa". <br><br>  Los compiladores ahora alinean perfectamente el código, incluso si no ha escrito la <i>palabra clave en línea</i> . <br><br>  Si estamos hablando de calcular expresiones en la etapa de compilación, entonces aquí las macros no son necesarias e incluso dañinas.  Con el mismo propósito, es mucho mejor y más seguro usar <i>constexpr</i> . <br><br>  Lo explicaré con un ejemplo.  Aquí hay un error macro clásico que tomé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">prestado</a> del código del kernel de FreeBSD. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ICB2400_VPOPT_WRITE_SIZE 20 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ICB2400_VPINFO_PORT_OFF(chan) \ (ICB2400_VPINFO_OFF + \ sizeof (isp_icb_2400_vpinfo_t) + \ (chan * ICB2400_VPOPT_WRITE_SIZE)) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;= static void isp_fibre_init_2400(ispsoftc_t *isp) { .... if (ISP_CAP_VP0(isp)) off += ICB2400_VPINFO_PORT_OFF(chan); else off += ICB2400_VPINFO_PORT_OFF(chan - 1); // &lt;= .... }</span></span></span></span></code> </pre> <br>  El argumento <i>chan</i> se usa en una macro sin envolver entre paréntesis.  Como resultado, la expresión <i>ICB2400_VPOPT_WRITE_SIZE</i> no multiplica la expresión <i>(chan - 1)</i> , sino solo una. <br><br>  El error no aparecería si se escribiera una función ordinaria en lugar de una macro. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ICB2400_VPINFO_PORT_OFF(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> chan) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ICB2400_VPINFO_OFF + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">isp_icb_2400_vpinfo_t</span></span>) + chan * ICB2400_VPOPT_WRITE_SIZE; }</code> </pre> <br>  Es muy probable que el compilador moderno de C y C ++ realice de forma independiente la <i>alineación de la</i> función, y el código será tan eficiente como en el caso de una macro. <br><br>  Al mismo tiempo, el código se ha vuelto más legible, así como libre de errores. <br><br>  Si se sabe que el valor de entrada es siempre una constante, puede agregar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">constexpr</a> y asegurarse de que todos los cálculos se realizarán en la etapa de compilación.  Imagine que es C ++ y que <i>chan</i> siempre es una constante.  Entonces es útil declarar la función <i>ICB2400_VPINFO_PORT_OFF de</i> esta manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ICB2400_VPINFO_PORT_OFF</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chan)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ICB2400_VPINFO_OFF + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">isp_icb_2400_vpinfo_t</span></span>) + chan * ICB2400_VPOPT_WRITE_SIZE; }</code> </pre> <br>  Beneficio! <br><br>  Espero haber logrado convencerte.  ¡Buena suerte y menos macros en el código! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444612/">https://habr.com/ru/post/444612/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444596/index.html">Yoduro: Mozilla Interactive Science Editor</a></li>
<li><a href="../444598/index.html">El CD tiene 40 años y está muerto (¿verdad?)</a></li>
<li><a href="../444600/index.html">Revisión de 14 cms sin cabeza 2019</a></li>
<li><a href="../444602/index.html">Encapsulación en C ++ y C</a></li>
<li><a href="../444610/index.html">Estadísticas y monitoreo de scripts PHP en tiempo real. ClickHouse y Grafana van a ayudar a Pinba</a></li>
<li><a href="../444614/index.html">Toda la historia de Linux. Parte II: altibajos corporativos</a></li>
<li><a href="../444616/index.html">Creación de su propia grabadora de voz de Android con Kotlin</a></li>
<li><a href="../444620/index.html">Uso de archivos de secuencia de kernel de Linux</a></li>
<li><a href="../444622/index.html">Paquete R tidyr y sus nuevas funciones pivot_longer y pivot_wider</a></li>
<li><a href="../444624/index.html">Coches eléctricos en llamas y baños</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>