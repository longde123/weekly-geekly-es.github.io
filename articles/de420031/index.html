<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚐 🤳🏿 👩‍🌾 Zeichnen mit Renderzielen in Unreal Engine 👩🏽‍🤝‍👨🏼 👉🏿 👨🏻‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Renderziel ist im Wesentlichen eine Textur, in die Sie zur Laufzeit schreiben können. Aus Sicht des Motors speichern sie Informationen wie Grundfa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zeichnen mit Renderzielen in Unreal Engine</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420031/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/276/6ee/ee4/2766eeee4fcc87c31919d427c829ee98.gif"></div><br>  Das Renderziel ist im Wesentlichen eine Textur, in die Sie zur Laufzeit schreiben können.  Aus Sicht des Motors speichern sie Informationen wie Grundfarbe, Normalen und Umgebungsokklusion. <br><br>  Aus Sicht des Benutzers werden Renderziele hauptsächlich als eine Art zusätzliche Kamera verwendet.  Sie können die Szenenaufnahme irgendwann einstellen und das Bild im Renderziel speichern.  Anschließend können Sie das Renderziel auf dem Netz anzeigen, um beispielsweise eine Überwachungskamera zu simulieren. <br><br>  Nach der Veröffentlichung der 4.13-Engine-Version hat Epic die Möglichkeit hinzugefügt, Materialien mithilfe von Blunts direkt auf das Rendering-Ziel zu zeichnen.  Mit dieser Funktion können Sie komplexe Effekte wie Flüssigkeitssimulation und Schneeverformung erstellen.  Klingt erstaunlich, oder?  Bevor Sie jedoch zu solch komplexen Effekten übergehen, sollten Sie sich mit etwas Einfachem vertraut machen.  Was könnte einfacher sein als das Zeichnen auf einem Renderziel? <br><br>  In diesem Tutorial lernen Sie Folgendes: <br><br><ul><li>  Erstellen Sie Renderziele dynamisch mit Blunts </li><li>  Renderziel auf Netz anzeigen </li><li>  Zeichnen Sie eine Textur auf das Renderziel </li><li>  Ändere Pinselgröße und Textur während des Spiels </li></ul><a name="habracut"></a><br><blockquote>  <em>Hinweis: In</em> diesem Lernprogramm wird davon ausgegangen, dass Sie bereits mit den Grundlagen der Arbeit mit Unreal Engine vertraut sind.  Wenn Sie Unreal Engine noch nicht kennen, lesen Sie unsere zehnteilige Reihe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unreal Engine-</a> Tutorials <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">für Anfänger</a> . </blockquote><br><h2>  An die Arbeit gehen </h2><br>  Beginnen wir mit dem Herunterladen von Materialien für dieses Tutorial (Sie können sie <a href="">hier</a> herunterladen).  Entpacken Sie sie, gehen Sie zu <em>CanvasPainterStarter</em> und öffnen Sie <em>CanvasPainter.uproject</em> .  Wenn Sie auf <em>Wiedergabe</em> klicken, wird Folgendes angezeigt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b9/e6d/01f/9b9e6d01f6955d5a93f737588f4bb730.jpg"></div><br>  Das Quadrat in der Mitte (Leinwand) ist das, worauf wir zeichnen werden.  Die UI-Elemente auf der linken Seite sind die Textur, die wir zeichnen werden, und ihre Größe. <br><br>  Schauen wir uns zunächst die Methode zum Zeichnen an. <br><br><h2>  Zeichenmethode </h2><br>  Das erste, was wir brauchen, ist ein Renderziel, das als Zeichenfläche verwendet wird.  Um zu bestimmen, wo auf dem Renderziel gezeichnet werden soll, verfolgen wir die gerade Linie, die aus der Kamera nach vorne kommt.  Wenn die Linie die Leinwand schneidet, können wir den Schnittpunkt im UV-Raum erhalten. <br><br>  Wenn die Leinwand beispielsweise eine perfekte Bindung der UV-Koordinaten aufweist, gibt der Schnittpunkt in der Mitte den Wert <em>(0,5, 0,5) zurück</em> .  Wenn die Linie die Leinwand in der unteren rechten Ecke kreuzt, erhalten wir den Wert <em>(1, 1)</em> .  Anschließend können Sie mithilfe einfacher Berechnungen den Ort der Zeichnung berechnen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f2/369/fe2/5f2369fe21d9655fa5e7fc0914c6c023.gif"></div><br>  Aber warum die Koordinaten im UV-Raum bekommen?  Warum nicht die Koordinaten des realen Weltraums verwenden?  Wenn wir den Raum der Welt nutzen, müssen wir zuerst den Schnittpunkt relativ zur Ebene berechnen.  Sie müssen auch die Drehung und den Maßstab der Ebene berücksichtigen. <br><br>  Bei Verwendung des UV-Raums sind alle diese Berechnungen nicht erforderlich.  In einer Ebene mit perfekter Bindung der UV-Koordinaten kehrt der Schnittpunkt mit der Mitte immer zurück <em>(0,5, 0,5)</em> , unabhängig von der Position und Drehung der Ebene. <br><br><blockquote>  <em>Hinweis: Die</em> in diesem Lernprogramm beschriebene Methode funktioniert im Allgemeinen nur mit Ebenen oder Oberflächen, die Ebenen ähnlich sind.  Andere Arten von Geometrie erfordern eine komplexere Methode, die ich in einem anderen Tutorial behandeln werde. </blockquote><br>  Zuerst erstellen wir Material, das das Renderziel rendert. <br><br><h2>  Erstellen Sie Leinwandmaterial </h2><br>  Gehen Sie zum Ordner <em>Materialien</em> und öffnen Sie <em>M_Canvas</em> . <br><br>  In diesem Tutorial erstellen wir Renderziele dynamisch mithilfe von Blunts.  Dies bedeutet, dass wir die Textur als Parameter einrichten müssen, damit wir sie an das Rendering-Ziel übergeben können.  Erstellen Sie dazu ein <em>TextureSampleParameter2D</em> und nennen Sie es <em>RenderTarget</em> .  <em>Schließen Sie</em> es dann an <em>BaseColor an</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/439/741/68a/43974168a064c39f35acc53ab09f1c65.jpg"></div><br>  Machen Sie sich vorerst keine Gedanken über die Auswahl einer Textur - wir werden dies später in Blaupausen tun.  Klicken <em>Sie auf</em> <em>Übernehmen</em> und schließen Sie <em>M_Canvas</em> . <br><br>  Der nächste Schritt besteht darin, ein Renderziel zu erstellen, wonach wir es als Canvas-Material verwenden. <br><br><h2>  Erstellen eines Renderziels </h2><br>  Es gibt zwei Möglichkeiten, ein Renderziel zu erstellen.  Erstens: Erstellen im Editor durch Klicken auf <em>Add New \ Materials &amp; Textures \ Render Target</em> .  Mit dieser Methode können Sie dasselbe Renderziel bequem auf mehrere Akteure verweisen.  Wenn wir jedoch mehrere Leinwände benötigen, müssen wir für jede Zeichenfläche manuell ein Renderziel erstellen. <br><br>  Daher ist es besser, Renderziele mit Blunts zu erstellen.  Der Vorteil dieses Ansatzes besteht darin, dass wir Renderziele nur bei Bedarf erstellen und sie die Größe der Projektdateien nicht erhöhen. <br><br>  Zuerst müssen wir ein Renderziel erstellen und es als Variable für die zukünftige Verwendung speichern.  Gehen Sie zum Ordner <em>Blueprints</em> und öffnen Sie <em>BP_Canvas</em> .  <em>Suchen Sie</em> das <em>Ereignis BeginPlay</em> und fügen Sie die ausgewählten Knoten hinzu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ed/91a/e85/7ed91ae8543ccf5875dad7828c308ed1.jpg"></div><br>  Stellen Sie <em>Breite</em> und <em>Höhe</em> auf <em>1024 ein</em> .  Daher ändern wir die Auflösung des Renderziels auf <em>1024 × 1024</em> .  Je höher der Wert, desto höher die Bildqualität, aber auch die Kosten für den Videospeicher. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aeb/56f/96c/aeb56f96c38d3ae2606d4f3b2d3abeaf.jpg"></div><br>  Als nächstes kommt der <em>2D-</em> Knoten <em>Clear Render Target</em> .  Mit diesem Knoten können Sie die Farbe des Renderziels festlegen.  Stellen Sie <em>Clear Color</em> auf <em>(0,07, 0,13, 0,06)</em> .  In diesem Fall wird das gesamte Renderziel mit grünlicher Farbe gefüllt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94b/d30/eed/94bd30eedc1f590ffd157c8091d7898e.jpg"></div><br>  Jetzt müssen wir das Renderziel auf dem Canvas-Netz anzeigen. <br><br><h3>  Zielanzeige rendern </h3><br>  Zu diesem Zeitpunkt verwendet das Canvas-Netz das Standardmaterial.  Um das <em>Renderziel</em> anzuzeigen, müssen Sie eine dynamische Instanz von <em>M_Canvas erstellen</em> und das <em>Renderziel</em> an dieses übergeben.  Anschließend müssen Sie eine dynamische Instanz des Materials auf das Canvas-Netz anwenden.  Dazu fügen wir die ausgewählten Knoten hinzu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c9a/7d8/1aa/c9a7d81aa770c63cc6cf75f52746c4c3.jpg"></div><br>  <em>Fahren</em> wir zunächst mit dem Knoten <em>Dynamische Materialinstanz erstellen fort</em> und setzen den <em>übergeordneten</em> Wert auf <em>M_Canvas</em> .  Also werden wir eine dynamische Instanz von <em>M_Canvas erstellen</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da7/f26/2bf/da7f262bfda0215098287d3a2286085b.jpg"></div><br>  <em>Wechseln Sie als</em> Nächstes zum Knoten <em>Set Texture Parameter Value</em> und setzen Sie den <em>Parameternamen</em> auf <em>RenderTarget</em> .  Daher übergeben wir das Renderziel an den zuvor erstellten Texturparameter. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c7/8d0/377/7c78d0377ef6a592c05f5cd54d08a89e.jpg"></div><br>  Jetzt wird das Renderziel auf dem Canvas-Netz angezeigt.  Klicken Sie auf <em>Kompilieren</em> und kehren Sie zum <em>Haupteditor</em> zurück.  Klicken Sie auf <em>Wiedergabe, um</em> zu sehen, wie sich die Farbe der Leinwand ändert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53f/949/fd6/53f949fd6ad350b4a016545af0eca47c.jpg"></div><br>  Nachdem wir die Leinwand haben, müssen wir Material erstellen, das als Pinsel verwendet werden kann. <br><br><h2>  Pinselmaterial erstellen </h2><br>  Gehen Sie zum Ordner <em>Materialien</em> .  Erstellen Sie das Material <em>M_Brush</em> und öffnen Sie es.  <em>Stellen Sie</em> zuerst den <em>Mischmodus</em> auf <em>Durchscheinend</em> .  Dadurch können wir Texturen mit Transparenz verwenden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf2/18a/4b7/cf218a4b7b0e2c57f307cd06d8a92860.jpg"></div><br>  Wie bei Leinwandmaterial setzen wir die Textur für den Pinsel in Blunts.  Erstellen Sie ein <em>TextureSampleParameter2D</em> und nennen Sie es <em>BrushTexture</em> .  Schließen Sie es wie folgt an: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/097/c49/7d1/097c497d1e50af95c004f9bdfe849897.jpg"></div><br>  Klicken Sie auf <em>Übernehmen</em> und schließen Sie <em>M_Brush</em> . <br><br>  Als Nächstes erstellen Sie eine dynamische Instanz des Pinselmaterials, damit Sie die Textur des Pinsels ändern können.  Öffnen Sie <em>BP_Canvas</em> und fügen Sie die ausgewählten Knoten hinzu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49d/628/860/49d62886060349fc146ce04c150d539c.jpg"></div><br>  <em>Wechseln</em> <em>Sie als</em> Nächstes zum Knoten <em>Dynamische Materialinstanz erstellen</em> und setzen Sie das <em>übergeordnete Element</em> auf <em>M_Canvas</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e0/009/4aa/8e00094aa61fbd27c527f207b360856b.jpg"></div><br>  Wir haben das Pinselmaterial erstellt und benötigen nun eine Funktion zum Malen mit dem Pinsel auf dem Renderziel. <br><br><h2>  Pinselmalerei auf Renderziel </h2><br>  Erstellen Sie eine neue Funktion und nennen Sie sie <em>DrawBrush</em> .  Zuerst benötigen wir die Parameter: verwendete Textur, Pinselgröße und Ort zum Zeichnen.  Erstellen Sie die folgende Eingabe: <br><br><ul><li>  <em>BrushTexture: Wählen</em> Sie den Typ <em>Texture 2D</em> <br></li><li>  <em>BrushSize:</em> <em>Float-</em> Typ auswählen <br></li><li>  <em>DrawLocation: Wählen</em> Sie den Typ <em>Vector 2D</em> </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6e/2cb/d2f/e6e2cbd2f9e69222d7bcbe616d30f8b2.jpg"></div><br>  Bevor wir einen Pinsel zeichnen, müssen wir seine Textur einstellen.  Erstellen Sie dazu die unten gezeigte Schaltung.  <em>Stellen</em> Sie sicher, dass <em>BrushTexture</em> als <em>Parametername</em> ausgewählt <em>ist</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ff/645/efc/0ff645efc2374126884a93b9b3a8c25b.jpg"></div><br>  Jetzt müssen wir das Rendern im Renderziel durchführen.  Erstellen Sie dazu die ausgewählten Knoten: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c69/b73/c02/c69b73c027dc7280673644d512498492.jpg"></div><br>  <em>Wenn Sie mit dem Zeichnen von Canvas zum</em> Rendern <em>von Zielen beginnen,</em> wird die Engine darüber informiert, dass das Rendern für ein bestimmtes Renderziel gestartet werden soll.  <em>Mit Material</em> zeichnen können Sie Material an einer bestimmten Stelle mit der ausgewählten Größe und Drehung zeichnen. <br><br>  Die Berechnung der Renderposition erfolgt in zwei Schritten.  Zuerst müssen wir <em>DrawLocation</em> so <em>skalieren</em> , dass es in die <em>Renderzielauflösung</em> passt.  Multiplizieren Sie dazu <em>DrawLocation</em> mit <em>Size</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cbb/513/4d2/cbb5134d2311305c42095e53939cc130.jpg"></div><br>  Standardmäßig rendert die Engine Materialien anhand der oberen linken Ecke als Ausgangspunkt.  Daher wird die Pinselstruktur nicht auf uns zentriert, wo wir rendern möchten.  Um dies zu beheben, müssen wir <em>BrushSize</em> durch <em>2</em> teilen und dann das Ergebnis vom vorherigen Schritt subtrahieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/501/58f/e82/50158fe822073487d12a3099f86c7737.jpg"></div><br>  Dann verbinden wir alles wie folgt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d58/20a/111/d5820a1117491a78e4e020c4fd13e6ca.jpg"></div><br>  Schließlich müssen wir der Engine mitteilen, dass das Rendern im Renderziel gestoppt werden soll.  Fügen Sie den <em>End Draw Canvas zum Render Target-</em> Knoten hinzu und verbinden Sie ihn wie folgt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86f/8ff/a3e/86f8ffa3ecad0a4b3b47fe21f4044eb0.jpg"></div><br>  Jedes Mal, wenn <em>DrawBrush</em> ausgeführt wird <em>,</em> wird zuerst die übertragene Textur als Textur für <em>BrushMaterial festgelegt</em> .  Anschließend <em>rendert sie</em> das <em>BrushMaterial</em> im <em>RenderTarget</em> unter Verwendung der übergebenen Position und Größe. <br><br>  Und damit ist die Rendering-Funktion fertig.  Klicken Sie auf <em>Kompilieren</em> und schließen Sie <em>BP_Canvas</em> .  Der nächste Schritt besteht darin, die Linie von der Kamera zu verfolgen und an der Stelle der Leinwand zu zeichnen, an der der Schnittpunkt aufgetreten ist. <br><br><h2>  Kamera direkte Spur </h2><br>  Bevor wir auf die Leinwand zeichnen, müssen wir die Pinselstruktur und -größe angeben.  Gehen Sie zum Ordner <em>Blueprints</em> und öffnen Sie <em>BP_Player</em> .  Setzen Sie dann die Variable BrushTexture auf <em>T_Brush_01</em> und die Variable <em>BrushSize</em> auf <em>500</em> .  Also weisen wir ein Pinselbild eines Affen mit einer Größe von <em>500 × 500</em> Pixel zu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a76/ab2/b26/a76ab2b267bd2f0ea514b319528eeb26.jpg"></div><br>  Als nächstes müssen Sie die Linie verfolgen.  <em>Suchen Sie InputAxis Paint</em> und erstellen Sie das folgende Diagramm: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/775/cf0/68e/775cf068e5c0820fa2d4539ca6ae3960.jpg"></div><br>  Wir werden also die Linie verfolgen, die direkt von der Kamera gerichtet ist, während der Player die dem <em>Malen</em> zugewiesene Taste hält (in unserem Fall ist dies die <em>linke Maustaste</em> ). <br><br>  Jetzt müssen wir überprüfen, ob die gerade Leinwand gekreuzt ist.  Ausgewählte Knoten hinzufügen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da5/f53/97b/da5f5397b6a59eebdb9fce09541a35d8.jpg"></div><br>  Wenn sich nun die Linie und die Leinwand <em>schneiden</em> , wird die <em>DrawBrush-</em> Funktion unter Verwendung der <em>Pinselvariablen</em> und der an sie übergebenen UV-Koordinaten ausgeführt. <br><br>  Damit der <em>UV-</em> Knoten " <em>Kollision suchen"</em> funktioniert, müssen zwei Parameter geändert werden.  <em>Wechseln</em> Sie zunächst zum <em>LineTraceByChannel-</em> Knoten und <em>aktivieren Sie</em> <em>Trace Complex</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/759/207/f4a/759207f4a22689a21f91f6c244648f75.jpg"></div><br>  Gehen Sie zweitens zu <em>Bearbeiten \ Projekteinstellungen</em> und dann zu <em>Engine \ Physics</em> .  Aktivieren Sie <em>Support UV From Hit Results</em> und starten Sie das Projekt neu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8f/42d/56b/c8f42d56bac2b1ec4ad15884efa7f51d.jpg"></div><br>  Klicken Sie nach dem Neustart auf <em>Wiedergabe</em> , um auf die Leinwand zu zeichnen, und klicken Sie mit der <em>linken Maustaste</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b3/5ff/ad6/2b35ffad6680fa6349018143397310f3.gif"></div><br>  Sie können sogar mehrere Leinwände erstellen und jeweils einzeln darauf zeichnen.  Dies ist möglich, da jede Zeichenfläche dynamisch ein eigenes Renderziel erstellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/151/9c6/89e/1519c689ef59642b5fbb6a8dfbd304dc.gif"></div><br>  Im nächsten Abschnitt implementieren wir die Funktion zum Ändern der Pinselgröße eines Spielers. <br><br><h2>  Pinselgröße ändern </h2><br>  Öffnen Sie <em>BP_Player</em> und suchen Sie den <em>InputAxis ChangeBrushSize-</em> Knoten.  Diese Achsenbindung ist für die Verwendung <em>des Mausrads</em> konfiguriert.  Um die Pinselgröße zu ändern, reicht es aus, den <em>BrushSize-</em> Wert abhängig vom <em>Achsenwert</em> zu ändern.  Erstellen Sie dazu das folgende Schema: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/554/da6/2c8/554da62c836912958e8588e582862a69.jpg"></div><br>  Es wird eine Addition oder Subtraktion von <em>BrushSize durchgeführt,</em> wenn der Player das Mausrad verwendet.  Die erste Multiplikation bestimmt die Additions- oder Subtraktionsrate.  Als Sicherheitsmaßnahme wurde eine <em>Klemme (Schwimmer)</em> hinzugefügt.  Es stellt sicher, dass die Pinselgröße nicht kleiner als <em>0</em> oder größer als <em>1000 wird</em> . <br><br>  Klicken Sie auf <em>Kompilieren</em> und kehren Sie zum <em>Haupteditor</em> zurück.  Drehen Sie <em>das Mausrad,</em> um die Größe des Pinsels beim Zeichnen zu ändern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/276/6ee/ee4/2766eeee4fcc87c31919d427c829ee98.gif"></div><br>  Im letzten Abschnitt erstellen wir eine Funktion, mit der der Spieler die Textur des Pinsels ändern kann. <br><br><h2>  Pinselstruktur ändern </h2><br>  Zuerst benötigen wir ein Array, um die Texturen zu speichern, die der Player verwenden kann.  Öffnen Sie <em>BP_Player</em> und erstellen Sie eine <em>Array-</em> Variable.  Wählen Sie den <em>2D-</em> Texturtyp aus und nennen Sie ihn <em>Texturen</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/425/45f/db9/42545fdb9060f05e84a1e251be28bc3e.jpg"></div><br>  Erstellen Sie dann <em>drei</em> Elemente in <em>Texturen</em> .  Weisen Sie ihnen folgende Werte zu: <br><br><ul><li>  <em>T_Brush_01</em> </li><li>  <em>T_Brush_02</em> </li><li>  <em>T_Brush_03</em> </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93e/a5a/9fb/93ea5a9fb103654bac3448131c9b6d11.jpg"></div><br>  Dies sind die Texturen, die der Spieler zeichnen kann.  Um neue Texturen hinzuzufügen, fügen Sie sie einfach diesem Array hinzu. <br><br>  Als nächstes benötigen wir eine Variable, um den aktuellen Index des Arrays zu speichern.  Erstellen Sie eine <em>Ganzzahlvariable</em> und nennen Sie sie <em>CurrentTextureIndex</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0f/b87/b82/c0fb87b8243042c1ce3a6d441490b63e.jpg"></div><br>  Als nächstes brauchen wir eine Möglichkeit, alle Texturen in einer Schleife zu durchlaufen.  Für dieses Tutorial habe ich eine Aktionszuordnung namens <em>NextTexture eingerichtet</em> und an die <em>rechte Maustaste</em> gebunden.  Wenn der Spieler diese Taste drückt, sollte der Übergang zur nächsten Textur durchgeführt werden.  Suchen Sie dazu den <em>InputAction NextTexture-</em> Knoten und erstellen Sie das folgende Diagramm: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f2/3d1/9ad/3f23d19ad803a74af5a11892dc7e3579.jpg"></div><br>  Dieses Schema erhöht <em>CurrentTextureIndex bei</em> jedem <em>Rechtsklick</em> .  Wenn der Index das Ende des Arrays erreicht, wird er erneut auf <em>0 zurückgesetzt</em> .  Schließlich legt <em>BrushTexture</em> die entsprechende Textur fest. <br><br>  Klicken Sie auf <em>Kompilieren</em> und schließen Sie <em>BP_Player</em> .  Klicken Sie auf <em>Wiedergabe</em> und <em>klicken</em> Sie mit der <em>rechten Maustaste</em> , um zwischen den Texturen zu wechseln. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f4/ed0/d25/8f4ed0d25ed9f1944327137905ecba2b.gif"></div><br><h2>  Wohin als nächstes? </h2><br>  Das fertige Projekt kann hier heruntergeladen <a href="">werden</a> . <br><br>  Render Target ist ein äußerst leistungsfähiges Tool. In diesem Tutorial haben wir nur die Grundlagen behandelt.  Wenn Sie wissen möchten, wozu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Renderziele in der</a> Lage sind, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lesen Sie Content-Driven Multipass Rendering in UE4</a> .  Dieses Video enthält Beispiele für Zeichnungsflusskarten, Volumenzeichnungen, Flüssigkeitssimulationen und mehr. <br><br>  In unserem Tutorial-Video zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeichnen von Blaupausen zum</a> Rendern von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zielen</a> erfahren Sie auch, wie Sie eine Höhenkarte mit Renderziel erstellen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420031/">https://habr.com/ru/post/de420031/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420019/index.html">Client-Server-Interaktion in einem neuen mobilen PvP-Shooter und Spieleserver: Probleme und Lösungen</a></li>
<li><a href="../de420021/index.html">Warum brauchst du Splunk? Internet der Dinge und Industriedaten</a></li>
<li><a href="../de420023/index.html">Speichern von Status in Android-Anwendungen</a></li>
<li><a href="../de420025/index.html">Intelligente Farm. Wie wird sie sein?</a></li>
<li><a href="../de420029/index.html">Wie wir bei 1C: Enterprise Systeme algebraischer Gleichungen lösen</a></li>
<li><a href="../de420033/index.html">Wie wir angefangen haben, Registrierkassen für unsere Kunden zu registrieren</a></li>
<li><a href="../de420035/index.html">Golang GUI: GTK + 3</a></li>
<li><a href="../de420037/index.html">Streamen Sie mit mehreren Kameras aus improvisierten Materialien</a></li>
<li><a href="../de420039/index.html">Funktionales Denken. Teil 2</a></li>
<li><a href="../de420041/index.html">TypeScript War oder Enum Conquest</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>