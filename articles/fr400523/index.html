<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤶 😲 🅾️ Pourquoi les physiciens utilisent encore Fortran ⚾️ 👨‍👧‍👧 🍰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je ne sais pas à quoi ressemblera le langage de programmation en 2000, mais je sais qu’il s’appellera FORTRAN. 
 - Charles Anthony Richard Hoar, env. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pourquoi les physiciens utilisent encore Fortran</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/400523/"><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je ne sais pas à quoi ressemblera le langage de programmation en 2000, mais je sais qu’il s’appellera FORTRAN. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - Charles Anthony Richard Hoar, env. </font><font style="vertical-align: inherit;">1982</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans l'industrie, le Fortran est rarement utilisé aujourd'hui - dans l'une des listes de langues populaires, il </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">occupait la 28e place</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mais Fortran est toujours le langage principal pour les simulations à grande échelle de systèmes physiques - c'est-à-dire pour des choses comme la modélisation astrophysique des étoiles et des galaxies (par exemple </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flash</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), la dynamique moléculaire à grande échelle, les codes de comptage de structures électroniques ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SIESTA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), les modèles climatiques, etc. Dans le domaine du calcul haute performance, dont un sous-ensemble est constitué de simulations numériques à grande échelle, seuls deux langages sont aujourd'hui utilisés - C / C ++ et «modern Fortran» (Fortran 90/95/03/08). Bibliothèques </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">MPI ouvertes</font></a><font style="vertical-align: inherit;"> populaires</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des outils de parallélisation de code ont été développés pour ces deux langages. En général, si vous avez besoin d'un code rapide qui s'exécute sur plusieurs processeurs, vous n'avez que deux options. Dans le Fortran moderne, il existe une fonctionnalité telle que " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coarray</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ", qui permet de travailler directement avec le langage dans une programmation parallèle. Coarray est apparu dans l'extension Fortran 95 et a ensuite été inclus dans Fortran 2008. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'utilisation active de Fortran par les physiciens confond souvent les informaticiens et d'autres personnes sans rapport avec ce domaine qui pensent que Fortran est un anachronisme historique.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je voudrais expliquer pourquoi Fortran est toujours utile. Je n'encourage pas les étudiants qui étudient la physique à enseigner le Fortran - puisque la plupart d'entre eux feront de la recherche, ils devraient étudier le C / C ++ (ou s'arrêter à Matlab / Octave / Python). Je voudrais expliquer pourquoi Fortran est toujours utilisé et prouver que ce n'est pas seulement parce que les physiciens sont «en retard» (bien que ce soit parfois le cas - l'année dernière, j'ai vu un étudiant en physique travailler avec du code Fortran 77, alors que ni lui ni son manager n'ont entendu parler de Fortran 90). Les informaticiens devraient considérer la domination de Fortran dans l'informatique numérique comme un défi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de me plonger dans le sujet, je veux discuter de l'histoire, car lorsque les gens entendent le mot "Fortran", ils imaginent immédiatement des cartes perforées et du code avec des lignes numérotées. La première spécification Fortran a été écrite en 1954. Le premier Fortran (alors son nom était écrit en majuscules, FORTRAN) était, selon les normes modernes, une langue infernale, mais c'était un pas en avant incroyable par rapport à la programmation précédente des assembleurs. FORTRAN était souvent programmé avec des cartes perforées, comme le rappelle le professeur Miriam Forman de l'Université Stony Brook sans plaisir. Fortran avait de nombreuses versions, dont les plus célèbres sont les normes 66, 77, 90, 95, 03 et 08. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On dit souvent que Fortran est toujours utilisé en raison de sa vitesse. Mais est-il le plus rapide? À </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">benchmarksgame.alioth.debian.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il y a une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comparaison de C et Fortran</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans plusieurs tests parmi de nombreuses langues. </font><font style="vertical-align: inherit;">Dans la plupart des cas, Fortran et C / C ++ sont les plus rapides. </font><font style="vertical-align: inherit;">Les programmeurs Python préférés sont souvent en retard de vitesse 100 fois, mais c'est dans l'ordre des choses pour le code interprété. </font><font style="vertical-align: inherit;">Python ne convient pas aux calculs numériques complexes, mais convient bien à un autre. </font><font style="vertical-align: inherit;">Fait intéressant, C / C ++ surpasse Fortran dans tous les tests sauf deux, bien qu'en général ils diffèrent peu dans les résultats. </font><font style="vertical-align: inherit;">Les tests où Fortran gagne, les plus «physiques» sont la simulation d'un système de n corps et le calcul du spectre. </font><font style="vertical-align: inherit;">Les résultats dépendent du nombre de cœurs de processeur, par exemple, Fortran est en retard sur C / C ++ sur le quad core. </font><font style="vertical-align: inherit;">Les tests, dans lesquels Fortran est loin derrière C / C ++, lisent et écrivent des données la plupart du temps, et à cet égard, la lenteur de Fortran est connue.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le C / C ++ est donc aussi rapide que Fortran, et parfois un peu plus rapide. </font><font style="vertical-align: inherit;">Nous sommes intéressés par "pourquoi les professeurs de physique continuent-ils à conseiller à leurs étudiants d'utiliser Fortran au lieu de C / C ++?"</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fortran a un code hérité</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grâce à la longue histoire de Fortran, il n’est pas surprenant que des montagnes de code physique y soient écrites. </font><font style="vertical-align: inherit;">Les physiciens essaient de minimiser le temps de programmation, donc s'ils trouvent du code antérieur, ils l'utiliseront. </font><font style="vertical-align: inherit;">Même si l'ancien code est illisible, mal documenté et pas le plus efficace, il est plus susceptible d'utiliser l'ancien code éprouvé que d'en écrire un nouveau. </font><font style="vertical-align: inherit;">La tâche des physiciens n'est pas d'écrire du code, ils essaient de comprendre la nature de la réalité. </font><font style="vertical-align: inherit;">Les professeurs ont toujours le code hérité à portée de main (souvent ils ont écrit ce code il y a des décennies), et ils le transmettent à leurs étudiants. </font><font style="vertical-align: inherit;">Cela leur fait gagner du temps et supprime les incertitudes du processus de correction d'erreurs.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les étudiants en physique apprennent le Fortran plus facilement que le C / C ++</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je pense que Fortran est plus facile à apprendre que C / C ++. Fortran 90 et C sont très similaires, mais Fortran est plus facile à écrire. Le C est un langage relativement primitif, donc les physiciens qui choisissent le C / C ++ sont engagés dans une programmation orientée objet. La POO peut être utile, en particulier dans les grands projets logiciels, mais étudiez-la beaucoup plus longtemps. Vous devez étudier les abstractions comme les classes et l'héritage. Le paradigme OOP est très différent de celui procédural utilisé par Fortran. Fortran est basé sur un paradigme procédural simple qui est plus proche de ce qui se passe sous le capot d'un ordinateur. Lorsque vous optimisez / vectorisez du code pour augmenter la vitesse, le paradigme procédural est plus facile à utiliser. Les physiciens comprennent généralement le fonctionnement des ordinateurs et pensent en termes de processus physiques, par exemple, le transfert de données du disque vers la RAM et de la RAM vers le cache du processeur.Ils diffèrent des mathématiciens qui préfèrent penser en termes de fonctions abstraites et de logique. En outre, cette pensée est différente de celle orientée objet. L'optimisation du code POO est plus compliquée de mon point de vue que procédurale. Les objets sont des structures très volumineuses par rapport aux structures de données préférées des physiciens: les tableaux.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Légèreté One: Fortran Array Work</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les matrices, ou, comme les physiciens les appellent, les matrices, sont au cœur de tout calcul physique. </font><font style="vertical-align: inherit;">Dans Fortran 90+, vous pouvez trouver de nombreuses opportunités de travailler avec eux, comme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">APL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et Matlab / Octave. </font><font style="vertical-align: inherit;">Les tableaux peuvent être copiés, multipliés par un scalaire, multipliés entre eux de manière très intuitive:</font></font><br>
 <br>
<pre><code class="hljs lisp">A = B<font></font>
A = <span class="hljs-number"><span class="hljs-number">3.24</span></span>*B<font></font>
C = A*B<font></font>
B = exp(<span class="hljs-name"><span class="hljs-name">A</span></span>)<font></font>
norm = sqrt(<span class="hljs-name"><span class="hljs-name">sum</span></span>(<span class="hljs-name"><span class="hljs-name">A**2</span></span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, A, B, C sont des tableaux d'une certaine dimension (disons, 10x10x10). C = A * B nous donne la multiplication élémentaire des matrices si A et B sont de la même taille. Pour la multiplication matricielle, C = matmul (A, B) est utilisé. Presque toutes les fonctions internes de Fortran (Sin (), Exp (), Abs (), Floor (), etc.) prennent des tableaux comme arguments, ce qui conduit à un code simple et propre. Il n'y a tout simplement pas de code similaire en C / C ++. Dans une implémentation C / C ++ de base, la simple copie d'un tableau nécessite l'exécution de boucles sur tous les éléments ou l'appel d'une fonction de bibliothèque. Si vous alimentez un tableau de la mauvaise fonction de bibliothèque en C, une erreur se produit. La nécessité d'utiliser des bibliothèques au lieu de fonctions internes signifie que le code résultant ne sera pas propre et portable, ni facile à apprendre.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans Fortran, l'accès aux éléments d'un tableau fonctionne à travers la syntaxe simple A [x, y, z], quand en C / C ++ vous devez écrire A [x] [y] [z]. </font><font style="vertical-align: inherit;">Les éléments des tableaux commencent par 1, ce qui correspond à la compréhension des physiciens des matrices, et dans les tableaux C / C ++, la numérotation commence à zéro. </font><font style="vertical-align: inherit;">Voici quelques fonctionnalités supplémentaires pour travailler avec des tableaux dans Fortran.</font></font><br>
 <br>
<pre><code class="hljs lisp">A = (<span class="hljs-name"><span class="hljs-name">/</span></span> i , i = <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span> /)<font></font>
B = A(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">100</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>)<font></font>
C(<span class="hljs-number"><span class="hljs-number">10</span></span>:) = B</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Premièrement, le vecteur A est créé via une boucle do implicite, également connue sous le nom de constructeur de tableau. </font><font style="vertical-align: inherit;">Ensuite, un vecteur B est créé, composé de chaque 10e élément de A, en utilisant une étape de 10. Et, enfin, le tableau B est copié dans le tableau C, à partir du 10e élément. </font><font style="vertical-align: inherit;">Fortran prend en charge la déclaration de tableaux avec des indices nuls ou négatifs:</font></font><br>
 <br>
<pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-type"><span class="hljs-type">precision</span></span>, dimension(<span class="hljs-number"><span class="hljs-number">-1</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>) :: myArray</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un indice négatif semble à première vue idiot, mais j'ai entendu parler de leur utilité - par exemple, imaginez que c'est un domaine supplémentaire pour publier des clarifications. </font><font style="vertical-align: inherit;">Fortran prend également en charge les </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">index vectoriels</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Par exemple, vous pouvez transférer les éléments 1, 5 et 7 d'un tableau A de dimension N x 1 vers un tableau B de dimension 3 x 1:</font></font><br>
 <br>
<pre><code class="hljs lisp">subscripts = (<span class="hljs-name"><span class="hljs-name">/</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span> /)<font></font>
B = A(<span class="hljs-name"><span class="hljs-name">subscripts</span></span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortran prend en charge les </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">masques de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tableau dans toutes les fonctions internes. </font><font style="vertical-align: inherit;">Par exemple, si nous devons calculer le logarithme de tous les éléments de matrice supérieurs à zéro, nous utilisons:</font></font><br>
 <br>
<pre><code class="hljs lisp">log_of_A = log(<span class="hljs-name"><span class="hljs-name">A</span></span>, mask= A .gt. <span class="hljs-number"><span class="hljs-number">0</span></span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ou nous pouvons annuler tous les éléments négatifs du tableau sur une seule ligne:</font></font><br>
 <br>
<pre><code class="hljs lisp">where(<span class="hljs-name"><span class="hljs-name">my_array</span></span> .lt. <span class="hljs-number"><span class="hljs-number">0.0</span></span>) my_array = <span class="hljs-number"><span class="hljs-number">0.0</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortran facilite l'allocation dynamique et la disponibilité de tableaux. </font><font style="vertical-align: inherit;">Par exemple, pour placer un tableau à deux dimensions:</font></font><br>
 <br>
<pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">real</span></span>, dimension(:,:), allocatable :: name_of_array<font></font>
allocate(name_of_array(xdim, ydim))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En C / C ++, cela </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nécessite l'entrée suivante</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
 <br>
<pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> **<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>;
<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(nrows * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *));<font></font>
 <font></font>
<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &amp;lt; nrows; i++){
     <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[i] = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(ncolumns * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour libérer un tableau à Fortran</font></font><br>
 <br>
<pre><code class="hljs lisp">deallocate(<span class="hljs-name"><span class="hljs-name">name_of_array</span></span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En C / C ++ pour cela</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &amp;lt; nrows; i++){
    <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[i]);<font></font>
}<font></font>
<span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>);</code></pre><br>
<h2> :        </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans des langages comme C / C ++, toutes les variables sont passées par valeur, à l'exception des tableaux qui sont passés par référence. Mais dans de nombreux cas, le passage d'un tableau par valeur a plus de sens. Par exemple, laissez les données se composer de positions de 100 molécules à différentes périodes. Nous devons analyser le mouvement d'une molécule. Nous prenons une tranche du tableau (sous-tableau) correspondant aux coordonnées des atomes de cette molécule et la passons à la fonction. Nous y traiterons une analyse complexe du sous-réseau transmis. Si nous le transmettions par référence, les données transférées ne seraient pas localisées en mémoire dans une rangée. En raison de la nature de l'accès à la mémoire, travailler avec un tel tableau serait lent. Si nous le transmettons par valeur, nous créerons en mémoire un nouveau tableau disposé en ligne. Pour le plus grand plaisir des physiciens, le compilateur se charge de tout le sale travail d'optimisation de la mémoire.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans Fortran, les variables sont généralement transmises par référence, et non par valeur. </font><font style="vertical-align: inherit;">Sous le capot, le compilateur Fortran optimise automatiquement leur transmission pour une efficacité accrue. </font><font style="vertical-align: inherit;">Du point de vue du professeur dans le domaine de l'optimisation de l'utilisation de la mémoire, le compilateur doit faire plus confiance qu'à l'étudiant! </font><font style="vertical-align: inherit;">En conséquence, les </font><font style="vertical-align: inherit;">physiciens utilisent rarement des </font><font style="vertical-align: inherit;">pointeurs, bien que Fortran-90 + </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ils ont</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelques exemples supplémentaires des différences entre Fortran et C</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortran dispose de plusieurs options pour gérer le compilateur lors du dépannage et de l'optimisation. </font><font style="vertical-align: inherit;">Des erreurs dans le code peuvent être détectées au stade de la compilation et non lors de l'exécution. </font><font style="vertical-align: inherit;">Par exemple, toute variable peut être déclarée en tant que paramètre, c'est-à-dire une constante.</font></font><br>
<br>
<pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-type"><span class="hljs-type">precision</span></span>, parameter :: hbar = <span class="hljs-number"><span class="hljs-number">6.63e-34</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si le paramètre du code change, le compilateur renvoie une erreur. </font><font style="vertical-align: inherit;">En C, cela s'appelle </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">const</font></font></a><br>
<br>
<pre><code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hbar = <span class="hljs-number"><span class="hljs-number">6.63e-34</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le problème est que const real est différent du simple real. Si une fonction acceptant real devient const real, elle retournera une erreur. Il est facile d'imaginer comment cela peut entraîner des problèmes d'interopérabilité dans le code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortran a également une spécification d'intention qui indique au compilateur si l'argument passé à la fonction est une entrée, une sortie ou à la fois une entrée et un paramètre de sortie. Cela aide le compilateur à optimiser le code et augmente sa lisibilité et sa fiabilité.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortran possède d'autres fonctionnalités qui sont utilisées à différentes fréquences. </font><font style="vertical-align: inherit;">Par exemple, Fortran 95 a la capacité de déclarer des fonctions avec le modificateur pur. </font><font style="vertical-align: inherit;">Une telle fonction n'a pas d'effets secondaires - elle modifie uniquement ses arguments et ne modifie pas les variables globales. </font><font style="vertical-align: inherit;">Un cas particulier d'une telle fonction est la fonction élémentaire, qui accepte et renvoie des scalaires. </font><font style="vertical-align: inherit;">Il est utilisé pour traiter les éléments du tableau. </font><font style="vertical-align: inherit;">Le fait que la fonction soit pure ou élémentaire permet au compilateur d'effectuer une optimisation supplémentaire, en particulier lors de la parallélisation du code.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À quoi s'attendre à l'avenir?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans les calculs scientifiques, le Fortran reste la langue principale et ne va pas disparaître dans un futur proche. </font><font style="vertical-align: inherit;">Dans l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enquête</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parmi les visiteurs de la conférence 2014 Supercomputing Convention utilisant cette langue, 100% d'entre eux ont déclaré qu'ils allaient l'utiliser dans les 5 prochaines années. Il ressort également de l'enquête que 90% ont utilisé un mélange de Fortran et C. Anticipant une augmentation du mélange de ces langages, les créateurs de la spécification Fortran 2015 incluent plus de fonctionnalités pour l'interopérabilité du code. Le code Fortran est de plus en plus appelé à partir du code Python. Les informaticiens qui critiquent l'utilisation de Fortran ne comprennent pas que ce langage reste uniquement adapté à son nom - FOrmula TRANslation, traduisant des formules, c'est-à-dire convertissant des formules physiques en code. Beaucoup d'entre eux ne savent pas que le langage évolue et inclut constamment de nouvelles fonctionnalités.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Appeler l'ancien Fortran 90+ moderne est le même que d'appeler l'ancien C ++ car C a été développé en 1973. D'autre part, même la nouvelle norme Fortran 2008 a une compatibilité descendante avec Fortran 77 et la plupart de Fortran 66. Par conséquent, le développement de la langue est associé à certaines difficultés. </font><font style="vertical-align: inherit;">Récemment, des chercheurs du MIT ont décidé de surmonter ces difficultés en développant à partir de zéro un langage pour HPC appelé </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Julia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sorti pour la première fois en 2012. </font><font style="vertical-align: inherit;">Reste à savoir si Julia prendra la place de Fortran. </font><font style="vertical-align: inherit;">En tout cas, je soupçonne que cela prendra très longtemps.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr400523/">https://habr.com/ru/post/fr400523/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr400511/index.html">À propos de la méthode moderne de stockage du combustible nucléaire irradié</a></li>
<li><a href="../fr400513/index.html">Théorème d'incomplétude de Gödel en 20 minutes</a></li>
<li><a href="../fr400515/index.html">Blockchainer: avantages de la blockchain pour ceux qui ne conviennent pas aux crypto-monnaies</a></li>
<li><a href="../fr400519/index.html">Imprimante 3D modulaire 3D-Start comme source d'intérêt pour un chat 3D</a></li>
<li><a href="../fr400521/index.html">Apple a corrigé le bogue et accuse Consumer Reports de méthodologie de test incorrecte</a></li>
<li><a href="../fr400525/index.html">Développement d'un système de mémorisation mnémonique des nombres</a></li>
<li><a href="../fr400527/index.html">Rééchantillonnage II. Comparaison du fonctionnement des filtres numériques et analogiques d'ordre élevé dans le chemin sonore et réponses aux questions</a></li>
<li><a href="../fr400529/index.html">Équipement de salle d'opération pour la correction de la vision</a></li>
<li><a href="../fr400531/index.html">La commission de la Douma d'État a approuvé un projet de loi sur la réglementation des services audiovisuels</a></li>
<li><a href="../fr400533/index.html">Le principal paradoxe de la conscience. Pourquoi copier le cerveau ou la personnalité n'a pas de sens</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>