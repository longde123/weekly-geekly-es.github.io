<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥉 🤟🏻 🦕 Cara menggunakan coroutine dalam makanan dan tidur nyenyak di malam hari 👃 🤟🏽 📗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Coroutine adalah alat yang ampuh untuk eksekusi kode asinkron. Mereka bekerja secara paralel, berkomunikasi satu sama lain, dan menghabiskan sedikit s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara menggunakan coroutine dalam makanan dan tidur nyenyak di malam hari</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/429908/">  Coroutine adalah alat yang ampuh untuk eksekusi kode asinkron.  Mereka bekerja secara paralel, berkomunikasi satu sama lain, dan menghabiskan sedikit sumber daya.  Tampaknya tanpa rasa takut, coroutine dapat dimasukkan ke dalam produksi.  Tapi ada ketakutan dan mereka ikut campur. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Laporan</a> <strong>Vladimir Ivanov</strong> tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AppsConf</a> adalah tentang fakta bahwa iblis tidak begitu mengerikan dan Anda dapat menggunakan coroutine sekarang: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengapa coroutine, bukan RxJava</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">apa yang menghambat pengembang</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cara membuat cache menggunakan coroutine</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cara menangani kesalahan dengan benar</a> . </li></ul><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1lEG1CPkRaw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Tentang pembicara</strong> : Vladimir Ivanov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">dzigoro</a> ) adalah pengembang Android terkemuka di <strong>EPAM</strong> dengan pengalaman 7 tahun, sangat menyukai Arsitektur Solusi, React Native dan pengembangan iOS, dan juga memiliki sertifikasi <strong>Google Cloud Architect</strong> . <br><a name="habracut"></a><br><blockquote>  Semua yang Anda baca adalah produk dari pengalaman produksi dan berbagai studi, jadi anggaplah apa adanya, tanpa jaminan apa pun. <br></blockquote><h2><a name="coroutine"></a>  Coroutines, Kotlin dan RxJava </h2><br>  Sebagai informasi: status corutin saat ini dalam rilis, kiri Beta.  <strong>Kotlin 1.3</strong> dirilis, coroutine dinyatakan stabil dan ada perdamaian di dunia. <br><br><img src="https://habrastorage.org/webt/it/jm/db/itjmdbtgjewt6v1kihv_5urqxie.png"><br><br>  Baru-baru ini saya melakukan survei di Twitter bahwa orang-orang menggunakan coroutine: <br><br><ul><li>  13% coroutine dalam makanan.  Semuanya baik-baik saja; </li><li>  25% mencobanya di proyek hewan peliharaan; </li><li>  24% - Apa Kotlin? </li><li>  Sebagian besar 38% RxJava ada di mana-mana. </li></ul><br>  Statistik tidak senang.  Saya percaya bahwa <strong>RxJava adalah alat yang terlalu kompleks</strong> untuk tugas-tugas yang biasa digunakan oleh pengembang.  Coroutine lebih cocok untuk mengendalikan operasi asinkron. <br><br>  Dalam laporan saya sebelumnya, saya berbicara tentang cara refactor dari RxJava ke coroutine di Kotlin, jadi saya tidak akan membahas hal ini secara rinci, tetapi hanya mengingat poin-poin utama. <br><br><h3>  Mengapa kita menggunakan coroutine? </h3><br>  Karena jika kita menggunakan RxJava, maka contoh implementasi yang biasa terlihat seperti ini: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApiClientRx</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(auth: Authorization)</span></span></span><span class="hljs-function"> : Single&lt;GithubUser&gt; fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRepositories</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reposUrl: String, auth: Authorization)</span></span></span><span class="hljs-function"> : Single&lt;List&lt;GithubRepository&gt;&gt; } </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//RxJava 2 implementation</span></span></span></span></code> </pre> <br>  Kami memiliki antarmuka, misalnya, kami menulis klien GitHub dan ingin melakukan beberapa operasi untuk itu: <br><br><ol><li>  Pengguna login. <br></li><li>  Dapatkan daftar repositori GitHub. <br></li></ol><br>  Dalam kedua kasus, fungsi akan mengembalikan objek bisnis tunggal: GitHubUser atau daftar GitHubRepository. <br><br>  Kode implementasi untuk antarmuka ini adalah sebagai berikut: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attemptLoginRx</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ showProgress(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) compositeDisposable.add(apiClient.login(auth) .flatMap { user -&gt; apiClient.getRepositories(user.repos_url, auth) } .map { list -&gt; list.map { it.full_name } } .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doFinally { showProgress(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } .subscribe( { list -&gt; showRepositories(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, list) }, { error -&gt; Log.e(<span class="hljs-string"><span class="hljs-string">"TAG"</span></span>, <span class="hljs-string"><span class="hljs-string">"Failed to show repos"</span></span>, error) } )) }</code> </pre><br>  - Kami menggunakan <strong>compositeDisposable</strong> sehingga tidak ada kebocoran memori. <br>  - Tambahkan panggilan ke metode pertama. <br>  - Kami menggunakan operator yang nyaman untuk mendapatkan pengguna, misalnya <strong>flatMap</strong> . <br>  - Kami mendapat daftar tempat penyimpanannya. <br>  - Kami menulis <strong>Boilerplate</strong> sehingga <strong>berjalan</strong> di utas kanan. <br>  - Ketika semuanya sudah siap, kami menampilkan daftar repositori untuk pengguna yang login. <br><br>  <strong>Kesulitan Kode RxJava:</strong> <br><br><ul><li>  <strong>Kompleksitas</strong>  Menurut pendapat saya, kode ini terlalu rumit untuk tugas sederhana dari dua panggilan jaringan dan menampilkan sesuatu pada <strong>UI</strong> . </li><li>  <strong>Jejak tumpukan tidak terikat.</strong>  Jejak tumpukan hampir tidak terkait dengan kode yang Anda tulis. </li><li>  <strong>Menguasai sumber daya</strong> <strong>.</strong>  RxJava menghasilkan banyak objek di bawah tenda dan kinerja dapat menurun. </li></ul><br>  <strong>Apa yang akan menjadi kode yang sama dengan coroutine hingga versi 0.26?</strong> <br><br>  Pada 0,26, API telah berubah, dan kita berbicara tentang produksi.  Belum ada yang berhasil menerapkan 0,26 di prod, tetapi kami sedang mengusahakannya. <br><br>  <strong>Dengan coroutine, antarmuka kita akan berubah cukup signifikan</strong> .  Fungsi akan berhenti mengembalikan Singles dan objek pembantu lainnya.  Mereka akan segera mengembalikan objek bisnis: GitHubUser dan daftar GitHubRepository.  Fungsi GitHubUser dan GitHubRepository akan <strong>menangguhkan</strong> pengubah.  Ini bagus, karena menunda hampir tidak mengharuskan kita untuk apa pun: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApiClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">suspend fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(auth: Authorization)</span></span></span><span class="hljs-function"> : GithubUser suspend fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRepositories</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reposUrl: String, auth: Authorization)</span></span></span><span class="hljs-function"> : List&lt;GithubRepository&gt; } </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//Base interface</span></span></span></span></code> </pre><br>  Jika Anda melihat kode yang sudah menggunakan implementasi antarmuka ini, itu akan berubah secara signifikan dibandingkan dengan RxJava: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attemptLogin</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ launch(UI) { val auth = BasicAuthorization(login, pass) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { showProgress(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) val userlnfo = async { apiClient.login(auth) }.await() val repoUrl = userlnfo.repos_url val list = async { apiClient.getRepositories(repoUrl, auth) }.await() showRepositories( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, list.map { it -&gt; it.full_name } ) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: RuntimeException) { showToast(<span class="hljs-string"><span class="hljs-string">"Oops!"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { showProgress(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } } }</code> </pre><br>  - Tindakan utama terjadi di mana kita memanggil <strong>async</strong> <strong>buildout</strong> <strong>coroutine</strong> , menunggu respons dan dapatkan <strong>userlnfo</strong> . <br>  - Kami menggunakan data dari objek ini. <br>  - Lakukan panggilan <strong>async</strong> lain dan panggilan <strong>tunggu</strong> . <br><br>  Semuanya tampak seolah-olah tidak ada pekerjaan asinkron terjadi, dan kami hanya menulis perintah di kolom dan dieksekusi.  Pada akhirnya, kami melakukan apa yang perlu dilakukan di UI. <br><br>  <strong>Mengapa coroutine lebih baik?</strong> <br><br><ul><li>  Kode ini lebih mudah dibaca.  Ini ditulis seolah-olah konsisten. </li><li>  Kemungkinan besar kinerja kode ini lebih baik daripada di RxJava. </li><li>  Sangat mudah untuk menulis tes, tetapi kita akan mendapatkannya nanti. </li></ul><br><h2>  2 langkah ke samping <br></h2><br>  Mari ngelantur sedikit, ada beberapa hal yang masih perlu dibahas. <br><br><h3>  Langkah 1. withContext vs launch / async <br></h3><br>  Selain <strong>coroutine builder async,</strong> ada <strong>coroutine builder withContext</strong> . <br><br>  <strong>Luncurkan</strong> atau <strong>async</strong> buat <strong>konteks Coroutine</strong> baru, yang tidak selalu diperlukan.  Jika Anda memiliki konteks Coroutine yang ingin Anda gunakan di seluruh aplikasi, maka Anda tidak perlu membuatnya kembali.  Anda cukup menggunakan kembali yang sudah ada.  Untuk melakukan ini, Anda memerlukan pembuat coroutine withContext.  Itu hanya menggunakan kembali konteks Coroutine yang ada.  Ini akan menjadi 2-3 kali lebih cepat, tetapi sekarang ini adalah pertanyaan yang tidak berprinsip.  Jika angka pastinya menarik, maka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">inilah pertanyaan</a> tentang <strong>stackoverflow</strong> dengan tolok ukur dan detail. <br><br><blockquote>  <strong>Aturan umum:</strong> Gunakan withContext tanpa ragu di mana itu cocok secara semantik.  Tetapi jika Anda membutuhkan pemuatan paralel, misalnya beberapa gambar atau potongan data, maka async / tunggu adalah pilihan Anda. <br></blockquote><br><h3>  Langkah 2. Refactoring <br></h3><br>  Bagaimana jika Anda memperbaiki rantai RxJava yang sangat kompleks?  Saya menemukan ini dalam produksi: <br><br><pre> <code class="java hljs">observable1.getSubject().zipWith(observable2.getSubject(), (t1, t2) -&gt; { <span class="hljs-comment"><span class="hljs-comment">// side effects return true; }).doOnError { // handle errors } .zipWith(observable3.getSubject(), (t3, t4) -&gt; { // side effects return true; }).doOnComplete { // gather data } .subscribe()</span></span></code> </pre><br>  Saya memiliki rantai rumit dengan <strong>subjek publik</strong> , dengan <strong>zip</strong> dan <strong>efek</strong> <strong>samping</strong> di setiap <strong>ritsleting</strong> yang mengirim sesuatu yang lain ke bus acara.  Tugas paling tidak adalah menyingkirkan bus acara.  Saya duduk selama sehari, tetapi tidak bisa memperbaiki kode untuk menyelesaikan masalah.  <strong>Keputusan yang tepat ternyata membuang semuanya dan menulis ulang kode pada coroutine dalam 4 jam</strong> . <br><br>  Kode di bawah ini sangat mirip dengan yang saya dapatkan: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { val firstChunkJob = async { call1 } val secondChunkJob = async { call2 } val thirdChunkJob = async { call3 } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result( firstChunkJob.await(), secondChunkJob.await(), thirdChunkJob.await()) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { <span class="hljs-comment"><span class="hljs-comment">// handle errors }</span></span></code> </pre><br>  - Kami melakukan async untuk satu tugas, untuk yang kedua dan ketiga. <br>  - Kami menunggu hasilnya dan memasukkan semuanya ke dalam objek. <br>  - Selesai! <br><br>  Jika Anda memiliki rantai yang rumit dan ada coroutine, maka cukup refactor saja.  Ini sangat cepat. <br><br><h2><a name="fear"></a>  Apa yang mencegah pengembang menggunakan coroutine dalam produk? <br></h2><br>  Menurut pendapat saya, kami, sebagai pengembang, saat ini dicegah menggunakan coroutine hanya karena takut akan sesuatu yang baru: <br><br><ul><li>  Kita tidak tahu apa yang harus dilakukan dengan <strong>siklus hidup</strong> , <strong>aktivitas</strong> , dan siklus hidup fragmen.  Bagaimana cara bekerja dengan coroutine dalam kasus ini? </li><li>  Tidak ada pengalaman dalam menyelesaikan tugas-tugas kompleks harian dalam produksi menggunakan corutin. </li><li>  Alat tidak cukup.  Banyak perpustakaan dan fungsi telah ditulis untuk RxJava.  Misalnya <strong>RxFCM</strong> .  RxJava sendiri memiliki banyak operator, yang bagus, tetapi bagaimana dengan coroutine? </li><li>  Kami tidak benar-benar mengerti cara menguji coroutine. </li></ul><br><blockquote>  Jika kita menghilangkan empat ketakutan ini, kita dapat tidur dengan tenang di malam hari dan menggunakan coroutine dalam produksi. <br></blockquote><br>  Mari poin demi poin. <br><br><h3>  1. Manajemen siklus hidup <br></h3><br><ul><li>  Coroutine dapat bocor <strong>sekali pakai</strong> atau <strong>AsyncTask</strong> .  Masalah ini harus diselesaikan secara manual. </li><li>  Untuk menghindari <strong>Pengecualian Null Pointer</strong> acak <strong>,</strong> coroutine harus dihentikan. </li></ul><br><h4>  Berhenti <br></h4><br>  Apakah Anda terbiasa dengan <strong>Thread.stop ()</strong> ?  Jika Anda menggunakannya, maka tidak lama.  Di <strong>JDK 1.1,</strong> metode ini segera dinyatakan usang, karena tidak mungkin untuk mengambil dan menghentikan kode tertentu dan tidak ada jaminan bahwa itu akan selesai dengan benar.  Kemungkinan besar Anda hanya akan mendapatkan <strong>kerusakan memori</strong> . <br><br>  Karenanya, <strong>Thread.stop () tidak berfungsi</strong> .  Anda perlu pembatalan agar kooperatif, yaitu kode di sisi lain untuk mengetahui bahwa Anda membatalkannya. <br><br>  Bagaimana kami menerapkan pemberhentian dengan RxJava: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val compositeDisposable = CompositeDisposable() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ compositeDisposable.add( apiClientRx.requestSomething() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(result -&gt; {}) } <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ compositeDisposable.dispose() }</code> </pre><br><br>  Dalam RxJava kita <strong>menggunakan CompositeDisposable</strong> . <br><br>  - Tambahkan variable <strong>compositeDisposable</strong> ke aktivitas di fragmen atau di presenter, di mana kita menggunakan RxJava. <br>  - Dalam <strong>onDestro</strong> tambahkan <strong>Buang</strong> dan semua pengecualian hilang dengan sendirinya. <br><br>  Kira-kira prinsipnya sama dengan coroutine: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val job: Job? = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">null</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job = launch(UI) { val user = apiClient.requestSomething() … } } <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job?.cancel() }</code> </pre><br>  Pertimbangkan contoh <strong>tugas sederhana</strong> . <br><br>  Biasanya, <strong>pembangun coroutine</strong> mengembalikan <strong>pekerjaan</strong> , dan dalam beberapa kasus <strong>ditangguhkan</strong> . <br><br>  - Kita bisa mengingat pekerjaan ini. <br>  - Berikan perintah <strong>"luncurkan"</strong> <strong>pembangun coroutine</strong> .  Proses dimulai, sesuatu terjadi, hasil eksekusi diingat. <br>  - Jika kami tidak meneruskan hal lain, maka "luncurkan" memulai fungsinya dan mengembalikan kami tautan ke pekerjaan itu. <br>  - Pekerjaan diingat, dan dalam onDestroy kita katakan <strong>"batal"</strong> dan semuanya bekerja dengan baik. <br><br>  <strong>Apa masalah dari pendekatan ini?</strong>  Setiap pekerjaan membutuhkan bidang.  Anda perlu mempertahankan daftar pekerjaan untuk membatalkan semuanya.  Pendekatan ini mengarah pada duplikasi kode, jangan lakukan itu. <br><br>  Berita baiknya adalah kita memiliki <strong>alternatif</strong> : pekerjaan <strong>CompositeJob</strong> dan <strong>Lifecycle-aware</strong> . <br><br>  CompositeJob adalah analog dari compositeDisposable.  Itu terlihat seperti ini <strong>:</strong> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val job: CompositeJob = CompositeJob() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job.add(launch(UI) { val user = apiClient.requestSomething() ... }) } <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job.cancel() }</code> </pre><br>  - Untuk satu fragmen kami memulai satu pekerjaan. <br>  - Kami menempatkan semua <strong>pekerjaan</strong> di CompositeJob dan memberikan perintah: <strong>"job.cancel () untuk semua orang!"</strong>  . <br><br>  Pendekatan ini mudah diimplementasikan dalam 4 baris, tidak termasuk deklarasi kelas: <br><br><pre> <code class="java hljs">Class CompositeJob { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val map = hashMapOf&lt;String, Job&gt;() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(job: Job, key: String = job.hashCode()</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">) </span></span>= map.put(key, job)?.cancel() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key: String)</span></span></span><span class="hljs-function"> </span></span>= map[key]?.cancel() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= map.forEach { _ ,u -&gt; u.cancel() } }</code> </pre><br><br>  Anda akan membutuhkan: <br><br>  - <strong>peta</strong> dengan kunci string, <br>  - <strong>tambahkan</strong> metode, di mana Anda akan menambahkan pekerjaan, <br>  - parameter <strong>kunci</strong> opsional. <br><br>  Jika Anda ingin menggunakan kunci yang sama untuk pekerjaan yang sama - silakan.  Jika tidak, maka <strong>hashCode</strong> akan menyelesaikan masalah kita.  Tambahkan pekerjaan ke peta, yang kami lewati, dan batalkan yang sebelumnya dengan kunci yang sama.  Jika kami memenuhi tugas secara berlebihan, maka hasil sebelumnya tidak menarik bagi kami.  Kami membatalkannya dan mengendarainya lagi. <br><br>  Batalkan itu sederhana: kami mendapatkan pekerjaan dengan kunci dan membatalkan.  Pembatalan kedua untuk seluruh peta membatalkan semuanya.  Semua kode ditulis dalam setengah jam dalam empat baris dan berfungsi.  Jika Anda tidak ingin menulis, ambil contoh di atas. <br><br><h4>  Pekerjaan sadar siklus </h4><br>  Sudahkah Anda menggunakan <strong>Siklus Hidup Android</strong> , <strong>pemilik</strong> atau <strong>pengamat</strong> <strong>Siklus Hidup</strong> ? <br><img src="https://habrastorage.org/webt/ud/pi/eq/udpieqn_xba30yasl2buwbs2bay.png"><br><br>  <strong>Aktivitas</strong> dan <strong>fragmen kami</strong> memiliki status tertentu.  Sorotan: <strong>dibuat,</strong> <strong>dimulai</strong> dan <strong>dilanjutkan</strong> .  Ada transisi yang berbeda antar negara.  <strong>LifecycleObserver</strong> memungkinkan Anda untuk berlangganan transisi ini dan melakukan sesuatu ketika salah satu transisi terjadi. <br><br>  Ini terlihat sangat sederhana: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyObserver</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LifecycleObserver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent</span></span>(Lifecycle.Event.ON_RESUME) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connectListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent</span></span>(Lifecycle.Event.ON_PAUSE) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disconnectListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ … } }</code> </pre><br>  Anda menutup anotasi dengan beberapa parameter pada metode, dan disebut dengan transisi yang sesuai.  Cukup gunakan pendekatan ini untuk coroutine: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AndroidJob</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lifecycle</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lifecycle</span></span></span><span class="hljs-class">) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">by</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class">(), </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LifecycleObserver</span></span></span><span class="hljs-class"> </span></span>{ init { lifecycle.addObserver(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent</span></span>(Lifecycle.Event.ON_DESTROY) <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Log.d(<span class="hljs-string"><span class="hljs-string">"AndroidJob"</span></span>, <span class="hljs-string"><span class="hljs-string">"Cancelling a coroutine"</span></span>) cancel() } }</code> </pre><br>  - Anda dapat menulis <strong>AndroidJob</strong> kelas dasar. <br>  - Kami akan mentransfer <strong>Lifecycle ke</strong> kelas. <br>  - Antarmuka <strong>LifecycleObserver</strong> akan mengimplementasikan pekerjaan itu. <br><br>  Yang kita butuhkan: <br><br>  - Dalam konstruktor tambahkan ke Lifecycle sebagai Pengamat. <br>  - Berlangganan <strong>ON_DESTROY</strong> atau apa pun yang menarik minat kami. <br>  - Buat pembatalan di ON_DESTROY. <br>  - <strong>Dapatkan</strong> satu <strong>parentJob</strong> di fragmen Anda. <br>  - Panggil <strong>pekerjaan Joy</strong> konstruktor atau <strong>siklus hidup</strong> fragmen aktivitas Anda.  Tidak ada perbedaan. <br>  - Lulus <strong>parentJob</strong> ini sebagai <strong>orangtua</strong> . <br><br>  Kode yang sudah selesai terlihat seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parentJob = AndroidJob(lifecycle) <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job = launch(UI, parent = parentJob) { <span class="hljs-comment"><span class="hljs-comment">// code } }</span></span></code> </pre><br>  Ketika Anda membatalkan orang tua, semua coroutine anak dibatalkan dan Anda tidak perlu lagi menulis apa pun di fragmen.  Semuanya terjadi secara otomatis, tidak ada lagi ON_DESTROY.  Yang utama jangan lupa lewat <strong>parent = parentJob</strong> . <br><br><blockquote>  Jika Anda menggunakan, Anda dapat menulis aturan serat sederhana yang akan menyoroti Anda: "Oh, Anda lupa orang tua Anda!" <br></blockquote><br>  Dengan <strong>&nbsp;</strong>  Manajemen siklus hidup beres.  Kami memiliki beberapa alat yang memungkinkan Anda melakukan ini dengan mudah dan nyaman. <br><br>  Bagaimana dengan skenario kompleks dan tugas-tugas non-sepele dalam produksi? <br><br><h3>  2. Kasus penggunaan yang kompleks <br></h3><br>  Skenario kompleks dan tugas non-sepele adalah: <br><br>  - <strong>Operator</strong> - operator kompleks di RxJava: flatMap, debounce, dll. <br>  - <strong>Penanganan</strong> kesalahan - penanganan kesalahan yang kompleks.  Bukan hanya <strong>coba..tangkap</strong> , tapi bersarang misalnya. <br>  - <strong>Caching</strong> <strong>adalah tugas yang</strong> tidak sepele.  Dalam produksi, kami mengalami cache dan ingin mendapatkan alat untuk dengan mudah menyelesaikan masalah caching dengan coroutine. <br><br><h4>  Ulangi </h4><br>  Ketika kami memikirkan operator untuk coroutine, opsi pertama adalah <strong>repeatWhen ()</strong> . <br><br>  Jika ada yang tidak beres dan Corutin tidak dapat menjangkau server di dalam, maka kami ingin mencoba lagi beberapa kali dengan semacam fallon eksponensial.  Mungkin alasannya adalah koneksi yang buruk dan kami akan mendapatkan hasil yang diinginkan dengan mengulangi operasi beberapa kali. <br><br>  Dengan coroutine, tugas ini mudah diimplementasikan: <br><br><pre> <code class="java hljs">suspend fun &lt;T&gt; retryDeferredWithDelay( deferred: () -&gt; Deferred&lt;T&gt;, tries: Int = <span class="hljs-number"><span class="hljs-number">3</span></span>, timeDelay: Long = <span class="hljs-number"><span class="hljs-number">1000L</span></span> ): T { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i in <span class="hljs-number"><span class="hljs-number">1</span></span>..tries) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deferred().await() } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; tries) delay(timeDelay) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> e } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> UnsupportedOperationException() }</code> </pre><br><br>  Implementasi operator: <br><br>  - Dia mengambil <strong>Ditangguhkan</strong> . <br>  - Anda harus memanggil <strong>async</strong> untuk mendapatkan objek ini. <br>  - Alih-alih <strong>Ditangguhkan,</strong> Anda dapat melewati kedua blok penangguhan dan umumnya semua <strong>fungsi penangguhan.</strong> <br>  - Loop <strong>for</strong> - Anda sedang menunggu hasil coroutine Anda.  Jika sesuatu terjadi dan penghitung pengulangan tidak habis, coba lagi melalui <strong>Penundaan</strong> .  Jika tidak, maka tidak. <br><br>  Fungsi ini dapat dengan mudah disesuaikan: menempatkan Delay eksponensial atau meneruskan fungsi lambda yang akan menghitung Delay tergantung pada keadaan. <br><br>  Gunakan, itu berhasil! <br><br><h4>  Ritsleting </h4><br>  Kami juga sering menjumpai mereka.  Di sini sekali lagi, semuanya sederhana: <br><br><pre> <code class="java hljs">suspend fun &lt;T1, T2, R&gt; zip( source1: Deferred&lt;T1&gt;, source2: Deferred&lt;T2&gt;, zipper: BiFunction&lt;T1, T2, R&gt;): R { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zipper.apply(sourcel.await(), source2.await()) } suspend fun &lt;T1, T2, R&gt; Deferred&lt;T1&gt;.zipWith( other: Deferred&lt;T2&gt;, zipper: BiFunction&lt;T1, T2, R&gt;): R { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zip(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, other, zipper) }</code> </pre><br>  - Gunakan <strong>ritsleting</strong> dan panggilan menunggu ditangguhkan Anda. <br>  - Alih-alih Ditangguhkan, Anda dapat menggunakan fungsi menangguhkan dan pembangun coroutine dengan withContext.  Anda akan menyampaikan konteks yang Anda butuhkan. <br><br>  Ini kembali berfungsi dan saya harap saya menghilangkan rasa takut ini. <br><br><a name="cache"></a><h3>  Cache </h3><br><br>  Apakah Anda memiliki implementasi cache dalam produksi dengan RxJava?  Kami menggunakan RxCache. <br><img src="https://habrastorage.org/webt/tz/ym/tn/tzymtn1tykponnxcmz0qqi_qjmi.png"><br><br>  Di diagram di sebelah kiri: <strong>View</strong> and <strong>ViewModel</strong> .  Di sebelah kanan adalah sumber data: panggilan jaringan dan database. <br><br>  Jika kita ingin sesuatu di-cache, maka cache akan menjadi sumber data lain. <br><br>  Jenis Cache: <br><br><ul><li>  <strong>Sumber Jaringan</strong> untuk panggilan jaringan. </li><li>  <strong>Cache dalam memori</strong> . </li><li>  <strong>Cache persisten</strong> dengan kedaluwarsa untuk disimpan di disk sehingga cache bisa selamat dari restart aplikasi. </li></ul><br>  Mari kita tulis <strong>cache</strong> sederhana dan primitif untuk kasus ketiga.  Pembangun Coroutine withContext datang untuk menyelamatkan lagi. <br><br><pre> <code class="java hljs">launch(UI) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = withContext(dispatcher) { persistence.getData() } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { data = withContext(dispatcher) { memory.getData() } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { data = withContext(dispatcher) { network.getData() } memory.cache(url, data) persistence.cache(url, data) } } }</code> </pre><br>  - Anda menjalankan setiap operasi dengan withContext dan melihat apakah ada data yang datang. <br>  - Jika data dari <strong>kegigihan</strong> tidak datang, maka Anda mencoba untuk mendapatkannya dari <strong>memory.cache</strong> . <br>  - Jika tidak ada memory.cache, maka hubungi <strong>sumber jaringan</strong> dan dapatkan data Anda.  Jangan lupa, tentu saja, untuk menaruh semua cache. <br><br>  Ini adalah implementasi yang agak primitif dan ada banyak pertanyaan, tetapi metode ini berfungsi jika Anda memerlukan cache di satu tempat.  Untuk tugas-tugas produksi, cache ini tidak cukup.  Dibutuhkan sesuatu yang lebih rumit. <br><br><h4>  Rx memiliki RxCache </h4><br>  Bagi yang masih menggunakan RxJava, Anda bisa menggunakan RxCache.  Kami masih menggunakannya juga.  <strong>RxCache</strong> adalah perpustakaan khusus.  Memungkinkan Anda untuk menyimpan data dan mengatur siklus hidupnya. <br><br>  Misalnya, Anda ingin mengatakan bahwa data ini akan kedaluwarsa setelah 15 menit: "Tolong, setelah periode waktu ini jangan mengirim data dari cache, tetapi kirimkan saya data baru." <br><br>  Perpustakaannya luar biasa karena secara deklaratif mendukung tim.  Deklarasi ini sangat mirip dengan apa yang Anda lakukan dengan <strong>Retrofit</strong> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeatureConfigCacheProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@ProviderKey</span></span>(<span class="hljs-string"><span class="hljs-string">"features"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@LifeCache</span></span>(duration = <span class="hljs-number"><span class="hljs-number">15</span></span>, timeUnit = TimeUnit.MINUTES) <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFeatures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( result: Observable&lt;Features&gt;, cacheName: DynamicKey )</span></span></span><span class="hljs-function">: Observable&lt;Reply&lt;Features&gt;&gt; }</span></span></code> </pre><br>  - Anda mengatakan bahwa Anda memiliki <strong>CacheProvider</strong> . <br>  - Mulai metode dan katakan bahwa masa pakai <strong>LifeCache adalah</strong> 15 menit.  Kunci yang akan tersedia adalah <strong>Fitur</strong> . <br>  - Returns <strong>Observable &lt;Balas</strong> , di mana <strong>Balas</strong> adalah objek perpustakaan bantu untuk bekerja dengan cache. <br><br>  Penggunaannya cukup sederhana: <br><br><pre> <code class="java hljs">val restObservable = configServiceRestApi.getFeatures() val features = featureConfigCacheProvider.getFeatures( restObservable, DynamicKey(CACHE_KEY) )</code> </pre><br>  - Dari cache Rx, akses <strong>RestApi</strong> . <br>  - <strong>Beralih</strong> ke <strong>CacheProvider</strong> . <br>  - Beri dia sebuah Observable. <br>  - Perpustakaan itu sendiri akan mencari tahu apa yang harus dilakukan: pergi ke cache atau tidak, jika waktu habis, beralih ke <strong>Diamati</strong> dan melakukan operasi lain. <br><br>  Menggunakan perpustakaan sangat mudah dan saya ingin mendapatkan yang serupa untuk coroutine. <br><br><h4>  Cache Coroutine dalam pengembangan </h4><br>  Di dalam EPAM, kami sedang menulis pustaka <strong>Coroutine Cache</strong> , yang akan melakukan semua fungsi RxCache.  Kami menulis versi pertama dan menjalankannya di dalam perusahaan.  Segera setelah rilis pertama keluar, saya akan dengan senang hati mempostingnya di Twitter saya.  Ini akan terlihat seperti ini: <br><br><pre> <code class="java hljs">val restFunction = configServiceRestApi.getFeatures() val features = withCache(CACHE_KEY) { restFunction() }</code> </pre><br>  Kami akan memiliki fungsi penangguhan <strong>getFeatures</strong> .  Kami akan meneruskan fungsi sebagai blok ke fungsi tingkat tinggi khusus <strong>denganCache</strong> , yang akan <strong>mencari</strong> tahu apa yang perlu dilakukan. <br><br>  Mungkin kita akan membuat antarmuka yang sama untuk mendukung fungsi deklaratif. <br><br><a name="err"></a><h3>  Menangani kesalahan <br></h3><br><img src="https://habrastorage.org/webt/sd/qq/uc/sdqqucxxckqchfozdoknxa3vi-k.png"><br><br>  Penanganan kesalahan sederhana sering ditemukan oleh pengembang dan biasanya diselesaikan dengan cukup sederhana.  Jika Anda tidak memiliki hal-hal yang rumit, maka Anda dapat menangkap <strong>pengecualian</strong> dan melihat apa yang terjadi di sana, menulis ke log atau menunjukkan kesalahan kepada pengguna.  Di UI, Anda dapat dengan mudah melakukan ini. <br><br>  Dalam kasus sederhana, semuanya diharapkan sederhana - penanganan kesalahan dengan coroutine dilakukan melalui <strong>try-catch-akhirnya</strong> . <br><br>  Dalam produksi, selain kasus-kasus sederhana, ada: <br><br>  - <strong>Mencoba-</strong> bersarang, <br>  - Berbagai macam <strong>pengecualian</strong> , <br>  - Kesalahan dalam jaringan atau dalam logika bisnis, <br>  - Kesalahan pengguna.  Dia kembali melakukan kesalahan dan harus disalahkan atas segalanya. <br><br>  Kita harus siap untuk ini. <br><br>  Ada 2 solusi: <strong>CoroutineExceptionHandler</strong> dan pendekatan dengan <strong>kelas Hasil</strong> . <br><br><h3>  Penangan Pengecualian Coroutine <br></h3><br>  Ini adalah kelas khusus untuk menangani kasus kesalahan yang kompleks.  <strong>ExceptionHandler</strong> memungkinkan Anda untuk menganggap <strong>Exception</strong> sebagai suatu kesalahan dan menanganinya. <br><br>  Bagaimana biasanya kita menangani kesalahan kompleks? <br><br>  Pengguna menekan sesuatu, tombolnya tidak bekerja.  Dia perlu mengatakan apa yang salah dan mengarahkannya ke tindakan tertentu: periksa Internet, Wi-Fi, coba nanti atau hapus aplikasi dan jangan pernah menggunakannya lagi.  Mengatakan ini kepada pengguna bisa sangat sederhana: <br><br><pre> <code class="java hljs">val handler = CoroutineExceptionHandler(handler = { , error -&gt; hideProgressDialog() val defaultErrorMsg = <span class="hljs-string"><span class="hljs-string">"Something went wrong"</span></span> val errorMsg = when (error) { is ConnectionException -&gt; userFriendlyErrorMessage(error, defaultErrorMsg) is HttpResponseException -&gt; userFriendlyErrorMessage(Endpoint.EndpointType.ENDPOINT_SYNCPLICITY, error) is EncodingException -&gt; <span class="hljs-string"><span class="hljs-string">"Failed to decode data, please try again"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; defaultErrorMsg } Toast.makeText(context, errorMsg, Toast.LENGTH_SHORT).show() })</code> </pre><br>  - Mari kita pesan default: "Ada yang salah!"  dan menganalisis pengecualian. <br>  - Jika ini adalah <strong>ConnectionException,</strong> maka kami mengambil pesan lokal dari sumber daya: “Man, nyalakan Wi-Fi dan masalah Anda akan hilang.  Saya jamin itu. " <br>  - Jika <strong>server mengatakan sesuatu yang salah</strong> , maka Anda harus memberi tahu klien: "Keluar dan masuk lagi", atau "Jangan lakukan ini di Moskow, lakukan di negara lain", atau "Maaf, kawan.  Yang bisa saya lakukan hanyalah mengatakan ada yang tidak beres. ” <br>  - Jika ini adalah <strong>kesalahan yang sama</strong> sekali <strong>berbeda</strong> , misalnya, <strong>kehabisan memori</strong> , kami mengatakan: "Ada yang salah, maafkan aku." <br>  - Semua pesan ditampilkan. <br><br>  Apa yang Anda tulis ke <strong>CoroutineExceptionHandler</strong> akan dieksekusi pada <strong>Dispatcher yang</strong> sama di mana Anda menjalankan coroutine.  Karena itu, jika Anda memberikan perintah "luncurkan" UI, maka semuanya terjadi pada UI.  Anda tidak perlu <strong>pengiriman</strong> terpisah <strong>,</strong> yang sangat nyaman. <br><br>  Gunakan sederhana: <br><br><pre> <code class="java hljs">launch(uiDispatcher + handler) { ... }</code> </pre><br>  Ada operator <strong>plus</strong> .  Dalam konteks Coroutine, tambahkan <strong>handler</strong> dan semuanya berfungsi, yang sangat nyaman.  Kami menggunakan ini untuk sementara waktu. <br><br><h3>  Kelas hasil <br></h3><br>  Kemudian kami menyadari bahwa CoroutineExceptionHandler mungkin hilang.  Hasilnya, yang dibentuk oleh karya coroutine, dapat terdiri dari beberapa data, dari bagian yang berbeda atau proses beberapa situasi. <br><br>  Pendekatan <strong>kelas hasil</strong> membantu untuk mengatasi masalah ini: <br><br><pre> <code class="java hljs">sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">data class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Success</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val payload: String)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> data class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val exception: Exception)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> }</span></span></code> </pre><br>  - Dalam logika bisnis Anda, Anda memulai <strong>kelas Hasil</strong> . <br>  - Tandai sebagai <strong>disegel</strong> . <br>  - Anda mewarisi dari kelas dua kelas data lainnya: <strong>Sukses</strong> dan <strong>Kesalahan</strong> . <br> —  <strong>Success</strong>   ,     . <br> —  <strong>Error</strong>  exception. <br><br>     -  : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">override suspend fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: Result </span></span>= withContext(CommonPool) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !isSessionValidForTask() ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span><span class="hljs-meta"><span class="hljs-meta">@withContext</span></span> Result.Error(Exception()) } … <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Result.Success(restApi.call()) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { Result.Error(e) } }</code> </pre><br>  Coroutine context — Coroutine builder withContex     . <br><br> ,  : <br><br> —   ,   error.     . <br> —   RestApi   -. <br> —   ,   <strong>Result.Success</strong> . <br> —   ,  <strong>Result.Error</strong> . <br><br>      - ,  ExceptionHandler   . <br><br> Result classes ,   .   Result classes,      ExceptionHandler  try-catch. <br><br><h3> 3.  <br></h3><br> ,       .    <strong>unit-</strong> ,   ,    .       unit-. <br><br> ,   .   ,   unit-,    2 : <br><br><ol><li> <strong>Replacing context</strong> .   ,    ; </li><li> <strong>Mocking coroutines</strong> .   . </li></ol><br><h4> Replacing context <br></h4><br>   presenter: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">val </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ launch(UI) { … } }</code> </pre><br> ,    <strong>login</strong>    ,     UI-.      ,        ,  <strong>         </strong> .    ,    ,   unit-. <br><br>   : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">val </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val coroutineContext = UI)</span></span></span><span class="hljs-function"> </span></span>{ launch(coroutineContext) { ... } }</code> </pre><br> —   login   coroutineContext. ,            .  Kotlin   ,     UI  . <br> —   Coroutine builder   Coroutine Contex,    . <br><br>  unit-   : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ val presenter = LoginPresenter () presenter.login(Unconfined) }</code> </pre><br><br> —    <strong>LoginPresenter</strong>   login   - , ,  Unconfined. <br> — <strong>Unconfined</strong> ,      ,    .         . <br><br><h4> Mocking coroutines <br></h4><br>   —  .    <strong>Mockk</strong>  unit-.     unit-    Kotlin,      .  suspend-        <strong>coEvery</strong>        -. <br><br>   login     <strong>githubUser</strong> : <br><br><pre> <code class="java hljs">coEvery { apiClient.login(any()) } returns githubUser</code> </pre><br>    <strong>Mockito-kotlin</strong> ,     —    . ,    ,     : <br><br><pre> <code class="java hljs">given { runBlocking { apiClient.login(any()) } }.willReturn (githubUser)</code> </pre><br>    <strong>runBlocking</strong> .  <strong>given-</strong>    ,    . <br><br>        <strong>Presenter</strong> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ val githubUser = GithubUser(<span class="hljs-string"><span class="hljs-string">'login'</span></span>) val presenter = LoginPresenter(mockApi) presenter.login (Unconfined) assertEquals(githubUser, presenter.user()) }</code> </pre><br> —   -, , <strong>GitHubUser</strong> . <br> —  LoginPresenter      API,     .      . <br> —   <strong>presenter.login</strong>  Unconfined   ,   Presenter    ,   . <br><br>  Dan itu saja!    . <br><br><h2>   <br></h2><br><br><ul><li> <strong> Rx-   .</strong>      .      ,  RxJava  RxJava.     -  —   ,   . </li><li> <strong>   .</strong>   ,       . Unit- —       ,  ,     ,    .  — welcome! </li><li> <strong>   .</strong>   ,  ,   ,   ,      .       . </li></ul><br><br><h3>  Tautan yang bermanfaat <br></h3><br><ul><li>      ,      Android GDE   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Android Coroutine Recipes</a> .     ,      : lifeCircle, coroutineContexts,   Coroutine builders   . </li><li> <a href="">  </a>  GitHub. </li><li>     Android  Kotlin,      ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> <strong>Codelab</strong></a> . </li><li>           .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Twitter</a>       . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong> Medium</strong></a>     «»      Android,   async-   . </li></ul><br><blockquote>  <strong>Berita</strong> <br><br> 30    Mail.ru   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a>      .  ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . <br><br>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AppsConf</a>   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a>   . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> ,   ,       ,       . <br><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">youtube-</a>       AppsConf 2018 —    :) <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id429908/">https://habr.com/ru/post/id429908/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id429892/index.html">xonsh - python sebagai pengganti shell</a></li>
<li><a href="../id429894/index.html">Menggunakan mata Ikan pada Raspberry Pi 3 dengan ROS - Bagian 2</a></li>
<li><a href="../id429898/index.html">DMS (Sistem Manajemen Dealer) - Implementasi Sistem Informasi Eco untuk mengelola jaringan Dealer</a></li>
<li><a href="../id429902/index.html">Page Rank di Era Web 2.0 - Bagian 1</a></li>
<li><a href="../id429904/index.html">Cerita lucu dan sedih tentang perkembangan game komputer</a></li>
<li><a href="../id429910/index.html">AppsConf Naik</a></li>
<li><a href="../id429912/index.html">Pengembangan perpustakaan: dari API ke rilis publik</a></li>
<li><a href="../id429914/index.html">OpenSceneGraph: Grafik Adegan dan Pointer Cerdas</a></li>
<li><a href="../id429916/index.html">Cara membangun dan membangun</a></li>
<li><a href="../id429918/index.html">Intel Dunia Virtual. Bagian 2: SMP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>