<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔌 🅿️ 👵🏽 Ir a estructuras de datos hoja de trucos 🎰 🤚🏿 🧑🏾‍🤝‍🧑🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Algunas compañías entrevistan el código de escritura en línea. Es necesario resolver el problema de la olimpiada para la velocidad. En tales circunsta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ir a estructuras de datos hoja de trucos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456194/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/mb/ec/q7/mbecq74rttiedgg0jjosbjzsaua.jpeg" width="300"></div><br>  Algunas compañías entrevistan el código de escritura en línea.  Es necesario resolver el problema de la olimpiada para la velocidad.  En tales circunstancias, no hay tiempo para ver los detalles de la implementación de estructuras de datos; debe darse cuenta de inmediato de la idea.  Pero los cursos sobre algoritmos y estructuras de datos proporcionan ejemplos en pseudocódigo o C ++.  A menudo se escriben más soluciones de referencia a los problemas en C ++.  Preparándome para una entrevista, hice una cuna de bibliotecas, análogos de contenedores STL, para no perder un tiempo precioso buscando. <br><a name="habracut"></a><br>  Comencemos con lo obvio. <br><br><h3>  Matriz continua dinámica </h3><br>  Analog <code>std::vector</code> . <br>  Admite el acceso a un elemento por índice durante un tiempo constante de varios ciclos de procesador.  Puede aumentar o disminuir la capacidad.  Este es el segmento incorporado: <br><br><pre> <code class="go hljs">vector := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{}</code> </pre><br>  Convenientemente, los conceptos básicos están integrados en el lenguaje. <br><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Pila</a> </h3><br>  Análogo de <code>std::stack</code> . <br><br>  Un conjunto ordenado en el que agregar elementos nuevos y eliminar los existentes se realiza desde un extremo.  El elemento que se colocó en último lugar (último en entrar, primero en salir - LIFO) se elimina primero de la pila.  Esta es nuevamente una rebanada amurallada.  Los fragmentos se copian de proyecto a proyecto: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Push stack = append(stack, value)</span></span></code> </pre><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Pop // ,  len(stack) &gt; 0 stack, value = a[:len(stack)-1], a[len(stack)-1]</span></span></code> </pre><br>  La operación de división no asigna una nueva memoria. <br><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cola</a> </h3><br>  Análogo de <code>std::queue</code> y <code>std::deque</code> . <br><br>  Las colas implementan operaciones de recuperación y adición para iniciar y finalizar en tiempo constante.  El elemento que se colocó primero (primero en entrar, primero en salir - FIFO) se elimina primero de la cola.  Un canal almacenado en una memoria intermedia es una cola en un búfer en anillo, puede usarlo cuando el lector y el escritor son diferentes rutinas.  Pero no hay una implementación de cola separada en la biblioteca estándar.  La lista <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">awesome-go</a> aconseja a la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/gammazero/deque</a> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/gammazero/deque"</span></span></code> </pre><br>  Operaciones en curso: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(q *Deque)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PushBack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(elem </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(q *Deque)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PushFront</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(elem </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(q *Deque)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PopBack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(q *Deque)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PopFront</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(q *Deque)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Back</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(q *Deque)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Front</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(q *Deque)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">At</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{}</code> </pre><br><h3>  Lista doblemente vinculada </h3><br>  Análogo a <code>std::list</code> . <br>  Se compone de elementos que contienen, además de sus propios datos, enlaces al elemento de la lista siguiente y anterior.  Está en la biblioteca estándar: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"container/list"</span></span></code> </pre><br>  Como se esperaba, admite operaciones de inserción (al principio, al final, antes y después del elemento, el puntero al que se pasa) y eliminación. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(l *List)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PushBack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Element</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(l *List)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PushFront</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Element</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(l *List)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InsertAfter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, mark *Element)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Element</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(l *List)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InsertBefore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, mark *Element)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Element</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(l *List)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *Element)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{}</code> </pre><br>  Go no proporciona una sintaxis específica para los iteradores.  Por lo tanto, el elemento siguiente / anterior se puede obtener de un puntero a cualquier nodo.  Estos métodos no salen mal después de agregar / eliminar un elemento de la lista, sin sorpresas. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *Element)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Element</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *Element)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Prev</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Element</span></span></span></span></code> </pre><br><h3>  Cola de prioridad </h3><br>  Analog <code>std::priority_queue</code> <br>  Le permite apilar elementos en cualquier orden y obtener en cualquier momento la máxima prioridad del resto.  Se utiliza, por ejemplo, en el algoritmo para construir un árbol de expansión mínimo, cuando, en el siguiente paso, el algoritmo selecciona el borde más corto de todos comenzando en los vértices ya cubiertos en un extremo. <br><br>  La biblioteca estándar tiene un adaptador que convierte cualquier contenedor ordenable (que implementa <code>sort.Interface</code> ) en una cola prioritaria. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"container/heap"</span></span></code> </pre><br>  Este es un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">montón binario</a> clásico.  Implementa inserción y eliminación en O (log n). <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(h Interface)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(h Interface, x </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(h Interface, i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{}</code> </pre><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tabla hash</a> </h3><br>  Es un diccionario y una matriz asociativa. <br><br>  Analog <code>std::unordered_map</code> . <br><br>  Le permite agregar un valor clave, eliminar el valor por clave y verificar la presencia de un elemento para O (1) en promedio.  Obviamente, el mapa está integrado en el lenguaje: <br><br><pre> <code class="go hljs">unorderedMap := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)</code> </pre><br>  El resultado de make (map) es un puntero, y la forma en que funciona es ligeramente diferente de los contenedores estándar: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//  : _, ok := unorderedMap["route"] //  : delete(unorderedMap, "route") //  : n := len(unorderedMap)</span></span></code> </pre><br>  "Runtime / map", a diferencia de std :: unordered_map, se encarga del programador; es seguro eliminar valores durante la iteración. <br><br><h3>  Muchos </h3><br>  Analog <code>std::unordered_set</code> . <br>  Casi lo mismo que una tabla hash, pero sin guardar el valor. <br>  Si solo necesitamos una verificación de entrada rápida, entonces podemos usar el mapa incorporado nuevamente.  Solo es necesario especificar un valor vacío para indicar que solo la clave es importante. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{}) m[<span class="hljs-string"><span class="hljs-string">"!"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{}{} _, ok := m[<span class="hljs-string"><span class="hljs-string">"!"</span></span>] <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre><br>  Pero esta implementación no admite operadores complejos.  Para fusionar, intersecar, la diferencia con el cuadro, necesita bibliotecas de terceros.  Más utilizado, a juzgar por el número de estrellas: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/deckarep/golang-set</a> <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/deckarep/golang-set"</span></span></code> </pre><br>  La parte más necesaria de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API</a> : <br><br><pre> <code class="go hljs">Add(i <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Remove(i <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Cardinality() <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-comment"><span class="hljs-comment">// len() Contains(i ...interface{}) bool IsSubset(other Set) bool Intersect(other Set) Set Union(other Set) Set Difference(other Set) Set SymmetricDifference(other Set) Set</span></span></code> </pre><br><h3>  Establecer int </h3><br>  En la parte experimental de la biblioteca estándar hay un conjunto optimizado int que guarda cada bit. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"golang.org/x/tools/container/intsets"</span></span></code> </pre><br>  También admite unión, intersección, diferencia de conjuntos. <br><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Árboles de búsqueda binaria</a> </h3><br>  Análogos <code>std::set</code> y <code>std::map</code> . <br>  Puede parecer un novato análogos malos de tablas hash: <br>  también admite agregar, eliminar y verificar ocurrencias, pero más allá de O (log n). <br>  Pero los árboles almacenan nodos ordenados por clave. <br><br>  No hay árboles en la biblioteca go estándar, se utiliza ampliamente un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio que</a> contiene AVL, Rojo-Negro y B-trees. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/emirpasic/gods/trees/avltree"</span></span></code> </pre><br>  Métodos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API</a> más utilizados: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree *Tree)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, found </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree *Tree)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Put</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, value </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree *Tree)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree *Tree)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree *Tree)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Keys</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree *Tree)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Values</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree *Tree)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Left</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree *Tree)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Right</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span></span></code> </pre><br>  Hay dos métodos de árbol particularmente importantes: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree *Tree)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ceiling</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ceiling *Node, found </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre><br>  devuelve el elemento existente más pequeño más grande que la clave. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree *Tree)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Floor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(floor *Node, found </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre><br>  devuelve el elemento existente más grande menos que una clave. <br><br>  Las tareas para esto se encuentran relativamente a menudo en las entrevistas.  En la vida real se usa en índices de bases de datos: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> x &lt;= $<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Si hay un índice, funcionará para O (log n), para 1 búsqueda del borde en el árbol B. <br><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Filtro de floración</a> </h3><br>  Pero esta estructura de datos en stl no lo es. <br>  Al igual que una tabla hash, le permite verificar si un elemento pertenece a un conjunto.  Pero el filtro no almacena claves al agregar, y toma una cantidad constante de memoria.  Es posible recibir una respuesta falsa positiva (no hay ningún elemento en el conjunto, pero la estructura de datos informa que sí), pero no falso negativo.  Se utiliza como filtro para cortar rápidamente casi todas las claves no existentes, lo que ahorra una verificación más costosa, por ejemplo, leer desde un disco o realizar una solicitud a la base de datos. <br>  Hay una biblioteca de terceros: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/willf/bloom</a> <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/willf/bloom"</span></span></code> </pre><br>  No se usa con tanta frecuencia, puede echar un vistazo a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API</a> . <br><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HyperLogLog</a> </h3><br>  No existe tal cosa en la biblioteca estándar de C ++. <br><br>  Estructura de datos probabilística.  Con un pequeño error (≈ 0.4%), considera el número de elementos únicos sin almacenar las claves.  Proporciona grandes ahorros de memoria.  Si la tarea es calcular rápidamente la cantidad de visitantes o solicitudes, HyperLogLog es ideal. <br><br>  La biblioteca más popular para esto ahora. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/axiomhq/hyperloglog</a> <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/axiomhq/hyperloglog"</span></span></code> </pre><br><h3>  Clasificaciones </h3><br>  Análogos <code>std::sort</code> y <code>std::stable_sort</code> . <br>  Desde el punto de vista del consumidor, solo hay 2 tipos fundamentalmente diferentes: <br>  Estable (no cambie el orden de los elementos iguales [[4, 0], [1, 2], [1, 1], [5, 6]] -&gt; [[1, 2], [1, 1], [4 , 0], [5, 6]]) <br>  y no es estable, no garantiza la consistencia de los campos restantes. <br>  Ambos están en la biblioteca estándar: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data Interface)</span></span></span></span></code> </pre><br>  Esta es una implementación rápida de Hoar, inestable.  Pero para las secciones de longitud &lt;12, la ordenación del montón se utiliza como optimización. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data Interface)</span></span></span></span></code> </pre><br>  En el interior, este es un tipo de fusión, pero para mayor eficiencia, cuando el algoritmo recursivo alcanza bloques de menos de 20 elementos, se utiliza el orden de inserción. <br><br>  Estos son los algoritmos clásicos que funcionan para O (n log n). <br><br>  Si lo lees, felicidades.  Conocer API específicas ayuda a resolver problemas de prueba.  (Si trabajó con algo y conoce las mejores alternativas, escriba en los comentarios. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/456194/">https://habr.com/ru/post/456194/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456182/index.html">Audio a través de Bluetooth: información más detallada sobre perfiles, códecs y dispositivos</a></li>
<li><a href="../456184/index.html">Radio definida por software: ¿cómo funciona? Parte 8</a></li>
<li><a href="../456186/index.html">CS231n: redes neuronales convolucionales para el reconocimiento de patrones</a></li>
<li><a href="../456188/index.html">Token, token de actualización y creación de un contenedor asíncrono para una solicitud REST</a></li>
<li><a href="../456192/index.html">De monolitos a microservicios: la experiencia de M.Video-Eldorado y MegaFon</a></li>
<li><a href="../456196/index.html">Conceptos erróneos básicos sobre SCRUM</a></li>
<li><a href="../456200/index.html">Historia de Internet: ARPANET - El origen</a></li>
<li><a href="../456202/index.html">WSL 2 ahora está disponible en Windows Insiders</a></li>
<li><a href="../456204/index.html">WSL 2 ahora está disponible para Windows Insiders</a></li>
<li><a href="../456206/index.html">Cómo Moovit mejoró su aplicación para ayudar a las personas con discapacidad a viajar en tránsito con confianza</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>