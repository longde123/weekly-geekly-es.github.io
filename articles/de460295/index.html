<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👽 🚚 🗝️ Was bedeutet unsicher in Rust? ⛽️ 🥨 👉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich präsentiere Ihnen die Übersetzung des Artikels "Was ist Rust unsicher?" Autor Nora Codes. 


 Ich habe viele Missverständnisse darüber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Was bedeutet unsicher in Rust?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460295/"><p> Hallo Habr!  Ich präsentiere Ihnen die Übersetzung des Artikels "Was ist Rust unsicher?"  Autor Nora Codes. </p><br><p>  Ich habe viele Missverständnisse darüber gesehen, was das unsichere Schlüsselwort für die Nützlichkeit und Korrektheit der Rust-Sprache und ihre Förderung als "sichere Systemprogrammiersprache" bedeutet.  Die Wahrheit ist leider viel komplizierter als in einem kurzen Tweet beschrieben werden kann.  So sehe ich sie. </p><br><p>  Im Allgemeinen <strong>deaktiviert</strong> das <strong>unsichere Schlüsselwort nicht das Typsystem, das den Rust-Code korrekt hält</strong> .  Es ist nur möglich, einige „Superkräfte“ zu verwenden, z. B. Dereferenzierungszeiger.  Unsicher wird verwendet, um sichere Abstraktionen basierend auf einer grundlegend unsicheren Welt zu implementieren, sodass die meisten Rust-Codes diese Abstraktionen verwenden und unsicheren Speicherzugriff vermeiden können. <a name="habracut"></a></p><br><h1 id="garantiya-bezopasnosti">  Sicherheitsgarantie </h1><br><p>  Rost garantiert Sicherheit als eines seiner Grundprinzipien.  Wir können sagen, dass dies die <em>Bedeutung der Existenz von</em> Sprache ist.  Es bietet jedoch keine Sicherheit im herkömmlichen Sinne während der Programmausführung und der Verwendung des Garbage Collector.  Stattdessen verwendet Rust ein sehr fortschrittliches Typsystem, um zu verfolgen, wann und auf welche Werte zugegriffen werden kann.  Der Compiler analysiert dann statisch jedes Rust-Programm, um sicherzustellen, dass es immer im richtigen Zustand ist. </p><br><h2 id="bezopasnost-v-python">  Python-Sicherheit </h2><br><p>  Nehmen wir als Beispiel Python.  Reiner Python-Code kann den Speicher nicht beschädigen.  Beim Zugriff auf Listenelemente wird überprüft, ob Grenzen überschritten werden.  Von Funktionen zurückgegebene Links werden gezählt, um das Auftreten von baumelnden Links zu vermeiden.  Es gibt keine Möglichkeit, mit Zeigern willkürlich zu rechnen. </p><br><p>  Dies hat zwei Konsequenzen.  Erstens müssen viele Typen "speziell" sein.  Beispielsweise ist es nicht möglich, eine effektive Liste oder ein Wörterbuch in reinem Python zu implementieren.  Stattdessen hat der CPython-Interpreter seine interne Implementierung.  Zweitens erfordert der Zugriff auf externe Funktionen (Funktionen, die in Python nicht implementiert sind), die als Schnittstelle einer externen Funktion bezeichnet werden, die Verwendung eines speziellen ctypes-Moduls und verletzt die Sicherheitsgarantien der Sprache. </p><br><p>  In gewissem Sinne bedeutet dies, dass alles, was in Python geschrieben ist, keinen sicheren Zugriff auf den Speicher garantiert. </p><br><h2 id="bezopasnost-v-rust">  Sicherheit in Rust </h2><br><p>  Rust bietet auch Sicherheit, aber anstatt unsichere Strukturen in C zu implementieren, bietet es einen Trick: das unsichere Schlüsselwort.  Dies bedeutet, dass die grundlegenden Datenstrukturen in Rust wie Vec, VecDeque, BTreeMap und String in Rust implementiert sind. </p><br><p>  Sie können fragen: "Aber wenn Rust einen Trick gegen seine Codesicherheitsgarantien bereitstellt und die Standardbibliothek mit diesem Trick implementiert wird, wird dann nicht alles in Rust als unsicher angesehen?" </p><br><p>  Mit einem Wort, lieber Leser, <strong>ja</strong> , genau so, wie es in Python war.  Schauen wir uns das genauer an. </p><br><h1 id="chto-zaprescheno-v-bezopasnom-rust">  Was ist in sicherem Rost verboten? </h1><br><p>  Sicherheit in Rust ist klar definiert: Wir denken viel darüber nach.  Kurz gesagt, sichere Rust-Programme können nicht: </p><br><ul><li>  <strong>Dereferenzieren eines Zeigers, der auf einen anderen Typ verweist, als der Compiler kennt</strong> .  Dies bedeutet, dass es keine Zeiger auf Null gibt (weil sie nirgendwo zeigen), keine Fehler beim Überschreiten von Grenzen und / oder Segmentierungsfehler (Segmentierungsfehler), keine Pufferüberläufe.  Es bedeutet aber auch, dass es nach dem Freigeben des Speichers oder dem erneuten Freigeben des Speichers keine Verwendung gibt (da das Freigeben des Speichers als Dereferenzierung des Zeigers angesehen wird) und kein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wortspiel zum Tippen vorgesehen ist</a> . </li><li>  <strong>Haben Sie mehrere veränderbare Verweise auf ein Objekt oder gleichzeitig veränderbare und unveränderliche Verweise auf ein Objekt</strong> .  Das heißt, wenn Sie einen veränderlichen Verweis auf ein Objekt haben, können Sie ihn nur haben, und wenn Sie einen unveränderlichen Verweis auf das Objekt haben, ändert sich dieser erst, wenn Sie ihn behalten.  Dies bedeutet, dass Sie in Safe Rust kein Datenrennen erzwingen können. Dies ist eine Garantie, die die meisten anderen sicheren Sprachen nicht bieten können. </li></ul><br><p>  Rust codiert diese Informationen in einem Typsystem oder verwendet <strong>algebraische Datentypen</strong> , z. B. Option, um das Vorhandensein / Fehlen eines Werts anzuzeigen, und Ergebnis &lt;T, E&gt;, um Fehler / Erfolg anzuzeigen, oder <strong>Referenzen und deren Lebensdauer</strong> , z. B. &amp; T vs &amp; mut T, um anzuzeigen ein gemeinsamer (unveränderlicher) Link und ein exklusiver (veränderlicher) Link und &amp; 'a T vs &amp;' b T, um Links zu unterscheiden, die in verschiedenen Kontexten korrekt sind (dies wird normalerweise weggelassen, da der Compiler klug genug ist, es selbst herauszufinden). . <br></p><br><h2 id="primery">  Beispiele </h2><br><p>  Beispielsweise wird der folgende Code nicht kompiliert, da er einen baumelnden Link enthält.  <em>Insbesondere lebt my_struct nicht genug</em> .  Mit anderen Worten, die Funktion gibt einen Link zu etwas zurück, das nicht mehr existiert, und daher kann der Compiler dies nicht kompilieren (und weiß sogar nicht einmal, wie). </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dangling_reference</span></span></span></span>(v: &amp;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; &amp;MyStruct { <span class="hljs-comment"><span class="hljs-comment">//     MyStruct   ,  v,   . let my_struct = MyStruct { value: v }; //      my_struct. return &amp;my_struct; //  - my_struct  (  ). }</span></span></code> </pre> <br><p>  Dieser Code macht dasselbe, versucht jedoch, dieses Problem zu umgehen, indem er den Wert auf den Heap legt (Box ist der Name des Basis-Smart-Zeigers in Rust). </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dangling_heap_reference</span></span></span></span>(v: &amp;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;MyStruct&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_struct = MyStruct { value: v }; <span class="hljs-comment"><span class="hljs-comment">//    Box         . let my_box = Box::new(my_struct); //      my_box. return &amp;my_box; // my_box   .   "" my_struct       - , //    - MyStruct  . }</span></span></code> </pre> <br><p>  Der korrekte Code wird von Box selbst anstelle eines Verweises darauf zurückgegeben.  Dies kodiert die Übertragung des Eigentums - die Verantwortung für die Freigabe des Speichers - in der Signatur der Funktion.  Beim Betrachten der Signatur wird deutlich, dass der aufrufende Code für das, was mit Box passiert, verantwortlich ist, und der Compiler verarbeitet ihn tatsächlich automatisch. <br></p><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">no_dangling_reference</span></span></span></span>(v: &amp;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;MyStruct&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_struct = MyStruct { value: v }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_box = <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(my_struct); <span class="hljs-comment"><span class="hljs-comment">//    my_box  . return my_box; //    .         , //    ;       //  Box&lt;MyStruct&gt;       ,      . }</span></span></code> </pre> <br><blockquote>  Einige schlechte Dinge sind in sicherem Rost nicht verboten.  Zum Beispiel ist es aus Sicht des Compilers erlaubt: <br><ul><li>  Deadlock im Programm verursachen </li><li>  eine beliebig große Menge an Speicher verlieren </li><li>  Schließen Sie keine Dateigriffe, Datenbankverbindungen oder Raketenschachtabdeckungen </li></ul><br><br>  Die Stärke des Rust-Ökosystems besteht darin, dass viele Projekte ein Typsystem verwenden, um sicherzustellen, dass der Code so genau wie möglich ist. Der Compiler erfordert jedoch keinen solchen Zwang, außer in Fällen, in denen ein sicherer Speicherzugriff bereitgestellt wird. </blockquote><br><h1 id="chto-razresheno-v-nebezopasnom-rust">  Was ist in unsicherem Rost erlaubt? </h1><br><p>  Unsicherer Rustcode ist Rustcode mit dem Schlüsselwort unsicher.  Unsicher kann auf eine Funktion oder einen Codeblock angewendet werden.  Wenn es auf eine Funktion angewendet wird, bedeutet dies, dass "diese Funktion erfordert, dass der aufgerufene Code manuell die Invariante bereitstellt, die normalerweise vom Compiler bereitgestellt wird."  Wenn es auf einen Codeblock angewendet wird, bedeutet dies, dass "dieser Codeblock manuell die Invariante bereitstellt, die erforderlich ist, um einen unsicheren Zugriff auf den Speicher zu verhindern, und daher unsichere Dinge tun darf." </p><br><p>  <strong>Mit anderen Worten bedeutet unsicher für die Funktion "Sie müssen alles überprüfen" und im Codeblock "Ich habe bereits alles überprüft".</strong> </p><br><p>  Wie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The Rust Programming Language angegeben</a> , kann der Code in einem Block, der mit dem unsicheren Schlüsselwort gekennzeichnet ist, Folgendes tun: </p><br><ul><li>  <strong>Dereferenzieren Sie einen Zeiger.</strong>  Dies ist eine wichtige "Supermacht", mit der Sie doppelt verknüpfte Listen, Hashmaps und andere grundlegende Datenstrukturen implementieren können. </li><li>  <strong>Rufen Sie eine unsichere Funktion oder Methode auf.</strong>  Mehr dazu weiter unten. </li><li>  <strong>Zugriff auf oder Änderung einer veränderlichen statischen Variablen.</strong>  Statische Variablen, deren Umfang nicht gesteuert wird, können nicht statisch überprüft werden, daher ist ihre Verwendung unsicher. </li><li>  <strong>Implementieren Sie unsichere Eigenschaften.</strong>  Unsichere Merkmale werden verwendet, um zu kennzeichnen, ob bestimmte Typen bestimmte Invarianten garantieren.  Beispielsweise bestimmen Senden und Synchronisieren, ob ein Typ zwischen Thread-Grenzen gesendet oder von mehreren Threads gleichzeitig verwendet werden kann. </li></ul><br><p>  Erinnerst du dich an die hängenden Zeiger oben?  Fügen Sie das Wort unsicher hinzu, und der Compiler schwört doppelt so viel, weil er es nicht mag, unsicher dort zu verwenden, wo es nicht benötigt wird. </p><br><p>  Stattdessen wird das unsichere Schlüsselwort verwendet, um sichere Abstraktionen basierend auf beliebigen Zeigeroperationen zu implementieren.  Zum Beispiel wird der Vec-Typ mit unsicher implementiert, aber es ist sicher, ihn zu verwenden, da er Versuche überprüft, auf Elemente zuzugreifen, und keine Überläufe zulässt.  Obwohl Operationen wie set_len bereitgestellt werden, die einen unsicheren Speicherzugriff verursachen können, werden sie als unsicher markiert. </p><br><p>  Zum Beispiel könnten wir dasselbe tun wie im Beispiel no_dangling_reference, jedoch mit einer unangemessenen Verwendung von unsicher: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">manual_heap_reference</span></span></span></span>(v: <span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> MyStruct { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_struct = MyStruct { value: v }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_box = <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(my_struct); <span class="hljs-comment"><span class="hljs-comment">//  Box    . let struct_pointer = Box::into_raw(my_box); return struct_pointer; //   ;     . // MyStruct     . }</span></span></code> </pre> <br><p>  Beachten Sie das Fehlen des Wortes unsicher.  Das Erstellen von Zeigern ist absolut sicher.  Wie bereits geschrieben, besteht die Gefahr eines Speicherverlusts, jedoch nicht mehr, und Speicherverluste sind sicher.  Das Aufrufen dieser Funktion ist ebenfalls sicher.  Unsicher ist nur erforderlich, wenn etwas versucht, <strong>einen</strong> Zeiger zu <strong>dereferenzieren</strong> .  Als zusätzlichen Bonus gibt die Dereferenzierung automatisch den zugewiesenen Speicher frei. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_pointer = manual_heap_reference(<span class="hljs-number"><span class="hljs-number">1337</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_boxed_struct = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::from_raw(my_pointer) }; <span class="hljs-comment"><span class="hljs-comment">//  "Value: 1337" println!("Value: {}", my_boxed_struct.value); // my_boxed_struct    .       ,  //    - MyStruct }</span></span></code> </pre> <br><p>  Nach der Optimierung entspricht dieser Code der einfachen Rückgabe einer Box.  Box ist eine sichere zeigerbasierte Abstraktion, da sie die Verteilung von Zeigern überall verhindert.  Zum Beispiel führt die nächste Version von main zu einem doppelten freien Speicher (doppelt frei). </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_pointer = manual_heap_reference(<span class="hljs-number"><span class="hljs-number">1337</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_boxed_struct_1 = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::from_raw(my_pointer) }; <span class="hljs-comment"><span class="hljs-comment">// DOUBLE FREE BUG! let my_boxed_struct_2 = unsafe { Box::from_raw(my_pointer) }; //  "Value: 1337" . println!("Value: {}", my_boxed_struct_1.value); println!("Value: {}", my_boxed_struct_2.value); // my_boxed_struct_2    .     ,  //    - MyStruct. //  my_boxed_struct_1    .      , //      - MyStruct.  double-free bug. }</span></span></code> </pre> <br><h2 id="tak-chto-takoe-bezopasnaya-abstrakciya">  Was ist also sichere Abstraktion? </h2><br><p>  Sichere Abstraktion ist eine Abstraktion, die ein Typsystem verwendet, um eine API bereitzustellen, mit der die oben genannten Sicherheitsgarantien nicht verletzt werden können.  Box ist sicherer * mut T, da es nicht zu einer doppelten Speicherfreigabe kommen kann, wie oben dargestellt. </p><br><p>  Ein weiteres Beispiel ist der Rc-Typ in Rust.  Dies ist ein Referenzzählzeiger - eine nicht änderbare Referenz auf Daten auf dem Heap.  Da mehrere gleichzeitige Zugriffe auf einen Speicherbereich möglich sind, <em>müssen</em> Änderungen verhindert werden, um als sicher zu gelten. </p><br><p>  Darüber hinaus ist es nicht threadsicher.  Wenn Sie Thread-Sicherheit benötigen, müssen Sie den Arc-Typ (Atomic Reference Counting) verwenden, der aufgrund der Verwendung von Atomwerten zum Zählen von Links und zur Verhinderung möglicher Datenrennen in Umgebungen mit mehreren Threads einen Leistungsverlust verursacht. </p><br><p>  Der Compiler erlaubt Ihnen nicht, Rc dort zu verwenden, wo Sie Arc verwenden sollten, da Ersteller wie Rc es nicht als threadsicher markiert haben.  Wenn sie dies tun würden, wäre dies unvernünftig: ein falsches Sicherheitsversprechen. </p><br><h2 id="kogda-neobhodim-nebezopasnyy-rust">  Wann wird unsicherer Rost benötigt? </h2><br><p>  Unsicheres Rost ist immer dann erforderlich, wenn eine Operation ausgeführt werden muss, die gegen eine der beiden oben beschriebenen Regeln verstößt.  In einer doppelt verknüpften Liste wird beispielsweise durch das Fehlen veränderlicher Verknüpfungen zu denselben Daten (für das nächste Element und das vorherige Element) der Nutzen vollständig beeinträchtigt.  Mit unsicher kann ein doppelt verknüpfter Listenimplementierer Code mit * mut Node-Zeigern schreiben und ihn dann in eine sichere Abstraktion kapseln. <br></p><p>  Ein weiteres Beispiel ist die Arbeit mit eingebetteten Systemen.  Oft verwenden Mikrocontroller einen Satz von Registern, deren Werte durch den physischen Zustand des Geräts bestimmt werden.  Die Welt kann nicht aufhören, während Sie &amp; mut u8 aus einem solchen Register entnehmen. Daher ist es unsicher, mit Geräteunterstützungskisten zu arbeiten.  In der Regel kapseln solche Kisten den Status in transparenten, sicheren Wrappern, die Daten nach Möglichkeit kopieren, oder verwenden andere Techniken, die Compiler-Garantien bieten. </p><br><p>  Manchmal ist es notwendig, einen Vorgang auszuführen, der zum gleichzeitigen Lesen und Schreiben oder zu einem unsicheren Zugriff auf den Speicher führen kann. Hier ist unsicher.  Solange jedoch die Möglichkeit besteht, sicherzustellen, dass sichere Invarianten beibehalten werden, bevor ein Benutzer etwas berührt (dh nicht als unsicher markiert), ist alles in Ordnung. </p><br><h1 id="na-chih-plechah-lezhit-eta-otvetstvennost">  Auf wessen Schultern liegt diese Verantwortung? </h1><br><p>  Wir kommen zu einer früher gemachten Aussage - <strong>ja</strong> , die Nützlichkeit von Rust-Code basiert auf unsicherem Code.  Trotz der Tatsache, dass dies etwas anders erfolgt als die unsichere Implementierung grundlegender Datenstrukturen in Python, sollte die Implementierung von Vec, Hashmap usw. in gewissem Umfang Zeigermanipulationen verwenden. </p><br><p>  Wir sagen, dass Rust sicher ist, mit der Grundannahme, dass der unsichere Code, den wir aufgrund unserer Abhängigkeiten von der Standardbibliothek oder dem Code anderer Bibliotheken verwenden, korrekt geschrieben und gekapselt ist.  Der grundlegende Vorteil von Rust besteht darin, dass unsicherer Code in unsichere Blöcke geschrieben wird, die von ihren Autoren sorgfältig geprüft werden müssen. </p><br><p>  In Python liegt die Last der Überprüfung der Sicherheit von Speichermanipulationen nur bei den Entwicklern der Interpreter und Benutzern der Schnittstellen externer Funktionen.  In C liegt diese Belastung bei jedem Programmierer. </p><br><p>  In Rust liegt es bei Benutzern des unsicheren Schlüsselworts.  Dies ist offensichtlich, da Invarianten in einem solchen Code manuell verwaltet werden müssen und daher die kleinste Menge dieses Codes in der Bibliothek oder im Anwendungscode angestrebt werden muss.  Unsicherheit wird erkannt, hervorgehoben und angezeigt.  Wenn daher in Ihrem Rust-Code Segfaults auftreten, finden Sie entweder einen Fehler im Compiler oder einen Fehler in mehreren Zeilen Ihres unsicheren Codes. </p><br><p>  Dies ist kein perfektes System, aber wenn Sie gleichzeitig Geschwindigkeit, Sicherheit und Multithreading benötigen, ist dies die einzige Option. </p><p></p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460295/">https://habr.com/ru/post/de460295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460281/index.html">Wie UX Writer zur Produktverbesserung beiträgt</a></li>
<li><a href="../de460283/index.html">Neue Do-it-yourself-Programmiersprache</a></li>
<li><a href="../de460285/index.html">Wir bereiten PHP vor. Wie sind while, foreach, array_walk und einige andere beängstigende Wörter</a></li>
<li><a href="../de460287/index.html">Runet News Visualisierung</a></li>
<li><a href="../de460291/index.html">Probleme der Stapelverarbeitung von Anfragen und deren Lösungen (Teil 1)</a></li>
<li><a href="../de460297/index.html">WeakRef - Vorschlag zur Ergänzung des ECMAScript-Standards</a></li>
<li><a href="../de460301/index.html">Hochleistungs-LED-Lampen der neuen Generation</a></li>
<li><a href="../de460305/index.html">AERODISK Motor: Katastrophal. Teil 2. Metrocluster</a></li>
<li><a href="../de460307/index.html">Modellierungserfahrung vom Computer Vision Mail.ru-Team</a></li>
<li><a href="../de460311/index.html">Zeit für eine neue Geldtheorie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>