<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëΩ üöö üóùÔ∏è Was bedeutet unsicher in Rust? ‚õΩÔ∏è ü•® üëâ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich pr√§sentiere Ihnen die √úbersetzung des Artikels "Was ist Rust unsicher?" Autor Nora Codes. 


 Ich habe viele Missverst√§ndnisse dar√ºber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Was bedeutet unsicher in Rust?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460295/"><p> Hallo Habr!  Ich pr√§sentiere Ihnen die √úbersetzung des Artikels "Was ist Rust unsicher?"  Autor Nora Codes. </p><br><p>  Ich habe viele Missverst√§ndnisse dar√ºber gesehen, was das unsichere Schl√ºsselwort f√ºr die N√ºtzlichkeit und Korrektheit der Rust-Sprache und ihre F√∂rderung als "sichere Systemprogrammiersprache" bedeutet.  Die Wahrheit ist leider viel komplizierter als in einem kurzen Tweet beschrieben werden kann.  So sehe ich sie. </p><br><p>  Im Allgemeinen <strong>deaktiviert</strong> das <strong>unsichere Schl√ºsselwort nicht das Typsystem, das den Rust-Code korrekt h√§lt</strong> .  Es ist nur m√∂glich, einige ‚ÄûSuperkr√§fte‚Äú zu verwenden, z. B. Dereferenzierungszeiger.  Unsicher wird verwendet, um sichere Abstraktionen basierend auf einer grundlegend unsicheren Welt zu implementieren, sodass die meisten Rust-Codes diese Abstraktionen verwenden und unsicheren Speicherzugriff vermeiden k√∂nnen. <a name="habracut"></a></p><br><h1 id="garantiya-bezopasnosti">  Sicherheitsgarantie </h1><br><p>  Rost garantiert Sicherheit als eines seiner Grundprinzipien.  Wir k√∂nnen sagen, dass dies die <em>Bedeutung der Existenz von</em> Sprache ist.  Es bietet jedoch keine Sicherheit im herk√∂mmlichen Sinne w√§hrend der Programmausf√ºhrung und der Verwendung des Garbage Collector.  Stattdessen verwendet Rust ein sehr fortschrittliches Typsystem, um zu verfolgen, wann und auf welche Werte zugegriffen werden kann.  Der Compiler analysiert dann statisch jedes Rust-Programm, um sicherzustellen, dass es immer im richtigen Zustand ist. </p><br><h2 id="bezopasnost-v-python">  Python-Sicherheit </h2><br><p>  Nehmen wir als Beispiel Python.  Reiner Python-Code kann den Speicher nicht besch√§digen.  Beim Zugriff auf Listenelemente wird √ºberpr√ºft, ob Grenzen √ºberschritten werden.  Von Funktionen zur√ºckgegebene Links werden gez√§hlt, um das Auftreten von baumelnden Links zu vermeiden.  Es gibt keine M√∂glichkeit, mit Zeigern willk√ºrlich zu rechnen. </p><br><p>  Dies hat zwei Konsequenzen.  Erstens m√ºssen viele Typen "speziell" sein.  Beispielsweise ist es nicht m√∂glich, eine effektive Liste oder ein W√∂rterbuch in reinem Python zu implementieren.  Stattdessen hat der CPython-Interpreter seine interne Implementierung.  Zweitens erfordert der Zugriff auf externe Funktionen (Funktionen, die in Python nicht implementiert sind), die als Schnittstelle einer externen Funktion bezeichnet werden, die Verwendung eines speziellen ctypes-Moduls und verletzt die Sicherheitsgarantien der Sprache. </p><br><p>  In gewissem Sinne bedeutet dies, dass alles, was in Python geschrieben ist, keinen sicheren Zugriff auf den Speicher garantiert. </p><br><h2 id="bezopasnost-v-rust">  Sicherheit in Rust </h2><br><p>  Rust bietet auch Sicherheit, aber anstatt unsichere Strukturen in C zu implementieren, bietet es einen Trick: das unsichere Schl√ºsselwort.  Dies bedeutet, dass die grundlegenden Datenstrukturen in Rust wie Vec, VecDeque, BTreeMap und String in Rust implementiert sind. </p><br><p>  Sie k√∂nnen fragen: "Aber wenn Rust einen Trick gegen seine Codesicherheitsgarantien bereitstellt und die Standardbibliothek mit diesem Trick implementiert wird, wird dann nicht alles in Rust als unsicher angesehen?" </p><br><p>  Mit einem Wort, lieber Leser, <strong>ja</strong> , genau so, wie es in Python war.  Schauen wir uns das genauer an. </p><br><h1 id="chto-zaprescheno-v-bezopasnom-rust">  Was ist in sicherem Rost verboten? </h1><br><p>  Sicherheit in Rust ist klar definiert: Wir denken viel dar√ºber nach.  Kurz gesagt, sichere Rust-Programme k√∂nnen nicht: </p><br><ul><li>  <strong>Dereferenzieren eines Zeigers, der auf einen anderen Typ verweist, als der Compiler kennt</strong> .  Dies bedeutet, dass es keine Zeiger auf Null gibt (weil sie nirgendwo zeigen), keine Fehler beim √úberschreiten von Grenzen und / oder Segmentierungsfehler (Segmentierungsfehler), keine Puffer√ºberl√§ufe.  Es bedeutet aber auch, dass es nach dem Freigeben des Speichers oder dem erneuten Freigeben des Speichers keine Verwendung gibt (da das Freigeben des Speichers als Dereferenzierung des Zeigers angesehen wird) und kein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wortspiel zum Tippen vorgesehen ist</a> . </li><li>  <strong>Haben Sie mehrere ver√§nderbare Verweise auf ein Objekt oder gleichzeitig ver√§nderbare und unver√§nderliche Verweise auf ein Objekt</strong> .  Das hei√üt, wenn Sie einen ver√§nderlichen Verweis auf ein Objekt haben, k√∂nnen Sie ihn nur haben, und wenn Sie einen unver√§nderlichen Verweis auf das Objekt haben, √§ndert sich dieser erst, wenn Sie ihn behalten.  Dies bedeutet, dass Sie in Safe Rust kein Datenrennen erzwingen k√∂nnen. Dies ist eine Garantie, die die meisten anderen sicheren Sprachen nicht bieten k√∂nnen. </li></ul><br><p>  Rust codiert diese Informationen in einem Typsystem oder verwendet <strong>algebraische Datentypen</strong> , z. B. Option, um das Vorhandensein / Fehlen eines Werts anzuzeigen, und Ergebnis &lt;T, E&gt;, um Fehler / Erfolg anzuzeigen, oder <strong>Referenzen und deren Lebensdauer</strong> , z. B. &amp; T vs &amp; mut T, um anzuzeigen ein gemeinsamer (unver√§nderlicher) Link und ein exklusiver (ver√§nderlicher) Link und &amp; 'a T vs &amp;' b T, um Links zu unterscheiden, die in verschiedenen Kontexten korrekt sind (dies wird normalerweise weggelassen, da der Compiler klug genug ist, es selbst herauszufinden). . <br></p><br><h2 id="primery">  Beispiele </h2><br><p>  Beispielsweise wird der folgende Code nicht kompiliert, da er einen baumelnden Link enth√§lt.  <em>Insbesondere lebt my_struct nicht genug</em> .  Mit anderen Worten, die Funktion gibt einen Link zu etwas zur√ºck, das nicht mehr existiert, und daher kann der Compiler dies nicht kompilieren (und wei√ü sogar nicht einmal, wie). </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dangling_reference</span></span></span></span>(v: &amp;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; &amp;MyStruct { <span class="hljs-comment"><span class="hljs-comment">//     MyStruct   ,  v,   . let my_struct = MyStruct { value: v }; //      my_struct. return &amp;my_struct; //  - my_struct  (  ). }</span></span></code> </pre> <br><p>  Dieser Code macht dasselbe, versucht jedoch, dieses Problem zu umgehen, indem er den Wert auf den Heap legt (Box ist der Name des Basis-Smart-Zeigers in Rust). </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dangling_heap_reference</span></span></span></span>(v: &amp;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;MyStruct&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_struct = MyStruct { value: v }; <span class="hljs-comment"><span class="hljs-comment">//    Box         . let my_box = Box::new(my_struct); //      my_box. return &amp;my_box; // my_box   .   "" my_struct       - , //    - MyStruct  . }</span></span></code> </pre> <br><p>  Der korrekte Code wird von Box selbst anstelle eines Verweises darauf zur√ºckgegeben.  Dies kodiert die √úbertragung des Eigentums - die Verantwortung f√ºr die Freigabe des Speichers - in der Signatur der Funktion.  Beim Betrachten der Signatur wird deutlich, dass der aufrufende Code f√ºr das, was mit Box passiert, verantwortlich ist, und der Compiler verarbeitet ihn tats√§chlich automatisch. <br></p><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">no_dangling_reference</span></span></span></span>(v: &amp;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;MyStruct&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_struct = MyStruct { value: v }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_box = <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(my_struct); <span class="hljs-comment"><span class="hljs-comment">//    my_box  . return my_box; //    .         , //    ;       //  Box&lt;MyStruct&gt;       ,      . }</span></span></code> </pre> <br><blockquote>  Einige schlechte Dinge sind in sicherem Rost nicht verboten.  Zum Beispiel ist es aus Sicht des Compilers erlaubt: <br><ul><li>  Deadlock im Programm verursachen </li><li>  eine beliebig gro√üe Menge an Speicher verlieren </li><li>  Schlie√üen Sie keine Dateigriffe, Datenbankverbindungen oder Raketenschachtabdeckungen </li></ul><br><br>  Die St√§rke des Rust-√ñkosystems besteht darin, dass viele Projekte ein Typsystem verwenden, um sicherzustellen, dass der Code so genau wie m√∂glich ist. Der Compiler erfordert jedoch keinen solchen Zwang, au√üer in F√§llen, in denen ein sicherer Speicherzugriff bereitgestellt wird. </blockquote><br><h1 id="chto-razresheno-v-nebezopasnom-rust">  Was ist in unsicherem Rost erlaubt? </h1><br><p>  Unsicherer Rustcode ist Rustcode mit dem Schl√ºsselwort unsicher.  Unsicher kann auf eine Funktion oder einen Codeblock angewendet werden.  Wenn es auf eine Funktion angewendet wird, bedeutet dies, dass "diese Funktion erfordert, dass der aufgerufene Code manuell die Invariante bereitstellt, die normalerweise vom Compiler bereitgestellt wird."  Wenn es auf einen Codeblock angewendet wird, bedeutet dies, dass "dieser Codeblock manuell die Invariante bereitstellt, die erforderlich ist, um einen unsicheren Zugriff auf den Speicher zu verhindern, und daher unsichere Dinge tun darf." </p><br><p>  <strong>Mit anderen Worten bedeutet unsicher f√ºr die Funktion "Sie m√ºssen alles √ºberpr√ºfen" und im Codeblock "Ich habe bereits alles √ºberpr√ºft".</strong> </p><br><p>  Wie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The Rust Programming Language angegeben</a> , kann der Code in einem Block, der mit dem unsicheren Schl√ºsselwort gekennzeichnet ist, Folgendes tun: </p><br><ul><li>  <strong>Dereferenzieren Sie einen Zeiger.</strong>  Dies ist eine wichtige "Supermacht", mit der Sie doppelt verkn√ºpfte Listen, Hashmaps und andere grundlegende Datenstrukturen implementieren k√∂nnen. </li><li>  <strong>Rufen Sie eine unsichere Funktion oder Methode auf.</strong>  Mehr dazu weiter unten. </li><li>  <strong>Zugriff auf oder √Ñnderung einer ver√§nderlichen statischen Variablen.</strong>  Statische Variablen, deren Umfang nicht gesteuert wird, k√∂nnen nicht statisch √ºberpr√ºft werden, daher ist ihre Verwendung unsicher. </li><li>  <strong>Implementieren Sie unsichere Eigenschaften.</strong>  Unsichere Merkmale werden verwendet, um zu kennzeichnen, ob bestimmte Typen bestimmte Invarianten garantieren.  Beispielsweise bestimmen Senden und Synchronisieren, ob ein Typ zwischen Thread-Grenzen gesendet oder von mehreren Threads gleichzeitig verwendet werden kann. </li></ul><br><p>  Erinnerst du dich an die h√§ngenden Zeiger oben?  F√ºgen Sie das Wort unsicher hinzu, und der Compiler schw√∂rt doppelt so viel, weil er es nicht mag, unsicher dort zu verwenden, wo es nicht ben√∂tigt wird. </p><br><p>  Stattdessen wird das unsichere Schl√ºsselwort verwendet, um sichere Abstraktionen basierend auf beliebigen Zeigeroperationen zu implementieren.  Zum Beispiel wird der Vec-Typ mit unsicher implementiert, aber es ist sicher, ihn zu verwenden, da er Versuche √ºberpr√ºft, auf Elemente zuzugreifen, und keine √úberl√§ufe zul√§sst.  Obwohl Operationen wie set_len bereitgestellt werden, die einen unsicheren Speicherzugriff verursachen k√∂nnen, werden sie als unsicher markiert. </p><br><p>  Zum Beispiel k√∂nnten wir dasselbe tun wie im Beispiel no_dangling_reference, jedoch mit einer unangemessenen Verwendung von unsicher: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">manual_heap_reference</span></span></span></span>(v: <span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> MyStruct { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_struct = MyStruct { value: v }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_box = <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(my_struct); <span class="hljs-comment"><span class="hljs-comment">//  Box    . let struct_pointer = Box::into_raw(my_box); return struct_pointer; //   ;     . // MyStruct     . }</span></span></code> </pre> <br><p>  Beachten Sie das Fehlen des Wortes unsicher.  Das Erstellen von Zeigern ist absolut sicher.  Wie bereits geschrieben, besteht die Gefahr eines Speicherverlusts, jedoch nicht mehr, und Speicherverluste sind sicher.  Das Aufrufen dieser Funktion ist ebenfalls sicher.  Unsicher ist nur erforderlich, wenn etwas versucht, <strong>einen</strong> Zeiger zu <strong>dereferenzieren</strong> .  Als zus√§tzlichen Bonus gibt die Dereferenzierung automatisch den zugewiesenen Speicher frei. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_pointer = manual_heap_reference(<span class="hljs-number"><span class="hljs-number">1337</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_boxed_struct = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::from_raw(my_pointer) }; <span class="hljs-comment"><span class="hljs-comment">//  "Value: 1337" println!("Value: {}", my_boxed_struct.value); // my_boxed_struct    .       ,  //    - MyStruct }</span></span></code> </pre> <br><p>  Nach der Optimierung entspricht dieser Code der einfachen R√ºckgabe einer Box.  Box ist eine sichere zeigerbasierte Abstraktion, da sie die Verteilung von Zeigern √ºberall verhindert.  Zum Beispiel f√ºhrt die n√§chste Version von main zu einem doppelten freien Speicher (doppelt frei). </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_pointer = manual_heap_reference(<span class="hljs-number"><span class="hljs-number">1337</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> my_boxed_struct_1 = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::from_raw(my_pointer) }; <span class="hljs-comment"><span class="hljs-comment">// DOUBLE FREE BUG! let my_boxed_struct_2 = unsafe { Box::from_raw(my_pointer) }; //  "Value: 1337" . println!("Value: {}", my_boxed_struct_1.value); println!("Value: {}", my_boxed_struct_2.value); // my_boxed_struct_2    .     ,  //    - MyStruct. //  my_boxed_struct_1    .      , //      - MyStruct.  double-free bug. }</span></span></code> </pre> <br><h2 id="tak-chto-takoe-bezopasnaya-abstrakciya">  Was ist also sichere Abstraktion? </h2><br><p>  Sichere Abstraktion ist eine Abstraktion, die ein Typsystem verwendet, um eine API bereitzustellen, mit der die oben genannten Sicherheitsgarantien nicht verletzt werden k√∂nnen.  Box ist sicherer * mut T, da es nicht zu einer doppelten Speicherfreigabe kommen kann, wie oben dargestellt. </p><br><p>  Ein weiteres Beispiel ist der Rc-Typ in Rust.  Dies ist ein Referenzz√§hlzeiger - eine nicht √§nderbare Referenz auf Daten auf dem Heap.  Da mehrere gleichzeitige Zugriffe auf einen Speicherbereich m√∂glich sind, <em>m√ºssen</em> √Ñnderungen verhindert werden, um als sicher zu gelten. </p><br><p>  Dar√ºber hinaus ist es nicht threadsicher.  Wenn Sie Thread-Sicherheit ben√∂tigen, m√ºssen Sie den Arc-Typ (Atomic Reference Counting) verwenden, der aufgrund der Verwendung von Atomwerten zum Z√§hlen von Links und zur Verhinderung m√∂glicher Datenrennen in Umgebungen mit mehreren Threads einen Leistungsverlust verursacht. </p><br><p>  Der Compiler erlaubt Ihnen nicht, Rc dort zu verwenden, wo Sie Arc verwenden sollten, da Ersteller wie Rc es nicht als threadsicher markiert haben.  Wenn sie dies tun w√ºrden, w√§re dies unvern√ºnftig: ein falsches Sicherheitsversprechen. </p><br><h2 id="kogda-neobhodim-nebezopasnyy-rust">  Wann wird unsicherer Rost ben√∂tigt? </h2><br><p>  Unsicheres Rost ist immer dann erforderlich, wenn eine Operation ausgef√ºhrt werden muss, die gegen eine der beiden oben beschriebenen Regeln verst√∂√üt.  In einer doppelt verkn√ºpften Liste wird beispielsweise durch das Fehlen ver√§nderlicher Verkn√ºpfungen zu denselben Daten (f√ºr das n√§chste Element und das vorherige Element) der Nutzen vollst√§ndig beeintr√§chtigt.  Mit unsicher kann ein doppelt verkn√ºpfter Listenimplementierer Code mit * mut Node-Zeigern schreiben und ihn dann in eine sichere Abstraktion kapseln. <br></p><p>  Ein weiteres Beispiel ist die Arbeit mit eingebetteten Systemen.  Oft verwenden Mikrocontroller einen Satz von Registern, deren Werte durch den physischen Zustand des Ger√§ts bestimmt werden.  Die Welt kann nicht aufh√∂ren, w√§hrend Sie &amp; mut u8 aus einem solchen Register entnehmen. Daher ist es unsicher, mit Ger√§teunterst√ºtzungskisten zu arbeiten.  In der Regel kapseln solche Kisten den Status in transparenten, sicheren Wrappern, die Daten nach M√∂glichkeit kopieren, oder verwenden andere Techniken, die Compiler-Garantien bieten. </p><br><p>  Manchmal ist es notwendig, einen Vorgang auszuf√ºhren, der zum gleichzeitigen Lesen und Schreiben oder zu einem unsicheren Zugriff auf den Speicher f√ºhren kann. Hier ist unsicher.  Solange jedoch die M√∂glichkeit besteht, sicherzustellen, dass sichere Invarianten beibehalten werden, bevor ein Benutzer etwas ber√ºhrt (dh nicht als unsicher markiert), ist alles in Ordnung. </p><br><h1 id="na-chih-plechah-lezhit-eta-otvetstvennost">  Auf wessen Schultern liegt diese Verantwortung? </h1><br><p>  Wir kommen zu einer fr√ºher gemachten Aussage - <strong>ja</strong> , die N√ºtzlichkeit von Rust-Code basiert auf unsicherem Code.  Trotz der Tatsache, dass dies etwas anders erfolgt als die unsichere Implementierung grundlegender Datenstrukturen in Python, sollte die Implementierung von Vec, Hashmap usw. in gewissem Umfang Zeigermanipulationen verwenden. </p><br><p>  Wir sagen, dass Rust sicher ist, mit der Grundannahme, dass der unsichere Code, den wir aufgrund unserer Abh√§ngigkeiten von der Standardbibliothek oder dem Code anderer Bibliotheken verwenden, korrekt geschrieben und gekapselt ist.  Der grundlegende Vorteil von Rust besteht darin, dass unsicherer Code in unsichere Bl√∂cke geschrieben wird, die von ihren Autoren sorgf√§ltig gepr√ºft werden m√ºssen. </p><br><p>  In Python liegt die Last der √úberpr√ºfung der Sicherheit von Speichermanipulationen nur bei den Entwicklern der Interpreter und Benutzern der Schnittstellen externer Funktionen.  In C liegt diese Belastung bei jedem Programmierer. </p><br><p>  In Rust liegt es bei Benutzern des unsicheren Schl√ºsselworts.  Dies ist offensichtlich, da Invarianten in einem solchen Code manuell verwaltet werden m√ºssen und daher die kleinste Menge dieses Codes in der Bibliothek oder im Anwendungscode angestrebt werden muss.  Unsicherheit wird erkannt, hervorgehoben und angezeigt.  Wenn daher in Ihrem Rust-Code Segfaults auftreten, finden Sie entweder einen Fehler im Compiler oder einen Fehler in mehreren Zeilen Ihres unsicheren Codes. </p><br><p>  Dies ist kein perfektes System, aber wenn Sie gleichzeitig Geschwindigkeit, Sicherheit und Multithreading ben√∂tigen, ist dies die einzige Option. </p><p></p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460295/">https://habr.com/ru/post/de460295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460281/index.html">Wie UX Writer zur Produktverbesserung beitr√§gt</a></li>
<li><a href="../de460283/index.html">Neue Do-it-yourself-Programmiersprache</a></li>
<li><a href="../de460285/index.html">Wir bereiten PHP vor. Wie sind while, foreach, array_walk und einige andere be√§ngstigende W√∂rter</a></li>
<li><a href="../de460287/index.html">Runet News Visualisierung</a></li>
<li><a href="../de460291/index.html">Probleme der Stapelverarbeitung von Anfragen und deren L√∂sungen (Teil 1)</a></li>
<li><a href="../de460297/index.html">WeakRef - Vorschlag zur Erg√§nzung des ECMAScript-Standards</a></li>
<li><a href="../de460301/index.html">Hochleistungs-LED-Lampen der neuen Generation</a></li>
<li><a href="../de460305/index.html">AERODISK Motor: Katastrophal. Teil 2. Metrocluster</a></li>
<li><a href="../de460307/index.html">Modellierungserfahrung vom Computer Vision Mail.ru-Team</a></li>
<li><a href="../de460311/index.html">Zeit f√ºr eine neue Geldtheorie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>