<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥔 🤸🏾 🎅🏻 Gestión de memoria Python 😏 💄 🥨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¿Alguna vez te has preguntado cómo se ven los datos con los que trabajas en las entrañas de Python? ¿Sobre cómo se crean y almacenan las variables en ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gestión de memoria Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/441568/">  ¿Alguna vez te has preguntado cómo se ven los datos con los que trabajas en las entrañas de Python?  ¿Sobre cómo se crean y almacenan las variables en la memoria?  ¿Cómo y cuándo se eliminan?  El material, cuya traducción publicamos, está dedicado a la investigación de las profundidades de Python, durante el cual trataremos de descubrir las características de la administración de memoria en este lenguaje.  Después de estudiar este artículo, comprenderá cómo funcionan los mecanismos de bajo nivel de las computadoras, especialmente los relacionados con la memoria.  Comprenderá cómo Python abstrae las operaciones de bajo nivel y cómo administra la memoria. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/ok/qc/59/okqc59rnficniaz3pfcaaae5onc.jpeg"></a> <br><br>  Saber lo que está sucediendo en Python le permitirá comprender mejor algunos de los comportamientos de este lenguaje.  Esto, espero, le dará la oportunidad de apreciar el enorme trabajo que se está realizando dentro de la implementación de este lenguaje que utiliza para que sus programas funcionen exactamente como lo necesita. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">La memoria es un libro vacio</font> </h2><br>  La memoria de la computadora, al comienzo de trabajar con ella, se puede representar en forma de un libro vacío destinado a cuentos.  Si bien no hay nada en sus páginas, pronto aparecerán los autores de las historias, cada uno de los cuales quiere escribir su propia historia en este libro. <br><br>  Como una historia no se puede escribir sobre otra, los autores deben tener cuidado con las páginas del libro en las que escriben.  Antes de escribir nada, consultan con el editor en jefe.  Él decide dónde exactamente los autores pueden grabar historias. <br><br>  Dado que el libro del que hablamos ha existido durante bastante tiempo, muchas de las historias ya están desactualizadas.  Si nadie lee una historia o la menciona en sus obras, esta historia se elimina del libro, dejando espacio para nuevas historias. <br><br>  En general, podemos decir que la memoria de la computadora es muy similar a un libro de este tipo.  De hecho, los bloques continuos de memoria de una longitud fija incluso se llaman páginas, por lo que creemos que comparar la memoria con un libro es muy exitoso. <br><br>  Los autores que escriben sus historias en un libro son diferentes aplicaciones o procesos que necesitan almacenar datos en la memoria.  El editor jefe, que decide qué páginas del libro pueden escribir los autores, es el mecanismo que se ocupa de la gestión de la memoria.  Y el que elimina viejas historias del libro, dejando espacio para nuevas, se puede comparar con el mecanismo de recolección de basura. <br><br><h2>  <font color="#3AC1EF">Gestión de la memoria: el camino del hierro a los programas</font> </h2><br>  La gestión de la memoria es un proceso, durante la implementación de los cuales los programas escriben datos en la memoria y los leen.  Un administrador de memoria es una entidad que determina dónde exactamente una aplicación puede colocar sus datos en la memoria.  Dado que el número de fragmentos de memoria que se pueden asignar a las aplicaciones no es infinito, así como el número de páginas en cualquier libro no es infinito, el administrador de memoria, que sirve a las aplicaciones, necesita encontrar fragmentos de memoria libres y proporcionarlos a las aplicaciones.  Este proceso, en el que la memoria se asigna a las aplicaciones, se denomina asignación de memoria. <br><br>  Por otro lado, cuando algunos datos ya no son necesarios, se pueden eliminar o, en otras palabras, liberar la memoria que ocupa.  Pero, ¿qué es exactamente "aislar" y "liberar" cuando se habla de memoria? <br><br>  En algún lugar de su computadora hay un dispositivo físico que almacena los datos utilizados por los programas Python mientras funcionan.  Antes de que un objeto Python aparezca en la memoria física, el código debe pasar por muchas capas de abstracción. <br><br>  Una de las principales capas de este tipo, que se encuentra en la parte superior del hardware (como RAM o disco duro) es el sistema operativo (SO).  Ejecuta (o se niega a cumplir) solicitudes para leer datos de la memoria y escribir datos en la memoria. <br><br>  Encima del sistema operativo hay una aplicación, en nuestro caso, una de las implementaciones de Python (puede ser un paquete de software que es parte de su sistema operativo o descargado de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">python.org</a> ).  Es este paquete de software el que se dedica a la gestión de la memoria, lo que garantiza el funcionamiento de su código Python.  El enfoque de este artículo está en los algoritmos y las estructuras de datos que Python usa para administrar la memoria. <br><br><h2>  <font color="#3AC1EF">Implementación de referencia de Python</font> </h2><br>  La implementación de Python de referencia se llama CPython.  Está escrito en C. Cuando lo escuché por primera vez, literalmente me inquietó.  ¿Un lenguaje de programación que está escrito en otro idioma?  Bueno, en realidad, esto no es del todo cierto. <br><br>  La especificación de Python se describe en inglés simple en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este documento</a> .  Sin embargo, esta especificación sola, el código escrito en Python, por supuesto, no puede ejecutarse.  Para hacer esto, necesita algo que, siguiendo las reglas de esta especificación, pueda interpretar el código escrito en Python. <br><br>  Además, necesita algo que pueda ejecutar el código interpretado en la computadora.  La implementación de Python de referencia resuelve ambas tareas.  Convierte el código en instrucciones que luego se ejecutan en la máquina virtual. <br><br>  Las máquinas virtuales son similares a las computadoras comunes hechas de silicio, metal y otros materiales, pero están implementadas en software.  Por lo general, están ocupados procesando instrucciones básicas, similares a las instrucciones escritas en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Assembler</a> . <br><br>  Python es un lenguaje interpretado.  El código escrito en Python se compila en un conjunto de instrucciones que es conveniente para la computadora, en el llamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">código de bytes</a> .  La máquina virtual interpreta estas instrucciones cuando ejecuta su programa. <br><br>  ¿Alguna vez has visto archivos con la extensión <code>.pyc</code> o la carpeta <code>__pycache__</code> ?  Contienen el mismo código de bytes interpretado por la máquina virtual. <br><br>  Es importante tener en cuenta que, además de CPython, hay otras implementaciones de Python.  Por ejemplo, cuando se usa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IronPython, el</a> código Python se compila en una declaración CLR de Microsoft.  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Jython, el</a> código se compila en código de bytes Java y se ejecuta en una máquina virtual Java.  En el mundo de Python, existe algo así como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PyPy</a> , pero es digno de un artículo separado, así que aquí solo lo mencionamos. <br><br>  Para los fines de este artículo, me enfocaré en cómo funcionan los mecanismos de administración de memoria en la implementación de referencia de Python: CPython. <br><br>  Cabe señalar que aunque la mayor parte de lo que vamos a hablar aquí será cierto para las nuevas versiones de Python, las cosas pueden cambiar en el futuro.  Por lo tanto, preste atención al hecho de que en este artículo me centro en la última versión de Python al momento de escribir: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Python 3.7</a> . <br><br>  Entonces, el paquete de software CPython está escrito en C, interpreta el código de bytes de Python.  ¿Qué tiene esto que ver con la gestión de la memoria?  El hecho es que los algoritmos y las estructuras de datos utilizados para la gestión de la memoria existen en el código CPython escrito, como ya se ha dicho, en C. Para comprender cómo funciona la gestión de la memoria en Python, primero debe comprender un poco sobre CPython. <br><br>  El lenguaje C en el que se escribe CPython no tiene soporte incorporado para la programación orientada a objetos.  Debido a esto, se utilizan muchas soluciones arquitectónicas interesantes en el código CPython. <br><br>  Es posible que haya escuchado que todo en Python es un objeto, incluso los tipos de datos primitivos como <code>int</code> y <code>str</code> .  Y este es el caso en el nivel de implementación del lenguaje en CPython.  Hay una estructura llamada <code>PyObject</code> , que es utilizada por los objetos creados en CPython. <br><br>  Una estructura es un tipo de datos compuesto que puede agrupar datos de diferentes tipos.  Si compara esto con la programación orientada a objetos, la estructura es similar a una clase que tiene atributos pero no métodos. <br><br>  <code>PyObject</code> es el antepasado de todos los objetos de Python.  Esta estructura contiene solo dos campos: <br><br><ul><li>  <code>ob_refcnt</code> - contador de referencia. </li><li>  <code>ob_type</code> : puntero a otro tipo. </li></ul><br>  El contador de referencia se usa para implementar el mecanismo de recolección de basura.  Otro campo de <code>PyObject</code> es un puntero a un tipo específico de objeto.  Este tipo está representado por otra estructura que describe el objeto Python (por ejemplo, puede ser un tipo <code>dict</code> o <code>int</code> ). <br><br>  Cada objeto tiene su propio mecanismo de asignación de memoria, único para dicho objeto, que sabe cómo obtener la memoria necesaria para almacenar este objeto.  Además, cada objeto tiene su propio mecanismo para liberar memoria, que "libera" la memoria después de que ya no es necesaria. <br><br>  Sin embargo, debe tenerse en cuenta que en todas estas conversaciones sobre la asignación y liberación de memoria, hay un factor importante.  El hecho es que la memoria de la computadora es un recurso compartido.  Si, al mismo tiempo, dos procesos diferentes intentan escribir algo en la misma área de memoria, puede suceder algo malo. <br><br><h2>  <font color="#3AC1EF">Intérprete Global Lock</font> </h2><br>  Global Interpreter Lock (GIL) es una solución a un problema común que ocurre cuando se trabaja con recursos informáticos compartidos como la memoria.  Cuando dos hilos intentan modificar simultáneamente el mismo recurso, pueden "colisionar" entre sí.  El resultado será un desastre y ninguna de las transmisiones logrará lo que buscaba. <br><br>  Volvamos a la analogía del libro nuevamente.  Imagine que dos autores decidieron arbitrariamente que ahora les tocaba tomar notas.  Pero también decidieron tomar notas simultáneamente en la misma página. <br><br>  Cada uno de ellos no presta atención al hecho de que el otro está tratando de escribir su historia.  Juntos comienzan a escribir texto en la página.  Como resultado, se grabarán dos historias allí, una encima de la otra, lo que hará que la página sea completamente ilegible. <br><br>  Una de las soluciones a este problema es un único mecanismo de intérprete global que bloquea los recursos compartidos con los que está trabajando un determinado hilo.  En nuestro ejemplo, este es un "mecanismo" que "bloquea" la página de un libro.  Tal mecanismo elimina la situación descrita anteriormente, en la que dos autores escriben simultáneamente texto en la misma página. <br><br>  El mecanismo GIL en Python logra esto mediante el bloqueo de todo el intérprete.  Como resultado, nada puede interferir con el funcionamiento del hilo actual.  Y cuando CPython está trabajando con memoria, utiliza el GIL para garantizar que este trabajo se realice de manera segura y eficiente. <br><br>  Hay puntos fuertes y débiles en este enfoque, y el GIL es objeto de un feroz debate en la comunidad de Python.  Para obtener más información sobre GIL, puede echar un vistazo a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este material</a> . <br><br><h2>  <font color="#3AC1EF">Recolección de basura</font> </h2><br>  Volvamos a la analogía del libro e imaginemos que algunas de las historias registradas en este libro están irremediablemente desactualizadas.  Nadie los lee, nadie los menciona en ningún lado.  Y si nadie lee o hace referencia a algún material en sus obras, entonces este material puede eliminarse, dejando espacio para nuevos textos. <br><br>  Estos viejos cuentos olvidados se pueden comparar con los objetos de Python cuyos recuentos de referencia son cero.  Estos son los mismos contadores de los que hablamos cuando discutimos la estructura de <code>PyObject</code> . <br><br>  El contador de enlaces se incrementa por varias razones.  Por ejemplo, el contador se incrementa si el objeto almacenado en una variable se escribe en otra variable: <br><br><pre> <code class="python hljs">numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-comment"><span class="hljs-comment">#   = 1 more_numbers = numbers #   = 2</span></span></code> </pre> <br>  Aumenta cuando el objeto se pasa a alguna función como argumento: <br><br><pre> <code class="python hljs">total = sum(numbers)</code> </pre> <br>  Y aquí hay otro ejemplo de una situación en la que el número en el contador de referencia aumenta.  Esto sucede si el objeto está incluido en la lista: <br><br><pre> <code class="python hljs">matrix = [numbers, numbers, numbers]</code> </pre> <br>  Python permite al programador encontrar el valor actual del recuento de referencia de un determinado objeto utilizando el módulo <code>sys</code> .  Para esto, se utiliza la siguiente construcción: <br><br><pre> <code class="python hljs">sys.getrefcount(numbers)</code> </pre> <br>  <code>getfefcount()</code> , debe recordar que pasar un objeto al método <code>getfefcount()</code> aumenta el valor del contador en 1. <br><br>  En cualquier caso, si el objeto todavía se usa en algún lugar del código, su contador de referencia será mayor que 0. Cuando el valor del contador cae a 0, entrará en juego una función especial que "libera" la memoria ocupada por el objeto.  Esta memoria puede ser utilizada por otros objetos. <br><br>  Ahora nos hacemos preguntas sobre qué es "liberar memoria" y sobre cómo otros objetos pueden usar esta memoria.  Para responder a estas preguntas, hablemos sobre los mecanismos de administración de memoria en CPython. <br><br><h2>  <font color="#3AC1EF">Mecanismos de gestión de memoria en CPython</font> </h2><br>  Ahora hablaremos sobre cómo CPython tiene una arquitectura de memoria y cómo se realiza la administración de memoria allí. <br><br>  Como ya se mencionó, hay varias capas de abstracción entre CPython y la memoria física.  El sistema operativo abstrae la memoria física y crea una capa de memoria virtual con la que las aplicaciones pueden trabajar (esto también se aplica a Python). <br><br>  El administrador de memoria virtual de un sistema operativo específico asigna un trozo de memoria para el proceso de Python.  Las áreas de color gris oscuro en la siguiente imagen son las piezas de memoria que pertenecen al proceso de Python. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e51/f01/548/e51f0154800b0ae223bf1c7d96f5bab8.png"><br>  <i><font color="#999999">Áreas de memoria utilizadas por CPython</font></i> <br><br>  Python usa una cierta cantidad de memoria para uso interno y para necesidades no relacionadas con la asignación de memoria para objetos.  Se usa otra pieza de memoria para almacenar objetos (estos son valores de los tipos <code>int</code> , <code>dict</code> y otros similares).  Tenga en cuenta que este es un diagrama simplificado.  Si desea ver la imagen completa, eche un vistazo al código fuente de <a href="">CPython</a> , donde está sucediendo todo lo que estamos hablando. <br><br>  CPython tiene una facilidad para asignar memoria para objetos, que es responsable de asignar memoria en el área destinada para almacenar objetos.  Lo más interesante sucede cuando este mecanismo funciona.  Se llama cuando el objeto necesita memoria, o en los casos en que la memoria necesita ser liberada. <br><br>  Por lo general, agregar o eliminar datos a objetos de Python como <code>list</code> e <code>int</code> no implica el procesamiento simultáneo de grandes cantidades de información.  Por lo tanto, la arquitectura de la herramienta de asignación de memoria se construye teniendo en cuenta el procesamiento de pequeñas cantidades de datos.  Además, esta herramienta busca no asignar memoria hasta que quede claro que es absolutamente necesario. <br><br>  Los comentarios en el <a href="">código fuente</a> describen la herramienta de asignación de memoria como "una herramienta de asignación de memoria rápida y especializada para bloques pequeños que está diseñada para usarse encima del malloc universal".  En este caso, <code>malloc</code> es una función de biblioteca C diseñada para asignar memoria. <br><br>  Analicemos la estrategia de asignación de memoria utilizada por CPython.  Primero, hablaremos de tres entidades: los llamados bloques (bloques), piscinas (piscinas) y arenas (arena), y cómo se relacionan entre sí. <br><br>  Las arenas son los fragmentos más grandes de memoria.  Están alineados en los bordes de las páginas de la memoria.  El límite de la página es donde el bloque continuo de memoria de longitud fija termina en uso por el sistema operativo.  Python, mientras trabaja con memoria, supone que el tamaño de la página de memoria del sistema es de 256 KB. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/75e/4d2/dc2/75e4d2dc2e0f6985363952432b7c169d.png"><br>  <i><font color="#999999">Arenas, Piscinas y Bloques</font></i> <br><br>  Los grupos se encuentran en las arenas, que son páginas de memoria virtual de 4 KB.  Se parecen a las páginas del libro de nuestro ejemplo.  Las piscinas se dividen en pequeños bloques de memoria. <br><br>  Todos los bloques en el mismo grupo pertenecen a la misma clase de tamaño.  La clase de tamaño a la que pertenece el bloque determina el tamaño de este bloque, que se selecciona teniendo en cuenta el tamaño de memoria solicitado.  Aquí hay una tabla tomada del código fuente que muestra la cantidad de datos que el sistema solicita almacenar en la memoria, los tamaños de los bloques asignados y los identificadores de las clases de tamaño. <br><table><tbody><tr><td>  La cantidad de datos en bytes. <br></td><td>  Tamaño del bloque <br></td><td>  tamaño de clase idx <br></td></tr><tr><td>  1-8 <br></td><td>  8 <br></td><td>  0 0 <br></td></tr><tr><td>  9-16 <br></td><td>  16 <br></td><td>  1 <br></td></tr><tr><td>  17-24 <br></td><td>  24 <br></td><td>  2 <br></td></tr><tr><td>  25-32 <br></td><td>  32 <br></td><td>  3 <br></td></tr><tr><td>  33-40 <br></td><td>  40 <br></td><td>  4 4 <br></td></tr><tr><td>  41-48 <br></td><td>  48 <br></td><td>  5 5 <br></td></tr><tr><td>  49-56 <br></td><td>  56 <br></td><td>  6 6 <br></td></tr><tr><td>  57-64 <br></td><td>  64 <br></td><td>  7 7 <br></td></tr><tr><td>  65-72 <br></td><td>  72 <br></td><td>  8 <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  ... <br></td></tr><tr><td>  497-504 <br></td><td>  504 <br></td><td>  62 <br></td></tr><tr><td>  505-512 <br></td><td>  512 <br></td><td>  63 <br></td></tr></tbody></table><br>  Por ejemplo, si se solicita que se almacenen 42 bytes, los datos se colocarán en un bloque de 48 bytes. <br><br><h2>  <font color="#3AC1EF">Piscinas</font> </h2><br>  Las agrupaciones consisten en bloques que pertenecen a la misma clase de tamaño.  Cada grupo está asociado con otros grupos que contienen bloques de la misma clase de tamaño utilizando el mecanismo de lista doblemente vinculada.  Con este enfoque, el algoritmo de asignación de memoria puede encontrar fácilmente espacio libre para un bloque de un tamaño determinado, incluso si se trata de encontrar espacio libre en diferentes grupos. <br><br>  La lista de <code>usedpools</code> permite realizar un seguimiento de todos los pools en los que hay espacio para datos que pertenecen a una clase de tamaño particular.  Cuando se le solicita guardar un bloque de cierto tamaño, el algoritmo verifica esta lista para ver una lista de grupos que almacenan bloques del tamaño requerido. <br><br>  Las piscinas mismas deben estar en uno de los tres estados.  Es decir, se pueden usar (estado <code>used</code> ), se pueden llenar ( <code>full</code> ) o vacías ( <code>empty</code> ).  El grupo utilizado tiene bloques libres en los que es posible guardar datos de un tamaño adecuado.  Todos los bloques del grupo lleno se asignan para datos.  Un grupo vacío no contiene datos y, si es necesario, puede asignarse a bloques de tiendas que pertenezcan a cualquier clase de tamaño. <br><br>  La lista de <code>freepools</code> almacena información sobre todos los grupos que están en estado <code>empty</code> .  Por ejemplo, si no hay entradas en la lista de grupos <code>usedpools</code> sobre grupos que almacenan bloques de 8 bytes (clase con idx 0), entonces se inicializa un nuevo grupo, que está en estado <code>empty</code> , diseñado para almacenar dichos bloques.  Este nuevo grupo se agrega a la lista de <code>usedpools</code> , se puede usar para cumplir con las solicitudes para guardar los datos recibidos después de su creación. <br><br>  Suponga que en un grupo que está en estado <code>full</code> , algunos bloques se liberan.  Esto se debe al hecho de que los datos almacenados en ellos ya no son necesarios.  Este grupo volverá a estar en la lista de <code>usedpools</code> y se puede usar para datos de la clase de tamaño correspondiente. <br><br>  Conocer este algoritmo nos permite comprender cómo cambia el estado de los grupos durante la operación (y cómo cambian las clases de tamaño, los bloques que pertenecen pueden almacenarse en ellos). <br><br><h2>  <font color="#3AC1EF">Bloques</font> </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/627/407/ef5/627407ef5dafac3533d81ae0beec66f2.png"><br>  <i><font color="#999999">Piscinas usadas, llenas y vacías</font></i> <br><br>  Como puede ver en la ilustración anterior, los grupos contienen punteros a los bloques de memoria "libres" que contienen.  En cuanto al trabajo con bloques, se debe tener en cuenta una pequeña característica, que se indica en el código fuente.  El sistema de gestión de memoria utilizado en CPython, en todos los niveles (arenas, agrupaciones, bloques), se esfuerza por asignar memoria solo cuando es absolutamente necesario. <br><br>  Esto significa que los grupos pueden contener bloques que se encuentran en uno de los tres estados: <br><br><ul><li>  <code>untouched</code> es la porción de memoria que aún no se ha asignado. </li><li>  <code>free</code> : la parte de la memoria que ya estaba asignada, pero que luego fue "libre" por CPython y ya no contiene datos valiosos. </li><li>  <code>allocated</code> es la porción de memoria que contiene datos valiosos. </li></ul><br>  El puntero de <code>freeblock</code> apunta a una lista individualmente vinculada de bloques de memoria libre.  En otras palabras, esta es una lista de lugares donde puede colocar datos.  Si se necesita más de un bloque libre para colocar datos, entonces la herramienta de asignación de memoria tomará varios bloques del grupo que están en estado <code>untouched</code> . <br><br>  A medida que la herramienta de administración de memoria hace que los bloques sean "libres", ellos, cuando adquieren el estado <code>free</code> , llegan a la parte superior de la lista de <code>freeblock</code> .  Los bloques contenidos en esta lista no representan necesariamente una región de memoria contigua similar a la que se muestra en la figura anterior.  En realidad, pueden parecerse a la de abajo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cca/0c7/725/cca0c7725ce480809ee3d59b4a1b28fa.png"><br>  <i><font color="#999999">Lista de bloque libre individual vinculada</font></i> <br><br><h2>  <font color="#3AC1EF">Arenas</font> </h2><br>  Las arenas contienen piscinas.  Estas agrupaciones, como ya se mencionó, pueden residir en los estados <code>used</code> , <code>full</code> o <code>empty</code> .  Cabe señalar que las arenas no tienen estados similares a los que tienen las piscinas. <br><br>  Las arenas se organizan en una lista doblemente vinculada llamada <code>usable_arenas</code> .  Esta lista está ordenada por la cantidad de agrupaciones gratuitas disponibles.  Cuantas menos piscinas libres haya en la arena, más cerca estará la arena de la parte superior de la lista. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f91/17d/6f1/f9117d6f1b6670afd7235a2efc936713.png"><br>  <i><font color="#999999">Lista de arenas utilizables</font></i> <br><br>  Esto significa que la arena, que es más fuerte que otras llenas de datos, se seleccionará para colocar nuevos datos en ella.  ¿Y por qué no al revés?  ¿Por qué no publicar nuevos datos en la arena con el mayor espacio libre? <br><br>  De hecho, esta característica nos lleva a la idea de liberar realmente la memoria.  Es posible que haya notado que a menudo usamos el concepto de "liberar memoria" aquí, encerrándolo entre comillas.  La razón por la que se hizo esto es que, aunque el bloque puede considerarse "libre", la pieza de memoria que representa no se devuelve al sistema operativo.  El proceso de Python contiene este fragmento de memoria y luego lo usa para almacenar nuevos datos.  La verdadera liberación de memoria es el retorno de su sistema operativo, que puede aprovecharlo. <br><br>  Las arenas son la única entidad en el esquema considerado aquí, la memoria representada por la cual puede ser verdaderamente liberada.  El sentido común dicta que el esquema descrito anteriormente de trabajar con arenas tiene como objetivo permitir que aquellas arenas que están casi vacías se vacian por completo.  Con este enfoque, esa pieza de memoria que está representada por una arena completamente vacía puede liberarse realmente, lo que reducirá la cantidad de memoria consumida por Python. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  Esto es lo que aprendiste al leer este material: <br><br><ul><li>  ¿Qué es la administración de memoria y por qué es importante? </li><li>  Cómo se organiza la implementación de referencia de Python, Cpython, escrita en el lenguaje de programación C. </li><li>  Qué estructuras de datos y algoritmos se utilizan en CPython para la gestión de la memoria. </li></ul><br>  La gestión de la memoria es una parte integral del trabajo de los programas de computadora.  Python resuelve casi todas las tareas de administración de memoria sin que el programador las note.  Python permite que cualquiera que escriba en este idioma ignore los muchos pequeños detalles relacionados con el trabajo con computadoras.  Esto le da al programador la oportunidad de trabajar a un nivel superior, para crear su propio código sin preocuparse de dónde se almacenan sus datos. <br><br>  <b>Estimados lectores!</b>  Si tiene experiencia con el desarrollo de Python, díganos cómo aborda el uso de la memoria en sus programas.  Por ejemplo, ¿buscas guardarlo? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441568/">https://habr.com/ru/post/441568/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441550/index.html">La vida de un programador simple es dura y llana</a></li>
<li><a href="../441554/index.html">Toda la historia de Linux. Parte I: cómo comenzó todo</a></li>
<li><a href="../441560/index.html">Eventos digitales en Moscú del 25 de febrero al 3 de marzo</a></li>
<li><a href="../441562/index.html">Pixel Gallop - Parte cinco - Animación de personajes. Caminando</a></li>
<li><a href="../441566/index.html">12 conceptos de JavaScript para conocer</a></li>
<li><a href="../441570/index.html">El resumen de materiales frescos del mundo del front-end para la última semana No. 353 (del 17 al 24 de febrero de 2019)</a></li>
<li><a href="../441572/index.html">Frontend Weekly Digest (18-24 de febrero de 2019)</a></li>
<li><a href="../441574/index.html">Learning Docker Parte 6: Trabajar con datos</a></li>
<li><a href="../441576/index.html">Redes de Kubernetes: Pods</a></li>
<li><a href="../441578/index.html">Tutorial de React Parte 19: Métodos del ciclo de vida de los componentes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>