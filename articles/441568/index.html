<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游볪 游뱢游 游꾼游낕 Gesti칩n de memoria Python 游땚 游눇 游볻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="쮸lguna vez te has preguntado c칩mo se ven los datos con los que trabajas en las entra침as de Python? 쯉obre c칩mo se crean y almacenan las variables en ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gesti칩n de memoria Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/441568/">  쮸lguna vez te has preguntado c칩mo se ven los datos con los que trabajas en las entra침as de Python?  쯉obre c칩mo se crean y almacenan las variables en la memoria?  쮺칩mo y cu치ndo se eliminan?  El material, cuya traducci칩n publicamos, est치 dedicado a la investigaci칩n de las profundidades de Python, durante el cual trataremos de descubrir las caracter칤sticas de la administraci칩n de memoria en este lenguaje.  Despu칠s de estudiar este art칤culo, comprender치 c칩mo funcionan los mecanismos de bajo nivel de las computadoras, especialmente los relacionados con la memoria.  Comprender치 c칩mo Python abstrae las operaciones de bajo nivel y c칩mo administra la memoria. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/ok/qc/59/okqc59rnficniaz3pfcaaae5onc.jpeg"></a> <br><br>  Saber lo que est치 sucediendo en Python le permitir치 comprender mejor algunos de los comportamientos de este lenguaje.  Esto, espero, le dar치 la oportunidad de apreciar el enorme trabajo que se est치 realizando dentro de la implementaci칩n de este lenguaje que utiliza para que sus programas funcionen exactamente como lo necesita. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">La memoria es un libro vacio</font> </h2><br>  La memoria de la computadora, al comienzo de trabajar con ella, se puede representar en forma de un libro vac칤o destinado a cuentos.  Si bien no hay nada en sus p치ginas, pronto aparecer치n los autores de las historias, cada uno de los cuales quiere escribir su propia historia en este libro. <br><br>  Como una historia no se puede escribir sobre otra, los autores deben tener cuidado con las p치ginas del libro en las que escriben.  Antes de escribir nada, consultan con el editor en jefe.  칄l decide d칩nde exactamente los autores pueden grabar historias. <br><br>  Dado que el libro del que hablamos ha existido durante bastante tiempo, muchas de las historias ya est치n desactualizadas.  Si nadie lee una historia o la menciona en sus obras, esta historia se elimina del libro, dejando espacio para nuevas historias. <br><br>  En general, podemos decir que la memoria de la computadora es muy similar a un libro de este tipo.  De hecho, los bloques continuos de memoria de una longitud fija incluso se llaman p치ginas, por lo que creemos que comparar la memoria con un libro es muy exitoso. <br><br>  Los autores que escriben sus historias en un libro son diferentes aplicaciones o procesos que necesitan almacenar datos en la memoria.  El editor jefe, que decide qu칠 p치ginas del libro pueden escribir los autores, es el mecanismo que se ocupa de la gesti칩n de la memoria.  Y el que elimina viejas historias del libro, dejando espacio para nuevas, se puede comparar con el mecanismo de recolecci칩n de basura. <br><br><h2>  <font color="#3AC1EF">Gesti칩n de la memoria: el camino del hierro a los programas</font> </h2><br>  La gesti칩n de la memoria es un proceso, durante la implementaci칩n de los cuales los programas escriben datos en la memoria y los leen.  Un administrador de memoria es una entidad que determina d칩nde exactamente una aplicaci칩n puede colocar sus datos en la memoria.  Dado que el n칰mero de fragmentos de memoria que se pueden asignar a las aplicaciones no es infinito, as칤 como el n칰mero de p치ginas en cualquier libro no es infinito, el administrador de memoria, que sirve a las aplicaciones, necesita encontrar fragmentos de memoria libres y proporcionarlos a las aplicaciones.  Este proceso, en el que la memoria se asigna a las aplicaciones, se denomina asignaci칩n de memoria. <br><br>  Por otro lado, cuando algunos datos ya no son necesarios, se pueden eliminar o, en otras palabras, liberar la memoria que ocupa.  Pero, 쯤u칠 es exactamente "aislar" y "liberar" cuando se habla de memoria? <br><br>  En alg칰n lugar de su computadora hay un dispositivo f칤sico que almacena los datos utilizados por los programas Python mientras funcionan.  Antes de que un objeto Python aparezca en la memoria f칤sica, el c칩digo debe pasar por muchas capas de abstracci칩n. <br><br>  Una de las principales capas de este tipo, que se encuentra en la parte superior del hardware (como RAM o disco duro) es el sistema operativo (SO).  Ejecuta (o se niega a cumplir) solicitudes para leer datos de la memoria y escribir datos en la memoria. <br><br>  Encima del sistema operativo hay una aplicaci칩n, en nuestro caso, una de las implementaciones de Python (puede ser un paquete de software que es parte de su sistema operativo o descargado de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">python.org</a> ).  Es este paquete de software el que se dedica a la gesti칩n de la memoria, lo que garantiza el funcionamiento de su c칩digo Python.  El enfoque de este art칤culo est치 en los algoritmos y las estructuras de datos que Python usa para administrar la memoria. <br><br><h2>  <font color="#3AC1EF">Implementaci칩n de referencia de Python</font> </h2><br>  La implementaci칩n de Python de referencia se llama CPython.  Est치 escrito en C. Cuando lo escuch칠 por primera vez, literalmente me inquiet칩.  쯋n lenguaje de programaci칩n que est치 escrito en otro idioma?  Bueno, en realidad, esto no es del todo cierto. <br><br>  La especificaci칩n de Python se describe en ingl칠s simple en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este documento</a> .  Sin embargo, esta especificaci칩n sola, el c칩digo escrito en Python, por supuesto, no puede ejecutarse.  Para hacer esto, necesita algo que, siguiendo las reglas de esta especificaci칩n, pueda interpretar el c칩digo escrito en Python. <br><br>  Adem치s, necesita algo que pueda ejecutar el c칩digo interpretado en la computadora.  La implementaci칩n de Python de referencia resuelve ambas tareas.  Convierte el c칩digo en instrucciones que luego se ejecutan en la m치quina virtual. <br><br>  Las m치quinas virtuales son similares a las computadoras comunes hechas de silicio, metal y otros materiales, pero est치n implementadas en software.  Por lo general, est치n ocupados procesando instrucciones b치sicas, similares a las instrucciones escritas en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Assembler</a> . <br><br>  Python es un lenguaje interpretado.  El c칩digo escrito en Python se compila en un conjunto de instrucciones que es conveniente para la computadora, en el llamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c칩digo de bytes</a> .  La m치quina virtual interpreta estas instrucciones cuando ejecuta su programa. <br><br>  쮸lguna vez has visto archivos con la extensi칩n <code>.pyc</code> o la carpeta <code>__pycache__</code> ?  Contienen el mismo c칩digo de bytes interpretado por la m치quina virtual. <br><br>  Es importante tener en cuenta que, adem치s de CPython, hay otras implementaciones de Python.  Por ejemplo, cuando se usa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IronPython, el</a> c칩digo Python se compila en una declaraci칩n CLR de Microsoft.  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Jython, el</a> c칩digo se compila en c칩digo de bytes Java y se ejecuta en una m치quina virtual Java.  En el mundo de Python, existe algo as칤 como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PyPy</a> , pero es digno de un art칤culo separado, as칤 que aqu칤 solo lo mencionamos. <br><br>  Para los fines de este art칤culo, me enfocar칠 en c칩mo funcionan los mecanismos de administraci칩n de memoria en la implementaci칩n de referencia de Python: CPython. <br><br>  Cabe se침alar que aunque la mayor parte de lo que vamos a hablar aqu칤 ser치 cierto para las nuevas versiones de Python, las cosas pueden cambiar en el futuro.  Por lo tanto, preste atenci칩n al hecho de que en este art칤culo me centro en la 칰ltima versi칩n de Python al momento de escribir: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Python 3.7</a> . <br><br>  Entonces, el paquete de software CPython est치 escrito en C, interpreta el c칩digo de bytes de Python.  쯈u칠 tiene esto que ver con la gesti칩n de la memoria?  El hecho es que los algoritmos y las estructuras de datos utilizados para la gesti칩n de la memoria existen en el c칩digo CPython escrito, como ya se ha dicho, en C. Para comprender c칩mo funciona la gesti칩n de la memoria en Python, primero debe comprender un poco sobre CPython. <br><br>  El lenguaje C en el que se escribe CPython no tiene soporte incorporado para la programaci칩n orientada a objetos.  Debido a esto, se utilizan muchas soluciones arquitect칩nicas interesantes en el c칩digo CPython. <br><br>  Es posible que haya escuchado que todo en Python es un objeto, incluso los tipos de datos primitivos como <code>int</code> y <code>str</code> .  Y este es el caso en el nivel de implementaci칩n del lenguaje en CPython.  Hay una estructura llamada <code>PyObject</code> , que es utilizada por los objetos creados en CPython. <br><br>  Una estructura es un tipo de datos compuesto que puede agrupar datos de diferentes tipos.  Si compara esto con la programaci칩n orientada a objetos, la estructura es similar a una clase que tiene atributos pero no m칠todos. <br><br>  <code>PyObject</code> es el antepasado de todos los objetos de Python.  Esta estructura contiene solo dos campos: <br><br><ul><li>  <code>ob_refcnt</code> - contador de referencia. </li><li>  <code>ob_type</code> : puntero a otro tipo. </li></ul><br>  El contador de referencia se usa para implementar el mecanismo de recolecci칩n de basura.  Otro campo de <code>PyObject</code> es un puntero a un tipo espec칤fico de objeto.  Este tipo est치 representado por otra estructura que describe el objeto Python (por ejemplo, puede ser un tipo <code>dict</code> o <code>int</code> ). <br><br>  Cada objeto tiene su propio mecanismo de asignaci칩n de memoria, 칰nico para dicho objeto, que sabe c칩mo obtener la memoria necesaria para almacenar este objeto.  Adem치s, cada objeto tiene su propio mecanismo para liberar memoria, que "libera" la memoria despu칠s de que ya no es necesaria. <br><br>  Sin embargo, debe tenerse en cuenta que en todas estas conversaciones sobre la asignaci칩n y liberaci칩n de memoria, hay un factor importante.  El hecho es que la memoria de la computadora es un recurso compartido.  Si, al mismo tiempo, dos procesos diferentes intentan escribir algo en la misma 치rea de memoria, puede suceder algo malo. <br><br><h2>  <font color="#3AC1EF">Int칠rprete Global Lock</font> </h2><br>  Global Interpreter Lock (GIL) es una soluci칩n a un problema com칰n que ocurre cuando se trabaja con recursos inform치ticos compartidos como la memoria.  Cuando dos hilos intentan modificar simult치neamente el mismo recurso, pueden "colisionar" entre s칤.  El resultado ser치 un desastre y ninguna de las transmisiones lograr치 lo que buscaba. <br><br>  Volvamos a la analog칤a del libro nuevamente.  Imagine que dos autores decidieron arbitrariamente que ahora les tocaba tomar notas.  Pero tambi칠n decidieron tomar notas simult치neamente en la misma p치gina. <br><br>  Cada uno de ellos no presta atenci칩n al hecho de que el otro est치 tratando de escribir su historia.  Juntos comienzan a escribir texto en la p치gina.  Como resultado, se grabar치n dos historias all칤, una encima de la otra, lo que har치 que la p치gina sea completamente ilegible. <br><br>  Una de las soluciones a este problema es un 칰nico mecanismo de int칠rprete global que bloquea los recursos compartidos con los que est치 trabajando un determinado hilo.  En nuestro ejemplo, este es un "mecanismo" que "bloquea" la p치gina de un libro.  Tal mecanismo elimina la situaci칩n descrita anteriormente, en la que dos autores escriben simult치neamente texto en la misma p치gina. <br><br>  El mecanismo GIL en Python logra esto mediante el bloqueo de todo el int칠rprete.  Como resultado, nada puede interferir con el funcionamiento del hilo actual.  Y cuando CPython est치 trabajando con memoria, utiliza el GIL para garantizar que este trabajo se realice de manera segura y eficiente. <br><br>  Hay puntos fuertes y d칠biles en este enfoque, y el GIL es objeto de un feroz debate en la comunidad de Python.  Para obtener m치s informaci칩n sobre GIL, puede echar un vistazo a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este material</a> . <br><br><h2>  <font color="#3AC1EF">Recolecci칩n de basura</font> </h2><br>  Volvamos a la analog칤a del libro e imaginemos que algunas de las historias registradas en este libro est치n irremediablemente desactualizadas.  Nadie los lee, nadie los menciona en ning칰n lado.  Y si nadie lee o hace referencia a alg칰n material en sus obras, entonces este material puede eliminarse, dejando espacio para nuevos textos. <br><br>  Estos viejos cuentos olvidados se pueden comparar con los objetos de Python cuyos recuentos de referencia son cero.  Estos son los mismos contadores de los que hablamos cuando discutimos la estructura de <code>PyObject</code> . <br><br>  El contador de enlaces se incrementa por varias razones.  Por ejemplo, el contador se incrementa si el objeto almacenado en una variable se escribe en otra variable: <br><br><pre> <code class="python hljs">numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-comment"><span class="hljs-comment">#   = 1 more_numbers = numbers #   = 2</span></span></code> </pre> <br>  Aumenta cuando el objeto se pasa a alguna funci칩n como argumento: <br><br><pre> <code class="python hljs">total = sum(numbers)</code> </pre> <br>  Y aqu칤 hay otro ejemplo de una situaci칩n en la que el n칰mero en el contador de referencia aumenta.  Esto sucede si el objeto est치 incluido en la lista: <br><br><pre> <code class="python hljs">matrix = [numbers, numbers, numbers]</code> </pre> <br>  Python permite al programador encontrar el valor actual del recuento de referencia de un determinado objeto utilizando el m칩dulo <code>sys</code> .  Para esto, se utiliza la siguiente construcci칩n: <br><br><pre> <code class="python hljs">sys.getrefcount(numbers)</code> </pre> <br>  <code>getfefcount()</code> , debe recordar que pasar un objeto al m칠todo <code>getfefcount()</code> aumenta el valor del contador en 1. <br><br>  En cualquier caso, si el objeto todav칤a se usa en alg칰n lugar del c칩digo, su contador de referencia ser치 mayor que 0. Cuando el valor del contador cae a 0, entrar치 en juego una funci칩n especial que "libera" la memoria ocupada por el objeto.  Esta memoria puede ser utilizada por otros objetos. <br><br>  Ahora nos hacemos preguntas sobre qu칠 es "liberar memoria" y sobre c칩mo otros objetos pueden usar esta memoria.  Para responder a estas preguntas, hablemos sobre los mecanismos de administraci칩n de memoria en CPython. <br><br><h2>  <font color="#3AC1EF">Mecanismos de gesti칩n de memoria en CPython</font> </h2><br>  Ahora hablaremos sobre c칩mo CPython tiene una arquitectura de memoria y c칩mo se realiza la administraci칩n de memoria all칤. <br><br>  Como ya se mencion칩, hay varias capas de abstracci칩n entre CPython y la memoria f칤sica.  El sistema operativo abstrae la memoria f칤sica y crea una capa de memoria virtual con la que las aplicaciones pueden trabajar (esto tambi칠n se aplica a Python). <br><br>  El administrador de memoria virtual de un sistema operativo espec칤fico asigna un trozo de memoria para el proceso de Python.  Las 치reas de color gris oscuro en la siguiente imagen son las piezas de memoria que pertenecen al proceso de Python. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e51/f01/548/e51f0154800b0ae223bf1c7d96f5bab8.png"><br>  <i><font color="#999999">츼reas de memoria utilizadas por CPython</font></i> <br><br>  Python usa una cierta cantidad de memoria para uso interno y para necesidades no relacionadas con la asignaci칩n de memoria para objetos.  Se usa otra pieza de memoria para almacenar objetos (estos son valores de los tipos <code>int</code> , <code>dict</code> y otros similares).  Tenga en cuenta que este es un diagrama simplificado.  Si desea ver la imagen completa, eche un vistazo al c칩digo fuente de <a href="">CPython</a> , donde est치 sucediendo todo lo que estamos hablando. <br><br>  CPython tiene una facilidad para asignar memoria para objetos, que es responsable de asignar memoria en el 치rea destinada para almacenar objetos.  Lo m치s interesante sucede cuando este mecanismo funciona.  Se llama cuando el objeto necesita memoria, o en los casos en que la memoria necesita ser liberada. <br><br>  Por lo general, agregar o eliminar datos a objetos de Python como <code>list</code> e <code>int</code> no implica el procesamiento simult치neo de grandes cantidades de informaci칩n.  Por lo tanto, la arquitectura de la herramienta de asignaci칩n de memoria se construye teniendo en cuenta el procesamiento de peque침as cantidades de datos.  Adem치s, esta herramienta busca no asignar memoria hasta que quede claro que es absolutamente necesario. <br><br>  Los comentarios en el <a href="">c칩digo fuente</a> describen la herramienta de asignaci칩n de memoria como "una herramienta de asignaci칩n de memoria r치pida y especializada para bloques peque침os que est치 dise침ada para usarse encima del malloc universal".  En este caso, <code>malloc</code> es una funci칩n de biblioteca C dise침ada para asignar memoria. <br><br>  Analicemos la estrategia de asignaci칩n de memoria utilizada por CPython.  Primero, hablaremos de tres entidades: los llamados bloques (bloques), piscinas (piscinas) y arenas (arena), y c칩mo se relacionan entre s칤. <br><br>  Las arenas son los fragmentos m치s grandes de memoria.  Est치n alineados en los bordes de las p치ginas de la memoria.  El l칤mite de la p치gina es donde el bloque continuo de memoria de longitud fija termina en uso por el sistema operativo.  Python, mientras trabaja con memoria, supone que el tama침o de la p치gina de memoria del sistema es de 256 KB. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/75e/4d2/dc2/75e4d2dc2e0f6985363952432b7c169d.png"><br>  <i><font color="#999999">Arenas, Piscinas y Bloques</font></i> <br><br>  Los grupos se encuentran en las arenas, que son p치ginas de memoria virtual de 4 KB.  Se parecen a las p치ginas del libro de nuestro ejemplo.  Las piscinas se dividen en peque침os bloques de memoria. <br><br>  Todos los bloques en el mismo grupo pertenecen a la misma clase de tama침o.  La clase de tama침o a la que pertenece el bloque determina el tama침o de este bloque, que se selecciona teniendo en cuenta el tama침o de memoria solicitado.  Aqu칤 hay una tabla tomada del c칩digo fuente que muestra la cantidad de datos que el sistema solicita almacenar en la memoria, los tama침os de los bloques asignados y los identificadores de las clases de tama침o. <br><table><tbody><tr><td>  La cantidad de datos en bytes. <br></td><td>  Tama침o del bloque <br></td><td>  tama침o de clase idx <br></td></tr><tr><td>  1-8 <br></td><td>  8 <br></td><td>  0 0 <br></td></tr><tr><td>  9-16 <br></td><td>  16 <br></td><td>  1 <br></td></tr><tr><td>  17-24 <br></td><td>  24 <br></td><td>  2 <br></td></tr><tr><td>  25-32 <br></td><td>  32 <br></td><td>  3 <br></td></tr><tr><td>  33-40 <br></td><td>  40 <br></td><td>  4 4 <br></td></tr><tr><td>  41-48 <br></td><td>  48 <br></td><td>  5 5 <br></td></tr><tr><td>  49-56 <br></td><td>  56 <br></td><td>  6 6 <br></td></tr><tr><td>  57-64 <br></td><td>  64 <br></td><td>  7 7 <br></td></tr><tr><td>  65-72 <br></td><td>  72 <br></td><td>  8 <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  ... <br></td></tr><tr><td>  497-504 <br></td><td>  504 <br></td><td>  62 <br></td></tr><tr><td>  505-512 <br></td><td>  512 <br></td><td>  63 <br></td></tr></tbody></table><br>  Por ejemplo, si se solicita que se almacenen 42 bytes, los datos se colocar치n en un bloque de 48 bytes. <br><br><h2>  <font color="#3AC1EF">Piscinas</font> </h2><br>  Las agrupaciones consisten en bloques que pertenecen a la misma clase de tama침o.  Cada grupo est치 asociado con otros grupos que contienen bloques de la misma clase de tama침o utilizando el mecanismo de lista doblemente vinculada.  Con este enfoque, el algoritmo de asignaci칩n de memoria puede encontrar f치cilmente espacio libre para un bloque de un tama침o determinado, incluso si se trata de encontrar espacio libre en diferentes grupos. <br><br>  La lista de <code>usedpools</code> permite realizar un seguimiento de todos los pools en los que hay espacio para datos que pertenecen a una clase de tama침o particular.  Cuando se le solicita guardar un bloque de cierto tama침o, el algoritmo verifica esta lista para ver una lista de grupos que almacenan bloques del tama침o requerido. <br><br>  Las piscinas mismas deben estar en uno de los tres estados.  Es decir, se pueden usar (estado <code>used</code> ), se pueden llenar ( <code>full</code> ) o vac칤as ( <code>empty</code> ).  El grupo utilizado tiene bloques libres en los que es posible guardar datos de un tama침o adecuado.  Todos los bloques del grupo lleno se asignan para datos.  Un grupo vac칤o no contiene datos y, si es necesario, puede asignarse a bloques de tiendas que pertenezcan a cualquier clase de tama침o. <br><br>  La lista de <code>freepools</code> almacena informaci칩n sobre todos los grupos que est치n en estado <code>empty</code> .  Por ejemplo, si no hay entradas en la lista de grupos <code>usedpools</code> sobre grupos que almacenan bloques de 8 bytes (clase con idx 0), entonces se inicializa un nuevo grupo, que est치 en estado <code>empty</code> , dise침ado para almacenar dichos bloques.  Este nuevo grupo se agrega a la lista de <code>usedpools</code> , se puede usar para cumplir con las solicitudes para guardar los datos recibidos despu칠s de su creaci칩n. <br><br>  Suponga que en un grupo que est치 en estado <code>full</code> , algunos bloques se liberan.  Esto se debe al hecho de que los datos almacenados en ellos ya no son necesarios.  Este grupo volver치 a estar en la lista de <code>usedpools</code> y se puede usar para datos de la clase de tama침o correspondiente. <br><br>  Conocer este algoritmo nos permite comprender c칩mo cambia el estado de los grupos durante la operaci칩n (y c칩mo cambian las clases de tama침o, los bloques que pertenecen pueden almacenarse en ellos). <br><br><h2>  <font color="#3AC1EF">Bloques</font> </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/627/407/ef5/627407ef5dafac3533d81ae0beec66f2.png"><br>  <i><font color="#999999">Piscinas usadas, llenas y vac칤as</font></i> <br><br>  Como puede ver en la ilustraci칩n anterior, los grupos contienen punteros a los bloques de memoria "libres" que contienen.  En cuanto al trabajo con bloques, se debe tener en cuenta una peque침a caracter칤stica, que se indica en el c칩digo fuente.  El sistema de gesti칩n de memoria utilizado en CPython, en todos los niveles (arenas, agrupaciones, bloques), se esfuerza por asignar memoria solo cuando es absolutamente necesario. <br><br>  Esto significa que los grupos pueden contener bloques que se encuentran en uno de los tres estados: <br><br><ul><li>  <code>untouched</code> es la porci칩n de memoria que a칰n no se ha asignado. </li><li>  <code>free</code> : la parte de la memoria que ya estaba asignada, pero que luego fue "libre" por CPython y ya no contiene datos valiosos. </li><li>  <code>allocated</code> es la porci칩n de memoria que contiene datos valiosos. </li></ul><br>  El puntero de <code>freeblock</code> apunta a una lista individualmente vinculada de bloques de memoria libre.  En otras palabras, esta es una lista de lugares donde puede colocar datos.  Si se necesita m치s de un bloque libre para colocar datos, entonces la herramienta de asignaci칩n de memoria tomar치 varios bloques del grupo que est치n en estado <code>untouched</code> . <br><br>  A medida que la herramienta de administraci칩n de memoria hace que los bloques sean "libres", ellos, cuando adquieren el estado <code>free</code> , llegan a la parte superior de la lista de <code>freeblock</code> .  Los bloques contenidos en esta lista no representan necesariamente una regi칩n de memoria contigua similar a la que se muestra en la figura anterior.  En realidad, pueden parecerse a la de abajo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cca/0c7/725/cca0c7725ce480809ee3d59b4a1b28fa.png"><br>  <i><font color="#999999">Lista de bloque libre individual vinculada</font></i> <br><br><h2>  <font color="#3AC1EF">Arenas</font> </h2><br>  Las arenas contienen piscinas.  Estas agrupaciones, como ya se mencion칩, pueden residir en los estados <code>used</code> , <code>full</code> o <code>empty</code> .  Cabe se침alar que las arenas no tienen estados similares a los que tienen las piscinas. <br><br>  Las arenas se organizan en una lista doblemente vinculada llamada <code>usable_arenas</code> .  Esta lista est치 ordenada por la cantidad de agrupaciones gratuitas disponibles.  Cuantas menos piscinas libres haya en la arena, m치s cerca estar치 la arena de la parte superior de la lista. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f91/17d/6f1/f9117d6f1b6670afd7235a2efc936713.png"><br>  <i><font color="#999999">Lista de arenas utilizables</font></i> <br><br>  Esto significa que la arena, que es m치s fuerte que otras llenas de datos, se seleccionar치 para colocar nuevos datos en ella.  쯏 por qu칠 no al rev칠s?  쯇or qu칠 no publicar nuevos datos en la arena con el mayor espacio libre? <br><br>  De hecho, esta caracter칤stica nos lleva a la idea de liberar realmente la memoria.  Es posible que haya notado que a menudo usamos el concepto de "liberar memoria" aqu칤, encerr치ndolo entre comillas.  La raz칩n por la que se hizo esto es que, aunque el bloque puede considerarse "libre", la pieza de memoria que representa no se devuelve al sistema operativo.  El proceso de Python contiene este fragmento de memoria y luego lo usa para almacenar nuevos datos.  La verdadera liberaci칩n de memoria es el retorno de su sistema operativo, que puede aprovecharlo. <br><br>  Las arenas son la 칰nica entidad en el esquema considerado aqu칤, la memoria representada por la cual puede ser verdaderamente liberada.  El sentido com칰n dicta que el esquema descrito anteriormente de trabajar con arenas tiene como objetivo permitir que aquellas arenas que est치n casi vac칤as se vacian por completo.  Con este enfoque, esa pieza de memoria que est치 representada por una arena completamente vac칤a puede liberarse realmente, lo que reducir치 la cantidad de memoria consumida por Python. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  Esto es lo que aprendiste al leer este material: <br><br><ul><li>  쯈u칠 es la administraci칩n de memoria y por qu칠 es importante? </li><li>  C칩mo se organiza la implementaci칩n de referencia de Python, Cpython, escrita en el lenguaje de programaci칩n C. </li><li>  Qu칠 estructuras de datos y algoritmos se utilizan en CPython para la gesti칩n de la memoria. </li></ul><br>  La gesti칩n de la memoria es una parte integral del trabajo de los programas de computadora.  Python resuelve casi todas las tareas de administraci칩n de memoria sin que el programador las note.  Python permite que cualquiera que escriba en este idioma ignore los muchos peque침os detalles relacionados con el trabajo con computadoras.  Esto le da al programador la oportunidad de trabajar a un nivel superior, para crear su propio c칩digo sin preocuparse de d칩nde se almacenan sus datos. <br><br>  <b>Estimados lectores!</b>  Si tiene experiencia con el desarrollo de Python, d칤ganos c칩mo aborda el uso de la memoria en sus programas.  Por ejemplo, 쯕uscas guardarlo? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441568/">https://habr.com/ru/post/441568/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441550/index.html">La vida de un programador simple es dura y llana</a></li>
<li><a href="../441554/index.html">Toda la historia de Linux. Parte I: c칩mo comenz칩 todo</a></li>
<li><a href="../441560/index.html">Eventos digitales en Mosc칰 del 25 de febrero al 3 de marzo</a></li>
<li><a href="../441562/index.html">Pixel Gallop - Parte cinco - Animaci칩n de personajes. Caminando</a></li>
<li><a href="../441566/index.html">12 conceptos de JavaScript para conocer</a></li>
<li><a href="../441570/index.html">El resumen de materiales frescos del mundo del front-end para la 칰ltima semana No. 353 (del 17 al 24 de febrero de 2019)</a></li>
<li><a href="../441572/index.html">Frontend Weekly Digest (18-24 de febrero de 2019)</a></li>
<li><a href="../441574/index.html">Learning Docker Parte 6: Trabajar con datos</a></li>
<li><a href="../441576/index.html">Redes de Kubernetes: Pods</a></li>
<li><a href="../441578/index.html">Tutorial de React Parte 19: M칠todos del ciclo de vida de los componentes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>