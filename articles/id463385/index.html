<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ… ğŸŒš ğŸ  Sekali lagi tentang prinsip substitusi Lisk, atau semantik warisan dalam OOP ğŸ‘¨ğŸ¼â€ğŸ’¼ ğŸ¤¦ğŸ» ğŸ‘©ğŸ»â€ğŸ“</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Warisan adalah salah satu pilar OOP. Warisan digunakan untuk menggunakan kembali kode umum. Tetapi kode umum tidak selalu diperlukan untuk menggunakan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sekali lagi tentang prinsip substitusi Lisk, atau semantik warisan dalam OOP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463385/"> <b>Warisan adalah salah satu pilar OOP.</b>  Warisan digunakan untuk menggunakan kembali kode umum.  Tetapi kode umum tidak selalu diperlukan untuk menggunakan kembali, dan pewarisan tidak selalu merupakan cara terbaik untuk menggunakan kembali kode.  Sering kali ternyata, sehingga ada kode yang serupa di dua bagian kode yang berbeda (kelas), tetapi persyaratan untuk mereka berbeda, yaitu.  kelas sebenarnya mewarisi dari satu sama lain dan mungkin tidak sepadan. <br><a name="habracut"></a><br>  Biasanya, untuk menggambarkan masalah ini, mereka menggunakan contoh tentang mewarisi kelas Kuadrat dari kelas Persegi Panjang, atau sebaliknya. <br><br>  Mari kita memiliki kelas persegi panjang: <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, width, height)</span></span></span><span class="hljs-function">:</span></span> self._width = width self._height = height <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_width</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, width)</span></span></span><span class="hljs-function">:</span></span> self._width = width <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, height)</span></span></span><span class="hljs-function">:</span></span> self._height = height <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._width * self._height ...</code> </pre> <br>  Sekarang kami ingin menulis kelas Square, tetapi untuk menggunakan kembali kode perhitungan area, tampaknya logis untuk mewarisi Square dari Rectangle: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Rectangle)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_width</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, width)</span></span></span><span class="hljs-function">:</span></span> self._width = width self._height = width <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, height)</span></span></span><span class="hljs-function">:</span></span> self._width = height self._height = height</code> </pre><br>  Tampaknya kode kelas Square dan Rectangle konsisten.  Tampaknya Square mempertahankan properti matematika dari alun-alun, mis.  dan persegi panjang.  Itu berarti kita bisa melewati objek Square daripada Rectangle. <br><br>  Tetapi jika kita melakukan ini, kita bisa melanggar <i>perilaku</i> kelas Rectangle: <br><br>  Misalnya, ada kode klien: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">client_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rect)</span></span></span><span class="hljs-function">:</span></span> rect.set_height(<span class="hljs-number"><span class="hljs-number">10</span></span>) rect.set_width(<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> rect.get_area() == <span class="hljs-number"><span class="hljs-number">200</span></span></code> </pre><br>  Jika Anda melewatkan instance dari kelas Square sebagai argumen untuk fungsi ini, fungsi tersebut akan berperilaku berbeda.  Yang merupakan pelanggaran kontrak untuk perilaku kelas Rectangle, karena tindakan dengan objek dari kelas dasar harus memberikan hasil yang persis sama dengan objek dari kelas turunan. <br><br>  Jika kelas kuadrat adalah turunan dari kelas persegi panjang, maka bekerja dengan kuadrat dan melakukan metode persegi panjang, kita bahkan tidak harus memperhatikan bahwa itu bukan persegi panjang. <br><br>  Anda dapat memperbaiki masalah ini, misalnya, seperti ini: <br><br><ol><li>  membuat pernyataan untuk mencocokkan kelas secara tepat, atau membuat jika itu akan bekerja secara berbeda untuk kelas yang berbeda </li><li>  di Square, buat metode set_size () dan timpa metode set_height, set_width sehingga mereka membuang pengecualian <br>  dll </li></ol><br>  Kode dan kelas semacam itu akan berfungsi, dalam arti bahwa kode tersebut akan berfungsi. <br><br>  Pertanyaan lain adalah bahwa kode klien yang menggunakan kelas Square atau kelas Rectangle perlu tahu baik tentang kelas dasar dan perilakunya, atau tentang kelas turunan dan perilakunya. <br><br>  Seiring waktu, kita bisa mendapatkan itu: <br><br><ul><li>  kelas turunan akan menimpa sebagian besar metode </li><li>  refactoring atau menambahkan metode ke kelas dasar akan memecah kode menggunakan keturunan </li><li>  dalam kode yang menggunakan objek dari kelas dasar akan ada seandainya, memeriksa kelas objek, dan perilaku untuk keturunan dan kelas dasar berbeda </li></ul><br>  Ternyata kode klien yang ditulis untuk kelas dasar menjadi tergantung pada implementasi kelas dasar dan kelas turunan.  Yang sangat mempersulit pengembangan seiring waktu.  Dan OOP dibuat agar Anda dapat mengedit kelas dasar dan kelas turunan secara independen satu sama lain. <br><br>  Kembali di tahun 80-an abad terakhir, kami memperhatikan bahwa agar warisan kelas berfungsi dengan baik untuk penggunaan kembali kode, kita harus tahu pasti bahwa kelas turunan dapat digunakan sebagai pengganti kelas dasar.  Yaitu  semantik warisan - ini seharusnya tidak hanya dan tidak banyak data sebagai perilaku.  Ahli waris tidak boleh "mematahkan" perilaku kelas dasar. <br><br>  Sebenarnya, ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prinsip substitusi Lisk</a> atau prinsip menentukan subtipe berdasarkan pada perilaku mengetik kelas yang kuat: <b>jika Anda dapat menulis setidaknya beberapa kode yang bermakna di mana mengganti objek kelas dasar dengan objek kelas turunan, itu akan pecah, maka itu tidak layak mewarisi mereka dari satu sama lain.</b>  Kita harus memperluas perilaku kelas dasar pada keturunan, dan tidak mengubahnya secara signifikan.  Fungsi yang menggunakan kelas dasar harus dapat menggunakan objek subclass tanpa menyadarinya.  Bahkan, ini adalah semantik warisan di OOP. <br><br>  Dan dalam kode industri nyata, sangat dianjurkan agar prinsip ini diikuti dan dipatuhi oleh semantik warisan yang dijelaskan.  Dan dengan prinsip ini ada beberapa kehalusan. <br><br>  <b>Prinsipnya harus dipenuhi bukan dengan abstraksi dari level domain, tetapi dengan abstraksi kode - kelas.</b>  Dari sudut pandang geometris, kotak adalah persegi panjang.  Dari sudut pandang hirarki warisan kelas, apakah kelas persegi akan menjadi pewaris kelas persegi panjang tergantung pada perilaku yang kita butuhkan dari kelas-kelas ini.  Bergantung pada bagaimana dan dalam situasi apa kita menggunakan kode ini. <br><br>  Jika kelas Rectangle hanya memiliki dua metode - menghitung area dan rendering, tanpa kemungkinan menggambar ulang dan mengubah ukuran, maka dalam kasus ini Square dengan konstruktor yang diganti akan memenuhi prinsip penggantian Liskov. <br><br>  Yaitu  kelas-kelas tersebut memenuhi prinsip substitusi: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_area</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Rectangle)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre><br>  Meskipun tentu saja ini bukan kode yang sangat baik, dan bahkan, mungkin, antipattern dari perancangan kelas, tetapi dari sudut pandang formal ia memenuhi prinsip Liskov. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh</a> lain.  Satu set adalah subtipe dari multiset.  Ini adalah rasio abstraksi domain.  Tetapi kode dapat ditulis sehingga kita mewarisi kelas Set dari Bag dan prinsip substitusi dilanggar, atau kita dapat menulis sehingga prinsip tersebut dihormati.  Dengan semantik domain subjek yang sama. <br><br>  Secara umum, pewarisan kelas dapat dianggap sebagai implementasi dari hubungan â€œISâ€, tetapi tidak antara entitas dari area subjek, tetapi antara kelas.  Dan apakah kelas turunan adalah subtipe dari kelas dasar ditentukan oleh batasan dan kontrak perilaku kelas apa yang digunakan kode klien (dan pada prinsipnya dapat digunakan). <br><br>  <b>Kendala, invarian, kontrak kelas dasar tidak diperbaiki dalam kode, tetapi diperbaiki di kepala pengembang yang mengedit dan membaca kode.</b>  Apa itu "melanggar", apa yang melanggar "kontrak" ditentukan bukan oleh kode, tetapi oleh semantik dari kelas di kepala pengembang. <br><br>  Kode apa pun yang bermakna untuk objek kelas dasar tidak boleh rusak jika kita menggantinya dengan objek kelas turunan.  Kode yang berarti adalah kode klien apa pun yang menggunakan objek kelas dasar (dan turunannya) dalam kerangka semantik dan batasan kelas dasar. <br><br>  Apa yang sangat penting untuk dipahami adalah bahwa keterbatasan abstraksi yang diterapkan di kelas dasar biasanya tidak terkandung dalam kode program.  Pembatasan ini dipahami, diketahui, dan didukung oleh pengembang.  Ini memantau konsistensi abstraksi dan kode.  Agar kode menyatakan apa artinya. <br><br>  Misalnya, persegi panjang memiliki metode lain yang mengembalikan tampilan dalam json <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_dict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-string"><span class="hljs-string">"height"</span></span>: self.height, <span class="hljs-string"><span class="hljs-string">"width"</span></span>: self.width}</code> </pre><br>  Dan di Square, kita mendefinisikan kembali: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Square</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_dict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-string"><span class="hljs-string">"size"</span></span>: self.height}</code> </pre><br>  Jika kita menganggap kontrak dasar untuk perilaku kelas Rectangle to_json memiliki tinggi dan lebar, maka kodenya <br><br><pre> <code class="python hljs">r = rect.to_dict() log(r[<span class="hljs-string"><span class="hljs-string">'height'</span></span>], r[<span class="hljs-string"><span class="hljs-string">'width'</span></span>])</code> </pre><br>  akan bermakna untuk objek Rectangle kelas dasar.  Saat mengganti objek kelas dasar dengan kelas, kode pewaris kuadrat mengubah perilakunya dan melanggar kontrak, dan dengan demikian melanggar prinsip substitusi Lisk. <br><br>  Jika kami percaya bahwa kontrak dasar untuk perilaku kelas Rectangle adalah to_dict mengembalikan kamus yang dapat diserialisasi tanpa meletakkan bidang tertentu, maka metode to_dict seperti itu akan baik-baik saja. <br><br>  Ngomong-ngomong, ini adalah contoh yang baik, menghancurkan mitos bahwa kekekalan menyelamatkan dari pelanggaran prinsip. <br><br>  Secara formal, pengubahan metode apa pun di kelas turunan berbahaya, juga perubahan logika di kelas dasar.  Sebagai contoh, cukup sering kelas turunan beradaptasi dengan perilaku "salah" dari kelas dasar, dan ketika bug diperbaiki di kelas dasar, mereka rusak. <br><br>  Dimungkinkan untuk mentransfer semua kondisi kontrak dan invarian ke kode sebanyak mungkin, tetapi dalam kasus umum, semantik perilaku semua berada di luar kode yang sama - di area masalah dan didukung oleh pengembang.  Contoh tentang to_dict adalah contoh di mana kontrak dapat dijelaskan dalam kode, tetapi misalnya, untuk memverifikasi bahwa metode get_hash benar-benar mengembalikan hash dengan semua properti hash, dan bukan hanya garis, tidak mungkin. <br><br>  Ketika seorang pengembang menggunakan kode yang ditulis oleh pengembang lain, ia dapat memahami apa semantik suatu kelas hanya secara langsung berdasarkan kode, nama metode, dokumentasi, dan komentar.  Tetapi bagaimanapun juga, semantik seringkali merupakan domain manusia, dan karenanya salah.  Konsekuensi yang paling penting: hanya dengan kode - secara sintaksis - apakah tidak mungkin untuk memverifikasi kepatuhan dengan prinsip Liskov, dan Anda perlu mengandalkan (sering) semantik yang tidak jelas.  Tidak ada cara formal (matematis) dari cara yang dapat diverifikasi dan dijamin untuk memverifikasi pengetikan perilaku yang kuat. <br><br>  Oleh karena itu, sering daripada prinsip Liskov, aturan formal untuk prasyarat dan postkondisi dari pemrograman kontrak digunakan: <br><br><ul><li>  prasyarat dalam subkelas tidak dapat diperkuat - subkelas seharusnya tidak memerlukan lebih dari kelas dasar </li><li>  postconditions dari subclass tidak dapat dilonggarkan - subclass tidak boleh memberikan (janji) kurang dari kelas dasar </li><li>  invarian dari kelas dasar harus dipertahankan dalam kelas turunan. </li></ul><br>  Misalnya, dalam metode kelas turunan, kami tidak dapat menambahkan parameter yang diperlukan yang tidak ada di kelas dasar - karena ini adalah cara kami memperkuat prasyarat.  Atau kita tidak bisa melempar pengecualian dalam metode yang diganti, karena  melanggar invarian kelas dasar.  Dll <br><br>  <b>Yang penting bukanlah perilaku kelas saat ini, tetapi perubahan kelas apa yang menyiratkan tanggung jawab atau semantik kelas.</b> <b><br></b> <br>  Kode ini terus diperbaiki dan diubah.  Karenanya, jika sekarang kode memenuhi prinsip substitusi, ini tidak berarti bahwa perubahan dalam kode tidak akan mengubah ini. <br><br>  Katakanlah ada pengembang kelas perpustakaan Rectangle, dan pengembang aplikasi yang mewarisi Square dari Rectangle.  Pada saat pengembang aplikasi mewarisi Square dari Rectangle - semuanya baik-baik saja, kelas memenuhi prinsip substitusi. <br><br>  Dan pada titik tertentu, pengembang yang bertanggung jawab atas perpustakaan menambahkan metode membentuk kembali atau set_width / set_height ke kelas dasar Rectangle.  Dari sudut pandangnya, perpanjangan kelas dasar baru saja terjadi.  Namun pada kenyataannya, ada perubahan dalam semantik dan kontrak yang menjadi sandaran kelas keturunan.  Sekarang kelas tidak lagi memenuhi prinsip. <br><br>  Secara umum, ketika mewarisi dalam OOP, perubahan di kelas dasar yang terlihat seperti perpanjangan antarmuka - metode atau bidang lain akan ditambahkan dapat melanggar kontrak "alami" sebelumnya, dan dengan demikian benar-benar mengubah semantik atau tanggung jawab.  Oleh karena itu, menambahkan metode apa pun ke kelas dasar berbahaya.  Anda dapat secara tidak sengaja mengubah kontrak. <br><br>  Dan dari sudut pandang praktis, dalam contoh dengan persegi panjang dan kelas, penting apakah sekarang ada membentuk kembali atau metode set_width / set_height.  Dari sudut pandang praktis, penting seberapa tinggi kemungkinan perubahan tersebut dalam kode perpustakaan.  Apakah semantik atau batasan tanggung jawab kelas menyiratkan perubahan tersebut.  Jika tersirat, maka kemungkinan kesalahan dan / atau kebutuhan lebih lanjut untuk refactoring meningkat secara signifikan.  Dan jika ada kemungkinan kecil, mungkin lebih baik untuk tidak mewarisi kelas-kelas tersebut dari satu sama lain. <br><br>  <b>Mempertahankan definisi subtipe berdasarkan perilaku sulit, bahkan untuk kelas sederhana dengan semantik yang jelas</b> , untuk mengatakan apa-apa tentang perusahaan dengan logika bisnis yang kompleks.  Terlepas dari kenyataan bahwa kelas dasar dan kelas pewaris adalah bagian kode yang berbeda, bagi mereka Anda perlu memikirkan antarmuka dan tanggung jawab dengan cermat dan hati-hati.  Dan bahkan dengan sedikit perubahan dalam semantik kelas - yang tidak dapat dihindari dengan cara apa pun, kita harus melihat kode kelas terkait, memeriksa untuk melihat apakah kontrak baru atau invarian melanggar apa yang sudah ditulis (!) Dan digunakan.  Dengan hampir semua perubahan dalam hierarki kelas bercabang, kita perlu melihat dan memeriksa banyak kode lainnya. <br><br>  Ini adalah salah satu alasan mengapa beberapa orang tidak begitu menyukai warisan klasik di OOP.  Dan karena itu, mereka sering memilih komposisi kelas, pewarisan antarmuka, dll., Dll.  bukannya warisan klasik perilaku. <br><br>  Dalam keadilan, ada beberapa aturan yang kemungkinan besar tidak melanggar prinsip substitusi.  Anda dapat melindungi diri sendiri sebanyak mungkin jika Anda melarang semua struktur berbahaya.  Misalnya, untuk C ++, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Oleg</a> menulis tentang ini.  Tetapi secara umum, aturan seperti itu tidak mengubah kelas menjadi kelas dalam arti klasik. <br><br>  Menggunakan metode administratif, tugasnya juga tidak diselesaikan dengan sangat baik.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini</a> Anda dapat membaca bagaimana Paman Martin melakukannya di C ++ dan bagaimana itu tidak berhasil. <br><br>  <b>Tetapi dalam kode industri yang sebenarnya, cukup sering, prinsip Liskov dilanggar, dan ini tidak menakutkan</b> .  Sulit untuk mengikuti prinsip, karena  1) tanggung jawab dan semantik suatu kelas sering tidak eksplisit dan tidak dinyatakan dalam kode 2) tanggung jawab kelas dapat berubah - baik di kelas dasar dan di kelas turunan.  Tetapi ini tidak selalu mengarah pada beberapa konsekuensi yang sangat mengerikan.  Pelanggaran yang paling umum, paling sederhana, dan paling mendasar adalah bahwa metode yang diganti mengubah perilaku.  Seperti pada contoh di sini: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.status = CLOSED ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProjectTask</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Task)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> status == STARTED: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Cannot close a started Project Task"</span></span>) ...</code> </pre><br>  Metode tutup ProjectTask akan mengeluarkan pengecualian dalam kasus di mana objek dari kelas Tugas berfungsi dengan baik.  Secara umum, redefinisi metode kelas dasar sangat sering mengarah pada pelanggaran prinsip substitusi, tetapi tidak menjadi masalah. <br><br>  Bahkan, dalam hal ini, pengembang menganggap warisan TIDAK sebagai implementasi dari hubungan "IS", tetapi hanya sebagai cara untuk menggunakan kembali kode.  Yaitu  subkelas hanyalah subkelas, bukan subtipe.  Dalam hal ini, dari sudut pandang pragmatis dan praktis, itu lebih penting - tetapi apa kemungkinan bahwa akan ada atau sudah ada kode klien yang akan melihat semantik berbeda dari metode kelas turunan dan kelas dasar? <br><br>  Apakah ada banyak kode yang mengharapkan objek dari kelas dasar, tetapi untuk itu kita meneruskan objek dari kelas turunan?  Untuk banyak tugas, kode seperti itu tidak akan pernah ada sama sekali. <br><br>  Kapan pelanggaran LSP menyebabkan masalah besar?  Ketika, karena perbedaan perilaku, kode klien harus ditulis ulang dengan perubahan di kelas turunan dan sebaliknya.  Ini menjadi masalah terutama jika kode klien ini adalah kode perpustakaan yang tidak dapat diubah.  Jika menggunakan kembali kode tidak akan dapat membuat dependensi antara kode klien dan kode kelas di masa depan, maka bahkan meskipun melanggar prinsip substitusi Liskov, kode seperti itu mungkin tidak menyebabkan masalah besar. <br><br>  Secara umum, selama pengembangan, pewarisan dapat dipertimbangkan dari dua perspektif: subclass adalah subtipe, dengan semua batasan pemrograman kontrak dan prinsip Lisk, dan subclass adalah cara untuk menggunakan kembali kode, dengan semua potensi masalahnya.  Yaitu  Anda dapat berpikir dan merancang tanggung jawab dan kontrak kelas dan tidak khawatir tentang kode klien.  Entah pikirkan tentang apa kode sisi klien, bagaimana kelas akan digunakan, dan bersiaplah untuk masalah potensial, tetapi pada tingkat yang lebih rendah peduli tentang mengamati prinsip substitusi.  Keputusan, seperti biasa, tergantung pada pengembang, yang paling penting adalah bahwa pilihan dalam situasi tertentu adalah sadar dan bahwa ada pemahaman tentang apa pro, kontra dan perangkap yang menyertai solusi ini atau itu. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463385/">https://habr.com/ru/post/id463385/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463367/index.html">Pembelajaran mesin dan teori kendala</a></li>
<li><a href="../id463369/index.html">Tentang layanan untuk janji dengan dokter</a></li>
<li><a href="../id463371/index.html">ITU di luar Moskow</a></li>
<li><a href="../id463373/index.html">Portofolio Desain UX: Praktik Terbaik</a></li>
<li><a href="../id463375/index.html">Anggur di Windows 10. Berhasil</a></li>
<li><a href="../id463387/index.html">Jalur QA Fighter</a></li>
<li><a href="../id463389/index.html">Personalisasi: cara kami bekerja dengan rekomendasi QIWI</a></li>
<li><a href="../id463391/index.html">Cara menikahi semua orang (pernikahan satu, dua, dan tiga jenis kelamin) dari sudut pandang matematika dan mengapa pria selalu menang</a></li>
<li><a href="../id463393/index.html">Apakah perusahaan Anda keluarga atau tim olahraga?</a></li>
<li><a href="../id463397/index.html">Pasar valuta asing dan rekayasa keuangan pada Abad Pertengahan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>