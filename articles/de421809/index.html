<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∞ üîÇ ü§ì Java EE Concurrency API üíÑ üåö ü•™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! 

 Und hier g√∂nnen wir uns Br√∂tchen und starten den zweiten Stream des Kurses "Java Enterprise Developer" . Der st√§ndige Sch√∂pfer un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Java EE Concurrency API</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/421809/"> Hallo allerseits! <br><br>  Und hier <s>g√∂nnen</s> wir uns <s>Br√∂tchen und</s> starten den zweiten Stream des Kurses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Java Enterprise Developer"</a> .  Der st√§ndige Sch√∂pfer und Lehrer des Kurses - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vitaly Ivanov</a> - hat sogar einen Artikel zu diesem Thema geschrieben, der Ihnen hoffentlich n√ºtzlich erscheinen wird :) <br><br>  Also lass uns gehen :) <br><br>  In diesem Artikel wird die JavaEE Concurrency Specification API ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JSR 236</a> ) erl√§utert, die den Standard f√ºr parallele Aufgaben in einem JavaEE-Container unter Verwendung des Konzepts verwalteter Ressourcen definiert.  Die Ver√∂ffentlichung der siebten Version von JavaEE erm√∂glichte die Ausf√ºhrung paralleler Aufgaben in Enterprise-Containern und bot dem Entwickler praktische Tools und Dienstprogramme f√ºr die Arbeit mit Multitasking.  Bis zu diesem Zeitpunkt war das gesamte Multitasking der spezifischen Implementierung des verwendeten Anwendungsservers √ºberlassen, der unabh√§ngig √ºber die Optimierung der Aufgaben entscheidet.  Verst√∂√üe gegen dieses Prinzip wurden als schlechte Praxis beim Aufbau der Architektur von Unternehmensanwendungen angesehen.  Infolgedessen wurde dem Entwickler nicht empfohlen, neue Threads zu erstellen, und manchmal war ein solches Verhalten auf Containerebene verboten. <br><br><img src="https://habrastorage.org/webt/k4/qq/by/k4qqbyksdbtsvyaceyok4sx3jgw.png"><a name="habracut"></a><br>  <i>Die Enterprise-Bean darf nicht versuchen, Threads zu verwalten.</i>  <i>Die Enterprise-Bean darf nicht versuchen, einen Thread zu starten, zu stoppen, anzuhalten oder fortzusetzen oder die Priorit√§t oder den Namen eines Threads zu √§ndern.</i>  <i>Die Enterprise-Bean darf nicht versuchen, Thread-Gruppen zu verwalten.</i> <br><br>  <i>(Kostenlose √úbersetzung des Autors: EJBs sollten nicht versuchen, Threads zu verwalten, dh versuchen, ihre Ausf√ºhrung zu starten, zu stoppen, anzuhalten und wiederherzustellen oder die Priorit√§t oder den Namen eines Threads zu √§ndern. Au√üerdem sollten EJBs nicht versuchen, Thread-Gruppen zu verwalten.)</i> <br><br>  Das Verbot der Erstellung eigener Threads in JavaEE-Containern ist zwar recht problematisch, bei diesem Ansatz k√∂nnen die Hintergrunddienste des Containers jedoch nicht die Richtigkeit ihrer Arbeit garantieren.  Beispielsweise kann das Schlie√üen einer Transaktion nach Abschluss der EJB-Methode m√∂glicherweise nicht ordnungsgem√§√ü funktionieren, wenn Aufgaben in einem neuen Thread mithilfe von Threads-Vererbungen (oder ausf√ºhrbaren Implementierungen) von JavaSE gestartet wurden.  Die Verwendung der von der Executor-API bereitgestellten grundlegenden Schnittstellentypen wie ExecutorService und ScheduledExecutorService w√ºrde beim Erstellen mit den statischen Methoden der Executors-Klasse zu potenziellen Fehlern f√ºhren und die Ausf√ºhrung von Containerdiensten st√∂ren. <br><br>  Von den in der JavaEE-Spezifikation empfohlenen Tools f√ºr die asynchrone Ausf√ºhrung von Aufgaben musste der Entwickler asynchrone zustandslose / Statefull-EJBs und / oder Message Driven Beans verwenden, deren Funktionen f√ºr einen bestimmten Aufgabenbereich ausreichen und deren Verwaltung zun√§chst vollst√§ndig und vollst√§ndig vom Anwendungsserver gesteuert wird. n√§mlich ein EJB-Container. <br><br>  Wie bereits erw√§hnt, sind dank <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JSR 236</a> Container-verwaltete Ressourcen erschienen, die Unterst√ºtzung f√ºr Multithreading und asynchrone Taskausf√ºhrung implementieren und die Funktionen des Pakets <code>java.util.concurrent</code> von JavaSE erweitern.  F√ºr den JavaEE-Stack befinden sich die verwalteten Ressourcenklassen im Paket <code>javax.enterprise.concurrent</code> , und der Zugriff auf die Objekte dieser Klassen erfolgt √ºber die Ressourceninjektion mithilfe der Annotation <code>@Resource</code> oder √ºber den JNDI-Kontext (insbesondere InitialContext).  Gleichzeitig wurde die M√∂glichkeit hinzugef√ºgt, Future / ScheduledFuture / CompletableFuture-Objekte zu verwenden, die in Umgebungen mit mehreren Threads in JavaEE-Anwendungen bekannt sind. <br><br>  Es gibt also gen√ºgend Texte und wir wollen uns die verwalteten Ressourcen, die in der Spezifikation bereitgestellt werden, aus praktischer Sicht genauer ansehen, und zwar im Zusammenhang mit der Verwendung der Anwendung im Anwendungscode sowie unter dem Gesichtspunkt der Ressourcenkonfiguration am Beispiel des Glassfish 5-Anwendungsservers. <br><br>  Nun, die ManagedExecutorService-Klasse war die erste, die in Betracht gezogen wurde. Sie erweitert (bereits aus dem Namen bekannt) die Funktionen des bekannten JavaSE ExecutorService und ist f√ºr die asynchrone Ausf√ºhrung von Aufgaben in der JavaEE-Umgebung ausgelegt. <br><br>  Um nicht nur diesen Typ von ExecutorService auf dem Glassfish-Anwendungsserver zu konfigurieren, sollten Sie auf die Konfigurationsdatei domain.xml verweisen, deren Speicherort durch das Verzeichnis $ {GLASSFISH_HOME} / domain / &lt;Dom√§nenname&gt; / config bestimmt wird.  Ein Fragment dieser Datei ist unten dargestellt: <br><br><pre> <code class="java hljs">&lt;domain application-root=<span class="hljs-string"><span class="hljs-string">"${com.sun.aas.instanceRoot}/applications"</span></span> version=<span class="hljs-string"><span class="hljs-string">"25"</span></span> log-root=<span class="hljs-string"><span class="hljs-string">"${com.sun.aas.instanceRoot}/logs"</span></span>&gt; &lt;resources&gt; &lt;context-service object-type=<span class="hljs-string"><span class="hljs-string">"system-all"</span></span> jndi-name=<span class="hljs-string"><span class="hljs-string">"concurrent/__defaultContextService"</span></span> /&gt; &lt;managed-executor-service object-type=<span class="hljs-string"><span class="hljs-string">"system-all"</span></span> jndi-name=<span class="hljs-string"><span class="hljs-string">"concurrent/__defaultManagedExecutorService"</span></span> /&gt; &lt;managed-scheduled-executor-service object-type=<span class="hljs-string"><span class="hljs-string">"system-all"</span></span> jndi-name=<span class="hljs-string"><span class="hljs-string">"concurrent/__defaultManagedScheduledExecutorService"</span></span> /&gt; &lt;managed-thread-factory object-type=<span class="hljs-string"><span class="hljs-string">"system-all"</span></span> jndi-name=<span class="hljs-string"><span class="hljs-string">"concurrent/__defaultManagedThreadFactory"</span></span> /&gt; &lt;/resources&gt; &lt;servers&gt; &lt;server config-ref=<span class="hljs-string"><span class="hljs-string">"server-config"</span></span> name=<span class="hljs-string"><span class="hljs-string">"server"</span></span>&gt; &lt;resource-ref ref=<span class="hljs-string"><span class="hljs-string">"concurrent/__defaultContextService"</span></span> /&gt; &lt;resource-ref ref=<span class="hljs-string"><span class="hljs-string">"concurrent/__defaultManagedExecutorService"</span></span> /&gt; &lt;resource-ref ref=<span class="hljs-string"><span class="hljs-string">"concurrent/__defaultManagedScheduledExecutorService"</span></span> /&gt; &lt;resource-ref ref=<span class="hljs-string"><span class="hljs-string">"concurrent/__defaultManagedThreadFactory"</span></span> /&gt; &lt;/server&gt; &lt;/servers&gt; &lt;/domain&gt;</code> </pre> <br>  Gehen Sie in die Benutzeroberfl√§che des Glassfish 5-Administrationsbereichs und konfigurieren Sie <br><br>  ManagedExecutorService lautet wie folgt: <br><br><img src="https://habrastorage.org/webt/ov/ik/wt/ovikwtidsmbgljlxmelboniomzy.png"><br><br>  Dieser Abschnitt erm√∂glicht das Erstellen neuer Ressourcen desselben Typs, das Verwalten vorhandener Ressourcen, das L√∂schen sowie das Sperren und Entsperren. <br><br>  F√ºr Fans der Konsolenverwaltung in Glassfish wird ein leistungsstarkes Dienstprogramm asadmin vorgestellt, mit dem Sie mithilfe des darin enthaltenen Befehls create-manage <code>create-managed-executor-service</code> neue ManagedExecutorService-Ressourcen erstellen k√∂nnen: <br><br><img src="https://habrastorage.org/webt/en/cp/nx/encpnxc2gn7fobfzuyhsgnw8jba.png"><br><br>  Im Anwendungscode ist es bequemer, die Ressourceninjektion zu verwenden, um einen Verweis auf das vom ManagedExecutorService erstellte Objekt abzurufen. Sie k√∂nnen jedoch auch die JNDI-Tools verwenden, wie unten gezeigt: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Resource</span></span>(lookup = <span class="hljs-string"><span class="hljs-string">"concurrent/OtusExecutorService"</span></span>) ManagedExecutorService executor; InitialContext context = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InitialContext(); ManagedExecutorService managedExecutorServiceWithContext = (ManagedExecutorService) context.lookup( <span class="hljs-string"><span class="hljs-string">"concurrent/OtusExecutorService"</span></span>);</code> </pre><br>  Ich m√∂chte den Leser darauf aufmerksam machen, dass der Lookup-Parameter f√ºr die <code>@Resource</code> Annotation optional ist. Wenn er vom Entwickler nicht im Anwendungscode definiert wird, <code>__default</code> der Container Standardressourcen mit dem Pr√§fix <code>__default</code> in ihrem <code>__default</code> .  In diesem Fall wird der Code f√ºr den Entwickler noch pr√§ziser: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ManagedExecutorService executor;</code> </pre> <br>  Nachdem Sie mit den Methoden execute <code>execute()</code> und submit <code>execute()</code> einen Verweis auf dieses Objekt erhalten haben, k√∂nnen Sie Aufgaben ausf√ºhren, die die Runnable- oder Callable-Schnittstelle im Container implementieren. <br><br>  An einem Beispiel m√∂chte ich festhalten, dass unter den vielen m√∂glichen F√§llen die interessantesten Aufgaben in einer verteilten JavaEE-Umgebung ausgef√ºhrt werden und es wichtig ist, Transaktionsunterst√ºtzung in einer Multithread-Umgebung bereitzustellen.  Wie Sie wissen, hat JavaEE die JTA-Spezifikation (Java Transaction API) entwickelt, mit der Sie die Grenzen einer Transaktion bestimmen k√∂nnen, indem Sie sie explizit mit der Methode <code>begin()</code> und mit <code>commit()</code> -Methoden enden, √Ñnderungen <code>rollback()</code> oder <code>rollback()</code> , mit der die ausgef√ºhrten Aktionen zur√ºckgesetzt werden. <br><br>  Stellen Sie sich eine Beispielaufgabe vor, die eine Nachricht aus einer Liste von einhundert Elementen nach Index in einer Benutzertransaktion zur√ºckgibt: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TransactionSupportCallableTask</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Callable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> messageIndex; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TransactionSupportCallableTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> messageId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>. messageIndex = messageId; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ UserTransaction tx = lookupUserTransaction(); String message = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { tx.begin(); message = getMessage(messageIndex); tx.commit(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { e.printStackTrace(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { tx.rollback(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e1) { e1.printStackTrace(); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> message; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> UserTransaction </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lookupUserTransaction</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ } }</code> </pre> <br>  Der Code f√ºr das Servlet, das eine Nachricht aus der Liste an einem zuf√§llig ausgew√§hlten Index anzeigt: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@WebServlet</span></span>(<span class="hljs-string"><span class="hljs-string">"/task"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ManagedExecutorServiceServlet</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpServlet</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span>(lookup = <span class="hljs-string"><span class="hljs-string">"concurrent/OtusExecutorService"</span></span>) ManagedExecutorService executor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doGet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ServletException, IOException </span></span>{ Future&lt;String&gt; futureResult = executor.submit(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TransactionSupportCallableTask(Random.nextInt(<span class="hljs-number"><span class="hljs-number">100</span></span>))); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!futureResult.isDone()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Thread.sleep(<span class="hljs-number"><span class="hljs-number">50</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { e.printStackTrace(); } } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { response.getWriter().write(<span class="hljs-string"><span class="hljs-string">"Callable task has received message with following content '"</span></span> + futureResult.get() + <span class="hljs-string"><span class="hljs-string">"'"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(Exception e) { e.printStackTrace(); } } }</code> </pre> <br>  Als n√§chstes ist die Ressource ManagedScheduledExecutorService zu ber√ºcksichtigen, deren Hauptzweck darin besteht, Aufgaben zu planen, die in regelm√§√üigen Abst√§nden wiederholt werden oder eine verz√∂gerte Ausf√ºhrung erfordern. <br><br><img src="https://habrastorage.org/webt/6t/85/k3/6t85k3th4xfxgvefxm9tahhxjus.png"><br><br>  Unter dem Gesichtspunkt der Konfiguration dieser Ressource √ºber die GlassFish-Administratorkonsole wurden im Vergleich zum vorherigen Typ keine besonderen √Ñnderungen festgestellt: <br><br><img src="https://habrastorage.org/webt/ks/jq/g6/ksjqg6dvumoskfqcclnkm2x6_lc.png"><br><br>  Um schnell eine Ressource vom Typ <code>asadmin</code> <code>create-managed-scheduled-executor-service</code> , verf√ºgt <code>asadmin</code> √ºber den Befehl <code>create-managed-scheduled-executor-service</code> <br><br><img src="https://habrastorage.org/webt/bd/zh/22/bdzh22mgi708cpcwtchliflffh4.png"><br><br>  Im Anwendungscode verwenden wir weiterhin die Ressourceninjektion: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Resource</span></span>(lookup = <span class="hljs-string"><span class="hljs-string">"concurrent/OtusScheduledExecutorService"</span></span>) ManagedScheduledExecutorService scheduledExecutor;</code> </pre> <br>  Die Hauptmethoden zum Ausf√ºhren von Aufgaben f√ºr diesen ExecutorService-Typ sind <code>schedule()</code> , das Aufgaben vom Typ Runnable oder Callable als Eingabe empf√§ngt, und <code>scheduleAtFixedRate()</code> , das zus√§tzlich die anf√§ngliche Verz√∂gerung in der Aufgabe bestimmt und das Wiederholungsintervall in TimeUnit (Sekunden, Minuten usw.) festlegt. .). <br><br>  Der vorherige Fall kann wie folgt umgeschrieben werden: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@WebServlet</span></span>(<span class="hljs-string"><span class="hljs-string">"/scheduledTask"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ManagedScheduledExecutorServiceServlet</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpServlet</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span>(lookup = <span class="hljs-string"><span class="hljs-string">"concurrent/OtusScheduledExecutorService"</span></span>) ManagedScheduledExecutorService scheduledExecutor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doGet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ServletException, IOException </span></span>{ ScheduledFuture&lt;String&gt; futureResult = scheduledExecutor.schedule( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TransactionSupportCallableTask(Random.nextInt(<span class="hljs-number"><span class="hljs-number">100</span></span>)), <span class="hljs-number"><span class="hljs-number">5</span></span>, TimeUnit.SECONDS); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!futureResult.isDone()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Thread.sleep(<span class="hljs-number"><span class="hljs-number">50</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Wait } catch (InterruptedException e) { e.printStackTrace(); } } try { response.getWriter().write("Callable task received message with following content '" + futureResult.get() + "'"); } catch ( Exception e) { e.printStackTrace(); } } }</span></span></code> </pre> <br>  Die Concurrency-API f√ºr die Enterpise-Umgebung bietet au√üerdem die M√∂glichkeit, kontrollierte Flows zu erstellen.  F√ºr diese Aufgaben sollten Sie die Funktionen einer verwalteten Thread-Factory verwenden, die ihre Funktionalit√§t √ºber die gleichnamige ManagedThreadFactory-Klasse implementiert und auf die auch √ºber den JNDI-Dienst zugegriffen wird: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ManagedThreadFactory factory;</code> </pre> <br>  Das Administrationsfenster f√ºr die Glassfish-Konsole sieht ‚Äûaltmodisch‚Äú aus: <br><br><img src="https://habrastorage.org/webt/c5/7n/dr/c57ndr_iu3zewecd6f_zte8vjsi.png"><br><br>  Mithilfe einer verwalteten Thread-Factory k√∂nnen Sie dem Container nicht nur Flusssteuerungsmechanismen zur Verf√ºgung stellen, sondern auch die Eigenschaften der generierten Threads initialisieren: Namen festlegen und Priorit√§ten setzen, was in Zukunft die Suche nach Problemen beim Parsen eines Thread-Dumps erheblich vereinfachen kann, indem die Ausf√ºhrungsreihenfolge zuvor benannter Threads leicht erkannt wird. <br><br>  In unserem Fall definieren wir die Klasse des Streams, die Informationen zu einem Freund anzeigt, mit dem diese Aufgabe untrennbar mit der Konsole verbunden ist: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleThreadTask</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String friend; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SimpleThreadTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String friend)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.friend = friend; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hello, "</span></span> + friend); } }</code> </pre> <br>  Lassen Sie das Servlet den Thread starten und melden Sie dies der Ausgabe: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@WebServlet</span></span>(<span class="hljs-string"><span class="hljs-string">"/thread"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ManagedThreadFactoryServlet</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpServlet</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ManagedThreadFactory factory; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doGet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ServletException, IOException </span></span>{ Thread thread = factory.newThread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleThreadTask(<span class="hljs-string"><span class="hljs-string">"Otus"</span></span>)); thread.setName(<span class="hljs-string"><span class="hljs-string">"ManagedThreadFromPool"</span></span>); thread.setPriority(<span class="hljs-number"><span class="hljs-number">7</span></span>); thread.start(); response.getWriter().write(<span class="hljs-string"><span class="hljs-string">"Custom thread has been running."</span></span>); } }</code> </pre><br>  In Bezug auf die letzte Funktion von JavaEE im Bereich Multithreading - Context Services sollte beachtet werden, dass diese Services dynamische kontextbezogene Proxy-Objekte erstellen.  Wir alle kennen die Funktionen dynamischer Proxys aus JavaSE ( <code>java.lang.reflect.Proxy</code> ), mit denen Sie eine dynamische Implementierung der erforderlichen Schnittstellen generieren k√∂nnen, deren Funktionen aktiv zum Erstellen von Datenbankverbindungen und zum Transaktionsmanagement verwendet werden und die f√ºr alle Arten von AOP-Interceptors usw. verwendet werden.  Dar√ºber hinaus wird f√ºr Proxys, die √ºber JavaEE-Kontextdienste erstellt wurden, angenommen, dass sie im Rahmen eines gemeinsamen JNDI-Kontexts, Sicherheitskontexts und einer gemeinsamen Containerklasse arbeiten k√∂nnen. <br><br>  Verwenden Sie zum Verbinden des Dienstes einfach den folgenden Code: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ContextService service;</code> </pre> <br>  Unter dem Gesichtspunkt der Verwaltung und Konfiguration dieser Ressource ist alles √§u√üerst vertraut und den bereits betrachteten Typen √§hnlich: <br><br><img src="https://habrastorage.org/webt/ql/n6/vw/qln6vwb5bbsk_e3sxner_vwjzsc.png"><br><br>  Unten sehen Sie ein Beispiel f√ºr einen Thread, der eine Proxy-Aufgabe im Kontext eines Containers startet: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SampleProxyTask</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  Subject subject = Subject.getSubject(AccessController.getContext()); logInfo(subject.getPrincipals()); //    calculateSmth(); } private void calculateSmth() { ‚Ä¶ } private void logInfo(Set&lt;Principal&gt; subject) { ‚Ä¶ } }</span></span></code> </pre> <br>  Zustandslose EJB-Bean zum Erstellen kontextbezogener Proxys: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Stateless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContextServiceBean</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ContextService service; <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ManagedExecutorService executor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Runnable task)</span></span></span><span class="hljs-function"> </span></span>{ Runnable proxy = service.createContextualProxy(task, Runnable.class); executor.submit(proxy); } }</code> </pre> <br>  Und schlie√ülich der Code f√ºr das Servlet, das die Aufgabe ausf√ºhrt: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@WebServlet</span></span>(<span class="hljs-string"><span class="hljs-string">"/context"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContextServiceServlet</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpServlet</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> ContextServiceBean contextServiceBean; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doGet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ServletException, IOException </span></span>{ contextServiceBean.perform(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SampleProxyTask()); } }</code> </pre> <br>  Dies beendet tats√§chlich die F√§higkeiten des JavaEE-Entwicklers, in einer Multithread-Umgebung zu arbeiten.  Dank ihnen unterliegen alle Prozesse und Dienste, die im Container stattfinden, der strengen Kontrolle des Servers, koordinieren ihre Arbeit und verletzen nicht die √ºbliche Ausf√ºhrungsreihenfolge.  F√ºr die Ziele des Enterprise-Entwicklers reichen diese Funktionen h√§ufig aus, und in der achten Version hat sich diese API nicht ge√§ndert. <br><br>  DAS ENDE <br><br>  Wie immer warten wir auf Fragen und Kommentare und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">besuchen</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vitaly</a> f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine offene Lektion</a> , in der er auch Fragen stellen und das Thema ‚ÄûCDI in Aktion @‚Äú anh√∂ren / daran teilnehmen kann. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de421809/">https://habr.com/ru/post/de421809/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de421799/index.html">Wie bekomme ich einen Job aus der Ferne in einem Unternehmen, in dem keine Remote-Mitarbeiter besch√§ftigt sind?</a></li>
<li><a href="../de421801/index.html">Der BetterSlack-Erweiterungsautor zieht es auf Antrag von Slack-Anw√§lten zur√ºck</a></li>
<li><a href="../de421803/index.html">USV und Batterie: Wo hinstellen? Ja warte auf dich</a></li>
<li><a href="../de421805/index.html">Eintauchen in die Entwicklung auf Ethereum. Teil 0: Keine Blockchain erforderlich</a></li>
<li><a href="../de421807/index.html">Nehmen Sie an den √∂ffentlichen Tests des Suchdienstes f√ºr Sicherheitsl√ºcken auf der Website von Positive Technologies teil</a></li>
<li><a href="../de421811/index.html">Die IETF hat einen neuen Standard f√ºr Messaging vorgeschlagen - was Sie wissen m√ºssen</a></li>
<li><a href="../de421815/index.html">Sechs Monate sp√§ter fl√ºssiges Metall in einem Laptop</a></li>
<li><a href="../de421817/index.html">Arbeiten mit Formularen in React.js mit grundlegenden Tools</a></li>
<li><a href="../de421819/index.html">ELK-Stapel zum Speichern von Django-Anwendungsprotokollen</a></li>
<li><a href="../de421821/index.html">Wir verwenden Voronois Mosaik-, Pixel- und geometrische Masken in Shadern, um die Site zu dekorieren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>