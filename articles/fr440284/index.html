<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍✈️ 🍓 👨🏻‍🏫 Un nouveau regard sur l'affichage des dialogues dans Android ♎️ 😋 👶🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'image montre la première pensée du lecteur qui se demande ce qui peut être écrit sur une tâche aussi simple que l'affichage d'un dialogue. Le manage...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un nouveau regard sur l'affichage des dialogues dans Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mobileup/blog/440284/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/cu/u9/xl/cuu9xl-sjrrfz5v4pqqh9hocnxo.png"></a> </p><br><p>  L'image montre la première pensée du lecteur qui se demande ce qui peut être écrit sur une tâche aussi simple que l'affichage d'un dialogue.  Le manager pense de la même manière: "Il n'y a rien de compliqué ici, notre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vasya</a> fera en 5 minutes."  Bien sûr, j'exagère, mais en réalité tout n'est pas aussi simple qu'il y paraît à première vue.  Surtout si nous parlons d'Android. </p><br><p>  Donc, 2019 était dans la cour et <strong>nous ne savons toujours pas comment afficher correctement les dialogues</strong> . </p><a name="habracut"></a><br><p>  Faisons-le dans l'ordre et commençons par l'énoncé du problème: </p><br><blockquote>  Il est nécessaire d'afficher un dialogue simple avec le texte pour confirmer l'action et les boutons «confirmer / annuler».  En cliquant sur le bouton «confirmer» - effectuer une action, par le bouton «annuler» - fermer la boîte de dialogue. </blockquote><br><h1 id="reshenie-v-lob">  Solution de front </h1><br><p>  J'appellerais cette méthode junior, car ce n'est pas la première fois que je rencontre un malentendu pourquoi vous ne pouvez pas simplement utiliser AlertDialog, comme indiqué ci-dessous: </p><br><pre><code class="kotlin hljs">AlertDialog.Builder(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .setMessage(<span class="hljs-string"><span class="hljs-string">"Please, confirm the action"</span></span>) .setPositiveButton(<span class="hljs-string"><span class="hljs-string">"Confirm"</span></span>) { dialog, which -&gt; <span class="hljs-comment"><span class="hljs-comment">// handle click } .setNegativeButton("Cancel", null) .create() .show()</span></span></code> </pre> <br><p>  Un moyen assez courant pour un développeur novice, il est évident et intuitif.  Mais, comme dans de nombreux cas lorsque vous travaillez avec Android, cette méthode est complètement fausse.  À l'improviste, nous obtenons une fuite de mémoire, il suffit de tourner l'appareil, et vous verrez l'erreur suivante dans les journaux: </p><br><div class="spoiler">  <b class="spoiler_title">stacktrace</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">E/WindowManager: android.view.WindowLeaked: Activity com.example.testdialog.MainActivity has leaked window DecorView@71b5789[MainActivity] that was originally added here at android.view.ViewRootImpl.&lt;init&gt;(ViewRootImpl.java:511) at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:346) at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:93) at android.app.Dialog.show(Dialog.java:329) at com.example.testdialog.MainActivity.onCreate(MainActivity.kt:27) at android.app.Activity.performCreate(Activity.java:7144) at android.app.Activity.performCreate(Activity.java:7135) at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1271) at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2931) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3086) at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:78) at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:108) at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:68) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1816) at android.os.Handler.dispatchMessage(Handler.java:106) at android.os.Looper.loop(Looper.java:193) at android.app.ActivityThread.main(ActivityThread.java:6718) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:493) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:858)</code> </pre></div></div><br><p>  Sur Stackoverflow, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">question</a> à ce sujet est l'une des plus populaires.  En bref, le problème est que nous affichons la boîte de dialogue ou ne fermons pas la boîte de dialogue une fois l'activation terminée. </p><br><p>  Vous pouvez, bien sûr, appeler le renvoi sur la boîte de dialogue dans l'activité onPause ou onDestroy, comme indiqué dans la réponse par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">référence</a> .  Mais ce n'est pas exactement ce dont nous avons besoin.  Nous voulons que le dialogue reprenne après avoir tourné l'appareil. </p><br><h1 id="ustarevshiy-sposob">  Manière obsolète </h1><br><p>  Avant que des fragments n'apparaissent dans Android, les dialogues auraient dû être affichés via un appel à la méthode d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">activation showDialog</a> .  Dans ce cas, l'activité gère correctement le cycle de vie du dialogue et le restaure après un tour.  La création du dialogue lui-même devait être implémentée dans le rappel onCreateDialog: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CONFIRMATION_DIALOG_ID = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... @Override protected Dialog onCreateDialog(int id, Bundle args) { if (id == CONFIRMATION_DIALOG_ID) { return new AlertDialog.Builder(this) .setMessage("Please, confirm the action") .setPositiveButton("Confirm", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { // handle click } }) .create(); } else { return super.onCreateDialog(id, args); } } }</span></span></code> </pre> <br><p>  Ce n'est pas très pratique que vous ayez à démarrer un identifiant de dialogue et à passer des paramètres via le Bundle.  Et nous pouvons toujours obtenir le problème de «fenêtre perdue» si nous essayons d'afficher une boîte de dialogue après avoir appelé onDestroy sur l'activité.  Cela est possible, par exemple, lorsque vous essayez d'afficher une erreur après une opération asynchrone. </p><br><p>  En général, ce problème est typique pour Android, lorsque vous devez faire quelque chose après une opération asynchrone et que l'activité ou le fragment est déjà détruit à ce moment.  C'est probablement pourquoi les modèles MV * sont plus populaires dans la communauté Android que parmi les développeurs iOS. </p><br><h1 id="sposob-iz-dokumentacii">  Méthode issue de la documentation </h1><br><p>  Des fragments sont apparus dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Android Honeycomb</a> , et la méthode décrite ci-dessus est déconseillée, et la méthode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">showDialog</a> de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">activité est</a> marquée comme déconseillée.  Non, AlertDialog n'est pas obsolète, car beaucoup se trompent.  Tout à l'heure, il y a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DialogFragment</a> , qui enveloppe l'objet de dialogue et contrôle son cycle de vie. </p><br><blockquote>  Les extraits natifs sont également obsolètes depuis l'API 28.  Maintenant, vous devez utiliser uniquement l'implémentation de la bibliothèque de support (AndroidX). </blockquote><p>  Accomplissons notre tâche, comme prescrit par la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation officielle</a> : </p><br><ol><li>  Vous devez d'abord hériter de DialogFragment et implémenter la création d'une boîte de dialogue dans la méthode onCreateDialog. </li><li>  Décrivez l'interface des événements de dialogue et instanciez l'écouteur dans la méthode onAttach. </li><li>  Implémentez une interface d'événement de dialogue dans une activité ou un fragment. </li></ol><br><blockquote>  Si le lecteur ne sait pas très bien pourquoi l'auditeur ne peut pas passer par le constructeur, il peut en savoir plus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> </blockquote><p>  Code de fragment de dialogue: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConfirmationDialogFragment</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DialogFragment</span></span></span></span>() { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConfirmationListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">confirmButtonClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancelButtonClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listener: ConfirmationListener <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAttach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Context</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onAttach(context) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Instantiate the ConfirmationListener so we can send events to the host listener = activity as ConfirmationListener } catch (e: ClassCastException) { // The activity doesn't implement the interface, throw exception throw ClassCastException(activity.toString() + " must implement ConfirmationListener") } } override fun onCreateDialog(savedInstanceState: Bundle?): Dialog { return AlertDialog.Builder(context!!) .setMessage("Please, confirm the action") .setPositiveButton("Confirm") { _, _ -&gt; listener.confirmButtonClicked() } .setNegativeButton("Cancel") { _, _ -&gt; listener.cancelButtonClicked() } .create() } }</span></span></code> </pre> <br><p>  Code d'activation: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span></span>(), ConfirmationListener { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showConfirmationDialog</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ConfirmationDialogFragment() .show(supportFragmentManager, <span class="hljs-string"><span class="hljs-string">"ConfirmationDialogFragmentTag"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">confirmButtonClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// handle click } override fun cancelButtonClicked() { // handle click } }</span></span></code> </pre> <br><p>  Assez de code s'est avéré, non? </p><br><p>  En règle générale, il existe une sorte de MVP dans le projet, mais j'ai décidé que les appels des présentateurs peuvent être omis dans ce cas.  Dans l'exemple ci-dessus, cela vaut la peine d'ajouter la méthode statique de création de la boîte de dialogue newInstance et de passer des paramètres aux arguments de fragment, le tout comme prévu. </p><br><p>  Et tout cela pour que le dialogue se cache dans le temps et se rétablisse correctement.  Il n'est pas surprenant que de telles questions se posent sur Stackoverflow: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deux</a> . </p><br><h1 id="poisk-idealnogo-resheniya">  Trouver la solution parfaite </h1><br><p>  La situation actuelle ne nous convenait pas et nous avons commencé à chercher un moyen de rendre le travail avec les dialogues plus confortable.  Il y avait un sentiment que vous pouvez le rendre plus facile, presque comme dans la première méthode. </p><br><p>  Voici les considérations qui nous ont guidés: </p><br><ul><li>  <strong>Dois-je enregistrer et restaurer la boîte de dialogue après avoir tué le processus de candidature?</strong> <br>  Dans la plupart des cas, cela n'est pas obligatoire, comme dans notre exemple, lorsque vous devez afficher un message simple ou demander quelque chose.  Un tel dialogue est pertinent jusqu'à ce que l'attention de l'utilisateur soit perdue.  Si vous le restaurez après une longue absence dans l'application, l'utilisateur perdra le contexte de l'action planifiée.  Par conséquent, il <strong>vous suffit de prendre en charge les tours de l'appareil</strong> et de gérer correctement le cycle de vie du dialogue.  Sinon, à cause du mouvement maladroit de l'appareil, l'utilisateur peut perdre le message qui vient d'être ouvert sans le lire. </li><li>  Lorsque vous utilisez DialogFragment, trop de code passe-partout apparaît, la simplicité est perdue.  Par conséquent, ce serait bien de se débarrasser du fragment comme wrapper et d' <strong>utiliser Dialog directement</strong> .  Pour ce faire, vous devrez enregistrer l'état de la boîte de dialogue afin de l'afficher à nouveau après avoir recréé la vue et la masquer lorsque la vue s'éteint. </li><li>  Tout le monde a l'habitude de percevoir l'affichage du dialogue en équipe, surtout si vous ne travaillez qu'avec MVP.  La tâche de la restauration ultérieure de l'état est assumée par le FragmentManager.  Mais vous pouvez regarder cette situation différemment et commencer à <strong>percevoir le dialogue comme un état</strong> .  C'est beaucoup plus pratique lorsque vous travaillez avec des modèles PM ou MVVM. </li><li>  Étant donné que la plupart des applications utilisent désormais des approches réactives, les <strong>dialogues doivent être réactifs</strong> .  La tâche principale n'est pas de briser la chaîne qui déclenche l'affichage du dialogue, et d'attacher un flux réactif d'événements pour en obtenir un résultat.  C'est très pratique du côté PresentationModel / ViewModel lorsque vous manipulez plusieurs flux de données. </li></ul><br><p>  Nous avons pris en compte toutes les exigences ci-dessus et avons trouvé un moyen d'afficher de manière réactive les dialogues, que nous avons mis en œuvre avec succès dans notre bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RxPM</a> (il y a un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> séparé à ce sujet). </p><br><p>  La solution elle-même ne nécessite pas de bibliothèque et peut être effectuée séparément.  Guidé par l'idée de «dialogue en tant qu'état», vous pouvez essayer de construire une solution basée sur le ViewModel et LiveData à la mode.  Mais je laisserai ce droit au lecteur, puis nous parlerons d'une solution toute faite de la bibliothèque. </p><br><h1 id="reaktivnyy-sposob">  Méthode réactive </h1><br><p>  Je vais montrer comment la tâche initiale est résolue dans RxPM, mais d'abord quelques mots sur les concepts clés de la bibliothèque: </p><br><ul><li>  <strong>PresentationModel</strong> - stocke un état de réaction, contient une logique d'interface utilisateur, survit aux virages. </li><li>  <strong>L'État</strong> est un <strong>état</strong> réactif.  Vous pouvez le considérer comme un wrapper sur BehaviorRelay. </li><li>  <strong>Action</strong> - un wrapper sur PublishRelay, sert à transférer des événements de View vers PresentationModel. </li><li>  <strong>État</strong> et <strong>action</strong> ont observable et consommateur. </li></ul><br><p>  La classe <a href="">DialogControl</a> est responsable de l'état de la boîte de dialogue.  Il a deux paramètres: le premier pour le type de données à afficher dans la boîte de dialogue, le second pour le type de résultat.  Dans notre exemple, le type de données sera Unit, mais il peut s'agir d'un message à l'utilisateur ou de tout autre type. </p><br><p>  DialogControl a les méthodes suivantes: </p><br><ul><li>  <code>show(data: T)</code> - donne juste une commande à afficher. </li><li>  <code>showForResult(data: T): Maybe&lt;R&gt;</code> - affiche une boîte de dialogue et ouvre le flux pour obtenir le résultat. </li><li>  <code>sendResult(result: R)</code> - envoie le résultat, est appelé du côté Affichage. </li><li>  <code>dismiss()</code> - masque simplement la boîte de dialogue. </li></ul><br><p>  DialogControl stocke l'état - y a-t-il un dialogue à l'écran ou non (affiché / absent).  Voici à quoi cela ressemble dans le code de classe: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DialogControl</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T, R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">internal</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>(pm: PresentationModel) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> displayed = pm.State&lt;Display&gt;(Absent) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = pm.Action&lt;R&gt;() <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Display</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Displayed</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt;</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: T) : Display() <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Absent : Display() } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Créez un modèle de présentation simple: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SamplePresentationModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PresentationModel</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConfirmationDialogResult</span></span></span><span class="hljs-class"> </span></span>{ CONFIRMED, CANCELED } <span class="hljs-comment"><span class="hljs-comment">//        enum    val confirmationDialog = dialogControl&lt;Unit, ConfirmationDialogResult&gt;() val buttonClicks = Action&lt;Unit&gt;() override fun onCreate() { super.onCreate() buttonClicks.observable .switchMapMaybe { //           confirmationDialog.showForResult(Unit) .filter { it == ConfirmationDialogResult.CONFIRMED } } .subscribe { //   } .untilDestroy() } }</span></span></code> </pre> <br><p>  Veuillez noter que le traitement des clics, la confirmation de la confirmation et le traitement des actions sont implémentés dans la même chaîne.  Cela vous permet de concentrer le code et de ne pas disperser la logique sur plusieurs rappels. </p><br><p>  Ensuite, nous lions simplement DialogControl à la vue à l'aide de l'extension bindTo. <br>  Nous collectons le AlertDialog habituel et envoyons le résultat via sendResult: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SampleActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PmSupportActivity</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SamplePresentationModel</span></span></span><span class="hljs-class">&gt;</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">providePresentationModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = SamplePresentationModel() <span class="hljs-comment"><span class="hljs-comment">//     View  PresentationModel override fun onBindPresentationModel(pm: SamplePresentationModel) { pm.confirmationDialog bindTo { data, dialogControl -&gt; AlertDialog.Builder(this@SampleActivity) .setMessage("Please, confirm the action") .setPositiveButton("Confirm") { _, _ -&gt; dialogControl.sendResult(CONFIRMED) } .setNegativeButton("Cancel") { _, _ -&gt; dialogControl.sendResult(CANCELED) } .create() } button.clicks() bindTo pm.buttonClicks } }</span></span></code> </pre> <br><p>  Dans un scénario typique, quelque chose comme ça se passe sous le capot: </p><br><ol><li>  Nous cliquons sur le bouton, l'événement à travers l'action "buttonClicks" entre dans le PresentationModel. </li><li>  Pour cet événement, nous lançons l'affichage de la boîte de dialogue via l'appel à showForResult. </li><li>  Par conséquent, l'état dans DialogControl passe d'Absent à Displayed. </li><li>  Lorsque l'événement affiché est reçu, le lambda que nous avons transmis dans la liaison bindTo est appelé.  Un objet de dialogue y est créé, qui s'affiche ensuite. </li><li>  L'utilisateur appuie sur le bouton Confirmer, l'écouteur se déclenche et le résultat du clic est envoyé à DialogControl en appelant sendResult. </li><li>  Ensuite, le résultat tombe dans le «résultat» de l'action interne et l'état de Affiché passe à Absent. </li><li>  Lorsqu'un événement absent est reçu, la boîte de dialogue actuelle se ferme. </li><li>  L'événement du «résultat» de l'action tombe dans le flux qui a été ouvert par l'appel à showForResult et est traité par la chaîne dans PresentationModel. </li></ol><br><p>  Il convient de noter que la boîte de dialogue se ferme même lorsque View est détaché de PresentationModel.  Dans ce cas, le statut reste affiché.  Il sera reçu lors de la prochaine reliure et le dialogue sera rétabli. </p><br><p>  Comme vous pouvez le voir, le besoin de DialogFragment a disparu.  La boîte de dialogue s'affiche lorsque la vue est attachée au modèle de présentation et est masquée lorsque la vue est déliée.  En raison du fait que l'état est stocké dans DialogControl, qui à son tour est stocké dans PresentationModel, la boîte de dialogue est restaurée après la rotation de l'appareil. </p><br><h1 id="pishite-dialogi-pravilno">  Ecrire correctement les dialogues </h1><br><p>  Nous avons examiné plusieurs façons d'afficher les boîtes de dialogue.  Si vous montrez toujours de la première manière, alors je vous en prie, ne le faites plus.  Pour les amateurs de MVP, il ne reste plus qu'à utiliser la méthode standard, qui est décrite dans la documentation officielle.  Malheureusement, la tendance à l'impérativité de ce schéma ne permet pas de faire autrement.  Eh bien, je recommande aux fans de RxJava de regarder de plus près la méthode réactive et notre bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RxPM</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr440284/">https://habr.com/ru/post/fr440284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr440274/index.html">Création d'un service de devise privé à l'aide d'Exonum</a></li>
<li><a href="../fr440276/index.html">Débogage frontal et principal</a></li>
<li><a href="../fr440278/index.html">Passer Tinder à Kubernetes</a></li>
<li><a href="../fr440280/index.html">Examen du logiciel libre Android</a></li>
<li><a href="../fr440282/index.html">Les frameworks Web Python les plus rapides en 2019</a></li>
<li><a href="../fr440286/index.html">Bruit Perlin, génération de contenu procédural et espace intéressant</a></li>
<li><a href="../fr440288/index.html">Sécurité IoT. Numéro 1. Montres intelligentes, trackers de fitness et balances</a></li>
<li><a href="../fr440292/index.html">Le livre «L'unité en action. Développement multiplateforme en C #. 2e int. édition »</a></li>
<li><a href="../fr440294/index.html">Routeur MIDI sur Raspberry Pi</a></li>
<li><a href="../fr440296/index.html">6 Applications pour l'IoT industriel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>