<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñ•Ô∏è üëï üßñüèæ PHP y expresiones regulares: lo b√°sico para principiantes ‚öΩÔ∏è üêû üò™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En previsi√≥n del inicio de un nuevo hilo en el curso "Backend-developer in PHP" , as√≠ como el curso relacionado "Framework Laravel" , queremos compart...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PHP y expresiones regulares: lo b√°sico para principiantes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/484048/">  <i>En previsi√≥n del inicio de un nuevo hilo en el curso <a href="https://otus.pw/vMHA/">"Backend-developer in PHP"</a> , as√≠ como el curso relacionado <a href="https://otus.pw/vS2d/">"Framework Laravel"</a> , queremos compartir el art√≠culo preparado por nuestro autor independiente.</i> <i><br><br></i>  <i><b>Atencion</b></i>  <i>Este art√≠culo <b>no</b> es <b>relevante para el programa del curso</b> y ser√° √∫til <b>solo para principiantes</b> .</i>  <i>Para obtener un conocimiento m√°s profundo, lo invitamos a visitar un <b><a href="https://otus.pw/vMHA/">intensivo en l√≠nea gratuito de dos d√≠as sobre el tema: "Crear un Telegram-bot para ordenar caf√© en la instituci√≥n y pagar en l√≠nea"</a></b> .</i>  <i>El segundo d√≠a de intenso se llevar√° a cabo <a href="https://otus.pw/cl2i/">aqu√≠</a> .</i> <i><br></i> <br><img src="https://habrastorage.org/webt/94/4h/6y/944h6y1qgyysdz1bigypwmh2kgc.png"><br><hr><br>  Hola a todos!  Todo con el pr√≥ximo <code>[20]{2,}0</code> a√±os.  Hoy quiero tocar un tema que a veces es un tema para bromas de "¬øPor qu√© necesitas aprender todo esto si ya tienes soluciones preparadas" para "¬øtambi√©n puedes aprender todo sobre Perl?"  Sin embargo, pasa el tiempo, muchos programadores comienzan a dominar las expresiones regulares, y en Habr√© no hay un solo art√≠culo nuevo ( <i>aunque las expresiones regulares no hayan cambiado mucho √∫ltimamente</i> ) sobre este tema.  ¬°Es hora de escribir otro! <br><a name="habracut"></a><br><br><h3>  Expresiones regulares aisladas de su implementaci√≥n espec√≠fica </h3><br>  Las expresiones regulares (denotadas en ingl√©s como <i>RegEx</i> o como expresiones regulares) son una herramienta que se utiliza para varias opciones para estudiar y procesar texto: buscar, verificar, buscar y reemplazar un elemento que consiste en letras o n√∫meros (o cualquier otro car√°cter en incluidos caracteres especiales y caracteres de puntuaci√≥n).  Inicialmente, las expresiones regulares llegaron al mundo de la programaci√≥n desde el entorno de la investigaci√≥n cient√≠fica, que se llev√≥ a cabo en los a√±os 50 en el campo de las matem√°ticas. <br><br>  D√©cadas m√°s tarde, los principios e ideas se transfirieron al entorno del sistema operativo UNIX (en particular, se incluyeron en la utilidad <code>grep</code> ) y se implementaron en el lenguaje de programaci√≥n Perl, que en los albores de Internet se usaba ampliamente en el backend (y hasta el d√≠a de hoy se usa, pero ya menos) para dicha tarea. como la validaci√≥n de formularios. <br><br><img src="https://habrastorage.org/webt/qc/ar/2n/qcar2n7t2d3mfadvtvfhnapw8by.png"><br><br><h5>  Si parecen ser simples, ¬øpor qu√© dan tanto miedo a primera vista? </h5><br>  De hecho, cualquier expresi√≥n puede ser "regular" y puede usarse para verificar o buscar cualquier car√°cter.  Por ejemplo, las palabras <em>Pavel</em> o <em>example@mail.ru</em> tambi√©n se pueden usar como clientes habituales, solo, por supuesto, en una clave bastante estrecha.  Para probar el rendimiento de las expresiones regulares en el entorno PHP sin iniciar su servidor o alojamiento, puede usar el siguiente <a href="https://regex101.com/">servicio en</a> l√≠nea (simplemente no funciona con el procesamiento de caracteres rusos en √©l).  Para empezar, solo usamos <em>Pavel</em> como una expresi√≥n regular. <br><br>  Supongamos que tenemos el siguiente texto: <br><br>  <b>Pavel</b> sabe demasiado.  <b>Pavel</b> usando nginx y √©l no es divagante. <br><br>  Ahora las expresiones regulares han encontrado ambas ocurrencias de la palabra Pavel.  Es genial, pero no suena muy √∫til (a menos que por alguna raz√≥n intentes analizar algo como la cantidad de menci√≥n de la palabra <b>se√±or</b> en War and Peace a trav√©s de Vim y Python, pero no tengo preguntas para ti). <br><br><h5>  Variabilidad de expresi√≥n </h5><br>  Si su expresi√≥n regular es variable (por ejemplo, solo conoce una cierta parte de ella y necesita encontrar el n√∫mero de ocurrencias de a√±os, comenzando desde 2000 y terminando en 2099), entonces podemos usar la siguiente expresi√≥n regular: <em>20 ..</em> <br><br>  <i>Texto: Los escritores j√≥venes escriben muchas cosas.</i>  <i>Por ejemplo, un escritor nacido en <b>2002 es</b> muy diferente de <b>2008</b> y <b>2012.</b></i> <br><br>  Aqu√≠, con la ayuda de expresiones regulares, podemos encontrar todos los a√±os, pero hasta ahora esto no tiene sentido.  Lo m√°s probable es que no necesitemos a√±os m√°s all√° de 2012 (aunque los escritores j√≥venes menores de 8 a√±os pueden ofenderse, pero no por eso ahora).  Vale la pena estudiar conjuntos de caracteres, pero m√°s sobre eso m√°s adelante, porque ahora hablaremos de otra parte importante de las expresiones regulares: escapar de metacaracteres. <br><br>  Imagine que necesitamos encontrar el n√∫mero de ocurrencias de archivos con la extensi√≥n <code>.doc</code> (supongamos que exportamos solo ciertos archivos cargados a nuestra base de datos).  ¬øPero un punto simplemente significa alg√∫n personaje?  Entonces que hacer? <br>  Aqu√≠, escapar de metacaracteres con una barra diagonal inversa nos ayuda.  Ahora la expresi√≥n <code>\.doc</code> tendr√° el √©xito suficiente para buscar cualquier menci√≥n de texto con la extensi√≥n <code>.doc</code> : <br><br>  Expresi√≥n regular: <code>\.doc</code> <br><br>  Texto: kursach <b>.doc</b> , <code>nepodozritelneyfail.exe</code> , work <b>.doc</b> , <code>shaprgalka.rtf doc</code> <br><br>  Como puede ver, podemos encontrar con √©xito la cantidad de archivos con la extensi√≥n <code>.doc</code> en la lista.  Sin embargo, no podemos extraer los nombres de archivo completos usando esta expresi√≥n regular, por ejemplo, en una matriz.  Es hora de echar un vistazo a los conjuntos de caracteres. <br><br><h5>  Une todo un conjunto de personajes </h5><br>  En expresiones regulares, la coincidencia con un conjunto se proporciona mediante metacaracteres: corchetes <code>[ ]</code> .  Se pueden especificar dos caracteres ASII como el inicio y el final de un rango.  Para una implementaci√≥n simple, supongamos que queremos encontrar todos los archivos numerados del 0 al 9 con la extensi√≥n <code>.jpg</code> . <br><br>  Expresi√≥n regular: <code>[0-9]\.jpg</code> <br><br>  Texto: <b>1.jpg</b> , <b>2.jpg</b> , <b>3.jpg</b> , photo.jpg, anime.jpg, <b>8.jpg</b> , jkl.jpg <br><br>  Vale la pena se√±alar que el nombre de archivo de m√°s de 1 d√≠gitos no estar√° cubierto por nuestra expresi√≥n regular.  Acerca de la opci√≥n m√∫ltiple ser√° un poco menor, pero por ahora imagine que de repente necesit√°bamos lograr el resultado opuesto.  Agregue el metacar√°cter <code>^</code> (que, por el contrario, tiene hasta dos funciones en expresiones regulares).  Para usarlo como una excepci√≥n, debe agregarlo exactamente a nuestro conjunto: <br><br>  Expresi√≥n regular: <code>[^0-9]\.jpg</code> <br><br>  Texto: 1.jpg, 2.jpg, 3.jpg, phot <b>o.jpg</b> , anim <b>e.jpg</b> , 8.jpg, jk <b>l.jpg</b> <br><br>  Pero sin opci√≥n m√∫ltiple, estas son, por supuesto, expresiones inferiores. <br><br><h5>  Tablas utiles </h5><br>  Aqu√≠ hay una tabla de metacaracteres: <br><br><div class="scrollable-table"><table><tbody><tr><td>  \ </td><td>  escapar del metacar√°cter como personaje regular </td></tr><tr><td>  ^ </td><td>  buscar un car√°cter espec√≠fico al comienzo de la l√≠nea (pero solo si lo excluye del conjunto []) </td></tr><tr><td>  $ $ </td><td>  fin de l√≠nea </td></tr><tr><td>  El | </td><td>  alternativa </td></tr><tr><td>  () </td><td>  agrupaci√≥n </td></tr><tr><td>  \ w </td><td>  todos los caracteres alfanum√©ricos (por alguna raz√≥n, muchos manuales no est√°n de acuerdo con los caracteres digitales) </td></tr><tr><td>  \ W </td><td>  lo mismo, todo lo contrario </td></tr><tr><td>  \ s </td><td>  cualquier espacio en blanco </td></tr><tr><td>  \ S </td><td>  cualquier espacio en blanco NO </td></tr></tbody></table></div><br><br>  Tabla de metacaracteres de espacios en blanco <br><div class="scrollable-table"><table><tbody><tr><td>  [\ b] </td><td>  retorno de un solo personaje </td></tr><tr><td>  \ f </td><td>  traducci√≥n de p√°ginas </td></tr><tr><td>  \ n </td><td>  avance de l√≠nea </td></tr><tr><td>  \ r </td><td>  retorno de carro </td></tr><tr><td>  \ t </td><td>  tabulaci√≥n </td></tr><tr><td>  \ v </td><td>  pesta√±a vertical </td></tr></tbody></table></div><br><br><h3>  Opci√≥n m√∫ltiple: hacer una validaci√≥n simple </h3><br>  Armados con el conocimiento adquirido, intentaremos hacer una expresi√≥n regular que encuentre, por ejemplo, palabras de menos de 3 letras (una tarea est√°ndar para anti-spam).  Si tratamos de usar la siguiente expresi√≥n regular - <code>\w{1,3}</code> (en la cual el metacar√°cter <code>\w</code> indica cualquier car√°cter, y los corchetes indican el n√∫mero de caracteres de cu√°ntos a cu√°ntos, entonces resaltaremos todos los caracteres en una fila; debe designar de alguna manera principio y final de las palabras en el texto, para esto necesitamos el metacar√°cter <code>\b</code> . <br><br>  Expresi√≥n regular: <code>\b\w{1,3}\b:</code> <br><br>  Texto: buena palabra <br>  <b>no</b> <br>  <b>huevo</b> <br><br>  No esta mal!  Ahora las palabras de menos de tres letras no podr√°n ingresar a nuestra base de datos.  Veamos la validaci√≥n de la direcci√≥n postal: <br><br>  Expresi√≥n regular: <code>\w+@\w+\.\w+</code> <br><br>  Requisitos: en el correo electr√≥nico al principio debe haber cualquier car√°cter (n√∫meros o letras, porque el correo electr√≥nico, que consiste solo en n√∫meros al principio, es bastante com√∫n).  Luego viene el s√≠mbolo <code>@</code> , luego tantos caracteres como desee, seguido de un punto escapado (es decir, solo un punto) y un dominio de primer nivel. <br><br><h5>  Considera la repetici√≥n de personajes </h5><br>  Ahora echemos un vistazo m√°s de cerca a c√≥mo repetir caracteres en expresiones regulares.  Por ejemplo, desea encontrar cualquier combinaci√≥n de n√∫meros del 2 al 6 en el texto: <br><br>  Expresi√≥n regular: <code>[2-6]+</code> <br><br>  Texto: Aqu√≠ est√°n los 89 diferentes <b>234</b> d√≠gitos <b>de</b> Come <b>24</b> . <br><br>  D√©jame darte una tabla de todos los cuantificadores de metacaracteres: <br><br><div class="scrollable-table"><table><tbody><tr><td>  * * </td><td>  los caracteres repiten 0 y hasta el infinito </td></tr><tr><td>  + </td><td>  repetido del 1 al infinito </td></tr><tr><td>  {n} </td><td>  repetir exactamente n veces </td></tr><tr><td>  {n,} </td><td>  de n al infinito </td></tr><tr><td>  {n1, n2} </td><td>  de n1 a n2 veces exactamente </td></tr><tr><td>  ? </td><td>  0 o 1 personaje, no m√°s </td></tr></tbody></table></div><br><br>  No hay nada complicado en aplicar cuantificadores.  Excepto por una advertencia: cuantificadores codiciosos y perezosos.  Aqu√≠ est√° la tabla: <br><br><div class="scrollable-table"><table><tbody><tr><td>  * * </td><td>  *? </td></tr><tr><td>  + </td><td>  +? </td></tr><tr><td>  {n,} </td><td>  {n,}? </td></tr></tbody></table></div><br><br>  Los cuantificadores perezosos difieren de los codiciosos en que toman el n√∫mero m√≠nimo, no el m√°ximo, de caracteres.  Imagine que tenemos la tarea de encontrar todas las etiquetas de encabezado h1-h6 y su contenido, y el resto del texto no deber√≠a verse afectado (ingres√© deliberadamente la etiqueta h7 inexistente para no ser atormentado por escapar de las etiquetas Habra): <br><br>  Expresi√≥n regular: &lt;h [1-7]&gt;. *? &lt;\ / H [1-7]&gt; <br><br>  Texto: <b><code>&lt;</code> <code>h7</code> <code>&gt;</code> hola <code>&lt;/</code> <code>h7</code> <code>&gt;</code></b> lorem ipsum avada kedavra <b><code>&lt;</code> <code>h7</code> &gt; comprar <code>&lt;</code> <code>/h7</code> <code>&gt;</code></b> <br><br>  Todo funcion√≥ con √©xito, pero solo gracias al cuantificador diferido.  En el caso de usar el cuantificador codicioso, todo el texto entre las etiquetas se destacar√≠a (creo que esto no necesita una ilustraci√≥n). <br><br><h5>  Bordes de cadena de caracteres </h5><br>  Los l√≠mites de las cadenas de caracteres que ya hemos usado anteriormente.  Aqu√≠ hay una tabla m√°s detallada: <br><br><div class="scrollable-table"><table><tbody><tr><td>  \ b </td><td>  l√≠mite de palabras </td></tr><tr><td>  \ B </td><td>  no l√≠mite de palabra </td></tr><tr><td>  \ A </td><td>  comienzo de l√≠nea </td></tr><tr><td>  \ Z </td><td>  fin de l√≠nea </td></tr><tr><td>  \ G </td><td>  fin de la acci√≥n </td></tr></tbody></table></div><br><br><h5>  Trabajar con subexpresiones </h5><br>  Las subexpresiones en expresiones regulares se realizan utilizando el metacaracteres del grupo <code>()</code> . <br>  Aqu√≠ hay un ejemplo de una expresi√≥n regular que puede encontrar universalmente diversas variaciones de direcciones IP. <br><br>  Expresi√≥n regular: (((25 [0-5]) | (2 [0-4] \ d) | (1 \ d {2}) | (\ d {1,2})) \.) {3} (((25 [0-5] | (2 [0-4] \ d) | (1 \ d {2}) | (\ d {1,2})))) <br><br>  Texto: <b>255.255.255.255 es</b> solo una direcci√≥n <br>  <b>191.198.174.192</b> wikipedia <br>  <b>87.240.190.67</b> vk <br>  <b>31.13.72.36</b> facebook <br><br>  Utiliza el operador l√≥gico <code>|</code>  (o) que nos permite componer una expresi√≥n regular que coincida con la regla por la cual se compilan las direcciones IP.  La direcci√≥n IP debe contener de 1 a 3 d√≠gitos, en los cuales un n√∫mero de tres n√∫meros puede comenzar con 1, con 2 (o el segundo d√≠gito debe estar entre 0 y 4), o comenzar con 25, y luego 3 d√≠gitos resulta estar entre 0 y 5. Adem√°s, debe haber un punto entre cada combinaci√≥n de n√∫meros.  Usando las tablas anteriores, intente descifrar la expresi√≥n regular en la parte superior.  Las expresiones regulares al principio te asustan con su largo, pero largo no significa complejo. <br><br><h5>  Mirar hacia adelante </h5><br>  Para ver una expresi√≥n para cualquier combinaci√≥n de ciertos caracteres, se indica un patr√≥n mediante el cual se detecta una coincidencia, pero no se devuelve.  Esencialmente, mirar hacia adelante define una subexpresi√≥n y, por lo tanto, se forma en consecuencia.  El patr√≥n de sintaxis para mirar hacia adelante consiste en una subexpresi√≥n precedida por? =, Y luego el texto que se va a hacer coincidir se sigue por igual. <br><br>  Aqu√≠ hay una tarea espec√≠fica: hay una contrase√±a que debe constar de al menos 7 caracteres y debe incluir necesariamente al menos una letra may√∫scula y un n√∫mero.  Aqu√≠ todo ser√° algo m√°s complicado, porque el usuario deber√≠a poder poner la letra may√∫scula tanto al principio como en el medio de la oraci√≥n (y lo mismo deber√≠a repetirse con la letra). <br><br>  Por lo tanto, debemos esperar la expresi√≥n.  Adem√°s, necesitamos dividir los signos en grupos.  Y quiero limitar sus tama√±os de 8 a 22 caracteres: <br><br>  <code>/^(?=.*[az])(?=.*[AZ])(?=.*\d)[a-zA-Z\d]{8,}$/</code> : <br><br>  Texto: <b>Qwerty123</b> <br>  <b>Im789098</b> <br>  contrase√±a d√©bil <br><br><h3>  Caracter√≠sticas del trabajo de expresiones regulares en PHP </h3><br>  Para saber c√≥mo funcionan las expresiones regulares en PHP, consulte las funciones en la documentaci√≥n oficial de PCRE (Expresiones regulares compatibles con Perl), que est√° disponible en el sitio web oficial.  La expresi√≥n debe estar encerrada en delimitadores, por ejemplo, en barras diagonales. <br><br>  Los caracteres arbitrarios pueden ser un delimitador, excepto alfanum√©ricos, barra invertida '\' y cero byte.  Si el car√°cter delimitador aparece en el patr√≥n, se debe escapar \.  Como separadores, las combinaciones provienen de Perl: (), {}, []. <br><br>  ¬øQu√© funciones se usan en php?  El paquete PCRE proporciona las siguientes caracter√≠sticas para admitir expresiones regulares: <br><br><ul><li>  <em>preg_grep ()</em> : realiza una b√∫squeda y devuelve una matriz de coincidencias. </li><li>  <em>preg_match ()</em> : busca la primera coincidencia utilizando expresiones regulares </li><li>  <em>preg_match_all ()</em> - Realiza una b√∫squeda global usando expresiones regulares </li><li>  <em>preg_quote ()</em> - toma una plantilla y devuelve su versi√≥n escapada </li><li>  <em>preg_replace ()</em> - realiza una operaci√≥n de b√∫squeda y reemplazo </li><li>  <em>preg_replace_callback ()</em> : tambi√©n realiza una operaci√≥n de b√∫squeda y reemplazo, pero utilizan la devoluci√≥n de llamada, una funci√≥n para cualquier reemplazo espec√≠fico </li><li>  <em>preg_split ()</em> - divide una cadena de caracteres en subcadenas </li></ul><br><br>  El modificador <code>i</code> para organizar coincidencias sin distinci√≥n entre may√∫sculas y min√∫sculas. <br>  Usando el modificador <code>m</code> , puede activar el modo de procesamiento de texto multil√≠nea. <br><br>  El reemplazo de cadenas se puede calcular como c√≥digo PHP.  Para activar este modo, use el modificador <em>e</em> . <br><br>  Todas las <code>preg_split()</code> <code>preg_replace()</code> , <code>preg_replace_callback()</code> y <code>preg_split()</code> admiten un argumento adicional, que introduce restricciones en el n√∫mero m√°ximo de reemplazos o particiones. <br><br>  Los v√≠nculos de retroceso se pueden indicar con el signo $ (por ejemplo, $ 1), y en versiones anteriores, se usan los signos \\ en lugar del signo $. <br>  Los metacaracteres \ E, \ l, \ L, \ u y \ U no se utilizan (por lo tanto, no se mencionaron en este art√≠culo). <br><br>  Nuestro art√≠culo estar√≠a incompleto sin las clases de caracteres POSIX, que tambi√©n funcionan en PHP (y en general pueden aumentar la legibilidad de sus clientes habituales, pero no todos tienen prisa por aprender, porque a menudo rompen la l√≥gica de la expresi√≥n). <br><br><div class="scrollable-table"><table><tbody><tr><td>  [[: alnum:]] </td><td>  Cualquier letra del alfabeto o n√∫mero en ingl√©s. </td></tr><tr><td>  [[: alfa:]] </td><td>  Cualquier letra ([a-zA-Z]) </td></tr><tr><td>  [[: en blanco:]] </td><td>  Espacio en blanco o c√≥digo de caracteres 0 y 255 </td></tr><tr><td>  [[: d√≠gito:]] </td><td>  Cualquier d√≠gito ([0-9]) </td></tr><tr><td>  [[: inferior:]] </td><td>  Cualquier letra min√∫scula del alfabeto ingl√©s ([az]) </td></tr><tr><td>  [[: superior:]] </td><td>  Cualquier letra may√∫scula del alfabeto ingl√©s ([AZ]) </td></tr><tr><td>  [[: punct:]] </td><td>  Cualquier signo de puntuaci√≥n </td></tr><tr><td>  [[: espacio:]] </td><td>  Cualquier espacio en blanco </td></tr><tr><td>  [[: xdigit:]] </td><td>  Cualquier d√≠gito hexadecimal ([0-9a-fA-F]) </td></tr></tbody></table></div><br><br>  Al final dar√© un ejemplo de una implementaci√≥n concreta de expresiones regulares en PHP, usando las implementaciones mencionadas anteriormente.  Tambi√©n agregu√© la validaci√≥n del nombre de usuario para que no pudiera ingresar combinaciones demasiado cortas de letras (bueno, supongamos que estos son apodos, no nombres, los nombres son m√°s cortos que dos letras): <br><br><pre> <code class="php hljs"> $pattern_name = <span class="hljs-string"><span class="hljs-string">'/\w{3,}/'</span></span>; $pattern_mail = <span class="hljs-string"><span class="hljs-string">'/\w+@\w+\.\w+/'</span></span>; $pattern_password = <span class="hljs-string"><span class="hljs-string">'/^(?=.*[az])(?=.*[AZ])(?=.*\d)[a-zA-Z\d]{8,}$/'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (preg_match($pattern_name, $name) &amp;&amp; preg_match($pattern_mail, $mail) &amp;&amp; preg_match($pattern_password, $_POST[<span class="hljs-string"><span class="hljs-string">'password'</span></span>])) { <span class="hljs-comment"><span class="hljs-comment">#  ,  ,   ,   ,      }</span></span></code> </pre><br><br>  ¬°Gracias a todos por su atenci√≥n!  Por supuesto, hoy hemos tocado solo una parte de las expresiones regulares y se pueden escribir algunos art√≠culos m√°s sobre ellas.  Por ejemplo, no hablamos sobre la implementaci√≥n de la b√∫squeda de repeticiones de palabras id√©nticas en el texto.  Pero espero que el conocimiento adquirido sea suficiente para escribir significativamente mi primera validaci√≥n de formularios y solo luego pasar a cosas m√°s furiosas. <br><br>  <b>Por tradici√≥n, algunos enlaces √∫tiles:</b> <br><br>  <a href="http://web.mit.edu/hackl/www/lab/turkshop/slides/regex-cheatsheet.pdf">Hoja de trucos de</a> expresi√≥n regular del MIT <br>  La parte oficial de la <a href="https://www.php.net/manual/ru/pcre.pattern.php">documentaci√≥n</a> de php regex. <br><br>  <b>Eso es todo.</b>  <b>¬°Nos vemos en el <a href="https://otus.pw/vMHA/">intensivo</a> !</b> <br>  <b>El segundo d√≠a de intenso <a href="https://otus.pw/cl2i/">se llevar√° a cabo aqu√≠.</a></b> </div></div><p>Source: <a href="https://habr.com/ru/post/484048/">https://habr.com/ru/post/484048/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../484026/index.html">Parte 6: Portar MemTest86 + a RISC-V</a></li>
<li><a href="../484028/index.html">Horseshoe Bend - tableta convertible con pantalla plegable</a></li>
<li><a href="../484034/index.html">Implementaci√≥n del esquema de trabajo del almacenamiento dirigido de bienes basado en la unidad de contabilidad de almac√©n 1C Integrated Automation 2</a></li>
<li><a href="../484036/index.html">Nuevo grupo industrial crea un est√°ndar universal para hogares inteligentes</a></li>
<li><a href="../484046/index.html">Comprobaci√≥n de Emby con PVS-Studio</a></li>
<li><a href="../484050/index.html">Incruste el an√°lisis del c√≥digo fuente con el analizador PVS-Studio</a></li>
<li><a href="../484052/index.html">Tareas para la base lunar</a></li>
<li><a href="../484056/index.html">¬øSu proyecto realmente necesita pruebas?</a></li>
<li><a href="../484062/index.html">Aprendiendo ingl√©s por MEMASICS</a></li>
<li><a href="../484064/index.html">¬øC√≥mo preparar un juego para la localizaci√≥n? 10 reglas b√°sicas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>