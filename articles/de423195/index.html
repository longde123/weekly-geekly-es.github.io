<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõåüèº üßùüèø ‚è∫Ô∏è Was ist neu in JPA 2.2? üåü üë©üèø‚Äçü§ù‚Äçüë®üèæ üëåüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sch√∂ne Ferien an alle! 

 Es kam so pl√∂tzlich vor, dass der Start der zweiten Gruppe ‚ÄûJava Enterprise Developer‚Äú mit dem 256. Tag des Jahres zusammenf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Was ist neu in JPA 2.2?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/423195/">  Sch√∂ne Ferien an alle! <br><br>  Es kam so pl√∂tzlich vor, dass der Start der zweiten Gruppe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûJava Enterprise Developer‚Äú</a> mit dem 256. Tag des Jahres zusammenfiel.  <s>Zufall?</s>  <s>Ich glaube nicht.</s> <br><br>  Nun, wir teilen das vorletzte Interesse: Welche neuen Dinge brachte JPA 2.2 - Streaming-Ergebnisse, verbesserte Datumskonvertierung, neue Anmerkungen - nur einige Beispiele f√ºr n√ºtzliche Verbesserungen. <br><br>  Lass uns gehen! <br><br>  Die Java Persistence API (JPA) ist eine grundlegende Java EE-Spezifikation, die in der Branche weit verbreitet ist.  Unabh√§ngig davon, ob Sie f√ºr die Java EE-Plattform oder f√ºr das alternative Java-Framework entwickeln, ist JPA Ihre Wahl zum Speichern von Daten.  JPA 2.1 hat die Spezifikation verbessert, sodass Entwickler Probleme wie die automatische Generierung von Datenbankschemata und die effiziente Arbeit mit in der Datenbank gespeicherten Prozeduren l√∂sen k√∂nnen.  Die neueste Version, JPA 2.2, verbessert die Spezifikation basierend auf diesen √Ñnderungen. <br>  In diesem Artikel werde ich √ºber neue Funktionen sprechen und Beispiele geben, die Ihnen den Einstieg erleichtern.  Als Beispiel verwende ich das Projekt ‚ÄûJava EE 8 Playground‚Äú, das auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> verf√ºgbar ist.  Die Beispielanwendung basiert auf der Java EE 8-Spezifikation und verwendet f√ºr die Persistenz die Frameworks JavaServer Faces (JSF), Enterprise JavaBeans (EJB) und JPA.  Sie m√ºssen mit JPA vertraut sein, um zu verstehen, worum es geht. <br><br><img src="https://habrastorage.org/webt/2a/o5/xl/2ao5xlvs1k6qa91gdq0ndz3akis.png"><br><a name="habracut"></a><br>  <b>Verwenden von JPA 2.2</b> <br><br>  JPA Version 2.2 ist Teil der Java EE 8-Plattform. Es ist erw√§hnenswert, dass nur Java EE 8-kompatible Anwendungsserver eine Spezifikation bereitstellen, die sofort einsatzbereit ist.  Zum Zeitpunkt dieses Schreibens (Ende 2017) gab es einige solcher Anwendungsserver.  Die Verwendung von JPA 2.2 mit Java EE7 ist jedoch einfach.  Zuerst m√ºssen Sie die entsprechenden JAR-Dateien mit <a href="">Maven Central</a> herunterladen und dem Projekt hinzuf√ºgen.  Wenn Sie Maven in Ihrem Projekt verwenden, f√ºgen Sie die Koordinaten zur Maven-POM-Datei hinzu: <br><br><pre><code class="java hljs">&lt;dependency&gt; &lt;groupId&gt;javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;javax.persistence-api&lt;/artifactId&gt; &lt;version&gt;<span class="hljs-number"><span class="hljs-number">2.2</span></span>&lt;/version&gt; &lt;/dependency&gt;</code> </pre> <br>  W√§hlen Sie dann die JPA-Implementierung aus, die Sie verwenden m√∂chten.  Ab JPA 2.2 verf√ºgen sowohl EclipseLink als auch Hibernate √ºber kompatible Implementierungen.  Als Beispiele in diesem Artikel verwende ich <a href="">EclipseLink,</a> indem ich die folgende Abh√§ngigkeit hinzuf√ºge: <br><br><pre> <code class="java hljs">&lt;dependency&gt; &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt; &lt;artifactId&gt;eclipselink&lt;/artifactId&gt; &lt;version&gt;<span class="hljs-number"><span class="hljs-number">2.7</span></span>.0 &lt;/version&gt; &lt;/dependency&gt;</code> </pre> <br>  Wenn Sie einen Java EE 8-kompatiblen Server wie GlassFish 5 oder Payara 5 verwenden, sollten Sie in der POM-Datei den Bereich "Bereitgestellt" f√ºr diese Abh√§ngigkeiten angeben k√∂nnen.  Andernfalls geben Sie den Bereich "Kompilieren" an, um sie in die Projektassembly aufzunehmen. <br><br>  <b>Java 8 Datums- und Uhrzeitunterst√ºtzung</b> <br><br>  M√∂glicherweise ist eine der positivsten Erg√§nzungen die Unterst√ºtzung der Java 8-API f√ºr Datum und Uhrzeit.  Seit der Ver√∂ffentlichung von Java SE 8 im Jahr 2014 haben Entwickler Problemumgehungen verwendet, um die Datums- und Uhrzeit-API mit JPA zu verwenden.  Obwohl die meisten Problemumgehungen recht einfach sind, ist die Notwendigkeit, grundlegende Unterst√ºtzung f√ºr die aktualisierte Datums- und Uhrzeit-API hinzuzuf√ºgen, l√§ngst √ºberf√§llig.  Die JPA-Unterst√ºtzung f√ºr die Datums- und Uhrzeit-API umfasst die folgenden Typen: <br><br><ul><li> <code>java.time.LocalDate</code> </li> <li> <code>java.time.LocalTime</code> </li> <li> <code>java.time.LocalDateTime</code> </li> <li> <code>java.time.OffsetTime</code> </li> <li> <code>java.time.OffsetDateTime</code> </li> </ul><br>  Zum besseren Verst√§ndnis werde ich zun√§chst erl√§utern, wie die API-Unterst√ºtzung f√ºr Datum und Uhrzeit ohne JPA 2.2 funktioniert.  JPA 2.1 kann nur mit √§lteren <code>java.sql.Timestamp</code> wie <code>java.util.Date</code> und <code>java.sql.Timestamp</code> .  Daher m√ºssen Sie einen Konverter verwenden, um das in der Datenbank gespeicherte Datum in ein altes Design zu konvertieren, das von JPA 2.1 unterst√ºtzt wird, und es dann zur Verwendung in der Anwendung in eine aktualisierte Datums- und Uhrzeit-API konvertieren.  Ein <code>LocalDate</code> in JPA 2.1, der eine solche Konvertierung erm√∂glicht, sieht m√∂glicherweise wie in Listing 1 aus. Der darin enthaltene Konverter wird zum Konvertieren zwischen <code>LocalDate</code> und <code>java.util.Date</code> . <br><br>  <i>Listing 1</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Converter</span></span>(autoApply = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDateTimeConverter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AttributeConverter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDate</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Date</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Date </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToDatabaseColumn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LocalDate entityValue)</span></span></span><span class="hljs-function"> </span></span>{ LocalTime time = LocalTime.now(); Instant instant = time.atDate(entityValue) .atZone(ZoneId.systemDefault()) .toInstant(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Date.from(instant); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> LocalDate </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToEntityAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Date databaseValue)</span></span></span></span>{ Instant instant = Instant.ofEpochMilli(databaseValue.getTime()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LocalDateTime.ofInstant(instant, ZoneId.systemDefault()).toLocalDate(); } }</code> </pre> <br>  JPA 2.2 muss einen solchen Konverter nicht mehr schreiben, da Sie unterst√ºtzte Datums- und Uhrzeittypen verwenden.  Die Unterst√ºtzung f√ºr solche Typen ist integriert, sodass Sie den unterst√ºtzten Typ einfach ohne zus√§tzlichen Code im Feld f√ºr die Entit√§tsklasse angeben k√∂nnen.  Das folgende Code-Snippet demonstriert dieses Konzept.  Beachten Sie, dass dem <code>@Temporal</code> Code keine Anmerkungen <code>@Temporal</code> m√ºssen, da die <code>@Temporal</code> automatisch erfolgt. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . . <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"WORK_DATE"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalDate workDate; . . . }</code> </pre> <br>  Da die unterst√ºtzten Datums- und Uhrzeittypen in der JPA erstklassige Objekte sind, k√∂nnen sie ohne zus√§tzliche Zeremonien angegeben werden.  In JPA 2.1 <code>@Temporal</code> Anmerkung in allen konstanten Feldern und Eigenschaften des <code>java.util.Calendar</code> <code>java.util.Date</code> und <code>java.util.Calendar</code> . <br><br>  Es ist erw√§hnenswert, dass in dieser Version nur ein Teil der <code>LocalDateTime</code> <code>ZonedDateTime</code> . Der Attributkonverter kann jedoch einfach generiert werden, um mit anderen Typen zu arbeiten, z. B. zum Konvertieren von <code>LocalDateTime</code> in <code>ZonedDateTime</code> .  Das gr√∂√üte Problem beim Schreiben eines solchen Konverters besteht darin, zu bestimmen, wie am besten zwischen verschiedenen Typen konvertiert werden kann.  Um die Sache noch einfacher zu machen, k√∂nnen jetzt Attributkonverter implementiert werden.  Ich werde unten eine Beispielimplementierung geben. <br><br>  Der Code in Listing 2 zeigt, wie die Zeit von <code>LocalDateTime</code> in <code>ZonedDateTime</code> . <br><br>  <i>Listing 2:</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Converter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalToZonedConverter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AttributeConverter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZonedDateTime</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDateTime</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> LocalDateTime </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToDatabaseColumn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ZonedDateTime entityValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entityValue.toLocalDateTime(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ZonedDateTime </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToEntityAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LocalDateTime databaseValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ZonedDateTime.of(databaseValue, ZoneId.systemDefault()); } }</code> </pre> <br>  Insbesondere ist dieses Beispiel sehr einfach, da <code>ZonedDateTime</code> Methoden enth√§lt, die einfach zu konvertieren sind.  Die Konvertierung erfolgt durch Aufrufen der <code>toLocalDateTime()</code> -Methode.  Die inverse Konvertierung kann durchgef√ºhrt werden, indem die <code>ZonedDateTimeOf()</code> -Methode <code>ZonedDateTimeOf()</code> und der <code>LocalDateTime</code> Wert zusammen mit <code>ZoneId</code> , um die Zeitzone zu verwenden. <br><br>  <b>Eingebettete Attributkonverter</b> <br><br>  Attributkonverter waren eine sehr sch√∂ne Erg√§nzung zu JPA 2.1, da sie es erm√∂glichten, Attributtypen flexibler zu gestalten.  Das JPA 2.2-Update bietet eine n√ºtzliche M√∂glichkeit, Attributkonverter implementierbar zu machen.  Dies bedeutet, dass Sie CDI-Ressourcen (Contexts and Dependency Injection) direkt in den Attributkonverter einbetten k√∂nnen.  Diese √Ñnderung steht im Einklang mit anderen CDI-Verbesserungen in den Java EE 8-Spezifikationen, z. B. erweiterten JSF-Konvertern, da diese jetzt auch die CDI-Injektion verwenden k√∂nnen. <br><br>  Um diese neue Funktion nutzen zu k√∂nnen, binden Sie die CDI-Ressourcen nach Bedarf einfach in den Attributkonverter ein.  Listing 2 enth√§lt ein Beispiel f√ºr einen Attributkonverter. Jetzt werde ich es auseinander nehmen und alle wichtigen Details erl√§utern. <br><br>  Die Konverterklasse muss die Schnittstelle <code>javax.persistence.AttributeConverter</code> implementieren und die X- und Y-Werte √ºbergeben. Der X-Wert entspricht dem Datentyp im Java-Objekt und der Y-Wert muss dem Datenbankspaltentyp entsprechen.  Dann sollte die Konverterklasse mit <code>@Converter</code> kommentiert <code>@Converter</code> .  Schlie√ülich muss die Klasse die <code>convertToDatabaseColumn()</code> und <code>convertToEntityAttribute()</code> √ºberschreiben.  Die Implementierung in jeder dieser Methoden sollte Werte von bestimmten Typen und zur√ºck zu diesen konvertieren. <br><br>  Um den Konverter bei jeder Verwendung des angegebenen Datentyps automatisch anzuwenden, f√ºgen Sie wie in <code>@Converter(autoApply=true)</code> " <code>@Converter(autoApply=true)</code> .  Um einen Konverter auf ein einzelnes Attribut anzuwenden, verwenden Sie die Annotation @Converter auf Attributebene, wie hier gezeigt: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Convert</span></span>(converter=LocalDateConverter.java) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalDate workDate;</code> </pre> <br>  Der Konverter kann auch auf Klassenebene angewendet werden: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Convert</span></span>(attributeName=<span class="hljs-string"><span class="hljs-string">"workDate"</span></span>, converter = LocalDateConverter.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . .</code> </pre> <br>  Angenommen, ich m√∂chte die im Feld <code>creditLimit</code> der <code>creditLimit</code> enthaltenen Werte beim <code>creditLimit</code> verschl√ºsseln.  Um diesen Prozess zu implementieren, m√ºssen die Werte vor dem Speichern verschl√ºsselt und nach dem Abrufen aus der Datenbank entschl√ºsselt werden.  Dies kann vom Konverter durchgef√ºhrt werden, und mit JPA 2.2 kann ich das Verschl√ºsselungsobjekt in den Konverter einbetten, um das gew√ºnschte Ergebnis zu erzielen.  Listing 3 enth√§lt ein Beispiel. <br><br>  <i>Listing 3:</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Converter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreditLimitConverter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AttributeConverter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigDecimal</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigDecimal</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> CreditLimitEncryptor encryptor; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BigDecimal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToDatabaseColumn</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BigDecimal entityValue)</span></span></span><span class="hljs-function"> </span></span>{ String encryptedFormat = encryptor.base64encode(entityValue.toString()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BigDecimal.valueOf(Long.valueOf(encryptedFormat)); } ... }</code> </pre> <br>  In diesem Code wird der Prozess ausgef√ºhrt, <code>CreditLimitEncryptor</code> Klasse in den Konverter <code>CreditLimitEncryptor</code> und anschlie√üend zur Unterst√ºtzung des Prozesses verwendet wird. <br><br>  <b>Streaming-Abfrageergebnisse</b> <br><br>  Jetzt k√∂nnen Sie die Funktionen von Java SE 8-Streams problemlos nutzen, wenn Sie mit Abfrageergebnissen arbeiten.  Threads vereinfachen nicht nur das Lesen, Schreiben und Verwalten von Code, sondern verbessern in einigen Situationen auch die Abfrageleistung.  Einige Thread-Implementierungen tragen auch dazu bei, eine √ºberm√§√üig gro√üe Anzahl von Datenanforderungen gleichzeitig zu vermeiden, obwohl in einigen F√§llen die Verwendung der <code>ResultSet</code> Paginierung m√∂glicherweise besser funktioniert als Streams. <br><br>  Um diese Funktion zu aktivieren, wurde die Methode <code>getResultStream()</code> zu den <code>TypedQuery</code> <code>Query</code> und <code>TypedQuery</code> hinzugef√ºgt.  Diese geringf√ºgige √Ñnderung erm√∂glicht es JPA, einfach einen Ergebnisstrom anstelle einer Liste zur√ºckzugeben.  Wenn Sie also mit einem gro√üen <code>ResultSet</code> , ist es sinnvoll, die Leistung zwischen einer neuen Thread-Implementierung und einem scrollbaren <code>ResultSets</code> oder einer Paginierung zu vergleichen.  Der Grund daf√ºr ist, dass Thread-Implementierungen alle Datens√§tze auf einmal abrufen, in einer Liste speichern und dann zur√ºckgeben.  Eine scrollbare <code>ResultSet</code> und Paginierungstechnik ruft Daten st√ºckweise ab, was f√ºr gro√üe Datenmengen m√∂glicherweise besser ist. <br><br>  Persistenzanbieter k√∂nnen beschlie√üen, die neue Methode <code>getResultStream()</code> verbesserter Implementierung zu √ºberschreiben.  Der <code>ResultSet</code> enth√§lt bereits eine stream () -Methode, die ein scrollbares <code>ResultSet</code> , um die Ergebnisse von Datens√§tzen zu analysieren, anstatt sie vollst√§ndig zur√ºckzugeben.  Dadurch kann Hibernate mit sehr gro√üen Datenmengen arbeiten und dies gut tun.  Es ist zu erwarten, dass andere Anbieter diese Methode √ºberschreiben, um √§hnliche Funktionen bereitzustellen, die f√ºr JPA von Vorteil sind. <br><br>  Neben der Leistung ist die M√∂glichkeit, Ergebnisse zu streamen, eine nette Erg√§nzung zu JPA, die eine bequeme M√∂glichkeit bietet, mit Daten zu arbeiten.  Ich werde einige Szenarien demonstrieren, in denen dies n√ºtzlich sein kann, aber die M√∂glichkeiten selbst sind endlos.  In beiden Szenarien frage ich die <code>Job</code> Entit√§t ab und gebe den Stream zur√ºck.  Schauen Sie sich zun√§chst den folgenden Code an, in dem ich den <code>Jobs</code> Stream einfach gegen einen bestimmten <code>Customer</code> analysiere, indem ich die Schnittstellenmethode <code>getResultStream()</code> von <code>Query</code> <code>getResultStream()</code> .  Dann verwende ich diesen Thread, um Details zu <code>customer</code> und <code>work date</code> Job'a auszugeben. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByCustomer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PoolCustomer customer)</span></span></span></span>{ Stream&lt;Job&gt; jobList = em.createQuery(<span class="hljs-string"><span class="hljs-string">"select object(o) from Job o "</span></span> + <span class="hljs-string"><span class="hljs-string">"where o.customer = :customer"</span></span>) .setParameter(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>, customer) .getResultStream(); jobList.map(j -&gt; j.getCustomerId() + <span class="hljs-string"><span class="hljs-string">" ordered job "</span></span> + j.getId() + <span class="hljs-string"><span class="hljs-string">" - Starting "</span></span> + j.getWorkDate()) .forEach(jm -&gt; System.out.println(jm)); }</code> </pre> <br><br>  Diese Methode kann leicht ge√§ndert werden, sodass mit der <code>Collectors .toList()</code> -Methode eine Liste der Ergebnisse wie folgt zur√ºckgegeben wird. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Job&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByCustomer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PoolCustomer customer)</span></span></span></span>{ Stream&lt;Job&gt; jobList = em.createQuery( <span class="hljs-string"><span class="hljs-string">"select object(o) from Job o "</span></span> + <span class="hljs-string"><span class="hljs-string">"where o.customerId = :customer"</span></span>) .setParameter(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>, customer) .getResultStream(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jobList.collect(Collectors.toList()); }</code> </pre> <br>  In dem folgenden Szenario, das unten gezeigt wird, finde ich eine <code>List</code> Aufgaben, die sich auf Pools eines bestimmten Formulars beziehen.  In diesem Fall gebe ich alle Aufgaben zur√ºck, die dem als Zeichenfolge √ºbermittelten Formular entsprechen.  √Ñhnlich wie im ersten Beispiel gebe ich zuerst einen Stream von <code>Jobs</code> Datens√§tzen zur√ºck.  Dann filtere ich Datens√§tze basierend auf dem Kundenpoolformular.  Wie Sie sehen k√∂nnen, ist der resultierende Code sehr kompakt und leicht zu lesen. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Job&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByCustPoolShape</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String poolShape)</span></span></span></span>{ Stream&lt;Job&gt; jobstream = em.createQuery( <span class="hljs-string"><span class="hljs-string">"select object(o) from Job o"</span></span>) .getResultStream(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jobstream.filter( c -&gt; poolShape.equals(c.getCustomerId().getPoolId().getShape())) .collect(Collectors.toList()); }</code> </pre><br>  Wie bereits erw√§hnt, ist es wichtig, die Leistung in Szenarien zu ber√ºcksichtigen, in denen gro√üe Datenmengen zur√ºckgegeben werden.  Es gibt Bedingungen, unter denen Threads beim Abfragen von Datenbanken n√ºtzlicher sind, aber es gibt auch Bedingungen, unter denen sie zu Leistungseinbu√üen f√ºhren k√∂nnen.  Eine gute Faustregel lautet: Wenn Daten im Rahmen einer SQL-Abfrage abgefragt werden k√∂nnen, ist es sinnvoll, genau das zu tun.  Manchmal √ºberwiegen die Vorteile der Verwendung einer eleganten Thread-Syntax nicht die beste Leistung, die mit der Standard-SQL-Filterung erzielt werden kann. <br><br>  <b>Unterst√ºtzung f√ºr doppelte Anmerkungen</b> <br><br>  Mit der Ver√∂ffentlichung von Java SE 8 wurden doppelte Anmerkungen m√∂glich, sodass Sie Anmerkungen in der Deklaration wiederverwenden k√∂nnen.  In einigen Situationen muss dieselbe Anmerkung f√ºr eine Klasse oder ein Feld mehrmals verwendet werden.  Beispielsweise kann es f√ºr eine bestimmte Entit√§tsklasse mehr als eine <code>@SqlResultSetMapping</code> Annotation geben.  In Situationen, in denen die Unterst√ºtzung f√ºr eine erneute Annotation erforderlich ist, sollte eine Container-Annotation verwendet werden.  Doppelte Anmerkungen reduzieren nicht nur die Notwendigkeit, Sammlungen identischer Anmerkungen in Containeranmerkungen zu verpacken, sondern k√∂nnen auch das Lesen von Code erleichtern. <br><br>  Dies funktioniert wie folgt: Die Implementierung der Annotation-Klasse sollte mit der Meta-Annotation <code>@Repeatable</code> gekennzeichnet werden, um anzuzeigen, dass sie mehrmals verwendet werden kann.  Die <code>@Repeatable</code> nimmt den Typ der Containeranmerkungsklasse an.  Beispielsweise ist die Annotationsklasse <code>NamedQuery</code> jetzt mit der Annotation <code>@Repeatable(NamedQueries.class)</code> .  In diesem Fall wird die Container-Annotation noch verwendet, aber Sie m√ºssen nicht dar√ºber nachdenken, wenn Sie dieselbe Annotation f√ºr die Deklaration oder Klasse verwenden, da <code>@Repeatable</code> dieses Detail abstrahiert. <br><br>  Wir geben ein Beispiel.  Wenn Sie einer Entit√§tsklasse in JPA 2.1 mehr als eine <code>@NamedQuery</code> Annotation hinzuf√ºgen m√∂chten, m√ºssen Sie diese in die <code>@NamedQueries</code> Annotation <code>@NamedQueries</code> , wie in Listing 4 gezeigt. <br><br>  <i>Listing 4:</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"CUSTOMER"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@XmlRootElement</span></span> <span class="hljs-meta"><span class="hljs-meta">@NamedQueries</span></span>({ <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findAll"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c"</span></span>) , <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByCustomerId"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.customerId = :customerId"</span></span>) , <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByName"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.name = :name"</span></span>) . . .)}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Customer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . . }</code> </pre> <br>  In JPA 2.2 ist jedoch alles anders.  Da <code>@NamedQuery</code> eine doppelte Annotation ist, kann sie in der Entit√§tsklasse mehrmals angegeben werden, wie in Listing 5 gezeigt. <br><br>  <i>Listing 5:</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"CUSTOMER"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@XmlRootElement</span></span> <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findAll"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByCustomerId"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.customerId = :customerId"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByName"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.name = :name"</span></span>) . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Customer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . . }</code> </pre> <br>  Liste der doppelten Anmerkungen: <br><br><ul><li> <code>@AssociationOverride</code> </li> <li> <code>@AttributeOverride</code> </li> <li> <code>@Convert</code> </li> <li> <code>@JoinColumn</code> </li> <li> <code>@MapKeyJoinColumn</code> </li> <li> <code>@NamedEntityGraphy</code> </li> <li> <code>@NamedNativeQuery</code> </li> <li> <code>@NamedQuery</code> </li> <li> <code>@NamedStoredProcedureQuery</code> </li> <li> <code>@PersistenceContext</code> </li> <li> <code>@PersistenceUnit</code> </li> <li> <code>@PrimaryKeyJoinColumn</code> </li> <li> <code>@SecondaryTable</code> </li> <li> <code>@SqlResultSetMapping</code> </li> </ul><br>  <b>Fazit</b> <br><br>  Die JPA 2.2-Version enth√§lt einige √Ñnderungen, die enthaltenen Verbesserungen sind jedoch erheblich.  Schlie√ülich ist der JPA auf Java SE 8 ausgerichtet, sodass Entwickler Funktionen wie die Datums- und Uhrzeit-API verwenden, Abfrageergebnisse streamen und Anmerkungen wiederholen k√∂nnen.  Diese Version verbessert auch die CDI-Konsistenz, indem die M√∂glichkeit hinzugef√ºgt wird, CDI-Ressourcen in Attributkonverter einzubetten.  JPA 2.2 ist jetzt verf√ºgbar und Teil von Java EE 8. Ich denke, Sie werden es gerne verwenden. <br><br>  DAS ENDE <br><br>  Wie immer warten wir auf Fragen und Kommentare. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423195/">https://habr.com/ru/post/de423195/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423185/index.html">Iss es nicht! N√ºtzlicher 3D-Zuckerdruck</a></li>
<li><a href="../de423187/index.html">Stamm- und Zwischenzertifikate autorisierter Zertifizierungsstellen Russlands</a></li>
<li><a href="../de423189/index.html">Forschung: Die H√§lfte der Unternehmen behebt Schwachstellen innerhalb eines Monats - warum?</a></li>
<li><a href="../de423191/index.html">Einf√ºhrung der Elemente von Offshore-Plattformen. Teil 1</a></li>
<li><a href="../de423193/index.html">Konfigurieren Sie Web-Push-Benachrichtigungen mithilfe von pywebpush Schritt f√ºr Schritt</a></li>
<li><a href="../de423197/index.html">LOLWUT: ein Kunstwerk in einem DB-Team</a></li>
<li><a href="../de423203/index.html">Cooler Teamleiter wird f√ºr den Service verantwortlich sein</a></li>
<li><a href="../de423205/index.html">Speicherprojekt auf MS SQL Server, Integration in 1C 7.7 und Entwicklungsautomatisierung in SSDT</a></li>
<li><a href="../de423207/index.html">So erstellen Sie ein automatisches Update eines Online-Spieleclients</a></li>
<li><a href="../de423209/index.html">Killer Form 2? √úbersicht √ºber den MoonRay S100 Dental 3D-Drucker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>