<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛌🏼 🧝🏿 ⏺️ Was ist neu in JPA 2.2? 🌟 👩🏿‍🤝‍👨🏾 👌🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Schöne Ferien an alle! 

 Es kam so plötzlich vor, dass der Start der zweiten Gruppe „Java Enterprise Developer“ mit dem 256. Tag des Jahres zusammenf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Was ist neu in JPA 2.2?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/423195/">  Schöne Ferien an alle! <br><br>  Es kam so plötzlich vor, dass der Start der zweiten Gruppe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Java Enterprise Developer“</a> mit dem 256. Tag des Jahres zusammenfiel.  <s>Zufall?</s>  <s>Ich glaube nicht.</s> <br><br>  Nun, wir teilen das vorletzte Interesse: Welche neuen Dinge brachte JPA 2.2 - Streaming-Ergebnisse, verbesserte Datumskonvertierung, neue Anmerkungen - nur einige Beispiele für nützliche Verbesserungen. <br><br>  Lass uns gehen! <br><br>  Die Java Persistence API (JPA) ist eine grundlegende Java EE-Spezifikation, die in der Branche weit verbreitet ist.  Unabhängig davon, ob Sie für die Java EE-Plattform oder für das alternative Java-Framework entwickeln, ist JPA Ihre Wahl zum Speichern von Daten.  JPA 2.1 hat die Spezifikation verbessert, sodass Entwickler Probleme wie die automatische Generierung von Datenbankschemata und die effiziente Arbeit mit in der Datenbank gespeicherten Prozeduren lösen können.  Die neueste Version, JPA 2.2, verbessert die Spezifikation basierend auf diesen Änderungen. <br>  In diesem Artikel werde ich über neue Funktionen sprechen und Beispiele geben, die Ihnen den Einstieg erleichtern.  Als Beispiel verwende ich das Projekt „Java EE 8 Playground“, das auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> verfügbar ist.  Die Beispielanwendung basiert auf der Java EE 8-Spezifikation und verwendet für die Persistenz die Frameworks JavaServer Faces (JSF), Enterprise JavaBeans (EJB) und JPA.  Sie müssen mit JPA vertraut sein, um zu verstehen, worum es geht. <br><br><img src="https://habrastorage.org/webt/2a/o5/xl/2ao5xlvs1k6qa91gdq0ndz3akis.png"><br><a name="habracut"></a><br>  <b>Verwenden von JPA 2.2</b> <br><br>  JPA Version 2.2 ist Teil der Java EE 8-Plattform. Es ist erwähnenswert, dass nur Java EE 8-kompatible Anwendungsserver eine Spezifikation bereitstellen, die sofort einsatzbereit ist.  Zum Zeitpunkt dieses Schreibens (Ende 2017) gab es einige solcher Anwendungsserver.  Die Verwendung von JPA 2.2 mit Java EE7 ist jedoch einfach.  Zuerst müssen Sie die entsprechenden JAR-Dateien mit <a href="">Maven Central</a> herunterladen und dem Projekt hinzufügen.  Wenn Sie Maven in Ihrem Projekt verwenden, fügen Sie die Koordinaten zur Maven-POM-Datei hinzu: <br><br><pre><code class="java hljs">&lt;dependency&gt; &lt;groupId&gt;javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;javax.persistence-api&lt;/artifactId&gt; &lt;version&gt;<span class="hljs-number"><span class="hljs-number">2.2</span></span>&lt;/version&gt; &lt;/dependency&gt;</code> </pre> <br>  Wählen Sie dann die JPA-Implementierung aus, die Sie verwenden möchten.  Ab JPA 2.2 verfügen sowohl EclipseLink als auch Hibernate über kompatible Implementierungen.  Als Beispiele in diesem Artikel verwende ich <a href="">EclipseLink,</a> indem ich die folgende Abhängigkeit hinzufüge: <br><br><pre> <code class="java hljs">&lt;dependency&gt; &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt; &lt;artifactId&gt;eclipselink&lt;/artifactId&gt; &lt;version&gt;<span class="hljs-number"><span class="hljs-number">2.7</span></span>.0 &lt;/version&gt; &lt;/dependency&gt;</code> </pre> <br>  Wenn Sie einen Java EE 8-kompatiblen Server wie GlassFish 5 oder Payara 5 verwenden, sollten Sie in der POM-Datei den Bereich "Bereitgestellt" für diese Abhängigkeiten angeben können.  Andernfalls geben Sie den Bereich "Kompilieren" an, um sie in die Projektassembly aufzunehmen. <br><br>  <b>Java 8 Datums- und Uhrzeitunterstützung</b> <br><br>  Möglicherweise ist eine der positivsten Ergänzungen die Unterstützung der Java 8-API für Datum und Uhrzeit.  Seit der Veröffentlichung von Java SE 8 im Jahr 2014 haben Entwickler Problemumgehungen verwendet, um die Datums- und Uhrzeit-API mit JPA zu verwenden.  Obwohl die meisten Problemumgehungen recht einfach sind, ist die Notwendigkeit, grundlegende Unterstützung für die aktualisierte Datums- und Uhrzeit-API hinzuzufügen, längst überfällig.  Die JPA-Unterstützung für die Datums- und Uhrzeit-API umfasst die folgenden Typen: <br><br><ul><li> <code>java.time.LocalDate</code> </li> <li> <code>java.time.LocalTime</code> </li> <li> <code>java.time.LocalDateTime</code> </li> <li> <code>java.time.OffsetTime</code> </li> <li> <code>java.time.OffsetDateTime</code> </li> </ul><br>  Zum besseren Verständnis werde ich zunächst erläutern, wie die API-Unterstützung für Datum und Uhrzeit ohne JPA 2.2 funktioniert.  JPA 2.1 kann nur mit älteren <code>java.sql.Timestamp</code> wie <code>java.util.Date</code> und <code>java.sql.Timestamp</code> .  Daher müssen Sie einen Konverter verwenden, um das in der Datenbank gespeicherte Datum in ein altes Design zu konvertieren, das von JPA 2.1 unterstützt wird, und es dann zur Verwendung in der Anwendung in eine aktualisierte Datums- und Uhrzeit-API konvertieren.  Ein <code>LocalDate</code> in JPA 2.1, der eine solche Konvertierung ermöglicht, sieht möglicherweise wie in Listing 1 aus. Der darin enthaltene Konverter wird zum Konvertieren zwischen <code>LocalDate</code> und <code>java.util.Date</code> . <br><br>  <i>Listing 1</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Converter</span></span>(autoApply = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDateTimeConverter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AttributeConverter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDate</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Date</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Date </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToDatabaseColumn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LocalDate entityValue)</span></span></span><span class="hljs-function"> </span></span>{ LocalTime time = LocalTime.now(); Instant instant = time.atDate(entityValue) .atZone(ZoneId.systemDefault()) .toInstant(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Date.from(instant); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> LocalDate </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToEntityAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Date databaseValue)</span></span></span></span>{ Instant instant = Instant.ofEpochMilli(databaseValue.getTime()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LocalDateTime.ofInstant(instant, ZoneId.systemDefault()).toLocalDate(); } }</code> </pre> <br>  JPA 2.2 muss einen solchen Konverter nicht mehr schreiben, da Sie unterstützte Datums- und Uhrzeittypen verwenden.  Die Unterstützung für solche Typen ist integriert, sodass Sie den unterstützten Typ einfach ohne zusätzlichen Code im Feld für die Entitätsklasse angeben können.  Das folgende Code-Snippet demonstriert dieses Konzept.  Beachten Sie, dass dem <code>@Temporal</code> Code keine Anmerkungen <code>@Temporal</code> müssen, da die <code>@Temporal</code> automatisch erfolgt. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . . <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"WORK_DATE"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalDate workDate; . . . }</code> </pre> <br>  Da die unterstützten Datums- und Uhrzeittypen in der JPA erstklassige Objekte sind, können sie ohne zusätzliche Zeremonien angegeben werden.  In JPA 2.1 <code>@Temporal</code> Anmerkung in allen konstanten Feldern und Eigenschaften des <code>java.util.Calendar</code> <code>java.util.Date</code> und <code>java.util.Calendar</code> . <br><br>  Es ist erwähnenswert, dass in dieser Version nur ein Teil der <code>LocalDateTime</code> <code>ZonedDateTime</code> . Der Attributkonverter kann jedoch einfach generiert werden, um mit anderen Typen zu arbeiten, z. B. zum Konvertieren von <code>LocalDateTime</code> in <code>ZonedDateTime</code> .  Das größte Problem beim Schreiben eines solchen Konverters besteht darin, zu bestimmen, wie am besten zwischen verschiedenen Typen konvertiert werden kann.  Um die Sache noch einfacher zu machen, können jetzt Attributkonverter implementiert werden.  Ich werde unten eine Beispielimplementierung geben. <br><br>  Der Code in Listing 2 zeigt, wie die Zeit von <code>LocalDateTime</code> in <code>ZonedDateTime</code> . <br><br>  <i>Listing 2:</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Converter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalToZonedConverter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AttributeConverter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZonedDateTime</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDateTime</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> LocalDateTime </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToDatabaseColumn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ZonedDateTime entityValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entityValue.toLocalDateTime(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ZonedDateTime </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToEntityAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LocalDateTime databaseValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ZonedDateTime.of(databaseValue, ZoneId.systemDefault()); } }</code> </pre> <br>  Insbesondere ist dieses Beispiel sehr einfach, da <code>ZonedDateTime</code> Methoden enthält, die einfach zu konvertieren sind.  Die Konvertierung erfolgt durch Aufrufen der <code>toLocalDateTime()</code> -Methode.  Die inverse Konvertierung kann durchgeführt werden, indem die <code>ZonedDateTimeOf()</code> -Methode <code>ZonedDateTimeOf()</code> und der <code>LocalDateTime</code> Wert zusammen mit <code>ZoneId</code> , um die Zeitzone zu verwenden. <br><br>  <b>Eingebettete Attributkonverter</b> <br><br>  Attributkonverter waren eine sehr schöne Ergänzung zu JPA 2.1, da sie es ermöglichten, Attributtypen flexibler zu gestalten.  Das JPA 2.2-Update bietet eine nützliche Möglichkeit, Attributkonverter implementierbar zu machen.  Dies bedeutet, dass Sie CDI-Ressourcen (Contexts and Dependency Injection) direkt in den Attributkonverter einbetten können.  Diese Änderung steht im Einklang mit anderen CDI-Verbesserungen in den Java EE 8-Spezifikationen, z. B. erweiterten JSF-Konvertern, da diese jetzt auch die CDI-Injektion verwenden können. <br><br>  Um diese neue Funktion nutzen zu können, binden Sie die CDI-Ressourcen nach Bedarf einfach in den Attributkonverter ein.  Listing 2 enthält ein Beispiel für einen Attributkonverter. Jetzt werde ich es auseinander nehmen und alle wichtigen Details erläutern. <br><br>  Die Konverterklasse muss die Schnittstelle <code>javax.persistence.AttributeConverter</code> implementieren und die X- und Y-Werte übergeben. Der X-Wert entspricht dem Datentyp im Java-Objekt und der Y-Wert muss dem Datenbankspaltentyp entsprechen.  Dann sollte die Konverterklasse mit <code>@Converter</code> kommentiert <code>@Converter</code> .  Schließlich muss die Klasse die <code>convertToDatabaseColumn()</code> und <code>convertToEntityAttribute()</code> überschreiben.  Die Implementierung in jeder dieser Methoden sollte Werte von bestimmten Typen und zurück zu diesen konvertieren. <br><br>  Um den Konverter bei jeder Verwendung des angegebenen Datentyps automatisch anzuwenden, fügen Sie wie in <code>@Converter(autoApply=true)</code> " <code>@Converter(autoApply=true)</code> .  Um einen Konverter auf ein einzelnes Attribut anzuwenden, verwenden Sie die Annotation @Converter auf Attributebene, wie hier gezeigt: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Convert</span></span>(converter=LocalDateConverter.java) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalDate workDate;</code> </pre> <br>  Der Konverter kann auch auf Klassenebene angewendet werden: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Convert</span></span>(attributeName=<span class="hljs-string"><span class="hljs-string">"workDate"</span></span>, converter = LocalDateConverter.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . .</code> </pre> <br>  Angenommen, ich möchte die im Feld <code>creditLimit</code> der <code>creditLimit</code> enthaltenen Werte beim <code>creditLimit</code> verschlüsseln.  Um diesen Prozess zu implementieren, müssen die Werte vor dem Speichern verschlüsselt und nach dem Abrufen aus der Datenbank entschlüsselt werden.  Dies kann vom Konverter durchgeführt werden, und mit JPA 2.2 kann ich das Verschlüsselungsobjekt in den Konverter einbetten, um das gewünschte Ergebnis zu erzielen.  Listing 3 enthält ein Beispiel. <br><br>  <i>Listing 3:</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Converter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreditLimitConverter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AttributeConverter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigDecimal</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigDecimal</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> CreditLimitEncryptor encryptor; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BigDecimal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToDatabaseColumn</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BigDecimal entityValue)</span></span></span><span class="hljs-function"> </span></span>{ String encryptedFormat = encryptor.base64encode(entityValue.toString()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BigDecimal.valueOf(Long.valueOf(encryptedFormat)); } ... }</code> </pre> <br>  In diesem Code wird der Prozess ausgeführt, <code>CreditLimitEncryptor</code> Klasse in den Konverter <code>CreditLimitEncryptor</code> und anschließend zur Unterstützung des Prozesses verwendet wird. <br><br>  <b>Streaming-Abfrageergebnisse</b> <br><br>  Jetzt können Sie die Funktionen von Java SE 8-Streams problemlos nutzen, wenn Sie mit Abfrageergebnissen arbeiten.  Threads vereinfachen nicht nur das Lesen, Schreiben und Verwalten von Code, sondern verbessern in einigen Situationen auch die Abfrageleistung.  Einige Thread-Implementierungen tragen auch dazu bei, eine übermäßig große Anzahl von Datenanforderungen gleichzeitig zu vermeiden, obwohl in einigen Fällen die Verwendung der <code>ResultSet</code> Paginierung möglicherweise besser funktioniert als Streams. <br><br>  Um diese Funktion zu aktivieren, wurde die Methode <code>getResultStream()</code> zu den <code>TypedQuery</code> <code>Query</code> und <code>TypedQuery</code> hinzugefügt.  Diese geringfügige Änderung ermöglicht es JPA, einfach einen Ergebnisstrom anstelle einer Liste zurückzugeben.  Wenn Sie also mit einem großen <code>ResultSet</code> , ist es sinnvoll, die Leistung zwischen einer neuen Thread-Implementierung und einem scrollbaren <code>ResultSets</code> oder einer Paginierung zu vergleichen.  Der Grund dafür ist, dass Thread-Implementierungen alle Datensätze auf einmal abrufen, in einer Liste speichern und dann zurückgeben.  Eine scrollbare <code>ResultSet</code> und Paginierungstechnik ruft Daten stückweise ab, was für große Datenmengen möglicherweise besser ist. <br><br>  Persistenzanbieter können beschließen, die neue Methode <code>getResultStream()</code> verbesserter Implementierung zu überschreiben.  Der <code>ResultSet</code> enthält bereits eine stream () -Methode, die ein scrollbares <code>ResultSet</code> , um die Ergebnisse von Datensätzen zu analysieren, anstatt sie vollständig zurückzugeben.  Dadurch kann Hibernate mit sehr großen Datenmengen arbeiten und dies gut tun.  Es ist zu erwarten, dass andere Anbieter diese Methode überschreiben, um ähnliche Funktionen bereitzustellen, die für JPA von Vorteil sind. <br><br>  Neben der Leistung ist die Möglichkeit, Ergebnisse zu streamen, eine nette Ergänzung zu JPA, die eine bequeme Möglichkeit bietet, mit Daten zu arbeiten.  Ich werde einige Szenarien demonstrieren, in denen dies nützlich sein kann, aber die Möglichkeiten selbst sind endlos.  In beiden Szenarien frage ich die <code>Job</code> Entität ab und gebe den Stream zurück.  Schauen Sie sich zunächst den folgenden Code an, in dem ich den <code>Jobs</code> Stream einfach gegen einen bestimmten <code>Customer</code> analysiere, indem ich die Schnittstellenmethode <code>getResultStream()</code> von <code>Query</code> <code>getResultStream()</code> .  Dann verwende ich diesen Thread, um Details zu <code>customer</code> und <code>work date</code> Job'a auszugeben. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByCustomer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PoolCustomer customer)</span></span></span></span>{ Stream&lt;Job&gt; jobList = em.createQuery(<span class="hljs-string"><span class="hljs-string">"select object(o) from Job o "</span></span> + <span class="hljs-string"><span class="hljs-string">"where o.customer = :customer"</span></span>) .setParameter(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>, customer) .getResultStream(); jobList.map(j -&gt; j.getCustomerId() + <span class="hljs-string"><span class="hljs-string">" ordered job "</span></span> + j.getId() + <span class="hljs-string"><span class="hljs-string">" - Starting "</span></span> + j.getWorkDate()) .forEach(jm -&gt; System.out.println(jm)); }</code> </pre> <br><br>  Diese Methode kann leicht geändert werden, sodass mit der <code>Collectors .toList()</code> -Methode eine Liste der Ergebnisse wie folgt zurückgegeben wird. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Job&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByCustomer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PoolCustomer customer)</span></span></span></span>{ Stream&lt;Job&gt; jobList = em.createQuery( <span class="hljs-string"><span class="hljs-string">"select object(o) from Job o "</span></span> + <span class="hljs-string"><span class="hljs-string">"where o.customerId = :customer"</span></span>) .setParameter(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>, customer) .getResultStream(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jobList.collect(Collectors.toList()); }</code> </pre> <br>  In dem folgenden Szenario, das unten gezeigt wird, finde ich eine <code>List</code> Aufgaben, die sich auf Pools eines bestimmten Formulars beziehen.  In diesem Fall gebe ich alle Aufgaben zurück, die dem als Zeichenfolge übermittelten Formular entsprechen.  Ähnlich wie im ersten Beispiel gebe ich zuerst einen Stream von <code>Jobs</code> Datensätzen zurück.  Dann filtere ich Datensätze basierend auf dem Kundenpoolformular.  Wie Sie sehen können, ist der resultierende Code sehr kompakt und leicht zu lesen. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Job&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByCustPoolShape</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String poolShape)</span></span></span></span>{ Stream&lt;Job&gt; jobstream = em.createQuery( <span class="hljs-string"><span class="hljs-string">"select object(o) from Job o"</span></span>) .getResultStream(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jobstream.filter( c -&gt; poolShape.equals(c.getCustomerId().getPoolId().getShape())) .collect(Collectors.toList()); }</code> </pre><br>  Wie bereits erwähnt, ist es wichtig, die Leistung in Szenarien zu berücksichtigen, in denen große Datenmengen zurückgegeben werden.  Es gibt Bedingungen, unter denen Threads beim Abfragen von Datenbanken nützlicher sind, aber es gibt auch Bedingungen, unter denen sie zu Leistungseinbußen führen können.  Eine gute Faustregel lautet: Wenn Daten im Rahmen einer SQL-Abfrage abgefragt werden können, ist es sinnvoll, genau das zu tun.  Manchmal überwiegen die Vorteile der Verwendung einer eleganten Thread-Syntax nicht die beste Leistung, die mit der Standard-SQL-Filterung erzielt werden kann. <br><br>  <b>Unterstützung für doppelte Anmerkungen</b> <br><br>  Mit der Veröffentlichung von Java SE 8 wurden doppelte Anmerkungen möglich, sodass Sie Anmerkungen in der Deklaration wiederverwenden können.  In einigen Situationen muss dieselbe Anmerkung für eine Klasse oder ein Feld mehrmals verwendet werden.  Beispielsweise kann es für eine bestimmte Entitätsklasse mehr als eine <code>@SqlResultSetMapping</code> Annotation geben.  In Situationen, in denen die Unterstützung für eine erneute Annotation erforderlich ist, sollte eine Container-Annotation verwendet werden.  Doppelte Anmerkungen reduzieren nicht nur die Notwendigkeit, Sammlungen identischer Anmerkungen in Containeranmerkungen zu verpacken, sondern können auch das Lesen von Code erleichtern. <br><br>  Dies funktioniert wie folgt: Die Implementierung der Annotation-Klasse sollte mit der Meta-Annotation <code>@Repeatable</code> gekennzeichnet werden, um anzuzeigen, dass sie mehrmals verwendet werden kann.  Die <code>@Repeatable</code> nimmt den Typ der Containeranmerkungsklasse an.  Beispielsweise ist die Annotationsklasse <code>NamedQuery</code> jetzt mit der Annotation <code>@Repeatable(NamedQueries.class)</code> .  In diesem Fall wird die Container-Annotation noch verwendet, aber Sie müssen nicht darüber nachdenken, wenn Sie dieselbe Annotation für die Deklaration oder Klasse verwenden, da <code>@Repeatable</code> dieses Detail abstrahiert. <br><br>  Wir geben ein Beispiel.  Wenn Sie einer Entitätsklasse in JPA 2.1 mehr als eine <code>@NamedQuery</code> Annotation hinzufügen möchten, müssen Sie diese in die <code>@NamedQueries</code> Annotation <code>@NamedQueries</code> , wie in Listing 4 gezeigt. <br><br>  <i>Listing 4:</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"CUSTOMER"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@XmlRootElement</span></span> <span class="hljs-meta"><span class="hljs-meta">@NamedQueries</span></span>({ <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findAll"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c"</span></span>) , <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByCustomerId"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.customerId = :customerId"</span></span>) , <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByName"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.name = :name"</span></span>) . . .)}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Customer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . . }</code> </pre> <br>  In JPA 2.2 ist jedoch alles anders.  Da <code>@NamedQuery</code> eine doppelte Annotation ist, kann sie in der Entitätsklasse mehrmals angegeben werden, wie in Listing 5 gezeigt. <br><br>  <i>Listing 5:</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"CUSTOMER"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@XmlRootElement</span></span> <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findAll"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByCustomerId"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.customerId = :customerId"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByName"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.name = :name"</span></span>) . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Customer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . . }</code> </pre> <br>  Liste der doppelten Anmerkungen: <br><br><ul><li> <code>@AssociationOverride</code> </li> <li> <code>@AttributeOverride</code> </li> <li> <code>@Convert</code> </li> <li> <code>@JoinColumn</code> </li> <li> <code>@MapKeyJoinColumn</code> </li> <li> <code>@NamedEntityGraphy</code> </li> <li> <code>@NamedNativeQuery</code> </li> <li> <code>@NamedQuery</code> </li> <li> <code>@NamedStoredProcedureQuery</code> </li> <li> <code>@PersistenceContext</code> </li> <li> <code>@PersistenceUnit</code> </li> <li> <code>@PrimaryKeyJoinColumn</code> </li> <li> <code>@SecondaryTable</code> </li> <li> <code>@SqlResultSetMapping</code> </li> </ul><br>  <b>Fazit</b> <br><br>  Die JPA 2.2-Version enthält einige Änderungen, die enthaltenen Verbesserungen sind jedoch erheblich.  Schließlich ist der JPA auf Java SE 8 ausgerichtet, sodass Entwickler Funktionen wie die Datums- und Uhrzeit-API verwenden, Abfrageergebnisse streamen und Anmerkungen wiederholen können.  Diese Version verbessert auch die CDI-Konsistenz, indem die Möglichkeit hinzugefügt wird, CDI-Ressourcen in Attributkonverter einzubetten.  JPA 2.2 ist jetzt verfügbar und Teil von Java EE 8. Ich denke, Sie werden es gerne verwenden. <br><br>  DAS ENDE <br><br>  Wie immer warten wir auf Fragen und Kommentare. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423195/">https://habr.com/ru/post/de423195/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423185/index.html">Iss es nicht! Nützlicher 3D-Zuckerdruck</a></li>
<li><a href="../de423187/index.html">Stamm- und Zwischenzertifikate autorisierter Zertifizierungsstellen Russlands</a></li>
<li><a href="../de423189/index.html">Forschung: Die Hälfte der Unternehmen behebt Schwachstellen innerhalb eines Monats - warum?</a></li>
<li><a href="../de423191/index.html">Einführung der Elemente von Offshore-Plattformen. Teil 1</a></li>
<li><a href="../de423193/index.html">Konfigurieren Sie Web-Push-Benachrichtigungen mithilfe von pywebpush Schritt für Schritt</a></li>
<li><a href="../de423197/index.html">LOLWUT: ein Kunstwerk in einem DB-Team</a></li>
<li><a href="../de423203/index.html">Cooler Teamleiter wird für den Service verantwortlich sein</a></li>
<li><a href="../de423205/index.html">Speicherprojekt auf MS SQL Server, Integration in 1C 7.7 und Entwicklungsautomatisierung in SSDT</a></li>
<li><a href="../de423207/index.html">So erstellen Sie ein automatisches Update eines Online-Spieleclients</a></li>
<li><a href="../de423209/index.html">Killer Form 2? Übersicht über den MoonRay S100 Dental 3D-Drucker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>