<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüè´ üòÆ üò´ PHPUnit. "Comment puis-je tester mon putain de contr√¥leur", ou tester les sceptiques ü§òüèø üéÖüèΩ ü¶é</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, Habr. 



 Oui, c'est un autre article sur le th√®me des tests. Il semblerait qu'ici il soit d√©j√† possible de discuter? Tous ceux qui en ont bes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PHPUnit. "Comment puis-je tester mon putain de contr√¥leur", ou tester les sceptiques</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485418/">  Salut, Habr. <br><br><img src="https://habrastorage.org/webt/do/li/as/doliasx6rmfzgqhvfc-7jdazq-w.jpeg" alt="image"><br><br>  Oui, c'est un autre article sur le th√®me des tests.  Il semblerait qu'ici il soit d√©j√† possible de discuter?  Tous ceux qui en ont besoin - ils √©crivent des tests, qui n‚Äôen ont pas besoin - ils n‚Äô√©crivent pas, tout le monde est content!  Le fait est que la plupart des articles sur les tests unitaires ont ... comment offenser personne ... des exemples idiots!  Non, vraiment!  Aujourd'hui, je vais essayer de le r√©parer.  Je demande un chat. <br><a name="habracut"></a><br>  Et donc, une recherche rapide sur le th√®me des tests trouve juste beaucoup d'articles, qui dans leur masse sont divis√©s en deux cat√©gories: <br><br>  1) Le bonheur d'un r√©dacteur publicitaire.  Nous voyons d'abord une longue introduction, puis l'histoire des tests unitaires dans la Russie antique, puis dix hacks de vie avec des tests, et √† la fin un exemple.  Avec des tests de code comme celui-ci: <br><br><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Calculator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($a, $b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $a + $b; } }</code> </pre> <br>  Et je ne plaisante pas pour le moment.  J'ai vraiment vu des articles avec une ¬´calculatrice¬ª comme guide d'√©tude.  Oui, oui, je comprends que pour commencer il faut tout simplifier, abstractions, va-et-vient ... Mais c'est l√† que tout se termine!  Et puis finir le hibou, comme on dit <br><br>  2) Exemples trop sophistiqu√©s.  √âcrivons un test, entassons-le dans Gitlab CI, puis nous le corrigerons automatiquement si le test r√©ussit, et nous appliquerons Infection PHP aux tests, mais nous connecterons tout √† Hudson.  Et ainsi de suite dans ce style.  Cela semble utile, mais il semble que ce ne soit pas du tout ce que vous recherchez.  Mais vous voulez juste augmenter l√©g√®rement la stabilit√© de votre projet.  Et toutes ces continuit√©s - enfin, pas toutes √† la fois. <br><br>  En cons√©quence, les gens doutent: "Mais en ai-je besoin?"  √Ä mon tour, je veux essayer d'expliquer plus clairement les tests.  Et faites une r√©servation tout de suite - je suis d√©veloppeur, je ne suis pas testeur.  Je suis s√ªr que moi-m√™me je ne sais pas grand-chose et mon premier mot dans ma vie n'√©tait pas le mot ¬´mok¬ª.  Je n'ai m√™me jamais travaill√© sur TDD!  Mais je sais avec certitude que m√™me mon niveau actuel de comp√©tences m'a permis de couvrir plusieurs projets avec des tests, et ces m√™mes tests ont d√©j√† d√©tect√© une douzaine de bugs.  Et si cela m'a aid√©, cela pourrait aider quelqu'un d'autre.  Certains bogues captur√©s seraient difficiles √† d√©tecter manuellement. <br><br>  Pour commencer, un court programme √©ducatif au format question-r√©ponse: <br><br>  Q: Dois-je utiliser une sorte de framework?  Et si j'ai Yii?  Et si Kohana?  Et si% one_more_framework_name%? <br>  R: Non, PHPUnit est un framework de test ind√©pendant, vous pouvez m√™me le visser au code h√©rit√© sur un framework self-made. <br><br>  Q: Et maintenant, je parcoure rapidement le site avec mes mains, et c'est normal.  Pourquoi en ai-je besoin? <br>  R: L'ex√©cution de plusieurs dizaines de tests dure plusieurs secondes.  Les tests automatiques sont toujours plus rapides que les tests manuels, et avec des tests de haute qualit√©, ils sont √©galement plus fiables, car ils couvrent tous les sc√©narios. <br><br>  Q: J'ai un code h√©rit√© avec des fonctions de 2000 lignes.  Puis-je tester cela? <br>  R: Oui et non.  En th√©orie, oui, tout code peut √™tre couvert par un test.  En pratique, le code doit √™tre √©crit avec une base pour les tests futurs.  Une fonction de ligne 2000 aura trop de d√©pendances, de branches, de cas fronti√®res.  Il se peut que cela finisse par couvrir tout cela, mais cela vous prendra probablement un temps inacceptable.  Plus le code est bon, plus il est facile de le tester.  Plus la responsabilit√© unique est respect√©e, plus les tests seront faciles.  Pour tester le plus souvent d'anciens projets, vous devez d'abord les refactoriser froidement. <br><br><img src="https://habrastorage.org/webt/c5/oa/ze/c5oaze8gmau8ticskgu44o5wyza.jpeg" alt="image"><br><br>  Q: J'ai des m√©thodes (fonctions) tr√®s simples, qu'y a-t-il √† tester?  Tout y est fiable, il n'y a pas de place √† l'erreur! <br>  R: Il faut comprendre que vous ne testez pas l'impl√©mentation correcte de la fonction (si vous n'avez pas TDD), vous ¬´fixez¬ª simplement son √©tat de fonctionnement actuel.  √Ä l'avenir, lorsque vous devrez le modifier, vous pourrez rapidement d√©terminer si vous avez rompu son comportement √† l'aide du test.  Exemple: il existe une fonction qui valide le courrier √©lectronique.  Elle en fait un habitu√©. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($email)</span></span></span><span class="hljs-function"> </span></span>{ $regex = <span class="hljs-string"><span class="hljs-string">"very_complex_regex_here"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_array($email)) { $result = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($email <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $item) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (preg_match($regex, $item) === <span class="hljs-number"><span class="hljs-number">0</span></span>) { $result = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $result = preg_match($regex, $emai) ==! <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $result; }</code> </pre><br>  Tout votre code s'attend √† ce que si vous passez un e-mail valide √† cette fonction, il reviendra vrai.  Un tableau d'e-mails valides est √©galement vrai.  Un tableau avec au moins une adresse e-mail non valide est faux.  Eh bien et ainsi de suite, le code est clair.  Mais le jour est venu, et vous avez d√©cid√© de remplacer la monstrueuse saison r√©guli√®re par une API externe.  Mais comment garantir que la fonction r√©√©crite n'a pas chang√© le principe de fonctionnement?  Soudain, il ne g√®re pas bien le tableau?  Ou reviendra-t-il pas bool√©en?  Et les tests peuvent garder cela sous contr√¥le.  Un test bien √©crit indiquera imm√©diatement un comportement de fonction autre que pr√©vu. <br><br>  Q: Quand vais-je commencer √† voir le sens des tests? <br>  R: Premi√®rement, d√®s que vous couvrez une partie importante du code.  Plus la couverture est proche de 100%, plus les tests sont fiables.  Deuxi√®mement, d√®s que vous devez apporter des modifications globales ou des modifications dans la partie complexe du code.  Les tests peuvent d√©tecter des probl√®mes qui peuvent √™tre facilement ignor√©s manuellement (cas limites).  Troisi√®mement, lors de la r√©daction des tests eux-m√™mes!  Il arrive souvent que l'√©criture d'un test r√©v√®le des d√©fauts de code qui ne sont pas visibles √† premi√®re vue. <br><br>  Q: Eh bien, j'ai un site Web sur laravel.  Le site n'est pas une fonction, le site est une montagne de code merdique.  Comment tester ici? <br>  R: C'est ce qui sera discut√© plus tard.  En bref: nous testons s√©par√©ment les m√©thodes des contr√¥leurs, s√©par√©ment le middleware, s√©par√©ment les services, etc. <br><br>  L'une des id√©es des tests unitaires consiste √† isoler la section de code test√©e.  Moins vous testez de code avec un seul test, mieux c'est.  Regardons un exemple aussi proche que possible de la vie r√©elle: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($userService, $emailService)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;userService = $userService; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;emailService = $emailService; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($request)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($request-&gt;login) || <span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($request-&gt;password)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Auth error"</span></span>; } $password = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;userService-&gt;getPasswordFor($request-&gt;login); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($password)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Auth error - no password"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($password !== $request-&gt;password) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Incorrect password"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;emailService-&gt;sendEmail($request-&gt;login); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Success"</span></span>; } } <span class="hljs-comment"><span class="hljs-comment">// .... /* somewhere in project core */ $controller = new Controller($userService, $emailService); $controller-&gt;login($request);</span></span></code> </pre> <br>  Il s'agit d'une m√©thode tr√®s typique de connexion au syst√®me sur de petits projets.  Tout ce que nous attendons, ce sont les messages d'erreur corrects et l'e-mail envoy√© en cas de connexion r√©ussie.  Comment tester cette m√©thode?  Tout d'abord, vous devez identifier les d√©pendances externes.  Dans notre cas, il y en a deux - $ userService et $ emailService.  Ils sont pass√©s par le constructeur de classe, ce qui facilite grandement notre t√¢che.  Mais, comme mentionn√© pr√©c√©demment, moins nous testons de code en un seul passage, mieux c'est. <br><br>  L'√©mulation, la substitution d'objets est appel√©e mokanem (de l'anglais. Mock object, litt√©ralement: "object-parody").  Personne ne prend la peine d'√©crire de tels objets manuellement, mais tout a √©t√© invent√© avant nous, alors une biblioth√®que aussi merveilleuse que <a href="https://github.com/mockery/mockery" rel="nofollow">Mockery</a> vient √† la rescousse.  Cr√©ons des mokas pour les services. <br><br><pre> <code class="php hljs">$userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); $emailService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'email_service'</span></span>);</code> </pre> <br>  Cr√©ez maintenant l'objet $ request.  Pour commencer, nous allons tester la logique de v√©rification des champs de connexion et de mot de passe.  Nous voulons √™tre s√ªrs que s'il n'y en a pas, notre m√©thode traitera correctement ce cas et retournera le message (!) Souhait√©. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEmptyLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); $emailService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'email_service'</span></span>); $controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Controller($userService, $emailService); $request = (object) []; $result = $controller-&gt;login($request); }</code> </pre><br>  Rien de compliqu√©, non?  Nous avons cr√©√© des stubs pour les param√®tres de classe n√©cessaires, cr√©√© une instance de la classe souhait√©e et "tir√©" la m√©thode souhait√©e, en passant une demande d√©lib√©r√©ment erron√©e.  J'ai une r√©ponse.  Mais comment le v√©rifier maintenant?  C'est la partie la plus importante du test - la soi-disant assertion.  PHPUnit a des dizaines d' <a href="https://phpunit.readthedocs.io/ru/latest/assertions.html" rel="nofollow">assertions</a> pr√™tes √† l'emploi.  Utilisez simplement l'un d'eux. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEmptyLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); $emailService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'email_service'</span></span>); $controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Controller($userService, $emailService); $request = (object) []; $result = $controller-&gt;login($request); <span class="hljs-comment"><span class="hljs-comment">// vv assertion here! vv $this-&gt;assertEquals("Auth error", $result); }</span></span></code> </pre><br>  Ce test garantit ce qui suit - si l'argument de connexion arrive √† l'objet de m√©thode qui n'a pas le champ de connexion ou de mot de passe, alors la m√©thode renverra la cha√Æne "Auth error".  C'est, en g√©n√©ral, tout.  Si simple - mais si utile, car nous pouvons maintenant modifier la m√©thode de connexion sans craindre de casser quelque chose.  Notre frontend peut √™tre s√ªr que si quelque chose se produit - il obtiendra exactement une telle erreur.  Et si quelqu'un casse ce comportement (par exemple, d√©cide de changer le texte d'erreur), le test le signalera imm√©diatement!  Nous ajoutons les ch√®ques restants pour couvrir autant de sc√©narios possibles que possible. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEmptyPassword</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// $userService-&gt;getPasswordFor(__any__arg__); // '' $userService-&gt;shouldReceive('getPasswordFor')-&gt;andReturn(''); $emailService = Mockery::mock('email_service'); $request = (object) [ 'login' =&gt; 'john', 'pass' =&gt; '1234' ]; $result = (new Controller($userService, $emailService))-&gt;login($request); $this-&gt;assertEquals("Auth error - no password", $result); } function testUncorrectPassword() { $userService = Mockery::mock('user_service'); // $userService-&gt;getPasswordFor(__any__arg__); // '4321' $userService-&gt;shouldReceive('getPasswordFor')-&gt;andReturn('4321'); $emailService = Mockery::mock('email_service'); $request = (object) [ 'login' =&gt; 'john', 'pass' =&gt; '1234' ]; $result = (new Controller($userService, $emailService))-&gt;login($request); $this-&gt;assertEquals("Incorrect password", $result); } function testSuccessfullLogin() { $userService = Mockery::mock('user_service'); // $userService-&gt;getPasswordFor(__any__arg__); // '1234' $userService-&gt;shouldReceive('getPasswordFor')-&gt;andReturn('1234'); $emailService = Mockery::mock('email_service'); $request = (object) [ 'login' =&gt; 'john', 'pass' =&gt; '1234' ]; $result = (new Controller($userService, $emailService))-&gt;login($request); $this-&gt;assertEquals("Success", $result); }</span></span></code> </pre><br>  Remarquez les m√©thodes shouldReceive et andReturn?  Ils nous permettent de cr√©er des m√©thodes dans des talons qui ne renvoient que ce dont nous avons besoin.  Besoin de tester la mauvaise erreur de mot de passe?  Nous √©crivons un stub $ userService qui renvoie toujours le mauvais mot de passe.  Et c'est tout. <br><br>  Et qu'en est-il des d√©pendances, demandez-vous.  Nous les avons ensuite ¬´noy√©s¬ª et que se passe-t-il s‚Äôils se cassent?  Mais c'est exactement √† cela que sert la couverture de code maximale avec les tests.  Nous ne v√©rifierons pas le fonctionnement de ces services dans le cadre de la connexion - nous testerons la connexion dans l'espoir du bon fonctionnement des services.  Et puis nous √©crivons les m√™mes tests isol√©s pour ces services.  Et puis teste leurs d√©pendances.  Et ainsi de suite.  Par cons√©quent, chaque test individuel garantit <b>uniquement le</b> bon fonctionnement d'un petit morceau de code, √† condition que toutes ses d√©pendances fonctionnent correctement.  Et comme toutes les d√©pendances sont √©galement couvertes par des tests, leur bon fonctionnement est √©galement garanti.  En cons√©quence, toute modification du syst√®me qui rompt la logique du travail m√™me du plus petit morceau de code appara√Ætra imm√©diatement dans un test particulier.  Comment ex√©cuter sp√©cifiquement le test - Je ne dirai pas, la documentation de PHPUnit est assez bonne.  Et dans Laravel, par exemple, il suffit d'ex√©cuter vendor / bin / phpunit √† partir de la racine du projet pour voir un message comme celui-ci <br><br><img src="https://habrastorage.org/webt/va/bc/co/vabccob2dpo9xiqk7ek9syxinmo.jpeg" alt="image">  - Tous les tests ont r√©ussi.  Ou quelque chose comme √ßa <br><br><img src="https://habrastorage.org/webt/bh/mc/pu/bhmcpuar0iluxa8nxxmwrkdgvqs.jpeg" alt="image">  L'une des sept affirmations a √©chou√©. <br><br>  "Bien s√ªr, c'est cool, mais qu'est-ce que je ne peux pas mettre la main sur?" Vous demandez.  Et imaginons le code suivant pour cela <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($infoApi, $userName)</span></span></span><span class="hljs-function"> </span></span>{ $response = $infoApi-&gt;getInfo($userName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($response-&gt;status === <span class="hljs-string"><span class="hljs-string">"API Error"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $response-&gt;result; } <span class="hljs-comment"><span class="hljs-comment">// ... somewhere in system $api = new ExternalApi(); $info = getInfo($api, 'John'); if ($info === null) { die('Api is down'); } echo $info;</span></span></code> </pre><br>  Nous voyons un mod√®le simplifi√© de travail avec une API externe.  La fonction utilise une classe pour fonctionner avec l'API et, en cas d'erreur, renvoie null.  Si, lors de l'utilisation de cette fonction, nous obtenons null, nous devons "d√©clencher la panique" (envoyer un message au jeu, ou envoyer un e-mail au d√©veloppeur, ou jeter une erreur dans le kibana. Oui, un tas d'options).  Tout semble simple, non?  Mais imaginez qu'apr√®s un certain temps, un autre d√©veloppeur a d√©cid√© de ¬´r√©parer¬ª cette fonction.  Il a d√©cid√© que le retour nul est le si√®cle dernier et il devrait lever une exception. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($infoApi, $userName)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ $response = $infoApi-&gt;getInfo($userName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($response-&gt;status === <span class="hljs-string"><span class="hljs-string">"API Error"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApiException($response); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $response-&gt;result; }</code> </pre><br>  Et il a m√™me r√©√©crit toutes les sections du code o√π cette fonction √©tait appel√©e!  Tous sauf un.  Il lui manquait.  Distrait, fatigu√©, juste faux - mais on ne sait jamais.  Le fait est qu'un morceau de code attend toujours l'ancien comportement de la fonction.  Et PHP n'est pas Java pour nous - nous n'obtiendrons pas d'erreur de compilation au motif que la fonction jetable n'est pas encapsul√©e dans try-catch.  Par cons√©quent, dans l'un des 100 sc√©narios d'utilisation du site, en cas de baisse de l'API, nous ne recevrons pas de message du syst√®me.  De plus, avec des tests manuels, nous ne verrons probablement pas cette version de l'√©v√©nement.  L'API est externe, elle ne d√©pend pas de nous, elle fonctionne bien - et tr√®s probablement nous ne la mettrons pas la main en cas de panne de l'API et de gestion incorrecte des exceptions.  Mais si nous avons des tests, ils intercepteront tr√®s bien ce cas, car la classe ExternalApi est "√©touff√©e" dans un certain nombre de tests, et elle √©mule √† la fois un comportement normal et un crash.  Et le prochain test va tomber <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testApiFail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $api = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'api'</span></span>); $api-&gt;shouldReceive(<span class="hljs-string"><span class="hljs-string">'getInfo'</span></span>)-&gt;andReturn((object) [ <span class="hljs-string"><span class="hljs-string">'status'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'API Error'</span></span> ]); $result = getInfo($api, <span class="hljs-string"><span class="hljs-string">'name'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertNull($result); }</code> </pre><br>  Cette information est en fait suffisante.  Si vous n'avez pas de nouilles Legacy, apr√®s 20-30 minutes, vous pouvez passer votre premier test.  Et quelques semaines plus tard - pour apprendre quelque chose de nouveau, cool, revenez aux commentaires sous ce post, et √©crivez quel auteur le govnokoder ne conna√Æt pas% framework_name%, et √©crit de mauvais tests, mais vous devez faire% this_way%.  Et je serai tr√®s heureux dans ce cas.  Cela signifiera que mon objectif a √©t√© atteint: quelqu'un d'autre a d√©couvert les tests par lui-m√™me et a un peu augment√© le niveau g√©n√©ral de professionnalisme dans notre domaine! <br><br>  Une critique raisonn√©e est la bienvenue. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr485418/">https://habr.com/ru/post/fr485418/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr485394/index.html">Comment est n√©e l'infrastructure Internet</a></li>
<li><a href="../fr485396/index.html">Bilan de sant√© de l'effectif: mesurer la sant√© de l'√©quipe</a></li>
<li><a href="../fr485398/index.html">PostgreSQL Antipatterns: hit hit on heavy JOIN</a></li>
<li><a href="../fr485404/index.html">Nous r√©alisons l'effet visuel du film "The Matrix"</a></li>
<li><a href="../fr485416/index.html">Des moyens pratiques pour cartographier les donn√©es dans Kotlin</a></li>
<li><a href="../fr485424/index.html">Comment j'enseigne aux enfants Python</a></li>
<li><a href="../fr485426/index.html">Voitures aux Pays-Bas: statistiques et informations pour 2019</a></li>
<li><a href="../fr485428/index.html">Le myst√©rieux programme LyX. Partie 5</a></li>
<li><a href="../fr485430/index.html">√âditeur de texte multi-utilisateurs simple avec chiffrement de bout en bout</a></li>
<li><a href="../fr485438/index.html">Test des composants React UI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>