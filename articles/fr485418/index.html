<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🏫 😮 😫 PHPUnit. "Comment puis-je tester mon putain de contrôleur", ou tester les sceptiques 🤘🏿 🎅🏽 🦎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, Habr. 



 Oui, c'est un autre article sur le thème des tests. Il semblerait qu'ici il soit déjà possible de discuter? Tous ceux qui en ont bes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PHPUnit. "Comment puis-je tester mon putain de contrôleur", ou tester les sceptiques</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485418/">  Salut, Habr. <br><br><img src="https://habrastorage.org/webt/do/li/as/doliasx6rmfzgqhvfc-7jdazq-w.jpeg" alt="image"><br><br>  Oui, c'est un autre article sur le thème des tests.  Il semblerait qu'ici il soit déjà possible de discuter?  Tous ceux qui en ont besoin - ils écrivent des tests, qui n’en ont pas besoin - ils n’écrivent pas, tout le monde est content!  Le fait est que la plupart des articles sur les tests unitaires ont ... comment offenser personne ... des exemples idiots!  Non, vraiment!  Aujourd'hui, je vais essayer de le réparer.  Je demande un chat. <br><a name="habracut"></a><br>  Et donc, une recherche rapide sur le thème des tests trouve juste beaucoup d'articles, qui dans leur masse sont divisés en deux catégories: <br><br>  1) Le bonheur d'un rédacteur publicitaire.  Nous voyons d'abord une longue introduction, puis l'histoire des tests unitaires dans la Russie antique, puis dix hacks de vie avec des tests, et à la fin un exemple.  Avec des tests de code comme celui-ci: <br><br><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Calculator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($a, $b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $a + $b; } }</code> </pre> <br>  Et je ne plaisante pas pour le moment.  J'ai vraiment vu des articles avec une «calculatrice» comme guide d'étude.  Oui, oui, je comprends que pour commencer il faut tout simplifier, abstractions, va-et-vient ... Mais c'est là que tout se termine!  Et puis finir le hibou, comme on dit <br><br>  2) Exemples trop sophistiqués.  Écrivons un test, entassons-le dans Gitlab CI, puis nous le corrigerons automatiquement si le test réussit, et nous appliquerons Infection PHP aux tests, mais nous connecterons tout à Hudson.  Et ainsi de suite dans ce style.  Cela semble utile, mais il semble que ce ne soit pas du tout ce que vous recherchez.  Mais vous voulez juste augmenter légèrement la stabilité de votre projet.  Et toutes ces continuités - enfin, pas toutes à la fois. <br><br>  En conséquence, les gens doutent: "Mais en ai-je besoin?"  À mon tour, je veux essayer d'expliquer plus clairement les tests.  Et faites une réservation tout de suite - je suis développeur, je ne suis pas testeur.  Je suis sûr que moi-même je ne sais pas grand-chose et mon premier mot dans ma vie n'était pas le mot «mok».  Je n'ai même jamais travaillé sur TDD!  Mais je sais avec certitude que même mon niveau actuel de compétences m'a permis de couvrir plusieurs projets avec des tests, et ces mêmes tests ont déjà détecté une douzaine de bugs.  Et si cela m'a aidé, cela pourrait aider quelqu'un d'autre.  Certains bogues capturés seraient difficiles à détecter manuellement. <br><br>  Pour commencer, un court programme éducatif au format question-réponse: <br><br>  Q: Dois-je utiliser une sorte de framework?  Et si j'ai Yii?  Et si Kohana?  Et si% one_more_framework_name%? <br>  R: Non, PHPUnit est un framework de test indépendant, vous pouvez même le visser au code hérité sur un framework self-made. <br><br>  Q: Et maintenant, je parcoure rapidement le site avec mes mains, et c'est normal.  Pourquoi en ai-je besoin? <br>  R: L'exécution de plusieurs dizaines de tests dure plusieurs secondes.  Les tests automatiques sont toujours plus rapides que les tests manuels, et avec des tests de haute qualité, ils sont également plus fiables, car ils couvrent tous les scénarios. <br><br>  Q: J'ai un code hérité avec des fonctions de 2000 lignes.  Puis-je tester cela? <br>  R: Oui et non.  En théorie, oui, tout code peut être couvert par un test.  En pratique, le code doit être écrit avec une base pour les tests futurs.  Une fonction de ligne 2000 aura trop de dépendances, de branches, de cas frontières.  Il se peut que cela finisse par couvrir tout cela, mais cela vous prendra probablement un temps inacceptable.  Plus le code est bon, plus il est facile de le tester.  Plus la responsabilité unique est respectée, plus les tests seront faciles.  Pour tester le plus souvent d'anciens projets, vous devez d'abord les refactoriser froidement. <br><br><img src="https://habrastorage.org/webt/c5/oa/ze/c5oaze8gmau8ticskgu44o5wyza.jpeg" alt="image"><br><br>  Q: J'ai des méthodes (fonctions) très simples, qu'y a-t-il à tester?  Tout y est fiable, il n'y a pas de place à l'erreur! <br>  R: Il faut comprendre que vous ne testez pas l'implémentation correcte de la fonction (si vous n'avez pas TDD), vous «fixez» simplement son état de fonctionnement actuel.  À l'avenir, lorsque vous devrez le modifier, vous pourrez rapidement déterminer si vous avez rompu son comportement à l'aide du test.  Exemple: il existe une fonction qui valide le courrier électronique.  Elle en fait un habitué. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($email)</span></span></span><span class="hljs-function"> </span></span>{ $regex = <span class="hljs-string"><span class="hljs-string">"very_complex_regex_here"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_array($email)) { $result = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($email <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $item) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (preg_match($regex, $item) === <span class="hljs-number"><span class="hljs-number">0</span></span>) { $result = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $result = preg_match($regex, $emai) ==! <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $result; }</code> </pre><br>  Tout votre code s'attend à ce que si vous passez un e-mail valide à cette fonction, il reviendra vrai.  Un tableau d'e-mails valides est également vrai.  Un tableau avec au moins une adresse e-mail non valide est faux.  Eh bien et ainsi de suite, le code est clair.  Mais le jour est venu, et vous avez décidé de remplacer la monstrueuse saison régulière par une API externe.  Mais comment garantir que la fonction réécrite n'a pas changé le principe de fonctionnement?  Soudain, il ne gère pas bien le tableau?  Ou reviendra-t-il pas booléen?  Et les tests peuvent garder cela sous contrôle.  Un test bien écrit indiquera immédiatement un comportement de fonction autre que prévu. <br><br>  Q: Quand vais-je commencer à voir le sens des tests? <br>  R: Premièrement, dès que vous couvrez une partie importante du code.  Plus la couverture est proche de 100%, plus les tests sont fiables.  Deuxièmement, dès que vous devez apporter des modifications globales ou des modifications dans la partie complexe du code.  Les tests peuvent détecter des problèmes qui peuvent être facilement ignorés manuellement (cas limites).  Troisièmement, lors de la rédaction des tests eux-mêmes!  Il arrive souvent que l'écriture d'un test révèle des défauts de code qui ne sont pas visibles à première vue. <br><br>  Q: Eh bien, j'ai un site Web sur laravel.  Le site n'est pas une fonction, le site est une montagne de code merdique.  Comment tester ici? <br>  R: C'est ce qui sera discuté plus tard.  En bref: nous testons séparément les méthodes des contrôleurs, séparément le middleware, séparément les services, etc. <br><br>  L'une des idées des tests unitaires consiste à isoler la section de code testée.  Moins vous testez de code avec un seul test, mieux c'est.  Regardons un exemple aussi proche que possible de la vie réelle: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($userService, $emailService)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;userService = $userService; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;emailService = $emailService; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($request)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($request-&gt;login) || <span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($request-&gt;password)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Auth error"</span></span>; } $password = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;userService-&gt;getPasswordFor($request-&gt;login); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($password)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Auth error - no password"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($password !== $request-&gt;password) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Incorrect password"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;emailService-&gt;sendEmail($request-&gt;login); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Success"</span></span>; } } <span class="hljs-comment"><span class="hljs-comment">// .... /* somewhere in project core */ $controller = new Controller($userService, $emailService); $controller-&gt;login($request);</span></span></code> </pre> <br>  Il s'agit d'une méthode très typique de connexion au système sur de petits projets.  Tout ce que nous attendons, ce sont les messages d'erreur corrects et l'e-mail envoyé en cas de connexion réussie.  Comment tester cette méthode?  Tout d'abord, vous devez identifier les dépendances externes.  Dans notre cas, il y en a deux - $ userService et $ emailService.  Ils sont passés par le constructeur de classe, ce qui facilite grandement notre tâche.  Mais, comme mentionné précédemment, moins nous testons de code en un seul passage, mieux c'est. <br><br>  L'émulation, la substitution d'objets est appelée mokanem (de l'anglais. Mock object, littéralement: "object-parody").  Personne ne prend la peine d'écrire de tels objets manuellement, mais tout a été inventé avant nous, alors une bibliothèque aussi merveilleuse que <a href="https://github.com/mockery/mockery" rel="nofollow">Mockery</a> vient à la rescousse.  Créons des mokas pour les services. <br><br><pre> <code class="php hljs">$userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); $emailService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'email_service'</span></span>);</code> </pre> <br>  Créez maintenant l'objet $ request.  Pour commencer, nous allons tester la logique de vérification des champs de connexion et de mot de passe.  Nous voulons être sûrs que s'il n'y en a pas, notre méthode traitera correctement ce cas et retournera le message (!) Souhaité. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEmptyLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); $emailService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'email_service'</span></span>); $controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Controller($userService, $emailService); $request = (object) []; $result = $controller-&gt;login($request); }</code> </pre><br>  Rien de compliqué, non?  Nous avons créé des stubs pour les paramètres de classe nécessaires, créé une instance de la classe souhaitée et "tiré" la méthode souhaitée, en passant une demande délibérément erronée.  J'ai une réponse.  Mais comment le vérifier maintenant?  C'est la partie la plus importante du test - la soi-disant assertion.  PHPUnit a des dizaines d' <a href="https://phpunit.readthedocs.io/ru/latest/assertions.html" rel="nofollow">assertions</a> prêtes à l'emploi.  Utilisez simplement l'un d'eux. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEmptyLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); $emailService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'email_service'</span></span>); $controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Controller($userService, $emailService); $request = (object) []; $result = $controller-&gt;login($request); <span class="hljs-comment"><span class="hljs-comment">// vv assertion here! vv $this-&gt;assertEquals("Auth error", $result); }</span></span></code> </pre><br>  Ce test garantit ce qui suit - si l'argument de connexion arrive à l'objet de méthode qui n'a pas le champ de connexion ou de mot de passe, alors la méthode renverra la chaîne "Auth error".  C'est, en général, tout.  Si simple - mais si utile, car nous pouvons maintenant modifier la méthode de connexion sans craindre de casser quelque chose.  Notre frontend peut être sûr que si quelque chose se produit - il obtiendra exactement une telle erreur.  Et si quelqu'un casse ce comportement (par exemple, décide de changer le texte d'erreur), le test le signalera immédiatement!  Nous ajoutons les chèques restants pour couvrir autant de scénarios possibles que possible. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEmptyPassword</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// $userService-&gt;getPasswordFor(__any__arg__); // '' $userService-&gt;shouldReceive('getPasswordFor')-&gt;andReturn(''); $emailService = Mockery::mock('email_service'); $request = (object) [ 'login' =&gt; 'john', 'pass' =&gt; '1234' ]; $result = (new Controller($userService, $emailService))-&gt;login($request); $this-&gt;assertEquals("Auth error - no password", $result); } function testUncorrectPassword() { $userService = Mockery::mock('user_service'); // $userService-&gt;getPasswordFor(__any__arg__); // '4321' $userService-&gt;shouldReceive('getPasswordFor')-&gt;andReturn('4321'); $emailService = Mockery::mock('email_service'); $request = (object) [ 'login' =&gt; 'john', 'pass' =&gt; '1234' ]; $result = (new Controller($userService, $emailService))-&gt;login($request); $this-&gt;assertEquals("Incorrect password", $result); } function testSuccessfullLogin() { $userService = Mockery::mock('user_service'); // $userService-&gt;getPasswordFor(__any__arg__); // '1234' $userService-&gt;shouldReceive('getPasswordFor')-&gt;andReturn('1234'); $emailService = Mockery::mock('email_service'); $request = (object) [ 'login' =&gt; 'john', 'pass' =&gt; '1234' ]; $result = (new Controller($userService, $emailService))-&gt;login($request); $this-&gt;assertEquals("Success", $result); }</span></span></code> </pre><br>  Remarquez les méthodes shouldReceive et andReturn?  Ils nous permettent de créer des méthodes dans des talons qui ne renvoient que ce dont nous avons besoin.  Besoin de tester la mauvaise erreur de mot de passe?  Nous écrivons un stub $ userService qui renvoie toujours le mauvais mot de passe.  Et c'est tout. <br><br>  Et qu'en est-il des dépendances, demandez-vous.  Nous les avons ensuite «noyés» et que se passe-t-il s’ils se cassent?  Mais c'est exactement à cela que sert la couverture de code maximale avec les tests.  Nous ne vérifierons pas le fonctionnement de ces services dans le cadre de la connexion - nous testerons la connexion dans l'espoir du bon fonctionnement des services.  Et puis nous écrivons les mêmes tests isolés pour ces services.  Et puis teste leurs dépendances.  Et ainsi de suite.  Par conséquent, chaque test individuel garantit <b>uniquement le</b> bon fonctionnement d'un petit morceau de code, à condition que toutes ses dépendances fonctionnent correctement.  Et comme toutes les dépendances sont également couvertes par des tests, leur bon fonctionnement est également garanti.  En conséquence, toute modification du système qui rompt la logique du travail même du plus petit morceau de code apparaîtra immédiatement dans un test particulier.  Comment exécuter spécifiquement le test - Je ne dirai pas, la documentation de PHPUnit est assez bonne.  Et dans Laravel, par exemple, il suffit d'exécuter vendor / bin / phpunit à partir de la racine du projet pour voir un message comme celui-ci <br><br><img src="https://habrastorage.org/webt/va/bc/co/vabccob2dpo9xiqk7ek9syxinmo.jpeg" alt="image">  - Tous les tests ont réussi.  Ou quelque chose comme ça <br><br><img src="https://habrastorage.org/webt/bh/mc/pu/bhmcpuar0iluxa8nxxmwrkdgvqs.jpeg" alt="image">  L'une des sept affirmations a échoué. <br><br>  "Bien sûr, c'est cool, mais qu'est-ce que je ne peux pas mettre la main sur?" Vous demandez.  Et imaginons le code suivant pour cela <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($infoApi, $userName)</span></span></span><span class="hljs-function"> </span></span>{ $response = $infoApi-&gt;getInfo($userName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($response-&gt;status === <span class="hljs-string"><span class="hljs-string">"API Error"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $response-&gt;result; } <span class="hljs-comment"><span class="hljs-comment">// ... somewhere in system $api = new ExternalApi(); $info = getInfo($api, 'John'); if ($info === null) { die('Api is down'); } echo $info;</span></span></code> </pre><br>  Nous voyons un modèle simplifié de travail avec une API externe.  La fonction utilise une classe pour fonctionner avec l'API et, en cas d'erreur, renvoie null.  Si, lors de l'utilisation de cette fonction, nous obtenons null, nous devons "déclencher la panique" (envoyer un message au jeu, ou envoyer un e-mail au développeur, ou jeter une erreur dans le kibana. Oui, un tas d'options).  Tout semble simple, non?  Mais imaginez qu'après un certain temps, un autre développeur a décidé de «réparer» cette fonction.  Il a décidé que le retour nul est le siècle dernier et il devrait lever une exception. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($infoApi, $userName)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ $response = $infoApi-&gt;getInfo($userName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($response-&gt;status === <span class="hljs-string"><span class="hljs-string">"API Error"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApiException($response); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $response-&gt;result; }</code> </pre><br>  Et il a même réécrit toutes les sections du code où cette fonction était appelée!  Tous sauf un.  Il lui manquait.  Distrait, fatigué, juste faux - mais on ne sait jamais.  Le fait est qu'un morceau de code attend toujours l'ancien comportement de la fonction.  Et PHP n'est pas Java pour nous - nous n'obtiendrons pas d'erreur de compilation au motif que la fonction jetable n'est pas encapsulée dans try-catch.  Par conséquent, dans l'un des 100 scénarios d'utilisation du site, en cas de baisse de l'API, nous ne recevrons pas de message du système.  De plus, avec des tests manuels, nous ne verrons probablement pas cette version de l'événement.  L'API est externe, elle ne dépend pas de nous, elle fonctionne bien - et très probablement nous ne la mettrons pas la main en cas de panne de l'API et de gestion incorrecte des exceptions.  Mais si nous avons des tests, ils intercepteront très bien ce cas, car la classe ExternalApi est "étouffée" dans un certain nombre de tests, et elle émule à la fois un comportement normal et un crash.  Et le prochain test va tomber <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testApiFail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $api = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'api'</span></span>); $api-&gt;shouldReceive(<span class="hljs-string"><span class="hljs-string">'getInfo'</span></span>)-&gt;andReturn((object) [ <span class="hljs-string"><span class="hljs-string">'status'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'API Error'</span></span> ]); $result = getInfo($api, <span class="hljs-string"><span class="hljs-string">'name'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertNull($result); }</code> </pre><br>  Cette information est en fait suffisante.  Si vous n'avez pas de nouilles Legacy, après 20-30 minutes, vous pouvez passer votre premier test.  Et quelques semaines plus tard - pour apprendre quelque chose de nouveau, cool, revenez aux commentaires sous ce post, et écrivez quel auteur le govnokoder ne connaît pas% framework_name%, et écrit de mauvais tests, mais vous devez faire% this_way%.  Et je serai très heureux dans ce cas.  Cela signifiera que mon objectif a été atteint: quelqu'un d'autre a découvert les tests par lui-même et a un peu augmenté le niveau général de professionnalisme dans notre domaine! <br><br>  Une critique raisonnée est la bienvenue. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr485418/">https://habr.com/ru/post/fr485418/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr485394/index.html">Comment est née l'infrastructure Internet</a></li>
<li><a href="../fr485396/index.html">Bilan de santé de l'effectif: mesurer la santé de l'équipe</a></li>
<li><a href="../fr485398/index.html">PostgreSQL Antipatterns: hit hit on heavy JOIN</a></li>
<li><a href="../fr485404/index.html">Nous réalisons l'effet visuel du film "The Matrix"</a></li>
<li><a href="../fr485416/index.html">Des moyens pratiques pour cartographier les données dans Kotlin</a></li>
<li><a href="../fr485424/index.html">Comment j'enseigne aux enfants Python</a></li>
<li><a href="../fr485426/index.html">Voitures aux Pays-Bas: statistiques et informations pour 2019</a></li>
<li><a href="../fr485428/index.html">Le mystérieux programme LyX. Partie 5</a></li>
<li><a href="../fr485430/index.html">Éditeur de texte multi-utilisateurs simple avec chiffrement de bout en bout</a></li>
<li><a href="../fr485438/index.html">Test des composants React UI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>