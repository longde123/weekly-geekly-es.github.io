<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüíº ü§ù üßöüèΩ Funktionen zum Dokumentieren von PostgreSQL-Datenbanken. Teil eins ü•ä üôçüèº ‚ôàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="W√§hrend der Arbeit mit PostgreSQL haben sich mehr als hundert Funktionen f√ºr die Arbeit mit Systemverzeichnissen angesammelt: pg_class, pg_attribute, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionen zum Dokumentieren von PostgreSQL-Datenbanken. Teil eins</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415575/">  W√§hrend der Arbeit mit PostgreSQL haben sich mehr als hundert Funktionen f√ºr die Arbeit mit Systemverzeichnissen angesammelt: pg_class, pg_attribute, pg_constraints usw. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zc/rx/ta/zcrxta08dnfat5cqpgid4lyq7by.png"></div><br>  Was tun mit ihnen?  Sie werden relativ selten eingesetzt.  In ein Projekt einbeziehen?  Der Krasnojarsker Kunde wird f√ºr solchen "Unsinn" nicht bezahlen.  Und doch, was ist, wenn sie jemand anderem als dem Autor n√ºtzlich sind?  Und er beschloss, sie wie gelesene B√ºcher in einen √∂ffentlichen Schrank f√ºr diejenigen zu stellen, die es w√ºnschen. <br><a name="habracut"></a><br>  Jemand m√∂chte sie in seiner Arbeit verwenden.  Und jemand, der sich f√ºr etwas anderes als seine Erfahrung mit Systemkatalogen interessiert. <br><br>  Aber um die Ver√∂ffentlichung nicht in eine langweilige Aufz√§hlung zu verwandeln, ist nicht bekannt, warum die Funktionen erstellt wurden. Ich habe mich entschlossen, auf diejenigen von ihnen einzugehen, die durch ein gemeinsames Ziel vereint werden k√∂nnen.  Daher werden die Funktionen ausgew√§hlt, mit denen eine erweiterte Liste von Merkmalen einer beliebigen Datenbanktabelle angezeigt wird. <br><br>  Die erweiterte Liste der Datenbanktabellenmerkmale wird von der Funktion <b>admtf_Table_ComplexFeatures zur√ºckgegeben</b> , die in diesem Artikel als <b>Kopffunktion</b> bezeichnet wird.  Daher beschr√§nkt sich der Artikel auf die Ber√ºcksichtigung von Funktionen, die beim Ausf√ºhren der Kopffunktion aufgerufen werden. <br><br>  Die erste H√§lfte des Artikels enth√§lt Kommentare zur Implementierung von Funktionen.  Der zweite ist der Quellcode der Funktionen.  F√ºr diejenigen Leser, die nur an den Ausgangstexten interessiert sind, empfehlen wir, sofort mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anhang fortzufahren</a> . <br><p>  <b>Siehe auch</b> <br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen zum Dokumentieren von PostgreSQL-Datenbanken.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil zwei</a> ;</b> <br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen zum Dokumentieren von PostgreSQL-Datenbanken.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil drei</a> .</b> <br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen zum Dokumentieren von PostgreSQL-Datenbanken.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Ende (Teil vier)</a> .</b> <br></p><br><br><a name="ExpFeatures"></a><br><h3>  √úber welche erweiterten Funktionen sprechen wir? </h3><br>  Um eine Vorstellung davon zu bekommen, was unter den erweiterten Merkmalen der Datenbanktabelle zu verstehen ist, betrachten wir zun√§chst die folgende Liste von Merkmalen.  Die Liste enth√§lt die Merkmale der Street-Datenbanktabelle, die von <b>admtf_Table_ComplexFeatures ( <i>'public'</i> , <i>'street'</i> ) zur√ºckgegeben wird</b> . <br><p>  Die folgende Tabelle enth√§lt eine abgek√ºrzte Liste der Street-Tabellenfunktionen.  Ein vollst√§ndiger Satz von Merkmalen dieser Tabelle ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in den erg√§nzenden Materialien von Anhang 2 angegeben.</a> <br><br>  <strong>Tabelle 1. Erweiterte Funktionen der Street-Tabelle.</strong> <br><img src="https://habrastorage.org/webt/zj/5x/jn/zj5xjnygaeedplccbe_itjr7fpu.png"><br></p><div class="spoiler">  <b class="spoiler_title">Die Textversion der Tabelle in der Abbildung</b> <div class="spoiler_text"><table width="95" border="1"><tbody><tr><th width="5">  Kategorie </th><th width="5">  Nein, nein. </th><th width="15">  Titel </th><th width="20">  Kommentar </th><th width="20">  Typ </th><th width="20">  Basistyp </th><th width="5">  ?  nicht NULL </th></tr><tr><td width="5">  tbl </td><td width="5">  0 </td><td width="15">  Stra√üe </td><td width="20">  Liste der Stra√üen in Siedlungen </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5">  att </td><td width="5">  1 </td><td width="15">  wcrccode </td><td width="20">  L√§ndercode </td><td width="20">  wcrccode </td><td width="20">  smallint </td><td width="5">  t </td></tr><tr><td width="5">  att </td><td width="5">  2 </td><td width="15">  localityid </td><td width="20">  Community ID </td><td width="20">  localityid </td><td width="20">  Ganzzahl </td><td width="5">  t </td></tr><tr><td width="5">  att </td><td width="5">  3 </td><td width="15">  streetid </td><td width="20">  ID Stra√üe des Dorfes </td><td width="20">  streetid </td><td width="20">  smallint </td><td width="5">  t </td></tr><tr><td width="5">  att </td><td width="5">  4 </td><td width="15">  Streettypeacrm </td><td width="20">  Stra√üenakronym </td><td width="20">  Streettypeacrm </td><td width="20">  Zeichen (8) </td><td width="5">  f </td></tr><tr><td width="5">  att </td><td width="5">  5 </td><td width="15">  Stra√üenname </td><td width="20">  Stra√üenname </td><td width="20">  Streettypeacrm </td><td width="20">  varchar (150) </td><td width="5">  t </td></tr><tr><td width="5">  pk </td><td width="5">  0 </td><td width="15">  xpkstreet </td><td width="20">  Stra√üentisch Prim√§rschl√ºssel </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5">  pkatt </td><td width="5">  1 </td><td width="15">  wcrccode </td><td width="20">  L√§ndercode </td><td width="20">  wcrccode </td><td width="20">  smallint </td><td width="5">  t </td></tr><tr><td width="5">  fk01 </td><td width="5">  1 </td><td width="15">  fk_street_locality </td><td width="20">  Fremdschl√ºssel der Tabelle </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5">  fk02 </td><td width="5">  2 </td><td width="15">  fk_street_streettype </td><td width="20">  Fremdschl√ºssel der Tabelle </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5">  idx01 </td><td width="5">  1 </td><td width="15">  xie1street </td><td width="20">  Index nach Typ und Stra√üenname der Siedlung </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5">  idx02 </td><td width="5">  2 </td><td width="15">  xie2street </td><td width="20">  Postleitzahl </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5">  idx03 </td><td width="5">  3 </td><td width="15">  xie3street </td><td width="20">  Index der Stra√üennamen aller Siedlungen </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5">  idx04 </td><td width="5">  4 </td><td width="15">  xpkstreet </td><td width="20">  Der eindeutige Index (Prim√§rschl√ºssel) der Stra√üentabelle </td><td width="20"></td><td width="20"></td><td width="5"></td></tr></tbody></table><br></div></div><br><p>  Wenn Sie die Feindseligkeit gegen√ºber diesem Satz von Buchstaben und Zahlen aufz√§hlen, k√∂nnen Sie sehen, dass es sich um die √ºblichen Merkmale einer Datenbanktabelle handelt: </p><br><ul><li>  Tabellennamen; </li><li>  Die Liste der Tabellenattribute und ihrer Typen; </li><li>  Der Prim√§rschl√ºssel und die Liste der Fremdschl√ºssel der Tabelle zusammen mit den Attributen der Tabelle, aus denen sie bestehen. </li><li>  Eine Liste der Tabellenindizes. </li></ul><br><p>  Die Eindeutigkeit jedes Eintrags aus der Liste der Merkmale wird durch die Werte der Felder "Kategorie" und die Seriennummer ("Nr.") Des Merkmals sichergestellt. </p><br><br>  <strong>Tabelle 2. Kategorien von Tabelleneigenschaften.</strong> <br><img src="https://habrastorage.org/webt/sy/j9/5z/syj95z_zta0nii9_9-n7zaxzq3q.png"><br><div class="spoiler">  <b class="spoiler_title">Die Textversion der Tabelle in der Abbildung</b> <div class="spoiler_text"><table><tbody><tr><th>  Akronym </th><th>  Termin </th></tr><tr><td>  tb </td><td>  Tabelleneigenschaften </td></tr><tr><td>  att </td><td>  Eigenschaften von Tabellenattributen </td></tr><tr><td>  seq </td><td>  Sequenzcharakteristika </td></tr><tr><td>  pk </td><td>  Hauptmerkmale </td></tr><tr><td>  pkAtt </td><td>  Merkmale der Prim√§rschl√ºsselattribute </td></tr><tr><td>  fk99 </td><td>  Fremdschl√ºsselmerkmale </td></tr><tr><td>  fk99att </td><td>  Fremdschl√ºsselattributmerkmale </td></tr><tr><td>  fk99rtbl </td><td>  Merkmale der Tabelle, auf die der Fremdschl√ºssel verweist </td></tr><tr><td>  fk99ratt </td><td>  Attributmerkmale der Tabelle, auf die der Fremdschl√ºssel verweist </td></tr><tr><td>  Idx99 </td><td>  Indexmerkmale </td></tr><tr><td>  Idx99att </td><td>  Indexattributmerkmale </td></tr><tr><td>  Inhtbl99 </td><td>  Eigenschaften der generierten Tabelle </td></tr></tbody></table><br></div></div><br><p>  Der Kategoriewert ist erforderlich, um verschiedene Gruppen von Merkmalen voneinander zu unterscheiden.  Eine Seriennummer, um die Merkmale innerhalb der Gruppe zu unterscheiden. </p><br><p>  In der Datenbanktabelle k√∂nnen mehrere Fremdschl√ºssel (FOREIGN KEY) und Indizes deklariert werden.  Daher enth√§lt der Kategoriewert f√ºr diese Merkmale und ihre Nachkommen eine Seriennummer.  Beispielsweise gibt ein Eintrag mit dem Schl√ºssel "Category" = <strong>idx02att</strong> und "No." = <strong>1</strong> das erste Attribut des 2. Index an. </p><br><p>  In der obigen Liste der Kategorien wird der Speicherort der Seriennummer als "99" angegeben. </p><br><p>  <strong>Bemerkung 1</strong> </p><br><img src="https://habrastorage.org/webt/xt/ye/1l/xtye1lr36ssftr4kmvnwedjgnew.png"><br><div class="spoiler">  <b class="spoiler_title">der Quellcode des Operators in der Abbildung</b> <div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> admtf_Table_ComplexFeatures(<span class="hljs-string"><span class="hljs-string">'pg_catalog'</span></span>,<span class="hljs-string"><span class="hljs-string">'pg_class'</span></span>);</code> </pre> <br></div></div><br><br><p>  Der Artikel enth√§lt Beispiele f√ºr die Eigenschaften von Tabellen, die in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem Hilfsschema</a> kurz beschrieben werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> das speziell zur Demonstration der Funktionen von Funktionen erstellt wurde.  Nachdem der Leser diese oder jene Funktion in seiner Datenbank erstellt hat, kann er die Namen seiner Schemata und Tabellen als Parameter verwenden.  Dar√ºber hinaus kann beispielsweise das Verzeichnis <strong>pg_class</strong> als Parameter verwendet werden, obwohl in diesem Fall eine begrenzte Anzahl von Merkmalen ausgegeben wird. </p><p></p><p>  <strong>Das Ende der Bemerkung.</strong> </p><br><a name="tfTableCF_def"></a><br><h3>  Struktur der Kopffunktion </h3><br><img src="https://habrastorage.org/webt/mn/pw/9w/mnpw9welx2ltfhwiqllgqrp6uyc.png"><br>  <strong>Abb.</strong>  <strong>1. Die Funktionen, die die Kopffunktion verursachen.</strong> <br><br>  <strong>Tabelle 3. Zuweisung von Funktionen.</strong> <br><img src="https://habrastorage.org/webt/po/yb/et/poybetf0ogfvr0l95pxzdw5m1yq.png"><br><div class="spoiler">  <b class="spoiler_title">Die Textversion der Tabelle in der Abbildung</b> <div class="spoiler_text"><table width="95" border="1"><tbody><tr><th width="5">  Nein, nein. </th><th width="10">  Titel </th><th width="40">  Termin </th></tr><tr><td width="5">  1 </td><td width="10">  admtf_Table_Features </td><td width="40">  Die Funktion gibt eine Liste der Datenbanktabellenmerkmale zur√ºck </td></tr><tr><td width="5">  2 </td><td width="10">  admtf_Table_Attributes </td><td width="40">  Die Funktion gibt eine Liste der Datenbanktabellenattribute und ihrer Eigenschaften zur√ºck. </td></tr><tr><td width="5">  3 </td><td width="10">  admtf_Table_Constraintes </td><td width="40">  Die Funktion gibt eine Liste der Datenbanktabelleneinschr√§nkungen und ihrer Eigenschaften zur√ºck. </td></tr><tr><td width="5">  4 </td><td width="10">  admtf_Table_Indexes </td><td width="40">  Die Funktion gibt eine Liste der Datenbanktabellenindizes und ihrer Merkmale zur√ºck. </td></tr><tr><td width="5">  5 </td><td width="10">  admtf_Table_InheritanceChildrens </td><td width="40">  Die Funktion gibt eine Liste der von (IHERITS) aus der Quelldatenbanktabelle generierten Tabellen zur√ºck. </td></tr><tr><td width="5">  6 </td><td width="10">  admtf_Table_Sequences </td><td width="40">  Die Funktion gibt eine Liste von Sequenzen (SEQUENCE) zur√ºck, von denen die Tabelle abh√§ngt. </td></tr><tr><td width="5">  7 </td><td width="10">  admtf_PrimaryKey_ComplexFeatures </td><td width="40">  Die Funktion gibt eine vollst√§ndige (erweiterte) Liste der Prim√§rschl√ºsselmerkmale (PRIMARY KEY) der Datenbanktabelle zur√ºck. </td></tr><tr><td width="5">  8 </td><td width="10">  admtf_ForeignKey_ComplexFeatures </td><td width="40">  Die Funktion gibt eine vollst√§ndige (erweiterte) Liste der Fremdschl√ºsselmerkmale (FOREIGN KEY) der Datenbanktabelle zur√ºck. </td></tr><tr><td width="5">  9 </td><td width="10">  admtf_Index_ComplexFeatures </td><td width="40">  Die Funktion gibt eine vollst√§ndige (erweiterte) Liste der Merkmale des Datenbanktabellenindex zur√ºck. </td></tr><tr><td width="5">  10 </td><td width="10">  admtf_Table_ComplexFeatures </td><td width="40">  Die Funktion gibt eine vollst√§ndige (erweiterte) Liste der Datenbanktabellenmerkmale zur√ºck. </td></tr></tbody></table><br></div></div><br><p>  <strong>Bemerkung 2.</strong> </p><br><p>  Funktionsbeschreibungen werden in der oben angegebenen Reihenfolge angeordnet.  Der Grund ist, dass der Artikel in mehrere Teile unterteilt werden muss.  Und Funktionen, die in dieser Reihenfolge angeordnet sind, k√∂nnen verwendet werden, unabh√§ngig davon, dass einige von ihnen nur in den folgenden Teilen der Ver√∂ffentlichung beschrieben werden. </p><br><p>  <strong>Das Ende der Bemerkung.</strong> </p><br><br><h3>  Admtf_Table_Features-Funktionsliste der Datenbanktabellenmerkmale </h3><br><a name="tfTableF_def"></a><br><br><p>  Die Funktion admtf_Table_Features gibt eine Liste der Merkmale der Datenbanktabelle selbst zur√ºck.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Quellcode kann hier angezeigt und heruntergeladen werden.</a> </p><br><p>  Als Parameter verwendet die Funktion den Namen der <b>Quelltabelle (a_TableName</b> ) und den Namen des Schemas, in dem die Tabelle erstellt wird ( <b>a_SchemaName</b> ). </p><br><p>  Die Funktion extrahiert die Hauptdaten aus dem Katalogeintrag <b>pg_class</b> , der neben Tabelleneintr√§gen auch Datens√§tze zu Sequenzen, Ansichten, materialisierten Ansichten und zusammengesetzten Typen enth√§lt.  Daher wird zur Auswahl von Tabellen die Bedingung relkind = <b><font color="red">'r' verwendet</font></b> . </p><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tbl.relname,dsc.description,tbl.relnatts::<span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>,tbl.relchecks::<span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>, tbl.relhaspkey,tbl.relhasindex,tbl.relhassubclass,tbl.reltuples::<span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class tbl <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_namespace nspc <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tbl.relnamespace = nspc.oid <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_description dsc <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tbl.oid=dsc.objoid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> dsc.objsubid=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>( nspc.nspname)=<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_SchemaName) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> tbl.relkind=<span class="hljs-string"><span class="hljs-string">'r'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(tbl.relname) =<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_TableName);</code> </pre><br><p>  Zus√§tzlich greift die Funktion auf die Verzeichnisdaten <b>pg_namespace</b> und <b>pg_description zu</b> .  Das erste enth√§lt die Namen der Datenbankschemata und das zweite enth√§lt Kommentare zu allen Datenbankobjekten. </p><br><p>  Es ist wichtig, auf die Bedingung <b>objsubid = 0</b> zu achten.  Es definiert den Kommentar zur Tabelle, da der Wert des Feldes objoid sowohl f√ºr die Tabelle als auch f√ºr ihre Attribute gleich ist.  Der Kommentar zum Attribut der Tabelle ist in dem Eintrag enthalten, in dem <b>objsubid</b> mit der Nummer dieses Attributs <b>√ºbereinstimmt</b> . </p><br><br>  <strong>Tabelle 4. Das Ergebnis der Ausf√ºhrung der Funktion admtf_Table_Features ('public', 'Street').</strong> <br><br><table width="95" border="1"><tbody><tr><th width="10">  Titel </th><th width="20">  Kommentar </th><th width="5">  Anzahl der Attribute </th><th width="5">  Anzahl der CHECK-Einschr√§nkungen </th><th width="5">  ?  Gibt es einen Prim√§rschl√ºssel? </th><th width="5">  ?  sind Indizes deklariert </th><th width="5">  ?  Gibt es Nachkommen? </th><th width="5">  Die Anzahl der Eintr√§ge in der Tabelle </th></tr><tr><td width="10">  Stra√üe </td><td width="20">  Liste der Stra√üen in Siedlungen </td><td width="5">  22 </td><td width="5">  0 </td><td width="5">  t </td><td width="5">  t </td><td width="5">  f </td><td width="5">  20150 </td></tr></tbody></table><br><p>  <strong>Bemerkung 3</strong> </p><br><p>  Achten Sie auf die Anzahl der Stra√üentabellenattribute.  Es unterscheidet sich erheblich von der Anzahl der im Hilfsschema angegebenen Attribute. </p><br><p>  Tabelle 5. Zus√§tzliche Attribute der Street-Tabelle. </p><br><table><tbody><tr><th width="10">  attname </th><th width="5">  atttypid </th><th width="5">  attnum </th><th width="10">  Hinweis </th></tr><tr><td width="10">  cmin </td><td width="5">  29 </td><td width="5">  -4 </td><td width="10">  Systemattribut </td></tr><tr><td width="10">  xmin </td><td width="5">  28 </td><td width="5">  -3 </td><td width="10">  Systemattribut </td></tr><tr><td width="10">  ctid </td><td width="5">  27 </td><td width="5">  -1 </td><td width="5">  Systemattribut </td></tr><tr><td width="10">  wcrccode </td><td width="5">  795369 </td><td width="5">  1 </td><td width="5">  G√ºltiges Attribut </td></tr><tr><td width="10">  localityid </td><td width="5">  795352 </td><td width="5">  2 </td><td width="10">  G√ºltiges Attribut </td></tr><tr><td width="10">  streetid </td><td width="5">  795364 </td><td width="5">  3 </td><td width="10">  G√ºltiges Attribut </td></tr><tr><td width="10">  Streettypeacrm </td><td width="5">  1919168 </td><td width="5">  4 </td><td width="10">  G√ºltiges Attribut </td></tr><tr><td width="10">  Stra√üenname </td><td width="5">  1043 </td><td width="5">  5 </td><td width="10">  G√ºltiges Attribut </td></tr><tr><td width="10">  ........ pg.dropped.6 ........ </td><td width="5">  0 </td><td width="5">  6 </td><td width="10">  Remote-Attribut </td></tr><tr><td width="10">  ........ pg.dropped.7 ........ </td><td width="5">  0 </td><td width="5">  7 </td><td width="10">  Remote-Attribut </td></tr></tbody></table><br><p>  Tatsache ist, dass PostgreSQL zus√§tzlich zu den Hauptattributen zus√§tzlich mehrere Systemattribute und sogar gel√∂schte Attribute ber√ºcksichtigt. </p><br><p>  <strong>Bemerkung beenden</strong> </p><br><br><h3>  Funktion admtf_Table_Attributes Liste der Datenbanktabellenattribute und ihrer Eigenschaften </h3><a name="tfTableA_def"></a><br><p>  Die Funktion <b>admtf_Table_Attributes</b> gibt eine Liste der Datenbanktabellenattribute zur√ºck.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Quellcode kann hier angezeigt und heruntergeladen werden.</a> </p><br><p>  Als Parameter verwendet die Funktion den Namen der <b>Quelltabelle</b> ( <b>a_TableName</b> ) und den Namen des Schemas, in dem die Tabelle erstellt wird ( <b>a_SchemaName</b> ). </p><br><p>  Die Funktion ruft die Hauptdaten aus den <b>Verzeichniseintr√§gen pg_attribute</b> und <b>pg_type ab</b> .  Der erste enth√§lt Datens√§tze mit Daten zu den Attributen von Tabellen, Ansichten, materialisierten Ansichten, zusammengesetzten Typen und sogar Funktionen.  Die zweite betrifft die Eigenschaften von Attributtypen. </p><br><p>  M√∂glicherweise ist eine Klarstellung erforderlich, wie die Benutzer- und Basistypen in der Funktion definiert sind. </p><br><p>  Ein Tabellenattribut wird mit einem benutzerdefinierten Typ deklariert, wenn das Feld <b>typbasetype</b> im entsprechenden Verzeichniseintrag <b>pg_type</b> <b>gr√∂√üer</b> als 0 ist. Andernfalls ist das Attribut vom Basistyp.  Daher ist das Verzeichnis <b>pg_type</b> zweimal an der FROM-Klausel beteiligt.  Im ersten Verzeichniseintrag wird das Vorhandensein eines Benutzertyps ermittelt. Wenn dieser nicht definiert ist ( <b>typbasetype = 0</b> ), wird aus diesem Eintrag ein Basistypwert generiert.  Andernfalls wird der Basistyp aus dem Datensatz bestimmt, f√ºr den btyp.OID = typ.typbasetype ist. </p><br><p>  Direkt wird die Linie mit dem Basistyp mit der Funktion des Systemkatalogs <b>FORMAT_TYPE (type_oid, typemod) gebildet</b> .  Der erste Parameter sind die OID-Datens√§tze des Basistyps.  Der zweite Parameter ist der Modifikatorwert f√ºr Typen, die eine Gr√∂√üe enthalten.  Zum Beispiel VARCHAR (100) oder NUMERIC (4,2), DECIMAL (4,2).  Der Wert des <b>typemod-</b> Parameters wird von <b>typ.typtypmod √ºbernommen,</b> wenn das Attribut von einem Benutzertyp ist, andernfalls von <b>attr.atttypmod</b> , d. H.  direkt aus einem Attributdatensatz. </p><br><img src="https://habrastorage.org/webt/gv/jx/q0/gvjxq0pb7kjjrv6galmsht5s9do.png"><br><div class="spoiler">  <b class="spoiler_title">der Quellcode des Operators in der Abbildung</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> attr.attnum, attr.attname::<span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COALESCE</span></span>(typ.typbasetype,<span class="hljs-number"><span class="hljs-number">0</span></span>)&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> typ.typname::<span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>, FORMAT_TYPE(<span class="hljs-keyword"><span class="hljs-keyword">COALESCE</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">NULLIF</span></span>(typ.typbasetype,<span class="hljs-number"><span class="hljs-number">0</span></span>),typ.oid), <span class="hljs-keyword"><span class="hljs-keyword">COALESCE</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">NULLIF</span></span>(typ.typtypmod,<span class="hljs-number"><span class="hljs-number">-1</span></span>),attr.atttypmod))::<span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">256</span></span>), attr.attnotnull, dsc.description <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_attribute <span class="hljs-keyword"><span class="hljs-keyword">attr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class tbl <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tbl.oid = attr.attrelid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_namespace nspc <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tbl.relnamespace = nspc.oid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_type typ <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> attr.atttypid=typ.oid <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_description dsc <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> dsc.objoid=attr.attrelid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> dsc.objsubid=attr.attnum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>( nspc.nspname)=<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_SchemaName) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(tbl.relname) =<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_TableName) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> tbl.relkind=<span class="hljs-string"><span class="hljs-string">'r'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attr.attnum&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attr.atttypID&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> tbl.relname,attr.attnum;</code> </pre><br></div></div><br><p>  Zus√§tzlich greift die Funktion auf die Verzeichnisdaten <b>pg_class</b> , <b>pg_namespace</b> und <b>pg_description zu</b> .  Das erste und zweite Verzeichnis werden verwendet, um nach Attributen anhand der Namen des Schemas und der Datenbanktabelle zu suchen. <br><br>  Das dritte Verzeichnis wird verwendet, um den Kommentar f√ºr das Tabellenattribut abzurufen. </p><br><p>  Der Kommentar zum Attribut der Tabelle befindet sich in dem Eintrag, in dem <b>dsc.objoid</b> die OID der <b>Quelltabelle</b> enth√§lt, und <b>dsc.objsubid ist die</b> Seriennummer des Attributs in der Tabelle, d. H.  <b>attr.attnum</b> . </p><br><p>  Um zu verhindern, dass die Funktion System- und Remote-Attribute <b>zur√ºckgibt</b> , setzt die WHERE-Klausel die Bedingung <b>attr.attnum&gt; 0 AND attr.atttypID&gt; 0</b> . </p><br><br>  <strong>Tabelle 6. Das Ergebnis der Ausf√ºhrung der Funktion admtf_Table_Attributes ('public', 'Street').</strong> <br><br><table width="95" border="1"><tbody><tr><th width="5">  Nein, nein. </th><th width="10">  Titel </th><th width="20">  Benutzerdefinierter Typ </th><th width="20">  Basistyp </th><th width="5">  ?  nicht NULL </th><th width="25">  Kommentar </th></tr><tr><td width="5">  1 </td><td width="10">  wcrccode </td><td width="20">  wcrccode </td><td width="20">  smallint </td><td width="5">  t </td><td width="25">  L√§ndercode </td></tr><tr><td width="5">  2 </td><td width="10">  localityid </td><td width="20">  localityid </td><td width="20">  Ganzzahl </td><td width="5">  t </td><td width="25">  Community ID </td></tr><tr><td width="5">  3 </td><td width="10">  streetid </td><td width="20">  streetid </td><td width="20">  smallint </td><td width="5">  t </td><td width="25">  ID Stra√üe des Dorfes </td></tr><tr><td width="5">  4 </td><td width="10">  Streettypeacrm </td><td width="20">  Streettypeacrm </td><td width="20">  Zeichen (8) </td><td width="5">  f </td><td width="25">  Stra√üenakronym </td></tr><tr><td width="5">  5 </td><td width="10">  Stra√üenname </td><td width="20"></td><td width="20">  varchar (150) </td><td width="5">  t </td><td width="25">  Name der Stra√üe der Siedlung </td></tr></tbody></table><br><h4>  Funktionsversion mit Regclass-Alias ‚Äã‚Äãf√ºr Typ oid </h4><br><p>  PostgreSQL-Objektkennungen (OIDs) sind vom gleichen Typ wie OID, die derzeit als vorzeichenlose 4-Byte-Ganzzahl implementiert ist.  Aufgrund des Vorhandenseins von Aliasnamen dieses Typs kann eine Ganzzahl als Name eines Objekts dargestellt werden.  Und umgekehrt - konvertieren Sie den Objektnamen in eine Ganzzahl vom Typ OID. </p><br><p>  Schauen Sie sich als Beispiel die folgende <b>SELECT-Anweisung an</b> .  Es ruft ungew√∂hnlich die Namen der Attributtabelle und die Namen ihrer Typen ab - anstatt auf die entsprechenden Verzeichnisfelder mit den Namen dieser Merkmale zuzugreifen, werden sie verwendet: <br></p><ul><li>  <b>attrelid :: regclass (attrelid :: regclass: NAME)</b> , </li><li>  <b>atttypid :: regtype (atttypid :: regtype: NAME)</b> </li><li>  <b>typbasetype :: regtype (typbasetype :: regtype: NAME)</b> . </li></ul><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> attr.attname,attr.attrelid::regclass, attr.atttypid::regtype, typ.typbasetype::regtype,attr.attrelid::regclass::<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, attr.atttypid::regtype::<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>,typ.typbasetype::regtype::<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_attribute <span class="hljs-keyword"><span class="hljs-keyword">attr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_type typ <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> attr.atttypid=typ.oid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> attr.attrelid=(<span class="hljs-string"><span class="hljs-string">'public'</span></span>||<span class="hljs-string"><span class="hljs-string">'.'</span></span>||<span class="hljs-string"><span class="hljs-string">'Street'</span></span>)::regclass <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attr.attnum&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attr.atttypID&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> attr.attnum;</code> </pre><br><p>  Das Folgende ist das Ergebnis der Ausf√ºhrung dieser Abfrage. </p><br><img src="https://habrastorage.org/webt/zr/4_/ga/zr4_gal9s-8jnhihyjia7cq0xvs.png"><br><p>  In der Liste der Ausgabewerte des Operators SELECT vor der Konvertierung unter Verwendung von Aliasnamen des Typs OID sind alle Werte au√üer dem Attributnamen numerisch. Infolgedessen werden die Tabellennamen und Attributtypen angezeigt.  Die Arten von Ausgabewerten k√∂nnen in der zweiten Zeile des Tabellenkopfs ber√ºcksichtigt werden. </p><br><p>  Au√üerdem befindet sich in der WHERE-Klausel der Anweisung die Bedingung <b>attr.attrelid = ('public' || '.' || 'Street') :: regclass</b> , auf deren linker Seite sich ein numerischer Wert befindet und auf der rechten Seite eine Zeichenfolge, die mit in einen numerischen Wert konvertiert wird Verwenden der Alias- <b>Regklasse</b> . </p><br><img src="https://habrastorage.org/webt/7v/tl/nh/7vtlnhnhqmr7idtdcebcsffzjik.png"><br><div class="spoiler">  <b class="spoiler_title">der Quellcode des Operators in der Abbildung</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> attr.attnum, attr.attname::<span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COALESCE</span></span>(typ.typbasetype,<span class="hljs-number"><span class="hljs-number">0</span></span>)&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> typ.typname::<span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>, FORMAT_TYPE(<span class="hljs-keyword"><span class="hljs-keyword">COALESCE</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">NULLIF</span></span>(typ.typbasetype,<span class="hljs-number"><span class="hljs-number">0</span></span>),typ.oid), <span class="hljs-keyword"><span class="hljs-keyword">COALESCE</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">NULLIF</span></span>(typ.typtypmod,<span class="hljs-number"><span class="hljs-number">-1</span></span>),attr.atttypmod))::<span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">256</span></span>), attr.attnotnull, dsc.description <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_attribute <span class="hljs-keyword"><span class="hljs-keyword">attr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_type typ <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> attr.atttypid=typ.oid <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_description dsc <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> dsc.objoid=attr.attrelid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> dsc.objsubid=attr.attnum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> attr.attrelid=( a_SchemaName ||<span class="hljs-string"><span class="hljs-string">'.'</span></span>|| a_TableName)::regclass <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attr.attnum&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attr.atttypID&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> attr.attnum;</code> </pre><br></div></div><br>  Mit der Alias-Regklasse aus der Hauptanweisung k√∂nnen Sie die Verbindung zu zwei Verzeichnissen entfernen.  Eine solche Verbesserung hatte jedoch fast keine Auswirkungen auf die Leistung der Funktion - in beiden Versionen wird die Funktion in 11 ms ausgef√ºhrt.  M√∂glicherweise aufgrund der Tatsache, dass die Testtabelle nur wenige Attribute aufweist. <br>  <b>Bemerkung 4</b> <br><p>  Ein schwerwiegender Fehler in der Bedingung in der Form <b>attr.attrelid = (a_SchemaName || '.' || a_TableName) :: regclass</b> wird <b>angezeigt,</b> wenn die Datenbank ein Schema und / oder eine Tabelle mit einem ungew√∂hnlichen Namen enth√§lt.  Zum Beispiel <b>"Mein Schema"</b> und / oder <b>"Meine Tabelle"</b> .  Solche Werte m√ºssen in doppelten Anf√ºhrungszeichen √ºbertragen werden oder die Funktion QUOTE_IDENT verwenden, da sonst die Funktion mit einem Systemfehler fehlschl√§gt. </p><br><img src="https://habrastorage.org/webt/jt/ak/nv/jtaknvaqwphry4yla4bnlemrdeq.png"><br><div class="spoiler">  <b class="spoiler_title">der Quellcode des Operators in der Abbildung</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">/*       ¬´   ¬ª*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> attr.attname,attr.attrelid::regclass, attr.atttypid::regtype,typ.typbasetype::regtype, attr.attrelid::regclass::<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, attr.atttypid::regtype::<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>,typ.typbasetype::regtype::<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_attribute <span class="hljs-keyword"><span class="hljs-keyword">attr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_type typ <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> attr.atttypid=typ.oid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> attr.attrelid=(<span class="hljs-string"><span class="hljs-string">' '</span></span>||<span class="hljs-string"><span class="hljs-string">'.'</span></span>||<span class="hljs-string"><span class="hljs-string">' '</span></span>)::regclass <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attr.attnum&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attr.atttypID&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> attr.attnum; <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> attr.attname,attr.attrelid::regclass, attr.atttypid::regtype,typ.typbasetype::regtype, attr.attrelid::regclass::<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, attr.atttypid::regtype::<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>,typ.typbasetype::regtype::<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_attribute <span class="hljs-keyword"><span class="hljs-keyword">attr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_type typ <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> attr.atttypid=typ.oid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> attr.attrelid=(<span class="hljs-string"><span class="hljs-string">'" "'</span></span>||<span class="hljs-string"><span class="hljs-string">'.'</span></span>||<span class="hljs-string"><span class="hljs-string">'" "'</span></span>)::regclass <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attr.attnum&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attr.atttypID&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> attr.attnum;</code> </pre><br></div></div><br>  Daher bevorzuge ich Bedingungen in der Form <b>LOWER (nspc.nspname) = LOWER (a_SchemaName) UND LOWER (tbl.relname) = LOWER (a_TableName)</b> , was nicht zu Systemfehlern f√ºhrt. <br><br>  <b>Bemerkung beenden</b> <br><a name="Script1"></a><br><h2>  ANHANG 1. Skripte </h2><a name="tfTableF"></a><br><h3>  Erstellen der Funktion admtf_Table_Features </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kommentare zum Funktionsquellcode finden Sie hier.</a> <br><div class="spoiler">  <b class="spoiler_title">Funktionsquellcode</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> admtf_Table_Features (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>); <span class="hljs-comment"><span class="hljs-comment">/********************************************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*     ,   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/********************************************************************************************************/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> admtf_Table_Features (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-string"><span class="hljs-string">'public'</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> (rs_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,rs_TableDescription <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>,rs_NumberOfAttribute <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>,rs_NumberOfChecks <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>,rs_hasPKey <span class="hljs-built_in"><span class="hljs-built_in">BOOLEAN</span></span>,rs_hasIndex <span class="hljs-built_in"><span class="hljs-built_in">BOOLEAN</span></span>,rs_hasSubClass <span class="hljs-built_in"><span class="hljs-built_in">BOOLEAN</span></span>,rs_NumberOfRow <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c_TableKind <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHAR</span></span>:=<span class="hljs-string"><span class="hljs-string">'r'</span></span>; v_TableOID OID; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_TableName NAME; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_TableDescription TEXT; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_TableNumberOfRowCalc INTEGER; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-comment"><span class="hljs-comment">--****************************************************************************************************** BEGIN SELECT INTO rs_TableName,rs_TableDescription,rs_NumberOfAttribute, rs_NumberOfChecks,rs_hasPKey,rs_hasIndex,rs_hasSubClass, rs_NumberOfRow tbl.relname,dsc.description,tbl.relnatts::INTEGER,tbl.relchecks::INTEGER, tbl.relhaspkey,tbl.relhasindex,tbl.relhassubclass,tbl.reltuples::INTEGER FROM pg_class tbl INNER JOIN pg_namespace nspc ON tbl.relnamespace = nspc.oid LEFT OUTER JOIN pg_Description dsc ON tbl.oid=dsc.objoid AND dsc.objsubid=0 WHERE nspc.nspname=LOWER(a_SchemaName) AND tbl.relkind=c_TableKind AND tbl.relname =LOWER(a_TableName); EXECUTE 'SELECT count(*) FROM ' ||LOWER(a_SchemaName) ||'.'||quote_ident(LOWER(a_TableName)) INTO v_TableNumberOfRowCalc; RETURN QUERY SELECT rs_TableName,rs_TableDescription,rs_NumberOfAttribute, rs_NumberOfChecks,rs_hasPKey,rs_hasIndex, rs_hasSubClass,v_TableNumberOfRowCalc AS rs_NumberOfRow; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Features(a_SchemaName NAME,a_TableName NAME) IS '   ,  '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; BEGIN TRANSACTION; DROP FUNCTION IF EXISTS admtf_Table_Features (a_SchemaName VARCHAR(256),a_TableName VARCHAR(256)); /********************************************************************************************************/ /*     ,   */ /********************************************************************************************************/ CREATE OR REPLACE FUNCTION admtf_Table_Features (a_SchemaName VARCHAR(256) default 'public', /*     */ a_TableName VARCHAR(256) default NULL /*   */ ) RETURNS TABLE (rs_TableName VARCHAR(256),rs_TableDescription TEXT,rs_NumberOfAttribute INTEGER,rs_NumberOfChecks INTEGER,rs_hasPKey BOOLEAN,rs_hasIndex BOOLEAN,rs_hasSubClass BOOLEAN,rs_NumberOfRow INTEGER) AS $BODY$ DECLARE c_TableKind CONSTANT CHAR:='r'; v_TableOID OID; /*   */ v_TableName VARCHAR(256); /*   */ v_TableDescription TEXT; /*   */ v_TableNumberOfRowCalc INTEGER; /*     */ --****************************************************************************************************** BEGIN RETURN QUERY SELECT tf.rs_TableName::VARCHAR(256), tf.rs_TableDescription::TEXT, tf.rs_NumberOfAttribute::INTEGER, tf.rs_NumberOfChecks::INTEGER, tf.rs_hasPKey::BOOLEAN, tf.rs_hasIndex::BOOLEAN, tf.rs_hasSubClass::BOOLEAN, tf.rs_NumberOfRow::INTEGER FROM admtf_Table_Features(a_SchemaName::NAME,a_TableName::NAME) tf; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Features(a_SchemaName VARCHAR(256),a_TableName VARCHAR(256)) IS '   ,  '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; SELECt * FROM admtf_Table_Features('public'::VARCHAR(256),'Street'::VARCHAR(256)); SELECt * FROM admtf_Table_Features('public':: NAME,'Street'::NAME);</span></span></code> </pre><br></div></div><br><a name="tfTableA"></a><br><h3>  Erstellen der Funktion admtf_Table_Attributes </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kommentare zum Funktionsquellcode finden Sie hier.</a> <br><div class="spoiler">  <b class="spoiler_title">Funktionsquellcode</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> admtf_Table_Attributes (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>); <span class="hljs-comment"><span class="hljs-comment">/********************************************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-comment"><span class="hljs-comment">/********************************************************************************************************/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> admtf_Table_Attributes (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-string"><span class="hljs-string">'public'</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> (r_AttributeNumber <span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>,r_AttributeName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_UserTypeName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_TypeName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_isNotNULL <span class="hljs-built_in"><span class="hljs-built_in">BOOLEAN</span></span>, r_Description <span class="hljs-built_in"><span class="hljs-built_in">Text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c_TableKind <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHAR</span></span>:=<span class="hljs-string"><span class="hljs-string">'r'</span></span>; v_Scale INTEGER; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">--****************************************************************************************************** BEGIN RETURN QUERY SELECT attr.attnum AS r_AttributeNumber, attr.attname::NAME AS r_AttributeName, CASE WHEN COALESCE(typ.typbasetype,0)&gt;0 THEN typ.typname::NAME ELSE ''::NAME END AS r_UserTypeName, FORMAT_TYPE(COALESCE(NULLIF(typ.typbasetype,0),typ.oid), COALESCE(NULLIF(typ.typtypmod,-1),attr.atttypmod))::NAME AS r_TypeName, attr.attnotnull AS r_isNotNULL, dsc.description AS r_Description FROM pg_attribute attr INNER JOIN pg_class tbl ON tbl.oid = attr.attrelid INNER JOIN pg_namespace nsp ON tbl.relnamespace=nsp.oid LEFT OUTER JOIN pg_type typ ON attr.atttypid=typ.oid LEFT OUTER JOIN pg_type btyp ON typ.typbasetype=btyp.oid LEFT OUTER JOIN pg_description dsc ON dsc.objoid=attr.attrelid AND dsc.objsubid=attr.attnum WHERE LOWER(nsp.nspname)=LOWER(a_SchemaName) AND LOWER(tbl.relname)=LOWER(a_TableName) AND tbl.relkind=c_TableKind AND attr.attnum&gt;0 AND attr.atttypID&gt;0 ORDER BY tbl.relname,attr.attnum; RETURN; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Attributes(a_SchemaName NAME,a_TableName NAME) IS '   '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; BEGIN TRANSACTION; DROP FUNCTION IF EXISTS admtf_Table_Attributes (a_SchemaName VARCHAR(256),a_TableName VARCHAR(256)); /********************************************************************************************************/ /*      */ /********************************************************************************************************/ CREATE OR REPLACE FUNCTION admtf_Table_Attributes (a_SchemaName VARCHAR(256) default 'public', /*     */ a_TableName VARCHAR(256) default NULL /*   */ ) RETURNS TABLE (r_AttributeNumber SMALLINT,r_AttributeName VARCHAR(256),r_UserTypeName VARCHAR(256),r_TypeName VARCHAR(256),r_isNotNULL BOOLEAN, r_Description Text) AS $BODY$ DECLARE c_TableKind CONSTANT CHAR:='r'; v_Scale INTEGER; /*   */ --****************************************************************************************************** BEGIN RETURN QUERY SELECT ta.r_AttributeNumber::SMALLINT, ta.r_AttributeName::VARCHAR(256), ta.r_UserTypeName::VARCHAR(256), ta.r_TypeName::VARCHAR(256), ta.r_isNotNULL::BOOLEAN, ta.r_Description::TEXT FROM admtf_Table_Attributes(a_SchemaName::NAME,a_TableName::NAME) ta; RETURN; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Attributes(a_SchemaName VARCHAR(256),a_TableName VARCHAR(256)) IS '   '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; SELECT * FROM admtf_Table_Attributes('public'::VARCHAR(256),'Street'::VARCHAR(256)); SELECT * FROM admtf_Table_Attributes('public'::NAME,'Street'::NAME);</span></span></code> </pre><br></div></div><br><h3>  Erstellen der Funktion admtf_Table_Attributes mithilfe des Regclass-Alias </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kommentare zum Funktionsquellcode finden Sie hier.</a> <br><div class="spoiler">  <b class="spoiler_title">Funktionsquellcode</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> admtf_Table_Attributes (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>); <span class="hljs-comment"><span class="hljs-comment">/********************************************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-comment"><span class="hljs-comment">/********************************************************************************************************/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> admtf_Table_Attributes (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-string"><span class="hljs-string">'public'</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> (r_AttributeNumber <span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>,r_AttributeName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_UserTypeName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_TypeName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_isNotNULL <span class="hljs-built_in"><span class="hljs-built_in">BOOLEAN</span></span>, r_Description <span class="hljs-built_in"><span class="hljs-built_in">Text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c_TableKind <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHAR</span></span>:=<span class="hljs-string"><span class="hljs-string">'r'</span></span>; v_Scale INTEGER; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">--****************************************************************************************************** BEGIN RETURN QUERY SELECT attr.attnum AS r_AttributeNumber, attr.attname::NAME AS r_AttributeName, CASE WHEN COALESCE(typ.typbasetype,0)&gt;0 THEN typ.typname::NAME ELSE ''::NAME END AS r_UserTypeName, FORMAT_TYPE(COALESCE(NULLIF(typ.typbasetype,0),typ.oid), COALESCE(NULLIF(typ.typtypmod,-1),attr.atttypmod))::NAME AS r_TypeName, attr.attnotnull AS r_isNotNULL, dsc.description AS r_Description FROM pg_attribute attr INNER JOIN pg_type typ ON attr.atttypid=typ.oid LEFT OUTER JOIN pg_type btyp ON typ.typbasetype=btyp.oid LEFT OUTER JOIN pg_description dsc ON dsc.objoid=attr.attrelid AND dsc.objsubid=attr.attnum WHERE attr.attrelid=(LOWER(a_SchemaName)||'.'|| LOWER(a_TableName))::regclass AND attr.attnum&gt;0 AND attr.atttypID&gt;0 ORDER BY attr.attnum; RETURN; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Attributes(a_SchemaName NAME,a_TableName NAME) IS '   '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; BEGIN TRANSACTION; DROP FUNCTION IF EXISTS admtf_Table_Attributes (a_SchemaName VARCHAR(256),a_TableName VARCHAR(256)); /********************************************************************************************************/ /*      */ /********************************************************************************************************/ CREATE OR REPLACE FUNCTION admtf_Table_Attributes (a_SchemaName VARCHAR(256) default 'public', /*     */ a_TableName VARCHAR(256) default NULL /*   */ ) RETURNS TABLE (r_AttributeNumber SMALLINT,r_AttributeName VARCHAR(256),r_UserTypeName VARCHAR(256),r_TypeName VARCHAR(256),r_isNotNULL BOOLEAN, r_Description Text) AS $BODY$ DECLARE c_TableKind CONSTANT CHAR:='r'; v_Scale INTEGER; /*   */ --****************************************************************************************************** BEGIN RETURN QUERY SELECT ta.r_AttributeNumber::SMALLINT, ta.r_AttributeName::VARCHAR(256), ta.r_UserTypeName::VARCHAR(256), ta.r_TypeName::VARCHAR(256), ta.r_isNotNULL::BOOLEAN, ta.r_Description::TEXT FROM admtf_Table_Attributes(a_SchemaName::NAME,a_TableName::NAME) ta; RETURN; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Attributes(a_SchemaName VARCHAR(256),a_TableName VARCHAR(256)) IS '   '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; SELECT * FROM admtf_Table_Attributes('public'::VARCHAR(256),'Street'::VARCHAR(256)); SELECT * FROM admtf_Table_Attributes('public'::NAME,'Street'::NAME);</span></span></code> </pre><br></div></div><br><a name="Apendix2"></a><br><h2>  ANHANG 2. Zus√§tzliche Materialien </h2><br><h3>  Hilfsdatenbankschema </h3><br><a name="scheme_for_tests"></a><br><img src="https://habrastorage.org/webt/qi/rb/9q/qirb9qyb5nzkn3hef8v7pvgyvvs.png"><br><br><ul><li>  <b>LAND</b> - Klassifikator der L√§nder der Welt - OKSM (Allrussische Klassifikation der L√§nder der Welt); </li><li>  <b>HOUSEADDR</b> - Liste der Hausnummern auf den Stra√üen von Siedlungen; </li><li>  <b>LCLTYTYPE</b> - Verzeichnis der Siedlungsarten; </li><li>  <b>LOKALIT√ÑT</b> - Liste der Siedlungen; </li><li>  <b>STRASSE</b> - Liste der Stra√üen in Siedlungen; </li><li> <b>STREETTYPE</b> ‚Äî   ; </li><li> <b>TERRITORY</b> ‚Äî   (, , ,   ..); </li><li> <b>TERRITORYTYPE</b> ‚Äî   . </li></ul><br><br><a name="Street_char"></a><br><h3>    Street () </h3><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">        .</a> <br> <strong> 1.    Street ().</strong> <br><img src="https://habrastorage.org/webt/vw/ze/rp/vwzerpaegckljldqsmbrq22zf_m.png"><br><div class="spoiler"> <b class="spoiler_title">    </b> <div class="spoiler_text"><table width="95" border="1"><tbody><tr><th width="5">  Kategorie </th><th width="5">  Nein, nein. </th><th width="15">  Titel </th><th width="20">  Kommentar </th><th width="20">  </th><th width="20">   </th><th width="5">  ? not NULL </th></tr><tr><td width="5"> tbl </td><td width="5">  0 </td><td width="15"> street </td><td width="20">      </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5"> att </td><td width="5">  1 </td><td width="15"> wcrccode </td><td width="20">   </td><td width="20"> wcrccode </td><td width="20"> smallint </td><td width="5"> t </td></tr><tr><td width="5"> att </td><td width="5">  2 </td><td width="15"> localityid </td><td width="20">    </td><td width="20"> localityid </td><td width="20"> integer </td><td width="5"> t </td></tr><tr><td width="5"> att </td><td width="5">  3 </td><td width="15"> streetid </td><td width="20">     </td><td width="20"> streetid </td><td width="20"> smallint </td><td width="5"> t </td></tr><tr><td width="5"> att </td><td width="5">  4 </td><td width="15"> streettypeacrm </td><td width="20">    </td><td width="20"> streettypeacrm </td><td width="20"> character(8) </td><td width="5"> f </td></tr><tr><td width="5"> att </td><td width="5">  5 </td><td width="15"> streetname </td><td width="20">   </td><td width="20"> streettypeacrm </td><td width="20"> varchar(150) </td><td width="5"> t </td></tr><tr><td width="5"> pk </td><td width="5">  0 </td><td width="15"> xpkstreet </td><td width="20">    street </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5"> pkatt </td><td width="5">  1 </td><td width="15"> wcrccode </td><td width="20">   </td><td width="20"> wcrccode </td><td width="20"> smallint </td><td width="5"> t </td></tr><tr><td width="5"> pkatt </td><td width="5">  2 </td><td width="15"> localityid </td><td width="20">    </td><td width="20"> localityid </td><td width="20"> integer </td><td width="5"> t </td></tr><tr><td width="5"> pkatt </td><td width="5">  3 </td><td width="15"> streetid </td><td width="20">     </td><td width="20"> streetid </td><td width="20"> smallint </td><td width="5"> t </td></tr><tr><td width="5"> fk01 </td><td width="5">  1 </td><td width="15"> fk_street_locality </td><td width="20">    </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5"> fk01att </td><td width="5">  1 </td><td width="15"> wcrccode </td><td width="20">   </td><td width="20"> wcrccode </td><td width="20"> smallint </td><td width="5"> t </td></tr><tr><td width="5"> fk01att </td><td width="5">  2 </td><td width="15"> localityid </td><td width="20">    </td><td width="20"> localityid </td><td width="20"> integer </td><td width="5"> t </td></tr><tr><td width="5"> fk01rtbl </td><td width="5">  0 </td><td width="15"> locality </td><td width="20">    </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5"> fk01ratt </td><td width="5">  1 </td><td width="15"> wcrccode </td><td width="20">   </td><td width="20"> wcrccode </td><td width="20"> smallint </td><td width="5"> t </td></tr><tr><td width="5"> fk01ratt </td><td width="5">  2 </td><td width="15"> localityid </td><td width="20">    </td><td width="20"> localityid </td><td width="20"> integer </td><td width="5"> t </td></tr><tr><td width="5"> fk02 </td><td width="5">  2 </td><td width="15"> fk_street_streettype </td><td width="20">    </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5"> fk02att </td><td width="5">  1 </td><td width="15"> streettypeacrm </td><td width="20">    </td><td width="20"> streettypeacrm </td><td width="20"> character(8) </td><td width="5"> f </td></tr><tr><td width="5"> fk02rtbl </td><td width="5">  0 </td><td width="15"> streettype </td><td width="20">    </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5"> fk02ratt </td><td width="5">  1 </td><td width="15"> streettypeacrm </td><td width="20">    </td><td width="20"> streettypeacrm </td><td width="20"> character(8) </td><td width="5"> t </td></tr><tr><td width="5"> idx01 </td><td width="5">  1 </td><td width="15"> xie1street </td><td width="20">         </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5"> idx01att </td><td width="5">  1 </td><td width="15"> wcrccode </td><td width="20">   </td><td width="20"> wcrccode </td><td width="20"> smallint </td><td width="5"> t </td></tr><tr><td width="5"> idx01att </td><td width="5">  2 </td><td width="15"> localityid </td><td width="20">    </td><td width="20"> localityid </td><td width="20"> integer </td><td width="5"> t </td></tr><tr><td width="5"> idx01att </td><td width="5">  3 </td><td width="15"> streettypeacrm </td><td width="20">    </td><td width="20"> streettypeacrm </td><td width="20"> character(8) </td><td width="5"> f </td></tr><tr><td width="5"> idx01att </td><td width="5">  4 </td><td width="15"> streetname </td><td width="20">     </td><td width="20"></td><td width="20"> varchar(150) </td><td width="5"> t </td></tr><tr><td width="5"> idx02 </td><td width="5">  2 </td><td width="15"> xie2street </td><td width="20">       </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5"> idx02att </td><td width="5">  1 </td><td width="15"> wcrccode </td><td width="20">   </td><td width="20"> wcrccode </td><td width="20"> smallin </td><td width="5"> t </td></tr><tr><td width="5"> idx02att </td><td width="5">  2 </td><td width="15"> localityid </td><td width="20">    </td><td width="20"> localityid </td><td width="20"> integer </td><td width="5"> t </td></tr><tr><td width="5"> idx02att </td><td width="5">  3 </td><td width="15"> streetname </td><td width="20">     </td><td width="20"></td><td width="20"> varchar(150) </td><td width="5"> t </td></tr><tr><td width="5"> idx03 </td><td width="5">  3 </td><td width="15"> xie3street </td><td width="20">        </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5"> idx03att </td><td width="5">  1 </td><td width="15"> streetname </td><td width="20">     </td><td width="20"></td><td width="20"> varchar(150) </td><td width="5"> t </td></tr><tr><td width="5"> idx04 </td><td width="5">  4 </td><td width="15"> xpkstreet </td><td width="20">   ( )  street </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5"> idx04att </td><td width="15">  1 </td><td width="15"> wcrccode </td><td width="20">   </td><td width="20"> wcrccode </td><td width="20"> smallint </td><td width="5"> t </td></tr><tr><td width="5"> idx04att </td><td width="5">  2 </td><td width="15"> localityid </td><td width="20">    </td><td width="20"> localityid </td><td width="20"> integer </td><td width="5"> t </td></tr><tr><td width="5"> idx04att </td><td width="5">  3 </td><td width="15"> streetid </td><td width="20">     </td><td width="20"> streetid </td><td width="20"> smallint </td><td width="5"> t </td></tr></tbody></table><br></div></div><br><h3>  Siehe auch </h3><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen zum Dokumentieren von PostgreSQL-Datenbanken.</a></b> <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ;</b> <br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen zum Dokumentieren von PostgreSQL-Datenbanken.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil drei</a> .</b> <br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen zum Dokumentieren von PostgreSQL-Datenbanken.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Ende (Teil vier)</a> .</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415575/">https://habr.com/ru/post/de415575/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415565/index.html">Warum (heute) 444 zur√ºckgibt, ist nicht immer sinnvoll</a></li>
<li><a href="../de415567/index.html">Senden Sie h264-Videos ohne Transcodierung von einer Logitech C920-Kamera</a></li>
<li><a href="../de415569/index.html">HOWTO Setup Ubuntu 18.04 Sendmail + DKIM + SPF + DMARC oder wie ich es geschafft habe, in die Google Mail-Bastion zu gelangen</a></li>
<li><a href="../de415571/index.html">kaggle: IEEE-Kameramodellidentifikation</a></li>
<li><a href="../de415573/index.html">Optimierung eines Modells f√ºr den 3D-Druck am Beispiel der Blender-Software</a></li>
<li><a href="../de415577/index.html">Folien des Kurses "DBMS Technologies and Development"</a></li>
<li><a href="../de415579/index.html">Lerne OpenGL. Lektion 5.5 - Normale Zuordnung</a></li>
<li><a href="../de415581/index.html">International Fintech - Digest: 12 Nachrichten √ºber das Wichtigste in der Branche</a></li>
<li><a href="../de415587/index.html">StereoPi - unsere Hardware zum Studium von Computer Vision, Drohnen und Robotern</a></li>
<li><a href="../de415589/index.html">"Ein bisschen mehr √ºber PD": US-amerikanische TV-Unternehmen werden den Verkauf von Kunden-Geodaten einstellen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>