<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíß üôéüèø üë®üèø‚Äçüîß Conozca la pseudo consola de Windows (ConPTY) üéß üö∂üèæ ü•°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Art√≠culo publicado el 2 de agosto de 2018 

 Este es el segundo art√≠culo sobre la l√≠nea de comandos de Windows, donde discutiremos la nueva infraestru...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Conozca la pseudo consola de Windows (ConPTY)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420853/">  <font color="gray">Art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicado</a> el 2 de agosto de 2018</font> <br><br>  Este es el segundo art√≠culo sobre la l√≠nea de comandos de Windows, donde discutiremos la nueva infraestructura y las interfaces de programaci√≥n de la pseudo-consola Windows, es decir, la Pseudo Consola de Windows (ConPTY): por qu√© la desarrollamos, para qu√© sirve, c√≥mo funciona, c√≥mo usarla y mucho m√°s. <br><br>  En el √∫ltimo art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"El grave legado del pasado.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Problemas con la l√≠nea de comandos de Windows ‚Äù</a> , hablamos sobre los requisitos previos para la aparici√≥n del terminal y la evoluci√≥n de la l√≠nea de comandos en Windows, y tambi√©n comenzamos a estudiar la estructura interna de la consola de Windows y la infraestructura de la l√≠nea de comandos de Windows.  Tambi√©n discutimos las muchas ventajas y desventajas principales de la consola de Windows. <br><br>  Uno de los inconvenientes es que Windows est√° tratando de ser "√∫til", pero interfiere con los desarrolladores de consolas alternativas y de terceros, desarrolladores de servicios, etc.  Al crear una consola o servicio, los desarrolladores deben tener acceso a los canales de comunicaci√≥n a trav√©s de los cuales su terminal / servicio intercambia datos con aplicaciones de l√≠nea de comandos, o proporcionarles acceso.  En el mundo * NIX, esto no es un problema porque * NIX proporciona una infraestructura de pseudo-terminal (PTY) que facilita la creaci√≥n de canales de comunicaci√≥n para una consola o servicio.  Pero en Windows no era ... <br><br>  <i><b>... hasta ahora!</b></i> <br><a name="habracut"></a><br><h1>  De TTY a PTY </h1><br>  Antes de contar en detalle sobre nuestro desarrollo, regresemos brevemente al desarrollo de terminales. <br><br><h2>  Al principio era TTY </h2><br>  Como se discuti√≥ en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo anterior</a> , en los primeros d√≠as de la inform√°tica, los usuarios controlaban las computadoras utilizando teletipos electromec√°nicos (TTY) conectados a una computadora a trav√©s de alg√∫n tipo de canal de comunicaci√≥n en serie (generalmente a trav√©s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un circuito de corriente de 20 mA</a> ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f7b/e47/7fa/f7be477fac4e46cc71e70df23b26bef6.jpg"><br>  <font color="gray"><i>Ken Thompson y Dennis Ritchie (de pie) trabajan en el teletipo DEC PDP-11 (mensajes sin pantalla electr√≥nica)</i></font> <br><br><h3>  Distribuci√≥n terminal </h3><br>  Los teletipos fueron reemplazados por terminales computarizados con pantallas electr√≥nicas (generalmente pantallas CRT).  Por lo general, los terminales son dispositivos muy simples (de ah√≠ el t√©rmino "terminal tonto"), que contienen solo la electr√≥nica y la potencia de procesamiento necesaria para las siguientes tareas: <br><br><ol><li>  Recepci√≥n de entrada de texto desde el teclado. </li><li>  Almacenar el texto ingresado en una l√≠nea (incluida la edici√≥n local antes del env√≠o). </li><li>  Enviar / recibir texto en un canal en serie (generalmente a trav√©s de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">interfaz RS-232,</a> una vez ubicua). </li><li>  Visualizaci√≥n del texto recibido en la pantalla del terminal. </li></ol><br>  A pesar de su simplicidad (o quiz√°s gracias a √©l), los terminales se convirtieron r√°pidamente en el principal medio para administrar minicomputadoras, mainframes y servidores: la mayor√≠a de los operadores de entrada de datos, operadores de computadoras, administradores de sistemas, cient√≠ficos, investigadores, desarrolladores de software y luminarias de la industria trabajaban en terminales DEC, IBM, Wyse y muchos otros. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/929/e3f/fd0/929e3ffd0e281600c9ef115f61b8b23a.jpg"><br>  <i><font color="gray">Almirante Grace Hopper en su oficina con un terminal DEC VT220 en su escritorio</font></i> <br><br><h3>  Distribuci√≥n de terminales de software. </h3><br>  Desde mediados de la d√©cada de 1980, en lugar de terminales especializadas, las computadoras de uso general han comenzado a usarse gradualmente, y se han vuelto m√°s asequibles, populares y potentes.  Muchas de las primeras PC y otras computadoras de los a√±os 80 ten√≠an aplicaciones terminales que abr√≠an la conexi√≥n RS-232 a la PC e intercambiaban datos con cualquier persona en el otro extremo de la conexi√≥n. <br><br>  A medida que las computadoras de uso general se volvieron m√°s sofisticadas, apareci√≥ una interfaz gr√°fica de usuario (GUI) y un mundo completamente nuevo de aplicaciones concurrentes, incluidas aplicaciones de terminal. <br><br>  Pero hab√≠a un problema: ¬øc√≥mo puede interactuar una aplicaci√≥n de terminal con otra aplicaci√≥n de l√≠nea de comandos que se ejecuta en la misma m√°quina?  ¬øY c√≥mo conectar f√≠sicamente un cable serial entre dos aplicaciones que se ejecutan en la misma computadora? <br><br><h2>  Apariencia pseudo terminal (PTY) </h2><br>  En el mundo * NIX, el problema se resolvi√≥ mediante la introducci√≥n de un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pseudo terminal (PTY)</a> . <br><br>  PTY emula equipos de telecomunicaciones en serie en una computadora al exponer los pseudodispositivos maestro y esclavo ("maestro" y "esclavo"): las aplicaciones de terminal se conectan al pseudodispositivo maestro y las aplicaciones de l√≠nea de comandos (por ejemplo, shells como cmd, PowerShell y bash) se conectan al pseudodispositivo esclavo.  Cuando un cliente terminal transmite comandos de texto y / o control (codificados como texto) al pseudodispositivo maestro, el texto se traduce al esclavo asociado con √©l.  El texto de la aplicaci√≥n se env√≠a al pseudodispositivo esclavo, luego de regreso al maestro y, por lo tanto, al terminal.  Los datos siempre se env√≠an / ‚Äã‚Äãreciben de forma asincr√≥nica. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a42/2ba/b58/a422bab5816acdd43dd7b1c562d65caf.png"><br>  <i><font color="gray">Aplicaci√≥n de pseudo terminal / Shell</font></i> <br><br>  Es importante tener en cuenta que el pseudodispositivo "esclavo" emula el comportamiento del terminal f√≠sico y convierte los caracteres del comando en se√±ales POSIX.  Por ejemplo, si el usuario ingresa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CTRL + C</a> en el terminal, el valor ASCII para CTRL + C (0x03) se env√≠a a trav√©s del maestro.  Cuando se recibe en un pseudodispositivo esclavo, el valor 0x03 se elimina del flujo de entrada y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se</a> genera una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se√±al SIGINT</a> . <br><br>  Dicha infraestructura PTY es ampliamente utilizada por aplicaciones de terminal * NIX, administradores de paneles de texto (por ejemplo, pantalla, tmux), etc.  Estas aplicaciones llaman a <code>openpty()</code> , que devuelve un par de descriptores de archivo (fd) para el maestro y esclavo PTY.  Luego, la aplicaci√≥n puede bifurcar / ejecutar una aplicaci√≥n secundaria de l√≠nea de comandos (por ejemplo, bash), que usa sus esclavos fd para escuchar y devolver texto al terminal conectado. <br><br>  Este mecanismo permite que las aplicaciones de terminal "hablen" directamente con las aplicaciones de l√≠nea de comandos que se ejecutan localmente, tal como un terminal hablar√≠a con una computadora remota a trav√©s de una conexi√≥n en serie / red. <br><br><h2>  ¬øQu√©, no pseudo-consola de Windows? </h2><br>  Como discutimos en el art√≠culo anterior, si bien la consola de Windows es conceptualmente similar al terminal tradicional * NIX, difiere en varias formas clave, especialmente en los niveles m√°s bajos, lo que puede causar problemas para los desarrolladores de aplicaciones de l√≠nea de comandos de Windows, terminales / consolas y servidores de terceros aplicaciones: <br><br><ol><li>  <b>Windows no tiene la infraestructura PTY</b> : cuando un usuario inicia una aplicaci√≥n de l√≠nea de comandos (por ejemplo, Cmd, PowerShell, wsl, ipconfig, etc.), el propio Windows "conecta" una instancia de consola nueva o existente a la aplicaci√≥n. </li><li>  <b>Windows interfiere con las consolas y aplicaciones de servidor de terceros</b> : Windows (actualmente) no brinda a los terminales una forma de proporcionar canales de comunicaci√≥n a trav√©s de los cuales desean interactuar con una aplicaci√≥n de l√≠nea de comandos.  ¬°Los terminales de terceros tienen que crear consolas fuera de la pantalla, enviar datos ingresados ‚Äã‚Äãpor el usuario all√≠ y desechar la salida redibuj√°ndola en la pantalla de la consola de terceros! </li><li>  <b>Solo Windows tiene la API de consola</b> : las aplicaciones de l√≠nea de comandos de Windows dependen de la API de Win32 Consol, que reduce la portabilidad del c√≥digo, ya que todas las dem√°s plataformas admiten texto / VT, no la API. </li><li>  <b>Acceso remoto no est√°ndar</b> : la dependencia de las aplicaciones de l√≠nea de comandos de la API de Consol complica significativamente la interacci√≥n y los scripts de acceso remoto. </li></ol><br><h2>  Que hacer </h2><br>  Muchos, <b>muchos</b> desarrolladores a menudo solicitaron un mecanismo similar a PTY en Windows, especialmente aquellos que trabajan con ConEmu / Cmder, Console2 / ConsoleZ, Hyper, VSCode, Visual Studio, WSL, Docker y OpenSSH. <br><br>  Incluso Peter Bright, editor de tecnolog√≠a de Ars Technica, me pidi√≥ que implementara el mecanismo PTY unos d√≠as despu√©s cuando comenc√© a trabajar en el equipo de la consola: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2dd/799/ebf/2dd799ebf0c14f418ae7d68d9a26acaa.png"><br><br>  Y recientemente nuevamente: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4d1/c1e/c00/4d1c1ec00ffe5ad5e6f019d1a33198c8.png"><br><br>  Bueno, finalmente lo hicimos: <b>creamos una pseudo-consola para Windows</b> : <br><br><h1>  Bienvenido a la Pseudo Consola de Windows (ConPTY) </h1><br>  Desde la formaci√≥n del Equipo de consola hace unos cuatro a√±os, el grupo se ha dedicado a la revisi√≥n de la consola de Windows y los mecanismos internos de la l√≠nea de comando.  Al mismo tiempo, consideramos regularmente y cuidadosamente los problemas descritos anteriormente y muchos otros problemas y problemas relacionados.  Pero la infraestructura y el c√≥digo no estaban listos para hacer posible el lanzamiento de la pseudo-consola ... ¬°hasta ahora! <br><br>  La nueva infraestructura de pseudo-consola de Windows (ConPTY), API y algunos otros cambios relacionados eliminar√°n / aliviar√°n toda una clase de problemas ... ¬° <b>sin romper la compatibilidad con las aplicaciones de l√≠nea de comandos existentes</b> ! <br><br><blockquote>  La nueva API Win32 ConPTY (la documentaci√≥n oficial se publicar√° pronto) ahora est√° disponible en las √∫ltimas compilaciones internas de Windows 10 y el correspondiente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SDK de Windows 10 Insider Preview</a> .  Aparecer√°n en la pr√≥xima versi√≥n principal de Windows 10 (en alg√∫n momento del oto√±o / invierno de 2018). </blockquote><br><h2>  Consola / ConHost Architecture </h2><br>  Para comprender ConPTY, debe estudiar la arquitectura de la consola de Windows, o m√°s bien ... ¬°ConHost! <br><br>  Es importante comprender que, aunque ConHost implementa todo lo que ve y conoce como una aplicaci√≥n de consola de Windows, ¬°ConHost tambi√©n contiene e implementa la mayor parte de la infraestructura de l√≠nea de comandos de Windows!  ¬°A partir de ahora, <b>ConHost se convierte en un verdadero "nodo de consola"</b> , que admite todas las aplicaciones de l√≠nea de comandos y / o aplicaciones GUI que interact√∫an con las aplicaciones de l√≠nea de comandos! <br><br>  <b>Como?</b>  <b>Por qu√©</b>  <b>Que?</b>  Echemos un vistazo m√°s de cerca. <br><br>  Aqu√≠ hay una vista de alto nivel de la arquitectura interna de la consola / ConHost: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/331/1bd/54d/3311bd54dbe80dc699ff243a4812b58a.png"><br><br>  En comparaci√≥n con la arquitectura del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo anterior</a> , ConHost ahora contiene varios m√≥dulos adicionales para el procesamiento de TV y el nuevo m√≥dulo ConPTY que implementa API abiertas: <br><br><ul><li>  <b>API ConPTY</b> : Las nuevas API Win32 ConPTY proporcionan un mecanismo similar al modelo POSIX PTY, pero en la refracci√≥n de Windows. </li><li>  <b>Interactividad VT</b> : recibe texto de entrada en codificaci√≥n UTF-8, convierte cada car√°cter de texto mostrado en el registro <code>INPUT_RECORD</code> correspondiente y lo guarda en el b√∫fer de entrada.  Tambi√©n procesa secuencias de escape, como 0x03 (CTRL + C), convirti√©ndolas en <code>KEY_EVENT_RECORDS</code> , que producen la acci√≥n de escape adecuada. </li><li>  <b>Renderizador de VT</b> : genera secuencias de VT necesarias para mover el cursor y representar texto y estilo en √°reas del b√∫fer de salida que han cambiado desde el fotograma anterior. </li></ul><br>  OK, pero ¬øqu√© significa realmente? <br><br><h2>  ¬øC√≥mo funcionan las aplicaciones de l√≠nea de comandos de Windows? </h2><br>  Para comprender mejor el impacto de la nueva infraestructura ConPTY, echemos un vistazo a c√≥mo la consola de Windows y las aplicaciones de l√≠nea de comandos han funcionado hasta ahora. <br><br>  Cada vez que un usuario inicia una aplicaci√≥n de l√≠nea de comandos como Cmd, PowerShell o ssh, Windows crea un nuevo proceso Win32 en el que carga el binario ejecutable de la aplicaci√≥n y cualquier dependencia (recursos o bibliotecas). <br><br>  Un proceso reci√©n creado generalmente hereda los descriptores stdin y stdout de su padre.  Si el proceso principal era un proceso de GUI de Windows, entonces faltan los descriptores stdin y stdout, por lo que Windows implementar√° y adjuntar√° la nueva aplicaci√≥n a la nueva instancia de la consola.  La comunicaci√≥n entre las aplicaciones de l√≠nea de comandos y su consola se transmite a trav√©s de ConDrv. <br><br>  Por ejemplo, al comenzar desde una instancia de PowerShell sin privilegios elevados, el nuevo proceso de aplicaci√≥n heredar√° los descriptores primarios stdin / stdout y, por lo tanto, recibir√° datos de entrada y enviar√° la salida a la misma consola que el padre. <br><br><blockquote>  Aqu√≠ tenemos que hacer una reserva, ya que en algunos casos las aplicaciones de l√≠nea de comandos se lanzan adjuntas a una <i>nueva</i> instancia de la consola, especialmente por razones de seguridad, pero la descripci√≥n anterior suele ser cierta. </blockquote><br>  Finalmente, cuando se inicia la aplicaci√≥n de l√≠nea de comandos / shell, Windows la conecta a la instancia de la consola (ConHost.exe) a trav√©s de ConDrv: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc3/4c8/d37/fc34c8d37f6f31c843422193bd5d01a6.png"><br><br><h2>  ¬øC√≥mo funciona ConHost? </h2><br>  Cada vez que se ejecuta una aplicaci√≥n de l√≠nea de comandos, Windows conecta la aplicaci√≥n a una instancia nueva o existente de ConHost.  La aplicaci√≥n y su instancia de consola est√°n conectadas a trav√©s del controlador de consola en modo kernel (ConDrv), que env√≠a / recibe mensajes IOCTL que contienen solicitudes de llamadas API serializadas y / o datos de texto. <br><br>  Hist√≥ricamente, como se indic√≥ en un art√≠culo anterior, el trabajo de ConHost es relativamente simple hoy en d√≠a: <br><br><ul><li>  El usuario genera informaci√≥n desde el teclado / mouse / bol√≠grafo / panel t√°ctil, que se convierte a <code>KEY_EVENT_RECORD</code> o <code>MOUSE_EVENT_RECORD</code> y se almacena en el b√∫fer de entrada. </li><li>  El b√∫fer de entrada se vac√≠a un registro a la vez, realizando las acciones de entrada solicitadas, como mostrar texto en la pantalla, mover el cursor, copiar / pegar texto, etc.  Muchas de estas acciones cambian el contenido del b√∫fer de salida.  Estas √°reas cambiadas son registradas por el motor de estado ConHost. </li><li>  En cada cuadro, la consola muestra las √°reas cambiadas del b√∫fer de salida. </li></ul><br>  Cuando la aplicaci√≥n de l√≠nea de comandos llama a la API de la consola de Windows, las llamadas a la API se serializan en mensajes IOCTL y se env√≠an a trav√©s del controlador ConDrv.  Luego entrega mensajes IOCTL a la consola adjunta, que decodifica y ejecuta la llamada API solicitada.  Los valores devueltos / de salida se vuelven a serializar al mensaje IOCTL y se env√≠an de vuelta a la aplicaci√≥n a trav√©s de ConDrv. <br><br><h2>  ConHost: contribuyendo al pasado para el futuro </h2><br>  Microsoft se esfuerza por mantener la compatibilidad con las aplicaciones y herramientas existentes siempre que sea posible.  Especialmente para la l√≠nea de comando.  De hecho, las versiones de 32 bits de Windows 10 a√∫n pueden ejecutar muchas / la mayor√≠a de las aplicaciones y ejecutables Win16 de 16 bits. <br><br>  Como se mencion√≥ anteriormente, una de las funciones clave de ConHost es proporcionar servicios a sus aplicaciones de l√≠nea de comandos, especialmente las aplicaciones heredadas que invocan y dependen de la API de la consola Win32.  Ahora ConHost ofrece nuevos servicios: <br><br><ul><li>  Infraestructura sin costuras tipo PTY para la comunicaci√≥n con consolas y terminales modernas </li><li>  Actualizaci√≥n de aplicaciones de l√≠nea de comandos tradicionales / heredadas <br><ul><li>  Recibir y convertir texto UTF-8 / VT para ingresar registros (como si los hubiera ingresado el usuario) </li><li>  Consola API llama a la aplicaci√≥n alojada, actualizando su b√∫fer de salida en consecuencia </li><li>  Mostrar √°reas modificadas del b√∫fer de salida en codificaci√≥n UTF-8, texto / VT </li></ul></li></ul><br>  El siguiente es un ejemplo de c√≥mo una aplicaci√≥n de consola moderna se comunica con una aplicaci√≥n de l√≠nea de comandos a trav√©s de ConPTY ConHost. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d72/7db/35e/d727db35e65b2e0eec45d0d535b4de83.png"><br><br>  En este nuevo modelo: <br><br><ol><li>  Consola: <br><ol><li>  Crea canales de comunicaci√≥n propios. </li><li>  Llama a la API de ConPTY para crear ConPTY, lo que obliga a Windows a ejecutar una instancia de ConHost conectada al otro extremo de los canales </li><li>  Crea una instancia de una aplicaci√≥n de l√≠nea de comandos (por ejemplo, PowerShell) conectada a ConHost, como de costumbre </li></ol></li><li>  Conhost: <br><ol><li>  Lee el texto UTF-8 / VT en la entrada y lo convierte en registros <code>INPUT_RECORD</code> , que se env√≠an a la aplicaci√≥n de l√≠nea de comando </li><li>  Realizar llamadas API desde una aplicaci√≥n de l√≠nea de comandos que puede modificar el contenido del b√∫fer de salida </li><li>  Muestra los cambios en el b√∫fer de salida en la codificaci√≥n UTF-8 (texto / VT) y env√≠a el texto recibido a su consola </li></ol></li><li>  Aplicaci√≥n de l√≠nea de comando: <br><ol><li>  Funciona como de costumbre, lee la entrada y llama a la API de la consola, ¬°sin tener idea de que su ConPTY ConHost traduce la entrada y salida de / a UTF-8! </li></ol></li></ol><br>  ¬°El √∫ltimo momento es importante!  Cuando la antigua aplicaci√≥n de l√≠nea de comandos usa llamadas a la API de la consola como <code>WriteConsoleOutput(...)</code> , el texto especificado se escribe en el b√∫fer de salida ConHost correspondiente.  Peri√≥dicamente, ConHost muestra las √°reas cambiadas del b√∫fer de salida como texto / VT, que se env√≠a a trav√©s de stdout a la consola. <br><br>  En √∫ltima instancia, ¬°incluso las aplicaciones de l√≠nea de comandos tradicionales desde el exterior "hablan" el texto / VT <b>sin ning√∫n cambio</b> ! <br><br>  Usando la nueva infraestructura ConPTY, las consolas de terceros ahora pueden interactuar directamente con aplicaciones de l√≠nea de comandos modernas y tradicionales e intercambiarlas todas en texto / VT. <br><br><h2>  Interactuando remotamente con las aplicaciones de l√≠nea de comandos de Windows </h2><br>  El mecanismo descrito anteriormente funciona bien en una computadora, pero tambi√©n ayuda al interactuar, por ejemplo, con una instancia de PowerShell en una computadora remota de Windows o en un contenedor. <br><br>  Hay un problema al iniciar una aplicaci√≥n de l√≠nea de comandos de forma remota (es decir, en computadoras remotas, servidores o contenedores).  El hecho es que las aplicaciones de l√≠nea de comandos en m√°quinas remotas se comunican con la instancia local de ConHost, porque los mensajes IOCTL no est√°n dise√±ados para transmitirse a trav√©s de la red.  ¬øC√≥mo transferir la entrada de la consola local a la m√°quina remota y c√≥mo obtener la salida de la aplicaci√≥n que se ejecuta all√≠?  Adem√°s, ¬øqu√© hacer con las m√°quinas Mac y Linux, donde hay terminales pero no hay consolas compatibles con Windows? <br><br>  Por lo tanto, para controlar de forma remota la m√°quina Windows, necesitamos alg√∫n tipo de agente de comunicaci√≥n que pueda serializar datos de manera transparente a trav√©s de la red, administrar la vida √∫til de la instancia de la aplicaci√≥n, etc. <br><br>  Tal vez algo como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ssh</a> ? <br><br>  Afortunadamente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OpenSSH se</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">port√≥</a> recientemente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">a Windows</a> y se agreg√≥ como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una opci√≥n adicional a Windows 10</a> .  PowerShell Core tambi√©n usa ssh como uno de los protocolos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">remotos</a> compatibles de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PowerShell Core Remoting</a> .  Y para aquellos que ejecutan Windows PowerShell, la comunicaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">remota de Windows PowerShell</a> todav√≠a es una opci√≥n aceptable. <br><br>  Veamos c√≥mo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OpenSSH para Windows ahora le</a> permite controlar de forma remota <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los</a> shells de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Windows</a> y las aplicaciones de l√≠nea de comandos: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/30e/7fc/eeb/30e7fceebcbcea167c2d50d448c975a4.png"><br><br>  OpenSSH actualmente incluye algunas complicaciones no deseadas: <br><br><ol><li>  Usuario: <br><ol><li>  Inicia el cliente ssh y Windows conecta la instancia de la consola como de costumbre. </li><li>  Introduce texto en la consola, que env√≠a pulsaciones de teclas al cliente ssh </li></ol></li><li>  cliente ssh: <br><ol><li>  Lee la entrada como bytes de datos de texto </li><li>  Env√≠a datos de texto a trav√©s de la red al servicio de escucha sshd </li></ol></li><li>  El servicio sshd pasa por varias etapas: <br><ol><li>  Inicia el shell predeterminado (por ejemplo, Cmd), que obliga a Windows a crear y conectar una nueva instancia de la consola. </li><li>  Encuentra y se conecta a la consola de la instancia de Cmd </li><li>  Mueve la consola fuera de la pantalla (y / o la oculta) </li><li>  Env√≠a la entrada recibida del cliente ssh a la consola fuera de la pantalla como entrada </li></ol></li><li>  La instancia de cmd funciona como siempre: <br><ol><li>  Recopila informaci√≥n del servicio sshd </li><li>  El trabajo </li><li>  Llama a la API de la consola para representar / dise√±ar texto, mover el cursor, etc. </li></ol></li><li>  Consola adjunta [fuera de pantalla]: <br><ol><li>  Realice llamadas de API actualizando el b√∫fer de salida. </li></ol></li><li>  Servicio sshd: <br><ol><li>  Desecha el b√∫fer de salida de la consola fuera de la pantalla, encuentra las diferencias, las codifica en texto / VT y las env√≠a de vuelta ... </li></ol></li><li>  Un cliente ssh que env√≠a texto ... </li><li>  Consola que muestra texto </li></ol><br>  <b>Diversi√≥n, verdad?</b>  <b>¬°Para nada!</b>  En esta situaci√≥n, muchas cosas pueden salir mal, especialmente en el proceso de simular y enviar la entrada del usuario y vaciar el b√∫fer de salida de una consola fuera de la pantalla.  Esto conduce a la inestabilidad, bloqueos, corrupci√≥n de datos, consumo excesivo de energ√≠a, etc.  Adem√°s, no todas las aplicaciones hacen el trabajo de eliminar no solo el texto en s√≠, sino tambi√©n sus propiedades, ¬°por eso se pierden el formato y el color! <br><br><h3>  Trabajo remoto utilizando ConHost y ConPTY modernos </h3><br>  <b>¬øSeguramente podemos mejorar la situaci√≥n?</b>  S√≠, por supuesto que podemos, hagamos algunos cambios arquitect√≥nicos y apliquemos nuestro nuevo ConPTY: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e8/677/f1d/5e8677f1da3a8abcf2951f4e539c6470.png"><br><br>  El diagrama muestra que el circuito ha cambiado de la siguiente manera: <br><br><ol><li>  Usuario: <br><ol><li>  Inicia el cliente ssh y Windows conecta la instancia de la consola como de costumbre. </li><li>  Introduce texto en la consola, que env√≠a pulsaciones de teclas al cliente ssh </li></ol></li><li>  cliente ssh: <br><ol><li>  Lee la entrada como bytes de datos de texto </li><li>  Env√≠a datos de texto a trav√©s de la red al servicio de escucha sshd </li></ol></li><li>  Servicio sshd: <br><ol><li>  Crea canales stdin / stdout </li><li>  Llama a la API de ConPTY para iniciar ConPTY </li><li>  Inicia una instancia de Cmd conectada al otro extremo de ConPTY.  Windows inicia y monta una nueva instancia de ConHost </li></ol></li><li>  La instancia de cmd funciona como siempre: <br><ol><li>  Recopila informaci√≥n del servicio sshd </li><li>  El trabajo </li><li>  Llama a la API de la consola para representar / dise√±ar texto, mover el cursor, etc. </li></ol></li><li>  Instancia ConPTY ConHost: <br><ol><li>  Realice llamadas de API actualizando el b√∫fer de salida. </li><li>  Muestra las regiones modificadas del b√∫fer de salida como texto / VT codificado UTF-8, que se env√≠a de vuelta a la consola / terminal a trav√©s de ssh </li></ol></li></ol><br>  Este enfoque utilizando ConPTY es claramente m√°s limpio y simple para el servicio sshd.  Las llamadas a la API de la consola de Windows se realizan completamente en la instancia de ConHost de la aplicaci√≥n de l√≠nea de comandos, que convierte todos los cambios visibles en texto / VT.  Quien se conecta a ConHost, no necesita saber que la aplicaci√≥n all√≠ llama a la API de la consola, ¬°y no genera texto / VT! <br><br>  Acuerde que este nuevo mecanismo de comunicaci√≥n remota ConPTY conduce a una arquitectura elegante, consistente y simple.  En combinaci√≥n con las potentes funciones integradas en ConHost, el soporte para aplicaciones m√°s antiguas y la visualizaci√≥n de cambios de las aplicaciones que llaman a las API de consola de la consola como texto / VT, la nueva infraestructura ConHost y ConPTY nos ayuda a mover el pasado hacia el futuro. <br><br><h1>  API de ConPTY y c√≥mo usarlo </h1><br><blockquote>  ConPTY API est√° disponible en la versi√≥n actual de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Windows 10 Insider Preview SDK</a> . </blockquote><br>  Por ahora, estoy seguro de que no puedes esperar para ver alg√∫n c√≥digo;) <br><br>  Echa un vistazo a las declaraciones de API: <br><br><pre> <code class="hljs pgsql">// Creates a "Pseudo Console" (ConPTY). HRESULT WINAPI CreatePseudoConsole( _In_ COORD size, // ConPty Dimensions _In_ HANDLE hInput, // ConPty <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> _In_ HANDLE hOutput, // ConPty Output _In_ DWORD dwFlags, // ConPty Flags _Out_ HPCON* phPC); // ConPty Reference // Resizes the given ConPTY <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the specified size, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> characters. HRESULT WINAPI ResizePseudoConsole(_In_ HPCON hPC, _In_ COORD size); // Closes the ConPTY <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> associated handles. Client applications attached // <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the ConPTY will <span class="hljs-keyword"><span class="hljs-keyword">also</span></span> terminated. <span class="hljs-type"><span class="hljs-type">VOID</span></span> WINAPI ClosePseudoConsole(_In_ HPCON hPC);</code> </pre> <br>  El API ConPTY anterior expone esencialmente tres nuevas funciones para su uso: <br><br><ul><li> <b><code>CreatePseudoConsole(size, hInput, hOutput, dwFlags, phPC)</code></b> <br> <ul><li>  Crea pty con dimensi√≥n en columnas <code>w</code> y l√≠neas <code>h</code> , utilizando canales creados por la persona que llama: <br><ul><li>  <code>size</code> : ancho y alto (en caracteres) del b√∫fer ConPTY </li><li>  <code>hInput</code> : para escribir datos de entrada en PTY como secuencias de texto / VT en codificaci√≥n UTF-8 </li><li>  <code>hOutput</code> : para leer la salida de PTY como secuencias de texto / VT en codificaci√≥n UTF-8 </li><li>  <code>dwFlags</code> : valores posibles: <br><ul><li>  <code>PSEUDOCONSOLE_INHERIT_CURSOR</code> : el <code>PSEUDOCONSOLE_INHERIT_CURSOR</code> creado intentar√° heredar la posici√≥n del cursor de la aplicaci√≥n de terminal principal </li></ul></li><li>  <code>phPC</code> : manejador de consola generado por ConPty </li></ul></li><li>  <b>Devoluciones</b> : √©xito / fracaso.  Si tiene √©xito, phPC contiene el identificador de la nueva ConPty </li></ul><br> <b><code>ResizePseudoConsole(hPC, size)</code></b> <br> <ul><li>  Cambia el tama√±o del b√∫fer interno ConPTY para mostrar un ancho y alto espec√≠ficos </li></ul><br> <b><code>ClosePseudoConsole (hPC)</code></b> <br> <ul><li>  ConPTY    .  ,   ConPTY,  ,        ,   </li></ul><br><h2>  ConPTY API </h2><br>       ConPTY API           ConPTY. <br><br><blockquote> :      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  GitHub</a> </blockquote><br><pre> <code class="hljs ruby"> /<span class="hljs-regexp"><span class="hljs-regexp">/ Note: Most error checking removed for brevity. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Initializes the specified startup info struct with the required properties and /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ updates its thread attribute list with the specified ConPTY handle HRESULT InitializeStartupInfoAttachedToConPTY(STARTUPINFOEX* siEx, HPCON hPC) { HRESULT hr = E_UNEXPECTED; size_t size; siEx-&gt;StartupInfo.cb = sizeof(STARTUPINFOEX); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Create the appropriately sized thread attribute list InitializeProcThreadAttributeList(NULL, 1, 0, &amp;size); std::unique_ptr&lt;BYTE[]&gt; attrList = std::make_unique&lt;BYTE[]&gt;(size); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Set startup info's attribute list &amp; initialize it siEx-&gt;lpAttributeList = reinterpret_cast&lt;PPROC_THREAD_ATTRIBUTE_LIST&gt;( attrList.get()); bool fSuccess = InitializeProcThreadAttributeList( siEx-&gt;lpAttributeList, 1, 0, (PSIZE_T)&amp;size); if (fSuccess) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Set thread attribute list's Pseudo Console to the specified ConPTY fSuccess = UpdateProcThreadAttribute( lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_PSEUDOCONSOLE, hPC, sizeof(HPCON), NULL, NULL); return fSuccess ? S_OK : HRESULT_FROM_WIN32(GetLastError()); } else { hr = HRESULT_FROM_WIN32(GetLastError()); } return hr; } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... HANDLE hOut, hIn; HANDLE outPipeOurSide, inPipeOurSide; HANDLE outPipePseudoConsoleSide, inPipePseudoConsoleSide; HPCON hPC = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Create the in/out</span></span> <span class="hljs-symbol"><span class="hljs-symbol">pipes:</span></span> CreatePipe(&amp;inPipePseudoConsoleSide, &amp;inPipeOurSide, NULL, <span class="hljs-number"><span class="hljs-number">0</span></span>); CreatePipe(&amp;outPipeOurSide, &amp;outPipePseudoConsoleSide, NULL, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Create the Pseudo Console, using the pipes CreatePseudoConsole( {<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>}, inPipePseudoConsoleSide, outPipePseudoConsoleSide, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;hPC); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Prepare the StartupInfoEx structure attached to the ConPTY. STARTUPINFOEX siEx{}; InitializeStartupInfoAttachedToConPTY(&amp;siEx, hPC); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Create the client application, using startup info containing ConPTY info wchar_t* commandline = L<span class="hljs-string"><span class="hljs-string">"c:\\windows\\system32\\cmd.exe"</span></span>; PROCESS_INFORMATION piClient{}; fSuccess = CreateProcessW( nullptr, commandline, nullptr, nullptr, TRUE, EXTENDED_STARTUPINFO_PRESENT, nullptr, nullptr, &amp;siEx-&gt;StartupInfo, &amp;piClient); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ...</code> </pre> <br>  cmd.exe    ConPTY,  <code>CreatePseudoConsole()</code> .       ConPTY     /  Cmd.      <code>ResizePseudoConsole()</code> ,   ‚Äî   <code>ClosePseudoConsole()</code> . <br><br><h3>    </h3><br>     ConPTY  : <br><br><pre> <code class="hljs pgsql">// <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> "echo Hello, World!", press enter <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> have cmd process the command, // <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> an up arrow (<span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> the previous command), <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> enter again <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span>. std::string helloWorld = "echo Hello, World!\n\x1b[A\n"; DWORD dwWritten; WriteFile(hIn, helloWorld.c_str(), (DWORD)helloWorld.length(), &amp;dwWritten, nullptr);</code> </pre> <br><h3>    </h3><br>   ,    ConPTY: <br><br><pre> <code class="hljs pgsql">// Suppose <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> other async callback triggered us <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resize. // This <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> will <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> the Terminal <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> the size we received. HRESULT hr = ResizePseudoConsole(hPC, {<span class="hljs-number"><span class="hljs-number">120</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>});</code> </pre> <br><h3>   </h3><br>     ConPTY: <br><br><pre> <code class="hljs lisp">ClosePseudoConsole(<span class="hljs-name"><span class="hljs-name">hPC</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br> :  ConPTY   ConHost    . <br><br><h1>   ! </h1><br>  ConPTY API ‚Äî ,       ,     Windows   ‚Ä¶   <i></i> ! <br><br>     ConPTY API   Microsoft,        Microsoft ( Windows  Linux (WSL),  Windows Containers, VSCode, Visual Studio  .),      ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@ConEmuMaximus5</a> ‚Äî    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ConEmu</a>  Windows. <br><br> <b>    </b> ,        ConPTY API. <br><br><h2>     </h2><br>       ,        : ConHost     .           Console API.     ,          ,    . <br><br>   ,      VT, ,    ‚Äî  . <br><br>   ,     <b></b>    Windows,      /VT   UTF-8    Console API:  ¬´  VT¬ª     ,      Console API (, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> 16M RGB True Color</a> ). <br><br><h2>   / </h2><br>       /     ,             ConPTY API:         ,  ,    ,   ,   . <br><br><blockquote>     VSCode      ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub #45693</a> )   ,     Windows. </blockquote><br><h2>  ConPTY API </h2><br>  ConPTY API     Windows 10 / 2018 . <br><br>      Windows, ,    ,     ConPTY.     Win32 API,     API    Runtime Dynamic Linking   <code>LoadLibrary()</code>  <code>GetProcAddress()</code> . <br><br>    Windows  ConPTY,        API ConPTY.  ,     ,    . <br><br><h1> ,    ? </h1><br>    ‚Ä¶   !  ,       , <b></b> !  : D <br><br>       ,   , <i></i>    ,   <i></i>  .   ‚Äî            ,          Windows  ,   . <br><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a> .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> Windows Console  GitHub</a> .    , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">    </a> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420853/">https://habr.com/ru/post/es420853/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420837/index.html">Prueba de matrices RAID de software para dispositivos NVMe utilizando la metodolog√≠a SNIA</a></li>
<li><a href="../es420841/index.html">Revisi√≥n prehospitalaria o "¬°Hola, Swagger! ¬øD√≥nde est√°n mis errores?</a></li>
<li><a href="../es420843/index.html">7 de septiembre, Ekaterimburgo: una reuni√≥n para desarrolladores de .NET</a></li>
<li><a href="../es420845/index.html">La domesticaci√≥n del obstinado con el uso de una muleta: el orificio del adaptador Wi-Fi WF2190 (Realtek8812AU Wireless LAN 802.11ac USB)</a></li>
<li><a href="../es420847/index.html">Introducci√≥n a la programaci√≥n de sombreadores para dise√±os</a></li>
<li><a href="../es420857/index.html">Roaming Wi-Fi sin interrupciones: teor√≠a en la pr√°ctica</a></li>
<li><a href="../es420859/index.html">A la pregunta de Wirth y cadenas</a></li>
<li><a href="../es420861/index.html">Prepar√°ndose para C ++ 20. Estudio de caso de Coroutines TS Real</a></li>
<li><a href="../es420863/index.html">Como hicimos el primer tel√©fono inteligente ruso, continu√≥</a></li>
<li><a href="../es420865/index.html">El principio de menor acci√≥n. Parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>