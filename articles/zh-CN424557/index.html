<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🔬 🏏 👵🏽 Node.js指南，第8部分：HTTP和WebSocket协议 🤚🏽 🎇 👳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Node.js是一个服务器平台。 服务器的主要任务是尽可能快而有效地处理来自客户端（尤其是来自浏览器）的请求。 我们今天发布的Node.js教程的译文的第八篇是关于HTTP和WebSocket的。 

  

 [我们建议您阅读]周期的其他部分  第1部分： 一般信息和入门 
 第2部分： Java...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js指南，第8部分：HTTP和WebSocket协议</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424557/">  Node.js是一个服务器平台。 服务器的主要任务是尽可能快而有效地处理来自客户端（尤其是来自浏览器）的请求。 我们今天发布的Node.js教程的译文的第八篇是关于HTTP和WebSocket的。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[我们建议您阅读]周期的其他部分</b> <div class="spoiler_text"> 第1部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一般信息和入门</a> <br> 第2部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JavaScript，V8，一些开发技巧</a> <br> 第3部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">托管，REPL，使用控制台，模块</a> <br> 第4部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">npm，package.json和package-lock.json文件</a> <br> 第5部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">npm和npx</a> <br> 第6部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">事件循环，调用堆栈，计时器</a> <br> 第7部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">异步编程</a> <br> 第8部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Node.js指南，第8部分：HTTP和WebSocket协议</a> <br> 第9部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Node.js指南，</a>第9 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">部分：使用文件系统</a> <br> 第10部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Node.js指南，第10部分：标准模块，流，数据库，NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Node.js指南的完整PDF</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">发出HTTP请求时会发生什么？</font> </h2><br> 让我们谈谈浏览器如何使用HTTP / 1.1协议向服务器发出请求。 <br><br> 如果您曾经在IT领域接受过采访，那么您可能会被问到在浏览器的地址栏中键入内容并按Enter时会发生什么。 也许这是在此类采访中出现的最受欢迎的问题之一。 任何提出此类问题的人都想知道您是否可以解释一些非常简单的概念，并了解您是否了解Internet的原理。 <br><br> 这个问题涉及许多技术，要了解其一般原理，就意味着要了解如何构建人类有史以来最复杂的系统之一，该系统涵盖整个世界。 <br><br><h3>  <font color="#3AC1EF">▍HTTP协议</font> </h3><br> 现代浏览器能够将输入其地址栏中的真实URL与搜索查询区分开，通常使用默认搜索引擎进行处理。 我们将讨论URL。 如果在浏览器栏中输入站点地址（例如<code>flaviocopes.com</code> ，则浏览器会基于HTTP协议将用于与指定资源交换数据的假设，将该地址转换为<code>http://flaviocopes.com</code>形式。 请注意，在Windows上，我们要讨论的内容可能与macOS和Linux上的有所不同。 <br><br><h3>  <font color="#3AC1EF">▍DNS查找阶段</font> </h3><br> 因此，浏览器开始从用户请求的地址下载数据，然后执行DNS查找操作（DNS查找）以找出相应服务器的IP地址。 在地址栏中输入的资源的符号名称对人们来说很方便，但是Internet设备暗示可以使用IP地址在计算机之间交换数据，IP地址是222.324.3.1（对于IPv4）这样的数字集。 <br><br> 首先，找出服务器的IP地址，浏览器会查看本地DNS缓存，以查看是否最近执行了类似的步骤。 例如，在Chrome浏览器中，有一种便捷的方法可以通过在地址栏中输入以下地址来查看DNS缓存： <code>chrome://net-internals/#dns</code> 。 <br><br> 如果在缓存中找不到任何内容，则浏览器将使用POSIX <code>gethostbyname</code>系统调用来查找服务器的IP地址。 <br><br><h3>  <font color="#3AC1EF">▍gethostbyname函数</font> </h3><br>  <code>gethostbyname</code>函数首先检查<code>hosts</code> ，该<code>hosts</code>在macOS或Linux上可以在<code>/etc/hosts</code>上找到，以便确定是否可以通过查找服务器地址来解析本地服务器信息。 <br><br> 如果本地解决请求服务器IP地址的请求失败，则系统会向DNS服务器执行请求。 此类服务器的地址存储在系统设置中。 <br><br> 以下是一些流行的DNS服务器： <br><br><ul><li>  8.8.8.8：Google DNS服务器。 </li><li>  1.1.1.1：CloudFlare DNS服务器。 </li></ul><br> 大多数人使用其提供商提供的DNS服务器。 浏览器使用UDP协议执行DNS查询。 <br><br>  TCP和UDP是计算机网络中使用的两个基本协议。 它们位于相同的概念级别，但是TCP是面向连接的协议，并且对于UDP消息的交换（UDP消息的处理在系统上造成很小的额外负担），不需要建立连接的过程。 我们不会确切讨论如何通过UDP交换数据。 <br><br> 与我们感兴趣的域名相对应的IP地址可能在DNS服务器的缓存中。 如果不是这种情况，他将联系根DNS服务器。 根DNS服务器系统由13个服务器组成，整个Internet的运行都依赖于这13个服务器。 <br><br> 应该注意的是，根DNS服务器不知道世界上所有现有域名和IP地址之间的对应关系。 但是类似的服务器知道诸如.com，.it，.pizza等域的顶级DNS服务器的地址。 <br><br> 收到请求后，根DNS服务器会将其重定向到顶级域的DNS服务器，再到所谓的TLD服务器（从顶级域）。 <br><br> 假设浏览器正在寻找<code>flaviocopes.com</code>服务器的IP地址。 转到根DNS服务器，浏览器将从中接收.com区域的TLD服务器地址。 现在，此地址将存储在缓存中，因此，如果您需要从.com区域中查找另一个URL的IP地址，则无需再次与根DNS服务器联系。 <br><br>  TLD服务器具有名称服务器（名称服务器，NS）的IP地址，借助它们，您可以从我们拥有的URL中找到IP地址。  NS服务器从哪里获得此信息？ 事实是，如果您购买域名，域名注册商会将有关该域名的数据发送到名称服务器。 例如，当更改主机时，将执行类似的过程。 <br><br> 有问题的服务器通常由托管提供商拥有。 通常，为了防止故障，将创建多个此类服务器。 例如，它们可能具有以下地址： <br><br><ul><li>  ns1.dreamhost.com </li><li>  ns2.dreamhost.com </li><li>  ns3.dreamhost.com </li></ul><br> 为了通过URL查找IP地址，最后，他们转向此类服务器。 它们存储有关IP地址的实际数据。 <br><br> 现在，在设法找出在浏览器地址栏中输入的URL的IP地址之后，我们继续进行下一步。 <br><br><h3>  <font color="#3AC1EF">▍建立TCP连接</font> </h3><br> 获悉服务器的IP地址后，客户端可以启动与其的TCP连接。 在建立TCP连接的过程中，客户端和服务器之间会相互传输一些服务数据，然后它们可以交换信息。 这意味着在建立连接之后，客户端将能够向服务器发送请求。 <br><br><h3>  <font color="#3AC1EF">request发送要求</font> </h3><br> 请求是根据使用的协议规则构造的文本片段。 它包括三个部分： <br><br><ul><li> 查询字串 </li><li> 请求标头。 </li><li> 请求正文。 </li></ul><br><h4> 查询字串 </h4><br> 查询字符串是包含以下信息的单个文本字符串： <br><br><ul><li>  HTTP方法。 </li><li> 资源地址 </li><li> 协议版本。 </li></ul><br> 例如，它可能看起来像这样： <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> / HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span></code> </pre> <br><h4> 请求标头 </h4><br> 请求标头由一组<code>: </code> 。 有2个必填的标头字段，其中一个是<code>Host</code> ，第二个是<code>Connection</code> 。 其余字段是可选的。 <br><br> 标题可能如下所示： <br><br><pre> <code class="hljs pgsql">Host: flaviocopes.com <span class="hljs-keyword"><span class="hljs-keyword">Connection</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">close</span></span></code> </pre> <br>  “ <code>Host</code>字段指示浏览器感兴趣的域名。 设置为<code>close</code>的<code>Connection</code>字段表示客户端和服务器之间的连接不需要保持打开状态。 <br><br> 其他常用的请求标头包括以下内容： <br><br><ul><li> <code>Origin</code> </li> <li> <code>Accept</code> </li> <li> <code>Accept-Encoding</code> </li> <li> <code>Cookie</code> </li> <li> <code>Cache-Control</code> </li> <li> <code>Dnt</code> </li> </ul><br> 实际上，还有更多。 <br><br> 请求标头以空字符串结尾。 <br><br><h4> 请求正文 </h4><br> 请求主体是可选的；在GET请求中不使用。 该请求正文可用于POST请求以及其他请求中。 例如，它可能包含JSON格式的数据。 <br><br> 由于现在我们正在讨论GET请求，因此请求正文将为空，我们将不再使用它。 <br><br><h3>  <font color="#3AC1EF">▍答案</font> </h3><br> 服务器接收到客户端发送的请求后，将对其进行处理并向客户端发送响应。 <br><br> 响应以状态码和相应的消息开始。 如果请求成功，则响应的开始将如下所示： <br><br><pre> <code class="hljs">200 OK</code> </pre> <br> 如果出了点问题，可能还有其他代码。 例如，以下内容： <br><br><ul><li> <code>404 Not Found</code> </li> <li> <code>403 Forbidden</code> </li> <li> <code>301 Moved Permanently</code> </li> <li> <code>500 Internal Server Error</code> </li> <li> <code>304 Not Modified</code> </li> <li> <code>401 Unauthorized</code> </li> </ul><br> 此外，响应包含HTTP标头列表和响应的主体（由于请求是由浏览器执行的，因此将为HTML代码）。 <br><br><h4>  HTML解析 </h4><br> 浏览器收到服务器的响应（服务器的主体包含HTML代码）后，便开始解析它，并对形成页面所需的每个资源重复上述过程。 这些资源包括，例如： <br><br><ul><li>  CSS文件。 </li><li> 图片 </li><li> 网页图标（图标）。 </li><li>  JavaScript文件。 </li></ul><br> 浏览器如何精确显示页面并不适用于我们的对话。 这里让我们感兴趣的主要事情是，以上请求和接收数据的过程不仅用于HTML代码，而且还用于使用HTTP协议从服务器传输到浏览器的任何其他对象。 <br><br><h2>  <font color="#3AC1EF">关于使用Node.js创建简单的服务器</font> </h2><br> 现在，在检查了浏览器和服务器之间的交互过程之后，您可以从本系列材料的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一部分中</a>的“ First Node.js应用程序”部分重新了解一下，其中我们描述了一个简单服务器的代码。 <br><br><h2>  <font color="#3AC1EF">使用Node.js发出HTTP请求</font> </h2><br> 要使用Node.js执行HTTP请求，请使用适当的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://nodejs.org/api/">模块</a> 。 下面的示例使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://nodejs.org/api/">https</a>模块。 事实是，在现代条件下，只要有可能，就必须使用HTTPS协议。 <br><br><h3>  <font color="#3AC1EF">▍执行GET请求</font> </h3><br> 这是一个使用Node.js执行GET请求的示例： <br><br><pre> <code class="hljs coffeescript">const https = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'https'</span></span>) const options = { hostname: <span class="hljs-string"><span class="hljs-string">'flaviocopes.com'</span></span>, port: <span class="hljs-number"><span class="hljs-number">443</span></span>, path: <span class="hljs-string"><span class="hljs-string">'/todos'</span></span>, method: <span class="hljs-string"><span class="hljs-string">'GET'</span></span> } const req = https.request(options, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">statusCode: ${res.statusCode}</span></span>`) res.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   process.stdout.write(d) }) }) req.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) }) req.end()</code> </pre> <br><h3>  <font color="#3AC1EF">▍POST请求执行</font> </h3><br> 以下是从Node.js发出POST请求的方法： <br><br><pre> <code class="hljs coffeescript">const https = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'https'</span></span>) const data = JSON.stringify({ todo: <span class="hljs-string"><span class="hljs-string">'Buy the milk'</span></span> }) const options = { hostname: <span class="hljs-string"><span class="hljs-string">'flaviocopes.com'</span></span>, port: <span class="hljs-number"><span class="hljs-number">443</span></span>, path: <span class="hljs-string"><span class="hljs-string">'/todos'</span></span>, method: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>, headers: {   <span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>,   <span class="hljs-string"><span class="hljs-string">'Content-Length'</span></span>: data.length } } const req = https.request(options, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">statusCode: ${res.statusCode}</span></span>`) res.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   process.stdout.write(d) }) }) req.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) }) req.write(data) req.end()</code> </pre> <br><h3>  <font color="#3AC1EF">▍PUT和DELETE查询</font> </h3><br> 这样的请求的执行看起来与POST请求的执行相同。 除了此类操作的语义内容之外，主要区别在于<code>options</code>对象的<code>method</code>属性的值。 <br><br><h3>  <font color="#3AC1EF">using使用Axios库在Node.js中执行HTTP请求</font> </h3><br>  Axios是一个非常流行的JavaScript库，它可以在浏览器（包括从IE8开始的所有现代浏览器和IE）中以及可用于执行HTTP请求的Node.js环境中运行。 <br><br> 该库基于Promise，与标准机制（尤其是API Fetch）相比，具有一些优势。 其优点包括： <br><br><ul><li> 支持较旧的浏览器（您需要使用polyfill才能使用Fetch）。 </li><li> 能够中断请求。 </li><li> 支持设置请求超时。 </li><li> 内置防御CSRF攻击的功能。 </li><li> 支持上传数据，并提供有关此过程进度的信息。 </li><li> 支持JSON数据转换。 </li><li>  Node.js的工作 </li></ul><br><h4> 安装方式 </h4><br> 您可以使用npm安装Axios： <br><br><pre> <code class="hljs sql">npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> axios</code> </pre> <br> 使用纱线可以达到相同的效果： <br><br><pre> <code class="hljs cs">yarn <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> axios</code> </pre> <br> 您可以使用<code>unpkg.com</code>将库连接到页面： <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://unpkg.com/axios/dist/axios.min.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h4>  Axios API </h4><br> 您可以使用<code>axios</code>对象发出HTTP请求： <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">axios</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">url</span></span>: <span class="hljs-string"><span class="hljs-string">'https://dog.ceo/api/breeds/list/all'</span></span>, method: <span class="hljs-string"><span class="hljs-string">'get'</span></span>, data: {   foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> } })</code> </pre> <br> 但是使用特殊方法通常更方便： <br><br><ul><li> <code>axios.get()</code> </li> <li> <code>axios.post()</code> </li> </ul><br> 这类似于jQuery使用<code>$.get()</code>和<code>$.post()</code>而不是<code>$.ajax()</code> <code>$.post()</code> 。 <br><br>  Axios提供了用于执行其他类型的HTTP请求的单独方法，这些方法不像GET和POST那样流行，但仍被使用： <br><br><ul><li> <code>axios.delete()</code> </li> <li> <code>axios.put()</code> </li> <li> <code>axios.patch()</code> </li> <li> <code>axios.options()</code> </li> </ul><br> 该库提供了一种用于执行请求的方法，该请求旨在仅接收HTTP头，而没有响应主体： <br><br><ul><li> <code>axios.head()</code> </li> </ul><br><h4>  GET请求 </h4><br>  Axios使用现代的异步/等待语法很方便使用。 以下为Node.js设计的代码示例使用该库从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Dog API</a>加载狗品种列表。 这里应用了<code>axios.get()</code>方法，并对岩石计数： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> axios = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'axios'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getBreeds = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> axios.get(<span class="hljs-string"><span class="hljs-string">'https://dog.ceo/api/breeds/list/all'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> countBreeds = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> breeds = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getBreeds() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (breeds.data.message) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Got </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">Object</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.entries(breeds.data.message).length}</span></span></span><span class="hljs-string"> breeds`</span></span>) } } countBreeds()</code> </pre> <br> 可以不使用async / await而是应用promise来重写相同的内容： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> axios = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'axios'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getBreeds = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> axios.get(<span class="hljs-string"><span class="hljs-string">'https://dog.ceo/api/breeds/list/all'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> countBreeds = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> breeds = getBreeds()   .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.data.message) {       <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(         <span class="hljs-string"><span class="hljs-string">`Got </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">Object</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.entries(response.data.message).length}</span></span></span><span class="hljs-string"> breeds`</span></span>       )     }   })   .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error)   }) } countBreeds()</code> </pre> <br><h4> 在GET请求中使用参数 </h4><br>  GET请求的URL中可能包含如下所示的参数： <br><br><pre> <code class="hljs objectivec">https:<span class="hljs-comment"><span class="hljs-comment">//site.com/?foo=bar</span></span></code> </pre> <br> 使用Axios时，可以这样进行查询： <br><br><pre> <code class="hljs swift">axios.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>('https:<span class="hljs-comment"><span class="hljs-comment">//site.com/?foo=bar')</span></span></code> </pre> <br> 通过在具有参数的对象中设置<code>params</code>属性，可以达到相同的效果： <br><br><pre> <code class="hljs cs">axios.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'https://site.com/'</span></span>, { <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>: {   foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> } })</code> </pre> <br><h4>  POST请求 </h4><br> 发出POST请求与发出GET请求非常相似，但是在这里，使用<code>axios.get()</code>方法代替<code>axios.post()</code>方法： <br><br><pre> <code class="hljs scala">axios.post(<span class="hljs-symbol"><span class="hljs-symbol">'https</span></span>:<span class="hljs-comment"><span class="hljs-comment">//site.com/')</span></span></code> </pre> <br> 作为第二个参数， <code>post</code>方法接受带有请求参数的对象： <br><br><pre> <code class="hljs cs">axios.post(<span class="hljs-string"><span class="hljs-string">'https://site.com/'</span></span>, { foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> })</code> </pre> <br><h2>  <font color="#3AC1EF">在Node.js中使用WebSocket协议</font> </h2><br>  WebSocket是HTTP的替代方法，可用于组织Web应用程序中的数据交换。 该协议允许您在客户端和服务器之间创建长期的双向通信通道。 建立连接后，通信通道保持打开状态，这使应用程序处于非常快速的连接状态，其特点是等待时间短且系统上的附加负载很小。 <br><br> 所有现代浏览器均支持WebSocket协议。 <br><br><h3>  <font color="#3AC1EF">▍HTTP差异</font> </h3><br>  HTTP和WebSocket是非常不同的协议，它们使用不同的方法交换数据。  HTTP基于“请求-响应”模型：请求后，服务器会将一些数据发送到客户端。 对于WebSocket，一切安排都不同。 即： <br><br><ul><li> 服务器可以主动向客户端发送消息，而无需等待客户端的请求。 </li><li> 客户端和服务器可以同时交换数据。 </li><li> 在发送消息时，将使用极少量的服务数据。 这尤其导致数据传输的低等待时间。 </li></ul><br>  WebSocket协议非常适合通过长时间开放的通道进行实时通信。 反过来，HTTP非常适合组织客户端发起的偶尔的通信会话。 同时，应注意的是，从编程的角度来看，使用HTTP协议实现数据交换要比使用WebSocket协议容易得多。 <br><br><h3>  <font color="#3AC1EF">Socket WebSocket协议的受保护版本</font> </h3><br>  WebSocket协议有一个不安全的版本（ <code>ws://</code> URI方案），就安全性而言，它类似于<code>http://</code>协议。 应该避免使用<code>ws://</code> ，而是使用协议的安全版本<code>wss://</code> 。 <br><br><h3>  <font color="#3AC1EF">▍创建WebSocket连接</font> </h3><br> 要创建WebSocket连接，您需要使用适当的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">构造函数</a> ： <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">'wss://myserver.com/something'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> connection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebSocket(url)</code> </pre> <br> 建立成功的连接后，将引发<code>open</code>事件。 您可以通过为<code>connection</code>对象的<code>onopen</code>属性分配回调函数来组织此事件： <br><br><pre> <code class="hljs javascript">connection.onopen = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br> 要处理错误，请使用<code>onerror</code>事件处理程序： <br><br><pre> <code class="hljs javascript">connection.onerror = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`WebSocket error: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${error}</span></span></span><span class="hljs-string">`</span></span>) }</code> </pre> <br><h3>  <font color="#3AC1EF">data将数据发送到服务器</font> </h3><br> 打开与服务器的WebSocket连接后，可以向其发送数据。 例如，可以在onopen <code>onopen</code>完成此操作： <br><br><pre> <code class="hljs coffeescript">connection.onopen = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { connection.send(<span class="hljs-string"><span class="hljs-string">'hey'</span></span>) }</code> </pre> <br><h3>  <font color="#3AC1EF">from从服务器获取数据</font> </h3><br> 要从服务器接收使用WebSocket协议发送的数据，可以分配onmessage <code>onmessage</code> ，当接收到<code>message</code>事件时将调用该<code>onmessage</code> ： <br><br><pre> <code class="hljs javascript">connection.onmessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(e.data) }</code> </pre> <br><h3>  <font color="#3AC1EF">Node在Node.js环境中实现WebSocket服务器</font> </h3><br> 为了在Node.js环境中实现WebSocket服务器，可以使用流行的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ws</a>库。 我们将使用它进行服务器开发，但它适用于创建客户端以及组织两个服务器之间的交互。 <br><br> 通过首先初始化项目来安装此库： <br><br><pre> <code class="hljs swift">yarn <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> yarn add ws</code> </pre> <br> 我们需要编写的WebSocket服务器代码非常紧凑： <br><br><pre> <code class="hljs javascript">constWebSocket = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ws'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wss = newWebSocket.Server({ <span class="hljs-attr"><span class="hljs-attr">port</span></span>: <span class="hljs-number"><span class="hljs-number">8080</span></span> }) wss.on(<span class="hljs-string"><span class="hljs-string">'connection'</span></span>, ws =&gt; { ws.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, message =&gt; {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Received message =&gt; </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${message}</span></span></span><span class="hljs-string">`</span></span>) }) ws.send(<span class="hljs-string"><span class="hljs-string">'ho!'</span></span>) })</code> </pre> <br> 在这里，我们创建一个新服务器，该服务器在标准端口8080上侦听WebSocket协议并描述一个回调，该回调在建立连接后将向客户端发送一个<code>ho!</code>消息<code>ho!</code> 并将从客户端收到的消息打印到控制台。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这是</a> WebSocket服务器<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>工作示例， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这</a>是可以与其交互的客户端。 <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 今天，我们讨论了Node.js平台支持的网络机制，并与浏览器中使用的类似机制进行了比较。 我们的下一个主题将是处理文件。 <br><br>  <b>亲爱的读者们！</b> 您是否在Web应用程序中使用WebSocket协议，该Web应用程序的服务器端是使用Node.js创建的？ <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN424557/">https://habr.com/ru/post/zh-CN424557/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN424541/index.html">UGJ 2018惨败故事：如何制作没人喜欢的游戏（不要做！）</a></li>
<li><a href="../zh-CN424543/index.html">Java 11 / JDK 11：常规可用性</a></li>
<li><a href="../zh-CN424551/index.html">暖管：关于磁性音频技术的五种法莱卡</a></li>
<li><a href="../zh-CN424553/index.html">Node.js指南，第6部分：事件循环，调用堆栈，计时器</a></li>
<li><a href="../zh-CN424555/index.html">Node.js手册，第7部分：异步编程</a></li>
<li><a href="../zh-CN424559/index.html">大数据抵抗1或难以捉摸的乔。 互联网匿名，反检测，针对您和您的反跟踪</a></li>
<li><a href="../zh-CN424563/index.html">直线将对话的详细信息发送给陌生人</a></li>
<li><a href="../zh-CN424565/index.html">概述：房地产场所的3D扫描</a></li>
<li><a href="../zh-CN424567/index.html">在公司的本地网络中阻止在线广告的经验</a></li>
<li><a href="../zh-CN424569/index.html">雇用程序员。 程序员技巧</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>