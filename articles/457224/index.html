<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔼 🏂🏽 🥄 Un enfoque moderno de la competencia en Android: Corotins en Kotlin 👎 ♻️ 🤲🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! 

 Le recordamos que ya tenemos un pedido anticipado para el libro tan esperado en el idioma Kotlin de la famosa serie Big Nerd Ranch Guide...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un enfoque moderno de la competencia en Android: Corotins en Kotlin</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/457224/"> Hola Habr! <br><br>  Le recordamos que ya tenemos un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pedido anticipado para el libro tan esperado</a> en el idioma Kotlin de la famosa serie Big Nerd Ranch Guides.  Hoy decidimos llamar su atención sobre la traducción de un artículo que habla sobre las corutinas de Kotlin y sobre el trabajo correcto con las transmisiones en Android.  El tema se está discutiendo muy activamente, por lo tanto, para completar, también recomendamos que consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este artículo</a> de Habr y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta publicación detallada</a> del blog de Axmor Software. <br><a name="habracut"></a><br>  El marco competitivo moderno en Java / Android inflige un infierno en las devoluciones de llamada y conduce a estados de bloqueo, ya que Android no tiene una forma bastante simple de garantizar la seguridad de los hilos. <br><br>  Las rutinas de Kotlin son un conjunto de herramientas muy efectivo y completo que hace que la gestión de la competencia sea mucho más fácil y productiva. <br><br>  <b>Pausa y bloqueo: ¿cuál es la diferencia?</b> <br><br>  Las rutinas no reemplazan los hilos, sino que proporcionan un marco para administrarlas.  La filosofía de corutin es definir un contexto que le permita <b>esperar</b> a que se completen las operaciones en segundo plano sin bloquear el hilo principal. <br><br>  El objetivo de Corutin en este caso es prescindir de las devoluciones de llamada y simplificar la competencia. <br><br>  <b>Ejemplo más simple</b> <br><br>  Para empezar, tomemos el ejemplo más simple: ejecutar coroutine en el contexto de <code>Main</code> (hilo principal).  En él, extraeremos la imagen de la secuencia de <code>IO</code> y la enviaremos para su procesamiento a <code>Main</code> . <br><br><pre> <code class="kotlin hljs">launch(Dispatchers.Main) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> image = withContext(Dispatchers.IO) { getImage() } <span class="hljs-comment"><span class="hljs-comment">//    IO imageView.setImageBitmap(image) //     }</span></span></code> </pre> <br>  El código es simple como una función de subproceso único.  Además, mientras <code>getImage</code> se ejecuta en el grupo asignado de subprocesos de <code>IO</code> , el subproceso principal es gratuito y puede asumir cualquier otra tarea.  La función withContext detiene la rutina actual mientras se ejecuta su acción ( <code>getImage()</code> ).  Tan pronto como <code>getImage()</code> regrese y el <code>looper</code> del hilo principal esté disponible, la rutina reanudará el trabajo en el hilo principal y llamará a <code>imageView.setImageBitmap(image)</code> . <br><br>  El segundo ejemplo: ahora necesitamos completar 2 tareas en segundo plano para poder usarlas.  Utilizaremos el dúo async / await para que estas dos tareas se realicen en paralelo, y usaremos su resultado en el hilo principal tan pronto como ambas tareas estén listas: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = launch(Dispatchers.Main) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferred1 = async(Dispatchers.Default) { getFirstValue() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferred2 = async(Dispatchers.IO) { getSecondValue() } useValues(deferred1.await(), deferred2.await()) } job.join() <span class="hljs-comment"><span class="hljs-comment">//    ,     </span></span></code> </pre> <br>  <code>async</code> es similar al <code>launch</code> , pero devuelve <code>deferred</code> (una entidad de Kotlin equivalente a <code>Future</code> ), por lo que su resultado se puede obtener usando <code>await()</code> .  Cuando se llama sin parámetros, funciona en el contexto predeterminado para el alcance actual. <br><br>  Nuevamente, el hilo principal permanece libre mientras esperamos nuestros 2 valores. <br>  Como puede ver, la función de <code>launch</code> devuelve <code>Job</code> , que se puede usar para esperar hasta que se complete la operación; esto se hace usando la función <code>join()</code> .  Funciona como en cualquier otro idioma, con la advertencia de que simplemente <b>suspende la rutina y no bloquea el flujo</b> . <br><br>  <b>Despacho</b> <br><br>  El envío es un concepto clave cuando se trabaja con corutinas.  Esta acción le permite "saltar" de un hilo a otro. <br><br>  Considere cómo se ve el equivalente para despachar en <code>Main</code> en Java, es decir, <br><br><pre> <code class="kotlin hljs">runOnUiThread: <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> void runOnUiThread(Runnable action) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.currentThread() != mUiThread) { mHandler.post(action); <span class="hljs-comment"><span class="hljs-comment">//  } else { action.run(); //   } }</span></span></code> </pre> <br>  <code>Main</code> Context Implementation para Android es un <code>Handler</code> basado en <code>Handler</code> .  Entonces, esta es una implementación muy adecuada: <br><br><pre> <code class="kotlin hljs">launch(Dispatchers.Main) { ... } vs launch(Dispatchers.Main, CoroutineStart.UNDISPATCHED) { ... } <span class="hljs-comment"><span class="hljs-comment">//   kotlinx 0.26: launch(Dispatchers.Main.immediate) { ... }</span></span></code> </pre> <br>  <code>launch(Dispatchers.Main)</code> envía <code>Runnable</code> a <code>Handler</code> , por lo que su código no se ejecuta de inmediato. <br><br>  <code>launch(Dispatchers.Main, CoroutineStart.UNDISPATCHED)</code> ejecutará inmediatamente su expresión lambda en el hilo actual. <br><br>  <code>Dispatchers.Main</code> <b>asegura que cuando la rutina reanude el trabajo, se dirigirá al hilo principal</b> ;  Además, Handler se usa aquí como una implementación nativa de Android para enviar al bucle de eventos de la aplicación. <br><br>  La implementación exacta se ve así: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> Main: HandlerDispatcher = HandlerContext(mainHandler, <span class="hljs-string"><span class="hljs-string">"Main"</span></span>)</code> </pre> <br>  Aquí hay un buen artículo para ayudarlo a comprender las complejidades del envío en Android: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comprender Android Core: Looper, Handler y HandlerThread</a> . <br><br>  <b>Contexto de rutina</b> <br><br>  El contexto de rutina (también conocido como el administrador de rutina) determina en qué subproceso se ejecutará su código, qué hacer si se produce una excepción, y se refiere al contexto principal para propagar la cancelación. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = Job() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> exceptionHandler = CoroutineExceptionHandler { coroutineContext, throwable -&gt; whatever(throwable) } launch(Disaptchers.Default+exceptionHandler+job) { ... }</code> </pre> <br>  <code>job.cancel()</code> cancelará todas las corutinas cuyo padre es <code>job</code> .  Una excepción Handler recibirá todas las excepciones lanzadas en estas rutinas. <br><br>  <b>Alcance</b> <br><br>  La interfaz <code>coroutineScope</code> simplifica el manejo de errores: <br>  Si cualquiera de sus corutinas hijas falla, entonces todo el alcance y todas las corutinas hijas también serán canceladas. <br><br>  En el ejemplo <code>async</code> , si no fue posible extraer el valor, mientras otra tarea continuó funcionando, tenemos un estado dañado y debemos hacer algo al respecto. <br><br>  Cuando se trabaja con <code>coroutineScope</code> , la función <code>useValues</code> solo se llamará si la extracción de ambos valores es exitosa.  Además, si <code>deferred2</code> falla, <code>deferred1</code> se cancelará. <br><br><pre> <code class="kotlin hljs">coroutineScope { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferred1 = async(Dispatchers.Default) { getFirstValue() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferred2 = async(Dispatchers.IO) { getSecondValue() } useValues(deferred1.await(), deferred2.await()) }</code> </pre> <br>  También puede "poner en el alcance" una clase completa para establecer un <code>CoroutineContext</code> predeterminado y usarlo. <br><br>  Una clase de ejemplo que implementa la interfaz <code>CoroutineScope</code> : <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScopedViewModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ViewModel</span></span></span></span>(), CoroutineScope { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = Job() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> coroutineContext = Dispatchers.Main+job <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCleared</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCleared() job.cancel() } }</code> </pre> <br>  Ejecución de Corutin en <code>CoroutineScope</code> : <br><br>  El administrador de <code>launch</code> o <code>async</code> predeterminado ahora se convierte en el administrador de alcance actual. <br><br><pre> <code class="kotlin hljs">launch { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> foo = withContext(Dispatchers.IO) { … } <span class="hljs-comment"><span class="hljs-comment">// -    CoroutineContext   … } launch(Dispatchers.Default) { // -        … }</span></span></code> </pre> <br>  Lanzamiento autónomo de coroutine (fuera de cualquier CoroutineScope): <br><br><pre> <code class="kotlin hljs">GlobalScope.launch(Dispatchers.Main) { <span class="hljs-comment"><span class="hljs-comment">// -    . … }</span></span></code> </pre> <br>  Incluso puede definir el alcance de una aplicación configurando el despachador <code>Main</code> predeterminado: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> AppScope : CoroutineScope <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> GlobalScope { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> coroutineContext = Dispatchers.Main.immediate }</code> </pre><br>  <b>Observaciones</b> <br><br><ul><li>  Las rutinas limitan la interoperabilidad con Java </li><li>  Limite la mutabilidad para evitar bloqueos </li><li>  Las corutinas están diseñadas para esperar, no para organizar hilos </li><li>  Evite las E / S en <code>Dispatchers.Default</code> (y <code>Main</code> ...): para eso es Dispatchers.IO </li><li>  Las secuencias consumen muchos recursos, por lo que se utilizan contextos de subproceso único </li><li>  <code>Dispatchers.Default</code> basa en <code>ForkJoinPool</code> , introducido en Android 5+ </li><li>  Las rutinas se pueden usar a través de canales </li></ul><br>  <b>Deshacerse de bloqueos y devoluciones de llamada utilizando canales</b> <br><br>  Definición del canal de la documentación de JetBrains: <br><br><blockquote>  Channel <code>Channel</code> conceptualmente muy similar a <code>BlockingQueue</code> .  La diferencia clave es que no bloquea la operación de venta, proporciona un <code>send</code> suspendido (u <code>offer</code> sin bloqueo) y, en lugar de bloquear la operación de toma, proporciona una <code>receive</code> suspendida. </blockquote><br><br>  <b>Actores</b> <br><br>  Considere una herramienta simple para trabajar con canales: <code>Actor</code> . <br><br>  <code>Actor</code> , de nuevo, es muy similar a <code>Handler</code> : definimos el contexto de la rutina (es decir, el hilo en el que vamos a realizar acciones) y trabajamos con ella en un orden secuencial. <br><br>  La diferencia, por supuesto, es que las corutinas se usan aquí;  <b>Puede especificar la potencia y el código ejecutado: pausa</b> . <br><br>  En principio, el <code>actor</code> redirigirá cualquier comando al canal de rutina.  <b>Garantiza la ejecución de un comando y restringe las operaciones en su contexto</b> .  ¡Este enfoque ayuda perfectamente a deshacerse de <code>synchronize</code> llamadas <code>synchronize</code> y mantener todos los hilos libres! <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> updateActor <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { actor&lt;Update&gt;(capacity = Channel.UNLIMITED) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (update <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> channel) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (update) { Refresh -&gt; updateList() <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Filter -&gt; filter.filter(update.query) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MediaUpdate -&gt; updateItems(update.mediaList <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;T&gt;) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MediaAddition -&gt; addMedia(update.media <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MediaListAddition -&gt; addMedia(update.mediaList <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;T&gt;) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MediaRemoval -&gt; removeMedia(update.media <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T) } } } <span class="hljs-comment"><span class="hljs-comment">//  fun filter(query: String?) = updateActor.offer(Filter(query)) //  suspend fun filter(query: String?) = updateActor.send(Filter(query))</span></span></code> </pre> <br>  En este ejemplo, utilizamos las clases de Kotlin selladas, eligiendo qué acción realizar. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Update</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Refresh</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Update</span></span></span></span>() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Filter</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> query: String?) : Update() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MediaAddition</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> media: Media) : Update()</code> </pre> <br>  Además, todas estas acciones se pondrán en cola, nunca se ejecutarán en paralelo.  Esta es una manera conveniente de lograr <b>límites de variabilidad</b> . <br><br>  <b>Android Life Cycle + Coroutines</b> <br><br>  Los actores también pueden ser muy útiles para controlar la interfaz de usuario de Android, simplificar la cancelación de tareas y evitar sobrecargar el hilo principal. <br>  Implementemos esto y llamemos a <code>job.cancel()</code> cuando se destruya la actividad. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span></span>(), CoroutineScope { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = SupervisorJob() <span class="hljs-comment"><span class="hljs-comment">//  Job    override val coroutineContext = Dispatchers.Main.immediate+job override fun onDestroy() { super.onDestroy() job.cancel() //      } }</span></span></code> </pre> <br>  La clase <code>SupervisorJob</code> es similar al <code>Job</code> normal con la única excepción de que la cancelación solo se extiende en la dirección descendente. <br><br>  Por lo tanto, no cancelamos todas las rutinas en una <code>Activity</code> cuando una de ellas falla. <br><br>  Las cosas están un poco mejor con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una función de extensión</a> que le permite acceder a este <code>CoroutineContext</code> desde cualquier <code>View</code> en <code>CoroutineScope</code> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> View.coroutineContext: CoroutineContext? <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = (context <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? CoroutineScope)?.coroutineContext</code> </pre> <br>  Ahora podemos combinar todo esto, la función <code>setOnClick</code> crea un actor combinado para controlar sus acciones <code>onClick</code> .  En el caso de múltiples toques, las acciones intermedias serán ignoradas, eliminando así los errores ANR (la aplicación no responde), y estas acciones se realizarán en el ámbito de la <code>Activity</code> .  Por lo tanto, cuando se destruye la actividad, todo esto se cancelará. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setOnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">suspend</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//         val scope = (context as? CoroutineScope)?: AppScope val eventActor = scope.actor&lt;Unit&gt;(capacity = Channel.CONFLATED) { for (event in channel) action() } //       setOnClickListener { eventActor.offer(Unit) } }</span></span></code> </pre> <br>  En este ejemplo, configuramos el <code>Channel</code> en <code>Conflated</code> para que ignore algunos eventos si hay demasiados.  Puede reemplazarlo con <code>Channel.UNLIMITED</code> si prefiere poner en cola eventos sin perder ninguno de ellos, pero aún así quiere proteger la aplicación de los errores ANR. <br><br>  También puede combinar las rutinas y los marcos de Lifecycle para automatizar la cancelación de tareas relacionadas con la interfaz de usuario: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> LifecycleOwner.untilDestroy: Job <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = Job() lifecycle.addObserver(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>: LifecycleObserver { <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { job.cancel() } }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> job } <span class="hljs-comment"><span class="hljs-comment">//  GlobalScope.launch(Dispatchers.Main, parent = untilDestroy) { /*    ! */ }</span></span></code> </pre> <br>  <b>Simplifique la situación con devoluciones de llamada (parte 1)</b> <br><br>  Aquí se explica cómo transformar el uso de API basadas en devolución de llamada con <code>Channel</code> . <br><br>  La API funciona así: <br><br><ol><li>  <code>requestBrowsing(url, listener)</code> analiza la carpeta ubicada en <code>url</code> . </li><li>  El <code>listener</code> recibe <code>onMediaAdded(media: Media)</code> para cualquier archivo multimedia que se encuentre en esta carpeta. </li><li>  Se llama a <code>listener.onBrowseEnd()</code> al analizar la carpeta </li></ol><br>  Aquí está la antigua función de <code>refresh</code> en el proveedor de contenido para el navegador VLC: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshList = mutableListOf&lt;Media&gt;() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = requestBrowsing(url, refreshListener) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshListener = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : EventListener{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMediaAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(media: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Media</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { refreshList.add(media)) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBrowseEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> list = refreshList.toMutableList() refreshList.clear() launch { dataset.value = list parseSubDirectories() } } }</code> </pre> <br>  <b>¿Cómo mejorarlo?</b> <br><br>  Crea un canal que se ejecutará en <code>refresh</code> .  Ahora las devoluciones de llamada del navegador solo dirigirán los medios a este canal y luego lo cerrarán. <br><br>  Ahora la función de <code>refresh</code> ha vuelto más clara.  Ella crea un canal, llama al navegador VLC, luego forma una lista de archivos multimedia y lo procesa. <br><br>  En lugar de <code>select</code> o <code>consumeEach</code> puede usar <code>for</code> esperar a los medios, y este ciclo se interrumpirá tan pronto como se cierre el <code>browserChannel</code> del <code>browserChannel</code> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> browserChannel : Channel&lt;Media&gt; <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMediaAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(media: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Media</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { browserChannel.offer(media) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBrowseEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { browserChannel.close() } <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { browserChannel = Channel(Channel.UNLIMITED) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshList = mutableListOf&lt;Media&gt;() requestBrowsing(url) <span class="hljs-comment"><span class="hljs-comment">//        for (media in browserChannel) refreshList.add(media) //   dataset.value = refreshList parseSubDirectories() }</span></span></code> </pre> <br>  <b>Simplificando la situación con devoluciones de llamada (parte 2): actualización</b> <br><br>  El segundo enfoque: no usamos las corutinas de Kotlinx en absoluto, pero usamos un marco central de la rutina. <br><br>  ¡Mira cómo funcionan realmente las corutinas! <br><br>  La función <code>retrofitSuspendCall</code> envuelve una solicitud de <code>Retrofit Call</code> para convertirla en una función de <code>suspend</code> . <br><br>  Usando <code>suspendCoroutine</code> llamamos al método <code>Call.enqueue</code> y hacemos una pausa en la rutina.  La devolución de llamada proporcionada de esta manera llamará a <code>continuation.resume(response)</code> para reanudar la rutina con una respuesta del servidor tan pronto como se reciba. <br><br>  Luego, solo necesitamos combinar nuestras funciones de Retrofit en <code>retrofitSuspendCall</code> para devolver los resultados de la consulta usándolos. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrofitSuspendCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request: ()</span></span></span></span> -&gt; Call &lt;T&gt; ) : Response &lt;T&gt; = suspendCoroutine { continuation -&gt; request.invoke().enqueue(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : Callback&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(call: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Call</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, response: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Response</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { continuation.resume(response) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onFailure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(call: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Call</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, t: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { continuation.resumeWithException(t) } }) } <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">browse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> = retrofitSuspendCall { ApiClient.browse(path) } <span class="hljs-comment"><span class="hljs-comment">//  (   Main) livedata.value = Repo.browse(path)</span></span></code> </pre> <br>  Por lo tanto, la llamada que bloquea la red se realiza en el subproceso dedicado de actualización, la rutina está aquí, esperando una respuesta del servidor, ¡y no hay ningún lugar para usarla en la aplicación! <br><br>  Esta implementación está inspirada en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">biblioteca gildor / kotlin-coroutines-retrofit</a> . <br><br>  También hay un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JakeWharton / retrofit2-kotlin-coroutines-adapter</a> con otra implementación que da un resultado similar. <br><br>  <b>Epílogo</b> <br><br>  <code>Channel</code> se puede usar de muchas otras formas;  Echa un vistazo a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BroadcastChannel para ver</a> implementaciones más potentes que te pueden resultar útiles. <br><br>  También puede crear canales utilizando la función <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Producir</a> . <br><br>  Finalmente, usando canales es conveniente organizar la comunicación entre los componentes de la interfaz de usuario: el adaptador puede transmitir eventos de clic a su fragmento / actividad a través del <code>Channel</code> o, por ejemplo, a través del <code>Actor</code> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/457224/">https://habr.com/ru/post/457224/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457204/index.html">Windows PowerShell y rutas largas</a></li>
<li><a href="../457206/index.html">SQL Index Manager: una larga historia sobre SQL Server, excavación de tumbas y mantenimiento de índices</a></li>
<li><a href="../457208/index.html">Generar dinámicamente robots.txt para sitios ASP.NET Core basados ​​en el entorno</a></li>
<li><a href="../457210/index.html">Almacene recursos estáticos en su alojamiento</a></li>
<li><a href="../457212/index.html">¿Por qué nunca es demasiado tarde para comenzar a aprender Java (u otros lenguajes Java)</a></li>
<li><a href="../457232/index.html">Robot abeja "Bumble" - el primer vuelo de prueba dentro de la EEI</a></li>
<li><a href="../457234/index.html">Sesgo cognitivo del producto</a></li>
<li><a href="../457236/index.html">Cómo una empresa de TI tuvo problemas para vender música</a></li>
<li><a href="../457240/index.html">Noticias de la semana: red neuronal e imágenes fotografiadas, crecimiento de las acciones de Yandex, Huawei requiere $ 1 mil millones para patentes</a></li>
<li><a href="../457246/index.html">Cómo parpadear 4 LED en CortexM usando C ++ 17, tupla y un poco de fantasía</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>