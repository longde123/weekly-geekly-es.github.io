<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóø üë®üèΩ‚Äçüíº üò± Configurando o Killer sem mem√≥ria no Linux para PostgreSQL üñêüèº üë®üèΩ‚Äç‚öñÔ∏è üëàüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quando o servidor de banco de dados √© encerrado inesperadamente no Linux, voc√™ precisa encontrar o motivo. Pode haver v√°rias raz√µes. Por exemplo, SIGS...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Configurando o Killer sem mem√≥ria no Linux para PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/464245/"><p><img src="https://habrastorage.org/webt/xn/ip/86/xnip86u-h8mejjpjkpvpaun7emc.png"></p><br><p>  Quando o servidor de banco de dados √© encerrado inesperadamente no Linux, voc√™ precisa encontrar o motivo.  Pode haver v√°rias raz√µes.  Por exemplo, <strong>SIGSEGV</strong> - falha devido a um erro no servidor de back-end.  Mas isso √© uma raridade.  Na maioria das vezes, o espa√ßo em disco ou a mem√≥ria simplesmente acaba.  Se o espa√ßo em disco acabar, uma sa√≠da √© liberar espa√ßo e reiniciar o banco de dados. </p><br><h3 id="out-of-memory-killer">  Assassino de falta de mem√≥ria </h3><br><p>  Quando o servidor ou processo fica sem mem√≥ria, o Linux oferece 2 solu√ß√µes: travar todo o sistema ou encerrar o processo (aplicativo) que consome a mem√≥ria.  √â melhor, √© claro, concluir o processo e salvar o sistema operacional da finaliza√ß√£o anormal.  Em poucas palavras, o Killer Sem Mem√≥ria √© o processo que encerra um aplicativo para salvar o kernel de uma falha.  Ele sacrifica o aplicativo para manter o sistema operacional em execu√ß√£o.  Vamos primeiro discutir como o OOM funciona e como control√°-lo, e depois ver como o OOM Killer decide qual aplicativo finalizar. </p><a name="habracut"></a><br><p>  Uma das principais tarefas do Linux √© alocar mem√≥ria aos processos quando solicitados.  Geralmente, um processo ou aplicativo solicita mem√≥ria ao sistema operacional, mas eles pr√≥prios n√£o a utilizam totalmente.  Se o sistema operacional emitir mem√≥ria para todos que a solicitarem, mas n√£o planeja us√°-la, muito em breve a mem√≥ria terminar√° e o sistema falhar√°.  Para evitar isso, o sistema operacional reserva mem√≥ria para o processo, mas na verdade n√£o o emite.  A mem√≥ria √© alocada somente quando o processo realmente vai us√°-lo.  Acontece que o sistema operacional n√£o possui mem√≥ria livre, mas atribui mem√≥ria ao processo e, quando o processo precisa, o sistema operacional o aloca, se puder.  A desvantagem √© que √†s vezes o sistema operacional reserva mem√≥ria, mas no momento certo n√£o h√° mem√≥ria livre e o sistema trava.  OOM desempenha um papel importante nesse cen√°rio e finaliza processos para evitar que o kernel entre em p√¢nico.  Quando o processo do PostgreSQL √© for√ßado a terminar, uma mensagem aparece no log: </p><br><pre><code class="plaintext hljs">Out of Memory: Killed process 12345 (postgres).</code> </pre> <br><p>  Se houver pouca mem√≥ria no sistema e for imposs√≠vel <code>out_of_memory</code> la, a fun√ß√£o <code>out_of_memory</code> ser√° <code>out_of_memory</code> .  Nesse est√°gio, ela tem apenas uma coisa: concluir um ou mais processos.  OOM-killer deve encerrar o processo imediatamente ou posso esperar?  Obviamente, quando out_of_memory √© chamado, isso ocorre devido √† espera de uma opera√ß√£o de E / S ou √† troca de p√°gina no disco.  Portanto, o OOM-killer deve primeiro executar verifica√ß√µes e, com base nelas, decidir que o processo deve ser conclu√≠do.  Se todas as verifica√ß√µes abaixo derem um resultado positivo, o OOM encerrar√° o processo. </p><br><h3 id="vybor-processa">  Sele√ß√£o de processo </h3><br><p>  Quando a mem√≥ria acaba, a fun√ß√£o <code>out_of_memory()</code> √© <code>out_of_memory()</code> .  Possui uma fun√ß√£o <code>select_bad_process()</code> , que recebe uma estimativa da fun√ß√£o <code>badness()</code> .  A distribui√ß√£o do processo mais "ruim".  A fun√ß√£o <code>badness()</code> seleciona um processo de acordo com certas regras. </p><br><ol><li>  O kernel precisa de alguma mem√≥ria m√≠nima para si. </li><li>  Voc√™ precisa liberar muita mem√≥ria. </li><li>  N√£o h√° necessidade de finalizar processos que usam pouca mem√≥ria. </li><li>  Voc√™ precisa concluir um m√≠nimo de processos. </li><li>  Algoritmos complexos que aumentam as chances de conclus√£o dos processos que o pr√≥prio usu√°rio deseja concluir. </li></ol><br><p>  Depois de concluir todas essas verifica√ß√µes, o OOM examina a nota ( <code>oom_score</code> ).  OOM atribui <code>oom_score</code> cada processo e multiplica esse valor pela quantidade de mem√≥ria.  Processos com valores mais altos t√™m maior probabilidade de se tornarem v√≠timas do OOM Killer.  Os processos associados a um usu√°rio privilegiado t√™m uma classifica√ß√£o mais baixa e s√£o menos propensos a for√ßar o encerramento. </p><br><pre> <code class="plaintext hljs">postgres=# SELECT pg_backend_pid(); pg_backend_pid ----------------    3813 (1 row)</code> </pre> <br><p>  O identificador do processo do Postgres √© 3813, portanto, em outro shell, voc√™ pode obter uma estimativa usando este <code>oom_score</code> kernel <code>oom_score</code> : </p><br><pre> <code class="plaintext hljs">vagrant@vagrant:~$ sudo cat /proc/3813/oom_score 2</code> </pre> <br><p>  Se voc√™ n√£o deseja que o OOM-Killer conclua o processo, existe outro par√¢metro do kernel: <code>oom_score_adj</code> .  Adicione um grande valor negativo para reduzir as chances de concluir o processo que voc√™ ama. </p><br><pre> <code class="plaintext hljs">sudo echo -100 &gt; /proc/3813/oom_score_adj</code> </pre> <br><p>  Para definir o valor <code>oom_score_adj</code> , configure OOMScoreAdjust no bloco de servi√ßo: </p><br><pre> <code class="plaintext hljs">[Service] OOMScoreAdjust=-1000</code> </pre> <br><p>  Ou use <code>oomprotect</code> no <code>rcctl</code> . </p><br><pre> <code class="plaintext hljs">rcctl set &lt;i&gt;servicename&lt;/i&gt; oomprotect -1000</code> </pre> <br><h3 id="prinuditelnoe-zavershenie-processa">  Finaliza√ß√£o for√ßada do processo </h3><br><p>  Quando um ou mais processos j√° est√£o selecionados, o OOM-Killer chama a fun√ß√£o <code>oom_kill_task()</code> .  Esta fun√ß√£o envia um sinal de finaliza√ß√£o para o processo.  Se n√£o houver mem√≥ria suficiente, <code>oom_kill()</code> chama esta fun√ß√£o para enviar um sinal SIGKILL ao processo.  Uma mensagem √© gravada no log do kernel. </p><br><pre> <code class="plaintext hljs">Out of Memory: Killed process [pid] [name].</code> </pre> <br><h3 id="kak-kontrolirovat-oom-killer">  Como controlar o OOM-Killer </h3><br><p>  No Linux, voc√™ pode ativar ou desativar o OOM-Killer (embora este √∫ltimo n√£o seja recomendado).  Para ativar e desativar, use a op√ß√£o <code>vm.oom-kill</code> .  Para habilitar o OOM-Killer em tempo de execu√ß√£o, execute o comando <code>sysctl</code> . </p><br><pre> <code class="plaintext hljs">sudo -s sysctl -w vm.oom-kill = 1</code> </pre> <br><p>  Para desativar o OOM-Killer, especifique o valor 0 no mesmo comando: </p><br><pre> <code class="plaintext hljs">sudo -s sysctl -w vm.oom-kill = 0</code> </pre> <br><p>  O resultado desse comando n√£o ser√° salvo para sempre, mas apenas at√© a primeira reinicializa√ß√£o.  Se voc√™ precisar de mais persist√™ncia, adicione esta linha ao arquivo <code>/etc/sysctl.conf</code> : </p><br><pre> <code class="plaintext hljs">echo vm.oom-kill = 1 &gt;&gt;/etc/sysctl.conf</code> </pre> <br><p>  Outra maneira de ativar e desativar √© escrever a vari√°vel <code>panic_on_oom</code> .  O valor sempre pode ser verificado em <code>/proc</code> . </p><br><pre> <code class="plaintext hljs">$ cat /proc/sys/vm/panic_on_oom 0</code> </pre> <br><p>  Se voc√™ definir o valor como 0, quando a mem√≥ria acabar, o kernel panic n√£o. </p><br><pre> <code class="plaintext hljs">$ echo 0 &gt; /proc/sys/vm/panic_on_oom</code> </pre> <br><p>  Se voc√™ definir o valor como 1, quando a mem√≥ria acabar, o kernel panic ocorrer√°. </p><br><pre> <code class="plaintext hljs">echo 1 &gt; /proc/sys/vm/panic_on_oom</code> </pre> <br><p>  OOM-Killer n√£o pode apenas ser ligado e desligado.  J√° dissemos que o Linux pode reservar mais mem√≥ria para processos do que existe, mas n√£o aloc√°-la de fato, e esse comportamento √© controlado pelo par√¢metro do kernel do Linux.  A vari√°vel <code>vm.overcommit_memory</code> √© respons√°vel por isso. </p><br><p>  Voc√™ pode especificar os seguintes valores para ele: </p><br><p>  <strong>0: O</strong> pr√≥prio kernel decide se deve reservar muita mem√≥ria.  Este √© o valor padr√£o na maioria das vers√µes do Linux. <br>  <strong>1: o</strong> kernel sempre reserva mem√≥ria extra.  Isso √© arriscado, porque a mem√≥ria pode terminar, porque, muito provavelmente, um dia os processos exigir√£o o que deveria ser. <br>  <strong>2: o</strong> kernel n√£o reserva mais mem√≥ria do que o especificado no par√¢metro <code>overcommit_ratio</code> . </p><br><p>  Neste par√¢metro, voc√™ especifica a porcentagem de mem√≥ria para a qual a redund√¢ncia √© permitida.  Se n√£o houver espa√ßo, a mem√≥ria n√£o ser√° alocada, a reserva ser√° negada.  Esta √© a op√ß√£o mais segura recomendada para o PostgreSQL.  OOM-Killer √© afetado por outro elemento - o recurso de troca, que √© controlado pela vari√°vel <code>cat /proc/sys/vm/swappiness</code> .  Esses valores informam ao kernel como lidar com pagina√ß√£o.  Quanto maior o valor, menor a probabilidade de o OOM finalizar o processo, mas devido √† E / S, isso afeta negativamente o banco de dados.  E vice-versa - quanto menor o valor, maior a probabilidade de interven√ß√£o do OOM-Killer, mas o desempenho do banco de dados tamb√©m √© maior.  O valor padr√£o √© 60, mas se o banco de dados inteiro couber na mem√≥ria, √© melhor definir o valor como 1. </p><br><h3 id="itogi">  Sum√°rio </h3><br><p>  N√£o se assuste com o assassino em OOM-Killer.  Nesse caso, o assassino ser√° o salvador do seu sistema.  Ele "mata" os piores processos e salva o sistema de termina√ß√£o anormal.  Para evitar ter que usar o OOM-Killer para concluir o PostgreSQL, configure <code>vm.overcommit_memory</code> como 2. Isso n√£o garante que o OOM-Killer n√£o precise intervir, mas reduzir√° a probabilidade de um processo for√ßado do PostgreSQL. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt464245/">https://habr.com/ru/post/pt464245/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt464225/index.html">REST Assured: o que aprendemos em cinco anos de uso da ferramenta</a></li>
<li><a href="../pt464227/index.html">Como eles vivem e trabalham em Krasnodar</a></li>
<li><a href="../pt464233/index.html">Chaos Constructions 2019 est√° chegando ...</a></li>
<li><a href="../pt464235/index.html">"Slurm" √© altamente viciante. Como transformar uma cabala em um projeto global</a></li>
<li><a href="../pt464237/index.html">Pascal Tanchiki: como as crian√ßas aprendiam programa√ß√£o nos anos 90 e o que havia de errado nisso</a></li>
<li><a href="../pt464249/index.html">Trabalho remoto no modo de tempo integral: por onde come√ßar, se voc√™ n√£o for s√™nior</a></li>
<li><a href="../pt464253/index.html">Parar de usar datetime</a></li>
<li><a href="../pt464255/index.html">NX JAVA meetup # 14: pesquisa de desempenho em produtos, pr√≥s e contras do Spark em solu√ß√µes baseadas em Cassandra</a></li>
<li><a href="../pt464257/index.html">Resumo do UX: reinicializa√ß√£o</a></li>
<li><a href="../pt464259/index.html">Jogos na nuvem: avalia√ß√£o em primeira m√£o dos recursos dos servi√ßos para jogar em PCs fracos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>