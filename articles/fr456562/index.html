<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📡 🚤 👩🏻‍🏫 Le livre "Programmation probabiliste en Python: inférence bayésienne et algorithmes" 🕹️ 🐙 🌨️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, habrozhiteli! Les méthodes bayésiennes font peur aux formules de nombreux informaticiens, mais vous ne pouvez plus vous passer d’analyse des st...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le livre "Programmation probabiliste en Python: inférence bayésienne et algorithmes"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/456562/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/he/38/cw/he38cwwp66fmz66fhaixur-fogs.jpeg" align="left" alt="image"></a>  Salut, habrozhiteli!  Les méthodes bayésiennes font peur aux formules de nombreux informaticiens, mais vous ne pouvez plus vous passer d’analyse des statistiques et des probabilités.  Cameron Davidson-Pylon parle de la méthode bayésienne du point de vue d'un programmeur pratique travaillant avec le langage multifonctionnel PyMC et les bibliothèques NumPy, SciPy et Matplotlib.  Révélant le rôle des conclusions bayésiennes dans les tests A / B, identifiant la fraude et d'autres tâches urgentes, vous comprendrez non seulement facilement ce sujet non trivial, mais vous commencerez également à appliquer les connaissances acquises pour atteindre vos objectifs. <br><br><h3>  Extrait: 4.3.3.  Exemple: tri des commentaires sur Reddit </h3><br>  Peut-être n'êtes-vous pas d'accord que la loi des grands nombres est appliquée par tous, bien qu'implicitement, dans la prise de décision inconsciente.  Prenons l'exemple des évaluations de produits en ligne.  Faites-vous souvent confiance à une note moyenne de cinq points sur la base d'un seul avis?  Deux critiques?  Trois avis?  Vous comprenez inconsciemment qu'avec un si petit nombre d'avis, la note moyenne ne reflète pas bien à quel point le produit est bon ou mauvais. <br><a name="habracut"></a><br><br>  En conséquence, il y a des omissions lors du tri des marchandises et généralement lors de leur comparaison.  Pour de nombreux acheteurs, il est clair que trier les résultats d'une recherche interactive par note n'est pas très objectif, peu importe si nous parlons de livres, de vidéos ou de commentaires sur Internet.  Souvent, les films ou commentaires en premier lieu obtiennent des notes élevées uniquement en raison d'un petit nombre de fans enthousiastes, et de très bons films ou commentaires sont cachés sur les pages suivantes avec des notes supposément imparfaites d'environ 4,8.  Que faire à ce sujet? <br><br>  Considérez le site populaire Reddit (je ne fournis pas délibérément de liens vers celui-ci, car Reddit est connu pour attirer les utilisateurs, et je crains que vous ne reveniez jamais à mon livre).  Sur ce site, il existe de nombreux liens vers différentes histoires et images, et les commentaires sur ces liens sont également très populaires.  Les utilisateurs du site (qui est généralement appelé le mot redditor1) peuvent voter pour ou contre chaque commentaire (les soi-disant votes positifs et négatifs).  Reddit trie les commentaires par défaut dans l'ordre décroissant.  Comment déterminer quels commentaires sont les meilleurs?  Ils se concentrent généralement sur les différents indicateurs suivants. <br><br>  1. <i>Popularité</i> .  Un commentaire est considéré comme bon si beaucoup de votes sont exprimés.  Les problèmes lors de l'utilisation de ce modèle commencent dans le cas d'un commentaire avec des centaines de votes pour et des milliers de contre.  Bien que très populaire, ce commentaire semble trop ambigu pour être considéré comme "le meilleur". <br><br>  2. <i>La différence</i> .  Vous pouvez profiter de la différence entre le nombre de votes pour et contre.  Cela résout le problème qui se pose lors de l'utilisation de la métrique de «popularité», mais ne prend pas en compte le caractère temporaire des commentaires.  Les commentaires peuvent être envoyés plusieurs heures après la publication du lien d'origine.  Dans le même temps, un biais apparaît, en raison duquel la note la plus élevée n'est pas du tout reçue par les meilleurs commentaires, mais les plus anciens, qui ont réussi à accumuler plus de votes pour que les plus récents. <br><br>  3. <i>Correction du temps</i> .  Considérons une méthode dans laquelle la différence entre le pour et le contre est divisée par l'âge du commentaire et une fréquence est obtenue, par exemple, la différence en par seconde ou par minute.  Un contre-exemple vient immédiatement à l'esprit: lorsque vous utilisez l'option «par seconde», un commentaire laissé il y a une seconde avec un vote «oui» sera meilleur que laissé il y a 100 secondes avec 99 votes «oui».  Ce problème peut être évité si vous ne considérez que les commentaires laissés il y a au moins t secondes.  Mais comment choisir une bonne valeur de t?  Est-ce à dire que tous les commentaires postés il y a moins de t secondes sont mauvais?  Le cas se terminera par une comparaison des valeurs instables avec stable (commentaires nouveaux et anciens). <br><br>  4. <i>Valeur</i> .  Classement des commentaires sur le rapport entre le nombre de voix pour et le nombre total de voix pour et contre.  Cette approche élimine le problème de la nature temporelle des commentaires, de sorte que les commentaires récemment publiés avec de bonnes notes recevront une note élevée avec la même probabilité que ceux laissés il y a longtemps, à condition qu'ils aient un ratio de votes relativement élevé par rapport au nombre total de votes.  Le problème avec cette méthode est qu’un commentaire avec un vote pour (ratio = 1.0) sera meilleur qu’un commentaire avec 999 votes pour et un contre (ratio = 0.999), bien qu’il soit évident que le second de ces commentaires sera probablement le meilleur. <br><br>  J'ai écrit <i>«plutôt»</i> pour une raison.  Il peut s'avérer que le premier commentaire avec un seul vote oui est vraiment meilleur que le second, avec 999 votes oui.  Il est difficile de souscrire à cette déclaration, car nous ne savons pas quels pourraient être les 999 prochains votes potentiels pour le premier commentaire.  Disons, il pourrait obtenir à la suite de 999 autres votes pour et pas un seul vote contre et être meilleur que le second, bien qu'un tel scénario ne soit pas très probable. <br><br>  En fait, nous devons évaluer le rapport réel des votes favorables.  Je constate que ce n'est pas du tout la même que la corrélation observée des votes pour;  le rapport réel des votes est caché, on observe seulement le nombre de votes pour par rapport aux votes contre (le rapport réel des votes peut être considéré comme la probabilité que ce commentaire reçoive un vote oui, pas contre).  Grâce à la loi des grands nombres, on peut dire avec certitude que dans un commentaire avec 999 voix pour et une contre, le ratio réel des voix sera probablement proche de 1. Par contre, nous sommes beaucoup moins sûrs de ce que Le ratio réel de votes pour le commentaire avec un vote en faveur.  Cela semble être un problème bayésien. <br><br>  Une façon de déterminer la répartition a priori des votes affirmatifs est d'étudier l'historique de la répartition des votes affirmatifs.  Cela peut être fait en grattant les commentaires Reddit, puis en définissant la distribution.  Cependant, cette méthode présente plusieurs inconvénients. <br><br>  1. <i>Données asymétriques</i> .  La majorité absolue des commentaires a un très petit nombre de votes, ce qui fait que les ratios de nombreux commentaires seront proches de l'extrême (voir le graphique «triangulaire» dans l'exemple avec le jeu de données Kaggle dans la figure 4.4) et la distribution sera fortement «biaisée».  Vous pouvez essayer de ne considérer que les commentaires dont le nombre de votes dépasse une certaine valeur seuil.  Mais ici surgissent des difficultés.  Il faut rechercher un équilibre entre le nombre de commentaires disponibles, d'une part, et une valeur de seuil plus élevée avec la précision correspondante du rapport, d'autre part. <br><br>  2. <i>Données biaisées (contenant des erreurs systématiques)</i> .  Reddit est composé de nombreux sous-forums (subreddits).  Deux exemples: r / aww avec des photos d'animaux drôles et r / politique.  Il est plus que probable que le comportement des utilisateurs lors de commentaires sur ces deux sous-forums Reddit sera radicalement différent: dans le premier d'entre eux, les visiteurs sont le plus susceptibles d'être touchés et de se comporter de manière amicale, ce qui conduira à un plus grand nombre de votes en faveur, par rapport au second, où les opinions dans les commentaires sont susceptibles de diverger. <br><br>  À la lumière de ce qui précède, il me semble qu'il est judicieux d'utiliser une distribution uniforme a priori. <br><br>  Maintenant, nous pouvons calculer la distribution postérieure du rapport réel des votes en faveur.  Le script comments_for_top_reddit_pic.py est utilisé pour supprimer les commentaires de l'image Reddit la plus populaire.  Dans le code suivant, nous avons gratté les commentaires Reddit liés à l'image [3]: <a href="">http://i.imgur.com/OYsHKlH.jpg.</a> <br><br><pre><code class="plaintext hljs">from IPython.core.display import Image #       %run #   i-   . %run top_pic_comments.py 2</code> </pre> <br><blockquote><pre> <code class="plaintext hljs">[Output]: Title of submission: Frozen mining truck http://i.imgur.com/OYsHKlH.jpg</code> </pre> </blockquote><br><pre> <code class="plaintext hljs">""" Contents:       Votes:   NumPy  ""  ""    """ n_comments = len(contents) comments = np.random.randint(n_comments, size=4) print "  (    %d) \n -----------"%n_comments for i in comments: print '"' + contents[i] + '"' print " ""/"": ",votes[i,:] print</code> </pre> <br><blockquote><pre> <code class="plaintext hljs">[Output]:   (   77) ----------- "Do these trucks remind anyone else of Sly Cooper?"  ""/"": [2 0] "Dammit Elsa I told you not to drink and drive."  ""/"": [7 0] "I've seen this picture before in a Duratray (the dump box supplier) brochure..."  ""/"": [2 0] "Actually it does not look frozen just covered in a layer of wind packed snow."  ""/"": [120 18]</code> </pre> </blockquote><br>  Avec N votes et un ratio de votes réel donné "pour" p, le nombre de votes "pour" ressemble à une variable aléatoire binomiale avec les paramètres p et N (le fait est que le ratio réel de votes pour "est équivalent à la probabilité de voter pour" par rapport au vote " contre "avec N votes / procès possibles).  Nous créons une fonction pour la dérivation bayésienne de p par rapport à l'ensemble des votes «pour» / «contre» un commentaire particulier. <br><br><pre> <code class="plaintext hljs">import pymc as pm def posterior_upvote_ratio(upvotes, downvotes, samples=20000): """         ""  "",   ,    ,    . ,    . """ N = upvotes + downvotes upvote_ratio = pm.Uniform("upvote_ratio", 0, 1) observations = pm.Binomial("obs", N, upvote_ratio, value=upvotes, observed=True) # ;    MAP,     #       . map_ = pm.MAP([upvote_ratio, observations]).fit() mcmc = pm.MCMC([upvote_ratio, observations]) mcmc.sample(samples, samples/4) return mcmc.trace("upvote_ratio")[:]</code> </pre> <br>  Voici les distributions postérieures résultantes. <br><br><pre> <code class="plaintext hljs">figsize(11., 8) posteriors = [] colors = ["#348ABD", "#A60628", "#7A68A6", "#467821", "#CF4457"] for i in range(len(comments)): j = comments[i] label = u'(%d :%d )\n%s...'%(votes[j, 0], votes[j,1], contents[j][:50]) posteriors.append(posterior_upvote_ratio(votes[j, 0], votes[j,1])) plt.hist(posteriors[i], bins=18, normed=True, alpha=.9, histtype="step", color=colors[i%5], lw=3, label=label) plt.hist(posteriors[i], bins=18, normed=True, alpha=.2, histtype="stepfilled", color=colors[i], lw=3) plt.legend(loc="upper left") plt.xlim(0, 1) plt.ylabel(u"") plt.xlabel(u"  ''") plt.title(u"    '' \   ");</code> </pre> <br><blockquote><pre> <code class="plaintext hljs">[Output]: [****************100%******************] 20000 of 20000 complete</code> </pre> </blockquote><br>  Comme on peut le voir sur la fig.  4.5, certaines distributions sont fortement «pressées», tandis que d'autres ont des «queues» relativement longues, exprimant que nous ne savons pas exactement à quoi sert le ratio réel des votes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_o/vm/4v/_ovm4vt7lqlq9m7ikb6hrrfdjtm.png" alt="image"></div><br><h3>  4.3.4.  Tri </h3><br>  Jusqu'à présent, nous avons ignoré l'objectif principal de notre exemple: trier les commentaires du meilleur au pire.  Bien sûr, il est impossible de trier les distributions;  trier les valeurs scalaires nécessaires.  Il existe de nombreuses façons d'extraire l'essence de la distribution sous la forme d'un scalaire;  par exemple, l'essence d'une distribution peut être exprimée en termes d'espérance mathématique ou de valeur moyenne.  Cependant, la valeur moyenne pour cela n'est pas appropriée, car cet indicateur ne prend pas en compte l'incertitude des distributions. <br><br>  Je recommanderais d'utiliser la valeur la moins plausible à 95%, qui est définie comme une valeur avec seulement 5% de probabilité que la valeur réelle du paramètre soit inférieure à celle-ci (cf. la borne inférieure de l'intervalle de confiance bayésien).  Ensuite, nous traçons les distributions postérieures avec la valeur la moins probable indiquée à 95% (Fig. 4.6). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fu/t-/-5/fut--5kk2z6ddywqyx-efnblbxo.png" alt="image"></div><br><pre> <code class="plaintext hljs">N = posteriors[0].shape[0] lower_limits = [] for i in range(len(comments)): j = comments[i] label = '(%d :%d )\n%s…'%(votes[j, 0], votes[j,1], contents[j][:50]) plt.hist(posteriors[i], bins=20, normed=True, alpha=.9, histtype="step", color=colors[i], lw=3, label=label) plt.hist(posteriors[i], bins=20, normed=True, alpha=.2, histtype="stepfilled", color=colors[i], lw=3) v = np.sort(posteriors[i])[int(0.05*N)] plt.vlines(v, 0, 10 , color=colors[i], linestyles="—", linewidths=3) lower_limits.append(v) plt.legend(loc="upper left") plt.ylabel(u"") plt.xlabel(u"  ''") plt.title(u"    '' \   "); order = np.argsort(-np.array(lower_limits)) print order, lower_limits</code> </pre> <br><blockquote><pre> <code class="plaintext hljs">[Output]: [3 1 2 0] [0.36980613417267094, 0.68407203257290061, 0.37551825562169117, 0.8177566237850703]</code> </pre> </blockquote><br>  Selon notre procédure, les meilleurs seront les commentaires pour lesquels la plus forte probabilité de recevoir un pourcentage élevé de votes oui.  Visuellement, il s'agit des commentaires dont la valeur la moins plausible est 95% la plus proche de l'unité.  Dans la fig.  4.6 La valeur la moins plausible à 95% est représentée à l'aide de lignes verticales. <br><br>  Pourquoi le tri basé sur cette métrique est-il une si bonne idée?  Le tri selon la valeur la moins plausible à 95% signifie une prudence maximale dans la déclaration des commentaires comme étant les meilleurs.  Autrement dit, même dans le pire des cas, si nous surestimons fortement le rapport des votes en faveur, il est garanti que les meilleurs commentaires seront au top.  Avec cette commande, les propriétés très naturelles suivantes sont fournies. <br><br>  1. Des deux commentaires avec le même ratio de votes «pour» observé, le commentaire avec le plus grand nombre de votes sera reconnu comme le meilleur (puisque la confiance est plus élevée pour le ratio le plus élevé). <br><br>  2. Des deux commentaires avec le même nombre de votes, le meilleur est considéré comme le commentaire avec le plus grand nombre de votes pour. <br><br>  »Plus d'informations sur le livre sont disponibles sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le site Web de l'éditeur</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Contenu</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Extrait</a> <br><br>  25% de réduction sur les colporteurs - <b>JavaScript</b> <br><br>  Lors du paiement de la version papier du livre, un livre électronique est envoyé par e-mail. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr456562/">https://habr.com/ru/post/fr456562/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr456544/index.html">10 meilleurs hacks JavaScript pour des performances optimisées</a></li>
<li><a href="../fr456546/index.html">Améliorer le travail du Wi-Fi. Partie 3. Emplacement des points d'accès</a></li>
<li><a href="../fr456554/index.html">Journée portes ouvertes Netrology «Profession Data Science»</a></li>
<li><a href="../fr456556/index.html">Recettes Nginx: autorisation de base avec captcha</a></li>
<li><a href="../fr456558/index.html">Scanner de port dans le compte personnel de Rostelecom</a></li>
<li><a href="../fr456564/index.html">Liste des utilisateurs avec des mots de passe faibles dans MS SQL</a></li>
<li><a href="../fr456568/index.html">Les développeurs sont désormais mesurés en nombre de vues et d'abonnés - et c'est faux</a></li>
<li><a href="../fr456570/index.html">Ce vendredi 21 juin sera l'anniversaire de DevConfX, 22 juin des master classes exclusives</a></li>
<li><a href="../fr456572/index.html">40 ans d'advergaming - une rétrospective des jeux vidéo publicitaires</a></li>
<li><a href="../fr456574/index.html">Réseaux de télévision par câble pour les plus petits. Partie 10: Dépannage des réseaux KTV</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>