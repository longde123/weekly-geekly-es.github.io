<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☄️ 🙍🏽 🐱 Nginx缓存：一切都是新的-被遗忘的很旧 🤳🏻 👩🏾‍✈️ ☝🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在每个项目的生命周期中，服务器停止满足SLA要求并从字面上开始阻塞传入流量的时间到了。 之后，漫长的过程开始了，发现了瓶颈，繁重的查询，错误创建的索引，未缓存的数据，反之亦然，因为缓存中的更新数据和项目的其他方面经常被更新。 

 但是，当您的代码“完美”，所有繁重的请求都放在后台，所有可能的内容都...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nginx缓存：一切都是新的-被遗忘的很旧</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428127/"> 在每个项目的生命周期中，服务器停止满足SLA要求并从字面上开始阻塞传入流量的时间到了。 之后，漫长的过程开始了，发现了瓶颈，繁重的查询，错误创建的索引，未缓存的数据，反之亦然，因为缓存中的更新数据和项目的其他方面经常被更新。 <br><br> 但是，当您的代码“完美”，所有繁重的请求都放在后台，所有可能的内容都已缓存并且服务器仍未达到我们所需的SLA指标时，该怎么办？ 当然，如果可能的话，您当然可以购买新车，分配一些交通流量，并暂时忘记问题。 <br><br> 但是，如果您觉得服务器功能强大，或者有一个神奇的参数可以使站点加速100倍，则可以调用内置的nginx功能，该功能可以缓存来自后端的响应。 让我们看一下它是什么以及它如何帮助增加服务器处理的请求数量。 <a name="habracut"></a><br><br><h3> 什么是Nginx缓存，它如何工作？ </h3><br>  Nginx缓存可以显着减少后端的请求数量。 这可以通过保存HTTP响应一定时间来实现，并在再次访问资源时从缓存中返回它而无需代理后端请求。 即使是短时间的缓存，也将显着增加服务器处理的请求数量。 <br><br> 在继续配置nginx之前，您需要确保它是使用“ ngx_http_proxy_module”模块构建的，因为我们将使用此模块对其进行配置。 <br><br> 为了方便起见，可以将配置放在单独的文件中，例如“ /etc/nginx/conf.d/cache.conf”。 让我们看一下proxy_cache_path指令，它允许您配置缓存存储设置。 <br><br><pre><code class="hljs swift">proxy_cache_path /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/lib/nginx/proxy_cache levels=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> keys_zone=proxy_cache:15m max_size=1G;</code> </pre> <br>  “ / Var / lib / nginx / proxy_cache”指定服务器上的缓存存储路径。  Nginx将在此目录中保存带有后端响应的文件。 同时，nginx不会单独为缓存创建目录，您需要自己进行维护。 <br><br>  “ Levels = 1：2”-设置目录与缓存的嵌套级别。 嵌套级别通过“：”指示，在这种情况下，将创建2个目录，总共允许3个嵌套级别。 对于每个嵌套级别，从1到2的值都可用，指示如何创建目录名称。 <br><br> 重要的是目录名称不是随机选择的，而是基于文件名创建的。 反过来，文件名是来自缓存键的md5函数的结果；我们稍后将查看缓存键。 <br><br> 让我们在实践中看看如何构建缓存文件的路径： <br><br><pre> <code class="hljs swift">/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/lib/nginx/proxy_cache/<span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">49</span></span>/07edcfe6974569ab4da6634ad4e5d492</code> </pre> <br>  “ Keys_zone = proxy_cache：15m”参数设置共享内存中区域的名称，所有活动密钥及其信息都存储在该区域中。 通过“：”表示分配的内存大小（以MB为单位）。 根据nginx的数据，1 MB足以存储8000个密钥。 <br><br>  “ Max_size = 1G”定义了所有页面的最大缓存大小，超过此大小，nginx将负责删除需要的数据。 <br><br> 也可以控制缓存中数据的生存期，为此，定义“ proxy_cache_path”指令的“ inactive”参数就足够了，默认情况下为10分钟。 如果在“无效”参数指定的时间内没有调用缓存数据，则即使缓存不是“酸”的，也会删除该数据。 <br><br> 这个缓存是什么样的？ 这实际上是服务器上的常规文件，其内容被写入： <br><br>  •缓存键； <br>  •缓存头； <br>  •来自后端的内容响应。 <br><br> 如果标题和后端的响应都清楚了，那么“缓存键”就会有很多问题。 它是如何构建的以及如何进行管理？ <br><br> 为了描述在nginx中构建缓存键的模板，有一个proxy_cache_key指令，其中将字符串指定为参数。 字符串可以包含nginx中可用的任何变量。 <br><br> 例如： <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_key</span></span> <span class="hljs-variable"><span class="hljs-variable">$request_method</span></span><span class="hljs-variable"><span class="hljs-variable">$host</span></span><span class="hljs-variable"><span class="hljs-variable">$orig_uri</span></span>:<span class="hljs-variable"><span class="hljs-variable">$cookie_some_cookie</span></span>:<span class="hljs-variable"><span class="hljs-variable">$arg_some_arg</span></span>;</code> </pre> <br>  cookie参数和get参数之间的“：”符号用于防止高速缓存键之间发生冲突，您可以选择任何其他符号。 默认情况下，nginx使用以下行来生成密钥： <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_key</span></span> <span class="hljs-variable"><span class="hljs-variable">$scheme</span></span><span class="hljs-variable"><span class="hljs-variable">$proxy_host</span></span><span class="hljs-variable"><span class="hljs-variable">$request_uri</span></span>;</code> </pre> <br> 应注意以下指令，这些指令将帮助您更灵活地管理缓存： <br><br>  <i>proxy_cache_valid-</i>指定响应缓存时间。 可以指示响应的特定状态，例如200、302、404等，或使用“ any”构造一次指定所有内容。 如果仅指定缓存时间，nginx将默认仅缓存200、301和302状态。 <br><br> 一个例子： <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_valid</span></span> <span class="hljs-number"><span class="hljs-number">15m</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_valid</span></span> <span class="hljs-number"><span class="hljs-number">404</span></span> <span class="hljs-number"><span class="hljs-number">15s</span></span>;</code> </pre><br> 在此示例中，我们将状态200、301、302的缓存生存期设置为15分钟（nginx默认使用它们，因为我们没有指定特定的状态）。 下一行将缓存时间设置为15秒，仅适用于状态为404的响应。 <br><br>  <i>proxy_cache_lock-</i>此指令将有助于避免在设置一组缓存后立即多次传递给后端，只需将值设置在“ on”位置即可。 所有其他请求将等待缓存中的响应，或者等待超时以阻止对该页面的请求。 因此，可以配置所有超时。 <br><br>  <i>proxy_cache_lock_age-</i>允许您为服务器的响应设置超时限制，之后将在设置缓存后将下一个请求发送给它。 默认值为5秒。 <br><br>  <i>proxy_cache_lock_timeout-</i>设置等待锁定的时间，之后将请求发送到后端，但不会缓存响应。 默认值为5秒。 <br><br>  <i>proxy_cache_use_stale-</i>另一个有用的指令，允许您配置何时可以使用过时的缓存。 <br><br> 一个例子： <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_use_stale</span></span> <span class="hljs-literal"><span class="hljs-literal">error</span></span> timeout updating;</code> </pre> <br> 在这种情况下，如果出现连接错误，发送请求，从服务器读取响应，超过发送请求的等待限制，从服务器读取响应或在请求时更新了缓存中的数据，它将使用过时的缓存。 <br><br>  <i>proxy_cache_bypass-</i>指定在什么条件下nginx不会从缓存中获取响应，而是立即将请求重定向到后端。 如果至少一个参数不为空且不等于“ 0”。 一个例子： <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_bypass</span></span> <span class="hljs-variable"><span class="hljs-variable">$cookie_nocache</span></span> <span class="hljs-variable"><span class="hljs-variable">$arg_nocache</span></span>;</code> </pre> <br>  <i>proxy_no_cache-</i>设置nginx将不将响应从后端保存到缓存的条件。 操作原理与proxy_cache_bypass指令的原理相同。 <br><br><h3> 页面缓存的可能问题 </h3><br> 如上所述，除了缓存HTTP响应外，nginx还保存从后端接收的标头。 如果您的站点使用会话，则会话cookie也将被缓存。 访问您幸运缓存的页面的所有用户将收到您存储在会话中的个人数据。 <br><br> 您将面临的下一个挑战是缓存管理。 当然，您可以将微不足道的缓存时间设置为2-5分钟，这在大多数情况下就足够了。 但这并不是在所有情况下都适用，因此我们将重新发明自行车。 现在，首先是第一件事。 <br><br>  <b>Cookie保存管理</b> <br><br>  Nginx端的缓存施加了一些设计限制。 例如，我们不能在缓存的页面上使用会话，因为用户没有到达后端，另一个限制是后端传递cookie。 由于nginx缓存所有标头，为了避免在缓存中存储其他人的会话，我们需要禁止为缓存的页面传递cookie。  proxy_ignore_headers指令将帮助我们解决这一问题。 该参数列出了应从后端忽略的标头。 <br><br> 一个例子： <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_ignore_headers</span></span> <span class="hljs-string"><span class="hljs-string">"Set-Cookie"</span></span>;</code> </pre> <br> 通过这一行，我们将忽略从代理服务器安装Cookie的情况，也就是说，用户将收到不带“ Set-Cookies”标头的响应。 因此，后端尝试写入Cookie的所有内容都将在客户端被忽略，因为它甚至不知道有什么用途。 开发应用程序时应考虑此cookie限制。 例如，要请求授权，您可以关闭标题点火，以便用户接收会话cookie。 <br><br> 您还应该考虑会话生存期，可以在php.ini配置的“ <i>session.gc_maxlifetime</i> ”参数中进行查看。 假设用户登录该站点并开始查看新闻源，则所有数据已经​​在nginx缓存中。 一段时间后，用户注意到他的授权已消失，并且他再次需要执行授权过程，尽管这段时间他一直在网站上观看新闻。 发生这种情况是因为nginx在所有请求上都从缓存返回了结果，而没有向后端发送请求。 因此，后端确定用户处于非活动状态，并且在“ <i>session.gc_maxlifetime</i> ”中指定的时间后删除了会话文件。 <br><br> 为了防止这种情况的发生，我们可以模拟后端请求。 例如，通过ajax发送一个可以保证传递到后端的请求。 要将nginx缓存传递到后端，只需发送POST请求，您还可以使用“ proxy_cache_bypass”指令中的规则，或直接禁用此页面的缓存。 该请求不必回馈，它可以是一个只有一行开始会话的文件。 这种请求的目的是延长用户在站点上时会话的生命周期，并且nginx认真地将缓存的数据提供给所有请求。 <br><br>  <b>缓存刷新管理</b> <br><br> 首先，您需要确定需求，我们正在努力实现什么目标。 假设我们的网站上有一个部分，其中包含流行体育赛事的文字广播。 当从缓存中提供页面时，所有新消息都会在套接字上出现。 为了使用户能够在第一次启动时（而不是15分钟前）在当前时间看到当前消息，我们需要能够在任何时间独立清除nginx缓存。 同时，nginx可能与应用程序不在同一台机器上。 同样，重置的要求之一是能够一次跨多个页面删除缓存。 <br><br> 在开始编写解决方案之前，让我们先看看nginx提供了什么。 为了重置缓存，nginx有一个特殊的指令称为“ proxy_cache_purge”，该指令记录了重置缓存的条件。 条件实际上是一条正常的行，如果不为空且不为“ 0”，则将通过传递的键删除缓存。 考虑一个小例子。 <br><br><pre> <code class="hljs perl">proxy_cache_path /data/nginx/cache keys_zone=cache_zone:<span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-keyword"><span class="hljs-keyword">m</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">map</span></span> $request_method $purge_method { PURGE <span class="hljs-number"><span class="hljs-number">1</span></span>; default <span class="hljs-number"><span class="hljs-number">0</span></span>; } server { ... location / { proxy_pass http:<span class="hljs-regexp"><span class="hljs-regexp">//backend</span></span>; proxy_cache cache_zone; proxy_cache_key $uri; proxy_cache_purge $purge_method; } }</code> </pre><br>  <i>一个例子来自nginx官方网站。</i> <br><br>  $ purge_method变量负责刷新缓存，这是proxy_cache_purge指令的条件，默认情况下设置为0。 这意味着nginx在“正常”模式下工作（它保存来自后端的响应）。 但是，如果将请求方法更改为“ PURGE”，则将使用相应的缓存键来删除缓存条目，而不是通过保存响应来代理后端请求。 也可以通过在缓存键的末尾指定“ *”来指定删除掩码。 因此，我们不需要知道缓存在磁盘上的位置以及密钥形成的原理，nginx承担了这些责任。 但是这种方法也有缺点。 <br><br><ul><li>  proxy_cache_purge指令可作为商业订阅的一部分使用。 </li><li> 只能逐点删除缓存，也可以使用{cache key}“ *”形式的掩码删除缓存 </li></ul><br> 由于缓存页面的地址可以完全不同，没有共同的部分，因此带掩码“ *”和指令“ proxy_cache_purge”的方法不适合我们。 回顾一点理论并发现自己喜欢的想法还有待时日。 <br><br> 我们知道nginx缓存是服务器上的常规文件。 我们在“ proxy_cache_path”指令中独立指定了用于存储缓存文件的目录，甚至还指定了使用“级别”从该目录形成文件路径的逻辑。 我们唯一缺少的是缓存密钥的正确格式。 但是我们也可以在“ proxy_cache_key”指令中看到它。 现在我们要做的就是： <br><br><ul><li> 完全按照proxy_cache_key指令中的指定形成页面的完整路径； </li><li> 将结果字符串编码为md5； </li><li> 使用“ levels”参数中的规则创建嵌套目录。 </li><li> 现在，我们已经拥有服务器上缓存文件的完整路径。 现在剩下要做的就是删除这个文件。 从入门部分开始，我们知道nginx可能不在应用程序计算机上，因此您需要使一次删除多个地址成为可能。 再次，我们描述算法： </li><li> 高速缓存文件的生成路径我们将写入该文件； </li><li> 让我们编写一个简单的bash脚本，将其与应用程序一起放入计算机。 他的任务是通过ssh连接到我们已缓存nginx的服务器，并删除步骤1中生成的文件中指定的所有缓存文件； </li></ul><br> 从理论到实践，我们将写一个小例子来说明我们的工作算法。 <br><br> 步骤1.生成包含缓存路径的文件。 <br><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$urls</span></span> = [ <span class="hljs-string"><span class="hljs-string">'httpGETdomain.ru/news/111/1:2'</span></span>, <span class="hljs-string"><span class="hljs-string">'httpGETdomain.ru/news/112/3:4'</span></span>, ]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_nginx_cache_path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span></span> { <span class="hljs-variable"><span class="hljs-variable">$nginxHash</span></span> = md5(<span class="hljs-variable"><span class="hljs-variable">$url</span></span>); <span class="hljs-variable"><span class="hljs-variable">$firstDir</span></span> = substr(<span class="hljs-variable"><span class="hljs-variable">$nginxHash</span></span>, <span class="hljs-literal"><span class="hljs-literal">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-variable"><span class="hljs-variable">$secondDir</span></span> = substr(<span class="hljs-variable"><span class="hljs-variable">$nginxHash</span></span>, <span class="hljs-literal"><span class="hljs-literal">-3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"/var/lib/nginx/proxy_cache/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$firstDir</span></span></span><span class="hljs-string">/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$secondDir</span></span></span><span class="hljs-string">/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$nginxHash</span></span></span><span class="hljs-string">"</span></span>; } //        tmp <span class="hljs-variable"><span class="hljs-variable">$filePath</span></span> = tempnam(<span class="hljs-string"><span class="hljs-string">'tmp'</span></span>, <span class="hljs-string"><span class="hljs-string">'nginx_cache_'</span></span>); //      <span class="hljs-variable"><span class="hljs-variable">$fileStream</span></span> = fopen(<span class="hljs-variable"><span class="hljs-variable">$filePath</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-variable"><span class="hljs-variable">$urls</span></span> as <span class="hljs-variable"><span class="hljs-variable">$url</span></span>) { //      <span class="hljs-variable"><span class="hljs-variable">$cachePath</span></span> = to_nginx_cache_path(<span class="hljs-variable"><span class="hljs-variable">$url</span></span>); //       fwrite(<span class="hljs-variable"><span class="hljs-variable">$fileStream</span></span>, <span class="hljs-variable"><span class="hljs-variable">$cachePath</span></span> . PHP_EOL); } //     fclose(<span class="hljs-variable"><span class="hljs-variable">$fileStream</span></span>); //  bash       exec(<span class="hljs-string"><span class="hljs-string">"/usr/local/bin/cache_remover </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$filePath</span></span></span><span class="hljs-string">"</span></span>);</code> </pre><br> 请注意，变量$ urls包含已缓存页面的url，已采用nginx配置中指定的proxy_cache_key格式。 网址充当页面上显示的实体的标签。 例如，您可以在数据库中创建一个常规表，其中每个实体都将映射到显示该实体的特定页面。 然后，当更改任何数据时，我们可以在表上进行选择并删除我们需要的所有页面的缓存。 <br><br> 步骤2.连接到缓存服务器并删除缓存文件。 <br><br><pre> <code class="hljs smalltalk">#      ,      <span class="hljs-type"><span class="hljs-type">FILE_LIST</span></span>=`cat <span class="hljs-string"><span class="hljs-string">$1</span></span> | tr <span class="hljs-comment"><span class="hljs-comment">"\n"</span></span> <span class="hljs-comment"><span class="hljs-comment">" "</span></span>` #   ssh  <span class="hljs-type"><span class="hljs-type">SSH</span></span>=`which ssh` <span class="hljs-type"><span class="hljs-type">USER</span></span>=<span class="hljs-comment"><span class="hljs-comment">"root"</span></span> #         nginx <span class="hljs-type"><span class="hljs-type">HOST</span></span>=<span class="hljs-comment"><span class="hljs-comment">"10.10.1.0"</span></span> #   <span class="hljs-type"><span class="hljs-type">KEY</span></span>=<span class="hljs-comment"><span class="hljs-comment">"/var/keys/id_rsa"</span></span> # <span class="hljs-type"><span class="hljs-type">SSH</span></span> ,          <span class="hljs-string"><span class="hljs-string">$S</span></span>SH -i <span class="hljs-string"><span class="hljs-string">${</span></span><span class="hljs-type"><span class="hljs-type">KEY</span></span>} <span class="hljs-string"><span class="hljs-string">${</span></span><span class="hljs-type"><span class="hljs-type">USER</span></span>}@<span class="hljs-string"><span class="hljs-string">${</span></span><span class="hljs-type"><span class="hljs-type">HOST</span></span>} <span class="hljs-comment"><span class="hljs-comment">"rm -f ${FILE_LIST}"</span></span> #       rm -rf rm -f <span class="hljs-string"><span class="hljs-string">$1</span></span> #  </code> </pre><br> 以上示例仅供参考，请勿在生产中使用。 在示例中，省略了对输入参数和命令限制的检查。 您可能会遇到的问题之一是将参数的长度限制为rm命令。 在开发环境中以小批量进行测试时，很容易错过这一点，在生产中会出现“ rm：参数列表过长”错误。 <br><br><h3> 自定义块缓存 </h3><br> 让我们总结一下我们要做的事情： <br><br><ul><li> 减少了后端的负载； </li><li> 了解如何管理缓存 </li><li> 学会了在任何给定时间刷新缓存。 </li></ul><br> 但是，并非一切看起来都像乍看起来那样好。 现在，如果不是每个站点，那么可能恰好每个站点都具有注册/授权功能，通过后，我们将要在标题中的某个位置显示用户名。 具有名称的块是唯一的，并应显示授权我们使用的用户名。 由于nginx保存了来自后端的响应，并且在页面的情况下，它是页面的html内容，带有个人数据的块也将被缓存。 该网站的所有访问者都将看到第一个传递给后端以获取一组缓存的用户的名称。 <br> 因此，后端不应提供个人信息所在的块，以使该信息不属于nginx缓存。 <br><br> 有必要考虑页面的这些部分的替代加载。 与往常一样，这可以通过多种方式来完成，例如，在加载页面，发送ajax请求并显示加载器代替个人内容之后。 我们今天将考虑的另一种方法是使用ssi标签。 首先让我们了解SSI是什么，然后如何将其与Nginx缓存结合使用。 <br><br><h3> 什么是SSI及其运作方式 </h3><br>  SSI（服务器端包含项，服务器端包含项）是嵌入html页面的一组命令，该命令告诉服务器该做什么。 <br><br> 以下是此类命令（指令）的列表： <br><br>  •if / elif / else / endif-分支运算符； <br>  •echo-显示变量的值； <br>  •包含-允许您将另一个文件的内容插入文档中。 <br> 仅讨论最后一条指令。  include指令具有两个参数： <br>  •file-指定服务器上文件的路径。 关于当前目录； <br>  •virtual-指示服务器上文档的虚拟路径。 <br><br> 我们对“虚拟”参数很感兴趣，因为在服务器上指定文件的完整路径并不总是很方便，或者在分布式体系结构的情况下，服务器上的文件根本不存在。 指令示例： <br><br><pre> <code class="hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!--#include virtual="/user/personal_news/"--&gt;</span></span></code> </pre> <br> 为了使nginx开始处理ssi插入，您需要按如下所示修改位置： <br><br><pre> <code class="hljs cs">location / { ssi <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; ... }</code> </pre><br> 现在，由位置“ /”处理的所有请求都将能够执行ssi插入。 <br><br> 我们的请求将如何处理整个方案？ <br><br><ul><li> 客户请求页面； </li><li>  Nginx代理后端请求； </li><li> 后端为页面提供ssi插入； </li><li> 结果存储在缓存中； </li><li>  Nginx“查询”缺失的区块； </li><li> 结果页面将发送到客户端。 </li></ul><br> 从步骤中可以看到，ssi构造将进入nginx缓存，这将不允许缓存个人块，并且带有所有插入内容的现成html页面将被发送到客户端。 在我们的加载工作中，nginx独立地请求缺少的页面块。 但是，与任何其他解决方案一样，此方法也有其优点和缺点。 想象一下，页面上有多个块，根据用户的不同应显示不同的块，然后将每个这样的块替换为ssi插入。 如预期的那样，Nginx将从后端请求每个这样的块，也就是说，来自用户的一个请求将立即为后端生成多个请求，而我根本不需要。 <br><br><h3> 通过ssi摆脱持久的后端请求 </h3><br> 为了解决这个问题，nginx模块“ ngx_http_memcached_module”将为我们提供帮助。 该模块允许从memcached服务器接收值。 通过模块写将无法正常工作，应用服务器应注意这一点。 考虑一个与模块一起配置nginx的小例子： <br><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /page { <span class="hljs-attribute"><span class="hljs-attribute">set</span></span> <span class="hljs-variable"><span class="hljs-variable">$memcached_key</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$uri</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">memcached_pass</span></span> <span class="hljs-number"><span class="hljs-number">127.0.0.1:11211</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">error_page</span></span> <span class="hljs-number"><span class="hljs-number">404</span></span> <span class="hljs-number"><span class="hljs-number">502</span></span> <span class="hljs-number"><span class="hljs-number">504</span></span> = <span class="hljs-variable"><span class="hljs-variable">@fallback</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> <span class="hljs-variable"><span class="hljs-variable">@fallback</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://backend; } }</code> </pre><br> 在变量$ memcache_key中，我们指定了Nginx尝试从memcache获取数据的键。 在memcached_pa​​ss指令中设置用于连接到内存缓存服务器的参数。 可以通过几种方式指定连接： <br><br>  •域名； <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">memcached_pass</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">cache</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.domain</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ru</span></span>;</code> </pre> <br>  •IP地址和端口； <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">memcached_pass</span></span> localhost:<span class="hljs-number"><span class="hljs-number">11211</span></span>;</code> </pre> <br>  •Unix套接字； <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">memcached_pass</span></span> unix:/tmp/memcached.socket;</code> </pre> <br>  •上游指令。 <br><br><pre> <code class="hljs axapta">upstream cachestream { hash $request_uri consistent; <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> <span class="hljs-number"><span class="hljs-number">10.10</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>:<span class="hljs-number"><span class="hljs-number">11211</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> <span class="hljs-number"><span class="hljs-number">10.10</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>:<span class="hljs-number"><span class="hljs-number">11211</span></span>; } location / { ... memcached_pass cachestream; ... }</code> </pre><br> 如果nginx设法从缓存服务器获得响应，那么它将响应提供给客户端。 如果缓存中没有数据，则请求将通过“ @fallback”发送到后端。 在nginx下对memcached模块进行的这种小设置将帮助我们减少ssi插入对后端传递请求的数量。 <br><br> 我们希望本文是有用的，并且我们能够展示一种优化服务器负载的方法，考虑设置nginx缓存的基本原理，并解决使用它时出现的问题。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN428127/">https://habr.com/ru/post/zh-CN428127/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN428117/index.html">Google在协作云中提供免费的张量处理器</a></li>
<li><a href="../zh-CN428119/index.html">“ Class-fields-proposal”或“ tc39 commit出了什么问题”</a></li>
<li><a href="../zh-CN428121/index.html">斯坦·德拉普金（Stan Drapkin）。 .NET中的高级密码陷阱</a></li>
<li><a href="../zh-CN428123/index.html">安全周41：好消息</a></li>
<li><a href="../zh-CN428125/index.html">谁是产品分析人员，为什么团队需要它们？</a></li>
<li><a href="../zh-CN428129/index.html">简单的模糊逻辑将燃气轮机的“从过去”粘合在一起</a></li>
<li><a href="../zh-CN428131/index.html">关于RTOS的全部真相。 第十七条 事件标志组：简介和基本服务</a></li>
<li><a href="../zh-CN428133/index.html">羽ura 高性能GraphQL到SQL Server的体系结构</a></li>
<li><a href="../zh-CN428135/index.html">如何在内置代码编辑器中配置或禁用linting</a></li>
<li><a href="../zh-CN428137/index.html">奥运会，创意大赛，有关IT项目管理和电影放映的讲座：ITMO大学即将举行的10个活动</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>