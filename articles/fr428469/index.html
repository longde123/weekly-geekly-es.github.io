<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§πüèø üè¥‚Äç‚ò†Ô∏è ‚ÜïÔ∏è Noyau Windows unique üë©üèæ‚Äçüç≥ ‚ôíÔ∏è üë®üèæ‚Äçüíª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Windows est l'un des syst√®mes d'exploitation les plus polyvalents et flexibles, il fonctionne sur des architectures compl√®tement diff√©rentes et est di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Noyau Windows unique</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428469/"> Windows est l'un des syst√®mes d'exploitation les plus polyvalents et flexibles, il fonctionne sur des architectures compl√®tement diff√©rentes et est disponible en diff√©rentes versions.  Aujourd'hui, il prend en charge les architectures x86, x64, ARM et ARM64.  Windows a pris en charge Itanium, PowerPC, DEC Alpha et MIPS.  En outre, Windows prend en charge une large gamme de SKU fonctionnant dans diverses conditions;  Des centres de donn√©es, ordinateurs portables, Xbox et t√©l√©phones aux versions int√©gr√©es de l'Internet des objets, par exemple, dans les distributeurs automatiques de billets. <br><br>  L'aspect le plus √©tonnant est que le noyau Windows reste pratiquement inchang√© en fonction de toutes ces architectures et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SKU</a> .  Le noyau √©volue dynamiquement en fonction de l'architecture et du processeur sur lesquels il fonctionne, afin de profiter pleinement de l'√©quipement.  Bien s√ªr, le noyau a une certaine quantit√© de code associ√©e √† une architecture sp√©cifique, mais il y en a une quantit√© minimale, ce qui permet √† Windows de fonctionner sur une vari√©t√© d'architectures. <br><br>  Dans cet article, je parlerai de l'√©volution des √©l√©ments cl√©s du noyau Windows qui lui permettent d'√©voluer de mani√®re transparente de la puce NVidia Tegra basse consommation fonctionnant sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Surface RT</a> 2012 aux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">monstres</a> g√©ants travaillant dans les centres de donn√©es Azure. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://gxcuf89792.i.lithium.com/t5/image/serverpage/image-id/55551i89F6A2C912C5C448/image-size/large?v=1.0&amp;px=999"></div><br>  Un gestionnaire de t√¢ches Windows s'ex√©cutant sur une machine pr√©liminaire Windows DataCenter, avec 896 c≈ìurs prenant en charge 1792 processeurs logiques et 2 To de m√©moire <br><br><h2>  √âvolution du noyau unique </h2><br>  Avant de discuter des d√©tails du noyau Windows, penchons-nous un peu vers le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">refactoring</a> .  Le refactoring joue un r√¥le cl√© dans l'augmentation de la r√©utilisation des composants du syst√®me d'exploitation sur diverses SKU et plates-formes (par exemple, client, serveur et t√©l√©phone).  L'id√©e de base du refactoring est de vous permettre de r√©utiliser la m√™me DLL sur diff√©rentes r√©f√©rences, en prenant en charge de petites modifications apport√©es sp√©cifiquement pour la r√©f√©rence souhait√©e, sans renommer la DLL et sans interrompre le travail des applications. <br><br>  La technologie de base du refactoring Windows est une technologie peu document√©e appel√©e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ensembles d'API</a> .  Les suites d'API sont un m√©canisme qui permet au syst√®me d'exploitation de s√©parer la DLL et son lieu d'utilisation.  Par exemple, le jeu d'API permet aux applications pour win32 de continuer √† utiliser kernel32.dll, malgr√© le fait que l'impl√©mentation de toutes les API est √©crite dans une autre DLL.  Ces DLL d'impl√©mentation peuvent √©galement diff√©rer entre les SKU.  Vous pouvez voir les ensembles d'API en action en ex√©cutant la travers√©e des d√©pendances sur une DLL Windows traditionnelle, par exemple, kernel32.dll. <br><br><div style="text-align:center;"><img src="https://gxcuf89792.i.lithium.com/t5/image/serverpage/image-id/55556i8BF228D9318A85CC/image-size/large?v=1.0&amp;px=999"></div><br>  Apr√®s avoir termin√© cette digression sur la structure de Windows, qui permet au syst√®me de maximiser la r√©utilisation et le partage de code, passons aux profondeurs techniques du d√©marrage du noyau selon le planificateur, qui est la cl√© pour faire √©voluer le syst√®me d'exploitation. <br><br><h2>  Composants du noyau </h2><br>  Windows NT est, en fait, un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">micro</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">noyau</a> , dans le sens o√π il poss√®de son propre noyau (KE) avec un ensemble limit√© de fonctions, utilisant la couche ex√©cutable (couche ex√©cutive, Ex) pour ex√©cuter toutes les strat√©gies de haut niveau.  EX est toujours en mode noyau, donc ce n'est pas exactement un micro-noyau.  Le noyau est responsable de la planification des threads, de la synchronisation entre les processeurs, de la gestion des exceptions au niveau mat√©riel et de l'impl√©mentation de fonctions d√©pendantes du mat√©riel de bas niveau.  La couche EX contient divers sous-syst√®mes qui fournissent un ensemble de fonctionnalit√©s qui est g√©n√©ralement consid√©r√© comme le noyau - IO, gestionnaire d'objets, gestionnaire de m√©moire, sous-syst√®me de processus, etc. <br><br><div style="text-align:center;"><img src="https://gxcuf89792.i.lithium.com/t5/image/serverpage/image-id/55558i85CBB1B2E72B3E88/image-size/large?v=1.0&amp;px=999"></div><br>  Pour mieux comprendre la taille des composants, voici une r√©partition approximative du nombre de lignes de code dans plusieurs r√©pertoires cl√©s de l'arborescence des sources du noyau (y compris les commentaires).  Le tableau n'a pas encore inclus beaucoup de tout ce qui concerne le noyau. <br><br><table><tbody><tr><th>  Sous-syst√®mes du noyau </th><th>  Lignes de code </th></tr><tr><td>  Gestionnaire de m√©moire </td><td>  501 000 </td></tr><tr><td>  Registre </td><td>  211 000 </td></tr><tr><td>  Puissance </td><td>  238 000 </td></tr><tr><td>  Ex√©cutif </td><td>  157 000 </td></tr><tr><td>  La s√©curit√© </td><td>  135 000 </td></tr><tr><td>  Noyau </td><td>  339 000 </td></tr><tr><td>  Sous-syst√®me de processus </td><td>  116 000 </td></tr></tbody></table><br>  Pour plus d'informations sur l'architecture Windows, consultez la s√©rie de livres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Windows Internals</a> . <br><br><h2>  Planificateur </h2><br>  Apr√®s avoir pr√©par√© le terrain de cette fa√ßon, parlons un peu du planificateur, de son √©volution et de la fa√ßon dont le noyau Windows peut √©voluer vers un tel nombre d'architectures diff√©rentes avec autant de processeurs. <br><br>  Un thread est une unit√© de base qui ex√©cute du code de programme, et c'est pr√©cis√©ment son travail que le planificateur Windows planifie.  Pour d√©cider quel thread d√©marrer, le planificateur utilise leurs priorit√©s et, en th√©orie, le thread avec la priorit√© la plus √©lev√©e devrait d√©marrer sur le syst√®me, m√™me si cela signifie qu'il ne restera plus de temps pour les threads avec des priorit√©s plus faibles. <br><br>  Ayant travaill√© le temps quantique (le temps minimum qu'un thread peut travailler), le thread subit une diminution de la priorit√© dynamique afin que les threads de haute priorit√© ne puissent pas fonctionner ind√©finiment, l'√¢me de tout le monde.  Lorsqu'un autre thread se r√©veille pour fonctionner, il re√ßoit la priorit√©, calcul√©e en fonction de l'importance de l'√©v√©nement qui a caus√© l'attente (par exemple, la priorit√© est consid√©rablement augment√©e pour l'interface utilisateur frontale, et pas beaucoup - pour terminer les op√©rations d'E / S).  Par cons√©quent, un thread fonctionne avec une priorit√© √©lev√©e tout en restant interactif.  Quand il devient principalement connect√© aux calculs (li√©s au CPU), sa priorit√© diminue et ils y reviennent apr√®s que d'autres threads avec une priorit√© √©lev√©e ont leur temps de processeur.  De plus, le noyau augmente arbitrairement la priorit√© des threads pr√™ts √† l'emploi qui n'ont pas re√ßu de temps processeur pendant une certaine p√©riode afin d'√©viter leur famine de calcul et de corriger l'inversion de priorit√©. <br><br>  Le planificateur Windows avait initialement une file d'attente de pr√©paration, √† partir de laquelle il a s√©lectionn√© le thread suivant, la plus prioritaire √† ex√©cuter.  Cependant, avec le d√©but de la prise en charge d'un nombre croissant de processeurs, la seule file d'attente s'est transform√©e en goulot d'√©tranglement et le planificateur a modifi√© le travail autour de la zone de publication de Windows Server 2003 et organis√© une file d'attente de disponibilit√© par processeur.  Lors du passage √† la prise en charge de plusieurs demandes pour un processeur, ils n'ont pas effectu√© un seul verrouillage global prot√©geant toutes les files d'attente et ont permis au planificateur de prendre des d√©cisions en fonction des optima locaux.  Cela signifie qu'√† tout moment dans le syst√®me, il existe un thread avec la priorit√© la plus √©lev√©e, mais cela ne signifie pas n√©cessairement que N des threads de la priorit√© la plus √©lev√©e (o√π N est le nombre de processeurs) fonctionne dans le syst√®me.  Cette approche a port√© ses fruits jusqu'√† ce que Windows commence √† passer √† des processeurs √† faible consommation tels que les ordinateurs portables et les tablettes.  Lorsque le thread avec les priorit√©s les plus √©lev√©es ne fonctionnait pas sur de tels syst√®mes (par exemple, le thread frontal de l'interface utilisateur), cela entra√Ænait des probl√®mes d'interface perceptibles.  Par cons√©quent, dans Windows 8.1, le planificateur a √©t√© transf√©r√© vers un mod√®le hybride, avec des files d'attente pour chaque processeur pour les threads associ√©s √† ce processeur, et une file d'attente partag√©e de processus pr√™ts √† l'emploi pour tous les processeurs.  Cela n'a pas affect√© les performances de mani√®re notable en raison d'autres modifications de l'architecture du planificateur, par exemple, la refactorisation d'un verrou de base de donn√©es de r√©partiteur. <br><br>  Windows 7 a introduit une telle chose comme un planificateur de partage √©quitable dynamique (Dynamic Fair Share Scheduler, DFSS);  cela concernait principalement les serveurs de terminaux.  Cette fonctionnalit√© a essay√© de r√©soudre le probl√®me qu'une session de terminal avec une charge CPU √©lev√©e pouvait affecter les threads dans d'autres sessions de terminal.  √âtant donn√© que le planificateur ne prenait pas en compte les sessions et utilisait simplement la priorit√© pour distribuer les flux, les utilisateurs des diff√©rentes sessions pouvaient influencer le travail des utilisateurs des autres sessions en √©tranglant leurs flux.  Cela donnait √©galement un avantage injuste aux sessions (et aux utilisateurs) avec un grand nombre de threads, car une session avec un grand nombre de threads avait plus d'occasions d'obtenir du temps processeur.  Une tentative a √©t√© faite pour ajouter une r√®gle au planificateur, selon laquelle chaque session √©tait consid√©r√©e sur un pied d'√©galit√© avec les autres en termes de temps processeur.  Des fonctionnalit√©s similaires existent sous Linux avec leur ordonnanceur compl√®tement honn√™te ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Completely Fair Scheduler</a> ).  Dans Windows 8, ce concept a √©t√© g√©n√©ralis√© en tant que groupe de planificateurs et ajout√© au planificateur, √† la suite de quoi chaque session est tomb√©e dans un groupe ind√©pendant.  En plus des priorit√©s pour les threads, le planificateur utilise les groupes du planificateur comme index de deuxi√®me niveau, en d√©cidant quel thread commencer ensuite.  Dans le serveur Terminal Server, tous les groupes de planificateurs ont le m√™me poids, de sorte que toutes les sessions re√ßoivent la m√™me quantit√© de temps processeur, quel que soit le nombre ou la priorit√© des threads au sein des groupes de planificateurs.  De plus, ces groupes sont √©galement utilis√©s pour un contr√¥le plus pr√©cis des processus.  Dans Windows 8, les objets Job ont √©t√© am√©lior√©s pour prendre en charge la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gestion du temps du processeur</a> .  √Ä l'aide d'une API sp√©ciale, vous pouvez d√©cider du temps processeur qu'un processus peut utiliser, qu'il s'agisse d'une limite souple ou stricte, et recevoir des notifications lorsque le processus atteint ces limites.  Ceci est similaire √† la gestion des ressources dans les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cgroups</a> sous Linux. <br><br>  √Ä partir de Windows 7, Windows Server a introduit la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">prise en charge de plus de 64 processeurs logiques</a> sur un seul ordinateur.  Pour ajouter un support √† autant de processeurs, une nouvelle cat√©gorie a √©t√© introduite dans le syst√®me, le ¬´groupe de processeurs¬ª.  Un groupe est un ensemble invariable de processeurs logiques ne d√©passant pas 64 √©l√©ments, qui sont consid√©r√©s par un ordonnanceur comme une unit√© informatique.  Le noyau au d√©marrage d√©termine quel processeur appartient √† quel groupe, et pour les machines avec moins de 64 c≈ìurs de processeur, cette approche est presque impossible √† remarquer.  Un processus peut √™tre divis√© en plusieurs groupes (par exemple, une instance de SQL Server), un seul thread √† la fois ne peut √™tre ex√©cut√© que dans le m√™me groupe. <br><br>  Mais sur les machines o√π le nombre de c≈ìurs de processeur d√©passe 64, Windows a commenc√© √† montrer de nouveaux goulots d'√©tranglement qui emp√™chaient les applications exigeantes telles que le serveur SQL d'√™tre mises √† l'√©chelle lin√©airement avec le nombre croissant de c≈ìurs de processeur.  Par cons√©quent, m√™me avec l'ajout de nouveaux c≈ìurs et de m√©moire, les mesures de vitesse n'ont pas montr√© d'augmentation significative.  L'un des principaux probl√®mes associ√©s √† cette situation √©tait le diff√©rend concernant le blocage de la base des r√©partiteurs.  Le verrouillage de la base de donn√©es du r√©partiteur prot√©geait l'acc√®s aux objets dont le travail devait √™tre planifi√©.  Parmi ces objets figurent des threads, des temporisateurs, des ports d'entr√©e / sortie, d'autres objets du noyau qui sont sujets √† attente (√©v√©nements, s√©maphores, mutex).  Sous la pression de la n√©cessit√© de r√©soudre ces probl√®mes, un travail a √©t√© effectu√© dans Windows 7 pour √©liminer le blocage de la base de donn√©es du r√©partiteur et le remplacer par des ajustements plus pr√©cis, tels que le verrouillage objet par bloc.  Cela a permis √† des mesures de performances telles que SQL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TPC-C</a> de d√©montrer une augmentation de 290% de la vitesse par rapport au sch√©ma pr√©c√©dent sur certaines configurations.  Il s'agit de l'une des plus grandes augmentations de performances de l'histoire de Windows qui s'est produite en raison d'un changement dans une seule fonctionnalit√©. <br><br>  Windows 10 a apport√© une autre innovation en introduisant des ensembles de processeurs.  Les ensembles d'UC permettent √† un processus de partitionner un syst√®me afin qu'un processus puisse √™tre r√©parti sur plusieurs groupes de processeurs, emp√™chant d'autres processus de les utiliser.  Le noyau Windows ne permet m√™me pas aux interruptions de p√©riph√©rique d'utiliser les processeurs inclus dans votre ensemble.  Cela garantit que m√™me les appareils ne peuvent pas ex√©cuter leur code sur les processeurs √©mis pour le groupe de votre application.  Cela ressemble √† une machine virtuelle low-tech.  Il est clair que c'est une fonctionnalit√© puissante, de nombreuses mesures de s√©curit√© y sont int√©gr√©es afin que le d√©veloppeur de l'application ne fasse pas de grosses erreurs lorsqu'il travaille avec l'API.  La fonctionnalit√© des jeux de CPU est utilis√©e en mode jeu. <br><br>  Enfin, nous arrivons √† la prise en charge d'ARM64, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qui est apparu dans Windows 10</a> .  L'architecture ARM prend en charge l'architecture <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">big.LITTLE</a> , qui est de nature h√©t√©rog√®ne - le ¬´grand¬ª c≈ìur est rapide et consomme beaucoup d'√©nergie, et le ¬´petit¬ª c≈ìur est lent et consomme moins.  L'id√©e est que des t√¢ches insignifiantes peuvent √™tre effectu√©es sur un petit noyau, √©conomisant ainsi la batterie.  Pour prendre en charge l'architecture big.LITTLE et augmenter la dur√©e de vie de la batterie lors de l'ex√©cution de Windows 10 sur ARM, une prise en charge de mise en page h√©t√©rog√®ne a √©t√© ajout√©e au planificateur, en tenant compte des souhaits d'une application travaillant avec l'architecture big.LITTLE. <br><br>  Par souhaits, je veux dire que Windows essaie de fournir un service de qualit√© pour les applications, de suivre les threads qui s'ex√©cutent au premier plan (ou ceux qui manquent de temps processeur), et de garantir leur ex√©cution sur le "gros" c≈ìur.  Toutes les t√¢ches, services et autres threads auxiliaires en arri√®re-plan s'ex√©cutent sur de petits c≈ìurs.  Dans le programme, vous pouvez √©galement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">noter de force la</a> faible importance du thread afin de le faire fonctionner sur le petit noyau. <br><br>  Travailler pour le compte de quelqu'un d'autre [Travailler pour le compte]: dans Windows, beaucoup de travail au premier plan est effectu√© par d'autres services qui travaillent en arri√®re-plan.  Par exemple, lors d'une recherche dans Outlook, la recherche elle-m√™me est effectu√©e par le service d'arri√®re-plan Indexer.  Si nous ex√©cutons tous les services sur un petit noyau, la qualit√© et la vitesse des applications au premier plan en souffriront.  Pour l'emp√™cher de ralentir sur les architectures big.LITTLE dans de tels sc√©narios de travail, Windows surveille les appels d'application arrivant vers d'autres processus afin d'effectuer des travaux en leur nom.  Dans ce cas, nous donnons la priorit√© au premier plan au thread li√© au service et le for√ßons √† s'ex√©cuter sur le gros noyau. <br><br>  Permettez-moi de terminer ce premier article sur le noyau Windows, qui donne un aper√ßu du planificateur.  Des articles avec des d√©tails techniques similaires sur le fonctionnement interne de l'OS suivront plus tard. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428469/">https://habr.com/ru/post/fr428469/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428453/index.html">Comment les programmeurs ont sauv√© leur patrie</a></li>
<li><a href="../fr428457/index.html">Contournement des labels: SoundCloud a lanc√© des accords directs avec des musiciens - conditions critiqu√©es</a></li>
<li><a href="../fr428461/index.html">Construire un r√©seau VPN distribu√© bas√© sur Check Point. Plusieurs sc√©narios courants</a></li>
<li><a href="../fr428465/index.html">Guide d'analyse d'impact sur l'entreprise</a></li>
<li><a href="../fr428467/index.html">Tout est sous contr√¥le. Pourquoi avons-nous besoin de syst√®mes de surveillance pour l'infrastructure d'ing√©nierie des centres de donn√©es</a></li>
<li><a href="../fr428471/index.html">La loi sur le droit d'auteur vient de s'am√©liorer dans l'histoire du jeu vid√©o</a></li>
<li><a href="../fr428475/index.html">Comment les designers se trompent</a></li>
<li><a href="../fr428477/index.html">Pour ceux qui choisissent un pare-feu</a></li>
<li><a href="../fr428481/index.html">Contrats num√©riques: un guide rapide pour PAS les avocats</a></li>
<li><a href="../fr428485/index.html">La plupart des gens ennuyeux sont la publicit√© non pertinente et l'utilisation de gadgets en public</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>