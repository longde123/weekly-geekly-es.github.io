<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ü üë∏ üõÖ C√≥mo funciona JS: tecnolog√≠a Shadow DOM y componentes web üëáüèø üöµüèº üõ£Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Recomendar lectura] Las otras 19 partes del ciclo  Parte 1: Descripci√≥n general del motor, mecanismos de tiempo de ejecuci√≥n, pila de llamadas 
 Part...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo funciona JS: tecnolog√≠a Shadow DOM y componentes web</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/415881/"><div class="spoiler">  <b class="spoiler_title">[Recomendar lectura] Las otras 19 partes del ciclo</b> <div class="spoiler_text">  Parte 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Descripci√≥n general del motor, mecanismos de tiempo de ejecuci√≥n, pila de llamadas</a> <br>  Parte 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Acerca de los componentes internos V8 y la optimizaci√≥n del c√≥digo</a> <br>  Parte 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">administrar la memoria, cuatro tipos de p√©rdidas de memoria y tratar con ellas</a> <br>  Parte 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bucle de eventos, as√≠ncrono y cinco formas de mejorar su c√≥digo con as√≠ncrono / espera</a> <br>  Parte 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WebSocket y HTTP / 2 + SSE.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Que elegir</a> <br>  Parte 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Caracter√≠sticas y alcance de WebAssembly</a> <br>  Parte 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trabajadores web y cinco escenarios de uso</a> <br>  Parte 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trabajadores de servicio</a> <br>  Parte 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">notificaciones push web</a> <br>  Parte 10: realizar un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">seguimiento de los cambios en el DOM con MutationObserver</a> <br>  Parte 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">motores de representaci√≥n de p√°ginas web y consejos para optimizar su rendimiento</a> <br>  Parte 12: El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">subsistema de red de los navegadores, optimizando su rendimiento y seguridad.</a> <br>  Parte 12: El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">subsistema de red de los navegadores, optimizando su rendimiento y seguridad.</a> <br>  Parte 13: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Animaci√≥n con CSS y JavaScript.</a> <br>  Parte 14: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: √°rboles de sintaxis abstracta, an√°lisis y su optimizaci√≥n</a> <br>  Parte 15: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: clases y herencia, transpilaci√≥n en Babel y TypeScript</a> <br>  Parte 16: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: almacenamiento</a> <br>  Parte 17: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: tecnolog√≠a Shadow DOM y componentes web</a> <br>  Parte 18: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: Mecanismos de comunicaci√≥n WebRTC y P2P</a> <br>  Parte 19: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: Elementos personalizados</a> </div></div><br>  Hoy, en la traducci√≥n de 17 partes de los materiales dedicados a las caracter√≠sticas de todo lo que de alguna manera est√° conectado con JavaScript, hablaremos sobre componentes web y varios est√°ndares que est√°n destinados a trabajar con ellos.  Se prestar√° especial atenci√≥n a la tecnolog√≠a Shadow DOM. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/8k/li/z5/8kliz5q5jcynt6ggr2rqa-fancc.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Revisar</font> </h2><br>  Los componentes web son una familia de API dise√±adas para describir nuevos elementos DOM adecuados para su reutilizaci√≥n.  La funcionalidad de dichos elementos est√° separada del resto del c√≥digo; se pueden usar en aplicaciones web de nuestro propio dise√±o. <br><br>  Existen cuatro tecnolog√≠as relacionadas con los componentes web: <br><br><ul><li>  Shadow DOM (Shadow DOM) </li><li>  Plantillas HTML (Plantillas HTML) </li><li>  Elementos personalizados </li><li>  Importaciones HTML (Importaci√≥n HTML) </li></ul><br>  En este art√≠culo, hablaremos sobre la tecnolog√≠a Shadow DOM, que est√° dise√±ada para crear aplicaciones basadas en componentes.  Ofrece formas de resolver problemas comunes de desarrollo web que quiz√°s ya haya encontrado: <br><br><ul><li> Aislamiento DOM: el componente tiene un √°rbol DOM aislado (esto significa que el comando <code>document.querySelector()</code> no permitir√° el acceso al nodo en el DOM sombra del componente).  Adem√°s, simplifica el sistema selector CSS en aplicaciones web, ya que los componentes DOM est√°n aislados, lo que permite al desarrollador usar los mismos identificadores universales y nombres de clase en diferentes componentes sin preocuparse por posibles conflictos de nombres. </li><li>  Aislamiento CSS: las reglas CSS descritas dentro del shadow DOM est√°n limitadas a √©l.  Estos estilos no abandonan el elemento, no se mezclan con otros estilos de p√°gina. </li><li>  Composici√≥n: Desarrollo de una API declarativa para componentes basados ‚Äã‚Äãen marcado. </li></ul><br><h2>  <font color="#3AC1EF">Tecnolog√≠a Shadow DOM</font> </h2><br>  Se supone que ya est√° familiarizado con el concepto de DOM y las API asociadas.  Si esto no es as√≠, puede leer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> material. <br><br>  Shadow DOM es b√°sicamente lo mismo que un DOM normal, pero con dos diferencias: <br><br><ul><li>  El primero es c√≥mo se crea y se usa el Shadow DOM, en particular, se trata de la relaci√≥n del Shadow DOM con el resto de la p√°gina. </li><li>  El segundo es el comportamiento del Shadow DOM en relaci√≥n con la p√°gina. </li></ul><br>  Cuando se trabaja con DOM, se crean nodos DOM que se unen, como elementos secundarios, a otros elementos de la p√°gina.  En el caso de la tecnolog√≠a Shadow DOM, se crea un √°rbol DOM aislado que une el elemento, pero est√° separado de sus elementos secundarios normales. <br><br>  Este sub√°rbol aislado se llama √°rbol de sombra.  El elemento al que se adjunta dicho √°rbol se llama host host.  Todo lo que se agrega al sub√°rbol DOM de la sombra resulta ser local para el elemento al que est√° adjunto, incluidos los estilos descritos con etiquetas <code>&lt;style&gt;</code> .  As√≠ es como se proporciona el aislamiento CSS a trav√©s de la tecnolog√≠a Shadow DOM. <br><br><h2>  <font color="#3AC1EF">Crear un DOM de sombra</font> </h2><br>  Shadow root es una parte del documento que se adjunta al elemento host.  Un elemento adquiere un DOM de sombra cuando se le adjunta un elemento ra√≠z de sombra.  Para crear un DOM de sombra para un determinado elemento, debe usar un comando del formulario <code>element.attachShadow()</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> header = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'header'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shadowRoot = header.attachShadow({<span class="hljs-attr"><span class="hljs-attr">mode</span></span>: <span class="hljs-string"><span class="hljs-string">'open'</span></span>}); shadowRoot.appendChild(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'&lt;p&gt; Shadow DOM &lt;/p&gt;'</span></span>);</code> </pre> <br>  Cabe se√±alar que en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la especificaci√≥n de</a> DOM de sombra hay una lista de elementos a los que no se pueden conectar los sub√°rboles de sombra de DOM. <br><br><h2>  <font color="#3AC1EF">Composici√≥n en Shadow DOM</font> </h2><br>  La composici√≥n es una de las caracter√≠sticas m√°s importantes de Shadow DOM, es una forma de crear aplicaciones web, que se utiliza en el proceso de escritura de c√≥digo HTML.  Durante este proceso, el programador combina los diversos bloques de construcci√≥n (elementos) que conforman la p√°gina, anid√°ndolos, si es necesario, entre s√≠.  Por ejemplo, estos son elementos como <code>&lt;div&gt;</code> , <code>&lt;header&gt;</code> , <code>&lt;form&gt;</code> y otros utilizados para crear interfaces de aplicaciones web, incluidos aquellos que act√∫an como contenedores para otros elementos. <br><br>  La composici√≥n determina la capacidad de los elementos, como <code>&lt;select&gt;</code> , <code>&lt;form&gt;</code> , <code>&lt;video&gt;</code> , para incluir otros elementos HTML como elementos secundarios, y la capacidad de organizar comportamientos especiales de tales estructuras que consisten en diferentes elementos. <br><br>  Por ejemplo, el elemento <code>&lt;select&gt;</code> tiene medios para representar elementos <code>&lt;option&gt;</code> en forma de una lista desplegable con el contenido predeterminado de los elementos de dicha lista. <br><br>  Considere algunas de las caracter√≠sticas del Shadow DOM que se usa en la composici√≥n de elementos. <br><br><h2>  <font color="#3AC1EF">Dom ligero</font> </h2><br>  Light DOM es el marcado creado por el usuario de su componente.  Este DOM est√° fuera del DOM oculto del componente y es un hijo del componente.  Imagine que cre√≥ un componente personalizado llamado <code>&lt;better-button&gt;</code> que ampl√≠a las capacidades del elemento HTML est√°ndar <code>&lt;button&gt;</code> , y el usuario necesita agregar una imagen y algo de texto a este nuevo elemento.  As√≠ es como se ve: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">extended-button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--  img  span -  Light DOM  extended-button --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">align</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"center"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"boot.png"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"image"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span>Launch<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">extended-button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  El elemento <code>&lt;extended-button&gt;</code> es un componente personalizado descrito por el programador por s√≠ mismo, y el c√≥digo HTML dentro de este componente es su Light DOM, lo que el usuario de este componente le agreg√≥. <br><br>  La sombra DOM en este ejemplo es el componente <code>&lt;extended-button&gt;</code> .  Este es un modelo de objeto local de un componente que describe su estructura interna, aislada del mundo exterior de CSS, y encapsula los detalles de implementaci√≥n del componente. <br><br><h2>  <font color="#3AC1EF">Dom aplanado</font> </h2><br>  El √°rbol de DOM aplanado representa c√≥mo el navegador muestra el componente en la pantalla, combinando el DOM de luz y el DOM de sombra.  Es un √°rbol DOM que se puede ver en las herramientas del desarrollador, y es el que se muestra en la p√°gina.  Puede verse m√°s o menos as√≠: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">extended-button</span></span></span><span class="hljs-tag">&gt;</span></span> #shadow-root <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"><span class="undefined">‚Ä¶</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"image"</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">align</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"center"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"boot.png"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"image"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"container"</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span>     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span>Launch<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">extended-button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Patrones</font> </h2><br>  Si tiene que usar constantemente las mismas estructuras en el marcado HTML de las p√°ginas web, ser√° √∫til usar una plantilla determinada en lugar de escribir el mismo c√≥digo una y otra vez.  Esto era posible antes, pero ahora todo se ha simplificado enormemente gracias a la aparici√≥n de la etiqueta HTML <code>&lt;template&gt;</code> , que goza de un excelente soporte para los navegadores modernos.  Este elemento y su contenido no se muestran en el DOM, pero puede trabajar con √©l desde JavaScript.  Considere un ejemplo simple: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-paragraph"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> Paragraph content. <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Si incluye este dise√±o en el marcado HTML de la p√°gina, el contenido de la etiqueta <code>&lt;p&gt;</code> descrita por √©l no aparecer√° en la pantalla hasta que se adjunte expl√≠citamente al DOM del documento.  Por ejemplo, podr√≠a verse as√≠: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> template = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'my-paragraph'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> templateContent = template.content; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.appendChild(templateContent);</code> </pre> <br>  Hay otros medios para lograr el mismo efecto, pero, como ya se mencion√≥, las plantillas son una herramienta est√°ndar muy conveniente que goza de un buen soporte para el navegador. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5dc/501/54c/5dc50154ca3bc462d1e9285334fe462e.png"></div><br>  <i><font color="#999999">Soporte de navegador HTML para navegadores modernos</font></i> <br><br>  Las plantillas son √∫tiles en s√≠ mismas, pero sus capacidades se revelan completamente cuando se usan con elementos personalizados.  Los elementos personalizados son un tema para un material separado, y ahora, para comprender lo que est√° sucediendo, es suficiente tener en cuenta que la <code>customElement</code> navegadores <code>customElement</code> permite al programador describir sus propias etiquetas HTML y especificar c√≥mo se ver√°n en la pantalla los elementos creados con estas etiquetas. <br><br>  Defina un componente web que use nuestra plantilla como contenido para su DOM sombra.  Llame a este nuevo elemento <code>&lt;my-paragraph&gt;</code> : <br><br><pre> <code class="hljs scala">customElements.define(<span class="hljs-symbol"><span class="hljs-symbol">'my</span></span>-paragraph', <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{  constructor() {    <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();    let template = document.getElementById(<span class="hljs-symbol"><span class="hljs-symbol">'my</span></span>-paragraph');    let templateContent = template.content;    const shadowRoot = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.attachShadow({mode: <span class="hljs-symbol"><span class="hljs-symbol">'ope</span></span>n'}).appendChild(templateContent.cloneNode(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)); } });</code> </pre> <br>  Lo m√°s importante a lo que debe prestar atenci√≥n es que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">adjuntamos</a> un clon del contenido de la plantilla utilizando el m√©todo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Node.cloneNode ()</a> a la ra√≠z de la sombra. <br><br>  Dado que adjuntamos el contenido de la plantilla al DOM de sombra, podemos incluir informaci√≥n de estilo en la plantilla en el elemento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">&lt;style&gt;</a> , que luego se encapsular√° en el elemento de usuario.  Todo este esquema no funcionar√° como se esperaba si trabaja con el DOM regular en lugar del DOM de la sombra. <br><br>  Por ejemplo, una plantilla se puede modificar de la siguiente manera al incluir informaci√≥n de estilo en ella: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-paragraph"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="css"><span class="css">   </span><span class="hljs-selector-tag"><span class="css"><span class="hljs-selector-tag">p</span></span></span><span class="css"> {     </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">color</span></span></span><span class="css">: white;     </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">background-color</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">#666</span></span></span><span class="css">;     </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">padding</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">5px</span></span></span><span class="css">;   } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Paragraph content. <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Ahora el elemento de usuario descrito por nosotros se puede usar en las p√°ginas web normales de la siguiente manera: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Tragamonedas</font> </h2><br>  Las plantillas HTML tienen varios inconvenientes, el principal es que las plantillas contienen marcado est√°tico, que no permite, por ejemplo, mostrar el contenido de ciertas variables con su ayuda para trabajar con ellas de la misma manera que funcionan con HTML est√°ndar patrones  Aqu√≠ es donde entra la etiqueta <code>&lt;slot&gt;</code> . <br><br>  Las ranuras se pueden percibir como marcadores de posici√≥n que le permiten incluir su propio c√≥digo HTML en la plantilla.  Esto le permite crear plantillas HTML universales y luego personalizarlas agregando ranuras a ellas. <br><br>  Eche un vistazo a c√≥mo se ver√° la plantilla anterior usando la <code>&lt;slot&gt;</code> : <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-paragraph"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-text"</span></span></span><span class="hljs-tag">&gt;</span></span>Default text<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Si el contenido de la ranura no se especifica cuando el elemento se incluye en el marcado, o si el navegador no admite trabajar con ranuras, el elemento <code>&lt;my-paragraph&gt;</code> incluir√° solo el contenido est√°ndar del <code>Default text</code> . <br><br>  Para establecer el contenido del espacio, debe incluir el c√≥digo HTML con el atributo de <code>slot</code> en el elemento <code>&lt;my-paragraph&gt;</code> , cuyo valor es equivalente al nombre del espacio en el que desea colocar este c√≥digo. <br><br>  Como antes, puede haber cualquier cosa.  Por ejemplo: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-text"</span></span></span><span class="hljs-tag">&gt;</span></span>Let's have some different text!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Los elementos que se pueden colocar en las ranuras se denominan elementos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">deslizables</a> . <br><br>  Tenga en cuenta que en el ejemplo anterior agregamos el elemento <code>&lt;span&gt;</code> a la ranura, es el llamado elemento ranurado.  Tiene un atributo de <code>slot</code> que se le asigna el valor <code>my-text</code> , es decir, el mismo valor que se usa en el atributo de <code>name</code> de la ranura descrita en la plantilla. <br><br>  Despu√©s de procesar el marcado anterior, el navegador crear√° el siguiente √°rbol DOM aplanado: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span> #shadow-root <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-text"</span></span></span><span class="hljs-tag">&gt;</span></span>     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-text"</span></span></span><span class="hljs-tag">&gt;</span></span>Let's have some different text!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Presta atenci√≥n al elemento <code>#shadow-root</code> .  Esto es solo un indicador de la existencia del Shadow DOM. <br><br><h2>  <font color="#3AC1EF">Estilizaci√≥n</font> </h2><br>  Los componentes que usan la tecnolog√≠a Shadow DOM se pueden dise√±ar de forma com√∫n, pueden definir sus propios estilos o proporcionar ganchos en forma de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">propiedades CSS personalizadas</a> que permiten a los usuarios de componentes anular los estilos predeterminados. <br><br><h3>  <font color="#3AC1EF">‚ñç Estilos descritos en componentes</font> </h3><br>  El aislamiento CSS es una de las caracter√≠sticas m√°s notables de la tecnolog√≠a Shadow DOM.  A saber, estamos hablando de lo siguiente: <br><br><ul><li>  Los selectores CSS de la p√°gina en la que se coloca el componente correspondiente no afectan lo que tiene dentro. </li><li>  Los estilos descritos dentro del componente no afectan la p√°gina.  Est√°n aislados en el elemento host. </li></ul><br>  Los selectores CSS utilizados dentro del shadow DOM se aplican localmente al contenido del componente.  En la pr√°ctica, esto significa la capacidad de reutilizar los mismos identificadores y nombres de clase en diferentes componentes y no hay que preocuparse por los conflictos de nombres.  Los selectores CSS simples tambi√©n significan un mejor rendimiento para las soluciones en las que se utilizan. <br><br>  Eche un vistazo al elemento <code>#shadow-root</code> , que define algunos estilos: <br><br><pre> <code class="hljs xml">#shadow-root <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="css"><span class="css"> </span><span class="hljs-selector-id"><span class="css"><span class="hljs-selector-id">#container</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">background</span></span></span><span class="css">: white; } </span><span class="hljs-selector-id"><span class="css"><span class="hljs-selector-id">#container-items</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">display</span></span></span><span class="css">: inline-flex; } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"container"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"container-items"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Todos los estilos anteriores son locales para <code>#shadow-root</code> . <br><br>  Adem√°s, puede usar la etiqueta <code>&lt;link&gt;</code> para incluir hojas de estilo externas en <code>#shadow-root</code> .  Dichos estilos tambi√©n ser√°n locales. <br><br><h3>  <font color="#3AC1EF">‚ñçPseudoclase: host</font> </h3><br>  La pseudoclase <code>:host</code> permite acceder a un elemento que contiene un √°rbol DOM de sombra y darle estilo a este elemento: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="css"><span class="css"> </span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:host</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">display</span></span></span><span class="css">: block; </span><span class="hljs-comment"><span class="css"><span class="hljs-comment">/*       display: inline */</span></span></span><span class="css"> } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Con la pseudoclase <code>:host</code> , recuerde que las reglas de la p√°gina principal tienen mayor prioridad que las especificadas en el elemento que utiliza esta pseudoclase.  Esto permite a los usuarios anular los estilos de componentes del host definidos desde afuera.  Adem√°s, la pseudoclase <code>:host</code> solo funciona en el contexto del elemento ra√≠z sombra; no puede usarlo fuera del √°rbol DOM sombra. <br><br>  La forma funcional de la pseudoclase ,: <code>:host(&lt;selector&gt;)</code> , le permite acceder al elemento host si coincide con el elemento <code>&lt;selector&gt;</code> especificado.  Esta es una excelente manera de permitir que los componentes encapsulen el comportamiento que responde a las acciones del usuario o los cambios en el estado de un componente, y le permite dise√±ar nodos internos basados ‚Äã‚Äãen el componente host: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="css"><span class="css"> </span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:host</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">opacity</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">0.4</span></span></span><span class="css">; } </span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:host(</span></span></span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:hover)</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">opacity</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">1</span></span></span><span class="css">; } </span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:host(</span></span></span><span class="hljs-selector-attr"><span class="css"><span class="hljs-selector-attr">[disabled]</span></span></span><span class="css">) { </span><span class="hljs-comment"><span class="css"><span class="hljs-comment">/*      -  disabled. */</span></span></span><span class="css">   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">background</span></span></span><span class="css">: grey;   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">pointer-events</span></span></span><span class="css">: none;   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">opacity</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">0.4</span></span></span><span class="css">; } </span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:host(.pink)</span></span></span><span class="css"> &gt; </span><span class="hljs-selector-id"><span class="css"><span class="hljs-selector-id">#tabs</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">color</span></span></span><span class="css">: pink; </span><span class="hljs-comment"><span class="css"><span class="hljs-comment">/*     #tabs   -  class="pink". */</span></span></span><span class="css"> } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçT√≥picos y elementos con una pseudoclase: host-context (&lt;selector&gt;)</font> </h3><br>  La pseudo- <code>:host-context(&lt;selector&gt;)</code> coincide con el elemento host si √©ste o alguno de sus antepasados ‚Äã‚Äãcoincide con el elemento <code>&lt;selector&gt;</code> especificado. <br><br>  Un caso de uso com√∫n para esta caracter√≠stica es dise√±ar elementos con temas.  Por ejemplo, los temas se usan a menudo asignando la clase apropiada a las etiquetas <code>&lt;html&gt;</code> o <code>&lt;body&gt;</code> : <br><br><pre> <code class="hljs javascript">&lt;body <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"lightheme"</span></span>&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">custom-container</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ‚Ä¶ </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">custom-container</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">body</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  La <code>:host-context(.lightheme)</code> se aplicar√° a <code>&lt;fancy-tabs&gt;</code> si este elemento es un descendiente de <code>.lightteme</code> : <br><br><pre> <code class="hljs css"><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:host-context(.lightheme)</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: black; <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: white; }</code> </pre> <br>  La construcci√≥n <code>:host-context()</code> puede ser √∫til para aplicar temas, pero para este prop√≥sito es mejor usar ganchos usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">propiedades CSS personalizadas</a> . <br><br><h3>  <font color="#3AC1EF">‚ñç Dise√±ar el elemento host del componente desde el exterior</font> </h3><br>  El elemento host del componente se puede dise√±ar externamente utilizando el nombre de su etiqueta como selector: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">custom-container</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; }</code> </pre> <br>  Los estilos externos tienen prioridad sobre los estilos definidos en la sombra DOM. <br>  Supongamos que un usuario crea el siguiente selector: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">custom-container</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">500px</span></span>; }</code> </pre> <br>  Anular√° la regla definida en el componente mismo: <br><br><pre> <code class="hljs css"><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:host</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">300px</span></span>; }</code> </pre> <br>  Con este enfoque, puede estilizar solo el componente en s√≠.  ¬øC√≥mo estilizar la estructura interna de un componente?  Se utilizan propiedades CSS personalizadas para este prop√≥sito. <br><br><h3>  <font color="#3AC1EF">‚ñçCreando ganchos de estilo usando propiedades CSS personalizadas</font> </h3><br>  Los usuarios pueden personalizar los estilos de las estructuras internas de los componentes si el autor del componente les proporciona enlaces de estilo utilizando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">propiedades CSS personalizadas</a> . <br><br>  Este enfoque se basa en un mecanismo similar al utilizado cuando se trabaja con etiquetas <code>&lt;slot&gt;</code> , pero, en este caso, se aplica a los estilos. <br><br>  Considere un ejemplo: <br><br><pre> <code class="hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- main page --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"><span class="undefined"> custom-container {   margin-bottom: 60px;    - custom-container-bg: black; } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">custom-container</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">background</span></span></span><span class="hljs-tag">&gt;</span></span>‚Ä¶<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">custom-container</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Esto es lo que hay dentro del √°rbol DOM de sombra: <br><br><pre> <code class="hljs css"><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:host(</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[background]</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">var</span></span>( - custom-container-bg, #CECECE); <span class="hljs-attribute"><span class="hljs-attribute">border-radius</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">padding</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; }</code> </pre> <br>  En este caso, el componente utiliza negro como color de fondo, ya que fue el usuario quien lo especific√≥.  De lo contrario, el color de fondo ser√° <code>#CECECE</code> . <br><br>  Como autor del componente, usted es responsable de informar a sus usuarios qu√© propiedades CSS espec√≠ficas pueden usar.  Considere esta parte de la interfaz abierta de su componente. <br><br><h2>  <font color="#3AC1EF">API de JavaScript para trabajar con slots</font> </h2><br>  La API Shadow DOM proporciona la capacidad de trabajar con slots. <br><br><h3>  <font color="#3AC1EF">‚ñç Cambio de ranura de evento</font> </h3><br>  El evento de cambio de ranura se <code>slotchange</code> cuando cambian los nodos ubicados en la ranura.  Por ejemplo, si un usuario agrega o elimina nodos secundarios en Light DOM: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> slot = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shadowRoot.querySelector(<span class="hljs-string"><span class="hljs-string">'#some_slot'</span></span>); slot.addEventListener(<span class="hljs-string"><span class="hljs-string">'slotchange'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Light DOM change'</span></span>); });</code> </pre> <br>  Para rastrear otros tipos de cambios en Light DOM, puede usar <code>MutationObserver</code> en el constructor del elemento.  Lea m√°s sobre esto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br><h3>  <font color="#3AC1EF">‚ñç M√©todo asignadoNodos ()</font> </h3><br>  El m√©todo <code>assignedNodes()</code> puede ser √∫til si necesita saber qu√© elementos est√°n asociados con la ranura.  Llamar al m√©todo <code>slot.assignedNodes()</code> permite averiguar exactamente qu√© elementos muestra la ranura.  El uso de la opci√≥n <code>{flatten: true}</code> permite obtener el contenido est√°ndar de la ranura (que se muestra si no se le asignaron nodos). <br><br>  Considere un ejemplo: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'slot1'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Default content<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Imagine que esta ranura se encuentra en el componente <code>&lt;my-container&gt;</code> . <br><br>  Echemos un vistazo a los diversos usos de este componente y lo que se devolver√° cuando se llame al m√©todo <code>assignedNodes()</code> . <br><br>  En el primer caso, agregamos nuestro propio contenido a la ranura: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-container</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"slot1"</span></span></span><span class="hljs-tag">&gt;</span></span> container text <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-container</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  En este caso, la llamada <code>assignedNodes()</code> devolver√° <code>[ container text ]</code> .  Tenga en cuenta que este valor es una matriz de nodos. <br><br>  En el segundo caso, no llenamos el espacio con nuestro propio contenido: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-container</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-container</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  La llamada <code>assignedNodes()</code> devolver√° una matriz vac√≠a - <code>[]</code> . <br><br>  Sin embargo, si pasa el par√°metro <code>{flatten: true}</code> a este m√©todo, entonces llamarlo para el mismo elemento devolver√° su contenido predeterminado: <code>[ Default content ]</code> <p> <code>[ Default content ]</code> </p>  <code>[ Default content ]</code> <br><br>  Adem√°s, para acceder a un elemento dentro de la ranura, puede llamar a <code>assignedNodes()</code> para informarle a qu√© ranura de componente est√° asignado su elemento. <br><br><h2>  <font color="#3AC1EF">Modelo de evento</font> </h2><br>  Hablemos de lo que sucede cuando aparece un evento que aparece en la sombra del √°rbol DOM.  El prop√≥sito del evento se establece teniendo en cuenta la encapsulaci√≥n admitida por la tecnolog√≠a Shadow DOM.  Cuando se redirige un evento, parece que proviene del componente en s√≠ y no de su elemento interno, que se encuentra en el √°rbol DOM de la sombra y es parte de este componente. <br><br>  Aqu√≠ hay una lista de eventos que se pasan del √°rbol de sombra DOM (este comportamiento no es caracter√≠stico de algunos eventos): <br><br><ul><li>  Eventos de enfoque: <code>blur</code> , <code>focus</code> , <code>focusin</code> , <code>focusout</code> . </li><li>  Eventos del mouse s: <code>click</code> , <code>dblclick</code> , <code>mousedown</code> , <code>mouseenter</code> , <code>mousemove</code> y otros. </li><li>  Eventos de <code>wheel</code> : <code>wheel</code> . </li><li>  Eventos de entrada: <code>beforeinput</code> <code>input</code> , <code>input</code> . </li><li>  Eventos de teclado: <code>keydown</code> , <code>keyup</code> . </li><li>  Eventos de <code>compositionstart</code> : inicio de <code>compositionstart</code> , <code>compositionupdate</code> <code>compositionstart</code> , <code>compositionupdate</code> <code>compositionend</code> . </li><li>  Eventos de arrastre: <code>dragstart</code> , <code>drag</code> , <code>dragend</code> , <code>drop</code> , etc. </li></ul><br><h2>  <font color="#3AC1EF">Eventos personalizados</font> </h2><br>  Los eventos de usuario de forma predeterminada no dejan el √°rbol de sombra DOM.  Si desea desencadenar un evento y desea que abandone el DOM DOM, debe proporcionarle las <code>bubbles: true</code> par√°metros <code>bubbles: true</code> y <code>composed: true</code> .  As√≠ es como se ve la llamada de tal evento: <br><br><pre> <code class="hljs axapta">var <span class="hljs-keyword"><span class="hljs-keyword">container</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shadowRoot.querySelector(<span class="hljs-string"><span class="hljs-string">'#container'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">container</span></span>.dispatchEvent(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">'containerchanged'</span></span>, {bubbles: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, composed: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>}));</code> </pre> <br><h2>  <font color="#3AC1EF">Soporte para navegadores Shadow DOM</font> </h2><br>  Para saber si el navegador admite la tecnolog√≠a Shadow DOM, puede verificar la presencia de <code>attachShadow</code> : <br><br><pre> <code class="hljs erlang-repl">const supportsShadowDOMV1 = !!HTMLElement.prototype.attachShadow;</code> </pre> <br>  Aqu√≠ hay informaci√≥n sobre c√≥mo varios navegadores admiten esta tecnolog√≠a. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bea/d78/c47/bead78c47c464b5059576df077613803.png"></div><br>  <i><font color="#999999">Soporte para la tecnolog√≠a Shadow DOM en navegadores</font></i> <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  El √°rbol DOM de sombra no se comporta como un √°rbol DOM normal.  En particular, seg√∫n el autor de este material, en la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SessionStack</a> esto se expresa en la complicaci√≥n del procedimiento para rastrear los cambios DOM, informaci√≥n sobre la cual se necesita para reproducir lo que sucedi√≥ con la p√°gina.  A saber, <code>MutationObserver</code> usa para rastrear cambios.  En este caso, el √°rbol de sombra DOM no genera el evento <code>MutationObserver</code> en el √°mbito global, lo que lleva a la necesidad de utilizar enfoques especiales para trabajar con componentes que usan el DOM sombra. <br><br>  ,     -  Shadow DOM,     ,   , ,     . <br><br>  <b>Estimados lectores!</b>    -,     Shadow DOM? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es415881/">https://habr.com/ru/post/es415881/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es415865/index.html">Markdown base de conocimiento (o blog, o documentaci√≥n del proyecto)</a></li>
<li><a href="../es415867/index.html">Y Combinator Investor School: Ron Conway</a></li>
<li><a href="../es415871/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 321 (25 de junio - 1 de julio de 2018)</a></li>
<li><a href="../es415875/index.html">Una palabra para el ling√ºista: ¬øy si las computadoras hablan mejor?</a></li>
<li><a href="../es415879/index.html">Eventos digitales en Mosc√∫ del 2 al 8 de julio</a></li>
<li><a href="../es415887/index.html">¬øQu√© tipo de robots ara√±a vuelan sobre estadios y disparan al f√∫tbol? Entrevista con el creador de Robycam</a></li>
<li><a href="../es415891/index.html">¬øCu√°les son los juegos secuelas geniales?</a></li>
<li><a href="../es415893/index.html">C√≥mo hacer que los procesos Java que se ejecutan en Linux / Docker sean simples y directos</a></li>
<li><a href="../es415895/index.html">El patr√≥n m√°s importante en la programaci√≥n.</a></li>
<li><a href="../es415897/index.html">Funciones para documentar bases de datos PostgreSQL. Parte dos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>