<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕳️ 🐽 🌾 Le meilleur est l'ennemi du bien 👩🏿‍💼 🧜🏿 🐷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article explique comment, une fois que nous avons décidé d'améliorer légèrement l'outil interne SelfTester, utilisé pour vérifier la qualité de l'...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le meilleur est l'ennemi du bien</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/466741/"><p><img src="https://habrastorage.org/getpro/habr/post_images/982/355/890/982355890903cccb9e35a693d48d72cf.png" alt="Image 12" align="left"></p>  Cet article explique comment, une fois que nous avons décidé d'améliorer légèrement l'outil interne SelfTester, utilisé pour vérifier la qualité de l'analyseur PVS-Studio.  L'amélioration était simple et semblait utile, mais elle a créé beaucoup de problèmes pour nous, et plus tard il s'est avéré que ce serait mieux si nous ne le faisions pas. <br><a name="habracut"></a><br><h2>  Selftester </h2><br>  Nous développons et promouvons l'analyseur de code statique PVS-Studio pour C, C ++, C # et Java.  Pour vérifier la qualité de l'analyseur, nous utilisons des outils internes appelés collectivement SelfTester.  Chacune des langues prises en charge a sa propre version de SelfTester.  Cela est dû aux fonctionnalités des tests, et c'est juste plus pratique.  Ainsi, pour le moment, notre entreprise utilise trois outils SelfTester internes pour C \ C ++, C # et Java, respectivement.  Ensuite, je vais parler de la version Windows de SelfTester pour les projets Visual Studio C \ C ++, en l'appelant simplement SelfTester.  Ce testeur a été le premier dans la gamme de ces outils internes, il est le plus avancé et le plus complexe de tous. <br><br>  Comment fonctionne SelfTester?  L'idée est simple: prendre un pool de projets de test (nous utilisons de vrais projets avec du code open source) et les analyser à l'aide de PVS-Studio.  Par conséquent, un journal d'avertissement de l'analyseur est généré pour chaque projet.  Ce journal est comparé au journal de <i>référence</i> pour le même projet.  Lors de la comparaison des journaux, SelfTester crée un <i>journal de</i> comparaison des journaux sous une forme que les développeurs peuvent percevoir. <br><br>  Après avoir étudié le journal de bord, le développeur tire une conclusion sur les changements dans le comportement de l'analyseur: le nombre et la nature des avertissements, la vitesse de fonctionnement, il y a des erreurs internes de l'analyseur, etc.  Toutes ces informations sont très importantes, elles vous permettent de comprendre dans quelle mesure l'analyseur fait son travail. <br><br>  Sur la base du journal de comparaison des journaux, le développeur apporte des modifications au cœur de l'analyseur (par exemple, lors de la création d'une nouvelle règle de diagnostic), contrôlant immédiatement l'effet de ses modifications.  Si le développeur n'a plus de questions sur la prochaine comparaison des journaux, il <i>fait</i> du journal d'avertissement <i>actuel</i> du projet une <i>référence</i> .  Sinon, le travail continue. <br><br>  Ainsi, la tâche de SelfTester est de travailler avec un pool de projets de test (au fait, il y en a déjà plus de 120 pour C / C ++).  Les projets pour le pool sont sélectionnés en tant que solutions Visual Studio.  Ceci est effectué afin de tester en plus l'analyseur sur différentes versions de Visual Studio que l'analyseur prend en charge (de Visual Studio 2010 à Visual Studio 2019 pour le moment). <br><br>  <i>Remarque</i> : Je séparerai davantage les concepts de <i>solution</i> et de <i>projet</i> , en comprenant le projet comme faisant partie de la solution, comme c'est la coutume dans Visual Studio. <br><br>  L'interface SelfTester ressemble à: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d0/627/355/1d0627355eb338938aa789d33aedec83.png" alt="Image 3"></div><br>  À gauche, une liste de solutions, à droite, les résultats des tests pour chaque version de Visual Studio. <br><br>  Les repères gris «Non pris en charge» indiquent que la solution ne prend pas en charge la version sélectionnée de Visual Studio ou n'a pas été convertie pour cette version.  Certaines solutions du pool ont un paramètre qui indique la version spécifique de Visual Studio à vérifier.  Si la version n'est pas spécifiée, la solution sera mise à jour vers toutes les versions ultérieures de Visual Studio.  Un exemple d'une telle solution dans la capture d'écran est «smart_ptr_check.sln» (la vérification a été effectuée pour toutes les versions de Visual Studio). <br><br>  Une marque verte «OK» indique que la vérification suivante n'a révélé aucune différence avec le journal de référence.  Un repère «Diff» rouge indique des différences.  C'est sur de telles étiquettes que le développeur doit faire attention.  Pour ce faire, il doit double-cliquer sur l'étiquette souhaitée.  La solution sélectionnée sera ouverte dans la version souhaitée de Visual Studio et une fenêtre avec un journal d'avertissement y sera également ouverte.  Les boutons de contrôle ci-dessous vous permettent de redémarrer l'analyse des décisions sélectionnées ou de toutes les décisions, d'affecter le journal sélectionné (ou tout d'un coup) aux journaux standard, etc. <br><br>  Les résultats présentés du travail SelfTester sont toujours dupliqués dans le rapport html (journal des différences). <br><br>  En plus de l'interface graphique, SelfTester dispose également de modes automatisés pour l'exécution pendant les générations nocturnes.  Cependant, le schéma d'utilisation habituel est des lancements répétés par le développeur pendant la journée de travail.  Par conséquent, l'une des caractéristiques importantes de SelfTester est sa <i>vitesse</i> . <br><br>  Pourquoi la vitesse est importante: <br><br><ol><li>  Pour s'exécuter pendant les tests de nuit, le temps nécessaire pour terminer chaque étape est critique.  De toute évidence, plus les tests réussissent rapidement, mieux c'est.  Et le temps de fonctionnement moyen de SelfTester dépasse actuellement 2 heures; </li><li>  Lors du lancement de SelfTester pendant la journée, le développeur doit attendre moins le résultat, ce qui augmente la productivité du travail. </li></ol><br>  C'est le désir d'accélérer le travail de SelfTester qui a provoqué les améliorations cette fois. <br><br><h2>  Multithreading dans SelfTester </h2><br>  SelfTester a été initialement créé comme une application multi-thread avec la possibilité de vérifier plusieurs solutions en parallèle.  La seule limitation était que vous ne pouvez pas vérifier simultanément la même solution pour différentes versions de Visual Studio, car de nombreuses solutions doivent être mises à jour vers certaines versions de Visual Studio avant de vérifier.  Pendant cela, des modifications sont apportées directement aux <i>fichiers de</i> projet <i>.vcxproj</i> , ce qui entraîne des erreurs lors de l'exécution en parallèle. <br><br>  Pour rendre le travail plus efficace, SelfTester utilise un planificateur de tâches intelligent, qui vous permet de définir une valeur strictement limitée pour les threads parallèles et de la maintenir. <br><br>  L'ordonnanceur est utilisé à deux niveaux.  Le premier est le niveau de <i>solution</i> , qui est utilisé pour commencer à vérifier la solution <i>.sln</i> à l'aide de l' <i>utilitaire PVS-Studio_Cmd.exe</i> .  Dans <i>PVS-Studio_Cmd.exe</i> (au niveau de la vérification des <i>fichiers de</i> code source), le même planificateur est utilisé, mais avec un paramètre <i>de parallélisme</i> différent. <br><br>  Le degré de parallélisme est un paramètre qui indique réellement combien de threads parallèles doivent s'exécuter simultanément.  Pour les valeurs de degré de parallélisme au niveau de la décision et des fichiers, les valeurs par défaut de <i>quatre</i> et <i>huit</i> ont été sélectionnées, respectivement.  Ainsi, le nombre de threads parallèles pour cette implémentation doit être égal à 32 (quatre solutions testées simultanément et huit fichiers).  Ce paramètre nous semble optimal pour que l'analyseur fonctionne sur un processeur à huit cœurs. <br><br>  Le développeur peut définir indépendamment d'autres valeurs du degré de parallélisme, en se concentrant sur les performances de son ordinateur ou des tâches en cours.  S'il ne définit pas ce paramètre, par défaut, le nombre de processeurs logiques du système sera sélectionné. <br><br>  <i>Remarque</i> : nous considérerons en outre que le travail est effectué avec les valeurs par défaut du degré de parallélisme. <br><br>  Le <i>planificateur LimitedConcurrencyLevelTaskScheduler est</i> hérité de <i>System.Threading.Tasks.TaskScheduler</i> et affiné pour fournir le niveau maximal de parallélisme lorsque vous travaillez sur <i>ThreadPool</i> .  Hiérarchie d'héritage: <br><br><pre><code class="cs hljs">LimitedConcurrencyLevelTaskScheduler : PausableTaskScheduler { .... } PausableTaskScheduler: TaskScheduler { .... }</code> </pre> <br>  <i>PausableTaskScheduler vous</i> permet de suspendre l'exécution des tâches, et <i>LimitedConcurrencyLevelTaskScheduler</i> , en outre, fournit un contrôle intelligent de la file d'attente des tâches et la planification de leur exécution, en tenant compte du degré de parallélisme, de la quantité de tâches planifiées et d'autres facteurs.  Le planificateur est utilisé lors du démarrage des tâches <i>System.Threading.Tasks.Task</i> . <br><br><h2>  Conditions préalables aux améliorations </h2><br>  La mise en œuvre des travaux décrits ci-dessus présente un inconvénient: elle n'est pas optimale lorsque l'on travaille avec des solutions de tailles différentes.  Et la taille des solutions dans le pool de tests est <i>très</i> différente: de 8 Ko à 4 Go pour la taille du dossier avec la solution, et d'un à plusieurs milliers de fichiers de code source dans chacun. <br><br>  L'ordonnanceur met les décisions en file d'attente simplement dans l'ordre, sans aucune composante intellectuelle.  Permettez-moi de vous rappeler que par défaut, plus de quatre solutions ne peuvent pas être vérifiées en même temps.  Si, à l'heure actuelle, quatre grandes solutions sont vérifiées (le nombre de fichiers dans chacune est supérieur à huit), il est supposé que nous travaillons efficacement, car nous utilisons le nombre maximal possible de threads (32). <br><br>  Mais imaginez une situation assez courante lorsque plusieurs petites solutions sont testées.  Par exemple, une solution est volumineuse et contient 50 fichiers (un maximum de huit threads seront impliqués), et les trois autres contiennent trois, quatre et cinq fichiers chacun.  Dans ce cas, nous n'utilisons que 20 threads (8 + 3 + 4 + 5).  Nous obtenons une sous-utilisation du temps processeur et une diminution des performances globales. <br><br>  <i>Remarque</i> : en fait, le goulot d'étranglement, en règle générale, est toujours le sous-système de disque, pas le processeur. <br><br><h2>  Améliorations </h2><br>  Une amélioration qui se propose dans ce cas est le classement de la liste des solutions soumises à vérification.  Il est nécessaire de parvenir à une utilisation optimale d'un nombre donné de threads exécutés simultanément (32) en soumettant des projets avec le nombre «correct» de fichiers pour vérification. <br><br>  Regardons à nouveau notre exemple, lorsque quatre solutions sont testées avec le nombre de fichiers suivant dans chacune: 50, 3, 4 et 5. Une tâche qui vérifie une solution de <i>trois</i> fichiers fonctionnera probablement bientôt.  Et au lieu de cela, il serait optimal d'ajouter une solution dans laquelle il y a huit fichiers ou plus (afin d'utiliser un maximum de huit flux disponibles pour cette solution).  Ensuite, au total, nous utiliserons déjà 25 threads (8 + <b>8</b> + 4 + 5).  Pas mal.  Cependant, sept threads étaient encore inutilisés.  Et ici surgit l'idée d'un autre raffinement, lié à la suppression de la restriction sur quatre threads pour la vérification des solutions.  En effet, dans l'exemple ci-dessus, vous pouvez ajouter non pas une, mais plusieurs solutions, en utilisant autant que possible les 32 threads.  Imaginons que nous ayons deux autres solutions, trois et quatre fichiers chacune.  L'ajout de ces tâches comblera complètement «l'écart» dans les threads inutilisés, et il y en aura 32 (8 + 8 + 4 + 5 + <b>3</b> + <b>4</b> ). <br><br>  Je pense que l'idée est claire.  En fait, la mise en œuvre de ces améliorations n'a pas non plus exigé beaucoup d'efforts.  Tout a été fait en une journée. <br><br>  Il a fallu affiner la classe de tâches: héritage de <i>System.Threading.Tasks.Task</i> et ajouter le champ "weight".  Pour définir le poids de la solution, un algorithme simple est utilisé: si le nombre de fichiers dans la solution est inférieur à huit, alors le poids est défini égal à cette valeur (par exemple, 5), si le nombre de fichiers est supérieur ou égal à huit, alors le poids est choisi égal à huit. <br><br>  Il a également fallu affiner l'ordonnanceur: lui apprendre à choisir des solutions avec le bon poids pour atteindre une valeur maximale de 32 threads.  Il était également nécessaire de permettre l'allocation de plus de quatre threads pour la vérification simultanée des solutions. <br><br>  Enfin, il a fallu une étape préliminaire pour analyser toutes les solutions de pool (évaluation à l'aide de l'API MSBuild) pour calculer et définir les pondérations de la solution (obtenir le nombre de fichiers avec le code source). <br><br><h2>  Résultat </h2><br>  Je pense qu'après une si longue introduction, vous avez déjà deviné que le résultat était nul. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91c/6c1/fca/91c6c1fca4017036c0fca83fd2113474.png" alt="Image 15"></div><br>  Heureusement que les améliorations ont été simples et rapides. <br><br>  Eh bien, maintenant, en fait, la partie de l'article sur «a créé beaucoup de problèmes pour nous» commence, et c'est tout. <br><br><h2>  Effets secondaires </h2><br>  Ainsi, un résultat négatif est également un résultat.  Il s'est avéré que le nombre de grandes solutions dans le pool dépasse <i>considérablement</i> le nombre de petites (moins de huit fichiers).  Dans ces conditions, les améliorations apportées n'ont pas d'effet notable, car elles sont pratiquement invisibles: leur vérification prend un temps microscopique par rapport aux grands projets. <br><br>  Néanmoins, il a été décidé de laisser la révision comme "sans interférence" et potentiellement utile.  En outre, le pool de solutions de test est constamment renouvelé, donc à l'avenir, la situation changera peut-être. <br><br>  Et puis ... <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdf/906/0ea/bdf9060ea6b9d1ce17ed820acc1468c7.png" alt="Image 5"></div><br>  L'un des développeurs s'est plaint de la "chute" de SelfTester.  Eh bien, ça arrive.  Pour éviter que cette erreur ne soit perdue, un incident interne (ticket) a été lancé avec le nom "Exception lors de l'utilisation de SelfTester".  L'erreur s'est produite lors de l'évaluation du projet.  Certes, une telle abondance de fenêtres témoigne également du problème dans le gestionnaire d'erreurs.  Mais cela a été rapidement éliminé et au cours de la semaine suivante, rien ne s'est cassé.  Soudain, un autre utilisateur s'est plaint de SelfTester.  Et encore une fois à l'erreur de l'évaluation du projet: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0fa/1f3/bd5/0fa1f3bd596a2a4bdbbc0f9ace32664c.png" alt="Image 8"></div><br>  La pile contenait cette fois des informations plus utiles - une erreur au format xml.  Probablement, lors du traitement du fichier de projet <i>Proto_IRC.vcxproj</i> (sa représentation xml), quelque chose est arrivé au fichier lui-même, donc <i>XmlTextReader</i> n'a pas pu le traiter. <br><br>  La présence de deux erreurs dans un laps de temps assez court nous a fait examiner de plus près le problème.  De plus, comme je l'ai dit plus haut, SelfTester est très activement utilisé par les développeurs. <br><br>  Pour commencer, une analyse a été faite du dernier lieu de l'automne.  Malheureusement, rien de suspect n'a pu être identifié.  Au cas où, ils ont demandé aux développeurs (utilisateurs SelfTester) d'être en alerte et de signaler d'éventuelles erreurs. <br><br>  Un point important: le code sur lequel l'erreur s'est produite a été réutilisé dans SelfTester.  Initialement, il est utilisé pour évaluer des projets dans l'analyseur lui <i>-</i> même ( <i>PVS-Studio_Cmd.exe</i> ).  C'est pourquoi l'attention portée au problème s'est accrue.  Cependant, aucune baisse similaire ne s'est produite dans l'analyseur. <br><br>  Pendant ce temps, un ticket sur les problèmes avec SelfTester a été réapprovisionné avec de nouvelles erreurs: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b49/15a/0ae/b4915a0aecc426246419f4a26e62a233.png" alt="Image 9"></div><br>  Et encore <i>une</i> fois <i>XmlException</i> .  Évidemment, quelque part, il existe des threads concurrents qui travaillent avec des fichiers de projet en lecture et en écriture.  SelfTester fonctionne avec des projets dans les cas suivants: <br><br><ol><li>  Évaluation des projets lors du calcul préliminaire des poids de décision: une nouvelle étape qui a d'abord suscité des soupçons; </li><li>  Mise à niveau des projets vers les versions nécessaires de Visual Studio: effectuée immédiatement avant la vérification (les projets ne se croisent en aucune façon) et ne doit pas affecter le travail; </li><li>  Évaluation des projets lors de la vérification: débogage du mécanisme thread-safe, qui a été réutilisé à partir de <i>PVS-Studio_Cmd.exe</i> ; </li><li>  Récupération des fichiers de projet (remplacement des fichiers <i>.vcxproj</i> modifiés <i>par les</i> fichiers <i>de</i> référence d'origine) à la sortie de SelfTester, car les fichiers de projet peuvent être mis à jour vers les versions nécessaires de Visual Studio dans le processus: la dernière étape, qui n'affecte pas non plus les autres mécanismes. </li></ol><br>  Les soupçons sont tombés sur le nouveau code ajouté pour l'optimisation (calcul des poids).  Mais l'étude de ce code a montré que si l'utilisateur commençait l'analyse immédiatement après le démarrage de SelfTester, le testeur attendait toujours correctement la fin de l'évaluation préliminaire.  Cet endroit avait l'air sûr. <br><br>  Encore une fois, nous n'avons pas pu identifier la source du problème. <br><br><h2>  La douleur </h2><br>  Au cours du mois suivant, SelfTester a continué de chuter de temps en temps.  Le ticket a été réapprovisionné en données, mais il n'était pas clair que faire de ces données.  La plupart des plantages étaient tous avec la même <i>exception XmlException</i> .  Parfois, il y avait autre chose, mais sur le même code réutilisé de <i>PVS-Studio_Cmd.exe</i> . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c31/fbe/c11/c31fbec1152210e397b6d9d1ffdb5aa6.png" alt="Image 1"></div><br>  Par tradition, les outils internes ne sont pas soumis à des exigences si élevées, de sorte que le travail avec les erreurs SelfTester a été effectué de manière résiduelle.  De temps en temps, différentes personnes se sont connectées (pendant toute la durée de l'incident, six personnes ont travaillé sur le problème, dont deux stagiaires stagiaires).  Néanmoins, la tâche devait être distraite. <br><br>  <i>Notre première erreur.</i>  En fait, il était déjà possible de résoudre le problème une fois pour toutes.  Comment?  Il était clair que l'erreur était due à une nouvelle optimisation.  Après tout, avant cela, tout fonctionnait bien et le code réutilisé ne pouvait évidemment pas être si mauvais.  De plus, cette optimisation n'a apporté aucun avantage.  Alors, que fallait-il faire?  <i>Supprimez cette optimisation</i> <b>.</b>  Comme vous le savez, cela n'a pas été fait.  Nous avons continué à travailler sur un problème que nous avions nous-mêmes créé.  La recherche s'est poursuivie pour trouver la réponse à la question: "COMMENT ???"  Comment ça tombe?  Pourtant, il semble être écrit correctement. <br><br>  <i>Notre deuxième erreur.</i>  <i>D'autres personnes</i> ont été <i>connectées</i> à la solution du problème.  Une très, très grosse erreur.  Malheureusement, non seulement cela n'a pas résolu le problème, mais des ressources supplémentaires ont été dépensées.  Oui, de nouvelles personnes ont apporté de nouvelles idées, mais pour leur mise en œuvre, cela a pris (absolument gaspillé) beaucoup de temps de travail.  À un certain stade, des programmes de test ont été écrits (par les mêmes stagiaires) qui émulent l'évaluation du même projet dans différents threads avec une modification parallèle du projet dans un autre thread.  Ça n'a pas aidé.  En plus de ce que nous savions déjà, l'API MSBuild est sécurisée pour les threads, ils n'ont rien découvert de nouveau.  Et dans SelfTester, un mini-vidage a été ajouté lorsqu'une <i>XmlException a été</i> levée.  Puis tout cela, quelqu'un de débraillé, d'horreur.  Des discussions ont eu lieu, beaucoup d'autres choses inutiles ont été faites. <br><br>  <i>Enfin, notre troisième erreur</i> .  Savez-vous combien de temps s'est écoulé depuis que le problème avec SelfTester est survenu jusqu'à ce qu'il soit résolu?  Bien que non, comptez-vous.  L'incident a été créé le 17/09/2018 et fermé le 20/02/2019, et il y a plus de 40 (quarante!) Messages là-bas.  Les gars, c'est beaucoup de temps!  Nous <i>nous</i> sommes <i>permis</i> de le faire <i>pendant</i> cinq mois.  Dans le même temps (en parallèle), nous nous sommes engagés à prendre en charge Visual Studio 2019, à ajouter le langage Java, à commencer à implémenter la norme MISRA C / C ++, à améliorer l'analyseur C #, à participer activement à des conférences, à écrire un tas d'articles, etc.  Et tous ces travaux n'ont pas reçu le temps des développeurs en raison de la stupide erreur SelfTester. <br><br>  Citoyens, apprenez de nos erreurs et ne faites jamais cela.  Et nous ne le ferons pas. <br><br>  J'ai tout. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a8/a29/f94/3a8a29f94aeed35ddeaec17222a4f990.png" alt="Image 17"></div><br>  Bien sûr, c'est une blague, et je vais vous dire quel était le problème avec SelfTester :) <br><br><h2>  Bingo! </h2><br>  Heureusement, parmi nous, il y avait une personne avec la conscience la moins trouble (mon collègue Sergey Vasiliev), qui vient de regarder le problème sous un angle complètement différent (et aussi il a eu un peu de chance).  Et si l'intérieur de SelfTester allait vraiment bien et que les projets cassaient quelque chose de l'extérieur?  En parallèle avec SelfTester, généralement rien n'a commencé, dans certains cas, nous contrôlions strictement le temps d'exécution.  Dans ce cas, ce «quelque chose» ne peut être que SelfTester lui-même, mais une autre instance de celui-ci. <br><br>  En quittant SelfTester, le flux de restauration des fichiers de projet à partir des normes continue de fonctionner pendant un certain temps.  À ce stade, vous pouvez redémarrer le testeur.  La protection contre l'exécution de plusieurs instances de SelfTester en même temps a été ajoutée <i>plus tard</i> et ressemble maintenant à ceci: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a3/7bf/437/0a37bf4373e3beb9bbfe2542afb258a0.png" alt="Image 16"></div><br>  Mais alors elle était partie. <br><br>  Incroyablement, pendant près de six mois de tourments, personne n'y a prêté attention.  La restauration de projets à partir des normes est une procédure d'arrière-plan assez rapide, mais malheureusement pas assez rapide pour ne pas interférer avec le redémarrage de SelfTester.  Et que se passe-t-il au démarrage?  C'est vrai, calculer les poids de décision.  Un processus écrase les fichiers <i>.vcxproj</i> , tandis qu'un autre essaie de les lire.  Salut, <i>XmlException</i> . <br><br>  Sergey a découvert tout cela en ajoutant au testeur la possibilité de passer au mode de travail avec un autre ensemble de journaux standard.  Le besoin s'est fait sentir après l'ajout de l'ensemble de règles MISRA à l'analyseur.  Vous pouvez basculer directement dans l'interface, pendant que l'utilisateur voit la fenêtre: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a5/9b0/87d/0a59b087d0e13688ab41a690ed490a3f.png" alt="Image 14"></div><br>  Après quoi SelfTester <i>redémarre</i> .  Eh bien, plus tôt, apparemment, les utilisateurs ont eux-mêmes émulé le problème en redémarrant le testeur. <br><br><h2>  Débriefing et conclusions </h2><br>  Bien sûr, nous avons supprimé, ou plutôt désactivé, l'optimisation précédemment créée.  De plus, c'était beaucoup plus facile que de faire une sorte de synchronisation entre le reste du testeur lui-même.  Et tout a commencé à bien fonctionner, comme avant.  Et comme mesure supplémentaire, la protection décrite ci-dessus contre le lancement simultané du testeur a été ajoutée. <br><br>  J'ai déjà écrit ci-dessus nos principales erreurs lors de la recherche du problème, donc l'auto-flagellation suffit.  Nous sommes aussi des gens et nous nous trompons donc.  Il est important d'apprendre de vos erreurs et de tirer des conclusions.  Les conclusions ici sont assez simples: <br><br><ul><li>  Il est nécessaire de suivre et d'évaluer la croissance de la complexité des tâches; </li><li>  Arrêtez-vous à temps; </li><li>  Essayez de regarder le problème plus largement, car au fil du temps la vue est «floue» et l'angle de vue se rétrécit; </li><li>  N'ayez pas peur de supprimer du code ancien ou inutile. </li></ul><br>  Maintenant, c'est sûr - c'est tout.  Merci d'avoir lu.  Pour tout code désespéré! <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a> </p><br><br>  Si vous souhaitez partager cet article avec un public anglophone, veuillez utiliser le lien vers la traduction: Sergey Khrenov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le meilleur est l'ennemi du bien</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466741/">https://habr.com/ru/post/fr466741/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466731/index.html">Extravagance. Septembre se lève</a></li>
<li><a href="../fr466733/index.html">Bienvenue à DINS Java EVENING le 18 septembre</a></li>
<li><a href="../fr466735/index.html">Un moyen simple de créer une alerte vocale dans le système domotique («Smart Home»)</a></li>
<li><a href="../fr466737/index.html">Pourquoi le réseau social Google+ a échoué</a></li>
<li><a href="../fr466739/index.html">Le meilleur est l'ennemi du bien</a></li>
<li><a href="../fr466745/index.html">Le premier lieu de travail ou comment commencer à développer une API sur Node.js</a></li>
<li><a href="../fr466747/index.html">Développeurs Mitap iOS chez Redmadrobot</a></li>
<li><a href="../fr466753/index.html">Administration réseau rapide et efficace - Network MACMonitor</a></li>
<li><a href="../fr466755/index.html">L'ordinateur vous rendra savoureux</a></li>
<li><a href="../fr466757/index.html">Le premier mitap Flutter à Saint-Pétersbourg - 26 septembre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>