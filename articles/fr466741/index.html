<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï≥Ô∏è üêΩ üåæ Le meilleur est l'ennemi du bien üë©üèø‚Äçüíº üßúüèø üê∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article explique comment, une fois que nous avons d√©cid√© d'am√©liorer l√©g√®rement l'outil interne SelfTester, utilis√© pour v√©rifier la qualit√© de l'...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le meilleur est l'ennemi du bien</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/466741/"><p><img src="https://habrastorage.org/getpro/habr/post_images/982/355/890/982355890903cccb9e35a693d48d72cf.png" alt="Image 12" align="left"></p>  Cet article explique comment, une fois que nous avons d√©cid√© d'am√©liorer l√©g√®rement l'outil interne SelfTester, utilis√© pour v√©rifier la qualit√© de l'analyseur PVS-Studio.  L'am√©lioration √©tait simple et semblait utile, mais elle a cr√©√© beaucoup de probl√®mes pour nous, et plus tard il s'est av√©r√© que ce serait mieux si nous ne le faisions pas. <br><a name="habracut"></a><br><h2>  Selftester </h2><br>  Nous d√©veloppons et promouvons l'analyseur de code statique PVS-Studio pour C, C ++, C # et Java.  Pour v√©rifier la qualit√© de l'analyseur, nous utilisons des outils internes appel√©s collectivement SelfTester.  Chacune des langues prises en charge a sa propre version de SelfTester.  Cela est d√ª aux fonctionnalit√©s des tests, et c'est juste plus pratique.  Ainsi, pour le moment, notre entreprise utilise trois outils SelfTester internes pour C \ C ++, C # et Java, respectivement.  Ensuite, je vais parler de la version Windows de SelfTester pour les projets Visual Studio C \ C ++, en l'appelant simplement SelfTester.  Ce testeur a √©t√© le premier dans la gamme de ces outils internes, il est le plus avanc√© et le plus complexe de tous. <br><br>  Comment fonctionne SelfTester?  L'id√©e est simple: prendre un pool de projets de test (nous utilisons de vrais projets avec du code open source) et les analyser √† l'aide de PVS-Studio.  Par cons√©quent, un journal d'avertissement de l'analyseur est g√©n√©r√© pour chaque projet.  Ce journal est compar√© au journal de <i>r√©f√©rence</i> pour le m√™me projet.  Lors de la comparaison des journaux, SelfTester cr√©e un <i>journal de</i> comparaison des journaux sous une forme que les d√©veloppeurs peuvent percevoir. <br><br>  Apr√®s avoir √©tudi√© le journal de bord, le d√©veloppeur tire une conclusion sur les changements dans le comportement de l'analyseur: le nombre et la nature des avertissements, la vitesse de fonctionnement, il y a des erreurs internes de l'analyseur, etc.  Toutes ces informations sont tr√®s importantes, elles vous permettent de comprendre dans quelle mesure l'analyseur fait son travail. <br><br>  Sur la base du journal de comparaison des journaux, le d√©veloppeur apporte des modifications au c≈ìur de l'analyseur (par exemple, lors de la cr√©ation d'une nouvelle r√®gle de diagnostic), contr√¥lant imm√©diatement l'effet de ses modifications.  Si le d√©veloppeur n'a plus de questions sur la prochaine comparaison des journaux, il <i>fait</i> du journal d'avertissement <i>actuel</i> du projet une <i>r√©f√©rence</i> .  Sinon, le travail continue. <br><br>  Ainsi, la t√¢che de SelfTester est de travailler avec un pool de projets de test (au fait, il y en a d√©j√† plus de 120 pour C / C ++).  Les projets pour le pool sont s√©lectionn√©s en tant que solutions Visual Studio.  Ceci est effectu√© afin de tester en plus l'analyseur sur diff√©rentes versions de Visual Studio que l'analyseur prend en charge (de Visual Studio 2010 √† Visual Studio 2019 pour le moment). <br><br>  <i>Remarque</i> : Je s√©parerai davantage les concepts de <i>solution</i> et de <i>projet</i> , en comprenant le projet comme faisant partie de la solution, comme c'est la coutume dans Visual Studio. <br><br>  L'interface SelfTester ressemble √†: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d0/627/355/1d0627355eb338938aa789d33aedec83.png" alt="Image 3"></div><br>  √Ä gauche, une liste de solutions, √† droite, les r√©sultats des tests pour chaque version de Visual Studio. <br><br>  Les rep√®res gris ¬´Non pris en charge¬ª indiquent que la solution ne prend pas en charge la version s√©lectionn√©e de Visual Studio ou n'a pas √©t√© convertie pour cette version.  Certaines solutions du pool ont un param√®tre qui indique la version sp√©cifique de Visual Studio √† v√©rifier.  Si la version n'est pas sp√©cifi√©e, la solution sera mise √† jour vers toutes les versions ult√©rieures de Visual Studio.  Un exemple d'une telle solution dans la capture d'√©cran est ¬´smart_ptr_check.sln¬ª (la v√©rification a √©t√© effectu√©e pour toutes les versions de Visual Studio). <br><br>  Une marque verte ¬´OK¬ª indique que la v√©rification suivante n'a r√©v√©l√© aucune diff√©rence avec le journal de r√©f√©rence.  Un rep√®re ¬´Diff¬ª rouge indique des diff√©rences.  C'est sur de telles √©tiquettes que le d√©veloppeur doit faire attention.  Pour ce faire, il doit double-cliquer sur l'√©tiquette souhait√©e.  La solution s√©lectionn√©e sera ouverte dans la version souhait√©e de Visual Studio et une fen√™tre avec un journal d'avertissement y sera √©galement ouverte.  Les boutons de contr√¥le ci-dessous vous permettent de red√©marrer l'analyse des d√©cisions s√©lectionn√©es ou de toutes les d√©cisions, d'affecter le journal s√©lectionn√© (ou tout d'un coup) aux journaux standard, etc. <br><br>  Les r√©sultats pr√©sent√©s du travail SelfTester sont toujours dupliqu√©s dans le rapport html (journal des diff√©rences). <br><br>  En plus de l'interface graphique, SelfTester dispose √©galement de modes automatis√©s pour l'ex√©cution pendant les g√©n√©rations nocturnes.  Cependant, le sch√©ma d'utilisation habituel est des lancements r√©p√©t√©s par le d√©veloppeur pendant la journ√©e de travail.  Par cons√©quent, l'une des caract√©ristiques importantes de SelfTester est sa <i>vitesse</i> . <br><br>  Pourquoi la vitesse est importante: <br><br><ol><li>  Pour s'ex√©cuter pendant les tests de nuit, le temps n√©cessaire pour terminer chaque √©tape est critique.  De toute √©vidence, plus les tests r√©ussissent rapidement, mieux c'est.  Et le temps de fonctionnement moyen de SelfTester d√©passe actuellement 2 heures; </li><li>  Lors du lancement de SelfTester pendant la journ√©e, le d√©veloppeur doit attendre moins le r√©sultat, ce qui augmente la productivit√© du travail. </li></ol><br>  C'est le d√©sir d'acc√©l√©rer le travail de SelfTester qui a provoqu√© les am√©liorations cette fois. <br><br><h2>  Multithreading dans SelfTester </h2><br>  SelfTester a √©t√© initialement cr√©√© comme une application multi-thread avec la possibilit√© de v√©rifier plusieurs solutions en parall√®le.  La seule limitation √©tait que vous ne pouvez pas v√©rifier simultan√©ment la m√™me solution pour diff√©rentes versions de Visual Studio, car de nombreuses solutions doivent √™tre mises √† jour vers certaines versions de Visual Studio avant de v√©rifier.  Pendant cela, des modifications sont apport√©es directement aux <i>fichiers de</i> projet <i>.vcxproj</i> , ce qui entra√Æne des erreurs lors de l'ex√©cution en parall√®le. <br><br>  Pour rendre le travail plus efficace, SelfTester utilise un planificateur de t√¢ches intelligent, qui vous permet de d√©finir une valeur strictement limit√©e pour les threads parall√®les et de la maintenir. <br><br>  L'ordonnanceur est utilis√© √† deux niveaux.  Le premier est le niveau de <i>solution</i> , qui est utilis√© pour commencer √† v√©rifier la solution <i>.sln</i> √† l'aide de l' <i>utilitaire PVS-Studio_Cmd.exe</i> .  Dans <i>PVS-Studio_Cmd.exe</i> (au niveau de la v√©rification des <i>fichiers de</i> code source), le m√™me planificateur est utilis√©, mais avec un param√®tre <i>de parall√©lisme</i> diff√©rent. <br><br>  Le degr√© de parall√©lisme est un param√®tre qui indique r√©ellement combien de threads parall√®les doivent s'ex√©cuter simultan√©ment.  Pour les valeurs de degr√© de parall√©lisme au niveau de la d√©cision et des fichiers, les valeurs par d√©faut de <i>quatre</i> et <i>huit</i> ont √©t√© s√©lectionn√©es, respectivement.  Ainsi, le nombre de threads parall√®les pour cette impl√©mentation doit √™tre √©gal √† 32 (quatre solutions test√©es simultan√©ment et huit fichiers).  Ce param√®tre nous semble optimal pour que l'analyseur fonctionne sur un processeur √† huit c≈ìurs. <br><br>  Le d√©veloppeur peut d√©finir ind√©pendamment d'autres valeurs du degr√© de parall√©lisme, en se concentrant sur les performances de son ordinateur ou des t√¢ches en cours.  S'il ne d√©finit pas ce param√®tre, par d√©faut, le nombre de processeurs logiques du syst√®me sera s√©lectionn√©. <br><br>  <i>Remarque</i> : nous consid√©rerons en outre que le travail est effectu√© avec les valeurs par d√©faut du degr√© de parall√©lisme. <br><br>  Le <i>planificateur LimitedConcurrencyLevelTaskScheduler est</i> h√©rit√© de <i>System.Threading.Tasks.TaskScheduler</i> et affin√© pour fournir le niveau maximal de parall√©lisme lorsque vous travaillez sur <i>ThreadPool</i> .  Hi√©rarchie d'h√©ritage: <br><br><pre><code class="cs hljs">LimitedConcurrencyLevelTaskScheduler : PausableTaskScheduler { .... } PausableTaskScheduler: TaskScheduler { .... }</code> </pre> <br>  <i>PausableTaskScheduler vous</i> permet de suspendre l'ex√©cution des t√¢ches, et <i>LimitedConcurrencyLevelTaskScheduler</i> , en outre, fournit un contr√¥le intelligent de la file d'attente des t√¢ches et la planification de leur ex√©cution, en tenant compte du degr√© de parall√©lisme, de la quantit√© de t√¢ches planifi√©es et d'autres facteurs.  Le planificateur est utilis√© lors du d√©marrage des t√¢ches <i>System.Threading.Tasks.Task</i> . <br><br><h2>  Conditions pr√©alables aux am√©liorations </h2><br>  La mise en ≈ìuvre des travaux d√©crits ci-dessus pr√©sente un inconv√©nient: elle n'est pas optimale lorsque l'on travaille avec des solutions de tailles diff√©rentes.  Et la taille des solutions dans le pool de tests est <i>tr√®s</i> diff√©rente: de 8 Ko √† 4 Go pour la taille du dossier avec la solution, et d'un √† plusieurs milliers de fichiers de code source dans chacun. <br><br>  L'ordonnanceur met les d√©cisions en file d'attente simplement dans l'ordre, sans aucune composante intellectuelle.  Permettez-moi de vous rappeler que par d√©faut, plus de quatre solutions ne peuvent pas √™tre v√©rifi√©es en m√™me temps.  Si, √† l'heure actuelle, quatre grandes solutions sont v√©rifi√©es (le nombre de fichiers dans chacune est sup√©rieur √† huit), il est suppos√© que nous travaillons efficacement, car nous utilisons le nombre maximal possible de threads (32). <br><br>  Mais imaginez une situation assez courante lorsque plusieurs petites solutions sont test√©es.  Par exemple, une solution est volumineuse et contient 50 fichiers (un maximum de huit threads seront impliqu√©s), et les trois autres contiennent trois, quatre et cinq fichiers chacun.  Dans ce cas, nous n'utilisons que 20 threads (8 + 3 + 4 + 5).  Nous obtenons une sous-utilisation du temps processeur et une diminution des performances globales. <br><br>  <i>Remarque</i> : en fait, le goulot d'√©tranglement, en r√®gle g√©n√©rale, est toujours le sous-syst√®me de disque, pas le processeur. <br><br><h2>  Am√©liorations </h2><br>  Une am√©lioration qui se propose dans ce cas est le classement de la liste des solutions soumises √† v√©rification.  Il est n√©cessaire de parvenir √† une utilisation optimale d'un nombre donn√© de threads ex√©cut√©s simultan√©ment (32) en soumettant des projets avec le nombre ¬´correct¬ª de fichiers pour v√©rification. <br><br>  Regardons √† nouveau notre exemple, lorsque quatre solutions sont test√©es avec le nombre de fichiers suivant dans chacune: 50, 3, 4 et 5. Une t√¢che qui v√©rifie une solution de <i>trois</i> fichiers fonctionnera probablement bient√¥t.  Et au lieu de cela, il serait optimal d'ajouter une solution dans laquelle il y a huit fichiers ou plus (afin d'utiliser un maximum de huit flux disponibles pour cette solution).  Ensuite, au total, nous utiliserons d√©j√† 25 threads (8 + <b>8</b> + 4 + 5).  Pas mal.  Cependant, sept threads √©taient encore inutilis√©s.  Et ici surgit l'id√©e d'un autre raffinement, li√© √† la suppression de la restriction sur quatre threads pour la v√©rification des solutions.  En effet, dans l'exemple ci-dessus, vous pouvez ajouter non pas une, mais plusieurs solutions, en utilisant autant que possible les 32 threads.  Imaginons que nous ayons deux autres solutions, trois et quatre fichiers chacune.  L'ajout de ces t√¢ches comblera compl√®tement ¬´l'√©cart¬ª dans les threads inutilis√©s, et il y en aura 32 (8 + 8 + 4 + 5 + <b>3</b> + <b>4</b> ). <br><br>  Je pense que l'id√©e est claire.  En fait, la mise en ≈ìuvre de ces am√©liorations n'a pas non plus exig√© beaucoup d'efforts.  Tout a √©t√© fait en une journ√©e. <br><br>  Il a fallu affiner la classe de t√¢ches: h√©ritage de <i>System.Threading.Tasks.Task</i> et ajouter le champ "weight".  Pour d√©finir le poids de la solution, un algorithme simple est utilis√©: si le nombre de fichiers dans la solution est inf√©rieur √† huit, alors le poids est d√©fini √©gal √† cette valeur (par exemple, 5), si le nombre de fichiers est sup√©rieur ou √©gal √† huit, alors le poids est choisi √©gal √† huit. <br><br>  Il a √©galement fallu affiner l'ordonnanceur: lui apprendre √† choisir des solutions avec le bon poids pour atteindre une valeur maximale de 32 threads.  Il √©tait √©galement n√©cessaire de permettre l'allocation de plus de quatre threads pour la v√©rification simultan√©e des solutions. <br><br>  Enfin, il a fallu une √©tape pr√©liminaire pour analyser toutes les solutions de pool (√©valuation √† l'aide de l'API MSBuild) pour calculer et d√©finir les pond√©rations de la solution (obtenir le nombre de fichiers avec le code source). <br><br><h2>  R√©sultat </h2><br>  Je pense qu'apr√®s une si longue introduction, vous avez d√©j√† devin√© que le r√©sultat √©tait nul. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91c/6c1/fca/91c6c1fca4017036c0fca83fd2113474.png" alt="Image 15"></div><br>  Heureusement que les am√©liorations ont √©t√© simples et rapides. <br><br>  Eh bien, maintenant, en fait, la partie de l'article sur ¬´a cr√©√© beaucoup de probl√®mes pour nous¬ª commence, et c'est tout. <br><br><h2>  Effets secondaires </h2><br>  Ainsi, un r√©sultat n√©gatif est √©galement un r√©sultat.  Il s'est av√©r√© que le nombre de grandes solutions dans le pool d√©passe <i>consid√©rablement</i> le nombre de petites (moins de huit fichiers).  Dans ces conditions, les am√©liorations apport√©es n'ont pas d'effet notable, car elles sont pratiquement invisibles: leur v√©rification prend un temps microscopique par rapport aux grands projets. <br><br>  N√©anmoins, il a √©t√© d√©cid√© de laisser la r√©vision comme "sans interf√©rence" et potentiellement utile.  En outre, le pool de solutions de test est constamment renouvel√©, donc √† l'avenir, la situation changera peut-√™tre. <br><br>  Et puis ... <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdf/906/0ea/bdf9060ea6b9d1ce17ed820acc1468c7.png" alt="Image 5"></div><br>  L'un des d√©veloppeurs s'est plaint de la "chute" de SelfTester.  Eh bien, √ßa arrive.  Pour √©viter que cette erreur ne soit perdue, un incident interne (ticket) a √©t√© lanc√© avec le nom "Exception lors de l'utilisation de SelfTester".  L'erreur s'est produite lors de l'√©valuation du projet.  Certes, une telle abondance de fen√™tres t√©moigne √©galement du probl√®me dans le gestionnaire d'erreurs.  Mais cela a √©t√© rapidement √©limin√© et au cours de la semaine suivante, rien ne s'est cass√©.  Soudain, un autre utilisateur s'est plaint de SelfTester.  Et encore une fois √† l'erreur de l'√©valuation du projet: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0fa/1f3/bd5/0fa1f3bd596a2a4bdbbc0f9ace32664c.png" alt="Image 8"></div><br>  La pile contenait cette fois des informations plus utiles - une erreur au format xml.  Probablement, lors du traitement du fichier de projet <i>Proto_IRC.vcxproj</i> (sa repr√©sentation xml), quelque chose est arriv√© au fichier lui-m√™me, donc <i>XmlTextReader</i> n'a pas pu le traiter. <br><br>  La pr√©sence de deux erreurs dans un laps de temps assez court nous a fait examiner de plus pr√®s le probl√®me.  De plus, comme je l'ai dit plus haut, SelfTester est tr√®s activement utilis√© par les d√©veloppeurs. <br><br>  Pour commencer, une analyse a √©t√© faite du dernier lieu de l'automne.  Malheureusement, rien de suspect n'a pu √™tre identifi√©.  Au cas o√π, ils ont demand√© aux d√©veloppeurs (utilisateurs SelfTester) d'√™tre en alerte et de signaler d'√©ventuelles erreurs. <br><br>  Un point important: le code sur lequel l'erreur s'est produite a √©t√© r√©utilis√© dans SelfTester.  Initialement, il est utilis√© pour √©valuer des projets dans l'analyseur lui <i>-</i> m√™me ( <i>PVS-Studio_Cmd.exe</i> ).  C'est pourquoi l'attention port√©e au probl√®me s'est accrue.  Cependant, aucune baisse similaire ne s'est produite dans l'analyseur. <br><br>  Pendant ce temps, un ticket sur les probl√®mes avec SelfTester a √©t√© r√©approvisionn√© avec de nouvelles erreurs: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b49/15a/0ae/b4915a0aecc426246419f4a26e62a233.png" alt="Image 9"></div><br>  Et encore <i>une</i> fois <i>XmlException</i> .  √âvidemment, quelque part, il existe des threads concurrents qui travaillent avec des fichiers de projet en lecture et en √©criture.  SelfTester fonctionne avec des projets dans les cas suivants: <br><br><ol><li>  √âvaluation des projets lors du calcul pr√©liminaire des poids de d√©cision: une nouvelle √©tape qui a d'abord suscit√© des soup√ßons; </li><li>  Mise √† niveau des projets vers les versions n√©cessaires de Visual Studio: effectu√©e imm√©diatement avant la v√©rification (les projets ne se croisent en aucune fa√ßon) et ne doit pas affecter le travail; </li><li>  √âvaluation des projets lors de la v√©rification: d√©bogage du m√©canisme thread-safe, qui a √©t√© r√©utilis√© √† partir de <i>PVS-Studio_Cmd.exe</i> ; </li><li>  R√©cup√©ration des fichiers de projet (remplacement des fichiers <i>.vcxproj</i> modifi√©s <i>par les</i> fichiers <i>de</i> r√©f√©rence d'origine) √† la sortie de SelfTester, car les fichiers de projet peuvent √™tre mis √† jour vers les versions n√©cessaires de Visual Studio dans le processus: la derni√®re √©tape, qui n'affecte pas non plus les autres m√©canismes. </li></ol><br>  Les soup√ßons sont tomb√©s sur le nouveau code ajout√© pour l'optimisation (calcul des poids).  Mais l'√©tude de ce code a montr√© que si l'utilisateur commen√ßait l'analyse imm√©diatement apr√®s le d√©marrage de SelfTester, le testeur attendait toujours correctement la fin de l'√©valuation pr√©liminaire.  Cet endroit avait l'air s√ªr. <br><br>  Encore une fois, nous n'avons pas pu identifier la source du probl√®me. <br><br><h2>  La douleur </h2><br>  Au cours du mois suivant, SelfTester a continu√© de chuter de temps en temps.  Le ticket a √©t√© r√©approvisionn√© en donn√©es, mais il n'√©tait pas clair que faire de ces donn√©es.  La plupart des plantages √©taient tous avec la m√™me <i>exception XmlException</i> .  Parfois, il y avait autre chose, mais sur le m√™me code r√©utilis√© de <i>PVS-Studio_Cmd.exe</i> . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c31/fbe/c11/c31fbec1152210e397b6d9d1ffdb5aa6.png" alt="Image 1"></div><br>  Par tradition, les outils internes ne sont pas soumis √† des exigences si √©lev√©es, de sorte que le travail avec les erreurs SelfTester a √©t√© effectu√© de mani√®re r√©siduelle.  De temps en temps, diff√©rentes personnes se sont connect√©es (pendant toute la dur√©e de l'incident, six personnes ont travaill√© sur le probl√®me, dont deux stagiaires stagiaires).  N√©anmoins, la t√¢che devait √™tre distraite. <br><br>  <i>Notre premi√®re erreur.</i>  En fait, il √©tait d√©j√† possible de r√©soudre le probl√®me une fois pour toutes.  Comment?  Il √©tait clair que l'erreur √©tait due √† une nouvelle optimisation.  Apr√®s tout, avant cela, tout fonctionnait bien et le code r√©utilis√© ne pouvait √©videmment pas √™tre si mauvais.  De plus, cette optimisation n'a apport√© aucun avantage.  Alors, que fallait-il faire?  <i>Supprimez cette optimisation</i> <b>.</b>  Comme vous le savez, cela n'a pas √©t√© fait.  Nous avons continu√© √† travailler sur un probl√®me que nous avions nous-m√™mes cr√©√©.  La recherche s'est poursuivie pour trouver la r√©ponse √† la question: "COMMENT ???"  Comment √ßa tombe?  Pourtant, il semble √™tre √©crit correctement. <br><br>  <i>Notre deuxi√®me erreur.</i>  <i>D'autres personnes</i> ont √©t√© <i>connect√©es</i> √† la solution du probl√®me.  Une tr√®s, tr√®s grosse erreur.  Malheureusement, non seulement cela n'a pas r√©solu le probl√®me, mais des ressources suppl√©mentaires ont √©t√© d√©pens√©es.  Oui, de nouvelles personnes ont apport√© de nouvelles id√©es, mais pour leur mise en ≈ìuvre, cela a pris (absolument gaspill√©) beaucoup de temps de travail.  √Ä un certain stade, des programmes de test ont √©t√© √©crits (par les m√™mes stagiaires) qui √©mulent l'√©valuation du m√™me projet dans diff√©rents threads avec une modification parall√®le du projet dans un autre thread.  √áa n'a pas aid√©.  En plus de ce que nous savions d√©j√†, l'API MSBuild est s√©curis√©e pour les threads, ils n'ont rien d√©couvert de nouveau.  Et dans SelfTester, un mini-vidage a √©t√© ajout√© lorsqu'une <i>XmlException a √©t√©</i> lev√©e.  Puis tout cela, quelqu'un de d√©braill√©, d'horreur.  Des discussions ont eu lieu, beaucoup d'autres choses inutiles ont √©t√© faites. <br><br>  <i>Enfin, notre troisi√®me erreur</i> .  Savez-vous combien de temps s'est √©coul√© depuis que le probl√®me avec SelfTester est survenu jusqu'√† ce qu'il soit r√©solu?  Bien que non, comptez-vous.  L'incident a √©t√© cr√©√© le 17/09/2018 et ferm√© le 20/02/2019, et il y a plus de 40 (quarante!) Messages l√†-bas.  Les gars, c'est beaucoup de temps!  Nous <i>nous</i> sommes <i>permis</i> de le faire <i>pendant</i> cinq mois.  Dans le m√™me temps (en parall√®le), nous nous sommes engag√©s √† prendre en charge Visual Studio 2019, √† ajouter le langage Java, √† commencer √† impl√©menter la norme MISRA C / C ++, √† am√©liorer l'analyseur C #, √† participer activement √† des conf√©rences, √† √©crire un tas d'articles, etc.  Et tous ces travaux n'ont pas re√ßu le temps des d√©veloppeurs en raison de la stupide erreur SelfTester. <br><br>  Citoyens, apprenez de nos erreurs et ne faites jamais cela.  Et nous ne le ferons pas. <br><br>  J'ai tout. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a8/a29/f94/3a8a29f94aeed35ddeaec17222a4f990.png" alt="Image 17"></div><br>  Bien s√ªr, c'est une blague, et je vais vous dire quel √©tait le probl√®me avec SelfTester :) <br><br><h2>  Bingo! </h2><br>  Heureusement, parmi nous, il y avait une personne avec la conscience la moins trouble (mon coll√®gue Sergey Vasiliev), qui vient de regarder le probl√®me sous un angle compl√®tement diff√©rent (et aussi il a eu un peu de chance).  Et si l'int√©rieur de SelfTester allait vraiment bien et que les projets cassaient quelque chose de l'ext√©rieur?  En parall√®le avec SelfTester, g√©n√©ralement rien n'a commenc√©, dans certains cas, nous contr√¥lions strictement le temps d'ex√©cution.  Dans ce cas, ce ¬´quelque chose¬ª ne peut √™tre que SelfTester lui-m√™me, mais une autre instance de celui-ci. <br><br>  En quittant SelfTester, le flux de restauration des fichiers de projet √† partir des normes continue de fonctionner pendant un certain temps.  √Ä ce stade, vous pouvez red√©marrer le testeur.  La protection contre l'ex√©cution de plusieurs instances de SelfTester en m√™me temps a √©t√© ajout√©e <i>plus tard</i> et ressemble maintenant √† ceci: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a3/7bf/437/0a37bf4373e3beb9bbfe2542afb258a0.png" alt="Image 16"></div><br>  Mais alors elle √©tait partie. <br><br>  Incroyablement, pendant pr√®s de six mois de tourments, personne n'y a pr√™t√© attention.  La restauration de projets √† partir des normes est une proc√©dure d'arri√®re-plan assez rapide, mais malheureusement pas assez rapide pour ne pas interf√©rer avec le red√©marrage de SelfTester.  Et que se passe-t-il au d√©marrage?  C'est vrai, calculer les poids de d√©cision.  Un processus √©crase les fichiers <i>.vcxproj</i> , tandis qu'un autre essaie de les lire.  Salut, <i>XmlException</i> . <br><br>  Sergey a d√©couvert tout cela en ajoutant au testeur la possibilit√© de passer au mode de travail avec un autre ensemble de journaux standard.  Le besoin s'est fait sentir apr√®s l'ajout de l'ensemble de r√®gles MISRA √† l'analyseur.  Vous pouvez basculer directement dans l'interface, pendant que l'utilisateur voit la fen√™tre: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a5/9b0/87d/0a59b087d0e13688ab41a690ed490a3f.png" alt="Image 14"></div><br>  Apr√®s quoi SelfTester <i>red√©marre</i> .  Eh bien, plus t√¥t, apparemment, les utilisateurs ont eux-m√™mes √©mul√© le probl√®me en red√©marrant le testeur. <br><br><h2>  D√©briefing et conclusions </h2><br>  Bien s√ªr, nous avons supprim√©, ou plut√¥t d√©sactiv√©, l'optimisation pr√©c√©demment cr√©√©e.  De plus, c'√©tait beaucoup plus facile que de faire une sorte de synchronisation entre le reste du testeur lui-m√™me.  Et tout a commenc√© √† bien fonctionner, comme avant.  Et comme mesure suppl√©mentaire, la protection d√©crite ci-dessus contre le lancement simultan√© du testeur a √©t√© ajout√©e. <br><br>  J'ai d√©j√† √©crit ci-dessus nos principales erreurs lors de la recherche du probl√®me, donc l'auto-flagellation suffit.  Nous sommes aussi des gens et nous nous trompons donc.  Il est important d'apprendre de vos erreurs et de tirer des conclusions.  Les conclusions ici sont assez simples: <br><br><ul><li>  Il est n√©cessaire de suivre et d'√©valuer la croissance de la complexit√© des t√¢ches; </li><li>  Arr√™tez-vous √† temps; </li><li>  Essayez de regarder le probl√®me plus largement, car au fil du temps la vue est ¬´floue¬ª et l'angle de vue se r√©tr√©cit; </li><li>  N'ayez pas peur de supprimer du code ancien ou inutile. </li></ul><br>  Maintenant, c'est s√ªr - c'est tout.  Merci d'avoir lu.  Pour tout code d√©sesp√©r√©! <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a> </p><br><br>  Si vous souhaitez partager cet article avec un public anglophone, veuillez utiliser le lien vers la traduction: Sergey Khrenov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le meilleur est l'ennemi du bien</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466741/">https://habr.com/ru/post/fr466741/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466731/index.html">Extravagance. Septembre se l√®ve</a></li>
<li><a href="../fr466733/index.html">Bienvenue √† DINS Java EVENING le 18 septembre</a></li>
<li><a href="../fr466735/index.html">Un moyen simple de cr√©er une alerte vocale dans le syst√®me domotique (¬´Smart Home¬ª)</a></li>
<li><a href="../fr466737/index.html">Pourquoi le r√©seau social Google+ a √©chou√©</a></li>
<li><a href="../fr466739/index.html">Le meilleur est l'ennemi du bien</a></li>
<li><a href="../fr466745/index.html">Le premier lieu de travail ou comment commencer √† d√©velopper une API sur Node.js</a></li>
<li><a href="../fr466747/index.html">D√©veloppeurs Mitap iOS chez Redmadrobot</a></li>
<li><a href="../fr466753/index.html">Administration r√©seau rapide et efficace - Network MACMonitor</a></li>
<li><a href="../fr466755/index.html">L'ordinateur vous rendra savoureux</a></li>
<li><a href="../fr466757/index.html">Le premier mitap Flutter √† Saint-P√©tersbourg - 26 septembre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>