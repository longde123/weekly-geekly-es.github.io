<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👼🏿 😴 🕺🏽 Die Grundlagen des GLTF- und GLB-Formats, Teil 1 🎍 👨🏿‍✈️ 👶🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Was sind GLTF und GLB? 


 GLTF (GL Transmission Format) ist ein Dateiformat zum Speichern von 3D-Szenen und -Modellen, das äußerst einfach zu versteh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Grundlagen des GLTF- und GLB-Formats, Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448220/"><h2 id="chto-takoe-gltf-i-glb">  Was sind GLTF und GLB? </h2><br><p> GLTF (GL Transmission Format) ist ein Dateiformat zum Speichern von 3D-Szenen und -Modellen, das äußerst einfach zu verstehen ist (die Struktur ist im JSON-Standard geschrieben), erweiterbar ist und problemlos mit modernen Webtechnologien interagiert.  Dieses Format komprimiert dreidimensionale Szenen gut und minimiert die Laufzeitverarbeitung von Anwendungen mithilfe von WebGL und anderen APIs.  Der GLTF wird jetzt von der Khronos Group aktiv als JPEG aus der 3D-Welt beworben.  Derzeit wird GLTF Version 2.0 verwendet.  Es gibt auch eine binäre Version dieses Formats namens GLB, deren einziger Unterschied darin besteht, dass alles in einer Datei mit der Erweiterung GLB gespeichert ist. </p><br><p>  Dieser Artikel ist Teil 1 von 2.  Darin werden <strong>Formatartefakte</strong> und ihre Attribute wie <strong>Szene, Knoten, Puffer, Pufferansicht, Accessor und Netz betrachtet</strong> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Und im zweiten Artikel werden</a> wir uns den Rest ansehen: <strong>Material, Textur, Animationen, Haut und Kamera.</strong>  Weitere allgemeine Formatinformationen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br>  Wenn Sie beim Anzeigen eines Artikels persönlich mit diesem Format arbeiten möchten, können Sie GLTF 2.0-Modelle aus dem offiziellen Khronos-Repository auf <a href="">GitHub</a> herunterladen </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/15e/e5d/a48/15ee5da4816090d71188478d4ca55299.jpg" alt="Bild"></p><br><h2 id="problematika-i-eyo-reshenie">  Das Problem und seine Lösung </h2><br><p>  Ursprünglich wurde das GLTF-Format von der Khronos Group als Lösung für die Übertragung von 3D-Inhalten über das Internet konzipiert und so konzipiert, dass die Anzahl der Importeure und Konverter minimiert wird, von denen beim Arbeiten mit grafischen APIs verschiedene Arten erstellt werden. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/4fd/258/dbe/4fd258dbe0327507b5217d1989cab6f1.png" alt="Bild"><br><p>  Derzeit werden GLTF und sein binärer Bruder GLB als einheitliche Formate in CAD-Programmen (Autodesk Maya, Blender usw.), in Game-Engines (Unreal Engine, Unity usw.), AR / VR-Anwendungen und sozialen Diensten verwendet.  Netzwerke usw. </p><a name="habracut"></a><br><p>  Vertreter der Khronos-Gruppe geben Folgendes an: </p><br><ol><li>  GLTF ist universell - es kann sowohl für einfache Geometrie als auch für komplexe Szenen mit Animationen, verschiedenen Materialien usw. verwendet werden. </li><li>  Es ist ziemlich kompakt.  Ja, dies kann argumentiert werden, da alles von den Konvertierungsalgorithmen abhängt und ich persönlich Fälle kenne, in denen GLTF größer als das Original war, z. B. FBX-Datei, aber in den meisten Fällen ist dies der Fall. </li><li>  Die einfache Datenanalyse ist das Plus dieses Formats.  Die GLTF-Hierarchie verwendet JSON und die Geometrie wird in binärer Form gespeichert. Es ist keine Dekodierung erforderlich! </li></ol><br><h2 id="sistema-koordinat-i-edinicy-izmereniya">  Koordinatensystem und Einheiten </h2><br><p>  GLTF verwendet ein rechtshändiges Koordinatensystem, dh das Kreuzprodukt von + X und + Y ergibt + Z, wobei + Y die obere Achse ist.  Die Vorderseite des 3D-GLTF-Assets zeigt zur + Z-Achse.  Die Maßeinheiten für alle linearen Abstände sind Meter, die Winkel werden im Bogenmaß gemessen und die positive Drehung von Objekten erfolgt gegen den Uhrzeigersinn.  Knotentransformationen und Kanalpfade von Animationen sind dreidimensionale Vektoren oder Quaternionen mit den folgenden Datentypen und Semantiken: </p><br><p>  <strong>Translation</strong> : Ein dreidimensionaler Vektor, der die Translation entlang der x-, y- und z-Achse enthält <br>  <strong>Rotation</strong> : Quaternion (x, y, z, w), wobei w ein Skalar ist <br>  <strong>Maßstab</strong> : Ein dreidimensionaler Vektor, der x-, y- und z-Skalierungsfaktoren enthält <br><img src="https://habrastorage.org/getpro/habr/post_images/6ae/873/435/6ae873435487db304a902cfb4f080387.png" alt="Bild"></p><br><h2 id="gltf---vzglyad-iznutri">  GLTF - ein Einblick </h2><br><p>  Wie oben erwähnt, besteht GLTF in der Regel aus zwei Dateien: der ersten mit dem .gltf-Format, in dem die Struktur der 3D-Szene in Form von JSON gespeichert ist, und der zweiten Datei mit dem .bin-Format, in der alle Daten dieser Szene direkt gespeichert sind. </p><br><p>  Die Formatstruktur ist streng hierarchisch und hat folgende Form: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/798/479/f31/798479f318326cba199da97f7570320c.png" alt="Bild"></p><br><p>  Wenn ich weiter über die Struktur spreche, werde ich Beispiele der einfachsten GLTF-Datei verwenden, in der 1 einseitiges Dreieck mit dem Standardmaterial gespeichert ist.  Wenn Sie möchten, können Sie es kopieren und in einen beliebigen GLTF-Viewer einfügen, um den Inhalt der Datei persönlich zu "fühlen".  In meiner Praxis habe ich verschiedene verwendet, mich aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dafür entschieden</a> , dass Three.js unter der Haube verwendet wird.  Eine gute Option wäre auch die Verwendung von Visual Studio Code mit dem GLTF-Plugin.  Sie haben also sofort die Wahl zwischen 3 Motoren: Babylon.js, Caesium, Three.js </p><br><h2 id="scene-i-node-elementy">  Szenen- und Knotenelemente </h2><br><p>  Das Wichtigste zuerst ist der Hauptknoten namens Szene.  Dies ist der Stammpunkt in der Datei, an dem alles beginnt.  Dieser Knoten enthält eine Reihe von Szenen, die GLTF speichert, und die Auswahl der Szenen, die standardmäßig nach dem Öffnen der Datei geladen werden.  Der Inhalt der 3D-Szene beginnt mit dem nächsten Objekt, das als „Knoten“ bezeichnet wird.  Eine Reihe von Szenen und Knoten wurde nicht umsonst erwähnt, weil  Die Möglichkeit, mehrere Szenen in einer Datei zu speichern, ist implementiert. In der Praxis wird jedoch versucht, eine Szene in einer Datei zu speichern. </p><br><pre><code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"scenes"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"nodes"</span></span> : [ <span class="hljs-number"><span class="hljs-number">0</span></span> ] } ], <span class="hljs-attr"><span class="hljs-attr">"nodes"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"mesh"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"scene"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br><p>  Jeder Knoten ist ein „Einstiegspunkt“ zur Beschreibung einzelner Objekte.  Wenn das Objekt komplex ist und aus mehreren Maschen besteht, wird ein solches Objekt durch die Knoten "Eltern" und "Kind" beschrieben.  Beispielsweise kann ein Auto, das aus einer Karosserie und Rädern besteht, wie folgt beschrieben werden: Der Hauptknoten beschreibt das Auto und insbesondere seine Karosserie.  Dieser Knoten enthält eine Liste von „untergeordneten Knoten“, die wiederum die verbleibenden Komponenten beschreiben, wie z. B. Räder.  Alle Elemente werden rekursiv verarbeitet.  Knoten können TRS-Animationen (Translation, Rotation, Scale aka Displacement, Rotation und Scaling) enthalten.  Neben der Tatsache, dass solche Transformationen das Netz selbst direkt beeinflussen, wirken sie sich genauso auf untergeordnete Knoten aus.  Zusätzlich zu all dem oben Genannten ist es erwähnenswert, dass die internen "Kameras", falls vorhanden, die für die Anzeige des Objekts im Rahmen für den Benutzer verantwortlich sind, auch an das Knotenobjekt angehängt sind.  Objekte verweisen unter Verwendung der entsprechenden Attribute aufeinander: Szene hat ein Knotenattribut, ein Knotenobjekt hat ein Netzattribut.  Zum einfacheren Verständnis sind alle oben genannten Punkte in der folgenden Abbildung dargestellt. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/53d/e95/3af/53de953af178091e6a696c12530b38a8.png" alt="Bild"></p><br><h2 id="buffer-bufferview-i-accessor">  Buffer, BufferView und Accessor </h2><br><p>  Pufferobjekt bedeutet Speicherung von binären, unverarbeiteten Daten ohne Struktur, ohne Vererbung, ohne Wert.  Der Puffer speichert Informationen zu Geometrie, Animationen und Skinning.  Der Hauptvorteil von Binärdaten besteht darin, dass sie von der GPU äußerst effizient verarbeitet werden  erfordern keine zusätzliche Analyse, außer möglicherweise Dekomprimierung.  Die Daten im Puffer können durch das URI-Attribut gefunden werden, wodurch deutlich wird, wo sich die Daten befinden, und es gibt nur zwei Optionen: Entweder werden die Daten in einer externen Datei im .bin-Format gespeichert oder sie sind in JSON selbst eingebettet.  Im ersten Fall enthält der URI einen Link zu einer externen Datei. In diesem Fall wird der Ordner, in dem sich die GLTF-Datei befindet, als Stammverzeichnis betrachtet.  Im zweiten Fall hat die Datei das .glb-Format, was uns auf das kompaktere GLTF-Zwillingsbruder, das GLB-Format, in Bezug auf die Anzahl der Dateien verweist.  Die Daten in der Binärdatei werden byteweise gespeichert. </p><br><img src="https://habrastorage.org/webt/ls/9i/51/ls9i51hrvcaoxqmd5g8evlt3bou.png"><br><p>  JSON in unserem Dreiecksbeispiel sieht folgendermaßen aus: <br>  Ein Beispiel für einen Base64-codierten Puffer: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"buffers"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"uri"</span></span> : <span class="hljs-string"><span class="hljs-string">"data:application/octet-stream;base64,AAABAAIAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAA="</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteLength"</span></span> : <span class="hljs-number"><span class="hljs-number">44</span></span> } ],</code> </pre> <br><p>  Wenn Sie eine externe Datei haben, konvertiert JSON die Ansicht in Folgendes: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"buffers"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"uri"</span></span> : <span class="hljs-string"><span class="hljs-string">"duck.bin"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteLength"</span></span> : <span class="hljs-number"><span class="hljs-number">102040</span></span> } ],</code> </pre> <br><p>  Der Pufferblock verfügt außerdem über ein zusätzliches Attribut byteLength, in dem der Wert der Puffergröße gespeichert wird. </p><br><p>  Der erste Schritt bei der Strukturierung der Daten aus dem Puffer ist das BufferView-Objekt.  BufferView kann als "Informationsscheibe" von Buffer bezeichnet werden, die durch eine bestimmte Verschiebung von Bytes vom Anfang des Puffers gekennzeichnet ist.  Dieses "Slice" wird anhand von zwei Attributen beschrieben: der Anzahl der "Verschiebungen" vom Anfang des Lesepuffers und der Länge des Slice selbst.  Ein einfaches Beispiel für mehrere BufferView-Objekte zur Veranschaulichung ihrer Verwendung anhand unseres Beispiels: </p><br><pre> <code class="json hljs"> <span class="hljs-string"><span class="hljs-string">"bufferViews"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"buffer"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteOffset"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteLength"</span></span> : <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span> : <span class="hljs-number"><span class="hljs-number">34963</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"buffer"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteOffset"</span></span> : <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteLength"</span></span> : <span class="hljs-number"><span class="hljs-number">36</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span> : <span class="hljs-number"><span class="hljs-number">34962</span></span> } ],</code> </pre> <br><p>  Wie Sie sehen können, enthält dieses Beispiel 4 Hauptattribute: </p><br><ol><li>  <strong>Der Puffer</strong> zeigt auf den Index des Puffers (die Sequenznummer im Pufferarray beginnt bei 0). </li><li>  <strong>byteOffset</strong> - definiert die "Verschiebung" des Ursprungs in Bytes für dieses "Slice" </li><li>  <strong>byteLength</strong> - definiert die Länge des "Slice" </li><li>  <strong>Ziel</strong> - Definiert den Datentyp, der in bufferView enthalten ist <br>  Die erste BufferView enthält die ersten 6 Bytes des Puffers und hat keine Verschiebung.  Beim zweiten „Slice“ ist alles etwas komplizierter: Wie Sie sehen, liegt die Verschiebung bei 8 MB anstelle des erwarteten sechsten.  Diese 2 Bytes sind leer und wurden während des Puffergenerierungsprozesses dank eines Prozesses namens "Auffüllen" hinzugefügt.  Der Wert muss den Wert der Grenzbytes auf 4 Bytes einstellen.  Dieser Trick wird zum schnelleren und einfacheren Lesen von Daten aus dem Puffer benötigt. </li></ol><br><p><img src="https://habrastorage.org/getpro/habr/post_images/300/8ea/c51/3008eac517a098df5794092bbce27af6.png" alt="Bild"></p><br><p>  Es lohnt sich, ein paar Worte über das Zielattribut zu sagen.  Es wird verwendet, um den Informationstyp zu klassifizieren, auf den bufferView verweist.  Es gibt nur zwei Optionen: Entweder ist es der Wert 34962, der verwendet wird, um auf die Scheitelpunktattribute (Scheitelpunktattribute - 34962 - ARRAY_BUFFER) zu verweisen, oder 34963, der für die Scheitelpunktindizes (Scheitelpunktindizes - 34963 - ELEMENT_ARRAY_BUFFER) verwendet wird.  Der letzte Schliff für das Verständnis und die Strukturierung aller Informationen in Buffer ist das Accessor-Objekt. </p><br><p>  <strong>Accessor</strong> ist ein Objekt, das auf BufferView zugreift und Attribute enthält, die den Typ und den Speicherort von Daten aus BufferView bestimmen.  Der Accessor-Datentyp ist in type und componentType codiert.  Der Wert des Typattributs ist eine Zeichenfolge und hat die folgenden Werte: SCALAR für Skalarwerte, VEC3 für dreidimensionale Vektoren und MAT4 für eine 4x4-Matrix oder das Quaternion, das zur Beschreibung der Rotation verwendet wird. </p><br><p>  ComponentType gibt wiederum den Komponententyp dieser Daten an.  Dies ist eine GL-Konstante, die Werte wie 5126 (FLOAT) oder 5123 (UNSIGNED_SHORT) haben kann, um beispielsweise anzuzeigen, dass die Elemente einen Gleitkomma usw. haben. </p><br><p>  Verschiedene Kombinationen dieser Eigenschaften können verwendet werden, um beliebige Datentypen zu beschreiben.  Ein Beispiel basierend auf unserem Dreieck. </p><br><pre> <code class="json hljs"> <span class="hljs-string"><span class="hljs-string">"accessors"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"bufferView"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteOffset"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"componentType"</span></span> : <span class="hljs-number"><span class="hljs-number">5123</span></span>, <span class="hljs-attr"><span class="hljs-attr">"count"</span></span> : <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"SCALAR"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"max"</span></span> : [ <span class="hljs-number"><span class="hljs-number">2</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"min"</span></span> : [ <span class="hljs-number"><span class="hljs-number">0</span></span> ] }, { <span class="hljs-attr"><span class="hljs-attr">"bufferView"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteOffset"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"componentType"</span></span> : <span class="hljs-number"><span class="hljs-number">5126</span></span>, <span class="hljs-attr"><span class="hljs-attr">"count"</span></span> : <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"VEC3"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"max"</span></span> : [ <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"min"</span></span> : [ <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span> ] } ],</code> </pre> <br><p>  Lassen Sie uns die in JSON dargestellten Attribute analysieren: </p><br><ol><li>  <strong>bufferView</strong> - <strong>Gibt</strong> die Sequenznummer der BufferView aus dem von Accessor verwendeten BufferView-Array an.  BufferView speichert wiederum Informationen zu Indizes. </li><li>  <strong>byteOffset</strong> - <strong>Byteverschiebung</strong> , um mit dem Lesen von Daten vom aktuellen Accessor zu beginnen.  Mehrere Accessor-Objekte können auf eine BufferView verweisen. </li><li>  <strong>componentType</strong> ist eine Konstante, die den Typ der Elemente angibt.  Es kann Werte 5123 haben, die dem Datentyp UNSIGNED_SHORT entsprechen, oder 5126 für FLOAT. </li><li>  <strong>count</strong> - Zeigt an, wie viele Elemente im Puffer gespeichert sind. </li><li>  <strong>Typ</strong> - Definiert den Datentyp: Skalar, Vektor, Matrix. </li><li>  <strong>max</strong> und <strong>min</strong> - Attribute, die den minimalen und maximalen Wert der Position dieser Elemente im Raum bestimmen. </li></ol><br><h2 id="mesh">  Mesh </h2><br><p>  Das <strong>Meshes-</strong> Objekt enthält Informationen zu den in der Szene befindlichen <strong>Meshes</strong> .  Ein Knoten (Knotenobjekt) kann nur 1 Netz speichern.  Jedes Objekt vom Typ mesh enthält ein Array vom Typ mesh.primitive Primitive wiederum sind primitive Objekte (z. B. Dreiecke), aus denen das Netz selbst besteht.  Dieses Objekt enthält viele zusätzliche Attribute, aber all dies dient einem Zweck - der korrekten Speicherung von Informationen über die Anzeige des Objekts.  Die Hauptattribute des Netzes: </p><br><ol><li>  <strong>POSITION</strong> - Position der Eckpunkte entlang der XYZ-Achsen </li><li>  <strong>NORMAL</strong> - Normalisierte XYZ-Scheitelpunktnormalen </li><li>  <strong>TANGENT</strong> - XYZW-Tangenten von Eckpunkten.  W gibt an, wohin die Tangente gerichtet ist und hat einen Wert von entweder +1 oder -1. </li><li>  <strong>TEXCOORD_0</strong> - UV-Texturkoordinaten.  Es können mehrere Sets gespeichert werden. </li><li>  <strong>COLOR_0</strong> - RGB- oder RGBA-Farben von Eckpunkten. </li><li>  <strong>JOINTS_0</strong> - Dieses Attribut enthält die Indizes der Gelenke / Gelenke aus dem entsprechenden <strong>Gelenkarray</strong> , die sich auf den Scheitelpunkt (Scheitelpunkt) auswirken sollten. </li><li>  <strong>WEIGHTS_0</strong> - Die Daten dieses Attributs bestimmen die Gewichte, die angeben, wie stark das Gelenk den Scheitelpunkt beeinflusst. </li><li>  <strong>Gewichte</strong> - Attribut, das für die Morphing-Gewichte verantwortlich ist. </li><li>  <strong>material</strong> - enthält den Index, der die Anzahl der Materialien im Materials-Array angibt </li></ol><br><p>  Dieses Objekt hat für unseren Fall die folgende Form: </p><br><pre> <code class="json hljs"> <span class="hljs-string"><span class="hljs-string">"meshes"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"primitives"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"attributes"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"POSITION"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"indices"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> } ] } ],</code> </pre> <br><p>  Leider passte aufgrund der Einschränkung nicht das gesamte Material in einen Artikel, sodass der Rest <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im zweiten Artikel zu finden ist</a> , in dem wir die verbleibenden Artefakte betrachten: <strong>Material, Textur, Animationen, Haut und Kamera</strong> sowie eine minimal funktionierende GLTF-Datei sammeln. </p><br><p>  Fortsetzung im 2. Teil: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://habr.com/en/post/448298/</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448220/">https://habr.com/ru/post/de448220/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448210/index.html">Kanone für Satelliten, einen Blaster und ein Solarschiff: neugierige und paradoxe Projekte</a></li>
<li><a href="../de448212/index.html">AIBUS Chinesisches Protokoll und chemischer Laborreaktor</a></li>
<li><a href="../de448214/index.html">ES6 Proxies in der Praxis</a></li>
<li><a href="../de448216/index.html">Richten Sie eine bequeme Zusammenstellung von Projekten in Visual Studio ein</a></li>
<li><a href="../de448218/index.html">Neue MFP-Sicherheit: imageRUNNER ADVANCE III</a></li>
<li><a href="../de448222/index.html">GPU, hexagonale Beschleuniger und lineare Algebra</a></li>
<li><a href="../de448224/index.html">AppsConf, um sie alle zu regieren</a></li>
<li><a href="../de448226/index.html">Auf der Suche nach dem einen (Themen für AppsConf melden)</a></li>
<li><a href="../de448228/index.html">Arten der Modellierung. Grundlagen der Bildhauerei, Retopologie und Sweep</a></li>
<li><a href="../de448230/index.html">Verwalten der Geschäftskontinuität mit ClearView</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>