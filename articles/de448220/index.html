<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëºüèø üò¥ üï∫üèΩ Die Grundlagen des GLTF- und GLB-Formats, Teil 1 üéç üë®üèø‚Äç‚úàÔ∏è üë∂üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Was sind GLTF und GLB? 


 GLTF (GL Transmission Format) ist ein Dateiformat zum Speichern von 3D-Szenen und -Modellen, das √§u√üerst einfach zu versteh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Grundlagen des GLTF- und GLB-Formats, Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448220/"><h2 id="chto-takoe-gltf-i-glb">  Was sind GLTF und GLB? </h2><br><p> GLTF (GL Transmission Format) ist ein Dateiformat zum Speichern von 3D-Szenen und -Modellen, das √§u√üerst einfach zu verstehen ist (die Struktur ist im JSON-Standard geschrieben), erweiterbar ist und problemlos mit modernen Webtechnologien interagiert.  Dieses Format komprimiert dreidimensionale Szenen gut und minimiert die Laufzeitverarbeitung von Anwendungen mithilfe von WebGL und anderen APIs.  Der GLTF wird jetzt von der Khronos Group aktiv als JPEG aus der 3D-Welt beworben.  Derzeit wird GLTF Version 2.0 verwendet.  Es gibt auch eine bin√§re Version dieses Formats namens GLB, deren einziger Unterschied darin besteht, dass alles in einer Datei mit der Erweiterung GLB gespeichert ist. </p><br><p>  Dieser Artikel ist Teil 1 von 2.  Darin werden <strong>Formatartefakte</strong> und ihre Attribute wie <strong>Szene, Knoten, Puffer, Pufferansicht, Accessor und Netz betrachtet</strong> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Und im zweiten Artikel werden</a> wir uns den Rest ansehen: <strong>Material, Textur, Animationen, Haut und Kamera.</strong>  Weitere allgemeine Formatinformationen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br>  Wenn Sie beim Anzeigen eines Artikels pers√∂nlich mit diesem Format arbeiten m√∂chten, k√∂nnen Sie GLTF 2.0-Modelle aus dem offiziellen Khronos-Repository auf <a href="">GitHub</a> herunterladen </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/15e/e5d/a48/15ee5da4816090d71188478d4ca55299.jpg" alt="Bild"></p><br><h2 id="problematika-i-eyo-reshenie">  Das Problem und seine L√∂sung </h2><br><p>  Urspr√ºnglich wurde das GLTF-Format von der Khronos Group als L√∂sung f√ºr die √úbertragung von 3D-Inhalten √ºber das Internet konzipiert und so konzipiert, dass die Anzahl der Importeure und Konverter minimiert wird, von denen beim Arbeiten mit grafischen APIs verschiedene Arten erstellt werden. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/4fd/258/dbe/4fd258dbe0327507b5217d1989cab6f1.png" alt="Bild"><br><p>  Derzeit werden GLTF und sein bin√§rer Bruder GLB als einheitliche Formate in CAD-Programmen (Autodesk Maya, Blender usw.), in Game-Engines (Unreal Engine, Unity usw.), AR / VR-Anwendungen und sozialen Diensten verwendet.  Netzwerke usw. </p><a name="habracut"></a><br><p>  Vertreter der Khronos-Gruppe geben Folgendes an: </p><br><ol><li>  GLTF ist universell - es kann sowohl f√ºr einfache Geometrie als auch f√ºr komplexe Szenen mit Animationen, verschiedenen Materialien usw. verwendet werden. </li><li>  Es ist ziemlich kompakt.  Ja, dies kann argumentiert werden, da alles von den Konvertierungsalgorithmen abh√§ngt und ich pers√∂nlich F√§lle kenne, in denen GLTF gr√∂√üer als das Original war, z. B. FBX-Datei, aber in den meisten F√§llen ist dies der Fall. </li><li>  Die einfache Datenanalyse ist das Plus dieses Formats.  Die GLTF-Hierarchie verwendet JSON und die Geometrie wird in bin√§rer Form gespeichert. Es ist keine Dekodierung erforderlich! </li></ol><br><h2 id="sistema-koordinat-i-edinicy-izmereniya">  Koordinatensystem und Einheiten </h2><br><p>  GLTF verwendet ein rechtsh√§ndiges Koordinatensystem, dh das Kreuzprodukt von + X und + Y ergibt + Z, wobei + Y die obere Achse ist.  Die Vorderseite des 3D-GLTF-Assets zeigt zur + Z-Achse.  Die Ma√üeinheiten f√ºr alle linearen Abst√§nde sind Meter, die Winkel werden im Bogenma√ü gemessen und die positive Drehung von Objekten erfolgt gegen den Uhrzeigersinn.  Knotentransformationen und Kanalpfade von Animationen sind dreidimensionale Vektoren oder Quaternionen mit den folgenden Datentypen und Semantiken: </p><br><p>  <strong>Translation</strong> : Ein dreidimensionaler Vektor, der die Translation entlang der x-, y- und z-Achse enth√§lt <br>  <strong>Rotation</strong> : Quaternion (x, y, z, w), wobei w ein Skalar ist <br>  <strong>Ma√üstab</strong> : Ein dreidimensionaler Vektor, der x-, y- und z-Skalierungsfaktoren enth√§lt <br><img src="https://habrastorage.org/getpro/habr/post_images/6ae/873/435/6ae873435487db304a902cfb4f080387.png" alt="Bild"></p><br><h2 id="gltf---vzglyad-iznutri">  GLTF - ein Einblick </h2><br><p>  Wie oben erw√§hnt, besteht GLTF in der Regel aus zwei Dateien: der ersten mit dem .gltf-Format, in dem die Struktur der 3D-Szene in Form von JSON gespeichert ist, und der zweiten Datei mit dem .bin-Format, in der alle Daten dieser Szene direkt gespeichert sind. </p><br><p>  Die Formatstruktur ist streng hierarchisch und hat folgende Form: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/798/479/f31/798479f318326cba199da97f7570320c.png" alt="Bild"></p><br><p>  Wenn ich weiter √ºber die Struktur spreche, werde ich Beispiele der einfachsten GLTF-Datei verwenden, in der 1 einseitiges Dreieck mit dem Standardmaterial gespeichert ist.  Wenn Sie m√∂chten, k√∂nnen Sie es kopieren und in einen beliebigen GLTF-Viewer einf√ºgen, um den Inhalt der Datei pers√∂nlich zu "f√ºhlen".  In meiner Praxis habe ich verschiedene verwendet, mich aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">daf√ºr entschieden</a> , dass Three.js unter der Haube verwendet wird.  Eine gute Option w√§re auch die Verwendung von Visual Studio Code mit dem GLTF-Plugin.  Sie haben also sofort die Wahl zwischen 3 Motoren: Babylon.js, Caesium, Three.js </p><br><h2 id="scene-i-node-elementy">  Szenen- und Knotenelemente </h2><br><p>  Das Wichtigste zuerst ist der Hauptknoten namens Szene.  Dies ist der Stammpunkt in der Datei, an dem alles beginnt.  Dieser Knoten enth√§lt eine Reihe von Szenen, die GLTF speichert, und die Auswahl der Szenen, die standardm√§√üig nach dem √ñffnen der Datei geladen werden.  Der Inhalt der 3D-Szene beginnt mit dem n√§chsten Objekt, das als ‚ÄûKnoten‚Äú bezeichnet wird.  Eine Reihe von Szenen und Knoten wurde nicht umsonst erw√§hnt, weil  Die M√∂glichkeit, mehrere Szenen in einer Datei zu speichern, ist implementiert. In der Praxis wird jedoch versucht, eine Szene in einer Datei zu speichern. </p><br><pre><code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"scenes"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"nodes"</span></span> : [ <span class="hljs-number"><span class="hljs-number">0</span></span> ] } ], <span class="hljs-attr"><span class="hljs-attr">"nodes"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"mesh"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"scene"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br><p>  Jeder Knoten ist ein ‚ÄûEinstiegspunkt‚Äú zur Beschreibung einzelner Objekte.  Wenn das Objekt komplex ist und aus mehreren Maschen besteht, wird ein solches Objekt durch die Knoten "Eltern" und "Kind" beschrieben.  Beispielsweise kann ein Auto, das aus einer Karosserie und R√§dern besteht, wie folgt beschrieben werden: Der Hauptknoten beschreibt das Auto und insbesondere seine Karosserie.  Dieser Knoten enth√§lt eine Liste von ‚Äûuntergeordneten Knoten‚Äú, die wiederum die verbleibenden Komponenten beschreiben, wie z. B. R√§der.  Alle Elemente werden rekursiv verarbeitet.  Knoten k√∂nnen TRS-Animationen (Translation, Rotation, Scale aka Displacement, Rotation und Scaling) enthalten.  Neben der Tatsache, dass solche Transformationen das Netz selbst direkt beeinflussen, wirken sie sich genauso auf untergeordnete Knoten aus.  Zus√§tzlich zu all dem oben Genannten ist es erw√§hnenswert, dass die internen "Kameras", falls vorhanden, die f√ºr die Anzeige des Objekts im Rahmen f√ºr den Benutzer verantwortlich sind, auch an das Knotenobjekt angeh√§ngt sind.  Objekte verweisen unter Verwendung der entsprechenden Attribute aufeinander: Szene hat ein Knotenattribut, ein Knotenobjekt hat ein Netzattribut.  Zum einfacheren Verst√§ndnis sind alle oben genannten Punkte in der folgenden Abbildung dargestellt. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/53d/e95/3af/53de953af178091e6a696c12530b38a8.png" alt="Bild"></p><br><h2 id="buffer-bufferview-i-accessor">  Buffer, BufferView und Accessor </h2><br><p>  Pufferobjekt bedeutet Speicherung von bin√§ren, unverarbeiteten Daten ohne Struktur, ohne Vererbung, ohne Wert.  Der Puffer speichert Informationen zu Geometrie, Animationen und Skinning.  Der Hauptvorteil von Bin√§rdaten besteht darin, dass sie von der GPU √§u√üerst effizient verarbeitet werden  erfordern keine zus√§tzliche Analyse, au√üer m√∂glicherweise Dekomprimierung.  Die Daten im Puffer k√∂nnen durch das URI-Attribut gefunden werden, wodurch deutlich wird, wo sich die Daten befinden, und es gibt nur zwei Optionen: Entweder werden die Daten in einer externen Datei im .bin-Format gespeichert oder sie sind in JSON selbst eingebettet.  Im ersten Fall enth√§lt der URI einen Link zu einer externen Datei. In diesem Fall wird der Ordner, in dem sich die GLTF-Datei befindet, als Stammverzeichnis betrachtet.  Im zweiten Fall hat die Datei das .glb-Format, was uns auf das kompaktere GLTF-Zwillingsbruder, das GLB-Format, in Bezug auf die Anzahl der Dateien verweist.  Die Daten in der Bin√§rdatei werden byteweise gespeichert. </p><br><img src="https://habrastorage.org/webt/ls/9i/51/ls9i51hrvcaoxqmd5g8evlt3bou.png"><br><p>  JSON in unserem Dreiecksbeispiel sieht folgenderma√üen aus: <br>  Ein Beispiel f√ºr einen Base64-codierten Puffer: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"buffers"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"uri"</span></span> : <span class="hljs-string"><span class="hljs-string">"data:application/octet-stream;base64,AAABAAIAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAACAPwAAAAA="</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteLength"</span></span> : <span class="hljs-number"><span class="hljs-number">44</span></span> } ],</code> </pre> <br><p>  Wenn Sie eine externe Datei haben, konvertiert JSON die Ansicht in Folgendes: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"buffers"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"uri"</span></span> : <span class="hljs-string"><span class="hljs-string">"duck.bin"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteLength"</span></span> : <span class="hljs-number"><span class="hljs-number">102040</span></span> } ],</code> </pre> <br><p>  Der Pufferblock verf√ºgt au√üerdem √ºber ein zus√§tzliches Attribut byteLength, in dem der Wert der Puffergr√∂√üe gespeichert wird. </p><br><p>  Der erste Schritt bei der Strukturierung der Daten aus dem Puffer ist das BufferView-Objekt.  BufferView kann als "Informationsscheibe" von Buffer bezeichnet werden, die durch eine bestimmte Verschiebung von Bytes vom Anfang des Puffers gekennzeichnet ist.  Dieses "Slice" wird anhand von zwei Attributen beschrieben: der Anzahl der "Verschiebungen" vom Anfang des Lesepuffers und der L√§nge des Slice selbst.  Ein einfaches Beispiel f√ºr mehrere BufferView-Objekte zur Veranschaulichung ihrer Verwendung anhand unseres Beispiels: </p><br><pre> <code class="json hljs"> <span class="hljs-string"><span class="hljs-string">"bufferViews"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"buffer"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteOffset"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteLength"</span></span> : <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span> : <span class="hljs-number"><span class="hljs-number">34963</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"buffer"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteOffset"</span></span> : <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteLength"</span></span> : <span class="hljs-number"><span class="hljs-number">36</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span> : <span class="hljs-number"><span class="hljs-number">34962</span></span> } ],</code> </pre> <br><p>  Wie Sie sehen k√∂nnen, enth√§lt dieses Beispiel 4 Hauptattribute: </p><br><ol><li>  <strong>Der Puffer</strong> zeigt auf den Index des Puffers (die Sequenznummer im Pufferarray beginnt bei 0). </li><li>  <strong>byteOffset</strong> - definiert die "Verschiebung" des Ursprungs in Bytes f√ºr dieses "Slice" </li><li>  <strong>byteLength</strong> - definiert die L√§nge des "Slice" </li><li>  <strong>Ziel</strong> - Definiert den Datentyp, der in bufferView enthalten ist <br>  Die erste BufferView enth√§lt die ersten 6 Bytes des Puffers und hat keine Verschiebung.  Beim zweiten ‚ÄûSlice‚Äú ist alles etwas komplizierter: Wie Sie sehen, liegt die Verschiebung bei 8 MB anstelle des erwarteten sechsten.  Diese 2 Bytes sind leer und wurden w√§hrend des Puffergenerierungsprozesses dank eines Prozesses namens "Auff√ºllen" hinzugef√ºgt.  Der Wert muss den Wert der Grenzbytes auf 4 Bytes einstellen.  Dieser Trick wird zum schnelleren und einfacheren Lesen von Daten aus dem Puffer ben√∂tigt. </li></ol><br><p><img src="https://habrastorage.org/getpro/habr/post_images/300/8ea/c51/3008eac517a098df5794092bbce27af6.png" alt="Bild"></p><br><p>  Es lohnt sich, ein paar Worte √ºber das Zielattribut zu sagen.  Es wird verwendet, um den Informationstyp zu klassifizieren, auf den bufferView verweist.  Es gibt nur zwei Optionen: Entweder ist es der Wert 34962, der verwendet wird, um auf die Scheitelpunktattribute (Scheitelpunktattribute - 34962 - ARRAY_BUFFER) zu verweisen, oder 34963, der f√ºr die Scheitelpunktindizes (Scheitelpunktindizes - 34963 - ELEMENT_ARRAY_BUFFER) verwendet wird.  Der letzte Schliff f√ºr das Verst√§ndnis und die Strukturierung aller Informationen in Buffer ist das Accessor-Objekt. </p><br><p>  <strong>Accessor</strong> ist ein Objekt, das auf BufferView zugreift und Attribute enth√§lt, die den Typ und den Speicherort von Daten aus BufferView bestimmen.  Der Accessor-Datentyp ist in type und componentType codiert.  Der Wert des Typattributs ist eine Zeichenfolge und hat die folgenden Werte: SCALAR f√ºr Skalarwerte, VEC3 f√ºr dreidimensionale Vektoren und MAT4 f√ºr eine 4x4-Matrix oder das Quaternion, das zur Beschreibung der Rotation verwendet wird. </p><br><p>  ComponentType gibt wiederum den Komponententyp dieser Daten an.  Dies ist eine GL-Konstante, die Werte wie 5126 (FLOAT) oder 5123 (UNSIGNED_SHORT) haben kann, um beispielsweise anzuzeigen, dass die Elemente einen Gleitkomma usw. haben. </p><br><p>  Verschiedene Kombinationen dieser Eigenschaften k√∂nnen verwendet werden, um beliebige Datentypen zu beschreiben.  Ein Beispiel basierend auf unserem Dreieck. </p><br><pre> <code class="json hljs"> <span class="hljs-string"><span class="hljs-string">"accessors"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"bufferView"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteOffset"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"componentType"</span></span> : <span class="hljs-number"><span class="hljs-number">5123</span></span>, <span class="hljs-attr"><span class="hljs-attr">"count"</span></span> : <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"SCALAR"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"max"</span></span> : [ <span class="hljs-number"><span class="hljs-number">2</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"min"</span></span> : [ <span class="hljs-number"><span class="hljs-number">0</span></span> ] }, { <span class="hljs-attr"><span class="hljs-attr">"bufferView"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"byteOffset"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"componentType"</span></span> : <span class="hljs-number"><span class="hljs-number">5126</span></span>, <span class="hljs-attr"><span class="hljs-attr">"count"</span></span> : <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"VEC3"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"max"</span></span> : [ <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"min"</span></span> : [ <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span> ] } ],</code> </pre> <br><p>  Lassen Sie uns die in JSON dargestellten Attribute analysieren: </p><br><ol><li>  <strong>bufferView</strong> - <strong>Gibt</strong> die Sequenznummer der BufferView aus dem von Accessor verwendeten BufferView-Array an.  BufferView speichert wiederum Informationen zu Indizes. </li><li>  <strong>byteOffset</strong> - <strong>Byteverschiebung</strong> , um mit dem Lesen von Daten vom aktuellen Accessor zu beginnen.  Mehrere Accessor-Objekte k√∂nnen auf eine BufferView verweisen. </li><li>  <strong>componentType</strong> ist eine Konstante, die den Typ der Elemente angibt.  Es kann Werte 5123 haben, die dem Datentyp UNSIGNED_SHORT entsprechen, oder 5126 f√ºr FLOAT. </li><li>  <strong>count</strong> - Zeigt an, wie viele Elemente im Puffer gespeichert sind. </li><li>  <strong>Typ</strong> - Definiert den Datentyp: Skalar, Vektor, Matrix. </li><li>  <strong>max</strong> und <strong>min</strong> - Attribute, die den minimalen und maximalen Wert der Position dieser Elemente im Raum bestimmen. </li></ol><br><h2 id="mesh">  Mesh </h2><br><p>  Das <strong>Meshes-</strong> Objekt enth√§lt Informationen zu den in der Szene befindlichen <strong>Meshes</strong> .  Ein Knoten (Knotenobjekt) kann nur 1 Netz speichern.  Jedes Objekt vom Typ mesh enth√§lt ein Array vom Typ mesh.primitive Primitive wiederum sind primitive Objekte (z. B. Dreiecke), aus denen das Netz selbst besteht.  Dieses Objekt enth√§lt viele zus√§tzliche Attribute, aber all dies dient einem Zweck - der korrekten Speicherung von Informationen √ºber die Anzeige des Objekts.  Die Hauptattribute des Netzes: </p><br><ol><li>  <strong>POSITION</strong> - Position der Eckpunkte entlang der XYZ-Achsen </li><li>  <strong>NORMAL</strong> - Normalisierte XYZ-Scheitelpunktnormalen </li><li>  <strong>TANGENT</strong> - XYZW-Tangenten von Eckpunkten.  W gibt an, wohin die Tangente gerichtet ist und hat einen Wert von entweder +1 oder -1. </li><li>  <strong>TEXCOORD_0</strong> - UV-Texturkoordinaten.  Es k√∂nnen mehrere Sets gespeichert werden. </li><li>  <strong>COLOR_0</strong> - RGB- oder RGBA-Farben von Eckpunkten. </li><li>  <strong>JOINTS_0</strong> - Dieses Attribut enth√§lt die Indizes der Gelenke / Gelenke aus dem entsprechenden <strong>Gelenkarray</strong> , die sich auf den Scheitelpunkt (Scheitelpunkt) auswirken sollten. </li><li>  <strong>WEIGHTS_0</strong> - Die Daten dieses Attributs bestimmen die Gewichte, die angeben, wie stark das Gelenk den Scheitelpunkt beeinflusst. </li><li>  <strong>Gewichte</strong> - Attribut, das f√ºr die Morphing-Gewichte verantwortlich ist. </li><li>  <strong>material</strong> - enth√§lt den Index, der die Anzahl der Materialien im Materials-Array angibt </li></ol><br><p>  Dieses Objekt hat f√ºr unseren Fall die folgende Form: </p><br><pre> <code class="json hljs"> <span class="hljs-string"><span class="hljs-string">"meshes"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"primitives"</span></span> : [ { <span class="hljs-attr"><span class="hljs-attr">"attributes"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"POSITION"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"indices"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> } ] } ],</code> </pre> <br><p>  Leider passte aufgrund der Einschr√§nkung nicht das gesamte Material in einen Artikel, sodass der Rest <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im zweiten Artikel zu finden ist</a> , in dem wir die verbleibenden Artefakte betrachten: <strong>Material, Textur, Animationen, Haut und Kamera</strong> sowie eine minimal funktionierende GLTF-Datei sammeln. </p><br><p>  Fortsetzung im 2. Teil: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://habr.com/en/post/448298/</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448220/">https://habr.com/ru/post/de448220/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448210/index.html">Kanone f√ºr Satelliten, einen Blaster und ein Solarschiff: neugierige und paradoxe Projekte</a></li>
<li><a href="../de448212/index.html">AIBUS Chinesisches Protokoll und chemischer Laborreaktor</a></li>
<li><a href="../de448214/index.html">ES6 Proxies in der Praxis</a></li>
<li><a href="../de448216/index.html">Richten Sie eine bequeme Zusammenstellung von Projekten in Visual Studio ein</a></li>
<li><a href="../de448218/index.html">Neue MFP-Sicherheit: imageRUNNER ADVANCE III</a></li>
<li><a href="../de448222/index.html">GPU, hexagonale Beschleuniger und lineare Algebra</a></li>
<li><a href="../de448224/index.html">AppsConf, um sie alle zu regieren</a></li>
<li><a href="../de448226/index.html">Auf der Suche nach dem einen (Themen f√ºr AppsConf melden)</a></li>
<li><a href="../de448228/index.html">Arten der Modellierung. Grundlagen der Bildhauerei, Retopologie und Sweep</a></li>
<li><a href="../de448230/index.html">Verwalten der Gesch√§ftskontinuit√§t mit ClearView</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>