<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêä üß§ üßöüèø C # Asynchronous Programming: Bagaimana kinerja Anda? üôÖüèø üéüÔ∏è üìé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini, kami telah berbicara tentang apakah akan menimpa Equals dan GetHashCode saat pemrograman dalam C #. Hari ini kita akan membahas paramet...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C # Asynchronous Programming: Bagaimana kinerja Anda?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/420627/">  Baru-baru ini, kami telah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berbicara</a> tentang apakah akan menimpa Equals dan GetHashCode saat pemrograman dalam C #.  Hari ini kita akan membahas parameter kinerja metode asinkron.  Bergabunglah sekarang! <br><br><img src="https://habrastorage.org/webt/ag/zp/yy/agzpyy85elnfvb3vg4qotz0wt6s.jpeg"><a name="habracut"></a><br><br>  Dalam dua artikel terakhir di blog msdn, kami melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">struktur internal metode asinkron dalam C #</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">poin ekstensi</a> yang disediakan oleh kompiler C # untuk mengontrol perilaku metode asinkron. <br><br>  Berdasarkan informasi dalam artikel pertama, kompiler melakukan banyak transformasi untuk membuat pemrograman asinkronik dengan sinkron mungkin.  Untuk melakukan ini, ia membuat instance dari mesin keadaan, meneruskannya ke pembangun metode asinkron, yang memanggil objek penunggu untuk tugas, dll. Tentu saja, logika seperti itu memiliki harga, tetapi berapa biayanya bagi kita? <br><br>  Sampai perpustakaan TPL muncul, operasi asinkron tidak digunakan dalam jumlah besar, oleh karena itu, biayanya tidak tinggi.  Tetapi hari ini, bahkan aplikasi yang relatif sederhana dapat melakukan ratusan, jika tidak ribuan, operasi asinkron per detik.  Pustaka tugas paralel TPL dibuat dengan beban kerja dalam pikiran, tetapi tidak ada keajaiban di sini dan Anda harus membayar semuanya. <br><br>  Untuk memperkirakan biaya metode asinkron, kami akan menggunakan contoh yang sedikit dimodifikasi dari artikel pertama. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StockPrices</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> name, <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span> price)&gt; _stockPricesCache; <span class="hljs-comment"><span class="hljs-comment">// Async version public async Task&lt;decimal&gt; GetStockPriceForAsync(string companyId) { await InitializeMapIfNeededAsync(); return DoGetPriceFromCache(companyId); } // Sync version that calls async init public decimal GetStockPriceFor(string companyId) { InitializeMapIfNeededAsync().GetAwaiter().GetResult(); return DoGetPriceFromCache(companyId); } // Purely sync version public decimal GetPriceFromCacheFor(string companyId) { InitializeMapIfNeeded(); return DoGetPriceFromCache(companyId); } private decimal DoGetPriceFromCache(string name) { foreach (var kvp in _stockPricesCache) { if (kvp.name == name) { return kvp.price; } } throw new InvalidOperationException($"Can't find price for '{name}'."); } [MethodImpl(MethodImplOptions.NoInlining)] private void InitializeMapIfNeeded() { // Similar initialization logic. } private async Task InitializeMapIfNeededAsync() { if (_stockPricesCache != null) { return; } await Task.Delay(42); // Getting the stock prices from the external source. // Generate 1000 items to make cache hit somewhat expensive _stockPricesCache = Enumerable.Range(1, Count) .Select(n =&gt; (name: n.ToString(), price: (decimal)n)) .ToList(); _stockPricesCache.Add((name: "MSFT", price: 42)); } }</span></span></code> </pre> <br>  Kelas <code>StockPrices</code> harga saham dari sumber eksternal dan memungkinkan Anda untuk meminta mereka melalui API.  Perbedaan utama dari contoh pada artikel pertama adalah transisi dari kamus ke daftar harga.  Untuk memperkirakan biaya berbagai metode asinkron dibandingkan dengan metode sinkron, operasi itu sendiri harus melakukan pekerjaan tertentu, dalam kasus kami ini adalah pencarian linear untuk harga saham. <br><br>  Metode <code>GetPricesFromCache</code> sengaja dibangun di sekitar loop sederhana untuk menghindari alokasi sumber daya. <br><br><h2>  Perbandingan metode sinkron dan metode asinkron berbasis tugas </h2><br>  Dalam pengujian kinerja pertama, kami membandingkan metode asinkron yang memanggil metode inisialisasi asinkron ( <code>GetStockPriceForAsync</code> ), metode sinkron yang memanggil metode inisialisasi asinkron ( <code>GetStockPriceFor</code> ), dan metode sinkron yang memanggil metode inisialisasi sinkron. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> StockPrices _stockPrices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StockPrices(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SyncVsAsyncBenchmark</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Warming up the cache _stockPrices.GetStockPriceForAsync("MSFT").GetAwaiter().GetResult(); } [Benchmark] public decimal GetPricesDirectlyFromCache() { return _stockPrices.GetPriceFromCacheFor("MSFT"); } [Benchmark(Baseline = true)] public decimal GetStockPriceFor() { return _stockPrices.GetStockPriceFor("MSFT"); } [Benchmark] public decimal GetStockPriceForAsync() { return _stockPrices.GetStockPriceForAsync("MSFT").GetAwaiter().GetResult(); }</span></span></code> </pre><br>  Hasilnya ditunjukkan di bawah ini: <br><br><img src="https://habrastorage.org/webt/nc/cb/zd/nccbzd9-gv5ehroih0zxvdofc20.png"><br><br>  Sudah pada tahap ini kami menerima data yang cukup menarik: <br><br><ul><li>  Metode asinkron cukup cepat.  <code>GetPricesForAsync</code> berjalan secara sinkron dalam pengujian ini dan kira-kira 15% (*) lebih lambat daripada metode yang murni sinkron. </li><li>  Metode <code>GetPricesFor</code> sinkron, yang memanggil metode <code>GetPricesFor</code> <code>InitializeMapIfNeededAsync</code> asynchronous, bahkan memiliki biaya yang lebih rendah, tetapi yang paling mengejutkan, itu tidak mengalokasikan sumber daya sama sekali (dalam kolom Alokasi dalam tabel di atas, harganya 0 untuk kedua <code>GetPricesDirectlyFromCache</code> dan <code>GetStockPriceFor</code> ). </li></ul><br>  <i>(*) Tentu saja, tidak dapat dikatakan bahwa biaya menjalankan metode asinkron secara sinkron adalah 15% untuk semua kasus yang mungkin.</i>  <i>Nilai ini secara langsung tergantung pada beban kerja yang dilakukan oleh metode.</i>  <i>Perbedaan antara overhead doa murni metode asinkron (yang tidak melakukan apa-apa) dan metode sinkron (yang tidak melakukan apa-apa) akan sangat besar.</i>  <i>Gagasan tes komparatif ini adalah untuk menunjukkan bahwa biaya metode asinkron, yang melakukan jumlah pekerjaan yang relatif kecil, relatif rendah.</i> <br><br>  Bagaimana mungkin ketika Anda memanggil <code>InitializeMapIfNeededAsync</code> , sumber daya tidak dialokasikan sama sekali?  Dalam artikel pertama dalam seri ini, saya menyebutkan bahwa metode asinkron harus mengalokasikan setidaknya satu objek di header yang dikelola - contoh tugas itu sendiri.  Mari kita bahas hal ini secara lebih rinci. <br><br><h2>  Optimasi # 1: contoh tugas caching bila memungkinkan </h2><br>  Jawaban untuk pertanyaan di atas sangat sederhana: <code>AsyncMethodBuilder</code> <b>menggunakan satu instance tugas untuk setiap operasi asinkron yang berhasil diselesaikan</b> .  Metode asinkron yang mengembalikan tugas menggunakan <code>AsyncMethodBuilder</code> dengan logika berikut dalam metode <code>SetResult</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// AsyncMethodBuilder.cs from mscorlib public void SetResult() { // Ie the resulting task for all successfully completed // methods is the same -- s_cachedCompleted. m_builder.SetResult(s_cachedCompleted); }</span></span></code> </pre> <br>  Metode <code>SetResult</code> dipanggil hanya untuk metode asinkron yang berhasil diselesaikan, dan <b>hasil yang berhasil untuk setiap metode berbasis <code>Task</code> dapat digunakan secara bebas bersama-sama</b> .  Kami bahkan dapat melacak perilaku ini dengan tes berikut: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncVoidBuilderCachesResultingTask</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = Foo(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = Foo(); Assert.AreSame(t1, t2); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } }</code> </pre><br>  Tapi ini bukan satu-satunya optimasi yang mungkin.  <code>AsyncTaskMethodBuilder&lt;T&gt;</code> mengoptimalkan pekerjaan dengan cara yang serupa: itu cache tugas untuk <code>Task&lt;bool&gt;</code> dan beberapa jenis sederhana lainnya.  Misalnya, cache semua nilai default untuk sekelompok tipe integer dan menggunakan cache khusus untuk <code>Task&lt;int&gt;</code> , menempatkan nilai dari rentang [-1;  9] (untuk lebih jelasnya, lihat <code>AsyncTaskMethodBuilder&lt;T&gt;.GetTaskForResult()</code> ). <br><br>  Ini dikonfirmasi oleh tes berikut: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncTaskBuilderCachesResultingTask</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// These values are cached Assert.AreSame(Foo(-1), Foo(-1)); Assert.AreSame(Foo(8), Foo(8)); // But these are not Assert.AreNotSame(Foo(9), Foo(9)); Assert.AreNotSame(Foo(int.MaxValue), Foo(int.MaxValue)); async Task&lt;int&gt; Foo(int n) =&gt; n; }</span></span></code> </pre><br>  <b>Jangan terlalu mengandalkan perilaku seperti itu</b> , tetapi selalu menyenangkan untuk menyadari bahwa pencipta bahasa dan platform melakukan segala yang mungkin untuk meningkatkan produktivitas dengan semua cara yang tersedia.  Caching tugas adalah metode optimisasi populer yang juga digunakan di area lain.  Sebagai contoh, implementasi baru <code>Socket</code> dalam repositori <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">corefx repo membuat</a> penggunaan metode ini secara luas dan menerapkan <a href="">tugas-tugas yang di-cache</a> jika memungkinkan. <br><br><h2>  Optimasi # 2: Menggunakan <code>ValueTask</code> </h2><br>  Metode optimasi yang dijelaskan di atas hanya berfungsi dalam beberapa kasus.  Oleh karena itu, alih-alih, kita dapat menggunakan <code>ValueTask&lt;T&gt;</code> (**), jenis nilai khusus yang mirip dengan tugas;  itu tidak akan mengalokasikan sumber daya jika metode ini berjalan secara sinkron. <br><br>  <code>ValueTask&lt;T&gt;</code> adalah kombinasi <code>T</code> dan <code>Task&lt;T&gt;</code> dibedakan: jika "nilai-tugas" selesai, maka nilai dasar akan digunakan.  Jika alokasi dasar belum habis, maka sumber daya akan dialokasikan untuk tugas tersebut. <br><br>  Jenis khusus ini membantu mencegah penyediaan tumpukan berlebihan saat melakukan operasi secara serempak.  Untuk menggunakan <code>ValueTask&lt;T&gt;</code> , Anda perlu mengubah tipe pengembalian untuk <code>GetStockPriceForAsync</code> : alih-alih <code>Task&lt;decimal&gt;</code> harus menentukan <code>ValueTask&lt;decimal&gt;</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceForAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> companyId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> InitializeMapIfNeededAsync(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DoGetPriceFromCache(companyId); }</code> </pre><br>  Sekarang kita dapat mengevaluasi perbedaan menggunakan tes komparatif tambahan: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Benchmark</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Await</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stockPricesThatYield.GetStockPriceValueTaskForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>).GetAwaiter().GetResult(); }</code> </pre><br><img src="https://habrastorage.org/webt/ek/pm/o5/ekpmo5bxsquftyndmelvwgsgjsc.png"><br><br>  Seperti yang Anda lihat, versi dengan <code>ValueTask</code> hanya sedikit lebih cepat daripada versi dengan Tugas.  Perbedaan utama adalah bahwa alokasi tumpukan dicegah.  Sebentar lagi kita akan membahas kelayakan transisi semacam itu, tetapi sebelum itu saya ingin berbicara tentang satu optimasi yang rumit. <br><br><h2>  Optimasi No. 3: meninggalkan metode asinkron dalam jalur umum </h2><br>  Jika Anda sangat sering menggunakan beberapa metode asinkron dan ingin mengurangi biaya lebih banyak lagi, saya sarankan Anda optimasi berikut: menghapus pengubah async, dan kemudian memeriksa status tugas di dalam metode dan melakukan seluruh operasi secara serempak, sepenuhnya meninggalkan pendekatan asinkron. <br><br>  Terlihat rumit?  Pertimbangkan sebuah contoh. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Optimized</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> companyId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> task = InitializeMapIfNeededAsync(); <span class="hljs-comment"><span class="hljs-comment">// Optimizing for acommon case: no async machinery involved. if (task.IsCompleted) { return new ValueTask&lt;decimal&gt;(DoGetPriceFromCache(companyId)); } return DoGetStockPricesForAsync(task, companyId); async ValueTask&lt;decimal&gt; DoGetStockPricesForAsync(Task initializeTask, string localCompanyId) { await initializeTask; return DoGetPriceFromCache(localCompanyId); } }</span></span></code> </pre><br>  Dalam kasus ini, pengubah <code>async</code> tidak digunakan dalam metode <code>GetStockPriceWithValueTaskAsync_Optimized</code> , jadi ketika menerima tugas dari metode <code>InitializeMapIfNeededAsync</code> , ia memeriksa status pelaksanaannya.  Jika tugas selesai, metode ini hanya menggunakan <code>DoGetPriceFromCache</code> untuk segera mendapatkan hasilnya.  Jika tugas inisialisasi masih berlangsung, metode memanggil fungsi lokal dan menunggu hasil. <br><br>  Menggunakan fungsi lokal bukan satu-satunya, tetapi salah satu cara termudah.  Tapi ada satu peringatan.  Selama implementasi paling alami, fungsi lokal akan menerima keadaan eksternal (variabel dan argumen lokal): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Optimized2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> companyId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Oops! This will lead to a closure allocation at the beginning of the method! var task = InitializeMapIfNeededAsync(); // Optimizing for acommon case: no async machinery involved. if (task.IsCompleted) { return new ValueTask&lt;decimal&gt;(DoGetPriceFromCache(companyId)); } return DoGetStockPricesForAsync(); async ValueTask&lt;decimal&gt; DoGetStockPricesForAsync() { await task; return DoGetPriceFromCache(companyId); } }</span></span></code> </pre><br>  Tapi, sayangnya, karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kesalahan kompiler,</a> kode ini akan menghasilkan penutupan, bahkan jika metode ini dieksekusi dalam jalur umum.  Begini cara metode ini terlihat dari dalam: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Optimized</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> companyId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> closure = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> __DisplayClass0_0() { __this = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, companyId = companyId, task = InitializeMapIfNeededAsync() }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (closure.task.IsCompleted) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ... } <span class="hljs-comment"><span class="hljs-comment">// The rest of the code }</span></span></code> </pre><br>  Seperti dibahas dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Membedah fungsi lokal di C #</a> , kompiler menggunakan contoh umum dari penutupan untuk semua variabel lokal dan argumen di area tertentu.  Akibatnya, ada beberapa perasaan dalam pembuatan kode seperti itu, tetapi itu membuat seluruh perjuangan dengan mengalokasikan tumpukan tidak berguna. <br><br>  <b>TIP</b> .  Optimalisasi seperti itu adalah hal yang sangat berbahaya.  Manfaatnya dapat diabaikan, dan bahkan jika Anda menulis fungsi lokal asli yang <b>benar</b> , Anda dapat secara tidak sengaja mendapatkan status eksternal yang menyebabkan tumpukan dialokasikan.  Anda masih dapat menggunakan optimasi jika Anda bekerja dengan pustaka yang umum digunakan (misalnya, BCL) dalam metode yang pasti akan digunakan pada bagian kode yang dimuat. <br><br><h4>  Biaya yang terkait dengan menunggu tugas </h4><br>  Saat ini, kami hanya mempertimbangkan satu kasus khusus: overhead metode asinkron yang berjalan secara sinkron.  Ini dilakukan dengan sengaja.  Semakin kecil metode sinkron, semakin terlihat biaya dalam kinerjanya secara keseluruhan.  Metode asinkron yang lebih terperinci, sebagai aturan, berjalan secara sinkron dan melakukan beban kerja yang lebih kecil.  Dan kami biasanya memanggil mereka lebih sering. <br><br>  Tetapi kita harus menyadari biaya dari mekanisme asinkron ketika metode ‚Äúmenunggu‚Äù untuk penyelesaian tugas yang luar biasa.  Untuk memperkirakan biaya ini, kami akan melakukan perubahan ke <code>InitializeMapIfNeededAsync</code> dan akan memanggil <code>Task.Yield()</code> bahkan ketika cache diinisialisasi: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeMapIfNeededAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_stockPricesCache != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Yield(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// Old initialization logic }</span></span></code> </pre><br>  Kami menambahkan metode berikut ke paket benchmark kami untuk pengujian perbandingan: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Benchmark</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceFor_Await</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stockPricesThatYield.GetStockPriceFor(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>); } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceForAsync_Await</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stockPricesThatYield.GetStockPriceForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>).GetAwaiter().GetResult(); } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Await</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stockPricesThatYield.GetStockPriceValueTaskForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>).GetAwaiter().GetResult(); }</code> </pre><br><img src="https://habrastorage.org/webt/d9/hm/qt/d9hmqtsqod_pexw3xdmfprfww2m.png"><br><br>  Seperti yang Anda lihat, perbedaannya bisa diraba - baik dalam hal kecepatan, dan dalam hal penggunaan memori.  Jelaskan secara singkat hasilnya. <br><br><ul><li>  Setiap menunggu operasi untuk tugas yang belum selesai membutuhkan sekitar 4 mikrodetik dan mengalokasikan hampir 300 byte (**) untuk setiap panggilan.  Itulah sebabnya GetStockPriceFor berjalan hampir dua kali lebih cepat dari GetStockPriceForAsync dan mengalokasikan lebih sedikit memori. </li><li>  Metode asinkron berdasarkan ValueTask membutuhkan waktu lebih lama daripada varian dengan Tugas, saat metode ini tidak dijalankan secara serempak.  Mesin keadaan metode berdasarkan ValueTask &lt;T&gt; harus menyimpan lebih banyak data daripada mesin keadaan metode berdasarkan Tugas &lt;T&gt;. </li></ul><br>  <i>(**) Tergantung pada platform (x64 atau x86) dan sejumlah variabel lokal dan argumen dari metode asinkron.</i> <br><br><h4>  Kinerja Metode Asinkron 101 </h4><br><ul><li>  Jika metode asinkron berjalan secara sinkron, biaya overhead cukup kecil. </li><li>  Jika metode asinkron dijalankan secara sinkron, maka overhead berikut terjadi dalam penggunaan memori: tidak ada overhead untuk metode Tugas async, dan untuk metode Tugas async &lt;T&gt; metode overrun adalah 88 byte per operasi (untuk platform x64). </li><li>  ValueTask &lt;T&gt; menghilangkan overhead yang disebutkan di atas untuk metode asinkron yang dijalankan secara sinkron. </li><li>  Ketika metode asinkron berdasarkan ValueTask &lt;T&gt; dieksekusi secara sinkron, dibutuhkan sedikit waktu lebih sedikit daripada metode dengan Tugas &lt;T&gt;, jika tidak ada sedikit perbedaan dalam mendukung opsi kedua. </li><li>  Kinerja overhead untuk metode asinkron menunggu untuk menyelesaikan tugas yang belum selesai secara signifikan lebih tinggi (sekitar 300 byte per operasi untuk platform x64). </li></ul><br>  Tentu saja, pengukuran adalah segalanya bagi kami.  Jika Anda melihat bahwa operasi asinkron menyebabkan masalah kinerja, Anda dapat beralih dari <code>Task&lt;T&gt;</code> ke <code>ValueTask&lt;T&gt;</code> , cache tugas, atau buat jalur eksekusi keseluruhan sinkron, jika mungkin.  Anda juga dapat mencoba menggabungkan operasi asinkron Anda.  Ini akan membantu meningkatkan kinerja, menyederhanakan debugging dan analisis kode secara umum.  <b>Tidak setiap kode kecil harus asinkron.</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420627/">https://habr.com/ru/post/id420627/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420615/index.html">JavaScript: menjelajahi objek</a></li>
<li><a href="../id420617/index.html">Panduan Desain Web untuk Pengembang</a></li>
<li><a href="../id420619/index.html">Gambar Responsif: Trik CSS Yang Menghemat Waktu</a></li>
<li><a href="../id420623/index.html">Aplikasi C ++ terdistribusi dengan upaya minimal</a></li>
<li><a href="../id420625/index.html">KDD 2018, Hari Pertama, tutorial</a></li>
<li><a href="../id420629/index.html">PHP Digest No. 137 (6 - 20 Agustus 2018)</a></li>
<li><a href="../id420631/index.html">Kami tidak takut pada "awan"</a></li>
<li><a href="../id420633/index.html">Menulis eksportir GeoIP untuk Prometheus dengan visualisasi di Grafana dalam 15 menit</a></li>
<li><a href="../id420635/index.html">AI, tentu saja praktis. Model dasar untuk mengenali emosi dalam gambar</a></li>
<li><a href="../id420637/index.html">Ulasan Printer 3D WANHAO D9 / 300: Video</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>