<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ§Ô∏è üïâÔ∏è üò∫ Hello World dari Bytecode untuk JVM üëåüèº ü§æüèΩ üì™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami menyusun program sederhana yang menampilkan "Hello World" dan menelusuri strukturnya 


 Saya tidak berpikir bahwa artikel tersebut akan cukup in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hello World dari Bytecode untuk JVM</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480550/"><p>  Kami menyusun program sederhana yang menampilkan "Hello World" dan menelusuri strukturnya </p><br><p>  Saya tidak berpikir bahwa artikel tersebut akan cukup informatif bagi mereka yang tidak tahu bagaimana tampilan bytecode dan bagaimana JVM bekerja dengannya (misalnya, setidaknya instruksi paling sederhana (pengetahuan tentang keberadaan mereka)). </p><br><p> Padahal, itu tidak begitu sulit.  Cukup menggunakan alat <code>javap</code> dari JDK dan mempertimbangkan kode yang dibongkar. </p><br><p>  Dan kita akan mulai menganalisis struktur bytecode untuk JVM </p><a name="habracut"></a><br><p>  Buku yang sangat berguna untuk ini adalah spesifikasi JVM resmi - Spesifikasi Mesin Virtual Java di <a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf">oracle</a> </p><br><p>  Untuk memulai, buat program sederhana: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String ... args)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hello World"</span></span>); } }</code> </pre><br><p>  Kompilasi dengan tim <code>javac Main.java</code> dan benar-benar melakukan pembongkaran </p><br><pre> <code class="plaintext hljs"> javap -c -v Main</code> </pre> <br><p>  <em>Kelas Utama</em> </p><br><pre> <code class="plaintext hljs">Classfile /C:/Users/Arthur/playground/java/jvm/Main.class Last modified 26.10.2019; size 413 bytes MD5 checksum 6449121a3bb611fee394e4f322401ee1 Compiled from "Main.java" public class Main minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPER Constant pool: #1 = Methodref #6.#15 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #16.#17 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #18 // Hello World #4 = Methodref #19.#20 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #21 // Main #6 = Class #22 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 main #12 = Utf8 ([Ljava/lang/String;)V #13 = Utf8 SourceFile #14 = Utf8 Main.java #15 = NameAndType #7:#8 // "&lt;init&gt;":()V #16 = Class #23 // java/lang/System #17 = NameAndType #24:#25 // out:Ljava/io/PrintStream; #18 = Utf8 Hello World #19 = Class #26 // java/io/PrintStream #20 = NameAndType #27:#28 // println:(Ljava/lang/String;)V #21 = Utf8 Main #22 = Utf8 java/lang/Object #23 = Utf8 java/lang/System #24 = Utf8 out #25 = Utf8 Ljava/io/PrintStream; #26 = Utf8 java/io/PrintStream #27 = Utf8 println #28 = Utf8 (Ljava/lang/String;)V { public Main(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 1: 0 public static void main(java.lang.String...); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC, ACC_VARARGS Code: stack=2, locals=1, args_size=1 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String Hello World 5: invokevirtual #4// Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 4: 0 line 5: 8 } SourceFile: "Main.java"</code> </pre><br><p>  Ini hanya representasi bytecode yang lebih mudah dilihat seseorang daripada bytecode asli, tetapi tampilannya berbeda: </p><br><pre> <code class="plaintext hljs"> cafe babe 0000 0034 001d 0a00 0600 0f09 0010 0011 0800 120a 0013 0014 0700 1507 0016 0100 063c 696e 6974 3e01 0003 2829 5601 0004 436f 6465 0100 0f4c 696e 654e 756d 6265 7254 6162 6c65 0100 046d 6169 6e01 0016 285b 4c6a 6176 612f 6c61 6e67 2f53 7472 696e 673b 2956 0100 0a53 6f75 7263 6546 696c 6501 0009 4d61 696e 2e6a 6176 610c 0007 0008 0700 170c 0018 0019 0100 0b48 656c 6c6f 2057 6f72 6c64 0700 1a0c 001b 001c 0100 044d 6169 6e01 0010 6a61 7661 2f6c 616e 672f 4f62 6a65 6374 0100 106a 6176 612f 6c61 6e67 2f53 7973 7465 6d01 0003 6f75 7401 0015 4c6a 6176 612f 696f 2f50 7269 6e74 5374 7265 616d 3b01 0013 6a61 7661 2f69 6f2f 5072 696e 7453 7472 6561 6d01 0007 7072 696e 746c 6e01 0015 284c 6a61 7661 2f6c 616e 672f 5374 7269 6e67 3b29 5600 2100 0500 0600 0000 0000 0200 0100 0700 0800 0100 0900 0000 1d00 0100 0100 0000 052a b700 01b1 0000 0001 000a 0000 0006 0001 0000 0001 0089 000b 000c 0001 0009 0000 0025 0002 0001 0000 0009 b200 0212 03b6 0004 b100 0000 0100 0a00 0000 0a00 0200 0000 0400 0800 0500 0100 0d00 0000 0200 0e</code> </pre> <br><p>  (Anda dapat membuka file <code>.class</code> Anda melalui Sublime Text yang menunjukkan File-&gt; Save with Encoding -&gt; Hexademical) </p><br><p>  Kami akan bekerja dengan kode ini. </p><br><p>  Tapi pertama-tama, kita perlu memformatnya agar tidak bingung di mana itu, dan bytecode, pada kenyataannya, memiliki struktur yang sangat kaku: </p><br><pre> <code class="plaintext hljs"> ClassFile { u4 magic; u2 minor_version; u2 major_version; u2 constant_pool_count; cp_info constant_pool[constant_pool_count-1]; u2 access_flags; u2 this_class; u2 super_class; u2 interfaces_count; u2 interfaces[interfaces_count]; u2 fields_count; field_info fields[fields_count]; u2 methods_count; method_info methods[methods_count]; u2 attributes_count; attribute_info attributes[attributes_count]; }</code> </pre> <br><p>  Anda dapat menemukannya di spesifikasi JVM <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">Bab 4.1 Struktur ClassFile</a> </p><br><p>  Semuanya sederhana di sini - dimensi dalam byte ditunjukkan di sebelah kiri, dan deskripsi di sebelah kanan. </p><br><p>  Kami akan menganalisis bytecode dalam heksadesimal, di mana setiap digit mengambil 4 bit, dan karenanya, untuk dua byte - 4 digit dan untuk empat byte - 8 digit. </p><br><p>  <strong>sihir</strong> </p><br><p>  sihir adalah nilai yang mengidentifikasi format kelas kami.  Itu sama dengan <code>0xCAFEBABE</code> , yang memiliki <a href="https://en.wikipedia.org/wiki/Java_class_file">sejarah pembuatannya sendiri</a> . </p><br><p>  <strong>minor_version, major_version</strong> </p><br><p>  Ini adalah versi file <code>class</code> Anda.  Jika kita memanggil <code>major_version</code> M dan <code>minor_version</code> m, kita mendapatkan versi file <code>class</code> kita sebagai <code>Mm</code> </p><br><p>  Sekarang saya akan segera memberikan contoh dari program kami "Hello World" untuk melihat bagaimana mereka digunakan: </p><br><pre> <code class="plaintext hljs"> cafe babe -- magic 0000 -- minor_version 0034 -- major_version</code> </pre> <br><p>  Kita bisa melihatnya dalam kode yang dibongkar, tetapi sudah dalam sistem angka desimal: </p><br><pre> <code class="plaintext hljs"> ... public class Main minor version: 0 major version: 52 flags: ACC_PUBLIC, ...</code> </pre> <br><p>  <strong>constant_pool_count</strong> </p><br><p>  Jumlah variabel dalam kumpulan konstan ditunjukkan di sini.  Pada saat yang sama, jika Anda memutuskan untuk menulis kode dalam bytecode murni, maka Anda pasti perlu memantau nilainya, karena jika Anda menentukan nilai yang salah, seluruh program akan masuk neraka (dicentang!). </p><br><p>  Juga, jangan lupa bahwa Anda harus menulis di sana <code>___ + 1</code> of_variables_ di <code>___ + 1</code> </p><br><p>  Total yang kami dapatkan: </p><br><pre> <code class="plaintext hljs"> cafe babe -- magic 0000 0034 -- version 001d -- constant_pool_count</code> </pre> <br><p>  <strong>constant_pool []</strong> </p><br><p>  Setiap jenis variabel dalam kumpulan konstan memiliki struktur sendiri: </p><br><pre> <code class="plaintext hljs"> cp_info { u1 tag; u1 info[]; }</code> </pre> <br><p>  Di sini semuanya perlu dilakukan secara berurutan.  Pertama-tama kita membaca <code>tag</code> untuk mengetahui tipe variabel dan berdasarkan tipe variabel ini kita melihat struktur apa yang nilainya selanjutnya memiliki <code>info[]</code> </p><br><p>  Tabel dengan tag dapat ditemukan dalam <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">Tabel 4.3</a> spesifikasi <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">tag pool konstan</a> . </p><br><p>  Sebenarnya, ini tabletnya: </p><br><div class="scrollable-table"><table><thead><tr><th>  Tipe konstan </th><th>  Nilai </th></tr></thead><tbody><tr><td> <code>CONSTANT_Class</code> </td> <td>  7 </td></tr><tr><td> <code>CONSTANT_Fieldref</code> </td> <td>  9 </td></tr><tr><td> <code>CONSTANT_Methodref</code> </td> <td>  10 </td></tr><tr><td> <code>CONSTANT_InterfaceMethodref</code> </td> <td>  11 </td></tr><tr><td> <code>CONSTANT_String</code> </td> <td>  8 </td></tr><tr><td> <code>CONSTANT_Integer</code> </td> <td>  3 </td></tr><tr><td> <code>CONSTANT_Float</code> </td> <td>  4 </td></tr><tr><td> <code>CONSTANT_Long</code> </td> <td>  5 </td></tr><tr><td> <code>CONSTANT_Double</code> </td> <td>  6 </td></tr><tr><td> <code>CONSTANT_NameAndType</code> </td> <td>  12 </td></tr><tr><td> <code>CONSTANT_Utf8</code> </td> <td>  1 </td></tr><tr><td> <code>CONSTANT_MethodHandle</code> </td> <td>  15 </td></tr><tr><td> <code>CONSTANT_MethodType</code> </td> <td>  16 </td></tr><tr><td> <code>CONSTANT_InvokeDynamic</code> </td> <td>  18 </td></tr></tbody></table></div><br><p>  Seperti disebutkan sebelumnya, setiap tipe konstanta memiliki strukturnya sendiri. </p><br><p>  Di sini, misalnya, adalah struktur <code>CONSTANT_Class</code> : </p><br><pre> <code class="plaintext hljs"> CONSTANT_Class_info { u1 tag; u2 name_index; }</code> </pre> <br><p>  Struktur bidang dan metode: </p><br><pre> <code class="plaintext hljs"> CONSTANT_Fieldref_info { u1 tag; u2 class_index; u2 name_and_type_index; } CONSTANT_Methodref_info { u1 tag; u2 class_index; u2 name_and_type_index; }</code> </pre> <br><p>  Penting untuk dicatat di sini bahwa struktur yang berbeda mungkin memiliki panjang yang berbeda. </p><br><p>  Pertimbangkan bagian dari kode kami: </p><br><pre> <code class="plaintext hljs"> cafe babe 0000 0034 001d -- constant_pool_count 0a00 0600 0f09 0010 0011 0800 12 ...</code> </pre> <br><p>  Jadi, kita melihat struktur konstanta dan mengetahui bahwa byte pertama dicadangkan untuk tipe konstanta.  Di sini kita melihat <code>0a</code> (10) - dan karenanya, itu adalah <code>CONSTANT_Methodref</code> </p><br><p>  Kami melihat strukturnya: </p><br><pre> <code class="plaintext hljs"> CONSTANT_Methodref_info { u1 tag; u2 class_index; u2 name_and_type_index; }</code> </pre> <br><p>  Setelah satu byte untuk tag, kita membutuhkan 4 byte lagi untuk <code>class_index</code> dan <code>name_and_type_index</code> </p><br><pre> <code class="plaintext hljs"> cafe babe 0000 0034 001d -- constant_pool_count 0a 0006 000f -- CONSTANT_Methodref 0900 1000 1108 0012 ...</code> </pre> <br><p>  Ya, kami menemukan salah satu nilai dari kumpulan konstan.  Silakan.  Kami melihat, <code>09</code> - berarti jenis <code>CONSTANT_Fieldref</code> </p><br><p>  Kami mendapatkan: </p><br><pre> <code class="plaintext hljs"> cafe babe 0000 0034 001d -- constant_pool_count 0a 0006 000f -- CONSTANT_Methodref 09 0010 0011 -- CONSTANT_Fieldref 08 0012 ...</code> </pre> <br><p>  Anda mungkin berpikir bahwa sebagian besar tipe memiliki bentuk yang sama, tetapi ini tidak terjadi. <br>  Misalnya, struktur tipe berikut ini terlihat seperti <code>CONSTANT_String</code> : </p><br><pre> <code class="plaintext hljs"> CONSTANT_String_info { u1 tag; u2 string_index; }</code> </pre> <br><p>  Semua struktur ini dapat ditemukan di <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">Bab 4.4 The Constant Pool.</a> </p><br><p>  Sekarang mari kita lihat apa artinya tipe di dalam <code>info</code> itu sendiri. </p><br><p>  Metode yang termasuk dalam pola <code>*_index</code> biasanya berisi alamat dari tabel pool konstan.  Misalnya, <code>class_index</code> untuk nilai tipe <code>CONSTANT_Class_info</code> , dan <code>string_index</code> untuk <code>string_index</code> <code>CONSTANT_Utf8_info</code> </p><br><p>  Kita dapat melihat ini dalam kode yang dibongkar: </p><br><pre> <code class="plaintext hljs"> #1 = Methodref #6.#15 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #16.#17 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #18</code> </pre> <br><pre> <code class="plaintext hljs"> 0a 0006 000f -- CONSTANT_Methodref 09 0010 0011 -- CONSTANT_Fieldref 08 0012 -- CONSTANT_String</code> </pre> <br><p>  Anda juga dapat menyorot representasi angka dan string. </p><br><p>  Anda dapat membaca tentang representasi angka mulai dari bab <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">4.4.4</a> , tetapi untuk saat ini kami hanya akan menganalisis garis, karena angka tersebut tidak termasuk dalam program Hello World. </p><br><p>  Sebenarnya, beginilah tampilan baris: </p><br><pre> <code class="plaintext hljs"> CONSTANT_Utf8_info { u1 tag; u2 length; u1 bytes[length]; }</code> </pre> <br><p>  Misalnya, Hello World kami: </p><br><pre> <code class="plaintext hljs"> 01 -- tag 000b -- length 48 65 6c 6c 6f 20 57 6f 72 6c 64 -- bytes[length] // H ello W orld</code> </pre> <br><p>  Parsing seluruh kumpulan konstanta bytecode, kita dapatkan: </p><br><div class="spoiler">  <b class="spoiler_title">Seluruh kumpulan konstanta</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> -- [Constant Pool] -- methodref 0a 0006 000f -- fieldref 09 0010 0011 -- string 08 0012 -- methodref 0a 0013 0014 -- Class 07 0015 -- Class 07 0016 -- Utf8 01 0006 3c 69 6e 69 74 3e -- Utf8 01 0003 28 29 56 -- Utf8 01 0004 43 6f 64 65 -- Utf8 01 000f 4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65 -- Utf8 01 0004 6d 61 69 6e -- Utf8 01 0016 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 29 56 -- Utf8 01 000a 53 6f 75 72 63 65 46 69 6c 65 -- Utf8 01 0009 4d 61 69 6e 2e 6a 61 76 61 -- NameAndType 0c 0007 0008 -- Class 07 0017 -- NameAndType 0c 0018 0019 -- Utf8 01 000b 48 65 6c 6c 6f 20 57 6f 72 6c 64 -- Class 07 001a -- NameAndType 0c 001b 001c -- Utf8 01 0004 4d 61 69 6e -- Utf8 01 0010 6a 61 76 61 2f 6c 61 6e 67 2f 4f 62 6a 65 63 74 -- Utf8 01 0010 6a 61 76 61 2f 6c 61 6e 67 2f 53 79 73 74 65 6d -- Utf8 01 0003 6f 75 74 -- Utf8 01 0015 4c 6a 61 76 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d 3b -- Utf8 01 0013 6a 61 76 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d -- Utf8 01 0007 70 72 69 6e 74 6c 6e -- Utf8 01 0015 28 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 29 56 -- [Constant Pool END]</code> </pre> </div></div><br><p>  Juga, kita dapat membandingkannya dengan kode yang dibongkar: </p><br><pre> <code class="plaintext hljs"> Constant pool: #1 = Methodref #6.#15 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #16.#17 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #18 // Hello World #4 = Methodref #19.#20 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #21 // Main #6 = Class #22 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 main #12 = Utf8 ([Ljava/lang/String;)V #13 = Utf8 SourceFile #14 = Utf8 Main.java #15 = NameAndType #7:#8 // "&lt;init&gt;":()V #16 = Class #23 // java/lang/System #17 = NameAndType #24:#25 // out:Ljava/io/PrintStream; #18 = Utf8 Hello World #19 = Class #26 // java/io/PrintStream #20 = NameAndType #27:#28 // println:(Ljava/lang/String;)V #21 = Utf8 Main #22 = Utf8 java/lang/Object #23 = Utf8 java/lang/System #24 = Utf8 out #25 = Utf8 Ljava/io/PrintStream; #26 = Utf8 java/io/PrintStream #27 = Utf8 println #28 = Utf8 (Ljava/lang/String;)V</code> </pre> <br><p>  Dengan demikian memeriksa bahwa semuanya cocok, karena pada kenyataannya <code>javap</code> hanya memproses bytecode ini dan menunjukkannya kepada kami dalam bentuk yang diformat. </p><br><p>  Kolam konstan diperlukan untuk instruksi.  Sebagai contoh: </p><br><pre> <code class="plaintext hljs"> public Main(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 //    1    4: return</code> </pre> <br><p>  Untuk informasi lebih lanjut tentang semua tipe dalam pool konstan, lihat <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">Bab 4.4 Pool Konstan.</a> </p><br><p>  Lebih jauh dalam struktur <em>ClassFile</em> </p><br><p>  <strong>access_flags</strong> </p><br><p>  Ini adalah bitmask untuk properti modifier. </p><br><div class="scrollable-table"><table><thead><tr><th>  Nama bendera </th><th>  Nilai </th><th>  Interpretasi </th></tr></thead><tbody><tr><td> <code>ACC_PUBLIC</code> </td> <td>  0x0001 </td><td>  Menyatakan <code>public</code> ;  dapat diakses dari luar paketnya. </td></tr><tr><td> <code>ACC_FINAL</code> </td> <td>  0x0010 </td><td>  Dinyatakan <code>final</code> ;  tidak ada subkelas yang diizinkan. </td></tr><tr><td> <code>ACC_SUPER</code> </td> <td>  0x0020 </td><td>  Perlakukan metode superclass secara khusus ketika diminta oleh instruksi khusus <em>invokes</em> . </td></tr><tr><td> <code>ACC_INTERFACE</code> </td> <td>  0x0200 </td><td>  Merupakan antarmuka, bukan kelas. </td></tr><tr><td> <code>ACC_ABSTRACT</code> </td> <td>  0x0400 </td><td>  Deklarasi <code>abstract</code> ;  tidak boleh dipakai. </td></tr><tr><td> <code>ACC_SYNTHETIC</code> </td> <td>  0x1000 </td><td>  Deklarasi sintetis;  tidak ada dalam kode sumber. </td></tr><tr><td> <code>ACC_ANNOTATION</code> </td> <td>  0x2000 </td><td>  Dinyatakan sebagai jenis anotasi. </td></tr><tr><td> <code>ACC_ENUM</code> </td> <td>  0x4000 </td><td>  Dinyatakan sebagai tipe <code>enum</code> . </td></tr></tbody></table></div><br><p>  <strong>kelas ini</strong> </p><br><p>  Harus berisi alamat di kelas <code>this</code> .  Dalam kasus kami, ini terletak di alamat 5: </p><br><pre> <code class="plaintext hljs"> Constant pool: #1 = Methodref #6.#15 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #16.#17 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #18 // Hello World #4 = Methodref #19.#20 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #21 // Main #6 = Class #22 // java/lang/Object ...</code> </pre> <br><p>  Perlu dicatat bahwa struktur variabel ini harus sesuai dengan <code>CONSTANT_Class_info</code> </p><br><p>  <strong>super_class</strong> </p><br><p>  Alamat leluhur kelas.  Dalam kasus kami, nilainya ada di alamat <code>#6</code> .  Yah, struktur nilai <code>CONSTANT_Class_info</code> juga diperlukan </p><br><p>  Nama-nama kelas ini didefinisikan dalam struktur konstanta <code>CONSTANT_Utf8_info</code> .  Jika kita melihat sel <code>#21</code> dan <code>#22</code> , kita akan melihat: </p><br><pre> <code class="plaintext hljs"> ... #21 = Utf8 Main #22 = Utf8 java/lang/Object ...</code> </pre> <br><p>  Artinya, dalam sel-sel ini <code>name_index</code> dari struktur ditunjukkan: </p><br><pre> <code class="plaintext hljs"> CONSTANT_Class_info { u1 tag; u2 name_index; }</code> </pre> <br><p>  <strong>interfaces_count, fields_count</strong> </p><br><p>  Mereka tidak ada dalam program kami, jadi nilainya akan sama dengan 0000, dan tidak akan ada nilai berikutnya dari <code>fields[]</code> , <code>interfaces[]</code> . </p><br><p>  Baca selengkapnya <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">4.1 Struktur ClassFile</a> </p><br><p>  <strong>methods_count</strong> </p><br><p>  Jumlah metode.  Meskipun dalam kode kita melihat satu metode di kelas, sebenarnya ada dua dari mereka.  Selain metode <code>main</code> , ada juga konstruktor default.  Karena itu, jumlah mereka adalah dua, dalam kasus kami. </p><br><p>  <strong>metode []</strong> </p><br><p>  Setiap elemen harus sesuai dengan struktur <code>method_info</code> yang diuraikan dalam <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">Bab 4.6 Metode</a> </p><br><pre> <code class="plaintext hljs"> method_info { u2 access_flags; u2 name_index; u2 descriptor_index; u2 attributes_count; attribute_info attributes[attributes_count]; }</code> </pre> <br><p>  Dalam bytecode kami (diformat, dengan komentar) tampilannya seperti ini: </p><br><pre> <code class="plaintext hljs"> -- [methods] -- public Main(); 0001 --access_flags 0007 -- name_index 0008 -- descriptor_index 0001 -- attributes_count -- attribute_info 0009 -- attribute_name_index (Code) 0000 001d - attribute_length 0001 -- max_stack 0001 -- max_locals 0000 0005 -- code_length 2a b7 00 01 b1 -- code[] 0000 -- exception_table_length 0001 -- attributes_count; 000a -- attribute_name_index 0000 0006 -- attribute_length 00 01 00 00 00 01 -- public static void main(java.lang.String...); 0089 --access_flags 000b -- name_index 000c -- descriptor_index 0001 -- attributes_count -- attribute_info 0009 -- attribute_name_index (Code) 0000 0025 -- attribute_length 0002 -- max_stack 0001 -- max_locals 0000 0009 -- code_length b2 00 02 12 03 b6 00 04 b1 -- code[] 0000 -- exception_table_length 0001 -- attributes_count 000a -- attribute_name_index 0000 000a -- attribute_length 00 02 00 00 00 04 00 08 00 05 -- [methods END]</code> </pre> <br><p>  Mari kita menganalisis struktur metode secara lebih rinci: </p><br><p>  <strong>access_flags</strong> </p><br><p>  Topeng pengubah.  <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">Tabel 4.5 Metode akses dan bendera properti</a> </p><br><div class="scrollable-table"><table><thead><tr><th>  Nama bendera </th><th>  Nilai </th><th>  Interpretasi </th></tr></thead><tbody><tr><td> <code>ACC_PUBLIC</code> </td> <td>  0x0001 </td><td>  Menyatakan <code>public</code> ;  dapat diakses dari luar paketnya. </td></tr><tr><td> <code>ACC_PRIVATE</code> </td> <td>  0x0002 </td><td>  Dinyatakan <code>private</code> ;  hanya dapat diakses dalam kelas yang mendefinisikan. </td></tr><tr><td> <code>ACC_PROTECTED</code> </td> <td>  0x0004 </td><td>  Dinyatakan <code>protected</code> ;  dapat diakses dalam subkelas. </td></tr><tr><td> <code>ACC_STATIC</code> </td> <td>  0x0008 </td><td>  Dinyatakan <code>static</code> . </td></tr><tr><td> <code>ACC_FINAL</code> </td> <td>  0x0010 </td><td>  Dinyatakan <code>final</code> ;  tidak boleh diganti ( <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html">¬ß5.4.5</a> ). </td></tr><tr><td> <code>ACC_SYNCHRONIZED</code> </td> <td>  0x0020 </td><td>  Dinyatakan <code>synchronized</code> ;  doa dibungkus dengan penggunaan monitor. </td></tr><tr><td> <code>ACC_BRIDGE</code> </td> <td>  0x0040 </td><td>  Metode jembatan, yang dihasilkan oleh kompiler. </td></tr><tr><td> <code>ACC_VARARGS</code> </td> <td>  0x0080 </td><td>  Dideklarasikan dengan jumlah variabel argumen. </td></tr><tr><td> <code>ACC_NATIVE</code> </td> <td>  0x0100 </td><td>  Menyatakan <code>native</code> ;  diimplementasikan dalam bahasa selain Jawa. </td></tr><tr><td> <code>ACC_ABSTRACT</code> </td> <td>  0x0400 </td><td>  Deklarasi <code>abstract</code> ;  tidak ada implementasi yang disediakan. </td></tr><tr><td> <code>ACC_STRICT</code> </td> <td>  0x0800 </td><td>  Dinyatakan <code>strictfp</code> ;  mode floating-point adalah FP-ketat. </td></tr><tr><td> <code>ACC_SYNTHETIC</code> </td> <td>  0x1000 </td><td>  Deklarasi sintetis;  tidak ada dalam kode sumber. </td></tr></tbody></table></div><br><p>  Seperti yang dapat kita lihat dari bytecode, dalam metode <code>public Main();</code>  (konstruktor) adalah mask <code>0001</code> , yang berarti <code>ACC_PUBLIC</code> . </p><br><p>  Sekarang mari kita coba merakit sendiri metode <code>main</code> .  Inilah yang dia miliki: </p><br><ul><li>  publik - ACC_PUBLIC - 0x0001 </li><li>  statis - ACC_STATIC - 0x0008 </li><li>  String ... args - ACC_VARARGS - 0x0080 </li></ul><br><p>  Kami mengumpulkan topeng: 0x0001 + 0x0008 + 0x0080 = <code>0x0089</code> .  Jadi kami mendapat <code>access_flag</code> </p><br><blockquote>  By the way, ACC_VARARGS adalah opsional di sini, dalam arti jika kita <br>  menggunakan String [] args sebagai ganti String ... args, maka flag ini tidak akan menjadi </blockquote><p>  <strong>name_index</strong> </p><br><p>  Metode nama alamat ( <code>CONSTANT_Utf8_info</code> ) di kumpulan konstan.  Penting untuk dicatat di sini bahwa nama konstruktor bukan Utama, tetapi <code>&lt;init&gt;</code> , terletak di sel # 7. </p><br><p>  Pelajari lebih lanjut tentang <code>&lt;init&gt;</code> dan <code>&lt;clinit&gt;</code> di <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html">Bab 2.9 Metode Khusus</a> </p><br><p>  <strong>descriptor_index</strong> </p><br><p>  Secara kasar, ini adalah alamat yang menunjuk ke pegangan metode.  Deskriptor ini berisi jenis nilai balik dan jenis tanda tangannya. </p><br><p>  Juga, JVM menggunakan singkatan yang ditafsirkan: </p><br><div class="scrollable-table"><table><thead><tr><th>  Karakter <em>BaseType</em> </th><th>  Jenis </th><th>  Interpretasi </th></tr></thead><tbody><tr><td> <code>B</code> </td> <td> <code>byte</code> </td> <td>  byte yang ditandatangani </td></tr><tr><td> <code>C</code> </td> <td> <code>char</code> </td> <td>  Titik kode karakter Unicode di Basic Multilingual Plane, disandikan dengan UTF-16 </td></tr><tr><td> <code>D</code> </td> <td> <code>double</code> </td> <td>  nilai floating-point presisi ganda </td></tr><tr><td> <code>F</code> </td> <td> <code>float</code> </td> <td>  nilai floating-point presisi tunggal </td></tr><tr><td> <code>I</code> </td> <td> <code>int</code> </td> <td>  bilangan bulat </td></tr><tr><td> <code>J</code> </td> <td> <code>long</code> </td> <td>  bilangan bulat panjang </td></tr><tr><td>  <code>L</code> <em>ClassName</em> <code>;</code> </td><td> <code>reference</code> </td> <td>  turunan dari class <em>ClassName</em> </td></tr><tr><td> <code>S</code> </td> <td> <code>short</code> </td> <td>  ditandatangani pendek </td></tr><tr><td> <code>Z</code> </td> <td> <code>boolean</code> </td> <td>  <code>true</code> atau <code>false</code> </td></tr><tr><td> <code>[</code> </td> <td> <code>reference</code> </td> <td>  satu dimensi array </td></tr></tbody></table></div><br><p>  Secara umum, ini terlihat seperti ini: </p><br><pre> <code class="plaintext hljs"> ( ParameterDescriptor* ) ReturnDescriptor</code> </pre> <br><p>  Sebagai contoh, metode berikut: </p><br><pre> <code class="plaintext hljs"> Object method(int i, double d, Thread t) {..}</code> </pre> <br><p>  Dapat direpresentasikan sebagai </p><br><pre> <code class="plaintext hljs"> (IDLjava/lang/Thread;)Ljava/lang/Object</code> </pre> <br><p>  Sebenarnya, <code>I</code> <code>int</code> , <code>D</code> <code>double</code> , dan <code>Ljava/lang/Thread;</code>  class <code>Thread</code> dari perpustakaan <code>java.lang</code> standar. </p><br><p>  Selanjutnya, ada atribut yang juga memiliki struktur sendiri. </p><br><p>  Tapi pertama-tama, seperti biasa, <code>attributes_count</code> menghitung </p><br><p>  Kemudian atribut diri dengan struktur yang dijelaskan dalam <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">Bab 4.7 Atribut</a> </p><br><pre> <code class="plaintext hljs"> attribute_info { u2 attribute_name_index; u4 attribute_length; u1 info[attribute_length]; }</code> </pre> <br><p>  <strong>atribut_name_index</strong> </p><br><p>  Menentukan nama atribut.  Dalam kasus kami, kedua metode memiliki <code>Code</code> .  Atribut adalah topik besar yang terpisah di mana Anda bahkan dapat membuat atribut Anda sendiri berdasarkan spesifikasi.  Tetapi untuk sekarang, kita harus tahu bahwa <code>attribute_name_index</code> hanya menunjuk ke alamat dalam kumpulan konstan dengan struktur <code>CONSTANT_Utf8_info</code> </p><br><p>  <strong>attribute_length</strong> </p><br><p>  Berisi panjang atribut, tidak termasuk <code>attribute_name_index</code> dan <code>attribute_length</code> </p><br><p>  <strong>info</strong> </p><br><p>  Selanjutnya, kita akan menggunakan struktur <code>Code</code> , karena dalam nilai <code>attribute_name_index</code> kita menunjuk ke nilai dalam kumpulan konstanta <code>Code</code> . </p><br><p>  Baca lebih lanjut: <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">Bab 4.7.3 Atribut Kode</a> </p><br><p>  Berikut strukturnya: </p><br><pre> <code class="plaintext hljs"> Code_attribute { u2 attribute_name_index; u4 attribute_length; u2 max_stack; u2 max_locals; u4 code_length; u1 code[code_length]; u2 exception_table_length; { u2 start_pc; u2 end_pc; u2 handler_pc; u2 catch_type; } exception_table[exception_table_length]; u2 attributes_count; attribute_info attributes[attributes_count]; }</code> </pre> <br><p>  <strong>max_stack</strong> </p><br><p>  Sepertinya saya bahwa nama atribut ini dapat menyesatkan karena max awalan.  Bahkan, ini adalah ukuran tumpukan minimum yang diperlukan untuk menyelesaikan operasi.  Nah, nama ini mengambil logika, untuk mengatakan ukuran tumpukan maksimum yang akan dicapai selama operasi. </p><br><p>  Sederhananya, JVM akan mengalokasikan ruang untuk tumpukan operan.  Di sana Anda dapat menentukan nilai yang lebih besar dari yang diperlukan, tetapi mendefinisikan nilai dalam atribut ini kurang dari yang diperlukan akan menghasilkan kesalahan. </p><br><p>  Pada topik tumpukan, Anda dapat membaca " <a href="https%253A%252F%252Fwww.tune-it.ru%252Fweb%252Fbleizard%252Fblog%253Fp_p_id%253Dcom_liferay_blogs_web_portlet_BlogsPortlet%2526p_p_lifecycle%253D0%2526p_p_state%253Dnormal%2526p_p_mode%253Dview%2526_com_liferay_blogs_web_portlet_BlogsPortlet_cur%253D2%2526_com_liferay_blogs_web_portlet_BlogsPortlet_delta%253D10%2526p_r_p_resetCur%253Dfalse">Pada tumpukan dan tumpukan dalam konteks dunia Java</a> " atau di " <a href="http://blog.jamesdbloom.com/JVMInternals.html">JVM Internals</a> " </p><br><p>  <strong>max_locals</strong> </p><br><p>  Ukuran maksimum variabel lokal </p><br><p>  Anda bisa berkenalan dengan variabel lokal baik dalam <a href="https://jrebel.com/rebellabs/rebel-labs-report-mastering-java-bytecode-at-the-core-of-the-jvm/">Menguasai Java Bytecode di Core JVM</a> atau di <a href="http://blog.jamesdbloom.com/JVMInternals.html">JVM Internal yang</a> sama </p><br><p>  <strong>code_length</strong> </p><br><p>  Ukuran kode yang akan dieksekusi di dalam metode </p><br><p>  <strong>kode []</strong> </p><br><p>  Setiap kode menunjuk ke beberapa instruksi.  Tabel korelasi <code>optcode</code> dan perintah dengan mnemonik dapat ditemukan di Wikipedia - <a href="https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings">Java bytecode daftar instruksi</a> atau dalam spesifikasi itu sendiri di akhir buku </p><br><p>  Misalnya, ambil konstruktor kami: </p><br><pre> <code class="plaintext hljs"> -- public Main(); 0001 --access_flags 0007 -- name_index 0008 -- descriptor_index 0001 -- attributes_count -- attribute_info 0009 -- attribute_name_index (Code) 0000 001d - attribute_length 00 01 -- max_stack 00 01 -- max_locals 00 00 00 05 -- code_length 2a b7 00 01 b1 -- code[] 0000 -- exception_table_length 0001 -- attributes_count; 00 0a -- attribute_name_index 0000 0006 -- attribute_length 00 01 00 00 00 01</code> </pre> <br><p>  Di sini kita dapat menemukan kode kita: </p><br><pre> <code class="plaintext hljs"> 2a b7 00 01 b1</code> </pre> <br><p>  Kami mencari perintah di tabel dan membandingkan: </p><br><pre> <code class="plaintext hljs"> 2a - aload_0 b7 0001 - invokespecial #1 b1 - return</code> </pre> <br><p>  Juga deskripsi perintah ini dapat ditemukan di sini: <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">Bab 4.10.1.9.</a>  <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">Ketik Instruksi Pemeriksaan</a> </p><br><p>  <strong>exception_table_length</strong> </p><br><p>  Menentukan jumlah elemen dalam exception_table.  Kami tidak memiliki kait pengecualian sehingga kami tidak akan menguraikannya.  Tetapi Anda juga dapat membaca <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html">Bab 4.7.3 Atribut Kode</a> </p><br><p>  <strong>exception_table []</strong> </p><br><p>  Ini memiliki struktur sebagai berikut: </p><br><pre> <code class="plaintext hljs"> { u2 start_pc; u2 end_pc; u2 handler_pc; u2 catch_type; }</code> </pre> <br><p>  Untuk menyederhanakan, Anda perlu menentukan awal, akhir ( <code>start_pc</code> , <code>end_pc</code> ) dari kode yang akan ditangani <code>catch_type</code> pengecualian <code>catch_type</code> </p><br><p>  <strong>attribute_count</strong> </p><br><p>  Jumlah Atribut dalam <code>Code</code> </p><br><p>  <strong>atribut []</strong> </p><br><p>  Atribut sering digunakan oleh penganalisa atau penentang. </p><br><hr><br><h3 id="sredstva-dlya-raboty-s-bayt-kodom">  Alat Bytecode </h3><br><p>  Ini bukan topik yang berhubungan dengan artikel ini, tetapi masih secara tidak langsung terkait dengannya. </p><br><p>  Ada banyak alat untuk bekerja dengan bytecode.  Di sini saya ingin meninjau <a href="https://commons.apache.org/proper/commons-bcel/">Byte Code Engineering Library</a> (BCEL) dari Apache Commons. </p><br><p>  Untuk memulainya, dengan menggunakannya kita bisa mendapatkan beberapa atribut bytecode: </p><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">// read file from resources/complied/ClassA.class InputStream inputStream = ClassParserExample.class.getResourceAsStream("/compiled/ClassA.class"); if (inputStream == null) throw new FileNotFoundException(); ClassParser parser = new ClassParser(inputStream, "ClassA.class"); JavaClass clazz = parser.parse(); final String HEX_BYTECODE = getHex(clazz.getBytes()); System.out.println("Hex bytecode: "); System.out.println(HEX_BYTECODE); System.out.println(); final String MINOR_VER = getHex(clazz.getMinor()); final String MAJOR_VER = getHex(clazz.getMajor()); final String CONSTANT_POOL = getHex(clazz.getConstantPool().getConstantPool()); final String ACCESS_FLAGS = getHex(clazz.getAccessFlags()); final String THIS_CLASS = getHex(clazz.getClassName().getBytes()); final String SUPER_CLASS = getHex(clazz.getSuperClass().getBytes()); final String INTERFACES = getHex(clazz.getInterfaces()); final String FIELDS = getHex(clazz.getFields()); final String METHODS = getHex(clazz.getMethods()); final String ATTRIBUTES = getHex(clazz.getAttributes());</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Daftar kode lengkap</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">import org.apache.bcel.classfile.*; import org.apache.commons.codec.binary.Hex; import java.io.*; public class ClassParserExample { public static void main(String... args) throws IOException, ClassNotFoundException { // read file from resources/complied/ClassA.class InputStream inputStream = ClassParserExample.class.getResourceAsStream("/compiled/ClassA.class"); if (inputStream == null) throw new FileNotFoundException(); ClassParser parser = new ClassParser(inputStream, "ClassA.class"); JavaClass clazz = parser.parse(); final String HEX_BYTECODE = getHex(clazz.getBytes()); System.out.println("Hex bytecode: "); System.out.println(HEX_BYTECODE); System.out.println(); final String MINOR_VER = getHex(clazz.getMinor()); final String MAJOR_VER = getHex(clazz.getMajor()); final String CONSTANT_POOL = getHex(clazz.getConstantPool().getConstantPool()); final String ACCESS_FLAGS = getHex(clazz.getAccessFlags()); final String THIS_CLASS = getHex(clazz.getClassName().getBytes()); final String SUPER_CLASS = getHex(clazz.getSuperClass().getBytes()); final String INTERFACES = getHex(clazz.getInterfaces()); final String FIELDS = getHex(clazz.getFields()); final String METHODS = getHex(clazz.getMethods()); final String ATTRIBUTES = getHex(clazz.getAttributes()); System.out.println( "minor: " + MINOR_VER ); // 0 System.out.println( "major: " + MAJOR_VER ); // 34 System.out.println( "constant pool: " + CONSTANT_POOL); // not correctly System.out.println( "access flags: " + ACCESS_FLAGS ); // 21 System.out.println( "this class: " + THIS_CLASS ); System.out.println( "super class: " + SUPER_CLASS ); // Object System.out.println( "interfaces: " + INTERFACES ); // &lt;empty&gt; System.out.println( "fields: " + FIELDS ); // &lt;empty&gt; System.out.println( "methods: " + METHODS ); // one method: psvm hello world System.out.println( "attributes: " + ATTRIBUTES ); // 536f7572636546696c65 - I think it's instructions for Java tools } private static String getHex(byte[] bytes){ return Hex.encodeHexString(bytes); } private static String getHex(int intNum){ return Integer.toHexString(intNum); } private static String getHex(Constant[] constants){ if (constants == null) return null; StringBuilder sb = new StringBuilder(); for (Constant c : constants){ if (c == null) continue; sb.append(getHex(c.getTag())).append(" "); } return sb.toString(); } private static String getHex(JavaClass[] clazzes){ if (clazzes == null) return null; StringBuilder sb = new StringBuilder(); for (JavaClass c : clazzes){ sb.append(getHex(c.getClassName().getBytes())).append(" "); } return sb.toString(); } private static String getHex(Field[] fields){ if (fields == null) return null; StringBuilder sb = new StringBuilder(); for (Field c : fields){ sb.append(getHex(c.getName().getBytes())).append(" "); } return sb.toString(); } private static String getHex(Method[] methods){ if (methods == null) return null; StringBuilder sb = new StringBuilder(); for (Method c : methods){ sb.append(getHex(c.getName().getBytes())).append(" "); } return sb.toString(); } private static String getHex(Attribute[] attributes){ if (attributes == null) return null; StringBuilder sb = new StringBuilder(); for (Attribute c : attributes){ sb.append(getHex(c.getName().getBytes())).append(" "); } return sb.toString(); } } /* Class A: public class ClassA { public static void main(String[] args) { System.out.println("Hello world"); } } */ /* Class A bytecode: cafe babe 0000 0034 0022 0a00 0600 1409 0015 0016 0800 170a 0018 0019 0700 1a07 001b 0100 063c 696e 6974 3e01 0003 2829 5601 0004 436f 6465 0100 0f4c 696e 654e 756d 6265 7254 6162 6c65 0100 124c 6f63 616c 5661 7269 6162 6c65 5461 626c 6501 0004 7468 6973 0100 1d4c 636f 6d2f 6170 706c 6f69 6478 7878 2f70 6172 7365 2f43 6c61 7373 413b 0100 046d 6169 6e01 0016 285b 4c6a 6176 612f 6c61 6e67 2f53 7472 696e 673b 2956 0100 0461 7267 7301 0013 5b4c 6a61 7661 2f6c 616e 672f 5374 7269 6e67 3b01 000a 536f 7572 6365 4669 6c65 0100 0b43 6c61 7373 412e 6a61 7661 0c00 0700 0807 001c 0c00 1d00 1e01 000b 4865 6c6c 6f20 776f 726c 6407 001f 0c00 2000 2101 001b 636f 6d2f 6170 706c 6f69 6478 7878 2f70 6172 7365 2f43 6c61 7373 4101 0010 6a61 7661 2f6c 616e 672f 4f62 6a65 6374 0100 106a 6176 612f 6c61 6e67 2f53 7973 7465 6d01 0003 6f75 7401 0015 4c6a 6176 612f 696f 2f50 7269 6e74 5374 7265 616d 3b01 0013 6a61 7661 2f69 6f2f 5072 696e 7453 7472 6561 6d01 0007 7072 696e 746c 6e01 0015 284c 6a61 7661 2f6c 616e 672f 5374 7269 6e67 3b29 5600 2100 0500 0600 0000 0000 0200 0100 0700 0800 0100 0900 0000 2f00 0100 0100 0000 052a b700 01b1 0000 0002 000a 0000 0006 0001 0000 0006 000b 0000 000c 0001 0000 0005 000c 000d 0000 0009 000e 000f 0001 0009 0000 0037 0002 0001 0000 0009 b200 0212 03b6 0004 b100 0000 0200 0a00 0000 0a00 0200 0000 0800 0800 0900 0b00 0000 0c00 0100 0000 0900 1000 1100 0000 0100 1200 0000 0200 13 */ /* Assembled code: Classfile /C:/java/BCEL/src/main/resources/compiled/ClassA.class Last modified 08.12.2019; size 563 bytes MD5 checksum bcd0198f6764a1dc2f3967fef701452e Compiled from "ClassA.java" public class com.apploidxxx.parse.ClassA minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPER Constant pool: #1 = Methodref #6.#20 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #21.#22 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #23 // Hello world #4 = Methodref #24.#25 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #26 // com/apploidxxx/parse/ClassA #6 = Class #27 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 Lcom/apploidxxx/parse/ClassA; #14 = Utf8 main #15 = Utf8 ([Ljava/lang/String;)V #16 = Utf8 args #17 = Utf8 [Ljava/lang/String; #18 = Utf8 SourceFile #19 = Utf8 ClassA.java #20 = NameAndType #7:#8 // "&lt;init&gt;":()V #21 = Class #28 // java/lang/System #22 = NameAndType #29:#30 // out:Ljava/io/PrintStream; #23 = Utf8 Hello world #24 = Class #31 // java/io/PrintStream #25 = NameAndType #32:#33 // println:(Ljava/lang/String;)V #26 = Utf8 com/apploidxxx/parse/ClassA #27 = Utf8 java/lang/Object #28 = Utf8 java/lang/System #29 = Utf8 out #30 = Utf8 Ljava/io/PrintStream; #31 = Utf8 java/io/PrintStream #32 = Utf8 println #33 = Utf8 (Ljava/lang/String;)V { public com.apploidxxx.parse.ClassA(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 6: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/apploidxxx/parse/ClassA; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String Hello world 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 8: 0 line 9: 8 LocalVariableTable: Start Length Slot Name Signature 0 9 0 args [Ljava/lang/String; } SourceFile: "ClassA.java */</code> </pre> </div></div><br><p>     ,    (,  Jasmin) -. </p><br><p>      <a href="https://github.com/AppLoidx/JVM-research"> </a>   <a href="https://github.com/apache/commons-bcel/tree/master/src/examples"> </a> </p><br><p> ,     <strong>Jasmin</strong> .   ,   ,     ,         JVM  -. </p><br><p>         : </p><br><div class="spoiler"> <b class="spoiler_title">Hello World</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">.bytecode 52.0 .source Main.j .class public Main .super java/lang/Object .method public static main([Ljava/lang/String;)V .limit stack 2 .limit locals 2 getstatic java/lang/System/out Ljava/io/PrintStream; ldc "Hello world!" invokevirtual java/io/PrintStream.println(Ljava/lang/String;)V return .end method</code> </pre> </div></div><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="plaintext hljs">; ClassCreating.j .bytecode 52.0 .source ClassCreating.java .class public ClassCreating .super java/lang/Object .method public &lt;init&gt;()V .limit stack 1 .limit locals 1 .line 1 0: aload_0 1: invokespecial java/lang/Object/&lt;init&gt;()V 4: return .end method .method public static main([Ljava/lang/String;)V ; Flag ACC_VARARGS set, see JVM spec .limit stack 2 .limit locals 3 .line 3 0: new java/lang/String 3: dup 4: invokespecial java/lang/String/&lt;init&gt;()V 7: astore_1 .line 4 8: new ClassCreating 11: dup 12: invokespecial ClassCreating/&lt;init&gt;()V 15: astore_2 .line 5 16: aload_2 17: invokevirtual ClassCreating/sayHello()V .line 6 20: return .end method .method public sayHello()V .limit stack 2 .limit locals 1 .line 9 0: getstatic java/lang/System/out Ljava/io/PrintStream; 3: ldc "Hello, User!" 5: invokevirtual java/io/PrintStream/println(Ljava/lang/String;)V .line 10 8: return .end method</code> </pre> </div></div><br><hr><br><p>       Hello World </p><br><p>  -       : <a href="https://gist.github.com/AppLoidx/7173d7277dd73025ae06377a7cc75ed0">gist.github</a> </p><br><p>          . </p><br><p>  <strong>Literatur bekas</strong> </p><br><ul><li> The Java Virtual Machine Specification ‚Äî <a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf">docs.oracle</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480550/">https://habr.com/ru/post/id480550/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480532/index.html">EDA dari sudut yang berbeda</a></li>
<li><a href="../id480534/index.html">16 tips pengembangan untuk android di Kotlin. Bagian 2</a></li>
<li><a href="../id480538/index.html">Apa yang lebih baik untuk game: Intel Optane atau SSD?</a></li>
<li><a href="../id480540/index.html">Rilis Umbraco 8.4: CMS bahkan lebih nyaman</a></li>
<li><a href="../id480542/index.html">Kesadaran Keamanan Dewasa: Cara Menutup Kerentanan Phishing</a></li>
<li><a href="../id480552/index.html">Firefox bertarung demi masa depan web</a></li>
<li><a href="../id480554/index.html">Masa depan komputasi awan Sun yang tidak pernah datang</a></li>
<li><a href="../id480556/index.html">NGINX: Verifikasi komunitas TI Rusia</a></li>
<li><a href="../id480558/index.html">Bagaimana tingkat penambangan impas memungkinkan Anda untuk menentukan titik pivot bitcoin</a></li>
<li><a href="../id480564/index.html">REST API di Java tanpa kerangka kerja</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>