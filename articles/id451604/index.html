<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👲🏾 👩‍🌾 👨‍🎨 Artikel ini terlalu banyak air. 👨🏽‍🏭 🤱🏼 👨🏿‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="“Kami mulai mengembangkan game baru, dan kami membutuhkan air dingin. Bisakah kamu melakukan ini? ” 


 - tanya saya. "Ya, tidak ada pertanyaan! Tentu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Artikel ini terlalu banyak air.</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451604/">  “Kami mulai mengembangkan game baru, dan kami membutuhkan air dingin.  Bisakah kamu melakukan ini? ” <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/iilqtDkeIBE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - tanya saya.  "Ya, tidak ada pertanyaan!  Tentu saja saya bisa, ”jawab saya, tetapi suara saya gemetar.  “Dan juga tentang Persatuan?” - dan menjadi jelas bagi saya bahwa ada banyak pekerjaan di depan. <br><a name="habracut"></a><br>  Jadi, air.  Sampai saat itu saya belum melihat Unity, persis seperti C #, jadi saya memutuskan untuk membuat prototipe pada alat yang saya tahu: C ++ dan DX9.  Apa yang saya tahu dan sanggup praktikkan pada saat itu adalah tekstur bergulir normal untuk membentuk permukaan, dan pemetaan perpindahan primitif berdasarkan pada mereka.  Segera perlu mengubah segalanya.  Bentuk animasi realistis dari permukaan air.  Naungan rumit (sangat).  Generasi busa.  Sistem LOD terpasang ke kamera.  Saya mulai mencari informasi di Internet bagaimana melakukan semua ini. <br><br>  Poin pertama, tentu saja, adalah pemahaman tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Simulasi Air Laut</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jerry Tessendorf</a> . <br><br>  Pager akademis dengan banyak formula yang tidak masuk akal tidak pernah diberikan kepada saya banyak, jadi setelah beberapa bacaan saya sedikit mengerti.  Prinsip-prinsip umum jelas: setiap frame dihasilkan oleh peta ketinggian menggunakan Fast Fourier Transform, yang, sebagai fungsi waktu, dengan lancar mengubah bentuknya untuk membentuk permukaan air yang realistis.  Tapi bagaimana dan apa yang harus dihitung, saya tidak tahu.  Saya perlahan-lahan mempelajari kebijaksanaan menghitung FFT pada shader di D3D9, dan kode sumber dengan artikel di suatu tempat di belantara Internet, yang saya coba temukan selama satu jam, tetapi tidak berhasil (sayangnya), benar-benar membantu saya.  Hasil pertama diperoleh (menakutkan sebagai perang nuklir): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/tdfwF1R81O4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Memulai kesuksesan dengan senang hati, dan transfer air ke Unity dimulai dengan penyelesaiannya. <br><br>  Beberapa persyaratan diajukan untuk pertandingan dalam pertempuran laut: <br><br><ul><li>  Tampilan realistis.  Cantik sebagai foreshortenings dekat dan jauh, busa dinamis, pencar, dll. </li><li>  Dukungan untuk berbagai kondisi cuaca: kondisi tenang, badai, dan menengah.  Ubah waktu hari. </li><li>  Fisika daya apung kapal pada permukaan yang disimulasikan, benda mengambang. </li><li>  Karena gim ini multipemain, airnya harus sama untuk semua peserta dalam pertempuran. </li><li>  Permukaan gambar: bidang yang ditarik dari penerbangan inti voli, busa dari masuknya inti ke dalam air. </li></ul><br><h3>  Geometri </h3><br>  Diputuskan untuk membangun struktur seperti quadtree, dengan pusat di sekitar kamera, yang dibangun kembali secara terpisah ketika pengamat bergerak.  Mengapa diskrit?  Jika Anda memindahkan mesh dengan lancar dengan kamera atau menggunakan proyeksi ruang layar seperti pada artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Real-time water rendering - memperkenalkan konsep grid yang diproyeksikan</a> , maka dalam rencana jangka panjang, karena resolusi geometri mesh yang tidak mencukupi, poligon akan “melompat” ke atas dan bawah.  Ini sangat mengejutkan.  Gambarnya beriak.  Untuk mengatasinya, seseorang harus sangat meningkatkan resolusi poligon kasa air, atau "meratakan" geometri jarak jauh, atau membangun dan memindahkan poligon sehingga perubahan ini tidak terlihat.  Air kami progresif (hehe) dan saya memilih jalan ketiga.  Seperti dalam teknik serupa (terutama yang akrab bagi semua orang yang menciptakan medan dalam permainan), Anda harus menyingkirkan persimpangan-T di perbatasan transisi tingkat detail.  Untuk mengatasi masalah ini, pada awalnya 3 jenis paha depan dengan parameter tessellation yang diberikan dihitung: <br><br><img src="https://habrastorage.org/webt/al/df/nw/aldfnwtnd2iihq2np9juxe5lvjm.jpeg"><br><br>  Jenis pertama adalah untuk paha depan yang tidak transisi ke detail yang lebih rendah.  Tidak ada pihak yang memiliki jumlah simpul dikurangi 2 kali lipat.  Tipe kedua adalah untuk batas, tetapi bukan paha depan sudut.  Tipe ketiga adalah paha batas sudut.  Water mesh terakhir dibangun dengan memutar dan menskalakan ketiga jenis jerat ini. <br><br>  Ini adalah bagaimana penampilan dengan warna yang berbeda dari level air LOD terlihat. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/JycUZlod3xs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Bingkai pertama menunjukkan hubungan dua tingkat detail yang berbeda. <br><br>  Video sebagai bingkai diisi dengan paha air: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/VldNrYKLb0w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Biarkan saya mengingatkan Anda bahwa itu sudah lama sekali (dan tidak benar).  Sekarang lebih optimal dan fleksibel dapat dilakukan langsung pada GPU (GPU Pro 5. Quadtrees pada GPU).  Dan itu akan menarik dalam satu panggilan undian, dan tessellation dapat meningkatkan detail. <br><br>  Kemudian, proyek pindah ke D3D11, tetapi tangan tidak mencapai peningkatan bagian ini membuat laut. <br><br><h3>  Generasi bentuk gelombang </h3><br>  Untuk ini kita perlu Fast Fourier Transform.  Untuk resolusi tekstur gelombang yang dipilih (anggap saja untuk saat ini, saya akan menjelaskan data apa yang disimpan di sana), kami menyiapkan data awal menggunakan parameter yang ditetapkan oleh para seniman (kekuatan, arah angin, ketergantungan gelombang pada arah angin dan lainnya).  Semua ini harus dimasukkan ke dalam formula yang disebut.  Spektrum Phillips  Kami memodifikasi data awal yang diperoleh untuk setiap frame dengan mempertimbangkan waktu dan melakukan FFT pada mereka.  Pada output, kami mendapatkan tekstur ubin di semua arah yang berisi offset simpul datar.  Mengapa bukan sekadar peta ketinggian?  Jika Anda hanya menyimpan tinggi offset, maka hasilnya akan menjadi massa "gelembung" yang tidak realistis, yang hanya menyerupai laut: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2234r1xpuI8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Jika kita mempertimbangkan perpindahan untuk ketiga koordinat, maka gelombang realistis "tajam" yang indah akan dihasilkan: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/tFhKaV1u-AY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Satu tekstur animasi tidak cukup.  Ubin terlihat, tidak cukup detail dalam waktu dekat.  Kami mengambil algoritma yang dijelaskan dan membuat bukan hanya satu, melainkan 3 tekstur yang dihasilkan fft.  Yang pertama adalah ombak besar.  Ini mengatur bentuk gelombang dasar dan digunakan untuk fisika.  Yang kedua adalah gelombang sedang.  Dan akhirnya, yang terkecil.  3 generator FFT (opsi ke-4 adalah campuran terakhir): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/gqxbAOS4sGM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Parameter lapisan diatur secara independen satu sama lain, dan tekstur yang dihasilkan dicampur dalam shader air ke dalam bentuk gelombang akhir.  Sejalan dengan offset, peta normal setiap lapisan juga dihasilkan. <br><br>  "Keseragaman" air di semua peserta pertempuran dipastikan dengan sinkronisasi parameter laut di awal pertempuran.  Informasi ini dikirimkan oleh server ke setiap klien. <br><br><h3>  Model daya apung fisik </h3><br>  Karena itu perlu untuk membuat tidak hanya gambar yang indah, tetapi juga perilaku kapal yang realistis.  Dan dengan mempertimbangkan fakta bahwa lautan badai (ombak besar) harus ada dalam permainan, tugas lain yang perlu diselesaikan adalah memastikan daya apung benda-benda di permukaan laut yang dihasilkan.  Pertama saya mencoba membuat GPU membaca kembali tekstur gelombang.  Tetapi, karena dengan cepat menjadi jelas bahwa semua fisika pertempuran laut harus dilakukan di server, laut, atau lebih tepatnya lapisan pertama, yang menetapkan bentuk gelombang, juga harus dibaca di server (dan, kemungkinan besar, tidak ada yang cepat dan / atau kompatibel dengan GPU), diputuskan untuk menulis salinan fungsional lengkap generator FFT GPU pada CPU dalam bentuk plug-in C ++ asli untuk Unity.  Saya tidak mengimplementasikan algoritma FFT sendiri dan menggunakannya di perpustakaan Intel Performance Primitives (IPP).  Tetapi semua pengikatan dan postprocessing dari hasil dilakukan oleh saya, diikuti oleh optimasi pada SSE dan paralelisasi oleh utas.  Ini termasuk persiapan array data untuk FFT setiap frame, dan konversi akhir dari nilai yang dihitung ke peta offset gelombang. <br><br>  Ada fitur lain yang menarik dari algoritma, yang didasarkan pada persyaratan untuk fisika air.  Yang dibutuhkan adalah fungsi untuk mendapatkan ketinggian gelombang dengan cepat pada titik tertentu di dunia.  Ini logis, karena ini adalah dasar untuk membangun daya apung dari objek apa pun.  Tetapi, karena pada output prosesor FFT kita mendapatkan offsetmap, bukan heightmap, pilihan biasa dari tekstur tidak memberi kita ketinggian gelombang jika diperlukan.  Untuk kesederhanaan, pertimbangkan opsi 2D: <br><br><img src="https://habrastorage.org/webt/u6/ec/pe/u6ecpek-vcazrjpgh4ygxwhon2g.jpeg"><br><br>  Untuk membentuk gelombang, texels (elemen tekstur yang ditunjukkan oleh garis-garis vertikal) berisi vektor (panah) yang mengatur offset titik puncak flat mesh (titik biru) ke arah posisi akhir (ujung panah).  Misalkan kita mengambil data ini dan mencoba mengekstraksi ketinggian air pada titik yang menarik bagi kita.  Sebagai contoh, kita perlu mengetahui ketinggian di hB.  Jika kita mengambil vektor texel tB, maka kita mendapatkan offset ke titik dekat hC, yang bisa sangat berbeda dari yang kita butuhkan.  Ada dua opsi untuk menyelesaikan masalah ini: pada setiap permintaan tinggi, periksa set texels yang berdekatan sampai kami menemukan satu yang memiliki offset ke posisi yang menarik bagi kami.  Dalam contoh kami, kami menemukan texel tA berisi offset terdekat.  Tetapi pendekatan ini tidak bisa disebut cepat.  Memindai radius texel tidak jelas ukuran apa (dan apakah laut badai atau tenang, pemindahan bisa sangat bervariasi) dapat memakan waktu lama. <br><br>  Opsi kedua - setelah menghitung peta ofset, mengonversinya menjadi peta ketinggian menggunakan pendekatan hamburan.  Ini berarti bahwa untuk setiap vektor offset, kami menulis ketinggian gelombang yang ditetapkannya ke titik di mana ia digeser.  Ini akan menjadi array data yang terpisah, yang akan digunakan untuk mendapatkan ketinggian di tempat tujuan.  Menggunakan ilustrasi kami, sel tB akan berisi tinggi hB yang diperoleh dari vektor tA → hB.  Ada satu fitur lagi.  Sel tA tidak akan berisi nilai yang valid, karena tidak ada vektor yang bergerak ke dalamnya.  Untuk mengisi "lubang" seperti itu, sebuah bagian dibuat untuk mengisinya dengan nilai-nilai tetangga. <br><br>  Ini adalah tampilannya jika Anda membuat visualisasi perpindahan menggunakan vektor (offset merah-besar, hijau-kecil): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/uBk8F55lR74" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Sisanya sederhana.  Pesawat dari garis air bersyarat diatur untuk kapal.  Di atasnya, grid persegi titik sampel ditentukan, yang mendefinisikan tempat penerapan kekuatan mendorong keluar dari air untuk kapal.  Kemudian untuk setiap titik kami memeriksa apakah itu di bawah air atau tidak menggunakan peta ketinggian air yang dijelaskan di atas.  Jika titik berada di bawah air, maka berikan gaya vertikal ke lambung fisika benda pada titik ini, diskalakan dengan jarak dari titik ke permukaan air.  Jika di atas air, maka kita tidak melakukan apa-apa, gravitasi akan melakukan segalanya untuk kita.  Faktanya, formula di sana sedikit lebih rumit (semua untuk penyempurnaan perilaku kapal), tetapi prinsip dasarnya adalah ini.  Dalam video visualisasi daya apung di bawah ini, kubus biru adalah lokasi sampel, dan garis-garis di bawahnya adalah besarnya gaya yang mendorong keluar dari air. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mwNRIKbRdpQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Dalam implementasi server ada titik optimasi lain yang menarik.  Tidak perlu mensimulasikan air yang berbeda untuk instance pertempuran yang berbeda jika mereka lulus dalam kondisi cuaca yang sama (parameter simulator FFT yang sama).  Jadi keputusan logisnya adalah membuat kumpulan simulator, yang unit tempur memenuhi permintaan untuk mendapatkan air simulasi dengan parameter yang diberikan.  Jika parameternya sama dari beberapa kejadian, maka air yang sama akan kembali ke mereka.  Ini diimplementasikan menggunakan Memor Mapped File API.  Ketika simulator FFT dibuat, itu memberikan akses ke datanya dengan mengekspor deskriptor dari blok yang diperlukan.  Contoh server, bukannya meluncurkan simulator nyata, meluncurkan "boneka" yang hanya memberikan data yang dibuka oleh deskriptor ini.  Ada beberapa bug lucu yang terkait dengan fungsi ini.  Karena kesalahan penghitungan referensi, simulator dihancurkan, tetapi file yang dipetakan memori masih hidup sementara setidaknya satu pegangan untuk itu terbuka.  Data berhenti diperbarui (tidak ada simulator) dan air "berhenti". <br><br>  Di sisi klien, kami membutuhkan informasi tentang bentuk gelombang untuk menghitung penetrasi inti ke dalam gelombang dan memainkan sistem partikel dan busa.  Kerusakan dihitung pada server dan di sana juga perlu untuk menentukan dengan benar apakah inti telah masuk ke air (gelombang dapat menutup kapal, terutama dalam badai).  Di sini sudah diperlukan untuk melakukan pelacakan peta ketinggian dengan analogi seperti yang dilakukan dalam pemetaan paralaks atau efek SSAO. <br><br><h3>  Shading </h3><br>  Pada prinsipnya, seperti di tempat lain.  Refleksi, refraksi, hamburan bawah permukaan secara licik diremas, dengan mempertimbangkan kedalaman bagian bawah, kami memperhitungkan efek fresnel, kami mempertimbangkan specular.  Kami mempertimbangkan hamburan untuk punggungan tergantung pada posisi matahari.  Busa dihasilkan sebagai berikut: buat "titik busa" pada puncak gelombang (gunakan ketinggian sebagai metrik), lalu terapkan bintik yang baru dibuat ke bintik-bintik dari bingkai sebelumnya sambil mengurangi intensitasnya.  Dengan demikian, kami memperoleh noda bintik busa dalam bentuk ekor dari lambang gelombang berjalan. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/MyzFcwr641g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Kami menggunakan tekstur "bintik-bintik" yang diperoleh sebagai topeng yang kami gunakan untuk mencampur tekstur gelembung, noda, dll. Kami mendapatkan pola busa dinamis yang cukup realistis di permukaan gelombang.  Topeng ini dibuat untuk setiap lapisan FFT (saya ingatkan Anda, kami memiliki 3 dari mereka), dan dalam campuran terakhir mereka semua bercampur. <br><br>  Video di atas memvisualisasikan topeng busa.  Lapisan pertama dan kedua.  Saya memodifikasi parameter generator dan hasilnya terlihat pada tekstur. <br><br>  Dan sebuah video dari laut badai yang agak kikuk.  Di sini Anda dapat melihat dengan jelas bentuk gelombang, kemampuan generator, dan busa: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/MAPUbmV4BAA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Gambar air </h3><br>  Gambar penggunaan: <br><br><img src="https://habrastorage.org/webt/zz/gz/1p/zzgz1pslmj1tg5si7o8mwnxqjye.jpeg"><br><br>  Digunakan untuk: <br><br><ul><li>  Penanda, visualisasi zona ekspansi inti. </li><li>  Gambar busa pada titik di mana inti menabrak air. </li><li>  Bangun kapal berbusa </li><li>  Memeras air di bawah kapal untuk menghilangkan efek ombak yang membanjiri geladak dan palka yang banjir. </li></ul><br>  Kasus dasar yang jelas adalah texturing proyektif.  Itu diimplementasikan.  Tetapi ada persyaratan tambahan.  Spesies terdekat - sabun karena resolusi yang tidak mencukupi (Anda dapat meningkatkan, tetapi tidak tanpa batas), dan saya ingin gambar proyeksi di atas air ini menjadi jauh terlihat.  Di mana masalah yang sama diselesaikan?  Itu benar, dalam bayangan (bayangan peta).  Bagaimana dia dipecahkan di sana?  Kanan, Cascaded (Parallel Split) Shadow Map.  Kami juga akan menggunakan teknologi ini dan menerapkannya pada tugas kami.  Kami memecah frustum kamera menjadi subfrust N (3-4 biasanya).  Untuk masing-masing, kami membuat persegi panjang yang menggambarkan di bidang horizontal.  Untuk setiap persegi panjang seperti itu, kami membuat matriks proyeksi ortografis dan menggambar semua objek yang menarik untuk masing-masing kamera ortho tersebut.  Setiap kamera tersebut menarik ke dalam tekstur yang terpisah, dan kemudian, di shader lautan, kami menggabungkan mereka menjadi satu gambar proyeksi yang solid. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/etG8tddmbmk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Jadi saya meletakkan pesawat besar dengan tekstur bendera di laut: <br><br><img src="https://habrastorage.org/webt/pd/uk/jr/pdukjrlnug2wu4debjrhlxbdxrc.jpeg"><br><br>  Inilah yang mengandung splits: <br><br><img src="https://habrastorage.org/webt/ez/dw/nm/ezdwnm3u85dzpavd5iz8e2u9q2k.jpeg"><br><br>  Selain gambar-gambar yang biasa, perlu untuk menggambar topeng busa tambahan (untuk jejak kapal dan tempat-tempat di mana inti menabrak) dengan cara yang persis sama, serta topeng untuk memeras air di bawah kapal.  Ini banyak kamera dan banyak gang.  Pada awalnya itu bekerja begitu mengerem, tetapi kemudian, setelah beralih ke D3D11, menggunakan "propagasi" geometri dalam shader geometris dan menggambar setiap salinan menjadi target render terpisah melalui SV_RenderTergetArrayIndex, sangat mungkin untuk mempercepat efek ini. <br><br><h3>  Perbaikan dan peningkatan </h3><br>  D3D11 adalah tangan yang sangat bebas dalam banyak momen.  Setelah beralih ke sana dan Unity 5, saya membuat generator FFT pada compute shaders.  Secara visual, tidak ada yang berubah, tetapi menjadi sedikit lebih cepat.  Terjemahan kesalahan perhitungan tekstur refleksi dari render kamera lengkap yang terpisah untuk teknologi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Screen Space Planar Reflections</a> memberikan dorongan yang baik dalam kinerja.  Saya menulis tentang optimalisasi objek permukaan air di atas, tetapi tangan saya tidak mencapai transfer jala ke Quadtree GPU. <br><br>  Banyak yang bisa dilakukan dengan lebih optimal dan sederhana.  Misalnya, jangan pagar kebun dengan simulator CPU, tetapi cukup jalankan opsi GPU pada server dengan perangkat d3d WARP (perangkat lunak).  Array data di sana tidak terlalu besar. <br><br>  Nah, secara umum, entah bagaimana.  Pada saat pembangunan dimulai, semuanya modern dan keren.  Sekarang sudah menjadi tua di beberapa tempat.  Ada lebih banyak bahan yang tersedia, bahkan ada analog yang mirip dengan github: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Crest</a> .  Sebagian besar game yang memiliki lautan menggunakan pendekatan yang serupa. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451604/">https://habr.com/ru/post/id451604/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451594/index.html">PHP Russia 2019 Report Guide</a></li>
<li><a href="../id451596/index.html">Grey Cardinal .NET - John Galloway</a></li>
<li><a href="../id451598/index.html">Unit Fairy Magic Fairy: DSL dalam C #</a></li>
<li><a href="../id451600/index.html">Cara menulis surat pengantar saat mencari pekerjaan di AS: 7 tips</a></li>
<li><a href="../id451602/index.html">Kami mempelajari MITER ATT & CK. Matriks Seluler: Akses Perangkat. Bagian 1</a></li>
<li><a href="../id451606/index.html">Sejarah Internet: Peluruhan, Bagian 2</a></li>
<li><a href="../id451610/index.html">Security Week 20: menonaktifkan ekstensi Firefox</a></li>
<li><a href="../id451614/index.html">"Apa yang kita diskusikan di Rusia juga relevan di Barat": wawancara dengan Denis Neklyudov</a></li>
<li><a href="../id451618/index.html">CampusInsight: Dari Pemantauan Infrastruktur hingga Analisis Pengalaman Pengguna</a></li>
<li><a href="../id451620/index.html">Otorisasi otomatis pada kartu Strava Heatmap</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>