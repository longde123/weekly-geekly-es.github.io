<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤞🏿 🤚🏾 📚 Wie man eine gute Reparatur von einer schlechten unterscheidet oder wie wir in SRG eine Multithread-Java-Bibliothek aus dem Tomit-Parser erstellt haben 🕺 🤲🏿 🚰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel wird erläutert, wie wir den von Yandex entwickelten Tomita-Parser in unser System integriert, in eine dynamische Bibliothek umgewand...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man eine gute Reparatur von einer schlechten unterscheidet oder wie wir in SRG eine Multithread-Java-Bibliothek aus dem Tomit-Parser erstellt haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/srg/blog/439614/">  In diesem Artikel wird erläutert, wie wir den von Yandex entwickelten Tomita-Parser in unser System integriert, in eine dynamische Bibliothek umgewandelt, uns mit Java angefreundet, Multithreading durchgeführt und damit das Problem der Textklassifizierung für die Immobilienbewertung gelöst haben. <br><br><img src="https://habrastorage.org/webt/vi/om/ub/viomubb37jryhlbwqzqucsl583s.jpeg"><br><a name="habracut"></a><br><h3>  Erklärung des Problems </h3><br>  Bei der Immobilienbewertung ist die Analyse von Verkaufsankündigungen von großer Bedeutung.  Aus der Ankündigung können Sie alle notwendigen Informationen über die Immobilie erhalten, einschließlich Informationen über den Zustand der Reparatur in der Wohnung.  Normalerweise sind diese Informationen im Anzeigentext enthalten.  Dies ist bei der Beurteilung sehr wichtig, da eine gute Reparatur den Quadratmeterpreis um mehrere Tausend erhöhen kann. <br><br>  Wir haben also einen Anzeigentext, der je nach Reparaturzustand in der Wohnung in eine der Kategorien eingeteilt werden muss (unvollendet, fair, durchschnittlich, gut, ausgezeichnet, exklusiv).  Bei Reparaturen kann eine Anzeige ein oder zwei Sätze, ein paar Wörter oder nichts enthalten. Daher ist es nicht sinnvoll, den Text vollständig zu klassifizieren.  Aufgrund der Spezifität des Textes und der begrenzten Anzahl von Wörtern im Zusammenhang mit dem Reparaturkontext bestand die einzig sinnvolle Lösung darin, alle erforderlichen Informationen aus dem Text zu extrahieren und zu klassifizieren. <br><br><img src="https://habrastorage.org/webt/p9/jr/id/p9jrid1dluodkjquebvvr7yc5dq.png" alt="Bild"><br><br>  Jetzt müssen wir lernen, wie wir aus dem Text alle Fakten über den Zustand der Dekoration extrahieren können.  Insbesondere, was direkt mit der Reparatur zusammenhängt, sowie alles, was indirekt über den Zustand der Wohnung sprechen kann - das Vorhandensein von abgehängten Decken, Einbaugeräten, Kunststofffenstern, einem Whirlpool, die Verwendung teurer Veredelungsmaterialien usw. <br><br>  In diesem Fall müssen wir nur Informationen über Reparaturen in der Wohnung selbst extrahieren, da uns der Zustand der Eingänge, Keller und Dachböden nicht interessiert.  Es ist auch notwendig zu berücksichtigen, dass der Text in natürlicher Sprache mit all seinen inhärenten Fehlern, Tippfehlern, Abkürzungen und anderen Merkmalen geschrieben ist. Ich persönlich habe drei Schreibweisen der Wörter „Linoleum“ und „Laminat“ und fünf Schreibweisen des Wortes „endgültig“ gefunden.  Einige Leute verstehen nicht, warum Leerzeichen zwischen Wörtern benötigt werden, während andere nichts von Kommas gehört haben.  Daher wurde der Parser mit kontextfrei freien Grammatiken zur einfachsten und vernünftigsten Lösung. <br><br>  Als die Entscheidung getroffen wurde, wurde eine zweite große und interessante Aufgabe gebildet - zu lernen, wie alle ausreichenden und notwendigen Informationen über die Reparatur aus der Ankündigung extrahiert werden können, nämlich eine schnelle syntaktische und morphologische Analyse des Textes bereitzustellen, die im Bibliotheksmodus unter Last parallel arbeiten kann. <br><br><h3>  Fahren Sie mit der Lösung fort </h3><br>  Von den verfügbaren Mitteln zum Extrahieren von Fakten aus Text basierend auf kontextfreien Grammatiken, die mit der russischen Sprache arbeiten können, wurde unsere Aufmerksamkeit auf Tomita-Parser und die Yagry-Bibliothek in Python gelenkt.  Yagry wurde sofort abgelehnt, da es vollständig in Python geschrieben und kaum gut optimiert ist.  Und Tomita sah anfangs sehr attraktiv aus: Sie hatte eine detaillierte Dokumentation für den Entwickler und viele Beispiele, C ++ versprach eine akzeptable Geschwindigkeit.  Es war nicht schwer, die Regeln für das Schreiben von Grammatiken zu verstehen, und die erste Version des Klassifikators mit seiner Verwendung war bereits am nächsten Tag fertig. <br><br>  Beispiele für Regeln aus unserer Grammatik, die Adjektive und Verben im Zusammenhang mit dem Reparaturkontext extrahieren: <br><br><pre><code class="javascript hljs">RepairW -&gt; <span class="hljs-string"><span class="hljs-string">""</span></span> | <span class="hljs-string"><span class="hljs-string">""</span></span> | <span class="hljs-string"><span class="hljs-string">""</span></span>; StopWords -&gt; <span class="hljs-string"><span class="hljs-string">""</span></span> | <span class="hljs-string"><span class="hljs-string">""</span></span> | <span class="hljs-string"><span class="hljs-string">""</span></span> | <span class="hljs-string"><span class="hljs-string">""</span></span>; Repair -&gt; RepairW&lt;gnc-agr[<span class="hljs-number"><span class="hljs-number">1</span></span>]&gt; Adj&lt;gnc-agr[<span class="hljs-number"><span class="hljs-number">1</span></span>]&gt;+ interp (Repair.AdjGroup {weight = <span class="hljs-number"><span class="hljs-number">0.5</span></span>}); Repair -&gt; Verb&lt;gnc-agr[<span class="hljs-number"><span class="hljs-number">1</span></span>]&gt; Adj&lt;gnc-agr[<span class="hljs-number"><span class="hljs-number">1</span></span>]&gt;* interp (Repair.Verb) RepairW&lt;gnc-agr[<span class="hljs-number"><span class="hljs-number">1</span></span>]&gt; {weight = <span class="hljs-number"><span class="hljs-number">0.5</span></span>};</code> </pre> <br>  Regeln, mit denen sichergestellt wird, dass keine Informationen zum Status öffentlicher Räume abgerufen werden: <br><br><pre> <code class="javascript hljs">Repair -&gt; StopWords Verb* Prep* Adj* RepairW; Repair -&gt; Adj+ RepairW Prep* StopWords;</code> </pre><br>  Standardmäßig ist das Gewicht der Regel 1, wobei der Regel ein kleineres Gewicht zugewiesen wird. Wir legen die Reihenfolge ihrer Ausführung fest. <br><br>  Es war ein wenig peinlich, dass nur die Konsolenanwendung und eine Menge C ++ - Code in die Öffentlichkeit hochgeladen wurden.  Der zweifelsfreie Vorteil war jedoch die einfache Bedienung und die schnellen Ergebnisse bei Experimenten.  Daher wurde beschlossen, über die möglichen Schwierigkeiten nachzudenken, es näher an der Implementierung selbst in unser System einzuführen. <br><br>  Fast sofort war es möglich, nahezu alle notwendigen Informationen über die Reparatur in hoher Qualität zu extrahieren.  "Fast", weil anfangs einige Wörter unter keinen Bedingungen und Grammatiken extrahiert wurden.  Es war jedoch schwierig, das Ausmaß dieses Problems sofort einzuschätzen, inwieweit es die Qualität der Lösung des gesamten Klassifizierungsproblems beeinflussen kann. <br><br>  Nachdem wir sichergestellt hatten, dass Tomita uns in erster Näherung die erforderlichen Funktionen zur Verfügung stellt, stellten wir fest, dass es keine Option ist, sie als Konsolenanwendung zu verwenden: Erstens erwies sich die Konsolenanwendung aus unbekannten Gründen als instabil und stürzte von Zeit zu Zeit ab, und zweitens bot sie keine die erforderliche Parsing-Last von mehreren Millionen Anzeigen pro Tag.  So wurde definitiv klar, woraus man eine Bibliothek machen sollte. <br><br><h3>  Wie wir Tomitha zu einer Multithread-Bibliothek gemacht und uns mit Java angefreundet haben </h3><br>  Unser System ist in Java geschrieben, Tomita-Parser in C ++.  Wir mussten in der Lage sein, Parsing-Anzeigentext von Java aus aufzurufen. <br><br>  Die Entwicklung von Java-Bindungen für Tomita-Parser kann bedingt in zwei Komponenten unterteilt werden - die Implementierung der Möglichkeit, Tomita als gemeinsam genutzte Bibliothek zu verwenden und tatsächlich eine Integrationsschicht mit jvm zu schreiben.  Die Hauptschwierigkeit betraf den ersten Teil.  Tomita selbst war ursprünglich für die Ausführung in einem separaten Prozess konzipiert.  Daraus folgte, dass die Haupthindernisse für die Verwendung des Parsers im Bewerbungsprozess zwei Faktoren waren. <br><br><ol><li>  Der Datenaustausch wurde über verschiedene Arten von E / A durchgeführt.  Es war erforderlich, die Fähigkeit zum Datenaustausch mit dem Parser über den Speicher zu implementieren.  Darüber hinaus war es notwendig, dies so zu tun, dass der Code des Parsers selbst minimal beeinflusst wurde.  Die Architektur von Tomita schlug eine Möglichkeit vor, das Lesen von Eingabedokumenten aus dem Speicher als Implementierung der Schnittstellen CDocStreamBase und CDocListRetrieverBase zu implementieren.  Bei der Ausgabe war es schwieriger - ich musste den Code des XML-Generators berühren. </li><li>  Der zweite Faktor, der sich aus dem Prinzip „ein Parser - ein Prozess“ ergibt, ist der globale Status, der aus verschiedenen Instanzen des Parsers modifiziert wurde.  Wenn Sie sich die Datei <a href="">src / util / generic / singleton.h ansehen</a> , sehen Sie den Mechanismus für die Verwendung des freigegebenen Status.  Es ist leicht vorstellbar, dass bei Verwendung von zwei Parser-Instanzen im selben Adressraum eine Race-Bedingung auftritt.  Um nicht den gesamten Parser neu zu schreiben, wurde beschlossen, diese Klasse zu ändern und den globalen Status durch einen lokalen Status relativ zum Thread (thread_local) zu ersetzen.  Dementsprechend setzen wir diese thread_local-Variablen vor jedem Parser-Aufruf im JTextMiner-Wrapper auf die aktuelle Parser-Instanz. Danach arbeitet der Parser-Code mit den Adressen der aktuellen Parser-Instanz. </li></ol><br>  Nachdem diese beiden Faktoren beseitigt wurden, konnte der Parser in jeder Umgebung als gemeinsam genutzte Bibliothek verwendet werden.  Das Schreiben von JNI-Bindemitteln und eines Java-Wrappers war nicht länger schwierig. <br><br>  Der Tomita-Parser muss vor der Verwendung konfiguriert werden.  Die Konfigurationsparameter ähneln denen, die beim Aufrufen des Konsolendienstprogramms verwendet werden.  Das Parsen selbst besteht darin, die parse () -Methode aufzurufen, die Dokumente zum Parsen empfängt und XML als Zeichenfolge mit den Ergebnissen des Parsers zurückgibt. <br><br>  Die Multithread-Version von Tomita - TomitaPooledParser verwendet zum Parsen eines Pools von TomitaParser-Objekten, die auf die gleiche Weise konfiguriert sind.  Zum Parsen wird der erste freie Parser verwendet.  Da die Anzahl der erstellten Parser der Anzahl der Threads im Pool entspricht, ist immer mindestens ein Parser für die Aufgabe verfügbar.  Die Analysemethode analysiert asynchron die bereitgestellten Dokumente im ersten freien Parser. <br><br>  Ein Beispiel für den Aufruf der Tomita-Bibliothek von Java aus: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> threadAmount number of threads in the pool * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> tomitaConfigFilename tomita config.proto * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> configDirname dir with configs: grammars, gazetteer, facttypes.proto */</span></span> tomitaPooledParser = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TomitaPooledParser(threadAmount, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(configDirname), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String[]{tomitaConfigFilename}); Future&lt;String&gt; result = tomitaPooledParser.parse(documents); String response = result.get();</code> </pre><br>  Als Antwort eine XML-Zeichenfolge mit dem Ergebnis der Analyse. <br><br><h3>  Probleme, auf die wir gestoßen sind und wie wir sie gelöst haben </h3><br>  Wenn die Bibliothek fertig ist, starten wir den Dienst mit seiner Verwendung für eine große Datenmenge und erinnern uns an das Problem, einige Wörter nicht zu extrahieren, und erkennen, dass dies für unsere Aufgabe sehr wichtig ist. <br><br>  Unter diesen Wörtern befanden sich "vorgefiltert" sowie "erledigt", "produziert" und andere gekürzte Partizipien.  Das heißt, die Wörter, die sehr oft in der Anzeige gefunden werden, und manchmal ist dies die einzige oder sehr wichtige Information über die Reparatur.  Der Grund für dieses Verhalten - das Wort „vorgefiltert“ stellte sich als Wort mit unbekannter Morphologie heraus, dh Tomita kann einfach nicht bestimmen, welcher Teil der Sprache es ist, und kann es dementsprechend nicht extrahieren.  Und für gekürzte Partizipien musste ich eine separate Regel schreiben, und das Problem wurde gelöst, aber es dauerte einige Zeit, um herauszufinden, dass es sich um abgekürzte Partizipien handelt, für deren Extraktion eine spezielle Regel erforderlich ist.  Und für das langmütige „endgültige“ Ende musste ich eine separate Regel für ein Wort mit einer unbekannten Morphologie schreiben. <br><br>  Um Analyseprobleme mithilfe von Grammatiken zu lösen, fügen wir dem Ortsverzeichnis ein Wort mit unbekannter Morphologie hinzu: <br><br><pre> <code class="javascript hljs">TAuxDicArticle <span class="hljs-string"><span class="hljs-string">"adjNonExtracted"</span></span> { key = <span class="hljs-string"><span class="hljs-string">""</span></span> | <span class="hljs-string"><span class="hljs-string">"-"</span></span> }</code> </pre><br>  Für abgekürzte Partizipien verwenden wir die grammatikalischen Eigenschaften von partcp, brev. <br><br>  Und jetzt können wir die Regeln für diese Fälle schreiben: <br><br><pre> <code class="javascript hljs">Repair -&gt; RepairW&lt;gnc-agr[<span class="hljs-number"><span class="hljs-number">1</span></span>]&gt; Word&lt;gram=<span class="hljs-string"><span class="hljs-string">"partcp,brev"</span></span>,gnc-agr[<span class="hljs-number"><span class="hljs-number">1</span></span>]&gt; interp (Repair.AdjGroup) {weight = <span class="hljs-number"><span class="hljs-number">0.5</span></span>}; Repair -&gt; Word&lt;kwtype=<span class="hljs-string"><span class="hljs-string">"adjNonExtracted"</span></span>,gnc-agr[<span class="hljs-number"><span class="hljs-number">1</span></span>]&gt; interp (Repair.AdjGroup) RepairW&lt;gnc-agr[<span class="hljs-number"><span class="hljs-number">1</span></span>]&gt; Prep* Adj&lt;gnc-agr[<span class="hljs-number"><span class="hljs-number">1</span></span>]&gt;+;</code> </pre><br>  Und das letzte der Probleme, die wir entdeckt haben, ist ein Dienst mit Multithread-Nutzung der Tomita-Bibliothek, der myStem-Prozesse erzeugt, die nicht zerstört werden und nach einiger Zeit den gesamten Speicher füllen.  Die einfachste Lösung bestand darin, die maximale und minimale Anzahl von Threads in Tomcat zu begrenzen. <br><br><h3>  Ein paar Worte zur Klassifizierung </h3><br>  Jetzt haben wir die Reparaturinformationen aus dem Text extrahiert.  Es war nicht schwierig, es mit einem der Gradientenverstärkungsalgorithmen zu klassifizieren.  Wir werden hier nicht lange auf dieses Thema verzichten, es wurde viel darüber gesagt und geschrieben, und wir haben in diesem Bereich nichts radikal Neues getan.  Ich werde nur die Qualitätsindikatoren der Klassifizierung angeben, die wir bei den Tests erhalten haben: <br><br><ul><li>  Genauigkeit = 95% </li><li>  F1-Punktzahl = 93% </li></ul><br><h3>  Fazit </h3><br>  Der implementierte Dienst, der Tomita-Parser im Bibliotheksmodus verwendet, arbeitet derzeit kontinuierlich und analysiert und klassifiziert mehrere Millionen Anzeigen pro Tag. <br><br><h3>  PS </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der gesamte Tomita-Code</a> , den wir im Rahmen dieses Projekts geschrieben haben, wird auf den Github hochgeladen.  Ich hoffe, dass dies für jemanden nützlich ist, und diese Person wird ein wenig Zeit für etwas noch Nützlicheres sparen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439614/">https://habr.com/ru/post/de439614/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439604/index.html">Wie ist der Barcode angeordnet?</a></li>
<li><a href="../de439606/index.html">Pilotproduktion von Elektronik zum Mindestpreis</a></li>
<li><a href="../de439608/index.html">Moderne Religion: Was geben Google, Facebook, Amazon und Apple den Menschen?</a></li>
<li><a href="../de439610/index.html">Wie bei meinem Elektrofahrzeug Chevrolet Bolt wurden im Rahmen der Garantie zwei Batteriemodule ausgetauscht und das dritte überwacht</a></li>
<li><a href="../de439612/index.html">Robustes JavaScript: Jagd nach einem Mythos</a></li>
<li><a href="../de439616/index.html">Die Zusammenfassung interessanter IT-Projekte auf Kickstarter Nr. 7</a></li>
<li><a href="../de439618/index.html">PHP für Anfänger. Dateiverbindung</a></li>
<li><a href="../de439620/index.html">Asynchronität in JavaScript verstehen [Übersetzung von Sukhjinder Arora]</a></li>
<li><a href="../de439624/index.html">Warum Daten im Orbit speichern?</a></li>
<li><a href="../de439626/index.html">Erleben Sie die Entwicklung einer kostenlosen Anwendung für OpenNumismat-Sammler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>