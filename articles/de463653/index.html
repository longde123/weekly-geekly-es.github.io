<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☘️ 🗓️ 👩🏻‍🚀 Einschränkungen von 16-Bit-Spielen und deren Wiederherstellung in Unity 📨 🧒🏿 🐕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In unserem ersten Retro-Game- Tutorial haben wir gezeigt, wie man das 2D Pixel Perfect-Tool anpasst und wie Grafiken im Zeitalter von 8-Bit-Spielen er...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einschränkungen von 16-Bit-Spielen und deren Wiederherstellung in Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463653/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ff/83e/cc7/7ff83ecc7638cc4231d30cbd03a253f5.png" alt="Bild"></div><br>  In unserem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten</a> Retro-Game- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tutorial</a> haben wir gezeigt, wie man das 2D Pixel Perfect-Tool anpasst und wie Grafiken im Zeitalter von 8-Bit-Spielen erstellt wurden.  In diesem Beitrag werden wir in die 16-Bit-Ära versetzt.  In Mega Cat Studios lernen wir, wie Sie mit Unity-Optionen, Grafikstrukturen und Farbpaletten authentische Grafiken für Spiele im Stil von Sega Genesis (Mega Drive) und Super NES erstellen. <br><br><h2>  Erstellen Sie authentische Grafiken im Genesis-Stil </h2><br>  In diesem Abschnitt werden wir den Workflow zum Erstellen von Grafiken betrachten, die das Bild verschiedener Konsolen nachahmen.  Es gibt weniger Einschränkungen als bei einem 8-Bit-Projekt und mehr Freiheit beim Arbeiten mit Farben, aber Genesis hat dennoch Grenzen.  Wir glauben, dass es auch nützlich sein wird, zu erklären, wie die Konsolenhardware funktioniert, damit Sie diese Einschränkungen in Ihrem eigenen Retro-Projekt anwenden können. <br><br><h2>  Paletten und Unterpaletten </h2><br>  Der Übergang von 8-Bit- zu 16-Bit-Konsolen aufgrund der Komplexität der Geräte bot Entwicklern mehr Möglichkeiten.  Die Grundsätze für die Erstellung hochwertiger NES-Grafiken gelten jedoch weiterhin.  Alle Grafiken werden weiterhin in Kacheln mit einer Größe von beispielsweise 8 × 8 gespeichert und daraus zu großen Bildern zusammengefasst - Sprites und Hintergrundelementen.  Künstler sind immer noch auf Unterpaletten mit einer gemeinsamen transparenten Farbe beschränkt, aber 16 Bit bieten mehr Flexibilität beim Arbeiten mit Paletten.  Sie werden höchstwahrscheinlich erfreut sein, dass die 16-Bit-Konsolen keine genau definierte Farbpalette hatten, dh die Anzahl der verfügbaren Farben hat sich im Vergleich zu NES stark erweitert. <br><a name="habracut"></a><br>  Darüber hinaus bietet Genesis Unterpaletten mit 15 Farben sowie der Gesamtfarbe für die Transparenz von Sprites und Ebenen.  Einer der Nachteile beim Erstellen von Grafiken für Genesis ist jedoch die Arbeit mit Unterpaletten.  Unterpaletten können Sprites oder Hintergrundkacheln frei zugewiesen werden. Mit Genesis können Sie jedoch nicht mehr als vier Unterpaletten gleichzeitig verwenden.  Daher müssen Künstler darüber nachdenken, welche Farben in der Unterpalette verwendet werden sollen, damit ihre Anzahl für Sprites und Hintergründe maximal ist.  Die Genesis-Unterpalette enthält normalerweise Farben, die sowohl für den Hintergrund als auch für Sprites verwendet werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b32/307/3a0/b323073a0263df666c196d02752ab3c4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/991/d48/3e7/991d483e76ca6dbca198c5c68c512c2e.png" width="729" height="151"></div><br>  <i>Die Szene aus dem Spiel für Genesis ist oben und die verwendeten Unterpaletten unten dargestellt.</i> <br><br>  Um Grafiken für jede 16-Bit-Plattform zu erstellen, müssen Sie mit einer indizierten Palette arbeiten.  Dazu können Sie den Gimp-Editor verwenden, eine kostenlose Alternative zu Photoshop, mit der Sie indizierte Paletten bearbeiten können. <br><br>  Um eine indizierte Palette in Gimp zu erstellen, gehen Sie zu <b>Bild&gt; Modus&gt; Indiziert</b> ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12c/4d2/f4f/12c4d2f4fcbe205b41af06268456d728.png"></div><br>  Das Fenster Indizierte Farbkonvertierung wird geöffnet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5eb/47d/78d/5eb47d78d29d7c9d1a8ff0d4b5e4e5a5.png"></div><br>  Stellen Sie für Maximale Anzahl von Farben den Wert auf <b>15 ein</b> .  Sie können automatische Dithering-Muster verwenden, diese sehen jedoch normalerweise besser aus, wenn Sie sie manuell erstellen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d5a/aae/a7b/d5aaaea7b7295e5cdb8119be1ee4a551.png"></div><br>  Bildfarben werden jetzt indiziert.  Diese Informationen werden automatisch mit dem Bild gespeichert, damit der Farbindex verwendet werden kann.  Wenn Sie die Reihenfolge der Farben im Index ändern müssen, klicken Sie einfach mit der rechten <b>Maustaste</b> auf die Farbkarte und wählen Sie <b>Farbkarte neu anordnen ...</b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dae/c84/530/daec845306aaf222db7ec36ab3e0043a.png"></div><br>  Es öffnet sich ein Fenster, in dem Sie Farben ziehen und ablegen und ihre Reihenfolge ändern können. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cdc/f0e/2c8/cdcf0e2c85543492765713f17934df03.png"></div><br>  Ein beliebter Trick zum Erhöhen der Farbtiefe besteht darin, die Palette in einer bestimmten Scanlinie zu steuern, ähnlich wie das Parallaxen-Scrollen auf NES implementiert ist.  Die Genesis-Konsole kann die Auswahl der Grafik-Unterpalette in der angegebenen Scanzeile ändern.  Dieser Trick wird oft verwendet, um die Illusion zu erzeugen, dass sich ein Teil des Levels unter Wasser befindet.  Unterwasserfarben werden einer separaten Unterpalette hinzugefügt, und diese Unterpalette wird geladen, wenn die angegebene Scanlinie auf dem Bildschirm gerendert wird. <br><br><h2>  Aufbewahrung in Kacheln und Laden in diese Konsole </h2><br>  Im Allgemeinen haben 16-Bit-Konsolen Grafikkacheln anders geladen als 8-Bit-Konsolen.  8-Bit-Konsolen luden Sprite- und Hintergrundkacheln mit großen Datenmengen, um Rechenleistung zu sparen, während die Ressourcen von 16-Bit-Konsolen für mehr Flexibilität sorgten.  Sie konnten separate Kacheln im laufenden Betrieb laden und ersetzen, wodurch es möglich war, nur die benötigten Grafiken zu laden.  Daher können Sie auf einem einzelnen Bildschirm oder einer einzelnen Ebene eine größere Auswahl an Grafiken verwenden. <br><br>  Ein weiterer einzigartiger Aspekt von Genesis / Mega Drive ist, dass die Grafik- und Palettendaten nicht die einzigen Daten sind, die während des Spiels in die VRAM-Konsole geladen werden.  Dies machte es schwierig, ein Grafikdesign für die Konsole zu erstellen, da die Anzahl der Grafikkacheln, die zu einem bestimmten Zeitpunkt in den Speicher geladen werden konnten, davon abhing, was sonst noch im Spiel geschah.  Im Allgemeinen hatten die meisten Spiele genug Platz, um etwa 1000 Kacheln zu laden, und mit dynamischen Elementen konnten Kacheln immer frei heruntergeladen und in den Speicher geladen werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62b/077/356/62b077356f85edd37119d66b9a0302bd.png" width="1600" height="501"></div><br>  <i>In der oben gezeigten Szene in den Speicher geladene Kacheln.</i>  <i>Ein großer leerer Raum in der Mitte und Artefakte darunter ist der Platz, der Feinden und anderen Elementen des Spiels im Speicher zugewiesen wird.</i> <br><br>  Trotz der Tatsache, dass in VRAM eine größere Vielfalt von Kacheln gleichzeitig geladen werden konnte, war dieser zusätzliche Platz meistens für Sprites reserviert.  Dies lieferte eine komplexere Animation und ermöglichte es, mehr Sprites gleichzeitig auf dem Bildschirm anzuzeigen.  Das heißt, die grundlegende Designphilosophie mit sich wiederholenden Kachelsegmenten wurde in 16-Bit-Grafiken immer noch aktiv verwendet, wodurch der Hintergrund nicht viel verfügbaren Platz beanspruchte.  Die Berechtigungen von NES, Genesis und SNES sind nahezu gleich, sodass 16 × 16 Segmente normalerweise der Ausgangspunkt für diese Arten von Designs waren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e7/6e4/ce5/1e76e4ce579739aaa92ba97773b9d9b2.png" width="1600" height="867"></div><br>  <i>Hier verwendete der Künstler ein 32 × 32-Blockmuster, um den Hauptteil des Bodens zu erstellen, der der Hintergrund ist.</i> <br><br><h2>  Arbeiten Sie mit Hintergrundebenen </h2><br>  Mit Genesis / Mega Drive können Sie zwei Hintergrundebenen gleichzeitig auf dem Bildschirm anzeigen.  Dies bedeutet, dass Überlagerungselemente für die Erstellung von Designhintergründen bequemer sind.  Trotzdem gibt es nur zwei Ebenen. Um der Szene mehr Tiefe zu verleihen, könnten der Künstler und der Entwickler Tricks mit Scanlinien anwenden.  Glücklicherweise konnten Designer, da all dies auf die zweite Ebene übertragen werden konnte, Vordergrundobjekte vor den Hintergrund stellen, ohne die Illusionen zu zerstören. <br><br>  Dank der zweiten Ebene mussten Entwickler außerdem keine Tricks mit Sprite-Prioritäten mehr anwenden.  Anstatt die Prioritäten von Sprites im laufenden Betrieb ständig zu ändern, war es jetzt möglich, eine zweite Ebene des vor dem Player angezeigten Hintergrunds festzulegen.  Für eine komplexere Überlagerung kann es jedoch immer noch erforderlich sein, die Sprite-Prioritäten schnell zu bearbeiten.  Die zweite Hintergrundebene hat auch einen Bereich, der für die Schnittstelle verwendet werden kann.  Dieser Bereich ist verriegelt und wird niemals gescrollt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d1/e8b/1ec/5d1e8b1ecf884a5b7df8825edec191e6.png" width="650" height="240"></div><br>  <i>Aufgrund der Ansicht von oben nach unten für den Baum mussten spezielle Kacheln erstellt werden, um die Reihenfolge der Sprite-Ebenen zu ändern.</i> <br><br><h2>  Sprite-Einschränkungen </h2><br>  Beim Umschalten auf 16 Bit erhöht sich die Freiheit beim Arbeiten mit Sprites erheblich.  Mit Genesis / Mega Drive können Sie bis zu 80 Sprites und bis zu 20 Sprites auf einer horizontalen Linie gleichzeitig auf dem Bildschirm anzeigen.  Alle nachfolgenden Sprites werden nicht gerendert.  Außerdem werden Sprites nicht mehr als separate 8 × 8-Kacheln betrachtet.  Genesis ist in der Lage, einzelne Sprites zu generieren, die aus mehreren Kacheln bestehen.  Sie können von einer Kachel bis zu 4x4 Kacheln reichen.  Größere Bilder müssen aus mehreren Sprites bestehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/80c/877/672/80c877672f97cbe26df1a7ba887d29c1.png" width="650" height="240"></div><br>  <i>Die Grafiken des Endgegners verwenden eine große Anzahl animierter Hintergrundelemente, Ebenen und viele Sprites.</i>  <i>All dies wäre auf einer 8-Bit-Plattform unmöglich.</i> <br><br><h2>  Dithering-Muster und Kontrast </h2><br>  Eines der charakteristischen Merkmale der Grafik der 16-Bit-Ära ist die Verwendung von Dithering.  In jenen Tagen wurden Spiele auf CRT-Fernsehern gespielt, bei denen Bildschirmpixel normalerweise miteinander verschmolzen.  Künstler nutzten diese Funktion, indem sie Dithering-Muster in ihre Grafiken einfügten: Wenn ein Pixel in einem sich wiederholenden Muster mit einem anderen verschmolz, entstand die Illusion von mehr Farben, als die Konsole zuließ.  Um die Ästhetik des Originals zu vermitteln, wird Dithering trotz besserer Darstellungen in der Pixelkunst immer noch aktiv eingesetzt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afd/2e2/f63/afd2e2f630cf7765c18f40d0c68b4950.png" width="623" height="240"></div><br>  <i>Dithering wurde häufig auf 16-Bit-Konsolen verwendet.</i>  <i>Auf einem CRT-Bildschirm wurde das Pixelmuster gemischt, wodurch neue Farben oder Transparenzeffekte erzeugt wurden, wo dies nicht möglich war.</i> <br><br>  Im Vergleich zu SNES zeigt Genesis / Mega Drive Farben mit höherem Kontrast an.  Dies muss auch bei der Auswahl von Unterpaletten berücksichtigt werden.  Wenn Sie ein Spiel mit gedämpften und stumpfen Farben erstellen, können sich die Paletten beim Rendern auf der Originalhardware unterscheiden.  Im Allgemeinen sollten Grafiken in einer kontrastreichen Farbpalette erstellt werden, damit das Endergebnis der ursprünglichen Vision des Künstlers entspricht. <br><br><h2>  Erstellen Sie authentische Grafiken im SNES-Stil </h2><br>  Super-NES-Spiele funktionierten immer noch mit 8 × 8-Pixel-Gittern / Kacheln. Daher ist es äußerst nützlich, sich wiederholende Kacheln zu verwenden.  Im Allgemeinen sollten ihre Größen ein Vielfaches von acht sein. <br><br><h2>  Farbpalette </h2><br>  Der erste grundlegende Unterschied zwischen Genesis / Mega Drive und SNES betrifft die Farbpalette.  Wie bei Mega Drive verfügt auch bei der SNES-Konsole keine Farbpalette in der Hardware, sodass Sie Ihre eigenen Farben auswählen können. <br><br>  Die Komplexität von SNES besteht darin, dass Farben mit einer Tiefe von 5 Bit pro Pixel (Bit pro Pixel, BPP) verwendet wurden, die heutzutage selten zu sehen sind.  Sie können sie mit Gimp implementieren und das Bild dann einfach in 32 RGB-Schattierungen posterisieren, was Farben mit 5 BPP entspricht.  Dadurch werden die Farben des Bildes auf der Konsole genau angezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f68/319/d19/f68319d19b2667682787c08eddb5a158.png"></div><br>  Diese Option in Gimp befindet sich im Menüpunkt <b>Farben&gt; Posterisieren ... Ein</b> Popup-Fenster wird angezeigt, in dem Sie die Posterize-Ebenen auf 32 einstellen können, um Farben zu erstellen, die mit 5 BPP kompatibel sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/96a/e0d/cc2/96ae0dcc2a2f31a300d9b6f5bac6354b.png"></div><br><h2>  Bildschirmauflösung </h2><br>  Ein weiterer wesentlicher Unterschied zwischen den beiden Systemen betrifft die Bildschirmauflösung.  Da SNES ein Nachkomme von NES war, hatten beide Konsolen ähnliche Bildschirmauflösungen.  Die interne Auflösung von SNES beträgt 256 × 224.  Sie können Bilder in sicheren Bereichen der meisten CRT-Fernseher rendern, ohne einen Teil des Bildes zu beschneiden.  Diese Auflösung ändert sich nie, daher entspricht sie der Größe des Bildes, und der Künstler sollte sie verwenden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/66d/e64/cc3/66de64cc31329db4bd07f2953cb7d75f.png" width="256" height="224"></div><br>  <i>Dieses Bild belegt die in den meisten Bildschirmmodi verwendete Vollbild-SNES-Auflösung.</i> <br><br><h2>  Konsolenbildschirmmodi </h2><br>  In diesem Abschnitt werden wir kurz auf die verschiedenen Bildschirmmodi eingehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/799/f1d/9ca/799f1d9caa299ff12bfe90efa8eca109.png"></div><br>  Der größte Unterschied zwischen den Konsolen besteht darin, dass SNES Hintergrundgrafiken in sieben verschiedenen Bildschirmmodi rendern kann.  In einigen Bildschirmmodi kann SNES gleichzeitig 256 Farben aus einer Unterpalette auf dem Bildschirm rendern.  Hier sind die beliebtesten Bildschirmmodi: <br><br><ul><li>  <b>Modus 1:</b> Einer der häufigsten Bildschirmmodi für SNES.  Dies ist der durchschnittlichste Modus, der die Funktionen der Konsole demonstriert.  In Modus 1 können Sie mit drei Hintergrundebenen arbeiten, von denen zwei über eigene 16-Farben-Unterpaletten verfügen. Die letzte Ebene verfügt über eine 4-Farben-Unterpalette. </li><li>  <b>Modus 3:</b> Dieser Modus wird häufig für große Standbilder wie Begrüßungsbildschirme oder Szenen verwendet.  Es hat zwei Hintergrundebenen.  Die erste verwendet eine vollständige 256-Farben-Unterpalette, die zweite eine 16-Farben-Unterpalette. </li><li>  <b>Modus 7:</b> Dies ist eine der Hauptfunktionen von SNES.  Dieser Modus wurde in den meisten Werbematerialien der Konsole angezeigt.  Dank Mode 7 konnten Heimkonsolen erstmals Bildtransformationen in Echtzeit durchführen: Skalieren, Drehen, Dehnen und Kippen in der Hintergrundebene.  Es wurde verwendet, um Pseudo-3D-Effekte zu erstellen, die in vielen Rennspielen und Flugsimulatoren für SNES zu sehen sind. </li></ul><br>  Um sicherzustellen, dass diese Funktionen funktionieren, wird die einzige Hintergrundebene in Modus 7 ganz anders verarbeitet als in anderen Bildschirmmodi.  Erstens gibt es nur eine 256-Farben-Farbebene, dh alle Sprites müssen Farben aus einer Unterpalette dieser Hintergrundebene haben.  Zweitens betrug die Hintergrundebene im Modus 7 anstelle der üblichen SNES-Bildschirmgröße 1024 × 1024 Pixel.  Es skaliert und passt sich an, wie es der Designer benötigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fe/e26/51a/3fee2651a4bbb628cbf6c79541e50780.png" width="520" height="224"></div><br>  Dieses Büro verwendet Modus 1 mit einer Unterpalette (die anderen beiden werden für die Benutzeroberfläche verwendet).  Der Bildschirm "Danke fürs Spielen" verwendet Modus 3, mit dem der Künstler eine 256-Farben-Palette anwenden kann. <br><br><h2>  Sprite-Größen </h2><br>  Im Vergleich zur Komplexität der Hintergrundbildschirmmodi sind die Regeln für das Arbeiten mit Sprites relativ einfach.  SNES hat mehrere verschiedene Sprite-Modi, fast wie Mega Drive, aber mit einer strengen Einschränkung: Die Konsole kann nur zwei verschiedene Sprite-Modi im Spiel verwenden <br><br>  Sprites können Größen von 8 × 8, 16 × 16, 32 × 32 oder 64 × 64 haben.  Aber das ist noch nicht alles - Designer mussten Kombinationen aus einer vorgefertigten Liste von Sprite-Größen auswählen.  Die folgenden Kombinationen können in SNES-Spielen verwendet werden: <br><br><ul><li>  8 × 8, 16 × 16 </li><li>  8 × 8, 32 × 32 </li><li>  8 × 8, 64 × 64 </li><li>  16 × 16, 32 × 32 </li><li>  16 × 16, 64 × 64 </li><li>  32 × 32, 64 × 64 </li></ul><br>  Diese Größen werden "ein für allemal" ausgewählt und alle Sprites im Spiel müssen mit ihnen übereinstimmen.  SNES kann 32 Sprites auf einer horizontalen Scanlinie und nicht mehr als 128 Sprites gleichzeitig auf dem Bildschirm rendern.  Alle anderen werden nicht gerendert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/deb/0f3/ef3/deb0f3ef3b38b654d808bbc41c03081d.png" width="650" height="640"></div><br>  <i>Fork Parkers Crunch-Out verwendet eine Kombination aus 32 × 32 und 16 × 16 für alle Sprites im Spiel.</i> <br><br>  Sprites können mit acht 16-Farben-Unterpaletten arbeiten.  Wie bei allen Retro-Konsolen ist die erste Farbe einer Unterpalette die Gesamtfarbe, die für die Transparenz verwendet wird.  Eine große Anzahl von Unterpaletten im Vergleich zu anderen Konsolen gibt uns mehr Freiheit bei der Auswahl der Farben für Sprites.  Sie müssen sich nur daran erinnern, dass es eine strenge Grenze von 256 Farben gibt. <br><br><h2>  Verwenden von 2D Pixel Perfect zum Erstellen von Retro-Spielen </h2><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Retro-Tutorial haben</a> wir die 2D Pixel Perfect-Optionen behandelt und 8-Bit-Grafiken neu erstellt. <br><br>  Ab Unity 2019.2 ist das 2D Pixel Perfect-Paket Teil des 2D Renderer, der wiederum Teil des Lightweight Render Pipeline (LWRP) -Pakets ist.  Wenn Sie kein LWRP verwenden, kann 2D Pixel Perfect auch als separates Paket verwendet werden.  In diesem Tutorial zeigen wir, wie Sie ein Projekt in LWRP einrichten. <br><br><h2>  Vorbereiten eines neuen Projekts in Unity 2019.2 und LWRP </h2><br><ol><li>  Starten Sie den Unity Hub, klicken Sie auf Neu, wählen Sie <b>2D aus</b> und geben Sie den Namen Ihres Projekts an. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7b/375/300/f7b375300754b91d5a8fc5a1d045bb95.png"></div></li><li>  Um ein 2D Pixel Perfect-Paket zu importieren, klicken Sie in der Symbolleiste auf das Menü Fenster und wählen Sie Paketmanager.  Wählen Sie im angezeigten Fenster das <b>Lightweight RP-</b> Paket aus und stellen Sie sicher, dass die Version 6.9.0 oder höher ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e90/8d6/e82/e908d6e824bfd3510efd8fd98c8f21ef.png"></div></li><li>  Anschließend müssen Sie den 2D-Renderer im Editor konfigurieren und ein neues Pipeline-Asset erstellen.  Klicken Sie im Projektfenster mit der rechten Maustaste auf das Fenster Assets und wählen Sie <b>Erstellen&gt; Rendern&gt; Lightweight Render Pipeline&gt; Pipeline Asset</b> . </li><li>  Erstellen Sie im Fenster "Assets" des Projektfensters einen neuen 2D-Renderer, indem Sie mit der rechten Maustaste klicken und " <b>Erstellen"&gt; "Rendern"&gt; "Leichte Render-Pipeline"&gt; "2D-Renderer"</b> wählen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/433/a37/fbb/433a37fbb86e42240f9f90322a84818b.png"></div></li><li>  Wählen Sie das erstellte Pipeline-Asset aus.  Wählen Sie <b>Allgemein</b> und wechseln Sie dann den Renderertyp von <b>Forward Renderer</b> zu <b>Custom</b> . </li><li>  Weisen Sie den generierten 2D-Renderer als Wert des Datenfelds zu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1aa/a61/a0a/1aaa61a0af6b9041e9f301d842017c6d.png"></div></li><li>  Ändern Sie in den Grafikoptionen die Einstellungen für die Skript-Render-Pipeline, um das neue Pipeline-Asset zu verwenden, das Sie erstellt haben. <br><br>  Damit ist die Einrichtung von 2D Renderer sowie 2D Pixel Perfect Camera abgeschlossen. </li></ol><br>  In Unity 2019.2 können zweidimensionale Sprites Sprite-Lit-Material enthalten, mit dem sie auf 2D-Lichtverhältnisse reagieren können.  Wenn Ihr Projekt keine 2D-Beleuchtung hat, verwenden Sie Material, für das keine 2D-Beleuchtung erforderlich ist, damit die Sprites sichtbar sind, dh "Sprites-Standard". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/67d/5e3/9d8/67d5e39d877a368fcc6ba635a5be7b22.png"></div><br><h2>  Pixel Perfekte Tinktur für 16-Bit-Grafikstile </h2><br>  Sie müssen die Komponente Pixel Perfect Camera zur Hauptkamera hinzufügen.  Wir empfehlen, dass Sie das Kontrollkästchen Im Bearbeitungsmodus ausführen aktivieren. <br><br>  Die <b>Sega Genesis-</b> Konsole hatte eine Auflösung von 320 × 224 Pixel (oder ein Raster von 40 × 28 Kacheln mit einer Größe von 8 × 8 Pixel).  Dies gilt für die NTSC-Version. <br><br>  Die <b>Super NES-</b> Konsole hatte auch in der NTSC-Version eine Auflösung von 256 × 224 (30 × 28 Kacheln mit einer Größe von 8 × 8 Pixel). <br><br>  Um beide Grafikstile zu erstellen, empfehlen wir die Verwendung einer Höhenauflösung von 224 Pixel und 8 PPU. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ff/83e/cc7/7ff83ecc7638cc4231d30cbd03a253f5.png" width="1194" height="950"></div><br>  Mit dem Hilfesprite (oben zeigt ein 320 × 224-Vollbild von Sonic the Hedgehog für Sega Genesis) können Sie verstehen, wie ein Sprite mit 8 Pixeln pro Einheit (Pixel pro Einheit, PPU) mit derselben Auflösung und PPU im Szenenfenster platziert wird. <br><br>  Wenn Sie sich daran erinnern möchten, was die einzelnen Optionen in der 2D Pixel Perfect Camera-Komponente bewirken, lesen Sie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherige Tutorial zum Retro-Spiel</a> . <br><br><h2>  Weiterentwicklung </h2><br>  Ich hoffe, Ihnen hat diese Reihe von Beiträgen zum Erstellen von 8- und 16-Bit-Retro-Spielen mit 2D Pixel Perfect in der neuesten Version von Unity gefallen. <br><br>  Wir haben 2D Pixel Perfect noch nicht fertiggestellt, da dieses Paket in Unity 2019.3 für die Produktion bereit sein wird und außerdem mehr Kompatibilität mit Cinemachine 2D bietet. <br><br>  Halten Sie uns mit 2D Pixel Perfect über Ihre Projekte auf dem Laufenden und vergessen Sie nicht, das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">2D-Forum</a> zu besuchen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">,</a> um mit Unity-Benutzern und Entwicklern von 2D-Funktionen zu sprechen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463653/">https://habr.com/ru/post/de463653/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463637/index.html">Testen Sie Ihre Infrastruktur als Code mit Pulumi. Teil 2</a></li>
<li><a href="../de463639/index.html">Nun, Apple BLEee</a></li>
<li><a href="../de463647/index.html">Videos und Berichte mit SmartMail Meetup: Frontend</a></li>
<li><a href="../de463649/index.html">Analytischer Hinweis. Überprüfung der Anordnung des Energieministeriums der Russischen Föderation vom 6. November 2018 N 1015</a></li>
<li><a href="../de463651/index.html">Diskrete Mathematik für WMS: Algorithmus zum Komprimieren von Waren in Zellen (Teil 2)</a></li>
<li><a href="../de463655/index.html">Die Geburt eines Projekts oder wie man ein eigenes CMS schreibt</a></li>
<li><a href="../de463657/index.html">Chatbots sind scheiße</a></li>
<li><a href="../de463663/index.html">10 Bücher, um die Struktur der Börse, Investitionen an der Börse und automatisierten Handel zu verstehen</a></li>
<li><a href="../de463665/index.html">1,1 Milliarden Taxifahrten: 108-Kern-ClickHouse-Cluster</a></li>
<li><a href="../de463667/index.html">Forest gibt sich nicht der Suchtechnologie hin, aber Ingenieure schlagen zurück</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>