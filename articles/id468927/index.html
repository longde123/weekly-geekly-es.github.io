<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🏫 🧕🏻 🧝 Quintet, bukan Byte - penyimpanan data dan pendekatan pengambilan 😶 🛸 💔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quintet adalah cara untuk menyajikan potongan atom data yang menunjukkan peran mereka dalam bidang bisnis. Kuintet dapat menggambarkan item apa saja, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Quintet, bukan Byte - penyimpanan data dan pendekatan pengambilan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468927/">  Quintet adalah cara untuk menyajikan potongan atom data yang menunjukkan peran mereka dalam bidang bisnis.  Kuintet dapat menggambarkan item apa saja, sementara masing-masing berisi informasi lengkap tentang dirinya dan hubungannya dengan kuintet lain.  Deskripsi seperti itu tidak tergantung pada platform yang digunakan.  Tujuannya adalah untuk menyederhanakan penyimpanan data dan untuk meningkatkan visibilitas presentasi mereka. <br><br><img src="https://habrastorage.org/webt/em/rc/sj/emrcsj86rsey9wacgmk-uj4i9og.gif"><br><br>  <b>Kami akan membahas pendekatan untuk menyimpan dan memproses informasi dan berbagi pemikiran untuk membuat platform pengembangan dalam paradigma baru ini.</b>  <b>Untuk apa</b>  <b>Untuk mengembangkan lebih cepat dan dalam iterasi yang lebih pendek: buat sketsa proyek Anda, pastikan itu yang Anda pikirkan, perbaiki, dan terus perbaiki hasilnya.</b> <br><br>  Kuintet memiliki properti: tipe, nilai, induk, dan urutan di antara rekan-rekan.  Dengan demikian, ada 5 komponen termasuk pengidentifikasi.  Ini adalah bentuk universal paling sederhana untuk mencatat informasi, standar baru yang berpotensi sesuai dengan tuntutan pemrograman.  Kuintet disimpan dalam sistem file dari struktur terpadu, dalam sejumlah besar data yang diindeks secara homogen kontinu.  Model data kuintet - model data yang menggambarkan struktur data apa pun sebagai daftar tunggal tipe dan istilah dasar yang saling berhubungan berdasarkan mereka (metadata), serta instance objek yang disimpan menurut metadata (data) ini. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Lirik setengah menit</b> <div class="spoiler_text">  Saat ini ada sejumlah standar untuk merekam data, berbagai pendekatan dan aturan, pengetahuan yang diperlukan untuk bekerja dengan catatan-catatan ini.  Standar dijelaskan secara terpisah dan tidak secara langsung berhubungan dengan data yang sesuai.  Dalam kasus kuintet, dengan mengambil salah satu dari itu, Anda dapat memperoleh informasi yang relevan tentang sifat, sifat, dan aturan pemrosesan di area bisnis pengguna.  Standarnya disatukan dan diperbaiki untuk semua area.  Kuintet disembunyikan dari pengguna - metadata dan data tersedia untuk yang terakhir dengan cara yang umum dipahami. <br><br>  Quintet bukan hanya informasi, tetapi juga dapat mewakili kode yang dapat dieksekusi.  Namun yang terpenting, itu adalah data yang ingin Anda rekam, simpan, dan ambil.  Karena dalam kuintet kasus kami langsung dialamatkan, saling berhubungan dan diindeks, kami akan menyimpannya dalam semacam basis data. </div></div><br><a name="why"></a><br><h3>  Kenapa Quintet bukannya Byte? </h3><br>  <b>Bukan bit atau impuls elektronik yang mengorientasikan putaran magnet.</b> <br><br>  Kami terbiasa mengukur data dalam byte, apakah itu ukuran dokumen atau foto, batas lalu lintas internet, atau ruang yang tersedia di perangkat seluler Anda.  Kami mengusulkan ukuran lain - Quintet - yang tidak memiliki ukuran tetap seperti Byte, tetapi mewakili jumlah atom data, yang bernilai bagi pengguna. <br><br>  Misalnya, Anda dapat mengatakan bahwa basis data Anda menempati 119 megabyte penyimpanan atau Anda dapat menyatakan bahwa basis data ini menyimpan 1,37 mega-kuintet.  Anda tidak terlalu peduli apa byte dalam konteks ini, tetapi Anda memahami bahwa basis data ini berisi 1,37 juta deskripsi istilah, objek, atribut, tautan, peristiwa, kueri dengan detailnya, dll.  Untuk memiliki 1,37 juta keping data berharga terdengar lebih seksi daripada memiliki 119 megabita barang pada Anda. <br><br>  Dengan demikian, ini bukan untuk menggantikan cara informasi disimpan pada media data, tetapi untuk beralih ke tingkat abstraksi lain. <br><a name="structure"></a><br><h3>  Struktur kuintet </h3><br>  Ide utama artikel ini adalah mengganti tipe mesin dengan istilah manusia dan mengganti variabel dengan objek.  Bukan oleh objek yang memerlukan konstruktor, destruktor, antarmuka, dan pengumpul sampah, tetapi oleh unit informasi sejernih kristal yang ditangani pelanggan.  Artinya, jika pelanggan mengatakan "Klien", maka untuk menyimpan esensi pernyataan ini pada medium tidak akan membutuhkan keahlian seorang programmer. <br><br><img src="https://habrastorage.org/webt/e-/ox/u9/e-oxu90oaiouj4zals6mgtnj7zy.png"><br><br>  Masuk akal untuk memusatkan perhatian pengguna hanya pada nilai objek, sedangkan jenisnya, induknya, urutan (di antara yang sederajat dalam subordinasi) dan pengidentifikasi harus jelas dari konteks atau hanya disembunyikan.  Ini berarti bahwa pengguna sama sekali tidak tahu tentang kuintet, ia hanya memberikan tugas, memastikan bahwa itu diterima dengan benar, dan kemudian memulai pelaksanaannya. <br><a name="concept"></a><br><h3>  Konsep dasar </h3><br>  Ada serangkaian tipe data yang dipahami semua orang: string, angka, file, teks, tanggal, dan sebagainya.  Set sederhana seperti itu cukup untuk membuat sketsa solusi, dan "memprogram" bersama dengan persyaratan yang diperlukan untuk implementasinya.  Tipe dasar yang diwakili oleh kuintet mungkin terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/ca/zb/7l/cazb7lfkvuldo5anzgnzibqu3oc.png"><br><br>  Dalam hal ini, beberapa komponen kuintet tidak digunakan, sedangkan kuintet itu sendiri digunakan sebagai tipe dasar.  Ini membuat sistem kernel lebih mudah dinavigasi saat mengumpulkan metadata. <br><a name="background"></a><br><h3>  Latar belakang </h3><br>  Karena kesenjangan analitik antara pengguna dan pemrogram, deformasi konsep yang signifikan terjadi pada tahap menguraikan proyek.  Pernyataan yang meremehkan, tidak dapat dipahami, dan inisiatif yang tidak diminta seringkali mengubah ide pelanggan yang sederhana dan masuk akal menjadi kekacauan yang mustahil secara logis, jika dievaluasi dari sudut pandang pengguna. <br><br><img src="https://habrastorage.org/webt/7p/jb/uz/7pjbuzxfddlosktjv3bs-om0v-8.png"><br><br>  Transfer pengetahuan harus terjadi tanpa kehilangan dan distorsi.  Selanjutnya, mengatur penyimpanan pengetahuan ini, Anda sebaiknya menyingkirkan pembatasan yang diberlakukan oleh sistem manajemen data yang dipilih. <br><a name="how"></a><br><h3>  Bagaimana kami menyimpan data sekarang </h3><br>  Biasanya, ada banyak database di server;  masing-masing berisi deskripsi skema data dengan sekumpulan detail spesifik - data yang saling berhubungan secara logis.  Mereka disimpan pada media data dalam urutan tertentu, idealnya - optimal untuk mengurangi upaya pengambilan. <br>  Sistem penyimpanan informasi yang diusulkan adalah kompromi antara berbagai metode terkenal: berorientasi kolom, relasional dan NoSQL.  Ini dirancang untuk menyelesaikan tugas-tugas yang biasanya dilakukan oleh salah satu pendekatan ini. <br><br>  Sebagai contoh, teori DBMS berorientasi kolom terlihat indah: kita hanya membaca kolom yang diinginkan, tetapi tidak semua baris catatan secara keseluruhan.  Namun, dalam praktiknya, tidak mungkin bahwa data akan ditempatkan di media sehingga nyaman untuk mengambil puluhan dimensi analitik yang berbeda.  Perhatikan bahwa atribut dan metrik analitik dapat ditambahkan dan dihapus, terkadang lebih cepat daripada kita dapat membangun kembali penyimpanan kolom kami.  Belum lagi bahwa data dalam database dapat diubah, yang juga akan melanggar keindahan skema penyimpanan karena fragmentasi yang tak terhindarkan. <br><a name="metadata"></a><br><h3>  Metadata </h3><br>  Kami memperkenalkan konsep - istilah - untuk menggambarkan objek yang kami operasikan: entitas, properti, permintaan, file, dll.  Kami akan mendefinisikan semua istilah yang kami gunakan di area bisnis kami.  Dan dengan bantuan mereka, kami akan menggambarkan semua entitas yang memiliki perincian, termasuk bentuk hubungan antar entitas.  Misalnya, atribut - tautan ke entri kamus status.  Istilah ini ditulis sebagai kuintet data. <br><br>  Seperangkat uraian istilah adalah metadata yang sama dengan yang diwakili oleh struktur tabel dan bidang dalam basis data biasa.  Misalnya, ada struktur data berikut: permintaan layanan pada tanggal tertentu yang memiliki konten (deskripsi permintaan) dan status, di mana peserta proses produksi menambahkan komentar yang menunjukkan tanggal.  Dalam konstruktor database tradisional akan terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/wj/ux/e5/wjuxe5yakm3i0e8-b8qatbsuvv0.png"><br><br>  Karena kami memutuskan untuk menyembunyikan dari pengguna semua detail yang tidak penting, seperti ID yang mengikat, misalnya, skema akan agak disederhanakan: menyebutkan ID dihapus dan nama entitas dan nilai kuncinya digabungkan. <br><br>  Pengguna "menggambar" tugas: permintaan dari tanggal hari ini yang memiliki status (nilai referensi) dan Anda dapat menambahkan komentar yang menunjukkan tanggal: <br><br><img src="https://habrastorage.org/webt/i7/-e/s0/i7-es0bgiqlj2mjrgaijlsj_nrg.png"><br><br>  Sekarang kita melihat 6 bidang data yang berbeda, bukan 9, dan keseluruhan skema menawarkan kita untuk membaca dan memahami 7 kata, bukannya 13. Meskipun ini bukan hal utama, tentu saja. <br><br>  Berikut ini adalah kuintet yang dihasilkan oleh kernel pemrosesan-kuintet untuk menggambarkan struktur ini: <br><br><img src="https://habrastorage.org/webt/os/55/ms/os55msg7_8xpt2jkcqpnc1xhnls.png"><br><br>  Penjelasan menggantikan nilai kuintet yang disorot dalam warna abu-abu disediakan untuk kejelasan.  Bidang-bidang ini tidak diisi, karena semua informasi yang diperlukan ditentukan secara jelas oleh komponen yang tersisa. <br><br><div class="spoiler">  <b class="spoiler_title">Lihat bagaimana kuintet terkait</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/he/sh/xu/heshxuxlzau8yljqiznxu2ckd-8.png"><br><br>  Apa yang kita miliki di sini: <br><br><ul><li>  atribut dengan ID 80, 81, 83 memiliki induk yang sama - Permintaan </li><li>  kuintet # 82 adalah atribut dari Comment, yang pada gilirannya adalah atribut dari Request </li><li>  atribut # 74 adalah referensi ke jenis yang dijelaskan oleh kuintet # 73 dan digunakan sebagai atribut # 81 dari Permintaan </li></ul></div></div><br>  Ini mungkin terlihat sedikit rumit bagi manusia, tetapi kabar baiknya adalah - manusia tidak akan pernah melihat ini.  Kernel akan merepresentasikan metadata sebagai diagram yang dapat dipahami dan data sebagai tabel datar sederhana. <br><a name="userdata"></a><br><h3>  Data pengguna </h3><br>  Biarkan saya menunjukkan bagaimana kami menyimpan kumpulan data untuk tugas di atas: <br><br><img src="https://habrastorage.org/webt/7r/fo/6g/7rfo6gvbnxz2wahg9vq-8x8wdty.png"><br><br>  Data itu sendiri disimpan dalam kuintet sesuai dengan metadata.  Kita dapat memvisualisasikannya seperti yang kita lakukan di atas: <br><br><img src="https://habrastorage.org/webt/lc/p4/15/lcp415pjpig8etl3lykjfi2lqca.png"><br><br>  Kita melihat struktur hierarkis yang akrab ditulis menggunakan sesuatu seperti metode Adjacency List. <br><a name="storage"></a><br><h3>  Penyimpanan fisik </h3><br>  Data ditulis ke memori sebagai urutan item kwintet dalam byte data.  Untuk mencari berdasarkan indeks, kernel memperlakukan byte-byte data tersebut sesuai dengan tipe data yang ditentukan oleh tipe-tipe dasar. <br>  Itu dia: daftar besar lima item data. <br><br>  Prinsip-prinsip penyimpanan tidak jauh berbeda dari yang sama di RDBMS, yang memungkinkan kita membangun kueri SQL ke data untuk membuat pengambilan data, BERGABUNG, fungsi agregat dan hal-hal lain yang kita sukai dalam database relasional. <br><blockquote>  <b>Untuk menguji prototipe platform pengembangan berdasarkan sistem penyimpanan kuintet, kami menggunakan basis data relasional.</b> </blockquote><br><a name="performance"></a><h3>  Performa </h3><br>  Contoh di atas sangat sederhana, tetapi apa yang akan terjadi ketika strukturnya seribu kali lebih kompleks dan ada gigabytes data? <br><br>  Apa yang kita butuhkan: <br><br><ol><li>  Struktur hierarkis yang dibahas - 1 pc. </li><li>  B-tree untuk pencarian berdasarkan ID, induk dan tipe - 3 pcs. </li></ol><br>  Dengan demikian, semua catatan dalam basis data kami akan diindeks, termasuk data dan metadata.  Pengindeksan seperti itu diperlukan untuk mendapatkan manfaat dari database relasional - alat paling sederhana dan paling populer.  Indeks induk sebenarnya komposit (ID induk + tipe).  Indeks berdasarkan tipe juga komposit (tipe + nilai) untuk pencarian cepat objek dari tipe tertentu. <br><br>  Metadata memungkinkan kita untuk menyingkirkan rekursi: misalnya, untuk menemukan semua detail objek yang diberikan, kita menggunakan indeks dengan ID induk.  Jika Anda perlu mencari objek dari tipe tertentu, maka kami menggunakan indeks dengan tipe ID.  Jenis adalah analog dari nama tabel dan bidang dalam DBMS relasional. <br><br><img src="https://habrastorage.org/webt/w0/3y/6_/w03y6_fst_enfkaxmihelbnxjcc.png"><br><br>  Dalam kasus apa pun, kami tidak memindai seluruh kumpulan data, dan bahkan dengan sejumlah besar nilai jenis apa pun, nilai yang diinginkan dapat ditemukan dalam sejumlah kecil langkah. <br><a name="basis"></a><br><h3>  Dasar untuk platform pengembangan </h3><br>  Dalam dirinya sendiri, basis data semacam itu tidak mencukupi untuk pemrograman aplikasi, dan tidak lengkap, seperti yang mereka katakan, menurut Turing.  Namun, kita berbicara di sini tidak hanya tentang database, tetapi mencoba untuk mencakup semua aspek: objek, antara lain, algoritma kontrol sewenang-wenang yang dapat diluncurkan, dan mereka akan bekerja. <br><br>  Akibatnya, alih-alih struktur basis data yang kompleks dan kode sumber algoritma kontrol yang disimpan secara terpisah, kami mendapatkan bidang informasi yang seragam, dibatasi oleh volume ruang penyimpanan dan diatur dengan metadata.  Data itu sendiri disajikan kepada pengguna dalam bentuk yang dapat dimengerti baginya - struktur area subjek dan entri yang sesuai di dalamnya.  Pengguna secara sewenang-wenang mengubah struktur dan data, termasuk membuat operasi massal dengannya. <br><br><h4>  Kami tidak menemukan sesuatu yang baru: semua data sudah disimpan dalam sistem file dan pencarian di dalamnya dilakukan dengan menggunakan B-tree, baik dalam sistem file, atau dalam database.  Kami hanya mengatur ulang penyajian data sehingga lebih mudah dan jelas untuk dikerjakan. </h4><br><br>  Untuk bekerja dengan representasi data ini, Anda akan memerlukan perangkat lunak kernel yang sangat kompak - mesin basis data kami berukuran lebih kecil dari BIOS komputer, dan, oleh karena itu, dapat dibuat jika tidak ada dalam perangkat keras, maka setidaknya secepat dan bug- sebebas mungkin.  Untuk alasan keamanan, itu juga bisa menjadi hanya-baca. <br><br>  Menambahkan kelas baru ke rakitan di .Net favorit saya, kita dapat mengamati hilangnya 200-300 MB RAM hanya pada definisi kelas ini.  Megabita ini tidak akan masuk ke cache dari tingkat yang tepat, menyebabkan sistem untuk swap pada disk dengan semua overhead yang diakibatkannya.  Situasi serupa terjadi pada Java.  Deskripsi kelas yang sama dengan kuintet akan memakan waktu puluhan atau ratusan byte, karena kelas hanya menggunakan operasi primitif untuk bekerja dengan data yang sudah diketahui kernel. <br><br><blockquote><h4>  Anda mungkin berpikir bahwa pendekatan ini sudah diterapkan berkali-kali di berbagai aplikasi, tetapi itu tidak benar. </h4><br>  Kami melakukan pencarian mendalam di pangkalan internet dan kekayaan intelektual (paten), dan tidak ada yang mengklaim untuk melakukan solusi yang persis sama untuk menembus batas kinerja konstruktor, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">solusi satu-tabel</a> , dan sistem berbasis EAV lainnya.  Namun demikian, kami menempatkan ratusan gigabytes dalam aplikasi kuintet tersebut dan ternyata berfungsi dengan baik.  Jika Anda ingin melihat bukti, buat dan uji contoh Anda sendiri, silakan kunjungi akun github kami. </blockquote><br>  Prototipe platform yang kami bangun memiliki empat komponen: <br><br><ol><li>  <b>Editor Tipe</b> Visual untuk mendefinisikan metadata </li><li>  <b>Alat navigasi data</b> seperti navigator SQL sederhana </li><li>  <b>Desainer Laporan</b> Visual untuk membangun kueri SQL ke data </li><li>  <b>Prosesor Templat</b> untuk menggabungkan templat dengan data yang diambil oleh kueri </li></ol><br><img src="https://habrastorage.org/webt/bc/lu/rq/bclurqpevkemespz7aofusqipps.png"><br><br>  Seperti yang dimaksudkan, bekerja dengan prototipe tidak ada pengguna akan berpikir ada kuintet di dalamnya - ini terlihat seperti konstruktor biasa. <br><br><div class="spoiler">  <b class="spoiler_title">Cara menangani berbagai format: RDBMS, NoSQL, basis kolom</b> <div class="spoiler_text">  Pendekatan yang dibahas mencakup dua bidang utama: RDBMS dan NoSQL.  Saat memecahkan masalah yang memanfaatkan basis data kolom, kita perlu memberi tahu kernel bahwa benda-benda tertentu harus disimpan, dengan mempertimbangkan pengoptimalan pengambilan sampel massal dari nilai-nilai tipe data tertentu (istilah kita).  Oleh karena itu, kernel akan dapat menempatkan data pada disk dengan cara yang paling menguntungkan. <br><br>  Jadi, untuk DB berbentuk kolom, kita dapat secara signifikan menghemat ruang yang ditempati oleh kuintet: gunakan hanya satu atau dua komponennya untuk menyimpan data yang bermanfaat, bukan lima, dan juga gunakan indeks hanya untuk menunjukkan awal rantai data.  Dalam banyak kasus, hanya indeks yang akan digunakan untuk pengambilan sampel dari analog kami dari basis kolom, tanpa perlu mengakses data daftar kuintet itu sendiri. <br><br>  Perlu dicatat bahwa ide ini tidak dimaksudkan untuk mengumpulkan semua perkembangan maju dari ketiga jenis database ini.  Sebaliknya, mesin sistem baru akan dikurangi sebanyak mungkin, hanya mewujudkan fungsi minimum yang diperlukan - segala sesuatu yang mencakup permintaan DDL dan DML dalam konsep yang dijelaskan di sini. <br></div></div><br><a name="paradigm"></a><br><h3>  Paradigma pemrograman </h3><br>  Pendekatan yang dideskripsikan tidak terbatas hanya pada penggunaan kuintet, tetapi mempromosikan paradigma yang berbeda dari yang digunakan oleh para programmer.  Alih-alih bahasa imperatif, deklaratif, atau objek, kami mengusulkan bahasa kueri sebagai lebih akrab bagi manusia dan memungkinkan kami untuk mengatur tugas langsung ke komputer, melewati programmer dan lapisan yang tidak bisa ditembus dari lingkungan pengembangan yang ada. <br><br>  <b>Tentu saja, penerjemah dari bahasa pengguna awam ke bahasa dengan persyaratan yang jelas masih diperlukan dalam kebanyakan kasus.</b> <br><br>  Topik ini akan dijelaskan lebih rinci dalam artikel terpisah dengan contoh dan perkembangan yang ada. <br><br>  Jadi, singkatnya, ini berfungsi sebagai berikut: <br><br><ol><li>  Kami pernah menggambarkan tipe data primitif menggunakan kuintet: string, angka, file, teks dan lainnya, dan juga melatih kernel untuk bekerja dengannya.  Pelatihan berarti penyajian data yang benar dan pelaksanaan operasi sederhana dengan mereka. </li><li>  Sekarang kami menggambarkan istilah pengguna (tipe data) - dalam bentuk metadata.  Deskripsi hanya menentukan tipe data primitif untuk setiap tipe pengguna dan menentukan hubungan. </li><li>  Kami memasukkan kuintet data sesuai dengan struktur yang ditentukan oleh metadata.  Setiap kwintet data berisi tautan ke jenis dan induknya, yang memungkinkan Anda menemukannya dengan cepat di penyimpanan data. </li><li>  Tugas-tugas kernel turun untuk mengambil data dan melakukan operasi sederhana dengan mereka untuk mengimplementasikan algoritma rumit yang ditentukan oleh pengguna. </li><li>  Pengguna mengelola <i>data</i> dan <i>algoritma</i> menggunakan antarmuka visual yang menyajikan keduanya. </li></ol><br><br>  Kelengkapan Turing seluruh sistem dipastikan dengan perwujudan persyaratan dasar: kernel dapat melakukan operasi berurutan, secara kondisional cabang, memproses data dan menghentikan pekerjaan ketika hasil tertentu tercapai. <br><br>  Bagi seseorang, manfaatnya adalah kesederhanaan persepsi, misalnya, daripada mendeklarasikan siklus yang melibatkan variabel <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;length (A); i ++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> A [i] meets a condition <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> something with A [i]</code> </pre> <br><br>  bentuk yang lebih dimengerti digunakan, seperti <br><br><pre> <code class="1c hljs">with every A, that match a condition, do something</code> </pre> <br><br>  Kami bermimpi mengabstraksi dari seluk-beluk sistem informasi tingkat rendah: loop, konstruktor, fungsi, manifes, perpustakaan - semua ini memakan terlalu banyak ruang di otak seorang programmer, menyisakan sedikit ruang untuk kerja kreatif dan pengembangan. <br><a name="scalability"></a><br><h3>  Skalabilitas </h3><br>  Suatu aplikasi sering kali tidak berguna tanpa alat penskalaan: diperlukan kemampuan yang tidak terbatas untuk memperluas kapasitas pemuatan sistem informasi.  Dalam pendekatan yang dijelaskan, dengan mempertimbangkan kesederhanaan ekstrim dari organisasi data, penskalaan ternyata tidak lebih rumit dari pada arsitektur yang ada. <br><br>  Dalam contoh di atas dengan permintaan layanan, Anda dapat memisahkan mereka, misalnya, dengan ID mereka, membuat pembuatan ID dengan byte TINGGI tetap untuk server yang berbeda.  Artinya, ketika menggunakan 32 bit untuk menyimpan ID, kiri dua-tiga-empat bit atau lebih, sesuai kebutuhan, akan menunjukkan server tempat penyimpanan aplikasi ini.  Dengan demikian, setiap server akan memiliki kumpulan ID sendiri. <br><br>  Kernel dari satu server dapat berfungsi secara independen dari server lain, tanpa mengetahui apa-apa tentang mereka.  Saat membuat objek, itu akan diberikan prioritas tinggi ke server dengan jumlah ID minimum yang digunakan, untuk memastikan distribusi beban yang merata. <br><br>  Dengan serangkaian kemungkinan variasi permintaan dan respons yang terbatas dalam organisasi data tersebut, Anda akan memerlukan operator yang cukup kompak yang mendistribusikan permintaan di seluruh server dan mengumpulkan hasilnya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468927/">https://habr.com/ru/post/id468927/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468909/index.html">Berkat otentikasi dua faktor, saya kehilangan semua uang saya dan 3 tahun bekerja</a></li>
<li><a href="../id468911/index.html">Tanya Jawab Quantum Excellence Luar Biasa</a></li>
<li><a href="../id468913/index.html">Tombol Dash Amazon: Retrospektif</a></li>
<li><a href="../id468915/index.html">Bagaimana cara Cisco memantau keamanan informasi perusahaan yang diserap dan memberikan akses mereka ke sumber daya mereka?</a></li>
<li><a href="../id468923/index.html">Aku akan menghubungimu kembali</a></li>
<li><a href="../id468929/index.html">Mini-manual cara mengatur hackintosh sesederhana dan sesakit mungkin</a></li>
<li><a href="../id468931/index.html">Jalankan systemd dalam wadah</a></li>
<li><a href="../id468933/index.html">Runcing dan tajam, ke mana pun Anda melihat: mekanisme penajaman sendiri gigi bulu babi</a></li>
<li><a href="../id468935/index.html">Intisari acara untuk profesional SDM di bidang TI pada Oktober 2019</a></li>
<li><a href="../id468937/index.html">Serangan Kartu Bank tanpa kontak</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>