<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👶🏽 🤟🏻 🧔 尝试在Kubernetes中构建和自动化部署的新工具 🤲🏾 ⛳️ 🍹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="你好 最近，已经发布了许多很酷的自动化工具，用于构建Docker映像以及将其部署到Kubernetes。 在这方面，我决定使用gitlab，研究如何研究它的功能，当然还要配置管道。 


 这项工作的灵感来自网站kubernetes.io ，该网站是从源代码自动生成的，对于每个发送的池，机器人会自动...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>尝试在Kubernetes中构建和自动化部署的新工具</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481662/"><p><img src="https://habrastorage.org/webt/fu/wy/ia/fuwyia7huxrflvry8lzz2dbl2tw.png"></p><br><p> 你好 最近，已经发布了许多很酷的自动化工具，用于构建Docker映像以及将其部署到Kubernetes。 在这方面，我决定使用gitlab，研究如何研究它的功能，当然还要配置管道。 </p><br><p> 这项工作的灵感来自网站<a href="https://kubernetes.io/" rel="nofollow">kubernetes.io</a> ，该网站是从<a href="http://github.com/kubernetes/website" rel="nofollow">源代码</a>自动生成的，对于每个发送的池，机器人会自动生成包含您<a href="https://kubernetes.io/" rel="nofollow">所做</a>更改的网站预览版本，并提供查看链接。 </p><br><p> 我尝试从头开始构建一个类似的过程，但完全基于Gitlab CI和我用来在Kubernetes中部署应用程序的免费工具。 今天，我最终将向您详细介绍它们。 </p><br><p> 本文将考虑以下工具： <br>  <strong>Hugo</strong> ， <strong>qbec</strong> ， <strong>kaniko</strong> ， <strong>git-crypt</strong>和<strong>GitLab CI</strong>以及动态环境的创建。 </p><a name="habracut"></a><br><hr><br><h1 id="coderzhanie"> 目录内容 </h1><br><ol><li>  <a href="https://habr.com/ru/post/481662/"><strong>雨果简介</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>准备Dockerfile</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>与kaniko相识</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>qbec简介</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>用Kubernetes-executor尝试Gitlab-runner</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>使用qbec部署Helm图表</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>引入git-crypt</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>创建工具箱图像</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>我们的第一个管道和标签的图像组装</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>部署自动化</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>工件和推入构建大师</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>动态环境</strong></a> </li><li>  <a href="https://habr.com/ru/post/481662/"><strong>评论应用</strong></a> </li></ol><br><hr><br><h1 id="1-znakomstvo-s-hugoanchorhugoanchor">  1.雨果简介 <a name="hugo"></a></h1><br><p> 作为我们项目的一个示例，我们将尝试创建一个网站来发布基于Hugo的文档。  Hugo是静态内容生成器。 </p><br><p> 对于那些不熟悉静态生成器的人，我会告诉您更多有关它们的信息。 与常规数据库站点引擎和某些php引擎不同，当用户提示时，它们会即时生成页面，而静态生成器的排列方式略有不同。 它们允许您获取源，通常它是Markdown标记和主题模板中的一组文件，然后将它们编译成一个完整的网站。 </p><br><p> 也就是说，在输出中，您将获得目录结构和一组生成的html文件，可以将其简单地上载到任何便宜的主机并获得一个工作站点。 </p><br><p> 雨果可以在本地安装并试用： </p><br><p> 我们初始化新站点： </p><br><pre><code class="bash hljs">hugo new site docs.example.org</code> </pre> <br><p> 并同时git存储库： </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> docs.example.org git init</code> </pre> <br><p> 到目前为止，我们的网站是原始的，要使它首先出现在其中，我们需要关联一个主题，一个主题-它只是生成我们网站所用的一组模板和预设规则。 </p><br><p> 作为主题，我们将使用<a href="https://themes.gohugo.io/hugo-theme-learn/" rel="nofollow"><strong>Learn</strong></a> ，我认为它最适合包含文档的网站。 </p><br><p> 我要特别注意一个事实，我们不需要将主题文件保存在我们项目的存储库中，而是可以使用<strong>git submodule</strong>进行简单连接： </p><br><pre> <code class="bash hljs">git submodule add https://github.com/matcornic/hugo-theme-learn themes/learn</code> </pre> <br><p> 因此，在我们的存储库中将只有与项目直接相关的文件，并且连接的主题将保持为指向特定存储库的链接的形式并在其中提交，即始终可以将其从原始源中拉出而不必担心更改不兼容。 </p><br><p> 修复<strong>config.toml</strong>配置： </p><br><pre> <code class="plaintext hljs">baseURL = "http://docs.example.org/" languageCode = "en-us" title = "My Docs Site" theme = "learn"</code> </pre> <br><p> 在此阶段，您可以运行： </p><br><pre> <code class="bash hljs">hugo server</code> </pre> <br><p> 在<a href="http://localhost:1313/" rel="nofollow">http：// localhost：1313 /</a>检查我们新创建的站点，对目录所做的所有更改都会自动更新，并且在浏览器中打开页面非常方便！ </p><br><p> 让我们尝试在<strong>content / _index.md中</strong>创建封面： </p><br><pre> <code class="markdown hljs"><span class="hljs-section"><span class="hljs-section"># My docs site ## Welcome to the docs! You will be very smart :-)</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">新建页面的屏幕截图</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/gb/yx/nv/gbyxnvagfs6bks4iqbwcrrovumu.png"></p></div></div><br><p> 要生成一个站点，只需运行： </p><br><pre> <code class="bash hljs">hugo</code> </pre> <br><p>  <strong>public /</strong>目录的内容将成为您的站点。 <br> 是的，顺便说一句，让我们立即将其添加到<strong>.gitignore</strong> ： </p><br><pre> <code class="plaintext hljs">echo /public &gt; .gitignore</code> </pre> <br><p> 不要忘记提交我们的更改： </p><br><pre> <code class="plaintext hljs">git add . git commit -m "New site created"</code> </pre> <br><hr><br><h1 id="2-podgotovka-dockerfileanchordockerfileanchor">  2.准备Dockerfile <a name="dockerfile"></a></h1><br><p> 现在是确定存储库结构的时候了。 通常我使用类似： </p><br><pre> <code class="plaintext hljs">. ├── deploy │ ├── app1 │ └── app2 └── dockerfiles ├── image1 └── image2</code> </pre> <br><ul><li>  <strong>dockerfiles--</strong>包含Dockerfiles目录以及构建docker映像所需的一切。 </li><li>  <strong>deploy /</strong> -包含用于将我们的应用程序部署到Kubernetes的目录 </li></ul><br><p> 因此，我们将沿着路径<strong>dockerfiles / website / Dockerfile</strong>创建我们的第一个<strong>Dockerfile。</strong> </p><br><pre> <code class="bash hljs">FROM alpine:3.11 as builder ARG HUGO_VERSION=0.62.0 RUN wget -O- https://github.com/gohugoio/hugo/releases/download/v<span class="hljs-variable"><span class="hljs-variable">${HUGO_VERSION}</span></span>/hugo_<span class="hljs-variable"><span class="hljs-variable">${HUGO_VERSION}</span></span>_linux-64bit.tar.gz | tar -xz -C /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin ADD . /src RUN hugo -s /src FROM alpine:3.11 RUN apk add --no-cache darkhttpd COPY --from=builder /src/public /var/www ENTRYPOINT [ <span class="hljs-string"><span class="hljs-string">"/usr/bin/darkhttpd"</span></span> ] CMD [ <span class="hljs-string"><span class="hljs-string">"/var/www"</span></span> ]</code> </pre> <br><p> 如您所见，Dockerfile包含两个FROM，此功能称为<a href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="nofollow"><strong>多阶段构建</strong></a> ，可让您从最终docker映像中排除所有不必要的内容。 <br> 因此，最终图像将仅包含<strong>darkhttpd</strong> （轻量级HTTP服务器）和<strong>public /</strong> -静态生成的站点的内容。 </p><br><p> 不要忘记提交我们的更改： </p><br><pre> <code class="plaintext hljs">git add dockerfiles/website git commit -m "Add Dockerfile for website"</code> </pre> <br><hr><br><h1 id="3-znakomstvo-s-kanikoanchorkanikoanchor">  3.认识加尼子 <a name="kaniko"></a></h1><br><p> 作为<strong><a href="https://github.com/GoogleContainerTools/kaniko" rel="nofollow">docker</a></strong>映像的收集者，我决定使用<strong><a href="https://github.com/GoogleContainerTools/kaniko" rel="nofollow">kaniko</a></strong> ，因为它不需要<strong><a href="https://github.com/GoogleContainerTools/kaniko" rel="nofollow">docker</a></strong>守护进程来工作，并且程序集本身可以在任何计算机上执行并将缓存直接存储在注册表中，从而消除了对完整持久性存储的需求。 。 </p><br><p> 要构建映像，只需使用<strong>kaniko executor</strong>启动容器并将当前的构建上下文传递给它，您可以通过<strong>docker</strong>在本地执行此操作： </p><br><pre> <code class="bash hljs">docker run -ti --rm \ -v <span class="hljs-variable"><span class="hljs-variable">$PWD</span></span>:/workspace \ -v ~/.docker/config.json:/kaniko/.docker/config.json:ro \ gcr.io/kaniko-project/executor:v0.15.0 \ --cache \ --dockerfile=dockerfiles/website/Dockerfile \ --destination=registry.gitlab.com/kvaps/docs.example.org/website:v0.0.1</code> </pre> <br><p> 其中<strong>registry.gitlab.com/kvaps/docs.example.org/website</strong>是您的泊坞窗映像的名称，在组装后它将被自动推送到泊坞窗寄存器中。 </p><br><p>  <strong>--cache</strong>参数允许您在<strong>docker</strong>注册表中缓存图层，对于给定的示例，它们将保存在<strong>Registry.gitlab.com/kvaps/docs.example.org/website/cache中</strong> ，但是您可以使用<strong>--cache-</strong>参数指定其他路径<strong>回购</strong> </p><br><div class="spoiler">  <b class="spoiler_title">屏幕截图docker-registry</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/0-/31/qx/0-31qxfta2gk7-colutf2l_qtmm.png"></p></div></div><br><hr><br><h1 id="4-znakomstvo-s-qbecanchorqbecanchor">  4.认识qbec <a name="qbec"></a></h1><br><p>  <a href="https://qbec.io/" rel="nofollow">Qbec</a>是一个部署工具，可让您声明性地描述应用程序的清单并将其部署到Kubernetes。 使用Jsonnet作为主要语法，可以大大简化几种环境下差异的描述，并且几乎完全消除了代码的可重复性。 </p><br><p> 在需要将应用程序部署到具有不同参数的多个集群中并且想要在Git中声明性地描述它们的情况下，尤其如此。 </p><br><p>  Qbec还允许您通过传递必要的参数并随后对其进行操作以及正常的声明（包括可以叠加在其上的各种突变）来渲染Helm图表，从而消除了使用ChartMuseum的需要。 也就是说，您可以直接从git所在的位置存储和渲染图表。 </p><br><p> 如前所述，我们将所有部署存储在<strong>deploy /</strong>目录中： </p><br><pre> <code class="bash hljs">mkdir deploy <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> deploy</code> </pre> <br><p> 让我们初始化第一个应用程序： </p><br><pre> <code class="bash hljs">qbec init website <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> website</code> </pre> <br><p> 现在，我们的应用程序的结构如下所示： </p><br><pre> <code class="plaintext hljs">. ├── components ├── environments │  ├── base.libsonnet │  └── default.libsonnet ├── params.libsonnet └── qbec.yaml</code> </pre> <br><p> 查看<strong>qbec.yaml</strong>文件： </p><br><pre> <code class="plaintext hljs">apiVersion: qbec.io/v1alpha1 kind: App metadata: name: website spec: environments: default: defaultNamespace: docs server: https://kubernetes.example.org:8443 vars: {}</code> </pre> <br><p> 在这里，我们主要对<strong>spec.environments</strong>感兴趣，qbec已经为我们创建了一个默认环境，并获取了服务器地址以及当前kubeconfig中的名称空间。 <br> 现在，当部署到<strong>默认</strong>环境时，qbec将始终只部署到指定的Kubernetes集群和指定的名称空间，也就是说，您将不再需要在上下文和名称空间之间切换来执行部署。 <br> 如有必要，您始终可以更新此文件中的设置。 </p><br><p> 您的所有环境都在<strong>qbec.yaml</strong>和<strong>params.libsonnet</strong>文件中进行了<strong>描述</strong> ，其中指出了需要在其中获取参数的位置。 </p><br><p> 接下来，我们看到两个目录： </p><br><ul><li>  <strong>组件/</strong> -我们应用程序的所有清单都将存储在此处，它们可以在jsonnet和普通yaml文件中进行描述 </li><li>  <strong>环境/</strong> -在这里，我们将描述<strong>环境的</strong>所有变量（参数）。 </li></ul><br><p> 默认情况下，我们有两个文件： </p><br><ul><li>  <strong>环境/ base.libsonnet-</strong>将包含所有环境的常规参数 </li><li>  <strong>环境/ default.libsonnet-</strong>包含<strong>默认</strong>环境中覆盖的参数 </li></ul><br><p> 让我们打开<strong>环境/ base.libsonnet</strong>并在<strong>此处</strong>添加第一个组件的参数： </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">components</span></span>: { <span class="hljs-attr"><span class="hljs-attr">website</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'example-docs'</span></span>, <span class="hljs-attr"><span class="hljs-attr">image</span></span>: <span class="hljs-string"><span class="hljs-string">'registry.gitlab.com/kvaps/docs.example.org/website:v0.0.1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">replicas</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">containerPort</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-attr"><span class="hljs-attr">servicePort</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-attr"><span class="hljs-attr">nodeSelector</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">tolerations</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">ingressClass</span></span>: <span class="hljs-string"><span class="hljs-string">'nginx'</span></span>, <span class="hljs-attr"><span class="hljs-attr">domain</span></span>: <span class="hljs-string"><span class="hljs-string">'docs.example.org'</span></span>, }, }, }</code> </pre> <br><p> 我们还将创建我们的第一个组件<strong>component / website.jsonnet</strong> ： </p><br><pre> <code class="javascript hljs">local env = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: std.extVar(<span class="hljs-string"><span class="hljs-string">'qbec.io/env'</span></span>), <span class="hljs-attr"><span class="hljs-attr">namespace</span></span>: std.extVar(<span class="hljs-string"><span class="hljs-string">'qbec.io/defaultNs'</span></span>), }; local p = <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'../params.libsonnet'</span></span>; local params = p.components.website; [ { <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: <span class="hljs-string"><span class="hljs-string">'apps/v1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'Deployment'</span></span>, <span class="hljs-attr"><span class="hljs-attr">metadata</span></span>: { <span class="hljs-attr"><span class="hljs-attr">labels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name }, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">spec</span></span>: { <span class="hljs-attr"><span class="hljs-attr">replicas</span></span>: params.replicas, <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: { <span class="hljs-attr"><span class="hljs-attr">matchLabels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name, }, }, <span class="hljs-attr"><span class="hljs-attr">template</span></span>: { <span class="hljs-attr"><span class="hljs-attr">metadata</span></span>: { <span class="hljs-attr"><span class="hljs-attr">labels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name }, }, <span class="hljs-attr"><span class="hljs-attr">spec</span></span>: { <span class="hljs-attr"><span class="hljs-attr">containers</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'darkhttpd'</span></span>, <span class="hljs-attr"><span class="hljs-attr">image</span></span>: params.image, <span class="hljs-attr"><span class="hljs-attr">ports</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">containerPort</span></span>: params.containerPort, }, ], }, ], <span class="hljs-attr"><span class="hljs-attr">nodeSelector</span></span>: params.nodeSelector, <span class="hljs-attr"><span class="hljs-attr">tolerations</span></span>: params.tolerations, <span class="hljs-attr"><span class="hljs-attr">imagePullSecrets</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'regsecret'</span></span> }], }, }, }, }, { <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: <span class="hljs-string"><span class="hljs-string">'v1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'Service'</span></span>, <span class="hljs-attr"><span class="hljs-attr">metadata</span></span>: { <span class="hljs-attr"><span class="hljs-attr">labels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name }, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">spec</span></span>: { <span class="hljs-attr"><span class="hljs-attr">selector</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">ports</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">port</span></span>: params.servicePort, <span class="hljs-attr"><span class="hljs-attr">targetPort</span></span>: params.containerPort, }, ], }, }, { <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: <span class="hljs-string"><span class="hljs-string">'extensions/v1beta1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'Ingress'</span></span>, <span class="hljs-attr"><span class="hljs-attr">metadata</span></span>: { <span class="hljs-attr"><span class="hljs-attr">annotations</span></span>: { <span class="hljs-string"><span class="hljs-string">'kubernetes.io/ingress.class'</span></span>: params.ingressClass, }, <span class="hljs-attr"><span class="hljs-attr">labels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name }, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">spec</span></span>: { <span class="hljs-attr"><span class="hljs-attr">rules</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">host</span></span>: params.domain, <span class="hljs-attr"><span class="hljs-attr">http</span></span>: { <span class="hljs-attr"><span class="hljs-attr">paths</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">backend</span></span>: { <span class="hljs-attr"><span class="hljs-attr">serviceName</span></span>: params.name, <span class="hljs-attr"><span class="hljs-attr">servicePort</span></span>: params.servicePort, }, }, ], }, }, ], }, }, ]</code> </pre> <br><p> 在此文件中，我们立即描述了三个Kubernetes实体，它们是： <strong>Deployment</strong> ， <strong>Service</strong>和<strong>Ingress</strong> 。 如果需要，我们可以将它们包含在不同的组件中，但是在此阶段，一个就足够了。 </p><br><p>  <strong>jsonnet</strong>语法与常规json非常相似，原则上常规json已经是有效的jsonnet，因此首先使用<strong>yaml2json之</strong>类的在线服务将您通常的yaml转换为json可能会更容易，或者如果您的组件不包含任何变量，那么它们可以以普通Yaml的形式描述。 </p><br><blockquote> 使用<strong>jsonnet时，</strong>强烈建议您为编辑器安装一个插件 <br><br> 例如，对于vim，有一个<strong>vim-jsonnet插件</strong>可以打开语法突出显示功能，并在每次保存时自动执行<strong>jsonnet fmt</strong> （它需要安装jsonnet）。 </blockquote><p> 一切准备就绪，现在我们可以开始部署了： </p><br><p> 要查看发生了什么，我们将执行以下操作： </p><br><pre> <code class="bash hljs">qbec show default</code> </pre> <br><p> 在输出中，您将看到渲染的Yaml清单，这些清单将应用于默认集群。 </p><br><p> 好的，现在申请： </p><br><pre> <code class="bash hljs">qbec apply default</code> </pre> <br><p> 在出口处，您将始终看到集群中将执行的操作，qbec将要求您接受更改，通过键入<strong>y</strong>可以确认您的意图。 </p><br><p> 完成，现在我们的应用程序已停靠！ </p><br><p> 如果进行更改，则始终可以执行以下操作： </p><br><pre> <code class="bash hljs">qbec diff default</code> </pre> <br><p> 了解这些更改将如何影响当前部署 </p><br><p> 不要忘记提交我们的更改： </p><br><pre> <code class="plaintext hljs">cd ../.. git add deploy/website git commit -m "Add deploy for website"</code> </pre> <br><hr><br><h1 id="5-probuem-gitlab-runner-s-kubernetes-executoranchorgitlab-runneranchor">  5.使用Kubernetes-executor尝试Gitlab-runner <a name="gitlab-runner"></a></h1><br><p> 直到最近，我仅在带有shell或docker-executor的预先准备好的机器（LXC容器）上使用普通的<strong>gitlab-runner</strong> 。 最初，我们在hitlab中全局定义了其中一些跑步者。 他们收集了所有项目的docker映像。 </p><br><p> 但是，正如实践所示，从实用性和安全性角度来看，此选项都不是最理想的选择。 为每个项目甚至为每个环境部署单独的运行器会更好，并且在思想上更正确。 </p><br><p> 幸运的是，这根本不是问题，因为现在我们将直接将<strong>gitlab-runner</strong>作为我们项目的一部分直接部署到Kubernetes。 </p><br><p>  Gitlab提供了一个现成的舵图，用于在Kubernetes中部署gitlab-runner。 因此，您需要做的就是在<strong>设置-&gt; CI / CD-&gt; Runners中</strong>找到我们项目的<strong>注册令牌</strong> ，并将其传递给头盔： </p><br><pre> <code class="bash hljs">helm repo add gitlab https://charts.gitlab.io helm install gitlab-runner \ --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> gitlabUrl=https://gitlab.com \ --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> runnerRegistrationToken=yga8y-jdCusVDn_t4Wxc \ --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> rbac.create=<span class="hljs-literal"><span class="hljs-literal">true</span></span> \ gitlab/gitlab-runner</code> </pre> <br><p> 其中： </p><br><ul><li>  <strong><a href="https://gitlab.com/" rel="nofollow">https://gitlab.com</a></strong>是您的Gitlab服务器的地址。 </li><li>  <strong>yga8y-jdCusVDn_t4Wxc-</strong>项目的注册令牌。 </li><li>  <strong>rbac.create = true-</strong>为跑步者提供所需数量的特权，使其能够使用kubernetes-executor创建吊舱以执行我们的任务。 </li></ul><br><p> 如果一切正确完成，则应该在项目设置的“运行<strong>者”</strong>部分中看到已注册的运行<strong>者</strong> 。 </p><br><div class="spoiler">  <b class="spoiler_title">添加的跑步者的屏幕截图</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/at/lx/g_/atlxg_u6rjn4n0pkcpn8--2gare.png"></p></div></div><br><p> 这么简单吗？  -是的，很简单！ 手动注册跑步者不再麻烦，从现在开始，跑步者将被自动创建和销毁。 </p><br><hr><br><h1 id="6-deploy-helm-chartov-s-qbecanchorqbec-helmanchor">  6.使用QBEC部署Helm图表 <a name="qbec-helm"></a></h1><br><p> 由于我们决定考虑将<strong>gitlab-runner</strong>纳入项目的一部分，因此该在我们的Git存储库中对其进行描述了。 </p><br><p> 我们可以将其描述为<strong>网站的</strong>一个单独组件，但是将来，我们计划非常频繁地部署<strong>网站的</strong>不同副本，这与<strong>gitlab-runner</strong>不同，后者对于每个Kubernetes集群仅部署一次。 因此，让我们为其初始化一个单独的应用程序： </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> deploy qbec init gitlab-runner <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> gitlab-runner</code> </pre> <br><p> 这次我们将不再手动描述Kubernetes实体，而是采用现成的Helm图表。  qbec的优点之一是能够直接从Git存储库中呈现Helm图表。 </p><br><p> 让我们使用git子模块将其插入： </p><br><pre> <code class="bash hljs">git submodule add https://gitlab.com/gitlab-org/charts/gitlab-runner vendor/gitlab-runner</code> </pre> <br><p> 现在， <strong>vendor / gitlab-runner</strong>目录包含我们的存储库以及gitlab-runner的图表。 </p><br><blockquote> 同样，您可以连接其他存储库，例如，整个存储库与官方图表<strong><a href="https://github.com/helm/charts" rel="nofollow">https://github.com/helm/charts</a></strong> </blockquote><p> 让我们描述<strong>组件/ gitlab-runner.jsonnet组件</strong> ： </p><br><pre> <code class="javascript hljs">local env = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: std.extVar(<span class="hljs-string"><span class="hljs-string">'qbec.io/env'</span></span>), <span class="hljs-attr"><span class="hljs-attr">namespace</span></span>: std.extVar(<span class="hljs-string"><span class="hljs-string">'qbec.io/defaultNs'</span></span>), }; local p = <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'../params.libsonnet'</span></span>; local params = p.components.gitlabRunner; std.native(<span class="hljs-string"><span class="hljs-string">'expandHelmTemplate'</span></span>)( <span class="hljs-string"><span class="hljs-string">'../vendor/gitlab-runner'</span></span>, params.values, { <span class="hljs-attr"><span class="hljs-attr">nameTemplate</span></span>: params.name, <span class="hljs-attr"><span class="hljs-attr">namespace</span></span>: env.namespace, <span class="hljs-attr"><span class="hljs-attr">thisFile</span></span>: std.thisFile, <span class="hljs-attr"><span class="hljs-attr">verbose</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, } )</code> </pre> <br><p>  <strong>expandHelmTemplate</strong>的第一个参数是传递路径到图表，然后是<strong>params.values</strong> ，它是从环境参数中获取的，然后是一个带有 </p><br><ul><li>  <strong>nameTemplate-</strong>发布名称 </li><li>  <strong>名称空间</strong> -传递给舵机的<strong>名称</strong>空间 </li><li>  <strong>thisFile-</strong>将路径传递到当前文件的必需参数 </li><li>  <strong>详细</strong> -呈现图表时显示带有所有参数的<strong>helm模板</strong>命令 </li></ul><br><p> 现在，我们将在<strong>环境/ base.libsonnet中</strong>描述组件的参数： </p><br><pre> <code class="javascript hljs">local secrets = <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'../secrets/base.libsonnet'</span></span>; { <span class="hljs-attr"><span class="hljs-attr">components</span></span>: { <span class="hljs-attr"><span class="hljs-attr">gitlabRunner</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'gitlab-runner'</span></span>, <span class="hljs-attr"><span class="hljs-attr">values</span></span>: { <span class="hljs-attr"><span class="hljs-attr">gitlabUrl</span></span>: <span class="hljs-string"><span class="hljs-string">'https://gitlab.com/'</span></span>, <span class="hljs-attr"><span class="hljs-attr">rbac</span></span>: { <span class="hljs-attr"><span class="hljs-attr">create</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">runnerRegistrationToken</span></span>: secrets.runnerRegistrationToken, }, }, }, }</code> </pre> <br><p> 注意我们从外部<strong>secrets / base.libsonnet文件中获取的RunnerRegistrationToken</strong> ，让我们创建它： </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">runnerRegistrationToken</span></span>: <span class="hljs-string"><span class="hljs-string">'yga8y-jdCusVDn_t4Wxc'</span></span>, }</code> </pre> <br><p> 检查一切是否正常： </p><br><pre> <code class="bash hljs">qbec show default</code> </pre> <br><p> 如果一切正常，那么我们可以通过Helm版本删除较早的版本： </p><br><pre> <code class="bash hljs">helm uninstall gitlab-runner</code> </pre> <br><p> 并部署它，但是已经通过qbec进行了部署： </p><br><pre> <code class="bash hljs">qbec apply default</code> </pre> <br><hr><br><h1 id="7-znakomstvo-s-git-cryptanchorgit-cryptanchor">  7.引入git-crypt <a name="git-crypt"></a></h1><br><p>  <strong><a href="https://github.com/AGWA/git-crypt" rel="nofollow">Git-crypt</a></strong>是一种工具，可让您为存储库设置透明加密。 </p><br><p> 目前，我们gitlab-runner的目录结构如下： </p><br><pre> <code class="plaintext hljs">. ├── components │  ├── gitlab-runner.jsonnet ├── environments │  ├── base.libsonnet │  └── default.libsonnet ├── params.libsonnet ├── qbec.yaml ├── secrets │  └── base.libsonnet └── vendor └── gitlab-runner (submodule)</code> </pre> <br><p> 但是在Git中保密并不安全，对吗？ 因此，我们需要对其进行适当的加密。 </p><br><blockquote> 通常，为了单个变量，这并不总是有意义。 您可以将机密传递给<strong>qbec</strong>并通过CI系统的环境变量。 <br> 但是，值得注意的是，还有更复杂的项目可以包含更多的秘密；通过环境变量将它们全部转移将极为困难。 <br><br> 另外，在这种情况下，我将无法告诉您有关<strong>git-crypt之</strong>类的出色工具的信息。 <br><br>  <strong>git-crypt</strong>也很方便，因为它允许您保存所有秘密历史记录，以及以与以前在Git情况下相同的方式比较，合并和解决冲突。 </blockquote><p> 首先，在安装<strong>git-crypt之后，</strong>我们需要为存储库生成密钥： </p><br><pre> <code class="plaintext hljs">git crypt init</code> </pre> <br><p> 如果您具有PGP密钥，则可以立即将自己添加为该项目的协作者： </p><br><pre> <code class="plaintext hljs">git-crypt add-gpg-user kvapss@gmail.com</code> </pre> <br><p> 因此，您始终可以使用私钥解密该存储库。 </p><br><p> 如果您没有PGP密钥并且不期望使用，则可以采用另一种方法导出项目密钥： </p><br><pre> <code class="plaintext hljs">git crypt export-key /path/to/keyfile</code> </pre> <br><p> 这样，拥有导出<strong>密钥文件的</strong>任何人都可以解密您的存储库。 </p><br><p> 现在是设置我们的第一个秘密的时候了。 <br> 让我提醒您，我们仍然位于<strong>deploy / gitlab-runner /</strong>目录中，在该目录中有<strong>secrets /</strong>目录，让我们加密其中的所有文件，为此，我们创建具有以下内容的<strong>secrets / .gitattributes文件</strong> ： </p><br><pre> <code class="plaintext hljs">* filter=git-crypt diff=git-crypt .gitattributes !filter !diff</code> </pre> <br><p> 正如您从内容中看到的那样，除<strong>.gitattributes</strong>本身之外，所有带掩码<strong>*的</strong>文件都将通过<strong>git-crypt</strong>运行 </p><br><p> 我们可以通过运行以下命令进行验证： </p><br><pre> <code class="bash hljs">git crypt status -e</code> </pre> <br><p> 在输出中，我们获得存储库中已启用加密的所有文件的列表 </p><br><p> 就是这样，现在我们可以安全地进行更改了： </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ../.. git add . git commit -m <span class="hljs-string"><span class="hljs-string">"Add deploy for gitlab-runner"</span></span></code> </pre> <br><p> 为了阻止存储库，只需执行以下操作： </p><br><pre> <code class="bash hljs">git crypt lock</code> </pre> <br><p> 然后所有加密的文件都变成二进制文件，将无法读取它们。 <br> 要解密存储库，请执行以下操作： </p><br><pre> <code class="bash hljs">git crypt unlock</code> </pre> <br><hr><br><h1 id="8-sozdayom-toolbox-obrazanchortoolboxanchor">  8.创建工具箱图像 <a name="toolbox"></a></h1><br><p> 工具箱映像就是包含用于部署项目的所有工具的映像。  gitlab运行程序将使用它来执行典型的部署任务。 </p><br><p> 这里的一切都很简单，我们创建一个具有以下内容的新<strong>dockerfiles / toolbox / Dockerfile</strong> ： </p><br><pre> <code class="bash hljs">FROM alpine:3.11 RUN apk add --no-cache git git-crypt RUN QBEC_VER=0.10.3 \ &amp;&amp; wget -O- https://github.com/splunk/qbec/releases/download/v<span class="hljs-variable"><span class="hljs-variable">${QBEC_VER}</span></span>/qbec-linux-amd64.tar.gz \ | tar -C /tmp -xzf - \ &amp;&amp; mv /tmp/qbec /tmp/jsonnet-qbec /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/ RUN KUBECTL_VER=1.17.0 \ &amp;&amp; wget -O /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/kubectl \ https://storage.googleapis.com/kubernetes-release/release/v<span class="hljs-variable"><span class="hljs-variable">${KUBECTL_VER}</span></span>/bin/linux/amd64/kubectl \ &amp;&amp; chmod +x /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/kubectl RUN HELM_VER=3.0.2 \ &amp;&amp; wget -O- https://get.helm.sh/helm-v<span class="hljs-variable"><span class="hljs-variable">${HELM_VER}</span></span>-linux-amd64.tar.gz \ | tar -C /tmp -zxf - \ &amp;&amp; mv /tmp/linux-amd64/helm /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin/helm</code> </pre> <br><p> 如您所见，在此图中，我们安装了用于部署应用程序的所有实用程序。 我们<strong>在这里</strong>不需要<strong>kubectl</strong> ，但是您可能想在管道设置阶段使用它。 </p><br><p> 另外，为了能够与Kubernetes通信并在其中进行部署，我们需要为gitlab-runner生成的pod配置角色。 </p><br><p> 为此，请使用gitlab-runner转到目录： </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> deploy/gitlab-runner</code> </pre> <br><p> 并添加一个新的组件<strong>components / rbac.jsonnet</strong> ： </p><br><pre> <code class="javascript hljs">local env = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: std.extVar(<span class="hljs-string"><span class="hljs-string">'qbec.io/env'</span></span>), <span class="hljs-attr"><span class="hljs-attr">namespace</span></span>: std.extVar(<span class="hljs-string"><span class="hljs-string">'qbec.io/defaultNs'</span></span>), }; local p = <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'../params.libsonnet'</span></span>; local params = p.components.rbac; [ { <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: <span class="hljs-string"><span class="hljs-string">'v1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'ServiceAccount'</span></span>, <span class="hljs-attr"><span class="hljs-attr">metadata</span></span>: { <span class="hljs-attr"><span class="hljs-attr">labels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, }, }, { <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: <span class="hljs-string"><span class="hljs-string">'rbac.authorization.k8s.io/v1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'Role'</span></span>, <span class="hljs-attr"><span class="hljs-attr">metadata</span></span>: { <span class="hljs-attr"><span class="hljs-attr">labels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">rules</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">apiGroups</span></span>: [ <span class="hljs-string"><span class="hljs-string">'*'</span></span>, ], <span class="hljs-attr"><span class="hljs-attr">resources</span></span>: [ <span class="hljs-string"><span class="hljs-string">'*'</span></span>, ], <span class="hljs-attr"><span class="hljs-attr">verbs</span></span>: [ <span class="hljs-string"><span class="hljs-string">'*'</span></span>, ], }, ], }, { <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: <span class="hljs-string"><span class="hljs-string">'rbac.authorization.k8s.io/v1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'RoleBinding'</span></span>, <span class="hljs-attr"><span class="hljs-attr">metadata</span></span>: { <span class="hljs-attr"><span class="hljs-attr">labels</span></span>: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">roleRef</span></span>: { <span class="hljs-attr"><span class="hljs-attr">apiGroup</span></span>: <span class="hljs-string"><span class="hljs-string">'rbac.authorization.k8s.io'</span></span>, <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'Role'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, }, <span class="hljs-attr"><span class="hljs-attr">subjects</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">kind</span></span>: <span class="hljs-string"><span class="hljs-string">'ServiceAccount'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: params.name, <span class="hljs-attr"><span class="hljs-attr">namespace</span></span>: env.namespace, }, ], }, ]</code> </pre> <br><p> 我们还将在<strong>环境/ base.libsonnet中</strong>描述新参数，现在看起来像这样： </p><br><pre> <code class="javascript hljs">local secrets = <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'../secrets/base.libsonnet'</span></span>; { <span class="hljs-attr"><span class="hljs-attr">components</span></span>: { <span class="hljs-attr"><span class="hljs-attr">gitlabRunner</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'gitlab-runner'</span></span>, <span class="hljs-attr"><span class="hljs-attr">values</span></span>: { <span class="hljs-attr"><span class="hljs-attr">gitlabUrl</span></span>: <span class="hljs-string"><span class="hljs-string">'https://gitlab.com/'</span></span>, <span class="hljs-attr"><span class="hljs-attr">rbac</span></span>: { <span class="hljs-attr"><span class="hljs-attr">create</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">runnerRegistrationToken</span></span>: secrets.runnerRegistrationToken, <span class="hljs-attr"><span class="hljs-attr">runners</span></span>: { <span class="hljs-attr"><span class="hljs-attr">serviceAccountName</span></span>: $.components.rbac.name, <span class="hljs-attr"><span class="hljs-attr">image</span></span>: <span class="hljs-string"><span class="hljs-string">'registry.gitlab.com/kvaps/docs.example.org/toolbox:v0.0.1'</span></span>, }, }, }, <span class="hljs-attr"><span class="hljs-attr">rbac</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'gitlab-runner-deploy'</span></span>, }, }, }</code> </pre> <br><p> 注意<strong>$ .components.rbac.name</strong>是指<strong>rbac</strong>组件的<strong>名称</strong> </p><br><p> 让我们检查一下发生了什么变化： </p><br><pre> <code class="bash hljs">qbec diff default</code> </pre> <br><p> 并将我们的更改应用于Kubernetes： </p><br><pre> <code class="bash hljs">qbec apply default</code> </pre> <br><p> 另外，不要忘记将更改提交到git： </p><br><pre> <code class="plaintext hljs">cd ../.. git add dockerfiles/toolbox git commit -m "Add Dockerfile for toolbox" git add deploy/gitlab-runner git commit -m "Configure gitlab-runner to use toolbox"</code> </pre> <br><hr><br><h1 id="9-nash-pervyy-payplayn-i-sborka-obrazov-po-tegamanchorpipeline-buildanchor">  9.我们的第一个流水线和按标签组装图像 <a name="pipeline-build"></a></h1><br><p> 在项目的根目录中，我们将创建具有以下内容的<strong>.gitlab-ci.yml</strong> ： </p><br><pre> <code class="plaintext hljs">.build_docker_image: stage: build image: name: gcr.io/kaniko-project/executor:debug-v0.15.0 entrypoint: [""] before_script: - echo "{\"auths\":{\"$CI_REGISTRY\":{\"username\":\"$CI_REGISTRY_USER\",\"password\":\"$CI_REGISTRY_PASSWORD\"}}}" &gt; /kaniko/.docker/config.json build_toolbox: extends: .build_docker_image script: - /kaniko/executor --cache --context $CI_PROJECT_DIR/dockerfiles/toolbox --dockerfile $CI_PROJECT_DIR/dockerfiles/toolbox/Dockerfile --destination $CI_REGISTRY_IMAGE/toolbox:$CI_COMMIT_TAG only: refs: - tags build_website: extends: .build_docker_image variables: GIT_SUBMODULE_STRATEGY: normal script: - /kaniko/executor --cache --context $CI_PROJECT_DIR --dockerfile $CI_PROJECT_DIR/dockerfiles/website/Dockerfile --destination $CI_REGISTRY_IMAGE/website:$CI_COMMIT_TAG only: refs: - tags</code> </pre> <br><p> 请注意，对于那些需要在执行之前显式初始化子模块的作业，我们使用<strong>GIT_SUBMODULE_STRATEGY：normal</strong> 。 </p><br><p> 不要忘记提交我们的更改： </p><br><pre> <code class="plaintext hljs">git add .gitlab-ci.yml git commit -m "Automate docker build"</code> </pre> <br><p> 我认为您可以放心地将其<strong>命名为v0.0.1</strong>版本并挂一个标签： </p><br><pre> <code class="bash hljs">git tag v0.0.1</code> </pre> <br><p> 每当需要发布新版本时，我们都会挂起标签。  Docker映像中的标签将绑定到Git标签。 带有新标签的每次推送都会初始化带有该标签的图像集合。 </p><br><p> 运行<strong>git push --tags</strong> ，然后看一下我们的第一个管道： </p><br><div class="spoiler">  <b class="spoiler_title">第一条管道的屏幕截图</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/5u/ce/fg/5ucefgejcfjz7jpwvou206mwufy.png"></p></div></div><br><blockquote> 值得关注的事实是，按标签组装适用于组装Docker映像，但不适用于在Kubernetes中部署应用程序。 由于新标签也可以分配给旧提交，因此在这种情况下，对它们的管道初始化将导致旧版本的部署。 <br><br> 为了解决此问题，通常将docker-images的程序集附加到标签，然后将应用程序部署到<strong>master</strong>分支，在该分支中，所收集映像的版本将进行硬编码。 在这种情况下，您可以使用简单的还原<strong>主</strong>标签来初始化回滚。 </blockquote><br><hr><br><h1 id="10-avtomatizaciya-deployaanchorpipeline-deployanchor">  10.部署自动化 <a name="pipeline-deploy"></a></h1><br><p> 为了让Gitlab-runner解密我们的机密，我们需要导出存储库密钥，并将其添加到CI的环境变量中： </p><br><pre> <code class="plaintext hljs">git crypt export-key /tmp/docs-repo.key base64 -w0 /tmp/docs-repo.key; echo</code> </pre> <br><p> 将结果字符串保存在Gitlab中，为此，我们将转到项目的设置： <br>  <strong>设置-&gt; CI / CD-&gt;变量</strong> </p><br><p>    : </p><br><div class="scrollable-table"><table><thead><tr><th> Type </th><th> Key </th><th> Value </th><th> Protected </th><th> Masked </th><th> Scope </th></tr></thead><tbody><tr><td> <code>File</code> </td> <td> <code>GITCRYPT_KEY</code> </td> <td> <code>&lt;your string&gt;</code> </td> <td> <code>true</code> <em>(     <code>false</code> )</em> </td><td> <code>true</code> </td> <td> <code>All environments</code> </td> </tr></tbody></table></div><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/vj/li/ea/vjliealfwwsmiy4-nvjfvcf89ig.png"></p></div></div><br><p>    <strong>.gitlab-ci.yml</strong>   : </p><br><pre> <code class="plaintext hljs">.deploy_qbec_app: stage: deploy only: refs: - master deploy_gitlab_runner: extends: .deploy_qbec_app variables: GIT_SUBMODULE_STRATEGY: normal before_script: - base64 -d "$GITCRYPT_KEY" | git-crypt unlock - script: - qbec apply default --root deploy/gitlab-runner --force:k8s-context __incluster__ --wait --yes deploy_website: extends: .deploy_qbec_app script: - qbec apply default --root deploy/website --force:k8s-context __incluster__ --wait --yes</code> </pre> <br><p>        qbec: </p><br><ul><li> <strong>--root some/app</strong> —      </li><li> <strong>--force:k8s-context __incluster__</strong> —   ,             gtilab-runner.   ,      qbec     Kubernetes-   kubeconfig </li><li> <strong>--wait</strong> —  qbec ,        Ready       exit-code. </li><li> <strong>--yes</strong> —     <strong>Are you sure?</strong>  . </li></ul><br><p>     : </p><br><pre> <code class="plaintext hljs">git add .gitlab-ci.yml git commit -m "Automate deploy"</code> </pre> <br><p>   <strong>git push</strong>       : </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/0p/aj/vs/0pajvs-a-lrxvfuw8zylnj6lleg.png"></p></div></div><br><hr><br><h1 id="11-artefakty-i-sborka-pri-push-v-masteranchorartifactsanchor"> 11.     push  master <a name="artifacts"></a></h1><br><p>            ,             .           digest  master-. </p><br><p>  :    <strong>website</strong>      push  <strong>master</strong> ,       Kubernetes. </p><br><p>        <strong>.gitlab-ci.yml</strong> : </p><br><pre> <code class="plaintext hljs">build_website: extends: .build_docker_image variables: GIT_SUBMODULE_STRATEGY: normal script: - mkdir -p $CI_PROJECT_DIR/artifacts - /kaniko/executor --cache --context $CI_PROJECT_DIR --dockerfile $CI_PROJECT_DIR/dockerfiles/website/Dockerfile --destination $CI_REGISTRY_IMAGE/website:$CI_COMMIT_REF_NAME --digest-file $CI_PROJECT_DIR/artifacts/website.digest artifacts: paths: - artifacts/ only: refs: - master - tags deploy_website: extends: .deploy_qbec_app script: - DIGEST="$(cat artifacts/website.digest)" - qbec apply default --root deploy/website --force:k8s-context __incluster__ --wait --yes --vm:ext-str digest="$DIGEST"</code> </pre> <br><p>  ,    <strong>master</strong>  <strong>refs</strong>   <strong>build_website</strong>     <strong>$CI_COMMIT_REF_NAME</strong>  <strong>$CI_COMMIT_TAG</strong> ,        Git           .  ,        ,           docker-registry. </p><br><p>   docker-       ,        Kubernetes,           ,         . </p><br><p>  <strong>--vm:ext-str digest="$DIGEST"</strong>  qbec —      jsonnet.            .   ,     ,     ,               . </p><br><p>     Kaniko  digest    ( <strong>--digest-file</strong> ) <br>          . </p><br><p>     <strong>deploy/website/environments/base.libsonnet</strong>     : </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">components</span></span>: { <span class="hljs-attr"><span class="hljs-attr">website</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'example-docs'</span></span>, <span class="hljs-attr"><span class="hljs-attr">image</span></span>: <span class="hljs-string"><span class="hljs-string">'registry.gitlab.com/kvaps/docs.example.org/website@'</span></span> + std.extVar(<span class="hljs-string"><span class="hljs-string">'digest'</span></span>), <span class="hljs-attr"><span class="hljs-attr">replicas</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">containerPort</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-attr"><span class="hljs-attr">servicePort</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-attr"><span class="hljs-attr">nodeSelector</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">tolerations</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">ingressClass</span></span>: <span class="hljs-string"><span class="hljs-string">'nginx'</span></span>, <span class="hljs-attr"><span class="hljs-attr">domain</span></span>: <span class="hljs-string"><span class="hljs-string">'docs.example.org'</span></span>, }, }, }</code> </pre> <br><p> ,     <strong>master</strong>   docker-  <strong>website</strong> ,      Kubernetes. </p><br><p>     : </p><br><pre> <code class="bash hljs">git add . git commit -m <span class="hljs-string"><span class="hljs-string">"Configure dynamic build"</span></span></code> </pre> <br><p> ,  <strong>git push</strong>    - : </p><br><div class="spoiler"> <b class="spoiler_title">   master</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/7_/ry/nh/7_rynh5lgu_8hqnnl_gasx73zwq.png"></p></div></div><br><p>       gitlab-runner   push, , ,      ,     <strong>.gitlab-ci.yml</strong> : </p><br><pre> <code class="plaintext hljs">deploy_gitlab_runner: extends: .deploy_qbec_app variables: GIT_SUBMODULE_STRATEGY: normal before_script: - base64 -d "$GITCRYPT_KEY" | git-crypt unlock - script: - qbec apply default --root deploy/gitlab-runner --force:k8s-context __incluster__ --wait --yes only: changes: - deploy/gitlab-runner/**/*</code> </pre> <br><p> <strong>changes</strong>      <strong>deploy/gitlab-runner/</strong>          </p><br><p>     : </p><br><pre> <code class="bash hljs">git add .gitlab-ci.yml git commit -m <span class="hljs-string"><span class="hljs-string">"Reduce gitlab-runner deploy"</span></span></code> </pre> <br><p> <strong>git push</strong> , - : </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/-t/9b/3m/-t9b3mtofbunu7xfogpmb0pacsm.png"></p></div></div><br><hr><br><h1 id="12-dynamic-environmentsanchordynamic-environmentsanchor"> 12. Dynamic environments <a name="dynamic-environments"></a></h1><br><p>       . </p><br><p>     <strong>build_website</strong>   <strong>.gitlab-ci.yml</strong> ,     <strong>only</strong> ,   Gitlab        : </p><br><pre> <code class="plaintext hljs">build_website: extends: .build_docker_image variables: GIT_SUBMODULE_STRATEGY: normal script: - mkdir -p $CI_PROJECT_DIR/artifacts - /kaniko/executor --cache --context $CI_PROJECT_DIR --dockerfile $CI_PROJECT_DIR/dockerfiles/website/Dockerfile --destination $CI_REGISTRY_IMAGE/website:$CI_COMMIT_REF_NAME --digest-file $CI_PROJECT_DIR/artifacts/website.digest artifacts: paths: - artifacts/</code> </pre> <br><p>    <strong>deploy_website</strong> ,    <strong>environment</strong> : </p><br><pre> <code class="plaintext hljs">deploy_website: extends: .deploy_qbec_app environment: name: prod url: https://docs.example.org script: - DIGEST="$(cat artifacts/website.digest)" - qbec apply default --root deploy/website --force:k8s-context __incluster__ --wait --yes --vm:ext-str digest="$DIGEST"</code> </pre> <br><p>   Gitlab    <strong>prod</strong>       . </p><br><p>     : </p><br><pre> <code class="plaintext hljs">deploy_website: extends: .deploy_qbec_app environment: name: prod url: https://docs.example.org script: - DIGEST="$(cat artifacts/website.digest)" - qbec apply default --root deploy/website --force:k8s-context __incluster__ --wait --yes --vm:ext-str digest="$DIGEST" deploy_review: extends: .deploy_qbec_app environment: name: review/$CI_COMMIT_REF_NAME url: http://$CI_ENVIRONMENT_SLUG.docs.example.org on_stop: stop_review script: - DIGEST="$(cat artifacts/website.digest)" - qbec apply review --root deploy/website --force:k8s-context __incluster__ --wait --yes --vm:ext-str digest="$DIGEST" --vm:ext-str subdomain="$CI_ENVIRONMENT_SLUG" --app-tag "$CI_ENVIRONMENT_SLUG" only: refs: - branches except: refs: - master stop_review: extends: .deploy_qbec_app environment: name: review/$CI_COMMIT_REF_NAME action: stop stage: deploy before_script: - git clone "$CI_REPOSITORY_URL" master - cd master script: - qbec delete review --root deploy/website --force:k8s-context __incluster__ --yes --vm:ext-str digest="$DIGEST" --vm:ext-str subdomain="$CI_ENVIRONMENT_SLUG" --app-tag "$CI_ENVIRONMENT_SLUG" variables: GIT_STRATEGY: none only: refs: - branches except: refs: - master when: manual</code> </pre> <br><p>     push     master    preview  . </p><br><p>      qbec: <strong>--app-tag</strong> —             ,       Kubernetes qbec    . <br>           review,       . </p><br><p>      <strong>qbec apply review</strong> ,  <strong>qbec apply default</strong> —               (review  default): </p><br><p>  <strong>review</strong>   <strong>deploy/website/qbec.yaml</strong> </p><br><pre> <code class="plaintext hljs">spec: environments: review: defaultNamespace: docs server: https://kubernetes.example.org:8443</code> </pre> <br><p>     <strong>deploy/website/params.libsonnet</strong> : </p><br><pre> <code class="javascript hljs">local env = std.extVar(<span class="hljs-string"><span class="hljs-string">'qbec.io/env'</span></span>); local paramsMap = { <span class="hljs-attr"><span class="hljs-attr">_</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./environments/base.libsonnet'</span></span>, <span class="hljs-attr"><span class="hljs-attr">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./environments/default.libsonnet'</span></span>, <span class="hljs-attr"><span class="hljs-attr">review</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./environments/review.libsonnet'</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> std.objectHas(paramsMap, env) then paramsMap[env] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> error <span class="hljs-string"><span class="hljs-string">'environment '</span></span> + env + <span class="hljs-string"><span class="hljs-string">' not defined in '</span></span> + std.thisFile</code> </pre> <br><p>        <strong>deploy/website/environments/review.libsonnet</strong> : </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// this file has the param overrides for the default environment local base = import './base.libsonnet'; local slug = std.extVar('qbec.io/tag'); local subdomain = std.extVar('subdomain'); base { components+: { website+: { name: 'example-docs-' + slug, domain: subdomain + '.docs.example.org', }, }, }</span></span></code> </pre> <br><p>       <strong>stop_review</strong> ,         gitlab    checkout    <strong>GIT_STRATEGY: none</strong> ,    <strong>master</strong> -   review  . <br>  ,        . <br>       review   ,     . </p><br><p>     : </p><br><pre> <code class="plaintext hljs">git add . git commit -m "Enable automatic review"</code> </pre> <br><p> <strong>git push</strong> , <strong>git checkout -b test</strong> , <strong>git push origin test</strong> , : </p><br><div class="spoiler"> <b class="spoiler_title">  environments  Gitlab</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/wc/pz/ce/wcpzcedcwgfqvr0h_thgcw4ylqk.png"></p></div></div><br><p>  ? — ,    : <strong>git checkout master</strong> , <strong>git push origin :test</strong> ,      environment   . </p><br><blockquote>    ,        ,     <strong>.gitlab-ci.yml</strong>       . <br>          protected-,   <strong>master</strong> ,        . </blockquote><br><hr><br><h1 id="13-review-appsanchorreview-appsanchor"> 13. Review Apps <a name="review-apps"></a></h1><br><p> <strong><a href="https://docs.gitlab.com/ee/ci/review_apps/" rel="nofollow">Review Apps</a></strong>    ,                . </p><br><p>      ,    <strong>.gitlab/route-map.yml</strong>       ,       : </p><br><pre> <code class="plaintext hljs"># Indices - source: /content\/(.+?)_index\.(md|html)/ public: '\1' # Pages - source: /content\/(.+?)\.(md|html)/ public: '\1/'</code> </pre> <br><p>     : </p><br><pre> <code class="plaintext hljs">git add .gitlab/ git commit -m "Enable review apps"</code> </pre> <br><p> <strong>git push</strong> ,  : </p><br><div class="spoiler"> <b class="spoiler_title">  Review App</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ns/wi/za/nswizajvjjozyoluazo21pzq7t8.png"></p></div></div><br><h1 id="job-is-done"> Job is done! </h1><br><p> <strong> :</strong> </p><br><ul><li>  Gitlab: <a href="" rel="nofollow">https://gitlab.com/kvaps/docs.example.org</a> </li><li>  GitHub: <a href="" rel="nofollow">https://github.com/kvaps/docs.example.org</a> </li></ul><br><p>   ,    <img src="https://habrastorage.org/getpro/habr/post_images/cd7/2c7/9c3/cd72c79c3eeb7355e20bba58e9088654.gif" alt="图片"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN481662/">https://habr.com/ru/post/zh-CN481662/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN481644/index.html">如何在21世纪的SQL数据库中生存：云，Kubernetes和PostgreSQL多主机</a></li>
<li><a href="../zh-CN481648/index.html">在Junos PyEZ上找到免费的ipv4子网的任务示例</a></li>
<li><a href="../zh-CN481652/index.html">在BlackBerry Android智能手机上的后门（？）</a></li>
<li><a href="../zh-CN481654/index.html">质量保证工程师如何使用Bot Framework在Test IT的帮助下使您的生活更轻松的故事</a></li>
<li><a href="../zh-CN481656/index.html">PagerDuty，或者为什么运营部门晚上无法入睡</a></li>
<li><a href="../zh-CN481664/index.html">无服务器定价和成本：AWS Lambda</a></li>
<li><a href="../zh-CN481666/index.html">自定义SwiftLint规则</a></li>
<li><a href="../zh-CN481668/index.html">第一个观众问题，或将WebRTC视频流转换为HLS的困难</a></li>
<li><a href="../zh-CN481670/index.html">使用AWS Cloud Adoption Framework创建行动计划</a></li>
<li><a href="../zh-CN481672/index.html">浏览器中的元胞自动机</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>