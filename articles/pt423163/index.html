<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÜï ü§¶üèº üë©üèΩ‚Äçüéì Conectando o CryptoPro ao Mono üë®üèæ‚Äçüéì üíáüèº üéí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em conex√£o com a transi√ß√£o para o Linux, tornou-se necess√°rio portar um de nossos sistemas de servidor escritos em C # para Mono. O sistema trabalha c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Conectando o CryptoPro ao Mono</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423163/"><p>  Em conex√£o com a transi√ß√£o para o Linux, tornou-se necess√°rio portar um de nossos sistemas de servidor escritos em C # para Mono.  O sistema trabalha com assinaturas digitais aprimoradas; portanto, uma das tarefas que enfrentamos foi verificar o desempenho dos certificados GOST do CryptoPro em mono.  O pr√≥prio CryptoPro implementou o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CSP</a> para Linux h√° algum tempo, mas a primeira tentativa de us√°-lo mostrou que as classes de criptografia Mono nativas (semelhantes √†s da base .Net - X509Store, X509Certificate2, etc.) n√£o apenas n√£o funcionam com chaves de convidado, mas tamb√©m n√£o os veja em seus cofres.  Devido a isso, o trabalho com criptografia teve que ser conectado diretamente atrav√©s das bibliotecas CryptoPro. </p><br><a name="habracut"></a><br><h2>  Instala√ß√£o de certificado </h2><br><p>  Antes de implementar o c√≥digo, voc√™ deve instalar o certificado e garantir que ele funcione corretamente. </p><br><div class="spoiler">  <b class="spoiler_title">Instala√ß√£o de certificado</b> <div class="spoiler_text"><p>  O componente CryptoPro CSP vers√£o 3.9 foi instalado no Centos 7 na pasta / opt / cprocsp.  Para evitar conflitos entre os utilit√°rios mono e CryptoPro com o mesmo nome (por exemplo, certmgr), o caminho para a pasta n√£o foi inserido nas vari√°veis ‚Äã‚Äãde ambiente e todos os utilit√°rios foram chamados no caminho completo. </p><br><p> Primeiro, definimos uma lista de leitores: <br> <code>/opt/cprocsp/bin/amd64/csptest -enum -info -type PP_ENUMREADERS | iconv -f cp1251</code> </p> <br><p>  Se n√£o houver um leitor da pasta no disco (HDIMAGE) na lista, coloque-o: <br> <code>/opt/cprocsp/sbin/amd64/cpconfig -hardware reader -add HDIMAGE store</code> </p> <br><p>  Em seguida, voc√™ pode criar cont√™ineres no formato '\\. \ HDIMAGE \ {container name}', criando um novo cont√™iner com as chaves: <br> <code>/opt/cprocsp/bin/amd64/csptest -keyset -provtype 75 -newkeyset -cont '\\.\HDIMAGE\test'</code> </p> <br><p>  ou criando a pasta / var / opt / cprocsp / keys / root / {nome do cont√™iner} .000, que cont√©m o conjunto padr√£o de arquivos de cont√™iner CryptoPro (* .key, * .mask etc.). </p><br><p>  Depois disso, o certificado do cont√™iner pode ser instalado no armazenamento de certificados: <br> <code>/opt/cprocsp/bin/amd64/certmgr -inst mMy -cont '\\.\HDIMAGE\{ }'</code> </p> <br><p>  O certificado instalado pode ser visto com o seguinte comando: <br> <code>/opt/cprocsp/bin/amd64/certmgr -list mMy</code> </p> <br><p>  A opera√ß√£o do certificado pode ser verificada da seguinte maneira: <br> <code>/opt/cprocsp/bin/amd64/cryptcp ‚Äì sign -norev -thumbprint {} {} { }</code> <br> <code>/opt/cprocsp/bin/amd64/cryptcp ‚Äì verify -norev { }</code> </p> <br><p>  Se tudo estiver bem com o certificado, voc√™ poder√° prosseguir para a conex√£o no c√≥digo. </p><br></div></div><br><h2>  Conex√£o no c√≥digo </h2><br><p>  Apesar do processo de portar para o Linux, o sistema deveria continuar funcionando no ambiente Windows; portanto, externamente, o trabalho com criptografia tinha que ser realizado atrav√©s de m√©todos gerais no formato ‚Äúbyte [] SignData (byte [] _arData, X509Certificate2 _pCert)‚Äù, que deveria funcionar igualmente como no Linux e no Windows. </p><br><p>  Uma an√°lise dos m√©todos das bibliotecas de criptografia resultou bem-sucedida, porque o CryptoPro implementou a biblioteca ‚Äúlibcapi20.so‚Äù, que imita completamente as bibliotecas de criptografia padr√£o do Windows - ‚Äúcrypt32.dll‚Äù e ‚Äúadvapi32.dll‚Äù.  Talvez, √© claro, n√£o inteiramente, mas todos os m√©todos necess√°rios para trabalhar com criptografia estejam dispon√≠veis l√°, e quase todo o trabalho. </p><br><p>  Portanto, formamos duas classes est√°ticas ‚ÄúWCryptoAPI‚Äù e ‚ÄúLCryptoAPI‚Äù, cada uma das quais importar√° o conjunto de m√©todos necess√°rio da seguinte maneira: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(LIBCAPI20, SetLastError = true)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CertCloseStore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hCertStore, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _iFlags</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br><p>  A sintaxe de conex√£o de cada um dos m√©todos pode ser criada independentemente, ou usar o site <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pinvoke</a> , ou copiar de fontes .Net (classe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CAPISafe</a> ).  No mesmo m√≥dulo, voc√™ pode desenhar constantes e estruturas associadas √† criptografia, cuja presen√ßa sempre facilita a vida ao trabalhar com bibliotecas externas. </p><br><p>  E ent√£o formamos a classe est√°tica ‚ÄúUCryptoAPI‚Äù que, dependendo do sistema, chamar√° o m√©todo de uma das duas classes: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_iFlags"&gt; (  0)&lt;/param&gt; * &lt;param name="_hCertStore"&gt;   &lt;/param&gt; * &lt;returns&gt;   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CertCloseStore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hCertStore, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _iFlags</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fIsLinux) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LCryptoAPI.CertCloseStore(_hCertStore, _iFlags); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WCryptoAPI.CertCloseStore(_hCertStore, _iFlags); } <span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  &lt;/summary&gt;**/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> fIsLinux { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iPlatform = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) Environment.OSVersion.Platform; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (iPlatform == <span class="hljs-number"><span class="hljs-number">4</span></span>) || (iPlatform == <span class="hljs-number"><span class="hljs-number">6</span></span>) || (iPlatform == <span class="hljs-number"><span class="hljs-number">128</span></span>); } }</code> </pre><br><p>  Portanto, usando os m√©todos da classe UCryptoAPI, voc√™ pode implementar c√≥digo quase uniforme para os dois sistemas. </p><br><h3>  Pesquisa de certificado </h3><br><p>  O trabalho com criptografia geralmente come√ßa com uma pesquisa de certificado; para isso, no crypt32.dll, existem dois m√©todos CertOpenStore (abre o armazenamento de certificados especificado) e um CertOpenSystemStore simples (abre os certificados pessoais do usu√°rio).  Como o trabalho com certificados n√£o se limita aos certificados de usu√°rio pessoal, conectamos o primeiro: </p><br><div class="spoiler">  <b class="spoiler_title">Pesquisa de certificado</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  (   )&lt;/summary&gt; * &lt;param name="_pFindType"&gt; &lt;/param&gt; * &lt;param name="_pFindValue"&gt; &lt;/param&gt; * &lt;param name="_pLocation"&gt; &lt;/param&gt; * &lt;param name="_pName"&gt; &lt;/param&gt; * &lt;param name="_pCert"&gt; &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_fVerify"&gt; &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindCertificateCP</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _pFindValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError, StoreLocation _pLocation = StoreLocation.CurrentUser, StoreName _pName = StoreName.My, X509FindType _pFindType = X509FindType.FindByThumbprint, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _fVerify = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { _pCert = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; IntPtr hCert = IntPtr.Zero; GCHandle hInternal = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GCHandle(); GCHandle hFull = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GCHandle(); IntPtr hSysStore = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)   hSysStore = UCryptoAPI.CertOpenStore(UCConsts.AR_CERT_STORE_PROV_SYSTEM[fIsLinux.ToByte()], UCConsts.PKCS_7_OR_X509_ASN_ENCODING, IntPtr.Zero, UCUtils.MapX509StoreFlags(_pLocation, OpenFlags.ReadOnly), UCConsts.AR_CRYPTO_STORE_NAME[(int)_pName]); if (hSysStore == IntPtr.Zero) { _sError = UCConsts.S_ERR_STORE_OPEN.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } // 1)     if ((_pFindType == X509FindType.FindByThumbprint) || (_pFindType == X509FindType.FindBySerialNumber)) { byte[] arData = _pFindValue.FromHex(); CRYPTOAPI_BLOB cryptBlob; cryptBlob.cbData = arData.Length; hInternal = GCHandle.Alloc(arData, GCHandleType.Pinned); cryptBlob.pbData = hInternal.AddrOfPinnedObject(); hFull = GCHandle.Alloc(cryptBlob, GCHandleType.Pinned); } else { byte[] arData; if(fIsLinux) arData = Encoding.UTF8.GetBytes(_pFindValue); else arData = Encoding.Unicode.GetBytes(_pFindValue); hFull = GCHandle.Alloc(arData, GCHandleType.Pinned); } // 2)  IntPtr hPrev = IntPtr.Zero; do { hCert = UCryptoAPI.CertFindCertificateInStore(hSysStore, UCConsts.PKCS_7_OR_X509_ASN_ENCODING, 0, UCConsts.AR_CRYPT_FIND_TYPE[(int)_pFindType, fIsLinux.ToByte()], hFull.AddrOfPinnedObject(), hPrev); // 2.1)   if(hPrev != IntPtr.Zero) UCryptoAPI.CertFreeCertificateContext(hPrev); // 2.2)    if(hCert == IntPtr.Zero) return UConsts.E_NO_CERTIFICATE; // 2.3)    X509Certificate2 pCert = new ISDP_X509Cert(hCert); if (!_fVerify || pCert.ISDPVerify()) { hCert = IntPtr.Zero; _pCert = pCert; return UConsts.S_OK; } hPrev = hCert; //    hCert = IntPtr.Zero; } while(hCert != IntPtr.Zero); return UConsts.E_NO_CERTIFICATE; } catch (Exception E) { _sError = UCConsts.S_FIND_CERT_GEN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { //      if(hInternal.IsAllocated) hInternal.Free(); if(hFull.IsAllocated) hFull.Free(); if (hCert != IntPtr.Zero) UCryptoAPI.CertFreeCertificateContext(hCert); UCryptoAPI.CertCloseStore(hSysStore, 0); } }</span></span></code> </pre><br></div></div><br>  A pesquisa ocorre em v√°rias etapas: <br><ol><li>  abertura de armazenamento; </li><li>  a forma√ß√£o da estrutura de dados pela qual estamos procurando </li><li>  pesquisa de certificado; </li><li>  se necess√°rio, a verifica√ß√£o do certificado (descrita em uma se√ß√£o separada); </li><li>  fechando o reposit√≥rio e liberando a estrutura do ponto 2 (j√° que em todos os lugares h√° trabalho com mem√≥ria .net n√£o gerenciada, nada ser√° feito para que possamos limp√°-lo); </li></ol><br><p>  Existem alguns pontos sutis ao procurar certificados. </p><br><p>  O CryptoPro no Linux funciona com seq√º√™ncias de caracteres ANSI e no Windows com UTF8, portanto: </p><br><ol><li>  ao conectar o m√©todo de abertura de armazenamento no Linux, √© necess√°rio indicar explicitamente o tipo de empacotamento [In, MarshalAs (UnmanagedType.LPStr)] para o par√¢metro de c√≥digo de armazenamento; </li><li>  passando a string de pesquisa (por exemplo, pelo nome de Subject), ela deve ser convertida em um conjunto de bytes com codifica√ß√µes diferentes; </li><li>  para todas as constantes criptogr√°ficas que possuem varia√ß√£o pelo tipo de sequ√™ncia (por exemplo, CERT_FIND_SUBJECT_STR_A e CERT_FIND_SUBJECT_STR_W) no Windows, voc√™ deve selecionar * _W e no Linux * _A; </li></ol><br><p>  O m√©todo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MapX509StoreFlags</a> pode ser obtido diretamente de fontes da Microsoft sem altera√ß√µes, simplesmente forma uma m√°scara final com base nos sinalizadores .Net. </p><br><p>  O valor pelo qual a pesquisa √© realizada depende do tipo de pesquisa (verifique no MSDN o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CertFindCertificateInStore</a> ); o exemplo mostra as duas op√ß√µes mais usadas - para o formato da string (nomes Assunto, Emissor, etc.) e bin√°rio (impress√£o digital, n√∫mero de s√©rie). </p><br><p>  O processo de cria√ß√£o de um certificado do IntPtr no Windows e Linux √© muito diferente.  O Windows criar√° o certificado de uma maneira simples: <br></p><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X509Certificate2(hCert);</code> </pre> <p></p><br><p>  no Linux, voc√™ precisa criar um certificado em duas etapas: <br></p><pre> <code class="cs hljs">X509Certificate2(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X509Certificate(hCert));</code> </pre> <p></p><br><p>  No futuro, precisamos acessar o hCert for work e ele dever√° ser armazenado no objeto de certificado.  No Windows, ele pode ser recuperado posteriormente a partir da propriedade Handle, mas o Linux converte a estrutura CERT_CONTEXT que segue o link hCert em um link para a estrutura x509_st (OpenSSL) e o registra no Handle.  Portanto, vale a pena criar um herdador do X509Certificate2 (ISDP_X509Cert no exemplo), que armazenar√° o hCert nos dois sistemas em um campo separado. </p><br><p>  N√£o esque√ßa que este √© um link para uma √°rea de mem√≥ria n√£o gerenciada e deve ser liberada ap√≥s o t√©rmino do trabalho.  Porque  no .Net 4.5 X509Certificate2 n√£o √© descart√°vel - a limpeza usando o m√©todo CertFreeCertificateContext deve ser executada no destruidor. </p><br><h3>  Forma√ß√£o de Assinaturas </h3><br><p>  Ao trabalhar com certificados GOST, quase sempre s√£o usadas assinaturas desconectadas com um signat√°rio.  Para criar essa assinatura, √© necess√°rio um bloco de c√≥digo bastante simples: </p><br><div class="spoiler">  <b class="spoiler_title">Forma√ß√£o de Assinaturas</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  &lt;/summary&gt; * &lt;param name="_arData"&gt;  &lt;/param&gt; * &lt;param name="_pCert"&gt;&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_arRes"&gt; &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SignDataCP</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arData, X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arRes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _arRes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// 0)   CRYPT_SIGN_MESSAGE_PARA pParams = new CRYPT_SIGN_MESSAGE_PARA(); pParams.cbSize = Marshal.SizeOf(typeof(CRYPT_SIGN_MESSAGE_PARA)); pParams.dwMsgEncodingType = (int)(UCConsts.PKCS_7_OR_X509_ASN_ENCODING); pParams.pSigningCert = _pCert.getRealHandle(); pParams.cMsgCert = 1; pParams.HashAlgorithm.pszObjId = _pCert.getHashAlgirtmOid(); IntPtr pGlobData = Marshal.AllocHGlobal(_arData.Length); GCHandle pGC = GCHandle.Alloc(_pCert.getRealHandle(), GCHandleType.Pinned); try { pParams.rgpMsgCert = pGC.AddrOfPinnedObject(); Marshal.Copy(_arData, 0, pGlobData, _arData.Length); uint iLen = 50000; byte[] arRes = new byte[iLen]; // 1)   if (!UCryptoAPI.CryptSignMessage(ref pParams, true, 1, new IntPtr[1] { pGlobData }, new uint[1] { (uint)_arData.Length }, arRes, ref iLen)) { _sError = UCConsts.S_MAKE_SIGN_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } Array.Resize(ref arRes, (int)iLen); _arRes = arRes; return UConsts.S_OK;; } catch (Exception E) { _sError = UCConsts.S_MAKE_SIGN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { pGC.Free(); Marshal.FreeHGlobal(pGlobData); } }</span></span></code> </pre></div></div><br><p>  Durante o trabalho do m√©todo, uma estrutura com par√¢metros √© formada e o m√©todo de assinatura √© chamado.  A estrutura de par√¢metros pode permitir que voc√™ salve certificados na assinatura para formar uma cadeia completa (os campos cMsgCert e rgpMsgCert, o primeiro armazena o n√∫mero de certificados e a segunda lista de links para as estruturas desses certificados). </p><br><p>  O m√©todo de assinatura pode receber um ou mais documentos para assinatura simult√¢nea com uma assinatura.  A prop√≥sito, isso n√£o contradiz a Lei Federal 63 e √© muito conveniente, pois √© improv√°vel que o usu√°rio fique satisfeito com a necessidade de clicar no bot√£o "assinar" v√°rias vezes. </p><br><p>  A principal estranheza desse m√©todo √© que ele n√£o funciona no modo de duas chamadas, o que √© t√≠pico da maioria dos m√©todos de biblioteca que trabalham com grandes blocos de mem√≥ria (o primeiro com nulo - retorna o comprimento do buffer necess√°rio, o segundo preenche o buffer).  Portanto, √© necess√°rio criar um buffer grande e reduzi-lo ao seu tamanho real. </p><br><p>  O √∫nico problema s√©rio √© a pesquisa do OID do algoritmo de hash (Digest) usado ao entrar - de forma expl√≠cita, n√£o est√° no certificado (existe apenas o algoritmo da pr√≥pria assinatura).  E se no Windows voc√™ pode especific√°-lo com uma string vazia - ele ser√° ativado automaticamente, mas o Linux se recusar√° a assinar se o algoritmo n√£o for o mesmo. </p><br><p>  Mas h√° um truque - nas informa√ß√µes sobre o algoritmo de assinatura (estrutura CRYPT_OID_INFO), o OID da assinatura √© armazenado no pszOID e o identificador do algoritmo de hash √© armazenado no Algid.  E converter Algid em OID j√° √© uma quest√£o t√©cnica: </p><br><div class="spoiler">  <b class="spoiler_title">Obtendo o OID do algoritmo de hash</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; OID   &lt;/summary&gt; * &lt;param name="_hCertHandle"&gt; &lt;/param&gt; * &lt;param name="_sOID"&gt;  OID&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHashAlgoritmOID</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hCertHandle, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sOID, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _sOID = <span class="hljs-string"><span class="hljs-string">""</span></span>; IntPtr hHashAlgInfo = IntPtr.Zero; IntPtr hData = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { CERT_CONTEXT pContext = (CERT_CONTEXT)Marshal.PtrToStructure(_hCertHandle, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CERT_CONTEXT)); CERT_INFO pCertInfo = (CERT_INFO)Marshal.PtrToStructure(pContext.pCertInfo, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CERT_INFO)); <span class="hljs-comment"><span class="hljs-comment">//  AlgID //  UCryptoAPI.CertAlgIdToOID  Windows   ,   byte[] arData = BitConverter.GetBytes(UCryptoAPI.CertOIDToAlgId(pCertInfo.SignatureAlgorithm.pszObjId)); hData = Marshal.AllocHGlobal(arData.Length); Marshal.Copy(arData, 0, hData, arData.Length); //  OID hHashAlgInfo = UCryptoAPI.CryptFindOIDInfo(UCConsts.CRYPT_OID_INFO_ALGID_KEY, hData, UCConsts.CRYPT_HASH_ALG_OID_GROUP_ID); if (hHashAlgInfo == IntPtr.Zero) { _sError = UCConsts.S_NO_HASH_ALG_ERR.Frm( Marshal.GetLastWin32Error()); return UConsts.E_GEN_EXCEPTION; } CRYPT_OID_INFO pHashAlgInfo = (CRYPT_OID_INFO)Marshal.PtrToStructure(hHashAlgInfo, typeof(CRYPT_OID_INFO)); _sOID = pHashAlgInfo.pszOID; return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_DETERM_HASH_ALG_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { Marshal.FreeHGlobal(hData); } }</span></span></code> </pre></div></div><br><p>  Ap√≥s a leitura cuidadosa do c√≥digo, voc√™ pode se surpreender ao descobrir que o identificador do algoritmo √© obtido de maneira simples (CertOIDToAlgId) e o Oid √© complicado (CryptFindOIDInfo).  Seria l√≥gico supor o uso de m√©todos complexos ou simples, e no Linux ambas as op√ß√µes funcionam com √™xito.  No entanto, no Windows, a op√ß√£o dif√≠cil de obter um identificador e simplesmente obter um OID √© inst√°vel; portanto, um h√≠brido t√£o estranho seria uma solu√ß√£o est√°vel. </p><br><h3>  Verifica√ß√£o de Assinatura </h3><br><p>  A verifica√ß√£o da assinatura ocorre em duas etapas, no in√≠cio, a pr√≥pria assinatura √© verificada e, em seguida, o certificado com o qual foi gerada √© verificado (cadeia, data de assinatura, etc.). <br>  Al√©m de assinar, voc√™ deve especificar o conjunto de dados a serem assinados, os par√¢metros de assinatura e a pr√≥pria assinatura: </p><br><div class="spoiler">  <b class="spoiler_title">Verifica√ß√£o de Assinatura</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;      &lt;/summary&gt; * &lt;returns&gt;&lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> CRYPT_VERIFY_MESSAGE_PARA </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStdSignVerifyPar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CRYPT_VERIFY_MESSAGE_PARA pVerifyParams = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CRYPT_VERIFY_MESSAGE_PARA(); pVerifyParams.cbSize = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Marshal.SizeOf(pVerifyParams); pVerifyParams.dwMsgEncodingType = UCConsts.PKCS_7_OR_X509_ASN_ENCODING; pVerifyParams.hCryptProv = <span class="hljs-number"><span class="hljs-number">0</span></span>; pVerifyParams.pfnGetSignerCertificate = IntPtr.Zero; pVerifyParams.pvGetArg = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pVerifyParams; } <span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_arData"&gt;,   &lt;/param&gt; * &lt;param name="_pSign"&gt;&lt;/param&gt; * &lt;param name="_pCert"&gt;&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_fVerifyOnlySign"&gt;  &lt;/param&gt; * &lt;param name="_pRevMode"&gt;  &lt;/param&gt; * &lt;param name="_pRevFlag"&gt;  &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * &lt;remarks&gt;   &lt;/remarks&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckSignCP</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _pSign, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _fVerifyOnlySign = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">, X509RevocationMode _pRevMode = X509RevocationMode.Online, X509RevocationFlag _pRevFlag = X509RevocationFlag.ExcludeRoot</span></span></span><span class="hljs-function">)</span></span>{ _pCert = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; IntPtr pHData = Marshal.AllocHGlobal(_arData.Length); GCHandle pCertContext = GCHandle.Alloc(IntPtr.Zero, GCHandleType.Pinned); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Marshal.Copy(_arData, <span class="hljs-number"><span class="hljs-number">0</span></span>, pHData, _arData.Length); CRYPT_VERIFY_MESSAGE_PARA pVerParam = UCUtils.GetStdSignVerifyPar(); <span class="hljs-comment"><span class="hljs-comment">// 0)   bool fRes = UCryptoAPI.CryptVerifyDetachedMessageSignature( ref pVerParam, //   0, //   _pSign, //  _pSign.Length, //   1, // -    new IntPtr[1] { pHData }, //   new int[1] { _arData.Length }, //    pCertContext.AddrOfPinnedObject());//    if (!fRes) { _sError = UCConsts.S_SIGN_CHECK_ERR.Frm(Marshal.GetLastWin32Error().ToString("X")); return UConsts.E_CRYPTO_ERR; } // 1)   _pCert = new ISDP_X509Cert((IntPtr)pCertContext.Target); if (_pCert == null) { _sError = UCConsts.S_SIGN_CHECK_CERT_ERR; return UConsts.E_CRYPTO_ERR; } // 2)   if (!_fVerifyOnlySign) { List&lt;DateTime&gt; pDates; // 2.1)    int iRes = GetSignDateTimeCP(_pSign, out pDates, ref _sError); // 2.2)    iRes = _pCert.ISDPVerify(ref _sError, pDates[0], _pRevMode, _pRevFlag); if (iRes != UConsts.S_OK) return iRes; } return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_SIGN_CHECK_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION;; } finally { Marshal.FreeHGlobal(pHData); if ((_pCert == null) &amp;&amp; pCertContext.IsAllocated &amp;&amp; ((IntPtr)pCertContext.Target != IntPtr.Zero)) UCryptoAPI.CertFreeCertificateContext((IntPtr)pCertContext.Target); pCertContext.Free(); } }</span></span></code> </pre></div></div><br><p>  Por conveni√™ncia, o processo de forma√ß√£o de uma estrutura com par√¢metros foi movido para um m√©todo separado (GetStdSignVerifyPar).  Depois disso, a pr√≥pria assinatura √© verificada e o primeiro signat√°rio √© extra√≠do (para o bem, seria necess√°rio extrair tudo, mas uma assinatura contendo v√°rios signat√°rios ainda √© ex√≥tica). </p><br><p>  Ap√≥s extrair o certificado do assinante, o converteremos em nossa classe e o verificaremos (se especificado nos par√¢metros do m√©todo).  Para verifica√ß√£o, √© usada a data de assinatura do primeiro signat√°rio (consulte a se√ß√£o sobre extra√ß√£o de informa√ß√µes da assinatura e a se√ß√£o sobre verifica√ß√£o de certificado). </p><br><h2>  Extrair informa√ß√µes de assinatura </h2><br><p>  Geralmente, os sistemas criptogr√°ficos exigem uma representa√ß√£o impressa da assinatura.  Em cada caso, √© diferente, portanto, √© melhor criar uma classe de informa√ß√µes sobre a assinatura, que conter√° informa√ß√µes de uma forma conveniente para uso e, com sua ajuda, fornecer√° uma apresenta√ß√£o impressa.  No .Net existe essa classe - o SignedCms, no entanto, seu anal√≥gico em mono com as assinaturas do CritiPro pro se recusa a trabalhar no primeiro, em segundo lugar, cont√©m o modificador selado e, em terceiro lugar, quase todas as suas propriedades s√£o protegidas contra grava√ß√£o, ent√£o voc√™ ter√° que criar seu pr√≥prio anal√≥gico. </p><br><p>  A assinatura em si cont√©m dois elementos principais - uma lista de certificados e uma lista de signat√°rios.  A lista de certificados pode estar vazia ou pode conter todos os certificados para verifica√ß√£o, incluindo cadeias completas.  A lista de signat√°rios indica o n√∫mero de assinaturas reais.  A comunica√ß√£o entre eles √© realizada por n√∫mero de s√©rie e editor (emissor).  Teoricamente, em uma assinatura, pode haver dois certificados de diferentes editores com o mesmo n√∫mero de s√©rie, mas, na pr√°tica, isso pode ser negligenciado e pesquisado apenas pelo n√∫mero de s√©rie. </p><br><p>  A leitura da assinatura √© a seguinte: </p><br><div class="spoiler">  <b class="spoiler_title">Extrair informa√ß√µes de assinatura</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;&lt;/summary&gt; * &lt;param name="_arSign"&gt;&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Decode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arSign, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { IntPtr hMsg = IntPtr.Zero; <span class="hljs-comment"><span class="hljs-comment">// 0)   try { hMsg = UCryptoAPI.CryptMsgOpenToDecode(UCConsts.PKCS_7_OR_X509_ASN_ENCODING, UCConsts.CMSG_DETACHED_FLAG, 0, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero); if (hMsg == IntPtr.Zero) { _sError = UCConsts.S_CRYP_MSG_FORM_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } // 1)   if (!UCryptoAPI.CryptMsgUpdate(hMsg, _arSign, (uint)_arSign.Length, true)) { _sError = UCConsts.S_CRYP_MSG_SIGN_COPY_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } // 2)   (PKCS7 SignedData) uint iMessType = UCUtils.GetCryptMsgParam&lt;uint&gt;(hMsg, UCConsts.CMSG_TYPE_PARAM); if (UCConsts.CMSG_SIGNED != iMessType) { _sError = UCConsts.S_CRYP_MSG_SIGN_TYPE_ERR.Frm(iMessType, UCConsts.CMSG_SIGNED); return UConsts.E_CRYPTO_ERR; } // 3)    fpCertificates = UCUtils.GetSignCertificates(hMsg); // 4)   uint iSignerCount = UCUtils.GetCryptMsgParam&lt;uint&gt;(hMsg, UCConsts.CMSG_SIGNER_COUNT_PARAM); for (int i = 0; i &lt; iSignerCount; i++) { ISDPSignerInfo pInfo = new ISDPSignerInfo(); fpSignerInfos.Add(pInfo); int iRes = pInfo.Decode(hMsg, i, this, ref _sError); if (iRes != UConsts.S_OK) return iRes; } return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_SIGN_INFO_GEN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if(hMsg != IntPtr.Zero) UCryptoAPI.CryptMsgClose(hMsg); } }</span></span></code> </pre></div></div><br><p>  A assinatura √© analisada em v√°rios est√°gios, primeiro a estrutura da mensagem (CryptMsgOpenToDecode) √© formada e, em seguida, os dados reais da assinatura (CryptMsgUpdate) s√£o inseridos nela.  Resta verificar se essa √© uma assinatura real e primeiro obter uma lista de certificados e depois uma lista de signat√°rios.  A lista de certificados √© recuperada sequencialmente: </p><br><div class="spoiler">  <b class="spoiler_title">Obtendo uma lista de certificados</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;     &lt;/summary&gt; * &lt;param name="_hMsg"&gt;Handle &lt;/param&gt; * &lt;returns&gt; &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> X509Certificate2Collection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSignCertificates</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hMsg</span></span></span><span class="hljs-function">)</span></span> { X509Certificate2Collection certificates = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X509Certificate2Collection(); <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> iCnt = GetCryptMsgParam&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>&gt;(_hMsg, UCConsts.CMSG_CERT_COUNT_PARAM); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; iCnt; i++) { IntPtr hInfo = IntPtr.Zero; IntPtr hCert = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> iLen = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GetCryptMsgParam(_hMsg, UCConsts.CMSG_CERT_PARAM, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hInfo, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> iLen)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; hCert = UCryptoAPI.CertCreateCertificateContext(UCConsts.PKCS_7_OR_X509_ASN_ENCODING, hInfo, iLen); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hCert != IntPtr.Zero) { certificates.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ISDP_X509Cert(hCert)); hCert = IntPtr.Zero; } } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hInfo != IntPtr.Zero) Marshal.FreeHGlobal(hInfo); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hInfo != IntPtr.Zero) Marshal.FreeHGlobal(hCert); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> certificates; }</code> </pre></div></div><br><p>  Primeiro, o n√∫mero de certificados √© determinado a partir do par√¢metro CMSG_CERT_COUNT_PARAM e, em seguida, as informa√ß√µes sobre cada certificado s√£o recuperadas seq√ºencialmente.  O processo de cria√ß√£o do contexto do certificado e com base no pr√≥prio certificado conclui o processo de cria√ß√£o. </p><br><p>  Recuperar dados do assinante √© mais dif√≠cil.  Eles cont√™m uma indica√ß√£o do certificado e uma lista de par√¢metros de assinatura (por exemplo, a data da assinatura).  O processo de extra√ß√£o de dados √© o seguinte: </p><br><div class="spoiler">  <b class="spoiler_title">Recuperando informa√ß√µes do assinante</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;   &lt;/summary&gt; * &lt;param name="_hMsg"&gt;Handler &lt;/param&gt; * &lt;param name="_iIndex"&gt; &lt;/param&gt; * &lt;param name="_pSignedCms"&gt; &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Decode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hMsg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _iIndex, ISDPSignedCms _pSignedCms, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1)   uint iLen = 0; // 2)  IntPtr hInfo = IntPtr.Zero; try { if (!UCryptoAPI.CryptMsgGetParam(_hMsg, UCConsts.CMSG_SIGNER_INFO_PARAM, (uint)_iIndex, IntPtr.Zero, ref iLen)) { _sError = UCConsts.S_ERR_SIGNER_INFO_LEN.Frm(_iIndex, Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } hInfo = Marshal.AllocHGlobal((int)iLen); if (!UCryptoAPI.CryptMsgGetParam(_hMsg, UCConsts.CMSG_SIGNER_INFO_PARAM, (uint)_iIndex, hInfo, ref iLen)) { _sError = UCConsts.S_ERR_SIGNER_INFO.Frm(_iIndex, Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } CMSG_SIGNER_INFO pSignerInfo = (CMSG_SIGNER_INFO) Marshal.PtrToStructure(hInfo, typeof(CMSG_SIGNER_INFO)); // 2.1)   byte[] arSerial = new byte[pSignerInfo.SerialNumber.cbData]; Marshal.Copy(pSignerInfo.SerialNumber.pbData, arSerial, 0, arSerial.Length); X509Certificate2Collection pLocCerts = _pSignedCms.pCertificates.Find(X509FindType.FindBySerialNumber, arSerial.Reverse().ToArray().ToHex(), false); if (pLocCerts.Count != 1) { _sError = UCConsts.S_ERR_SIGNER_INFO_CERT.Frm(_iIndex); return UConsts.E_NO_CERTIFICATE; } fpCertificate = pLocCerts[0]; fpSignedAttributes = UCUtils.ReadCryptoAttrsCollection(pSignerInfo.AuthAttrs); return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_ERR_SIGNER_INFO_READ.Frm(_iIndex, E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if(hInfo != IntPtr.Zero) Marshal.FreeHGlobal(hInfo); } }</span></span></code> </pre></div></div><br><p>        ,       CMSG_SIGNER_INFO.                 .  ,       . </p><br><p>       ,     ‚Äî   (        ,     ). </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;   &lt;/summary&gt; * &lt;param name="_pAttrs"&gt; &lt;/param&gt; * &lt;returns&gt; &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> CryptographicAttributeObjectCollection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadCryptoAttrsCollection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CRYPT_ATTRIBUTES _pAttrs</span></span></span><span class="hljs-function">)</span></span> { CryptographicAttributeObjectCollection pRes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CryptographicAttributeObjectCollection(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _pAttrs.cAttr; i++) { IntPtr hAttr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntPtr((<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)_pAttrs.rgAttr + (i * Marshal.SizeOf(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CRYPT_ATTRIBUTE)))); CRYPT_ATTRIBUTE pAttr = (CRYPT_ATTRIBUTE) Marshal.PtrToStructure(hAttr, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CRYPT_ATTRIBUTE)); CryptographicAttributeObject pAttrInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CryptographicAttributeObject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Oid(pAttr.pszObjId), GetAsnEncodedDataCollection(pAttr)); pRes.Add(pAttrInfo); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pRes; }</code> </pre></div></div><br><p>        Oid ‚Äì   (     ASN.1).       : </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;      &lt;/summary&gt; * &lt;param name="_sName"&gt;&lt;/param&gt; * &lt;returns&gt; &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Pkcs9AttributeObject </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pkcs9AttributeFromOID</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (_sName) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> UCConsts.S_SIGN_DATE_OID : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pkcs9SigningTime(); <span class="hljs-comment"><span class="hljs-comment">// case UConsts.S_CONTENT_TYPE_OID : return new Pkcs9ContentType(); -&gt;&gt;  Mono  // case UConsts.S_MESS_DIGEST_OID : return new Pkcs9MessageDigest(); default: return new Pkcs9AttributeObject(); } } /**&lt;summary&gt;  ASN&lt;/summary&gt; * &lt;param name="_pAttr"&gt;&lt;/param&gt; * &lt;returns&gt;&lt;/returns&gt; * **/ internal static AsnEncodedDataCollection GetAsnEncodedDataCollection (CRYPT_ATTRIBUTE _pAttr) { AsnEncodedDataCollection pRes = new AsnEncodedDataCollection(); Oid pOid = new Oid(_pAttr.pszObjId); string sOid = pOid.Value; for (uint i = 0; i &lt; _pAttr.cValue; i++) { checked { IntPtr pAttributeBlob = new IntPtr((long)_pAttr.rgValue + (i * Marshal.SizeOf(typeof(CRYPTOAPI_BLOB)))); Pkcs9AttributeObject attribute = new Pkcs9AttributeObject(pOid, BlobToByteArray(pAttributeBlob)); Pkcs9AttributeObject customAttribute = Pkcs9AttributeFromOID(sOid); if (customAttribute != null) { customAttribute.CopyFrom(attribute); attribute = customAttribute; } pRes.Add(attribute); } } return pRes; }</span></span></code> </pre></div></div><br><p>         Pkcs9AttributeObject.   ,      mono          .       Mono       . </p><br><p>        ‚Äî        ‚Äî   SignedCms,        . </p><br><h3>  </h3><br><p>       ,   ,         .                 (,      ,       ). </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_arInput"&gt;  &lt;/param&gt; * &lt;param name="_pCert"&gt;&lt;/param&gt; * &lt;param name="_arRes"&gt;&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;   ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EncryptDataCP</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arInput, X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arRes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _arRes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)   CRYPT_ENCRYPT_MESSAGE_PARA pParams = new CRYPT_ENCRYPT_MESSAGE_PARA(); pParams.dwMsgEncodingType = UCConsts.PKCS_7_OR_X509_ASN_ENCODING; pParams.ContentEncryptionAlgorithm.pszObjId = _pCert.getEncodeAlgirtmOid(); pParams.cbSize = Marshal.SizeOf(pParams); // 1)   int iLen = 0; if (!UCryptoAPI.CryptEncryptMessage(ref pParams, 1, new IntPtr[] { _pCert.getRealHandle() }, _arInput, _arInput.Length, null, ref iLen)) { _sError = UCConsts.S_CRYPT_ENCODE_LEN_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } // 2)     _arRes = new byte[iLen]; if (!UCryptoAPI.CryptEncryptMessage(ref pParams, 1, new IntPtr[] {_pCert.getRealHandle() }, _arInput, _arInput.Length, _arRes, ref iLen)) { _sError = UCConsts.S_CRYPT_ENCODE_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_CRYPT_ENCODE_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } }</span></span></code> </pre></div></div><br><p>       ‚Äî  ,     .     , ,      . </p><br><p>       ,              ,    . </p><br><p>      .     ,            (    ).        : </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; OID   &lt;/summary&gt; * &lt;param name="_hCertHandle"&gt; &lt;/param&gt; * &lt;param name="_sOID"&gt;  OID&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEncodeAlgoritmOID</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hCertHandle, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sOID, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> fNeedRelease = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; _sOID = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> iKeySpec = <span class="hljs-number"><span class="hljs-number">0</span></span>; IntPtr hCrypto = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)    if (!UCryptoAPI.CryptAcquireCertificatePrivateKey(_hCertHandle, 0, IntPtr.Zero, ref hCrypto, ref iKeySpec, ref fNeedRelease)) { _sError = UCConsts.S_CRYPTO_PROV_INIT_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } uint iLen = 1000; byte[] arData = new byte[1000]; uint iFlag = 1; //  // 1)      while (UCryptoAPI.CryptGetProvParam(hCrypto, UCConsts.PP_ENUMALGS, arData, ref iLen, iFlag)){ iFlag = 2; //  PROV_ENUMALGS pInfo = ConvertBytesToStruct&lt;PROV_ENUMALGS&gt;(arData); // 2)   OID     byte[] arDataAlg = BitConverter.GetBytes(pInfo.aiAlgid); IntPtr hDataAlg = Marshal.AllocHGlobal(arDataAlg.Length); try { Marshal.Copy(arDataAlg, 0, hDataAlg, arDataAlg.Length); IntPtr hHashAlgInfo2 = UCryptoAPI.CryptFindOIDInfo(UCConsts.CRYPT_OID_INFO_ALGID_KEY, hDataAlg, UCConsts.CRYPT_ENCRYPT_ALG_OID_GROUP_ID); // 2.1)  -  if (hHashAlgInfo2 != IntPtr.Zero) { CRYPT_OID_INFO pHashAlgInfo2 = (CRYPT_OID_INFO)Marshal.PtrToStructure(hHashAlgInfo2, typeof(CRYPT_OID_INFO)); _sOID = pHashAlgInfo2.pszOID ; return UConsts.S_OK; } } finally { Marshal.FreeHGlobal(hDataAlg); } } // 3)   -  _sError = UCConsts.S_NO_ENCODE_ALG_ERR; return UConsts.E_CRYPTO_ERR; } catch (Exception E) { _sError = UCConsts.S_DETERM_ENCODE_ALG_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; }finally { if((hCrypto != IntPtr.Zero) &amp;&amp; fNeedRelease) UCryptoAPI.CryptReleaseContext(hCrypto, 0); } }</span></span></code> </pre></div></div><br><p>             .        ( , , ,   .),      .          (UCConsts.CRYPT_ENCRYPT_ALG_OID_GROUP_ID).     ‚Äî    . </p><br><p>               (    ). </p><br><h3>  </h3><br><p>  ,   ,               .        .       ‚Äî  ,      : </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_arInput"&gt;  &lt;/param&gt; * &lt;param name="_arRes"&gt;&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_pCert"&gt;&lt;/param&gt; * &lt;returns&gt;  ,  UCOnsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecryptDataCP</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arInput, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arRes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _arRes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; _pCert = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; IntPtr hSysStore = UCryptoAPI.CertOpenSystemStore(IntPtr.Zero, UCConsts.AR_CRYPTO_STORE_NAME[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)StoreName.My]); GCHandle GC = GCHandle.Alloc(hSysStore, GCHandleType.Pinned); IntPtr hOutCertL = IntPtr.Zero; IntPtr hOutCert = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)   CRYPT_DECRYPT_MESSAGE_PARA pParams = new CRYPT_DECRYPT_MESSAGE_PARA(); pParams.dwMsgAndCertEncodingType = UCConsts.PKCS_7_OR_X509_ASN_ENCODING; pParams.cCertStore = 1; pParams.rghCertStore = GC.AddrOfPinnedObject(); pParams.cbSize = Marshal.SizeOf(pParams); int iLen = 0; // 1)     if (!UCryptoAPI.CryptDecryptMessage(ref pParams, _arInput, _arInput.Length, null, ref iLen, ref hOutCertL)) { _sError = UCConsts.S_DECRYPT_LEN_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } // 2)    _arRes = new byte[iLen]; if (!UCryptoAPI.CryptDecryptMessage(ref pParams, _arInput, _arInput.Length, _arRes, ref iLen, ref hOutCert)) { _sError = UCConsts.S_DECRYPT_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } // 3)     if (hOutCert != IntPtr.Zero) _pCert = new ISDP_X509Cert(hOutCert); if(_pCert != null) hOutCert = IntPtr.Zero; //    return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_DECRYPT_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if (hOutCertL != IntPtr.Zero) UCryptoAPI.CertFreeCertificateContext(hOutCertL); if (hOutCert != IntPtr.Zero) UCryptoAPI.CertFreeCertificateContext(hOutCert); GC.Free(); UCryptoAPI.CertCloseStore(hSysStore, 0); } }</span></span></code> </pre></div></div><br><p>     ,          .         ,    ( Linux    ). </p><br><h3>   </h3><br><p>      ,         ,  ,       ,      .          ,   .       : </p><br><ol><li>   ( ,    ,  . .); </li><li>    ‚Äî       ; </li><li>     ‚Äî         ; <br></li><li>     ,  ,         (CRL); </li></ol><br><p>        ,       . </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como j√° ficou claro na introdu√ß√£o, verificar a validade do certificado √© uma das tarefas mais dif√≠ceis. </font><font style="vertical-align: inherit;">√â por isso que a biblioteca possui muitos m√©todos para implementar cada um dos itens individualmente. </font><font style="vertical-align: inherit;">Portanto, para simplificar, recorremos √†s fontes .Net do m√©todo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X509Certificate2.Verify ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e as tomamos como base.</font></font></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A verifica√ß√£o consiste em dois est√°gios: </font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> formar uma cadeia de certificados at√© a raiz; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verifique cada um dos certificados nele (revoga√ß√£o, hor√°rio etc.); </font></font></li></ol><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa verifica√ß√£o deve ser realizada antes da assinatura e criptografia na data atual e no momento da verifica√ß√£o da assinatura na data da assinatura. </font><font style="vertical-align: inherit;">O pr√≥prio m√©todo de verifica√ß√£o √© pequeno:</font></font></p><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verifica√ß√£o de certificado</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_iRevFlag"&gt; &lt;/param&gt; * &lt;param name="_iRevMode"&gt; &lt;/param&gt; * &lt;param name="_hPolicy"&gt;   &lt;/param&gt; * &lt;param name="_hCert"&gt; &lt;/param&gt; * &lt;param name="_iCTLTimeout"&gt;   &lt;/param&gt; * &lt;param name="_rOnDate"&gt; &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VerifyCertificate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hCert, X509RevocationMode _iRevMode, X509RevocationFlag _iRevFlag, DateTime _rOnDate, TimeSpan _iCTLTimeout, IntPtr _hPolicy, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_hCert == IntPtr.Zero) { _sError = UCConsts.S_CRYPTO_CERT_CHECK_ERR; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UConsts.E_NO_CERTIFICATE; } CERT_CHAIN_POLICY_PARA pPolicyParam = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CERT_CHAIN_POLICY_PARA(Marshal.SizeOf(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CERT_CHAIN_POLICY_PARA))); CERT_CHAIN_POLICY_STATUS pPolicyStatus = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CERT_CHAIN_POLICY_STATUS(Marshal.SizeOf(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CERT_CHAIN_POLICY_STATUS))); <span class="hljs-comment"><span class="hljs-comment">// 1)   IntPtr hChain = IntPtr.Zero; try { int iRes = BuildChain(new IntPtr(UCConsts.HCCE_CURRENT_USER), _hCert, __iRevMode, _iRevFlag, _rOnDate, _iCTLTimeout, ref hChain, ref _sError); if (iRes != UConsts.S_OK) return iRes; // 2)   if (UCryptoAPI.CertVerifyCertificateChainPolicy(_hPolicy, hChain, ref pPolicyParam, ref pPolicyStatus)) { if (pPolicyStatus.dwError != 0) { _sError = UCConsts.S_CRYPTO_CHAIN_CHECK_ERR.Frm(pPolicyStatus.dwError); return UConsts.E_CRYPTO_ERR; } } else{ _sError = UCConsts.S_CRYPTO_CHAIN_CHECK_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_CRYPTO_CERT_VERIFY_GEN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if(hChain != IntPtr.Zero) UCryptoAPI.CertFreeCertificateChain(hChain); } }</span></span></code> </pre></div></div><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, uma cadeia √© formada usando o m√©todo BuildChain e, em seguida, √© verificada. </font><font style="vertical-align: inherit;">Durante a forma√ß√£o da cadeia, a estrutura dos par√¢metros, a data da verifica√ß√£o e os sinalizadores de verifica√ß√£o s√£o formados:</font></font></p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;    &lt;/summary&gt; * &lt;param name="_hChain"&gt;  &lt;/param&gt; * &lt;param name="_iRevFlag"&gt; &lt;/param&gt; * &lt;param name="_iRevMode"&gt; &lt;/param&gt; * &lt;param name="_hChainEngine"&gt; &lt;/param&gt; * &lt;param name="_hCert"&gt; &lt;/param&gt; * &lt;param name="_rCTLTimeOut"&gt;   &lt;/param&gt; * &lt;param name="_rOnDate"&gt; &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuildChain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hChainEngine, IntPtr _hCert, X509RevocationMode _iRevMode, X509RevocationFlag _iRevFlag, DateTime _rOnDate, TimeSpan _rCTLTimeOut, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntPtr _hChain, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)    if (_hCert == IntPtr.Zero) { _sError = UCConsts.S_CRYPTO_CERT_CHAIN_ERR; return UConsts.E_NO_CERTIFICATE; } // 1)  CERT_CHAIN_PARA pChainParams = new CERT_CHAIN_PARA(); pChainParams.cbSize = (uint) Marshal.SizeOf(pChainParams); IntPtr hAppPolicy = IntPtr.Zero; IntPtr hCertPolicy = IntPtr.Zero; try { // 2)    pChainParams.dwUrlRetrievalTimeout = (uint)Math.Floor(_rCTLTimeOut.TotalMilliseconds); // 3)   FILETIME pVerifyTime = new FILETIME(_rOnDate.ToFileTime()); // 4)   uint _iFlags = MapRevocationFlags(_iRevMode, _iRevFlag); // 5)   if (!UCryptoAPI.CertGetCertificateChain(_hChainEngine, _hCert, ref pVerifyTime, IntPtr.Zero, ref pChainParams, _iFlags, IntPtr.Zero, ref _hChain)) { _sError = UCConsts.S_CRYPTO_CHAIN_BUILD_ERR.Frm(Marshal.GetLastWin32Error()); return UConsts.E_CRYPTO_ERR; } } catch(Exception E) { _sError = UCConsts.S_CRYPTO_CHAIN_GEN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { Marshal.FreeHGlobal(hAppPolicy); Marshal.FreeHGlobal(hCertPolicy); } return UConsts.S_OK; }</span></span></code> </pre></div></div><br><p>          ,    Microsoft.  hCertPolicy  hAppPolicy   OID-,    ,     .   ,  ,     . </p><br><p>            (,   ). </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MapRevocationFlags</a> ‚Äî      .Net   ‚Äî   uint    . </p><br><h3>  Conclus√£o </h3><br><p>               : </p><br><ol><li>  10 ; </li><li>  ; </li><li>  byte[] {1, 2, 3, 4, 5}; </li><li>   ; </li><li>   ; </li><li>  byte[] {1, 2, 3, 4, 5}; </li><li>   ; </li></ol><br><p>      Windows   Linux  1-, 10-  50- ,     Linux    .   Linux     -   -  (   ,    ),   ¬´¬ª .       (deadlock-)   (             ¬´Access Violation¬ª). </p><br><p>           UCryptoAPI    .     fpCPSection  object        : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> fpCPSection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); <span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_hCryptMsg"&gt;  &lt;/param&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CryptMsgClose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hCryptMsg</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (pCPSection) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fIsLinux) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LCryptoAPI.CryptMsgClose(_hCryptMsg); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WCryptoAPI.CryptMsgClose(_hCryptMsg); } } <span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;     &lt;/summary&gt;**/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> pCPSection { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fpCPSection;} }</code> </pre><br><p>   ,         Linux- . </p><br><p>         mono     Issuer  Subject . , ,    mono   X500DistinguishedName    .  , mono      (     ),           (impl.issuerName  impl.subjectName).         (Reflection)      X500DistinguishedName,       CERT_CONTEXT . </p><br><h2>  Refer√™ncias </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>  CAPILite </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> c      # </li><li>  .Net: <br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CAPIBase</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">X509Certificate2</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SignedCMS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SignerInfo</a> </li></ol><br></li><li>  mono: <br><ol><li>  <a href="">X509Certificate2</a> </li><li>  <a href="">X509CertificateImplBtls</a> </li></ol><br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt423163/">https://habr.com/ru/post/pt423163/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt423153/index.html">Guia do Node.js, parte 2: JavaScript, V8, alguns truques de desenvolvimento</a></li>
<li><a href="../pt423155/index.html">Curso MIT "Seguran√ßa de sistemas de computadores". Aula 8: Modelo de Seguran√ßa de Rede, Parte 2</a></li>
<li><a href="../pt423157/index.html">Usando a fun√ß√£o connect () do react-redux</a></li>
<li><a href="../pt423159/index.html">Feliz dia do programador! Ame seus desenvolvedores</a></li>
<li><a href="../pt423161/index.html">As empresas querem dados pessoais</a></li>
<li><a href="../pt423165/index.html">Desenho de malha din√¢mica no Unreal Engine 4</a></li>
<li><a href="../pt423167/index.html">O que Mark Zuckerberg fala sobre quest√µes do Facebook. Artigo essencial do The New Yorker</a></li>
<li><a href="../pt423169/index.html">Inicializa√ß√£o do dia (julho a agosto de 2018)</a></li>
<li><a href="../pt423171/index.html">Como o Discord serve simultaneamente 2,5 milh√µes de bate-papos por voz usando o WebRTC</a></li>
<li><a href="../pt423173/index.html">Tempo m√≠nimo - dor m√°xima</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>