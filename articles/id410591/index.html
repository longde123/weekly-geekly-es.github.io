<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’¸ ğŸ“ â›…ï¸ Sejarah emosional prosesor untuk komputer pertama dari 70-an hingga awal 90-an ğŸ» ğŸŒ¶ï¸ ğŸ‚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya kebetulan memprogram perakit prosesor yang berbeda. Terakhir dalam daftar adalah Xilinx MicroBlaze. Saya memutuskan untuk memposting beberapa pen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sejarah emosional prosesor untuk komputer pertama dari 70-an hingga awal 90-an</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/410591/">  Saya kebetulan memprogram perakit prosesor yang berbeda.  Terakhir dalam daftar adalah Xilinx MicroBlaze.  Saya memutuskan untuk memposting beberapa pengamatan saya pada fitur-fitur besi yang hampir ajaib ini, yang, seperti kunci ajaib Pinocchio, membuka pintu bagi kami di tanah ajaib dari realitas virtual dan kreativitas massa.  Tentang fitur sistem modern x86, x86-64, ARM, ARM-64, dll.  Saya tidak akan menulis, mungkin lain kali - topiknya sangat besar dan kompleks.  Oleh karena itu, saya berencana untuk menyelesaikan dengan Intel 80486 dan Motorola 68040. Saya juga ingin menyertakan IBM / 370 yang saya hadapi.  Sistem ini cukup jauh dari massa pengguna, tetapi pada saat yang sama memiliki dampak besar pada teknologi komputer.  Mereka hanya tidak memiliki cukup waktu yang dialokasikan untuk topik ini, mereka tidak menggunakan chip prosesor, dan untuk beberapa alasan mereka sendiri tampaknya benar-benar hilang.  Saya sangat berharap bahwa materi saya akan menarik perhatian para pecinta yang dapat menambahkan sesuatu yang mereka tidak pikirkan atau tidak tahu. <br><br>  Sebagai bahan ilustrasi, saya melampirkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">batu</a> kecil saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">dari Rosetta</a> - program untuk menghitung angka Ï€ pada prosesor dan sistem yang berbeda menggunakan algoritma rana, mengklaim sebagai yang tercepat dari implementasinya. <br><br><a name="habracut"></a><br><h2>  Intel 8080 dan 8085 </h2><br>  Prosesor nyata pertama pada sebuah chip, dibuat pada paruh pertama tahun 1974, masih diproduksi dan digunakan.  Di-kloning berkali-kali di seluruh dunia, di USSR ia memiliki sebutan KR580VM80A.  Prosesor Intel modern untuk PC masih dengan mudah mengungkapkan afinitas mereka terhadap produk peninggalan ini dalam arti tertentu.  Saya sendiri tidak menulis kode untuk prosesor ini, tetapi karena terbiasa dengan arsitektur z80, saya akan berani membawa beberapa komentar saya. <br><br>  Sistem instruksi 8080, seperti prosesor Intel lainnya untuk PC, hampir tidak bisa disebut ideal, tetapi universal, cukup fleksibel dan memiliki beberapa fitur yang sangat menarik.  Dari para pesaingnya, Motorola 6800 dan MOS Technology 6502, 8080 berbeda dalam jumlah besar walaupun registernya agak canggung, memberikan kepada pengguna satu baterai 8-bit A, satu akumulator semi-16 16-bit dan register indeks HL cepat paruh waktu, penunjuk tumpukan SP 16-bit, penunjuk tumpukan SP 16-bit , serta dua lagi register 16-bit, Sun dan DE.  Register BC, DE, dan HL dapat digunakan sebagai register 6 byte.  Selain itu, 8080 memiliki dukungan untuk hampir semua bendera status: carry, sign, zero, dan bahkan parity dan semi-transfer.  Beberapa instruksi dari set instruksi 8080 telah lama menjadi juara kecepatan.  Sebagai contoh, perintah XCHG menukar isi register DE dan HL 16-bit hanya dalam 4 siklus clock - itu sangat cepat!  Sejumlah tim lain, meskipun mereka tidak membuat catatan jelas seperti itu, juga di antara yang terbaik untuk waktu yang lama: <br><br><ul><li>  XTHL - bertukar isi register HL dan data di atas tumpukan, siklus 18 jam - tampaknya banyak, bahkan pada 16-bit 8086 nyata perintah seperti itu membutuhkan 22 siklus clock, dan untuk 6800 atau 6502 bahkan sulit membayangkan perintah seperti itu; </li><li>  AYAH - menambah HL semi-akumulator nilai register 16-bit lain (BC, DE atau bahkan SP), 10 clock cycle.  Ini adalah tambahan nyata 16-bit dengan mengatur flag carry.  Jika Anda menambahkan HL dengan diri Anda sendiri, Anda akan mendapatkan shift kiri 16-bit yang cepat atau multiplikasi 2 kali lipat, operasi utama untuk perkalian dan pembagian penuh; </li><li>  PUSH dan POP - taruh di tumpukan dan hapus dari nilai tumpukan 16-bit, masing-masing, dari register atau ke dalam register.  Dilakukan dalam 11 dan 10 siklus.  Ini adalah operasi tercepat 8080 untuk bekerja dengan memori dan pada kinerjanya ada peningkatan otomatis atau penurunan SP.  PUSH dapat digunakan, misalnya, untuk dengan cepat mengisi memori dengan pola dengan nilai dari 3 register (BC, DE, HL).  Tidak ada perintah untuk bekerja dengan jumlah 8-bit dengan tumpukan sama sekali; </li><li>  LXI - memuat konstanta 16-bit ke register (HL, DE, BC, SP) selama 10 siklus clock; </li><li>  RNZ, RZ, RNC, RC, RPO, RPE, RP, RM - pengembalian bersyarat dari subrutin, diizinkan untuk membuat kode lebih bersih, menghilangkan kebutuhan untuk menulis cabang kondisional tambahan.  Tim-tim ini ditinggalkan dalam arsitektur x86, ada kemungkinan bahwa sia-sia, kode dengan itu ternyata lebih bagus. </li></ul><br>  Prosesor ini digunakan di komputer pribadi Altair 8800 pertama, yang menjadi sangat populer setelah penerbitan majalah pada awal 1975. Ngomong-ngomong, di USSR publikasi serupa hanya terjadi pada 1980, dan relevansinya yang sesuai hanya pada 1986. <br><br><img src="https://img.newatlas.com/altair-8800-clone-0.jpg?auto=format%2Ccompress&amp;fit=max&amp;h=670&amp;q=60&amp;w=1000&amp;s=a0b62f09568803467c43a40736f5f4df" align="left"><br>  <i>Pertama hampir pc</i> <i><br></i> <br>  Intel 8080 menjadi dasar untuk pengembangan sistem operasi CP / M profesional massal yang pertama kali, yang mendominasi mikrokomputer untuk pekerjaan profesional hingga pertengahan 1980-an. <br><br>  Sekarang tentang kekurangannya.  8080 membutuhkan tiga suplai tegangan -5, 5 dan 12 volt.  Bekerja dengan interupsi canggung dan lambat.  Dan secara umum, 8080 agak tidak tergesa-gesa, jika kita membandingkannya dengan pesaing yang segera muncul.  6502 bisa menjadi 3 kali lebih cepat saat beroperasi pada frekuensi yang sama dengan 8080. <br><br>  Namun dalam arsitektur 8080, ternyata menjadi visi yang benar tentang masa depan, yaitu fakta yang tidak diketahui di tahun 70-an bahwa prosesor akan lebih cepat daripada memori.  Register 8080 DE dan BC lebih seperti prototipe cache yang dioperasikan dengan tangan modern daripada register tujuan umum.  The 8080 dimulai dengan frekuensi 2 MHz, dan pesaing dengan hanya 1, yang memuluskan perbedaan kinerja. <br><br>  Sulit untuk menyebut 8080 prosesor 8-bit pada 100%.  Tentu saja, ia memiliki ALU 8-bit, tetapi ada banyak instruksi 16-bit yang lebih cepat daripada hanya menggunakan analog 8-bit.  Dan untuk beberapa tim tidak ada analog 8-bit sama sekali.  Intinya dan tim XCHG 100% 16-bit.  Ada register 16-bit nyata.  Oleh karena itu, saya berani menelepon 8080 sebagian 16-bit.  Akan menarik untuk menghitung indeks kapasitas prosesor dari total tanda, tetapi sejauh yang penulis tahu, belum ada yang melakukan pekerjaan seperti itu. <br><br>  Penulis tidak tahu alasan mengapa Intel menolak dukungan langsung untuk pengembangan PC 8-bit dengan prosesornya.  Intel selalu dibedakan oleh kompleksitas dan ambiguitas politik.  Hubungannya dengan politik, khususnya, diilustrasikan oleh fakta bahwa untuk waktu yang lama Intel mengoperasikan pabrik-pabrik di Israel dan sampai akhir tahun 90an itu adalah rahasia.  Secara praktis Intel tidak berusaha memperbaiki 8080, frekuensi clock hanya dinaikkan menjadi 3 dengan MHz kecil.  Bahkan, pasar 8-bit ditransfer ke Zilog dengan prosesor 8080 z80 terkait, yang mampu cukup berhasil menghadapi pesaing utama, "terminator" 6502. <br><br>  Di Uni Soviet dan Rusia, klon domestik 8080 menjadi basis dari banyak komputer massal yang tetap populer hingga awal 90-an.  Ini, tentu saja, adalah Radio-86RK, Mikrosh, multi-warna Orion-128, Vector dan Corvette.  Namun, klon berbasis zX Spectrum z80 yang murah dan ditingkatkan mengalahkan Clone Wars. <br><br><img src="https://www.old-games.ru/forum/attachments/d64acd00877a00143c992eeffc16e35d-jpg.75531/"><br>  <i>Ini adalah PC asli.</i> <br><br>  Pada awal 1976, Intel memperkenalkan prosesor 8085, kompatibel dengan 8080, tetapi jauh lebih unggul dari pendahulunya.  Itu sudah membuat catu daya -5 dan 12 volt tidak perlu dan diagram koneksi disederhanakan, bekerja dengan interupsi ditingkatkan, frekuensi clock digunakan dari 3 menjadi sangat padat 6 MHz, sistem perintah diperluas dengan beberapa instruksi yang berguna: pengurangan 16-bit, perpindahan 16-bit ke kanan hanya dalam 7 siklus (ini sangat cepat), rotasi 16-bit ke kiri melalui bendera transfer, memuat register 16-bit dengan offset 8-bit (perintah ini juga dapat digunakan dengan penunjuk tumpukan SP), tulis register HL ke alamat pada register DE mirip dengan h  HL mengalir melalui DE.  Semua instruksi di atas, kecuali untuk bergeser ke kanan, dilakukan dalam 10 siklus - ini kadang-kadang secara signifikan lebih cepat daripada rekan-rekan mereka atau emulasi pada z80.  Beberapa instruksi ditambahkan, dan bahkan dua bendera bendera baru.  Di antara flag-flag baru, perlu dicatat flag overflow, meskipun bekerja dengannya ternyata tidak didukung.  Selain itu, banyak instruksi untuk bekerja dengan data byte dipercepat sesuai irama.  Ini sangat signifikan, karena pada banyak sistem dengan 8080 atau z80, tick ticks diperkenalkan, yang, karena adanya tick tambahan pada 8080, dapat memperpanjang waktu eksekusi hampir dua kali lipat.  Sebagai contoh, di komputer domestik, instruksi vektor dari tipe register-register dieksekusi selama 8 clock cycle, dan jika ada 8085 atau z80 di sana, maka instruksi yang sama ini akan dieksekusi hanya dalam 4 siklus clock.  Instruksi XTHL bahkan dua langkah lebih cepat.  Dengan instruksi baru, Anda dapat menulis kode untuk menyalin blok memori, yang lebih cepat daripada perintah LDI / LDD dari prosesor Z80!  Namun, beberapa instruksi, misalnya, kenaikan dan penurunan 16-bit, PUSH dan pengembalian bersyarat menjadi lebih lambat per jam. <br><br>  8085 memiliki dukungan bawaan untuk bekerja dengan interupsi, yang dalam banyak kasus memungkinkan Anda melakukannya tanpa pengontrol interupsi terpisah dalam sistem, dan port input / output serial.  Seperti yang telah dicatat, pada 8085 mereka tidak menambahkan dukungan penuh untuk bendera melimpah, sehingga aritmatika angka dengan tanda tetap agak tidak lengkap. <br><br>  Namun, saya dapat kembali mengulangi rumus "untuk alasan yang tidak diketahui oleh penulis" Intel menolak untuk mempromosikan 8085 sebagai prosesor utama.  Hanya pada tahun 80-an muncul beberapa sistem berbasis 8085 yang agak berhasil muncul, yang pertama pada tahun 1981 adalah pendahulu dan hampir saingan dari PC IBM - IBM System / 23 Datamaster.  Kemudian pada tahun 1982 komputer yang sangat cepat dengan grafis yang sangat baik Zenith Z-100 dirilis, di mana 8085 bekerja pada 5 MHz.  Pada tahun 1983, perusahaan Jepang Kyotronic menciptakan bantalan lutut KC-85 yang sangat sukses, varian di antaranya juga diproduksi oleh perusahaan lain: Tandy memproduksi TRS-80 model 100, NEC - PC-8201a, Olivetti - M-10.  Secara total, lebih dari 10 juta salinan komputer tersebut dirilis!  Dalam USSR / RF di awal 90-an, berdasarkan klon domestik IM1821VM85A, ada upaya untuk meningkatkan beberapa sistem, misalnya, komputer Vector.  Yang mengejutkan, prosesor utama rover Sojourner, yang mencapai permukaan Mars pada tahun 1997, adalah 8085 dengan frekuensi 2 MHz! <br><br>  Bahkan, Intel memberi z80 warna hijau.  Beberapa tahun kemudian, dalam pertempuran untuk pasar 16-bit, Intel berperilaku sangat berbeda, memulai gugatan untuk melarang penjualan prosesor v20 dan v30 di Amerika Serikat.  Menariknya, prosesor yang disebutkan dari perusahaan Jepang NEC dapat beralih ke mode kompatibilitas biner penuh dengan 8080, yang menjadikan mereka prosesor tercepat dari arsitektur 8080. <br><br>  Rahasia lain dari Intel adalah penolakan untuk menerbitkan sistem perintah yang diperluas, termasuk dukungan untuk bendera baru.  Namun, salah satu produsen resmi prosesor ini telah menerbitkan seluruh sistem tim.  Apa alasan penolakan aneh itu?  Orang hanya bisa menebak.  Mungkin Zilog kemudian memainkan peran yang mirip dengan apa yang pernah dimainkan AMD, dan menciptakan tampilan kompetisi, dan 8085 dapat menurunkan Zilog?  Mungkin intinya adalah keinginan untuk menjaga sistem perintah lebih dekat dengan yang dirancang 8086?  Yang terakhir ini tampaknya meragukan.  Intel 8086 dirilis lebih dari 2 tahun setelah rilis 8085 dan sulit untuk percaya bahwa pada tahun 1975 sistem komandonya sudah dikenal.  Dan dalam hal apa pun, kompatibilitas dengan 8080 dan 8085 hingga 8086 hanya dapat dicapai dengan menggunakan prosesor makro, terkadang mengganti satu perintah 8080/8085 dengan beberapa perintahnya sendiri.  Selain itu, dua instruksi baru yang diterbitkan 8085 di 8086 tidak layak sama sekali.  Sangat sulit untuk menjelaskan mengapa Intel tidak mempublikasikan informasi tentang tim baru setelah rilis 8086. Kami hanya dapat berasumsi bahwa itu kemungkinan besar adalah masalah pemasaran.  Secara artifisial memperburuk spesifikasi 8085, kami mendapat 8086 lebih spektakuler dengan latar belakang ini. <br><br><h2>  Motorola 6800 dan kerabat dekat </h2><br>  Prosesor Motorola selalu dibedakan dengan kehadiran beberapa "highlight" yang sangat menarik sementara pada saat yang sama kehadiran beberapa solusi arsitektur yang absurd dalam abstrak dan kepraktisan yang rendah.  "Sorotan" utama dari semua prosesor yang dimaksud adalah baterai register kedua yang penuh dan sangat cepat. <br><br>  The 6800 adalah prosesor pertama di dunia yang hanya membutuhkan satu sumber daya (5 volt) - itu adalah inovasi yang sangat berguna.  Karena keunikan dari register indeks 16-bit, yang rumit untuk arsitektur 8-bit, Ho 6800 ternyata tidak nyaman untuk pemrograman dan digunakan oleh produk.  Ini dirilis kembali pada tahun 1974, tidak lebih dari 8080, tetapi tidak pernah menjadi dasar untuk sistem komputer yang terkenal.  Yang menarik, 6502 pengembang, Chuck Peddle dan Bill Mensch, menyebut 6800 salah, "terlalu besar."  Namun, ia dan variannya banyak digunakan sebagai mikrokontroler.  Mungkin perlu dicatat bahwa Intel telah memproduksi prosesor sejak tahun 1971, yang menempatkan Motorola pada posisi yang menarik, di mana 6800 adalah prosesor pertama.  Dan jika Anda membandingkan 6800 bukan dengan 8080, tetapi dengan pendahulunya 8008, maka 6800 akan jauh lebih disukai.  Motorola hampir menyusul Intel dengan 68000/20/30/40.  Anda mungkin juga memperhatikan bahwa di tahun 70-an, Motorola adalah perusahaan yang jauh lebih besar daripada Intel. <br><br>  Berbagai varian 6800 juga diproduksi: 6801, 6802, 6803, 6805, ... Sebagian besar dari mereka adalah mikrokontroler dengan memori yang terpasang dan port input / output.  6803 adalah 6801 yang disederhanakan dan digunakan pada akhir (1983) untuk komputer kelasnya Tandy TRS-80 MC-10 dan klon Prancisnya Matra Alice, yang dapat dibandingkan dengan Commodore VIC-20 (1980) atau Sinclair ZX81 (1981).  Sistem instruksi 6801/6803 telah ditingkatkan secara signifikan, instruksi 16-bit, multiplikasi, telah ditambahkan ... Instruksi cabang tanpa syarat yang tidak biasa (BRN - cabang tidak pernah) telah muncul, yang tidak pernah dieksekusi!  Beberapa instruksi menjadi sedikit lebih cepat. <br><br>  680x sepenuhnya mendukung pekerjaan dengan bilangan bulat yang ditandatangani, z80 dan 6502 mendukungnya lebih buruk, sedangkan 8080 dan 8085 hampir tidak memiliki dukungan seperti itu.  Namun, dalam perangkat lunak 8-bit, dukungan seperti itu jarang diperlukan. <br><br>  6809 dirilis pada 1978, ketika era 16-bit sudah dimulai dengan 8086, dan memiliki sistem komando yang sangat maju, termasuk mengalikan baterai dua byte untuk mendapatkan hasil 16-bit dalam 11 siklus (untuk perbandingan, 8086 membutuhkan 70 siklus untuk operasi semacam itu) .  Dalam beberapa kasus, dua baterai dapat dikelompokkan menjadi satu 16-bit, yang memberikan instruksi cepat 16-bit.  6809 memiliki dua register indeks dan mencatat sejumlah metode pengalamatan di antara prosesor 8-bit - 12. Di antara metode pengalamatan ada yang unik untuk chip 8-bit, seperti indeks dengan kenaikan atau penurunan otomatis, relatif terhadap penghitung instruksi, indeks dengan offset.  6809 memiliki peluang menarik untuk menggunakan dua jenis interupsi: Anda dapat menggunakan interupsi cepat dengan penyimpanan register parsial otomatis dan interupsi dengan penyimpanan register penuh - 6809 memiliki tiga input untuk sinyal interupsi FIRQ (fast masking), IRQ (maskable), NMI (non-masking).  Terkadang juga nyaman menggunakan instruksi cepat untuk membaca dan mengatur semua flag sekaligus. <br><br>  Namun, operasi memori memerlukan lebih dari 6502 siklus clock. Register indeks tetap canggung dinosaurus 16-bit di dunia 8-bit, beberapa operasi hanya mengejutkan karena lambatnya mereka, misalnya, mentransfer baterai satu byte ke yang lain membutuhkan waktu 6 siklus, dan pertukaran isinya adalah 8 siklus (bandingkan dengan 8080, di mana pertukaran 16-bit terjadi dalam 4 siklus)!  Untuk beberapa alasan, dua penunjuk tumpukan ditawarkan segera, mungkin itu adalah pengaruh dari arsitektur deadlock VAX-11 - dalam arsitektur 8-bit dengan memori 64 KB itu terlihat sangat canggung.  Dan bahkan kehadiran instruksi dengan nama SEX yang menarik tidak dapat menyelesaikan semua masalah 6809.  Secara umum, 6809 masih agak lebih cepat dari 6502 pada frekuensi yang sama, tetapi membutuhkan kecepatan memori yang sama.  Saya berhasil melakukan pembagian untuk 6809 dengan dividen 32-bit dan pembagi 16-bit (32/16 = 32,16) untuk sedikit lebih dari 520 siklus, untuk 6502 saya tidak dapat mencapai kurang dari 650 siklus.  Baterai kedua adalah keuntungan besar, tetapi fitur lain 6502, khususnya, transfer terbalik, mengurangi keunggulan ini hanya untuk 25% yang ditunjukkan.  Tetapi perkalian dengan konstanta 16-bit ternyata lebih lambat daripada tabel satu untuk 6502 dengan tabel untuk 768 byte.  6809 memungkinkan Anda untuk menulis kode yang cukup ringkas dan cepat menggunakan pengalamatan halaman yang diinstal (halaman langsung), tetapi pengalamatan ini membuat kode agak membingungkan.  Inti dari pengalamatan ini adalah untuk mengatur byte tinggi dari alamat data dalam register khusus dan hanya menentukan byte rendah dari alamat dalam perintah.  Sistem yang sama dengan hanya nilai byte tinggi tetap digunakan di 6502, di mana ia disebut pengalamatan halaman nol.  Mengatasi halaman yang diinstal adalah analog langsung dengan menggunakan register segmen DS di x86 tidak hanya untuk segmen 64 KB, tetapi untuk segmen hanya 256 byte.  Arsitektur 6800 lainnya yang dibuat-buat adalah penggunaan byte order dari tinggi ke rendah (Big Endian), yang memperlambat operasi penambahan dan pengurangan 16-bit.  6809 tidak sepenuhnya kompatibel dengan kode instruksi 6800. 6809 adalah prosesor 8-bit terakhir dari Motorola, dalam perkembangan selanjutnya, diputuskan untuk menggunakan 68008. <br><br>  Dapat diasumsikan bahwa Motorola menghabiskan banyak uang untuk mempromosikan 6809. Ini masih benar pada saat menyebutkan prosesor ini.  Tentang 6809 ada banyak ulasan yang menguntungkan, berbeda dalam beberapa nebula, generalisasi dan ketidakjelasan.  6809 diposisikan sebagai prosesor super berbasis mikroprosesor 8-bit.  Hampir sistem operasi Unix, OS-9 dan UniFlex bahkan dibuat untuknya.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dia melolong sebagai prosesor utama untuk Apple Macintosh dan, sebagai berikut dari film-film tentang Steve Jobs, hanya intervensi emosionalnya yang menentukan transisi ke 68000 yang lebih menjanjikan. Tentu saja, 6809 adalah prosesor yang baik, tetapi secara umum hanya sedikit lebih baik daripada pesaingnya yang muncul lebih awal dari 6502. (tiga tahun sebelumnya) dan z80 (dua). Orang hanya dapat menebak apa yang akan terjadi jika Motorola menghabiskan setidaknya setengah dari upaya yang dihabiskan untuk mengembangkan dan mempromosikan 6809 untuk mengembangkan 6502.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6809 digunakan dalam beberapa sistem komputer yang cukup terkenal. Yang paling terkenal di antara mereka adalah komputer Amerika Tandy Color atau Tandy Coco, serta klon Inggris atau lebih tepatnya Welsh Dragon-32/64. Pasar komputer tahun 80-an ditandai dengan transparansi yang signifikan dan Tandy Coco didistribusikan terutama hanya di AS, dan Naga, selain Inggris sendiri, memperoleh popularitas di Spanyol. Di Prancis, 6809 karena alasan tertentu menjadi dasar untuk komputer massa tahun 80-an dari seri Thomson, yang tetap hampir tidak dikenal di tempat lain kecuali Prancis. The 6809 juga digunakan sebagai prosesor kedua dalam setidaknya dua sistem: dalam seri Commodore SuperPET 9000 dan dalam set-top box yang dijalankan dan sekarang hampir terlupakan untuk antarmuka TUBE dari komputer BBC Micro.Prosesor ini juga digunakan dalam sistem lain yang kurang dikenal oleh penulis, khususnya yang Jepang. Dia juga mendapatkan beberapa distribusi di dunia konsol game. Perlu disebutkan salah satu konsol ini, Vectrex, yang menggunakan teknologi unik - tampilan vektor.</font></font><br><br><img src="https://i.imgur.com/DOVW3CM.jpg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Color CoCo 3</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 680x memiliki instruksi tidak berdokumen yang menarik dengan nama menarik "Hentikan dan Tangkap Api" (HCF), yang digunakan untuk pengujian di tingkat elektronik, misalnya, dengan osiloskop. Penggunaannya menyebabkan prosesor membeku, dari mana dimungkinkan untuk keluar hanya dengan menyalakannya kembali (reset). Prosesor ini juga memiliki instruksi tidak berdokumen lainnya. Pada 6800 ada, misalnya, instruksi yang simetris dengan pemuatan langsung dari konstanta register, mis. instruksi untuk langsung menurunkan register ke alamat setelah instruksi ini!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti 8080, 8085 atau z80 6809, sangat sulit untuk memanggil murni 8-bit. Dan 6309 bahkan secara formal sulit untuk disebut 8-bit, itu diproduksi oleh perusahaan Jepang Toshiba (saya tidak dapat menemukan tahun yang tepat dari produksinya, tetapi ada beberapa data yang menunjukkan 1982) sebagai prosesor yang sepenuhnya kompatibel dengan 6809. Namun, prosesor ini dapat diaktifkan ke dalam mode baru, yang, sambil mempertahankan kompatibilitas hampir penuh dengan 6809, memberikan hampir urutan besarnya peluang besar. Fitur-fitur ini disembunyikan dalam dokumentasi resmi, tetapi diterbitkan pada tahun 1988 di jaringan Usenet. Dua baterai lagi ditambahkan, tetapi instruksi dengan mereka secara signifikan lebih lambat daripada dengan dua yang pertama. Waktu pelaksanaan untuk sebagian besar instruksi telah sangat berkurang. Menambahkan sejumlah tim,di antaranya pembagian simbolis dari dividen 32-bit oleh pembagi 16-bit (32/16 = 16,16) untuk 34 siklus cukup fantastis untuk prosesor kelas ini, dan pembagi diambil dari memori. Ada juga perkalian 16-bit dengan hasil 32-bit untuk siklus 28 jam. Instruksi yang sangat berguna juga ditambahkan untuk menyalin blok memori dengan cepat dengan runtime 6 + 3n, di mana n adalah jumlah byte yang akan disalin, Anda dapat menyalin dengan mengurangi atau meningkatkan alamat. Instruksi yang sama dapat digunakan untuk mengisi memori dengan cepat dengan byte yang diberikan. Ketika dieksekusi, gangguan dapat terjadi. Masih ada operasi bitwise baru, null-register, dll. Interupsi ditambahkan ketika menjalankan instruksi yang tidak diketahui dan ketika membaginya dengan 0. Dalam beberapa hal,6309 adalah puncak dari kemajuan teknologi di antara prosesor 8-bit, atau lebih tepatnya prosesor dengan ukuran memori yang dapat dialamatkan 64 KB.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6309 sepenuhnya kompatibel dengan terminal 6809, menjadikannya upgrade yang populer untuk warna Tandy atau Dragons. </font><font style="vertical-align: inherit;">Ada versi khusus OS menggunakan fitur baru 6309.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teknologi MOS 6502 dan WDC 65816 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah prosesor dengan nasib yang sangat dramatis. </font><font style="vertical-align: inherit;">Tidak ada prosesor lain yang dapat membandingkannya. </font><font style="vertical-align: inherit;">Penampilan dan implementasinya disertai dengan peristiwa dan konsekuensi berskala sangat besar. </font><font style="vertical-align: inherit;">Saya akan membuat daftar beberapa di antaranya:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> melemahnya Motorola raksasa, yang kemampuannya selama beberapa waktu melebihi kemampuan Intel; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> penghancuran Teknologi MOS; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> penghentian pengembangan 6502 dan rilis stagnan dengan sedikit atau tanpa modernisasi. </font></font></li></ul><br>  Semuanya berawal dari fakta bahwa Motorola untuk alasan yang sama sekali tidak dikenal menolak untuk mendukung inisiatif insinyur muda yang mengusulkan untuk meningkatkan prosesor 6800 yang umumnya biasa-biasa saja. Mereka harus meninggalkan perusahaan dan melanjutkan pekerjaan mereka di perusahaan kecil tapi menjanjikan MOS Technology, di mana mereka segera menyiapkan dua prosesor 6501 dan 6502 dibuat menggunakan teknologi NMOS.  Yang pertama kompatibel dengan 6800, tetapi selain itu identik.  Tim 6501/6502 berhasil memperkenalkan teknologi pembuatan chip baru, yang secara radikal mengurangi biaya prosesor baru.  Pada tahun 1975, Teknologi MOS dapat menawarkan $ 6502 untuk $ 25, sedangkan harga awal untuk Intel 8080 dan Motorola 6800 adalah pada tahun 1974 $ 360.  Pada tahun 1975, Motorola dan Intel memotong harga, tetapi harganya masih mendekati $ 100.  Pakar Teknologi MOS mengklaim bahwa prosesor mereka hingga 4 kali lebih cepat daripada 6800. Sepertinya saya ragu: 6502 dapat bekerja dengan memori lebih cepat, tetapi baterai 6800 kedua sangat mempercepat banyak perhitungan.  Saya dapat memperkirakan bahwa rata-rata 6502 lebih cepat daripada tidak lebih dari 2 kali.  Motorola memulai gugatan terhadap mantan karyawannya - mereka diduga menggunakan banyak rahasia teknologi perusahaan.  Selama proses itu, adalah mungkin untuk menetapkan bahwa salah satu insinyur yang meninggalkan Motorola mengeluarkan beberapa dokumen rahasia pada 6800, bertindak berlawanan dengan pengaturan rekan-rekan mereka.  Apakah itu perbuatannya sendiri atau pasukan penuntun yang berdiri di belakangnya masih belum diketahui.  Untuk alasan ini dan lainnya yang tidak sepenuhnya jelas, Motorola memaksa Teknologi MOS, yang kemampuan finansialnya sangat kecil, untuk membayar sejumlah $ 200.000 dan meninggalkan produksi 6501. Intel dalam situasi yang sama dengan Zilog tidak bertindak sama sekali.  Meskipun harus diakui bahwa Teknologi MOS terkadang terlalu berisiko ketika mencoba menggunakan uang besar yang dihabiskan oleh Motorola untuk mempromosikan 6800 untuk keperluannya sendiri. <br><br>  Lebih jauh dalam cerita tersebut, perusahaan Commodore yang legendaris dan pendiri yang sama-sama legendarisnya Jack Tramiel muncul, dalam bayangan yang merupakan sosok kepala pemodal perusahaan yang menentukan kebijakannya - seorang pria bernama Irving Gould.  Jack menerima pinjaman dari Irving dan dengan uang ini, menggunakan beberapa, untuk membuatnya lebih halus, taktik yang tidak bermoral, memaksa MOS Tecchnology untuk menjadi bagian dari Commodore.  Setelah itu, mungkin bertentangan dengan keinginan Tramel, yang harus menyerah pada Hood, pengembangan 6502 praktis terhenti, meskipun pada tahun 1976 dimungkinkan untuk memproduksi prototipe 6502 dengan frekuensi operasi hingga 10 MHz, meskipun pesan tentang ini muncul hanya setelah bertahun-tahun dari seseorang. bernama Bill Mensch (dia berada di tim yang meninggalkan Motorola), yang berulang kali membuat pernyataan keras tetapi sebagian besar kosong dan memainkan peran yang agak ambigu dalam nasib 6502.  6502 kepala pengembang Chuck Peddle selamanya dihapus dari pengembangan prosesor.  6502 terus diproduksi tidak hanya di Commodore, tetapi juga di perusahaan yang dibuat oleh Bill Mensch, Western Design Center (WDC).  Sangat mengherankan bahwa tidak ada tim 6502 sebelumnya yang bekerja dengannya di masa depan. <br><br>  Drama sekitar 6502 tidak berakhir di sana.  Pada tahun 1980, sebuah artikel pendek anonim muncul di majalah Rockwell AIM65 Interactive yang menyatakan bahwa semua 6502 membawa bug berbahaya yang disebut JMP (xxFF).  Nada artikel menunjukkan sesuatu yang sama sekali tidak biasa.  Selanjutnya, sikap ini pindah ke posisi Apple tentang masalah ini dan menjadi semacam arus utama.  Meskipun, sebenarnya, tidak ada "bug".  Tentu saja, salah satu fitur, cukup tepat dan bahkan berguna di antara mikroprosesor, mungkin tampak seperti bug yang menjengkelkan bagi seorang spesialis yang terbiasa dengan prosesor nyaman dari sistem besar tahun itu.  Tetapi pada kenyataannya, perilaku ini, yang melukai perasaan seseorang, dijelaskan dalam dokumentasi resmi dari tahun 1976 dan dalam buku teks pemrograman yang muncul sebelum munculnya artikel ini.  "Bug" dihilangkan oleh Bill Mensch, yang membuat 65 6502 (CMOS 6502) seharusnya pada tahun 1983, yaitu, setelah rilis 65816. Sementara Intel, Motorola dan lainnya membuat prosesor 16-bit generasi baru, 6502 hanya ditingkatkan secara mikroskopis dan membuat sebagian buatan tidak kompatibel dengan dirinya sendiri.  Selain menghilangkan "bug", sejumlah perubahan dibuat, yang, khususnya, menyebabkan perubahan dalam pelaksanaan beberapa instruksi, yang menjadi lebih lambat per beat, tetapi pada saat yang sama dalam beberapa pengertian akademis yang dibuat-buat, mereka menjadi lebih benar.  Tetapi saya harus mengakui bahwa beberapa instruksi baru telah diharapkan dan bermanfaat.  Di sisi lain, sebagian besar instruksi baru hanya menempati ruang kode, hampir tidak menambah kemampuan 6502, yang meninggalkan lebih sedikit kode baru untuk kemungkinan peningkatan lebih lanjut.  Commodore dan Japanese Ricoh (produsen konsol game NES paling populer) tidak menerima perubahan ini.  Penulis materi ini sendiri menemukan beberapa kali masalah "bug" ini.  Tidak tahu apa-apa tentang dia, dia menulis program untuk Commodore.  Kemudian ia memindahkan salah satunya ke sistem di mana seperangkat perintah 65 commands02 digunakan.  Ketidakcocokan muncul, saya harus mengubah kode, membuat kompilasi bersyarat.  Kode untuk 6502 ternyata lebih tebal dan lambat.  Kemudian ia mengangkat masalah ini di forum 6502.org, di mana sebagian besar pesertanya berasal dari dunia Apple.  Saya bertanya apakah ada yang bisa memberikan contoh ketika "bug" yang ditunjukkan crash program.  Saya hanya menerima komentar emosional dan umum, tidak ada contoh konkret yang diajukan. <br><br><img src="https://habrastorage.org/webt/f-/8q/mv/f-8qmv2x4io6ga8qxomqg0dxqnw.png">  Bug !!! <br><br>  65C02 telah dilisensikan ke banyak perusahaan, khususnya NCR, GTE, Rockwell, Synertek dan Sanyo.  Digunakan di Apple II, dimulai dengan model IIe, meskipun banyak IIe menggunakan NMOS 6502. Varian 65C02 6512 juga digunakan dalam model BBC Micro nanti.  Atari menggunakan NMOS 6502. Selain CMOS 6502, Synertek dan Rockwell juga memproduksi NMOS 6502. Omong-omong, NMOS 6502 memiliki set instruksi sendiri yang tidak berdokumen, sifatnya yang sepenuhnya berbeda dari perintah "rahasia" 8085. Pada 6502, instruksi ini muncul sebagai efek samping dari teknologi yang digunakan, oleh karena itu kebanyakan dari mereka agak tidak berguna, tetapi beberapa, misalnya, memuat atau membongkar dua register dengan satu perintah sekaligus dan beberapa lainnya dapat membuat kode lebih cepat dan lebih kompak. <br><br>  Ada upaya lain untuk memutakhirkan 6502. Pada 1979 yang sama, sebuah artikel muncul bahwa komputer Atari bersiap untuk memproduksi prosesor 6509 (jangan dikelirukan dengan prosesor dengan nama yang sama dengan perusahaan Commodore yang muncul kemudian), yang diharapkan dapat mempercepat pelaksanaan perintah sebesar 25% dan banyak yang baru instruksi.  Tetapi karena alasan yang tidak diketahui dalam keakuratan, produksi prosesor ini tidak terjadi.  Commodore hanya melakukan peningkatan mikroskopis.  Di sana, khususnya, mereka beralih ke teknologi HMOS dan produksi core statis, yang memungkinkan untuk memperlambat prosesor.  Dari sudut pandang pemrograman, yang paling menarik adalah prosesor 6509, yang, meskipun dalam bentuk yang sangat primitif, dengan bantuan hanya dua instruksi yang dialokasikan khusus untuk tujuan ini, memungkinkan menangani memori hingga 1 MB.  Dalam Commodore 64 dan 128 yang sangat populer, terdapat 6510/8510 prosesor, dan dalam seri 264 yang kurang berhasil - 7501/8501.  Prosesor ini masing-masing hanya memiliki 6 dan 7 built-in port bit I / O, sedangkan 7501/8501 tidak mendukung interupsi yang tidak dapat kedok.  Rockwell memproduksi varian 65C02 dengan rangkaian operasi 32 bit yang diperluas (mirip dengan instruksi z80 bit), namun, sejauh yang saya tahu, prosesor tersebut tidak digunakan dalam komputer dan instruksi bit ini sendiri lebih cenderung digunakan hanya pada sistem embedded.  Omong-omong, ekstensi ini diproduksi oleh Bill Mensch. <br><br>  Adegan terakhir drama dengan partisipasi 6502 ditunjukkan dalam pencegahan komputer berbasis 6502 dengan frekuensi 2 MHz ke pasar AS pada paruh pertama tahun 80-an.  Ini memengaruhi orang asing-Inggris BBC Micro, perusahaan produksi mereka Acorn membuat banyak komputer untuk Amerika Serikat, tetapi ternyata sia-sia.  Semacam kunci bekerja dan komputer harus segera diulang ke standar Eropa.  Komputer semi-Amerika, tetapi secara resmi Kanada Commodore CBM II (1982), meskipun ada beberapa masalah (khususnya, sesuai dengan standar untuk peralatan listrik), masih diperbolehkan.  Mungkin karena fakta bahwa mereka tidak memiliki mode grafis dan bahkan teks berwarna - bahkan desain Porsche yang stylish tidak dapat mengimbangi ini.  Yang terakhir dalam daftar pecundang adalah 100% Apple Amerika III (1980) - diketahui bahwa Steve Jobs, seperti manajemen Apple pada umumnya, melakukan banyak hal untuk mencegah komputer ini terjadi.  Pekerjaan menuntut spesifikasi yang jelas mustahil, dan manajemen - tenggat waktu yang tidak realistis.  Akankah kita mengetahui motif mereka?  Apple III Plus, dirilis pada tahun 1983, berhasil menghilangkan kekurangan dari Apple III, tetapi manajemen Apple diam-diam menutup proyek pada tahun 1984 karena keengganan untuk bersaing dengan komputer Macintosh.  Hanya pada tahun 1985, ketika era teknologi 8-bit mulai pergi, Commodore 128 muncul, yang dapat menggunakan 6502 dalam salah satu modenya dengan kecepatan clock 2 MHz.  Tapi di sini juga, ternyata lebih seperti lelucon, karena mode ini praktis tidak didukung dan praktis tidak ada program untuk itu.  Hanya pada paruh kedua tahun 80-an di Amerika Serikat mulai memproduksi konsol-akselerator untuk Apple II, dan sejak tahun 1988 model Apple IIc + dengan prosesor 4 MHz.  Mengapa ini terjadi?  Mungkin karena 6502 pada 2 atau 3 MHz (dan itu sudah diproduksi pada awal tahun 80-an) pada sejumlah tugas dan khususnya dengan permainan dapat berhasil bersaing dengan sistem berbasis Intel 8088 atau Motorola 68000. Pada tahun 1991, Commodore Corporation ditutup Yang menarik, meskipun terlambat, proyek C65 berdasarkan pada prosesor 4510 dengan frekuensi 3,54 MHz.  4510 - ini adalah 6502 tercepat, dibuat hanya pada tahun 1988, itu dilakukan akhirnya disebutkan optimasi siklus sebelumnya, yang memberikan peningkatan kecepatan 25%.  Dengan demikian, prosesor di C65 mendekati kecepatan ke sistem dengan 6502 pada 4,5 MHz.  Anehnya, ini 6502 tercepat dengan serangkaian instruksi diperluas (dalam beberapa detail ekstensi ini ternyata lebih sukses daripada di 65.816) tidak pernah digunakan di mana pun sejak itu. <br><br>  C128 dan Apple III Plus memiliki unit manajemen memori (MMU), yang memungkinkan menggunakan beberapa tumpukan dan nol halaman, menangani lebih dari 64 KB memori, dll. Di C128, MMU secara artifisial dipangkas untuk bekerja dengan hanya 128 KB memori.  Untuk BBC Micro, konsol dengan 6502 pada 3 MHz (1984) dan 4 MHz (1986) diproduksi. <br><br><img src="http://www.starringthecomputer.com/snapshots/jewel_of_the_nile_cbm_ii.jpg"><br>  <i>Anti-iklan - beberapa Porsche PET di apartemen penjahat dari Pearl of the Nile (1985) - era Apple-only di Hollywood belum tiba</i> <br><br>  Sekarang beberapa kata tentang sistem instruksi 6502. Fitur utama dari prosesor ini adalah dibuat hampir secepat mungkin, dengan praktis tidak ada siklus jam tambahan, yang sangat banyak di prosesor 8080/8085 / z80 / 8088/68000.  Bahkan, itu adalah ideologi dari 6502 prosesor arsitektur RISC yang muncul kemudian dan di bawah pengaruh langsung.  Ideologi yang sama mendominasi, mulai dari 80486, dan di antara prosesor Intel.  Selain itu, 6502 bereaksi secepat mungkin terhadap gangguan, yang membuatnya sangat berguna di beberapa sistem tertanam.  6502 memiliki satu baterai dan dua register indeks, selain itu, 256 byte pertama dari memori dapat digunakan dalam perintah khusus baik sebagai memori yang lebih cepat atau sebagai set register 16-bit (yang hampir identik dalam fungsinya dengan register BC dan DE pada 8080 / z80) untuk metode pengalamatan yang cukup kuat.  Beberapa instruksi aritmatika (shift, rotasi, kenaikan dan penurunan) dapat digunakan dengan memori secara langsung, tanpa menggunakan register.  Tidak ada instruksi 16-bit - ini adalah 100% prosesor 8-bit.  Semua flag utama didukung kecuali arsitektur flag parity Intel yang khas.  Ada beberapa flag yang lebih tidak biasa dari mode ke-10 yang tidak berguna.  Prosesor Intel dan Motorola menggunakan instruksi korektif khusus untuk bekerja dengan angka desimal, dan 6502 dapat beralih ke mode 10, yang membuat keunggulan kecepatannya dengan 10 angka bahkan lebih signifikan daripada dengan yang biner.  Sangat mengesankan bahwa untuk perkalian 6502 tabel dari operan 8-bit dengan memperoleh hasil 16-bit dalam siklus kurang dari 30 jam, dengan ukuran tabel tambahan dalam 2048 byte.  Perlahan, 6502 menghasilkan operasi penyalinan massal memori - dari 14 clock cycle per byte. <br><br>  6502 dapat bekerja secara paralel dengan perangkat lain, misalnya, 6502. Lainnya sejauh yang saya tahu, sistem prosesor ganda seperti itu tidak pernah diproduksi.  Alih-alih prosesor kedua, pengontrol video biasanya digunakan, yang berbagi memori dengan 6502. <br><br>  65816 dirilis oleh WDC pada tahun 1983. Menariknya, Bill Mensch menerima spesifikasi untuk prosesor baru dari Apple.  Tentu saja, ini adalah langkah maju yang besar, tetapi jelas terlambat dan dengan kekurangan arsitektur yang hebat.  65816 tidak dianggap oleh siapa pun sebagai pesaing untuk prosesor Intel atau Motorola utama - itu sudah menjadi orang luar sekunder, yang telah diprogram untuk mengatur kehilangan posisi lebih lanjut.  65816 memiliki dua keuntungan penting - itu relatif murah dan hampir kompatibel dengan 6502. Masih sangat populer. Pada tahun-tahun berikutnya, Bill Mensch bahkan tidak mencoba untuk meningkatkan gagasannya, melakukan optimasi lingkaran, mengganti alamat halaman nol dengan alamat yang diperluas menggunakan Z register ( ini dilakukan pada 4510), untuk menambah setidaknya perkalian, ... WDC hanya meningkatkan frekuensi clock maksimum, mencapai pertengahan 90-an hingga 14 MHz (prosesor semacam itu digunakan dalam akselerator populer untuk C64 SuperCPU pada frekuensi 20 MHz).  Namun, bahkan sekarang (2019!) WDC menawarkan 65816 untuk beberapa alasan hanya pada 14 MHz yang sama.  65816 dapat menggunakan memori hingga 16 MB, tetapi metode pengalamatan yang digunakan untuk ini terlihat jauh dari optimal.  Misalnya, register indeks hanya bisa 8- atau 16-bit, tumpukan hanya dapat ditempatkan di 64 KB memori pertama, hanya di sana Anda dapat menggunakan pengalamatan singkat yang nyaman dari halaman yang diinstal (halaman langsung - generalisasi halaman nol), bekerja dengan memori di atas 64 KB relatif canggung, ... 65816 memiliki ALU 16-bit tetapi bus data 8-bit, sehingga dalam operasi aritmatika hanya sekitar 50% lebih cepat dari 6502. Namun demikian, 65816 dirilis dalam jumlah lebih dari satu miliar.  Tentu saja, sejumlah instruksi 65816 jelas melengkapi celah dalam arsitektur 6502, misalnya, instruksi untuk memori penyalinan massal selama 7 clock cycle per byte.  Anda juga dapat menambahkan bahwa 65816 menggunakan hampir semua kode instruksi (255 dari 256).  Kode yang tidak digunakan terakhir adalah untuk instruksi masa depan yang panjang yang tidak pernah muncul. <br><br>  Apple IIx, yang dalam perkembangannya Steve Wozniak mengambil bagian aktif, seharusnya menggunakan 65816, tetapi itu hanya mungkin untuk mengatur produksi prosesor ini pada tahun 1984 dan batch pertama 65816 rusak, yang menyebabkan penundaan yang berlebihan dan, akibatnya, seluruh proyek ditutup. <br><br>  Ada juga opsi 65816 65802, yang menggunakan bus alamat 16-bit dan kompatibel dengan konektor 6502. Ada peningkatan untuk Apple II berdasarkan prosesor ini, tetapi Anda bisa mendapatkan sedikit akselerasi dengan peningkatan seperti itu hanya pada program yang ditulis khusus untuk itu. <br><br>  6502 digunakan dalam sejumlah besar sistem komputer, yang paling populer di antaranya adalah Commodore 8-bit, Atari, Apple, NES.  Menariknya, 6502 digunakan sebagai pengontrol keyboard di komputer Commodore Amiga, dan dua 6502 pada 10 MHz digunakan di Apple Macintosh IIfx yang berkinerja tinggi.  Di sini orang tidak bisa tidak menyebutkan konsol game Atari, yang diproduksi dari tahun 1977 hingga 1996, - mereka terjual sekitar 35 juta!  65816 digunakan di komputer Apple IIgs yang agak populer, di konsol game Super NES, dan juga di komputer Inggris Acorn Communicator yang langka. <br><br>  Pada tahun 1984, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah artikel</a> tentang salinan buruk komputer Apple] [dibuat di USSR] muncul di majalah Byte dengan latar belakang gambar dengan spanduk merah, Lenin dan tentara berbaris.  Artikel ini mengutip harga yang aneh untuk komputer ini - $ 17.000 (ini adalah angka yang absurd, harga sebenarnya adalah sekitar 4.000 rubel) dan ironisnya menunjukkan bahwa produsen Soviet harus secara dramatis menurunkan harga jika mereka ingin menjual produk mereka di Barat.  Agate digunakan terutama dalam pendidikan sekolah.  Model Agate yang lebih tua hampir 100% kompatibel dengan Apple] [dan memiliki beberapa ekstensi yang sangat berguna. <br><br>  Anda hanya dapat mencoba membayangkan apa yang akan terjadi jika 6502 dapat berkembang pada kecepatan yang sama dengan para pesaingnya.  Tampak bagi saya bahwa transfer bertahap dari memori halaman nol ke dalam register dan ekspansi bertahap dari sistem instruksi dengan optimalisasi siklus secara simultan akan memungkinkan 6502 "terminator" tetap memimpin dalam hal kecepatan sampai awal 90-an.  Pengenalan mode 16 dan kemudian 32 bit akan memungkinkan penggunaan sejumlah besar memori dan perintah yang lebih cepat.  Bisakah para pesaingnya memiliki sesuatu untuk ditentang? <br><br>  Saya ingin mengakhiri dengan beberapa pertimbangan filosofis umum.  Mengapa 6502 direm dan tidak memiliki masa depan yang lebih cerah?  Mungkin karena fakta bahwa ia benar-benar dapat menekan perusahaan-perusahaan besar dan menciptakan kenyataan yang sama sekali baru.  Tetapi apakah tim 6502 dibentuk untuk itu?  Sebaliknya, mereka hanya ingin membuat prosesor yang lebih baik. <br><br>  Sudah lama kemudian, pada awal abad ke-21, dengan bantuan tuntutan hukum yang dipaksakan dengan alasan yang tidak masuk akal, perusahaan Lexra, yang memproduksi berbagai prosesor inovatif selama 5 tahun, dikalahkan.  Kisah sedih ini agak mengingatkan pada apa yang terjadi dengan Teknologi MOS. <br><br><h2>  Zilog z80 </h2><br>  Prosesor ini, bersama dengan 6502, menjadi prosesor utama dari komputer pribadi pertama.  Tidak ada peristiwa dramatis dalam sejarah penampilan dan penggunaannya.  Hanya ada beberapa intrik dalam kegagalan Zilog untuk membuat prosesor generasi berikutnya.  Z80 mulai berproduksi pada tahun 1976 dan variannya masih diproduksi.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suatu kali, bahkan Bill Gates sendiri mengumumkan dukungan untuk sistem berbasis z80. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sejumlah kebetulan menarik. Seperti pada kasus 6502, pengembang utama Z80, Federico Faggin (Federico Faggin), meninggalkan perusahaan besar, dari Intel. Setelah mengerjakan z80, Federico hampir tidak bekerja dengan prosesor Z8000 generasi berikutnya dan pada awal 80-an meninggalkan perusahaannya, sehingga ia tidak akan pernah berurusan dengan prosesor di masa depan. Dia kemudian menciptakan beberapa startup yang relatif sukses, menciptakan sistem komunikasi, touchpads, dan kamera digital. Anda dapat menyebutkan bahwa, selain Z80, di Zilog ia juga mengembangkan mikrokontroler Z8 yang sukses dan masih diproduksi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z80 adalah prosesor yang lebih nyaman untuk dimasukkan ke dalam sistem komputer daripada 8080. Z80 hanya membutuhkan satu tegangan suplai dan memiliki dukungan bawaan untuk regenerasi memori dinamis. Selain itu, dengan kompatibilitas penuh dengan 8080, ia memiliki beberapa perintah baru, set kedua register utama dan beberapa register yang sama sekali baru. Sangat mengherankan bahwa Zilog menolak untuk menggunakan mnemonik assembler 8080, dan mulai menggunakan mnemonik mereka sendiri, yang lebih cocok untuk sistem perintah extended z80. Kisah serupa terjadi dengan assembler Intel x86 di dunia perangkat lunak GNU, karena beberapa alasan mereka juga menggunakan konvensi mereka sendiri untuk menulis program di assembler secara default. Z80 menambahkan dukungan untuk flag overflow, Intel menambahkan dukungan untuk flag semacam itu hanya pada 8086. Namun,Bendera ini di z80 dikombinasikan dengan bendera paritas, jadi pada saat yang sama, seperti pada 8086, kedua bendera tidak dapat digunakan. Di z80, seperti pada 6502, hanya ada pemeriksaan dasar dari nilai satu flag, mis. tidak ada pemeriksaan dua atau tiga bendera sekaligus, yang diperlukan untuk perbandingan "benar-benar lebih besar", "kurang dari atau sama dengan", serta semua yang signifikan - dalam kasus seperti itu Anda harus melakukan beberapa pemeriksaan, satu pada 8086, 6800 atau PDP-11 sudah cukup.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di antara instruksi z80 baru, instruksi untuk menyalin memori secara massal selama 21 siklus per byte, serta perintah pencarian byte yang menarik dalam memori, sangat mengesankan. </font><font style="vertical-align: inherit;">Namun, yang paling menarik adalah perintah EXX, yang menukar isi dari 48 byte memori register, register BC, DE, HL dengan ganda mereka, yang berjalan hanya dalam 4 siklus! </font><font style="vertical-align: inherit;">Bahkan ARM 32-bit membutuhkan setidaknya 6 siklus clock untuk operasi yang sama. </font><font style="vertical-align: inherit;">Instruksi tambahan lainnya tidak begitu mengesankan, meskipun kadang-kadang bisa bermanfaat. </font><font style="vertical-align: inherit;">Ditambahkan lebih banyak:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengurangan 16-bit dengan pinjaman dan penambahan 16-bit dengan transfer selama 15 siklus; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> minus unary untuk baterai selama 8 ticks; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kemampuan membaca dari memori dan menulis ke sana menggunakan register BC, DE, SP, IX, IY, dan bukan hanya HL; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pergeseran, rotasi dan input-output untuk semua register 8-bit; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operasi pengecekan, pengaturan dan pengaturan ulang sedikit dengan nomornya; </font></font></li><li>    (JR); </li><li>  . </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagian besar perintah baru agak lambat, tetapi menggunakannya dengan benar masih dapat membuat kode sedikit lebih cepat dan secara signifikan lebih kompak. Ini terutama berlaku untuk penggunaan register 16-bit IX dan IY baru, yang dapat digunakan untuk metode pengalamatan baru. Menariknya, register indeks IX dan IY muncul di Z80 untuk menarik 6800 pengguna ke transisi ke Z80! Tapi saya berani menyatakan pendapat saya, operasi dengan register indeks Z80 dibuat agak tidak berhasil karena adanya byte offset yang hampir tidak berguna dalam perintah menggunakan register ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Banyak 8080 tim di z80 mendapat ketukan lebih cepat dan ini adalah akselerasi yang sangat nyata. Tetapi perintah ADD, dasar untuk aritmatika 16-bit, menjadi lebih lambat per siklus, yang membuat aritmatika secara umum, jika lebih cepat, hanya sedikit.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sistem untuk bekerja dengan interupsi menjadi jauh lebih menarik daripada pada 8080. Dengan z80, Anda dapat menggunakan kedua interupsi non-maskable dan tiga metode (salah satunya kompatibel dengan 8080) untuk bekerja dengan masked. Mode paling menarik dari masked interrupt 2, yang memungkinkan Anda untuk secara fleksibel mengubah alamat kode untuk menangani interupsi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z80 memiliki banyak instruksi tidak berdokumen, banyak dari instruksi ini menghilang ketika beralih ke teknologi CMOS, tetapi yang bertahan menjadi standar dan didokumentasikan oleh beberapa perusahaan. Instruksi yang sangat berguna memungkinkan Anda untuk bekerja dengan byte individu dari register 16-bit yang canggung IX dan IY. Selain instruksi tidak berdokumen, Z80 memiliki properti tidak terdokumentasi lainnya, misalnya, dua bendera khusus dalam register negara.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentu saja, z80 bahkan lebih dari 8.080 berhak disebut sedikit 16-bit. Indeks kapasitas digit hipotetis untuk z80 jelas sedikit lebih tinggi, tetapi paradoks bahwa ALU untuk z80 sebenarnya 4-bit! Pada level elektronik, z80 dan 8080 adalah chip yang sama sekali berbeda.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Banyak yang telah ditulis tentang membandingkan kinerja z80 dan 6502, karena prosesor ini sangat banyak digunakan pada komputer massal pertama. Ada beberapa momen sulit dalam topik ini, yang tanpanya sangat sulit untuk mempertahankan objektivitas. Karena keberadaan register z80 dalam jumlah yang agak besar, adalah wajar untuk menggunakan pada frekuensi yang lebih tinggi daripada memori yang bekerja. Oleh karena itu, z80 pada 4 MHz dapat menggunakan memori yang sama dengan 6502 atau 6809 pada 1,3 MHz. Menurut banyak programmer berpengalaman yang menulis kode untuk kedua prosesor, pada frekuensi yang sama, rata-rata 6502, dari 2,4 menjadi 2,6 kali lebih cepat daripada z80. Penulis materi ini setuju dengan ini. Anda hanya perlu menambahkan bahwa penulisan yang baik, kode cepat untuk z80 sangat sulit, Anda harus terus mengoptimalkan penggunaan register, dan menggunakan tumpukan untuk bekerja dengan memori sebanyak mungkin.Jika Anda berusaha keras, maka menurut saya Anda dapat mengurangi perbedaan antara z80 dan 6502 menjadi sekitar 2,2 kali. Dan jika Anda tidak mencoba dan mengabaikan timing, maka Anda dapat dengan mudah mendapatkan perbedaan hingga 4 kali. Dalam beberapa kasus individual, z80 dapat menunjukkan kinerja yang sangat cepat. Pada tugas mengisi memori, z80, menggunakan perintah PUSH, bahkan bisa sedikit lebih cepat dari 6502, tetapi ini dengan biaya melarang interupsi. Pada menyalin blok memori, z80 hanya 1,5 kali lebih lambat. Sangat mengesankan bahwa dalam membagi 32-bit yang dapat dibagi oleh 16-pembagi, z80 hanya 1,7 kali lebih lambat. Omong-omong, super-sharing semacam itu diterapkan oleh seorang programmer Rusia. Dengan demikian, kita mendapatkan bahwa ZX Spectrum dengan z80 pada 3,5 MHz sekitar satu setengah kali lebih cepat daripada C64 dari 6502 pada 1 MHz. Perlu dicatatbagian dari jam di sebagian besar sistem dengan z80 atau 6502 diambil dari prosesor dengan skema dukungan pembuatan video, misalnya, karena ini, untuk komputer Amstrad CPC / PCW yang populer, frekuensi prosesor sebenarnya adalah 3,2 MHz, dan bukan penuh 4. Dalam sistem pada 6502, Anda biasanya dapat mematikan layar untuk kinerja prosesor maksimum. Jika kita mengambil frekuensi memori, daripada prosesor, sebagai dasar, ternyata z80 adalah 25-40% lebih cepat dari 6502. Hasil terakhir dapat diilustrasikan oleh fakta bahwa dengan memori dengan frekuensi 2 MHz z80 dapat beroperasi pada frekuensi hingga 6 MHz, dan 6502 hanya hingga 2 MHz.Jika kita mengambil frekuensi memori, daripada prosesor, sebagai dasar, ternyata z80 adalah 25-40% lebih cepat dari 6502. Hasil terakhir dapat diilustrasikan oleh fakta bahwa dengan memori dengan frekuensi 2 MHz z80 dapat beroperasi pada frekuensi hingga 6 MHz, dan 6502 hanya hingga 2 MHz.Jika kita mengambil frekuensi memori, daripada prosesor, sebagai dasar, ternyata z80 adalah 25-40% lebih cepat dari 6502. Hasil terakhir dapat diilustrasikan oleh fakta bahwa dengan memori dengan frekuensi 2 MHz z80 dapat beroperasi pada frekuensi hingga 6 MHz, dan 6502 hanya hingga 2 MHz.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z80 digunakan dalam sejumlah besar sistem komputer. Tandy TRS-80 sangat populer di AS, ZX Spectrum di Eropa, dan kemudian Amstrad CPC dan PCW. Sangat mengherankan bahwa komputer Amstrad PCW tetap relevan sampai pertengahan 90-an dan secara besar-besaran dan aktif digunakan untuk tujuan yang dimaksudkan sampai akhir 90-an. Di Jepang dan negara lain, mereka memproduksi komputer MSX yang cukup sukses di seluruh dunia. C128 yang agak populer juga bisa menggunakan z80, tetapi di sini pengguna lebih cenderung merasa malu - rilis akhir tahun 1985 ini, komputer z80 8-bit, secara resmi clock 2 MHz, benar-benar bekerja hanya pada 1,6 MHz. Ini bahkan lebih lambat dari sistem pertama di 8080-an pertengahan 70-an. Kisaran komputer untuk menggunakan sistem operasi CP / M mencakup setidaknya tiga lusin sistem yang cukup terkenal.</font></font><br><br><img src="http://www.old-computers.com/museum/photos/Amstrad_9512_Running_s1.jpg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PC semacam itu tampak layak bahkan di pertengahan tahun 90-an, tetapi z80-nya lebih lambat dari pada ZX Spectrum.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sistem komputer berbasis-z80 tercepat yang dikenal penulis adalah BBC Micro dengan set-top-box TUBE dengan 680 MHz z80B, diproduksi sejak 1984. Prosesor dalam Sistem ini bekerja dengan kecepatan penuh, seperti yang mereka katakan, "tanpa rem". Konsol serupa dibuat untuk Apple] [sejak 1979. Kemudian, beberapa konsol ini menggunakan Z80H pada 8 MHz dan bahkan lebih tinggi. Menariknya, pada tahun 1980, Microsoft menerima keuntungan terbesar dari penjualan konsol tersebut. Anda juga dapat menyebutkan Amstrad PCW16, yang diproduksi sejak 1994, yang menggunakan CMOS Z80 pada frekuensi 16 MHz.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di Jepang, R800 yang kompatibel dengan z80 diproduksi untuk sistem MSX TurboR (1990). Perkalian perangkat keras 16-bit dengan hasil 32-bit telah ditambahkan ke R800. Meskipun ketika dikalikan dengan konstanta 16-bit, tabel perkalian dengan tabel 768 byte diperoleh dengan jam lebih cepat. Ada pendapat bahwa R800 adalah Z800 yang sangat disederhanakan yang beroperasi pada frekuensi empat kali lebih tinggi dari frekuensi bus, yaitu sekitar 7,16 MHz. Dengan demikian, frekuensi internal R800 adalah sekitar 28,64 MHz!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zilog sendiri telah berupaya memperbaiki Z80 dengan sangat tidak konsisten dan sangat lambat. Z80 pertama bekerja pada frekuensi hingga 2,5 MHz, dan Z80A, yang muncul tak lama kemudian, meningkatkan frekuensi maksimum menjadi 4 MHz - prosesor ini menjadi dasar bagi kebanyakan komputer populer menggunakan Z80. Z80B muncul pada 1980, tetapi digunakan relatif jarang, misalnya, di BBC Micro console atau pada akhir (1989) komputer Sam CoupÃ©. Z80H muncul pada pertengahan 80-an dan dapat beroperasi pada frekuensi hingga 8 MHz - tidak digunakan pada komputer terkenal. Sangat menarik bahwa produk Zilog memiliki jebakan khusus pada chip untuk mereka yang mencoba membuat salinannya, misalnya, pangkalan Z80 memiliki 9 jebakan dan, menurut ulasan dari mereka yang melakukan ini, mereka memperlambat proses penyalinan selama hampir setahun.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peningkatan z80 yang lebih dalam terhambat oleh keinginan Zilog untuk membuat prosesor yang bersaing dengan prosesor 16-bit Intel. Pada tahun 1978, 8086 kemudian dirilis Z8000, tidak kompatibel dengan z80. Prosesor ini tidak mampu menahan pesaing dari Intel, dan terutama Motorola - 68000 melebihi Z8000 dalam hampir semua hal, meskipun Z8000 digunakan di sekitar selusin sistem murah yang berbeda, biasanya untuk bekerja dengan varian Unix. Yang menarik, IBM bahkan tidak menganggap Z8000 sebagai prosesor yang mungkin untuk PC IBM, karena Zilog didanai oleh Exxon, yang akan bersaing dengan IBM. Mungkin karena kegagalan Z8000, Zilog menjadi divisi Exxon pada 1980. Ada juga upaya untuk membuat prosesor 32-bit yang kompetitif. Pada tahun 1986, Z80000 muncul, kompatibel dengan Z8000, yang </font><b><font style="vertical-align: inherit;">mana</font></b><font style="vertical-align: inherit;"> - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mana.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan tidak menemukan aplikasi. Beberapa keadaan, khususnya, keluhan Zilog yang sangat aneh tentang pendanaan yang berlebihan, menunjukkan bahwa mungkin Zilog, untuk beberapa alasan yang tidak jelas, agak menyabot kerjanya sebagai bagian dari Exxon. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Orang hanya dapat bertanya-tanya mengapa Zilog meninggalkan pendekatannya, yang menunjukkan hasil super-sukses dengan Z80, yaitu, membuat prosesor yang kompatibel secara terprogram dengan prosesor Intel, tetapi yang terbaik dan pada saat yang sama benar-benar berbeda pada tingkat perangkat keras. Selanjutnya, pendekatan ini berhasil digunakan oleh banyak perusahaan, khususnya, AMD, Cyrix, VIA.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penciptaan prosesor baru berbasis Z80 ditunda hingga 1985, ketika Z800 dibuat. Namun, kemudian upaya utama Zilog ditujukan pada Z80000 dan sangat sedikit yang dirilis Z800. Pada tahun 1986, setelah kegagalan z80000, Z280 dirilis, versi yang sedikit ditingkatkan dari Z800, yang, khususnya, dapat beroperasi pada frekuensi internal beberapa kali lebih tinggi daripada frekuensi bus - hal baru tersebut membawa kesuksesan besar pada prosesor Intel 486DX2 dan 486DX4. Z280 juga memiliki fitur menjanjikan lainnya yang kemudian berhasil diterapkan oleh perusahaan lain. Tapi, mungkin karena kinerja rendah - Z280, meskipun banyak inovasi teknologi, hanya bisa menggunakan kecepatan clock yang relatif rendah, prosesor ini juga </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak ada</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak ditemukan aplikasi. Diyakini bahwa Z280 secara kasar sesuai dengan kemampuan Intel 80286, tetapi secara signifikan, setidaknya 50% lebih lambat ketika menggunakan frekuensi clock yang sama dengan 80286. Mungkin jika Z280 muncul 5 tahun sebelumnya, maka itu bisa menjadi sangat sukses.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keberhasilan terbesar dicapai berkat kerja sama dengan perusahaan Jepang Hitachi, yang pada tahun 1985 merilis super-Z80, HD64180, yang memiliki kemampuan serupa dengan Intel 80186, yang memungkinkan penggunaan memori 512 KB, menambahkan selusin instruksi baru, tetapi beberapa instruksi standar hampir tidak terdokumentasi Z80 tidak didukung. HD64180 telah digunakan di beberapa sistem komputer. Zilog memperoleh lisensi untuk HD64180 dan mulai memproduksinya dengan tanda Z64180. Zilog berhasil sedikit meningkatkan prosesor ini, khususnya, menambahkan dukungan untuk bekerja dengan memori 1 MB dan melepaskannya pada akhir tahun 1986. Prosesor baru ini disebut Z180 dan menjadi dasar untuk keluarga prosesor dan pengontrol, dengan frekuensi clock hingga 33 MHz. Itu digunakan pada beberapa komputer MSX2 yang langka, tetapi lebih seperti sebuah pengontrol. Ingin tahubahwa Z280 dan Z180 muncul dalam satu tahun, serta perkiraan rekan-rekan mereka 80286 dan 80 166 empat tahun sebelumnya. Pada tahun 1994, Z380 32-bit dibuat berdasarkan Z180, yang tetap kompatibel dengan z80 dan kira-kira setara dalam kapasitas untuk Intel 80386 atau Motorola 68020 - Zilog menunjukkan jarak hampir 10 tahun dari para pesaingnya. Sudah di abad ke-21, pengontrol prosesor eZ80 yang sangat sukses dengan timing hampir seperti 6502 sedang dibuat lagi berdasarkan Z180. Mereka digunakan dalam berbagai peralatan, khususnya dalam kartu jaringan, drive DVD, kalkulator, ...Sudah di abad ke-21, pengontrol-prosesor eZ80 yang sangat sukses dengan timing hampir seperti 6502 sedang dibuat lagi berdasarkan Z180. Mereka digunakan dalam berbagai peralatan, khususnya dalam kartu jaringan, drive DVD, kalkulator, ...Sudah di abad ke-21, pengontrol-prosesor eZ80 yang sangat sukses dengan timing hampir seperti 6502 sedang dibuat lagi berdasarkan Z180. Mereka digunakan dalam berbagai peralatan, khususnya dalam kartu jaringan, drive DVD, kalkulator, ...</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Texas Instruments TMS9900 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk pemroses kode yang sangat khusus ini, saya tidak pernah bisa menulis. </font><font style="vertical-align: inherit;">Dan ini adalah prosesor 16-bit pertama yang tersedia untuk digunakan di komputer pribadi. </font><font style="vertical-align: inherit;">Ini telah diproduksi sejak 1976. </font><font style="vertical-align: inherit;">Menggunakan urutan byte yang jauh lebih jarang dari tinggi ke rendah (Big Endian). </font><font style="vertical-align: inherit;">Pesanan ini masih digunakan hanya dalam prosesor seri Motorola 6800 dan 68000 dan dalam arsitektur raksasa IBM / 370. </font><font style="vertical-align: inherit;">Semua prosesor lain dalam ulasan ini menggunakan urutan byte terbalik (Little Endian).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TMS9900 hanya memiliki tiga register 16-bit: penghitung perintah, register negara, dan register basis pseudo-register. Prosesor ini menggunakan memori yang dialokasikan 32 byte sebagai 16 register bita-ganda. Penggunaan memori ini agak mengingatkan pada halaman nol memori dalam arsitektur 6502. Dengan menggunakan register dasar, TMS9900 dapat dengan cepat mengubah konteks. Ini menyerupai Z80, yang memiliki dua konteks register. Sistem bendera dibedakan oleh orisinalitasnya, bersama dengan bendera khas carry, nol (kesetaraan), melimpah, paritas, ada dua bendera lebih unik dari tanda-tanda logis dan aritmatika kurang. Bekerja dengan tumpukan dan rutinitas menyerupai prosesor RISC di masa depan. Hanya tidak ada tumpukan selesai, itu dapat dibuat menggunakan salah satu register semu.Ketika subrutin dipanggil, nilai baru dipilih untuk penghitung dan basis, dan ketiga register disimpan dalam register semu dari konteks baru. Dengan demikian, panggilan subrutin lebih mirip panggilan interupsi program. TMS9900 memiliki pengontrol interupsi internal, yang dirancang untuk bekerja dengan interupsi perangkat keras hingga 16.</font></font><br><br><img src="https://habrastorage.org/webt/bs/ir/lv/bsirlvxf7fobwzwpdcvxkcnousc.jpeg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komputer rumah 16-bit pertama - bahkan memiliki sprite warna</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sistem perintah terlihat sangat mengesankan. Bahkan ada penggandaan dan pembagian. Instruksi unik X memungkinkan Anda untuk menjalankan satu instruksi di alamat mana saja di memori dan beralih ke instruksi berikutnya. Eksekusi perintah agak lambat, instruksi tercepat dieksekusi hanya dalam 8 siklus clock, instruksi aritmatika dalam 14, tetapi perkalian (16 * 16 = 32) dalam 52 siklus clock dan terutama divisi (32/16 = 16,16) dalam 124 jam periode mungkin merupakan catatan tercepat di antara prosesor 70-an.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TMS9900 membutuhkan tegangan suplai tiga -5, 5 dan 12 volt dan empat fase sinyal clock - ini adalah anti-rekaman di antara prosesor yang saya tahu. Pada tahun 1979, prosesor ini diperlihatkan kepada spesialis IBM yang kemudian mencari prosesor untuk prototipe IBM PC yang sedang dikembangkan. Kekurangan yang jelas dari TMS9900 (addressability hanya 64 KB memori, kurangnya arsitektur pengontrol yang diperlukan, kelambatan relatif) membuat kesan yang sesuai dan Intel 8088 dipilih sebagai pemimpin masa depan di antara PC. Untuk mengatasi masalah kurangnya pengontrol, Texas Instruments juga memproduksi versi TMS9900 dengan bus 8-bit, TMS -9980, yang bekerja 33% lebih lambat.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TMS9900 digunakan dalam komputer TI99 / 4 dan TI99 / 4A, yang cukup populer di AS, yang "dihancurkan" dalam perang harga oleh komputer Commodore VIC-20 pada tahun 1983. Sangat mengherankan bahwa akibat perang ini Texas Instruments terpaksa mengurangi harga komputernya menjadi tidak dapat dipercaya. untuk 1983 $ 49 (pada 1979 harganya $ 1150!) dan menjualnya dengan kerugian besar untuk Anda sendiri. Sebagai contoh, kita dapat mengutip Commodore + 4 komputer yang relatif tidak populer, yang dihentikan pada tahun 1986, tetapi yang harganya jatuh ke $ 49 ini hanya pada tahun 1989. T99 / 4A berhenti berproduksi pada 1984, ketika, karena harga yang sangat rendah, ia mulai mendapatkan popularitas. Komputer ini hanya bisa disebut 16-bit. Karena hanya memiliki 256 byte (!) Memori RAM dan semua memori ROM ditangani melalui bus 16-bit.Sisa memori dan perangkat I / O bekerja melalui bus 8-bit yang lambat. Oleh karena itu, dimungkinkan untuk menganggap BK-0010 domestik sebagai komputer rumah 16-bit yang lebih tepat. Anehnya, TI99 / 4 dan TI99 / 4A menggunakan prosesor pada 3 MHz - persis sama dengan BK-0010.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam TI-99/4 dan TI99 / 4A, chip TMS9918 yang agak sukses digunakan sebagai pengontrol video, yang menjadi dasar untuk standar MSX yang sangat populer di seluruh dunia, serta beberapa komputer dan konsol game lainnya. </font><font style="vertical-align: inherit;">Di perusahaan Jepang Yamaha, chip video ini meningkat secara signifikan dan kemudian digunakan, khususnya, untuk meningkatkan TI-99/4 dan TI99 / 4A sendiri! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seri TI99 / 4 adalah contoh langka dari komputer di mana pabrikan prosesor dan komputer itu sama.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prosesor DEC PDP-11 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sejak awal 70-an, era 10-tahun dominasi DEC dimulai di dunia. Komputer DEC secara signifikan lebih murah daripada yang diproduksi oleh IBM dan karena itu menarik perhatian organisasi kecil yang sistem IBM tidak tersedia. Era pemrograman profesional massal juga dimulai dengan komputer ini. Seri komputer PDP-11 telah sangat sukses. Berbagai model PDP-11 diproduksi dari awal 70-an hingga awal 90-an. Di Uni Soviet, mereka berhasil dikloning dan menjadi sistem komputer populer massal pertama. Di antara klon adalah komputer dengan nama komputer SM, Elektronik-60/81/85, DVK-1/2/3, BK-0010/0011 (BK0010 adalah PC pertama yang dimungkinkan untuk membeli di toko).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, DEC juga mempromosikan komputer yang lebih mahal dan canggih dari keluarga VAX-11, situasi yang agak dipolitisasi. Dan dari paruh kedua tahun 70-an, DEC praktis menghentikan pengembangan di garis PDP-11, khususnya, dukungan untuk 16 angka untuk assembler tidak diperkenalkan. Kinerja sistem PDP-11 juga tetap tidak berubah sejak pertengahan 70-an.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PDP-11 menggunakan prosesor berbeda yang kompatibel dengan sistem perintah utama, misalnya, LSI-11, F-11, J-11. Pada akhir 70-an, DEC membuat prosesor murah untuk mikrokomputer T-11. Namun, untuk alasan yang tidak jelas, itu, meskipun perangkat lunak yang tampaknya besar dan berkualitas tinggi yang dapat ditransfer ke sistem menggunakannya di masa depan, tidak pernah diperhatikan oleh produsen sistem komputer. Satu-satunya pengecualian adalah model konsol game Atari. T-11 ditemukan digunakan secara luas hanya di dunia peralatan tertanam, meskipun dalam hal kemampuannya agak lebih unggul dari z80. Di Uni Soviet, prosesor K1801BM1, K1801BM2, K1801BM3, ... dekat dengan prosesor DEC, serta salinan yang tepat dari prosesor DEC yang diproduksi. Yang terakhir jauh lebih mahal dan diproduksi dalam jumlah kecil.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sistem perintah prosesor arsitektur PDP-11 dibedakan oleh ortogonalitas yang hampir lengkap, kualitas yang menyenangkan, tetapi ketika dibawa ke ekstrem, itu dapat membuat perintah yang konyol. Sistem instruksi prosesor PDP-11 telah memengaruhi banyak arsitektur, dan khususnya Motorola 68000.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sistem perintah PDP-11 benar-benar 16-bit. Semua 8 register tujuan umum (dan penghitung instruksi dalam arsitektur ini adalah register R7 reguler) adalah 16-bit, register status (berisi bendera khas) juga 16-bit, ukuran instruksi adalah dari 1 hingga 3 kata 16-bit. Setiap operan dalam suatu perintah dapat (walaupun ada pengecualian, misalnya, instruksi XOR) dari jenis apa pun - ini adalah ortogonalitas. Di antara jenisnya adalah register biasa atau memori. Pemrogram pada tahun 80-an terkadang tidak mengerti mengapa tidak ada instruksi memori-memori dalam sistem instruksi Intel x86. Ini adalah pengaruh sekolah PDP-11, di mana Anda dapat dengan mudah menulis alamat lengkap untuk setiap operan. Ini, tentu saja, lambat dan terutama lambat untuk sistem dengan memori lambat yang khas pada awal 90-an. Memori juga dapat diakses melalui register, register dengan offset, register dengan auto-decrementation atau incrementation.Fitur dari sistem instruksi PDP-11 adalah kemungkinan akses ganda tidak langsung ke memori melalui register, misalnya,</font></font><br><br><pre><code class="plaintext">MOV @(R0)+,@-(R1)</code> </pre> <br>  artinya sama dengan operator bahasa C / C ++ <br><br><pre> <code class="plaintext">**â€“r1 = **r1++;</code> </pre> <br>  , di mana r0 dan r1 dinyatakan sebagai <br><br><pre> <code class="plaintext">signed short **r0, **r1;</code> </pre> <br>  Contoh lain, perintah <br><br><pre> <code class="plaintext">MOVB @11(R2),@-20(R3)</code> </pre> <br>  sesuai dengan <br><br><pre> <code class="plaintext">**(r3-20) = **(r2+11);</code> </pre> <br>  di mana r2 dan r3 dinyatakan sebagai <br><br><pre> <code class="plaintext">char **r2, **r3;</code> </pre> <br>  Dalam arsitektur populer saat ini, satu tim tidak dapat melakukannya tanpa tim seperti itu, setidaknya 10 tim mungkin akan dibutuhkan.  Anda juga bisa mendapatkan alamat relatif terhadap nilai saat ini dari penghitung perintah.  Saya akan memberikan contoh lain dengan pengalamatan yang lebih sederhana.  Tim <br><br><pre> <code class="plaintext">ADD #16,11(R4)</code> </pre> <br>  dalam arsitektur Intel x86 dapat dipetakan <br><br><pre> <code class="plaintext">ADD [BX+11],16</code> </pre> <br>  Pada perakit DEC, biasanya menulis operan dari kiri ke kanan, tidak seperti Intel, di mana mereka menulis dari kanan ke kiri.  Ada alasan untuk percaya bahwa assembler GNU untuk x86 dibuat di bawah pengaruh assembler PDP-11. <br><br>  Perintah perkalian dan pembagian hanya simbolis dan tidak tersedia pada semua prosesor.  Aritmatika angka desimal juga opsional - inilah yang disebut terminologi komersial terminologi DEC.  Sebagai keingintahuan ortogonalitas lengkap, saya akan memberikan contoh perintah <br><br><pre> <code class="plaintext">MOV #11,#22</code> </pre> <br>  yang setelah eksekusi berubah menjadi <br><br><pre> <code class="plaintext">MOV #11,#11</code> </pre> <br>  - Ini adalah contoh menggunakan konstanta langsung sebagai operan.  Tim penasaran lain adalah perintah MARK unik, kode yang harus didorong ke tumpukan dan tidak pernah dapat digunakan secara eksplisit.  Memanggil rutinitas dalam arsitektur PDP-11 juga agak aneh.  Perintah yang sesuai pertama-tama menyimpan register yang dialokasikan (mungkin ada) di stack, kemudian menyimpan counter instruksi dalam register ini dan hanya kemudian menulis nilai baru ke counter instruksi.  Perintah kembali dari subprogram harus melakukan yang sebaliknya dan tahu register mana yang digunakan saat memanggil subprogram.  Efek yang sangat aneh dan tidak terduga dapat diperoleh dengan menggunakan penghitung perintah sebagai register normal. <br><br>  Sangat menarik bahwa di antara programmer PDP-11, budaya bekerja secara langsung dengan kode mesin telah dikembangkan.  Pemrogram dapat, misalnya, bekerja tanpa disassembler saat melakukan debugging.  Atau bahkan menulis program kecil langsung di memori tanpa perakitan! <br><br>  Tentu saja, pengaturan waktu tim tidak berbeda dalam karakteristik kecepatan terlalu tinggi.  Mengejutkan sekali ketika mengetahui bahwa pada komputer domestik BK, perintah transfer dari register ke register memakan waktu sebanyak 12 siklus (10 siklus saat menggunakan kode dari ROM), dan perintah dengan dua operan dengan pengalamatan ganda tidak langsung dieksekusi selama lebih dari 100 siklus.  Z80 melakukan transfer register 16-bit untuk 8. Namun, lambatnya BC disebabkan tidak begitu banyak oleh prosesor, tetapi oleh buruknya kualitas memori domestik, di bawah fitur yang BC harus disesuaikan.  Jika memori yang cukup cepat digunakan, maka BC mengirim 16 bit register untuk siklus 8 jam juga.  Pernah ada banyak kontroversi, mana yang lebih cepat dari BC atau Spectrum?  Harus segera dikatakan bahwa Spectrum adalah salah satu komputer pribadi 8-bit tercepat saat menggunakan memori 32 KB.  Oleh karena itu, tidak mengherankan bahwa Spectrum lebih cepat daripada BC, tetapi tidak banyak.  Dan jika BC bekerja dengan memori tanpa rem, maka itu mungkin akan sedikit lebih cepat. <br><br>  Kepadatan kode juga merupakan titik lemah dari arsitektur PDP-11.  Kode instruksi harus merupakan kelipatan dari panjang kata mesin - 2 byte, yang sangat tidak menyenangkan ketika bekerja dengan argumen byte atau perintah sederhana seperti mengatur atau mengatur ulang bendera. <br><br>  Upaya membuat komputer pribadi berdasarkan arsitektur PDP-11 menarik.  Salah satu PC pertama di dunia yang muncul sedikit lebih lambat dari Apple] [dan Commodore PET, dan sedikit lebih awal dari Tandy TRS-80, adalah Terak 8510 / a, yang memiliki grafis hitam dan putih dan kemampuan untuk mengunduh Unix versi yang tidak lengkap.  PC ini cukup mahal dan, sejauh yang saya tahu, hanya digunakan di sistem pendidikan tinggi AS.  Sejak 1978, komputer diproduksi dalam bentuk kit untuk merakit Heathkit H11.  DEC sendiri juga mencoba membuat PC sendiri, tetapi sangat tidak konsisten.  DEC, misalnya, merilis PC berbasiskan z80 dan 8088, yang jelas bermain melawan perkembangan utamanya.  Personil yang berbasis pada arsitektur PDP-11 DEC PRO-325/350/380 memiliki beberapa ketidaksesuaian buatan dengan arsitektur yang mendasarinya, yang membuatnya sulit untuk menggunakan bagian dari perangkat lunak.  Personalisasi terbaik dari teknologi komputer mini adalah di Uni Soviet, di mana BC, DVK, CC NT dibuat ... Omong-omong, Electronics-85 adalah klon yang cukup akurat dari DEC PRO-350.  Selain itu, prosesor CP1600, mirip dengan arsitektur PDP-11, digunakan dalam konsol game Intellivision, yang populer di awal tahun 80-an. <br><br><img src="https://hsto.org/storage2/054/de2/ed6/054de2ed61ad81127c1d7db0f7171100.jpg"><br>  <i>Domestik komputer rumah 16-bit (1985) - hampir kompatibel PDP-11</i> <br><br>  K1802BM2, yang digunakan dalam DVK, sekitar dua kali lebih cepat dari K1801BM1, K1801BM3 bahkan lebih cepat dan mendekati kecepatan Intel 8086. <br><br>  Dalam model PDP-11 yang lebih lama dan komputer rumah tangga yang dekat dengan mereka, prosesor dapat menangani hingga 4 MB memori, tetapi tidak lebih dari 64 KB dapat dialokasikan untuk satu program.  Dalam hal kecepatan, prosesor ini juga mendekati 8086 dalam hal jumlah operasi per megahertz, meskipun masih lebih lambat dari itu. <br><br><h2>  CPU untuk DEC VAX-11 </h2><br>  Sistem VAX-11 cukup populer di tahun 80-an, terutama di pendidikan tinggi.  Sekarang sulit untuk memahami beberapa konsep yang dijelaskan dalam buku-buku tahun-tahun itu tanpa mengetahui arsitektur sistem ini.  VAX-11 lebih mahal daripada PDP-11, tetapi mereka lebih berorientasi pada pemrograman universal dan masih jauh lebih murah daripada sistem IBM / 370.  Untuk arsitektur VAX, prosesor V-11 dibuat pada pertengahan 80-an, dan sampai saat itu, rakitan prosesor digunakan. <br><br>  Arsitektur VAX-11 adalah 32-bit, ia menggunakan 16 register, di antaranya, seperti pada PDP-11, ada penghitung perintah.  Dua tumpukan seharusnya digunakan, salah satunya digunakan untuk menyimpan bingkai subframe.  Selain itu, salah satu register ditugaskan untuk bekerja dengan argumen fungsi yang dipanggil.  Dengan demikian, 3 dari 16 register dialokasikan untuk tumpukan.  Sistem perintah VAX-11 tidak dapat gagal memukau dengan besarnya dan kehadiran perintah yang sangat langka dan sering unik, misalnya, untuk bekerja dengan bidang bit atau beberapa jenis antrian, untuk menghitung CRC, mengalikan 10 baris ... Banyak perintah dalam versi tiga-alamat (keduanya ARM), dan dalam dua alamat (seperti x86), tetapi ada perintah empat-alamat, misalnya, perluasan divisi EDIV.  Tentu saja ada dukungan untuk bekerja dengan bilangan real. <br><br>  Tapi VAX-11 adalah sistem yang sangat lambat untuk kelas dan harganya.  Bahkan 6502 super-sederhana pada 4 MHz dapat menyalip yang paling lambat dari keluarga VAX-11/730, dan sistem VAX-11 tercepat - kabinet besar dan "set furnitur lengkap", berada pada tingkat kinerja AT PC pertama.  Ketika 80286 muncul, menjadi jelas bahwa hari-hari VAX-11 diberi nomor dan bahkan pengereman dengan pengenalan sistem berbasis 80286 tidak dapat lagi secara fundamental mengubah apa pun.  Orang Inggris yang lebih langsung dari Acorn, yang membuat ARM pada tahun 1985 tanpa menyembunyikan apa pun, mengatakan bahwa ARM jauh lebih murah dan terasa lebih cepat.  Namun, VAX-11 tetap relevan hingga awal 90-an, masih memiliki beberapa keunggulan dibandingkan PC, khususnya, sistem yang lebih cepat untuk bekerja dengan disk. <br><br>  VAX-11 mungkin adalah sistem massa terakhir di mana kenyamanan bekerja di assembler dianggap lebih penting daripada kecepatan.  Dalam arti tertentu, pendekatan ini telah bergeser ke bahasa scripting modern dan populer. <br><br><img src="https://gordonbell.azurewebsites.net/Digital/timeline/photos/vax11-785.jpg" align="left">  <i>Foto menunjukkan VAX-11/785 - ini juga merupakan komputer (1984) - tercepat di antara VAX-11, dalam hal kecepatan prosesor, sebanding dengan IBM PC AT atau ARM Evaluation System</i> <br><br>  Anehnya, ada sangat sedikit literatur yang tersedia pada sistem VAX-11.  Seolah-olah semacam hukum aneh dilupakan berlaku.  Beberapa episode yang dekat dengan politik dan berkorelasi dengan sejarah Uni Soviet dihubungkan dengan sejarah arsitektur ini.  Ada kemungkinan bahwa penolakan sebenarnya terhadap pengembangan arsitektur PDP-11 disebabkan oleh murahnya dan keberhasilan kloningnya di Uni Soviet.  Dan kloning VAX-11 membutuhkan biaya besar sumber daya besar dan menyebabkan jalan buntu.  Ketertarikan pada VAX-11 dibuat menggunakan, misalnya, menggunakan undian seperti Kremlin Vax yang terkenal pada 1 April 1984, di mana pemimpin USSR saat itu Konstantin Chernenko menawarkan untuk minum vodka pada kesempatan menghubungkan ke jaringan Usenet.  Lelucon lainnya adalah bahwa beberapa chip VAX-11 dicetak dengan pesan dalam bahasa Rusia yang rusak tentang seberapa baik VAX-11.  :) <br><br>  Beberapa model VAX-11 dikloning di USSR pada akhir tahun 80-an, tetapi sangat sedikit klon yang diproduksi dan mereka hampir tidak pernah ditemukan digunakan. <br><br>  Beberapa sistem VAX-11 tersedia untuk digunakan melalui jaringan.  Dan ini membandingkan mereka dengan sistem IBM / 370 yang mereka bersaing. <br><br><h2>  Intel: 8086 hingga 80486 </h2><br>  Tentu saja, salah satu prosesor terbaik yang dibuat pada tahun 70-an adalah 8086, serta yang lebih murah hampir analog 8088. Arsitektur prosesor ini sangat baik dibedakan dengan tidak adanya peminjaman mekanis dan kepatuhan pada teori abstrak, arsitektur yang perhatian dan seimbang, keseimbangan dan fokus pada pengembangan lebih lanjut.  Di antara kekurangan arsitektur x86, dapat disebut beberapa ketidaknyamanan dan kecenderungan untuk pertumbuhan luas dalam jumlah instruksi. <br><br>  Salah satu solusi desain cerdik 8086 adalah penemuan register segmen.  Ini, seolah-olah, secara bersamaan mencapai dua tujuan: portabilitas program "bebas" hingga ukuran 64 KB (ini adalah jumlah memori komputer yang sangat layak untuk satu program hingga pertengahan 80-an), dan kemampuan addressability hingga 1 MB ruang alamat.  Anda juga dapat melihat bahwa 8086, seperti 8080 atau z80, juga memiliki ruang alamat khusus untuk port I / O berukuran 64 KB (y 8080 dan 8085, volume ini adalah 256 byte).  Hanya ada empat register segmen: untuk kode, untuk tumpukan, dan dua untuk data.  Dengan demikian, 64 * 4 = 256 KB memori tersedia untuk penggunaan cepat, tetapi ini sangat banyak bahkan di pertengahan 80-an.  Bahkan, tidak ada masalah dengan ukuran kode, karena Anda dapat menggunakan panggilan panjang yang disebut subprogram dengan memuat dan menyimpan alamat lengkap dari dua register.  Hanya ada batas 64 KB pada ukuran satu subprogram - ini sudah cukup untuk banyak aplikasi modern.  Ketidakmungkinan menangani array data dengan cepat lebih besar dari 64 KB menciptakan masalah tertentu - saat menggunakan array seperti itu, Anda perlu memuat register segmen dan alamat itu sendiri setiap kali diakses, yang mengurangi kecepatan bekerja dengan array besar seperti itu beberapa kali. <br><br>  Register segmen diimplementasikan sedemikian rupa sehingga kehadiran mereka hampir tidak terlihat dalam kode mesin, yang membuatnya mudah untuk menolak mereka ketika saatnya tiba. <br><br>  Arsitektur 8086 mempertahankan kedekatannya dengan arsitektur 8080, yang memungkinkan relatif sedikit usaha untuk mentransfer program dari 8080 (atau bahkan z80) ke 8086, dan terutama jika kode sumber program tersedia. <br><br>  Tim 8086 tidak berbeda dalam eksekusi kecepatan tinggi, tetapi cukup sebanding dengan pesaing, misalnya, Motorola 68000, yang muncul setahun kemudian.  Salah satu produk baru, yang sedikit mempercepat 8086 yang umumnya tidak tergesa-gesa, adalah pergantian tim. <br><br>  8086 menggunakan delapan register 16-bit, beberapa di antaranya dapat digunakan sebagai register dua byte, dan beberapa sebagai yang indeks.  Dengan demikian, register 8086 agak heterogen, tetapi seimbang dan register sangat nyaman digunakan.  Heterogenitas ini, omong-omong, memungkinkan Anda untuk memiliki kode yang lebih padat.  8086 menggunakan bendera yang sama dengan 8080, ditambah beberapa yang baru.  Sebagai contoh, sebuah bendera muncul yang khas untuk arsitektur PDP-11 - eksekusi langkah demi langkah. <br><br>  8086 memungkinkan Anda untuk menggunakan mode pengalamatan yang sangat menarik, misalnya, alamat dapat terdiri dari jumlah dua register dan campuran 16-bit yang konstan, di mana nilai salah satu register segmen ditumpangkan.  Hanya dua atau bahkan satu istilah yang dapat diabaikan dari jumlah alamat.  Ini pada PDP-11 dengan satu perintah tidak akan berfungsi.  Sebagian besar instruksi 8086 tidak memungkinkan kedua operan tipe memori, salah satu operan harus berupa register.  Tetapi ada perintah string yang hanya tahu cara bekerja dengan memori menggunakan dua alamat.  Perintah string memungkinkan Anda melakukan penyalinan blok cepat (17 langkah per byte atau kata), mencari, mengisi, memuat, dan membandingkan.  Selain itu, perintah string dapat digunakan saat bekerja dengan port I / O.  Ide 8086 untuk menggunakan awalan perintah sangat menarik, memungkinkan fungsionalitas tambahan yang sangat berguna sering digunakan tanpa komplikasi yang signifikan dari skema pengkodean perintah. <br><br>  8086 memiliki salah satu yang terbaik di antara semua sistem komputer yang bekerja dengan stack.  Dengan hanya menggunakan dua register (BP dan SP), 8086 memungkinkan Anda untuk menyelesaikan semua masalah saat mengatur panggilan ke rutinitas dengan parameter. <br><br>  Di antara tim ada perkalian dan pembagian simbolik dan tanpa tanda tangan.  Bahkan ada perintah penyesuaian desimal unik untuk perintah perkalian dan pembagian.  Sulit untuk mengatakan bahwa jelas ada sesuatu yang hilang dalam sistem perintah 8086.  Justru sebaliknya.  Membagi dividen 32-bit menjadi pembagi 16-bit untuk mendapatkan 32-bit private dan sisa 16-bit mungkin memerlukan hingga 300 siklus clock - tidak terlalu cepat, tetapi beberapa kali lebih cepat daripada pembagian tersebut pada prosesor 8-bit (kecuali 6309) dan sebanding dalam kecepatan hingga 68000. Pembagian oleh x86 memiliki satu fitur yang tidak terduga - ia mengubah tanda-tanda yang tak terduga ... <br><br>  Perlu ditambahkan bahwa dalam arsitektur x86, tim XCHG yang diwarisi dari 8080 tetap ada, yang diperbaiki.  Selain itu, prosesor kemudian mulai menggunakan instruksi XADD, CMPXCHG dan CMPXCHG8B, yang juga dapat melakukan pertukaran atom argumen.  Instruksi tersebut adalah salah satu fitur dari x86, sulit untuk menemukannya pada prosesor arsitektur lain. <br><br>  Kita dapat meringkas bahwa 8086 adalah prosesor yang sangat sukses, menggabungkan kenyamanan pemrograman dan keterikatan pada batasan memori yang merupakan karakteristik dari waktu mereka.  8086 jarang digunakan, memberikan tempat yang lebih murah pada 8088 untuk menjadi prosesor pertama untuk arsitektur PC utama saat ini, arsitektur PC IBM.  8088 menggunakan bus data 8-bit, yang membuatnya agak lebih lambat, tetapi memungkinkan untuk membangun sistem yang lebih mudah diakses oleh pelanggan berdasarkannya. <br><br>  Menariknya, Intel pada dasarnya menolak untuk melakukan perbaikan pada prosesornya, lebih memilih untuk mengembangkan generasi berikutnya.  Salah satu subkontraktor kedua terbesar Intel (NEC), perusahaan Jepang NEC, yang pada awal 80-an jauh lebih besar daripada Intel, memutuskan untuk meningkatkan 8088 dan 8086, melepaskan prosesor V20 dan V30, yang kompatibel dengan mereka pada soket dan hingga 30% lebih cepat.  NEC bahkan menawarkan Intel untuk menjadi subkontraktornya!  Intel malah meluncurkan gugatan terhadap NEC, yang, bagaimanapun, tidak bisa menang.  Untuk beberapa alasan, pertikaian besar antara Intel dan NEC ini sepenuhnya diabaikan oleh Wikipedia. <br><br>  80186 dan 80286 muncul pada tahun 1982. Dengan demikian, dapat diasumsikan bahwa Intel memiliki dua tim pengembangan yang hampir independen.  80186 adalah 8086 yang ditingkatkan oleh beberapa perintah dan timing yang lebih pendek, ditambah beberapa sirkuit terintegrasi yang khas pada arsitektur x86: clock generator, timer, DMA / DAP, interrupt controller, delay generator, dll. Prosesor seperti itu tampaknya akan sangat menyederhanakan produksi komputer berdasarkan itu, tetapi karena pengontrol interupsi internal ternyata tidak kompatibel dengan PC IBM karena alasan tertentu, itu hampir tidak pernah digunakan pada PC.  Penulis hanya tahu sistem BBC Master 512 yang didasarkan pada komputer Mikro BBC, yang tidak menggunakan sirkuit built-in, bahkan timer, tetapi ada beberapa sistem yang menggunakan 80186. Memori yang dialamatkan 80186 tetap dengan cara yang sama seperti pada 8086 dengan ukuran 1 MB.  Perusahaan Jepang NEC menghasilkan analog 80186, yang kompatibel dengan IBM PC. <br><br>  80286 bahkan memiliki timing yang lebih baik daripada 80.186, di antaranya hanya pembagian yang fantastis (32/16 = 16,16) untuk 22 langkah yang sangat terkenal - karena pembagian itu belum dipelajari untuk melakukan lebih cepat!  80286 mendukung bekerja dengan semua tim 80186 baru, ditambah banyak tim untuk bekerja dalam mode baru yang dilindungi.  80286 adalah prosesor pertama dengan dukungan bawaan untuk mode terlindungi, yang memungkinkan pengorganisasian perlindungan memori, penggunaan instruksi khusus yang benar, dan akses ke memori virtual.  Meskipun bekerja dalam mode baru menciptakan banyak masalah bermasalah (mode terlindungi dibuat agak gagal) dan relatif jarang digunakan, itu adalah terobosan besar ke depan.  Dalam mode baru ini, register segmen telah memperoleh kualitas baru, memungkinkan Anda untuk menggunakan hingga 16 MB memori yang dapat dialamatkan dan hingga 1 GB memori virtual per tugas.  Masalah besar dengan 80286 adalah ketidakmampuan untuk beralih dari mode terlindungi ke mode nyata, di mana sebagian besar program bekerja saat itu.  Menggunakan instruksi LOADALL tanpa dokumen â€œrahasiaâ€, dimungkinkan untuk menggunakan 16 MB dalam memori dan dalam mode nyata. <br><br>  Pada 80286, perhitungan alamat dalam operan instruksi mulai dilakukan oleh skema terpisah dan berhenti memperlambat eksekusi perintah.  Ini menambahkan fitur menarik, misalnya, dengan tim <br><br><pre> <code class="plaintext">LEA AX,[BX+SI+4000]</code> </pre> <br>  hanya dalam 3 siklus, menjadi mungkin untuk melakukan dua tambahan dan mentransfer hasilnya ke register AX! <br><br>  Register tersegmentasi dalam mode terlindungi telah menjadi bagian dari sistem manajemen memori lengkap (MMU).  Dalam mode nyata, register ini hanya menyediakan fungsionalitas MMU sebagian. <br><br>  Jumlah pabrikan dan sistem spesifik yang menggunakan 80286 sangat besar, tetapi, tentu saja, yang pertama adalah komputer PC IBM AT dengan indikator kinerja yang hampir fantastis di antara komputer pribadi.  Dari komputer-komputer ini, memori mulai tertinggal dalam kecepatan dari prosesor, ada keadaan penundaan, tetapi kemudian tampak sesuatu yang sementara. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada 80286, seperti pada 8086/8088, bekerja dengan interupsi tidak dilaksanakan 100% dengan benar, yang dalam kasus yang sangat jarang dapat menyebabkan konsekuensi yang sangat tidak menyenangkan. Misalnya, perintah POPF 80286 selalu mengizinkan interupsi selama eksekusi, dan ketika mengeksekusi perintah dengan dua awalan (sebagai contoh, ambil REP ES: MOVSB) pada 8086/8088, setelah memanggil interupsi, salah satu awalan hilang. Bug di POPF hanya ada di rilis 80286 sebelumnya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mode terproteksi 80286 sangat merepotkan, membagi semua memori menjadi segmen tidak lebih dari 64 KB dan memerlukan dukungan perangkat lunak yang kompleks untuk bekerja dengan memori virtual. Setelah muncul pada tahun 1985, 80386 membuat pekerjaan dalam mode terproteksi cukup nyaman, memungkinkan untuk menggunakan hingga 4 GB memori yang dapat dialamatkan dan dengan mudah beralih di antara mode. Selain itu, untuk mendukung multitasking, mode 8086 virtual dibuat untuk program untuk 8086. Untuk memori virtual, menjadi mungkin untuk menggunakan mode halaman yang relatif mudah dikelola. 80386, dengan semua inovasinya, mempertahankan kompatibilitas penuh dengan program yang ditulis untuk 80286. Di antara inovasi 80386, kami juga dapat menyebutkan ekstensi register menjadi 32-bit dan penambahan dua register segmen baru. Pengaturan waktunya telah berubah, tetapi ambigu. Shifter bit cepat telah ditambahkanyang memungkinkan untuk membuat banyak shift dengan timing satu. Namun, inovasi ini karena alasan tertentu sangat memperlambat pelaksanaan instruksi shift siklik. Perkalian telah menjadi sedikit lebih lambat dari pada 80286. Bekerja dengan memori telah menjadi, sebaliknya, sedikit lebih cepat, tetapi ini tidak berlaku untuk perintah string, yang tetap lebih cepat dari 80286. Penulis materi ini sering menemukan pendapat bahwa dalam mode nyata dengan 16- kode bit 80286 pada akhirnya masih sedikit lebih cepat dari 80386 pada frekuensi yang sama.Penulis materi ini lebih dari satu kali harus menemukan pendapat bahwa dalam mode nyata dengan kode 16-bit 80286, pada akhirnya, itu masih sedikit lebih cepat daripada 80386 pada frekuensi yang sama.Penulis materi ini lebih dari satu kali harus menemukan pendapat bahwa dalam mode nyata dengan kode 16-bit 80286, pada akhirnya, itu masih sedikit lebih cepat daripada 80386 pada frekuensi yang sama.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam 80386 perintah baru ditambahkan, sebagian besar hanya memberikan cara baru untuk bekerja dengan data, sebenarnya menduplikasi yang tersedia untuk beberapa kasus dengan optimasi. </font><font style="vertical-align: inherit;">Misalnya, perintah berikut ditambahkan:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk memeriksa, mengatur, dan mengatur ulang bit dengan angka, mirip dengan yang dibuat untuk z80; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pemindaian bit BSF dan BSR; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menyalin nilai dengan ekstensi yang ditandatangani atau nol, MOVSX dan MOVZX; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menetapkan nilai tergantung pada nilai flag dari operasi SETxx; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shift ganda SHLD, SHRD. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum munculnya 80386, prosesor x86 hanya dapat menggunakan lompatan bersyarat offset satu byte pendek - ini sering sangat tidak mencukupi. Dengan 80386 menjadi mungkin untuk menggunakan offset dua (atau empat dalam mode alamat 32-bit), dan terlepas dari kenyataan bahwa kode transisi baru menjadi dua (atau tiga) kali lebih lama, waktu eksekusi tetap sama dengan yang sebelumnya, transisi pendek. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dukungan debugging ditingkatkan secara radikal dengan memperkenalkan 4 breakpoint perangkat keras, menggunakannya, menjadi mungkin untuk menghentikan program bahkan pada alamat dalam memori yang tidak dapat diubah.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mode terproteksi utama telah menjadi jauh lebih mudah untuk dikelola daripada di 80286, yang membuat sejumlah perintah bawaan tidak diperlukan. Dalam mode terlindungi utama, apa yang disebut mode datar menggunakan segmen hingga 4 GB, yang mengubah semua register segmen menjadi formalitas halus. Dan mode unreal semi-didokumentasikan bahkan memungkinkan untuk menggunakan semua memori seperti dalam mode flat, tetapi dari mode nyata, yang mudah untuk menginstal dan mengelola.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan 80386, Intel menolak untuk membagikan teknologinya, menjadi produsen prosesor monopolistik untuk arsitektur PC IBM, dan dengan melemahnya Motorola, untuk arsitektur komputer pribadi lainnya. </font><font style="vertical-align: inherit;">Sistem berbasis 80386 sangat mahal sampai awal 90-an, ketika mereka akhirnya tersedia untuk konsumen massal pada frekuensi dari 25 hingga 40 MHz. </font><font style="vertical-align: inherit;">C 80386 IBM mulai kehilangan posisinya sebagai produsen terkemuka komputer yang kompatibel dengan IBM PC. </font><font style="vertical-align: inherit;">Ini dimanifestasikan, khususnya, pada kenyataan bahwa komputer Compaq adalah PC pertama berdasarkan 80386 pada tahun 1986.</font></font><br><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sulit untuk tidak menahan kekaguman atas volume pekerjaan yang dilakukan oleh pencipta 80386 dan hasilnya. </font><font style="vertical-align: inherit;">Saya bahkan berani menyarankan bahwa 80386 mengandung lebih banyak pencapaian daripada semua pencapaian teknologi umat manusia sebelum tahun 1970, dan bahkan mungkin sebelum tahun 1980.</font></font><br><br></p><p>      80386.   .     ,               .       80386 ,    .     IBTS  XBTS.   80386DX/SX,   AMD,   Intel (     ),      ,       EAX,            POPAD  PUSHAD  ,     BX.       .      ,        .    . <br><br>  ARM      .   ,  ARM   .  Intel  80486.             Intel           â€“   . <br><br>  80486                ARM  .     -   .  ,           ,   8088!      ,  8 ,  -.    , , CMPXCHG â€“       IBTS  XBTS (,             80386).     â€“  ,             32-  BSWAP.           â€“     .      . <br><br>     80486   .  ,      80486,  VX FT,    Apricot â€“    1989   18  40  ,     â€“  60 !           Intel       ARM  Acorn. IBM      80486  1990,    PS/2 90  $17000. <br><br>     Intel  ,   .      ,     8086. ,        ,        AAD  AAM      ,   (      Pentium  15 !).      AND/OR/XOR    , , AND BX,7      (83 E3 07).  ,    ,       ,        80386. ,      8086  80286     ,       .      ADD/ADC/SBB/SUB,      . ,  ,   ,    (?)      .           â€“       .  , ,   SAL/SHL ( D0 E0, D0 F0  D1 E0, D1 F0)   . ,    ,     . ,     .   ,  Intel     ,     ?  SALC      1995  20 !    ICEBP    10   1985  1995.       LOADALL  LOADALLD â€“      ,                80286  80386 .        UD1 (0F B9),      .    . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Di Uni Soviet, produksi klon prosesor 8088 dan 8086 dikuasai, dan itu tidak mungkin untuk sepenuhnya mereproduksi 80286. </font></font><br><br></p><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Motorola: 68.000 hingga 68040 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Motorola adalah satu-satunya perusahaan yang untuk beberapa waktu dapat berhasil bersaing dengan Intel dalam produksi prosesor untuk komputer pribadi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">68000 dirilis pada tahun 1979 dan pada pandangan pertama tampak jauh lebih mengesankan daripada 8086. Ia memiliki 16 register 32-bit (lebih tepatnya 17), penghitung komando terpisah dan register status. Dapat menangani 16 MB memori secara langsung, yang tidak membuat batasan apa pun, misalnya untuk array besar. Namun, analisis yang cermat terhadap fitur 68000 menunjukkan bahwa tidak semuanya sebagus kelihatannya. Pada tahun-tahun itu, memiliki memori lebih dari 1 MB adalah kemewahan yang tidak dapat dicapai bahkan untuk organisasi menengah. Kepadatan kode di 68000 lebih buruk daripada di 8086 - yang berarti bahwa kode dengan fungsi yang sama menempati 68.000 lebih banyak ruang. Yang terakhir ini juga disebabkan oleh fakta bahwa kode 68k harus merupakan kelipatan dari 2 byte panjangnya, dan x86 harus memiliki 1. Namun informasi tentang kepadatan kode masih kontroversial, karena ada bukti bahwa dalam beberapa kasus 68000 bisa lebih baik daripada 8086 Dari 16 register, 8 dialamatkan,dalam beberapa hal, ini adalah analog register segmen x86 yang sedikit lebih maju. ALU dan bus data 16-bit, jadi operasi dengan data 32-bit lebih lambat dari yang Anda harapkan. Waktu pelaksanaan operasi register-to-register adalah 4 siklus, dan bahwa 8086 hanya 2. Komputer berbasis 68000 hingga pertengahan 80-an ternyata jauh lebih mahal daripada komputer berbasis Intel 8088, tetapi 68000 tidak dapat bekerja dengan memori virtual dan tidak memiliki perangkat keras dukungan untuk bekerja dengan bilangan real, yang membuatnya tidak cocok untuk digunakan dalam sistem yang paling canggih.dibandingkan berdasarkan Intel 8088, tetapi 68000 tidak dapat bekerja dengan memori virtual dan tidak memiliki dukungan perangkat keras untuk bekerja dengan bilangan real, yang membuatnya tidak cocok untuk digunakan dalam sistem yang paling canggih.dibandingkan berdasarkan Intel 8088, tetapi 68000 tidak dapat bekerja dengan memori virtual dan tidak memiliki dukungan perangkat keras untuk bekerja dengan bilangan real, yang membuatnya tidak cocok untuk digunakan dalam sistem yang paling canggih.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti biasa, dengan produk-produk dari Motorola, arsitektur 68000 menunjukkan beberapa kecanggungan dan keanehan yang dibuat-buat. Misalnya, dua tumpukan atau dua membawa bendera (satu untuk fitur dan satu untuk operasi). Keanehan dengan bendera ini tidak berakhir di sana. Untuk beberapa alasan, banyak tim, termasuk bahkan MOVE, diisi dengan bendera untuk bendera carry dan overflow. Hal aneh lainnya adalah bahwa perintah untuk menyimpan keadaan bendera aritmatika, yang bekerja dengan baik di 68000, telah dibuat istimewa di semua prosesor mulai dari 68010. Beberapa operasi menjengkelkan dengan non-optimalisasi mereka, misalnya, operasi penulisan nol ke memori CLR lebih lambat daripada menulis konstanta 0 ke memori dengan perintah MOVE atau shift kiri lebih lambat daripada menambahkan operan ke dirinya sendiri. Ada beberapa perintah praktis yang tidak perlu, misalnya, ada aritmatika dan pergeseran kiri logis.Bahkan register alamat dengan keunggulan yang tampaknya lebih unggul dari 8086 register segmen memiliki sejumlah kelemahan yang mengganggu. Sebagai contoh, di dalamnya itu diperlukan untuk memuat sebanyak 4 byte, bukan dua di 8086 dan salah satu dari empat ini berlebihan. Sistem perintah 68000 mengungkapkan banyak kesamaan dengan sistem perintah PDP-11 yang dikembangkan kembali di tahun 60an.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode untuk Motorola terlihat lebih tebal dan canggung dibandingkan dengan x86 atau ARM. Di sisi lain, 68.000 masih lebih cepat dari 8086, menurut perkiraan saya, sekitar 20-30%. Namun, kode 680x0 juga memiliki keindahan dan keanggunan khusus, karakteristik mekanis yang kurang dari x86. Selain itu, seperti yang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ditunjukkan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oleh komunikasi dengan para ahli </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">eab.abime.net</font></a><font style="vertical-align: inherit;"> , kepadatan kode 68k seringkali lebih baik daripada x86.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara keseluruhan, 68000 adalah prosesor yang baik, dengan sistem instruksi yang besar. Itu digunakan di banyak komputer pribadi legendaris: di komputer Apple Macintosh pertama, yang diproduksi sebelum awal tahun 90-an, di komputer multimedia pertama Commodore Amiga, di komputer Atari ST yang relatif murah dan berkualitas tinggi. The 68.000 juga digunakan dalam komputer yang relatif murah yang bekerja dengan varian Unix, khususnya di Tandy 16B yang agak populer. Menariknya, IBM bersamaan dengan pengembangan PC memimpin pengembangan sistem System 9000 berbasis 68000, yang dirilis kurang dari setahun setelah PC.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">68010 tampak jelas terlambat, hanya pada tahun 1982, pada saat yang sama Intel merilis 80286, yang menempatkan komputer pribadi pada tingkat komputer mini. 68010 kompatibel dengan konektor 68000, tetapi sistem perintahnya sedikit berbeda, jadi mengganti 68000 dengan 68010 belum menjadi populer. Ketidakcocokan disebabkan oleh alasan yang tidak masuk akal untuk membawa 68.000 lebih sejalan dengan teori ideal pengorganisasian dukungan virtualisasi. 68010 hanya sedikit, tidak lebih dari 10% lebih cepat dari 68000. Jelas bahwa 68010 kehilangan banyak untuk 80.286 dan bahkan lebih lemah dari 80.186 yang muncul pada tahun yang sama. Seperti 80186, 68010 hampir tidak pernah menemukan penggunaannya di komputer pribadi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">68008 juga dirilis pada tahun 1982, mungkin dengan harapan mengulang kesuksesan 8088. Ini adalah 68000, tetapi dengan bus data 8-bit, yang memungkinkannya untuk digunakan dalam sistem yang lebih murah. Tetapi 68008, seperti 68000, tidak memiliki baris perintah, yang membuatnya sekitar 50% lebih lambat dari 68000. Dengan demikian, 68008 bahkan bisa sedikit lebih lambat dari 8088, yang, karena baris perintah, hanya sekitar 20% lebih lambat dari 8086.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berdasarkan hal ini, Sir Clive Sinclair membuat Spectrum QL - komputer yang sangat menarik yang, karena harganya yang lebih murah, dapat bersaing dengan Atari ST dan komputer sejenis. Tetapi Clive secara bersamaan dan jelas sebelum waktunya mulai menginvestasikan banyak energi dalam pengembangan kendaraan listrik, menjadikan QL (Quantum leap - quantum leap) sebagai tugas sekunder, yang, dengan beberapa solusi desain yang tidak berhasil, membuat komputer Clive dan seluruh perusahaan tutup secara prematur (perusahaan menjadi bagian Amstrad, yang menolak untuk memproduksi QL). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akan menarik untuk menghitung indeks bit untuk 68000, menurut saya itu jelas lebih tinggi dari 16, meskipun lebih mungkin tidak lebih tinggi dari 24.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah muncul pada tahun 1984, 68020 kembali mengembalikan Motorola ke posisi pertama. Prosesor ini telah menerapkan banyak produk baru yang sangat menarik dan menjanjikan. Efek terkuat tentu saja dihasilkan oleh pipa instruksi, yang terkadang memungkinkan Anda untuk mengeksekusi hingga tiga instruksi sekaligus! Bus alamat 32-bit tampak agak prematur pada tahun-tahun itu, dan karena itu versi yang lebih murah dari prosesor 68020EC dengan bus 24-bit diproduksi. Tetapi bus data 32-bit tampak cukup tepat dan memungkinkan untuk mempercepat pekerjaan secara signifikan. Hal yang baru juga terlihat pada cache bawaan, walaupun kecil, 256 byte, dalam volume, yang memungkinkan untuk secara signifikan meningkatkan kinerja, karena memori dinamis utama tidak dapat lagi mengikuti prosesor. Operasi yang cukup cepat ditambahkan untuk pembagian (64/32 = 32.32) dan multiplikasi (32 * 32 = 64), masing-masing untuk sekitar 80 dan hingga 45 langkah.Pengaturan waktu instruksi secara umum ditingkatkan secara signifikan, misalnya, pembagian (32/16 = 16.16) mulai dilakukan dalam sekitar 45 siklus (lebih dari 140 siklus pada 68.000). Beberapa instruksi, dalam kasus yang paling menguntungkan, dapat dieksekusi tanpa mengambil siklus sama sekali! Mode pengalamatan baru ditambahkan, khususnya dengan penskalaan - dalam x86 mode ini hanya muncul tahun depan di 80386. Mode pengalamatan baru lainnya memungkinkan penggunaan pengalamatan ganda tidak langsung, menggunakan beberapa offset pada saat yang sama - PDP-11 secara signifikan dilampaui di sini.dengan penskalaan - dalam x86 mode ini hanya muncul tahun depan di 80386. Mode pengalamatan baru lainnya memungkinkan menggunakan pengalamatan ganda tidak langsung, menggunakan beberapa offset pada saat yang sama - PDP-11 secara signifikan dilampaui di sini.dengan penskalaan - dalam x86 mode ini hanya muncul tahun depan di 80386. Mode pengalamatan baru lainnya memungkinkan menggunakan pengalamatan ganda tidak langsung, menggunakan beberapa offset pada saat yang sama - PDP-11 secara signifikan dilampaui di sini.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi beberapa instruksi baru, misalnya, operasi berat dengan bidang bit atau operasi baru dengan 10 angka yang menjadi tidak perlu selama pembagian cepat dan multiplikasi, tampak lebih seperti roda kelima dalam kereta daripada sesuatu yang pada dasarnya berguna. Mode alamat dengan pengalamatan ganda tidak langsung secara teoritis terlihat menarik, tetapi secara praktis jarang diperlukan dan dijalankan dengan sangat lambat. Tidak seperti 80286, 68020 membutuhkan waktu untuk menghitung alamat operan, yang disebut alamat efektif. Divisi di 68020 ternyata hampir dua kali lebih lambat dari divisi ajaib di 80286. Penggandaan dan beberapa operasi juga lebih lambat. 68020 tidak memiliki sistem manajemen memori terintegrasi (MMU) dan kemampuan eksotis untuk menghubungkan hingga delapan coprocessor tidak dapat memperbaikinya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">68020 digunakan secara luas pada komputer Apple Macintosh II, Macintosh LC, dan Commodore Amiga 1200 yang besar, dan juga digunakan pada beberapa sistem Unix.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Munculnya 80386 dengan built-in dan sangat solid membuat MMU dan bus 32-bit dan register menempatkan Motorola lagi di posisi nomor 2. 68030, setelah muncul pada tahun 1987, untuk terakhir kalinya, mampu mendapatkan kembali kepemimpinan Motorola untuk sementara waktu. 68030 memiliki sistem manajemen memori terintegrasi dan cache berlipat ganda, dibagi menjadi cache untuk instruksi dan data - itu adalah produk baru yang sangat menjanjikan. Selain itu, 68030 dapat menggunakan antarmuka akses memori yang lebih cepat, yang dapat mempercepat operasi memori hampir sepertiga. Namun, terlepas dari semua inovasi, 68030 ternyata sedikit lebih lambat dari 80386 pada frekuensi yang sama. Namun, 68030 tersedia pada frekuensi hingga 50 MHz, dan 80386 hanya hingga 40 MHz, yang membuat sistem teratas berdasarkan 68030 sedikit lebih cepat.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">68030 digunakan di komputer seri Apple Macintosh II, Commodore Amiga 3000, Atari TT, Atari Falcon dan beberapa lainnya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan 68040, Motorola sekali lagi mencoba mengungguli Intel. Prosesor ini muncul setahun kemudian setelah 80486, tetapi dalam hal kombinasi kualitas yang berguna, itu tidak bisa melampaui itu. Faktanya, Motorola, yang memiliki sistem komando yang kelebihan beban, tidak dapat mendukungnya dan, dalam beberapa hal, kehilangan jejak. Pada 68040 mereka hanya dapat menempatkan coprocessor yang sangat terpotong untuk bekerja dengan bilangan real dan chip itu sendiri memanas secara signifikan lebih dari 80486. Menurut hasil pada lowendmac.com/benchmarks 68040, hanya sekitar 2,1 kali lebih cepat dari 68030, yang berarti bahwa 68040 sedikit lebih lambat dari 80486 pada yang frekuensi yang sama. 68040 praktis tidak menemukan aplikasi di komputer populer. Hanya opsi yang lebih murah, 68LC040, yang tidak memiliki coprocessor terintegrasi, menemukan beberapa penggunaan yang nyata. Namun demikianVersi pertama dari chip ini memiliki cacat perangkat keras yang serius, yang bahkan tidak memungkinkan penggunaan perangkat lunak emulasi coprocessor!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motorola selalu memiliki masalah dengan koprosesor matematika. </font><font style="vertical-align: inherit;">Motorola, seperti yang telah disebutkan, belum merilis coprocessor untuk 68000/68010, sementara Intel merilis 8087 yang sangat sukses sejak 1980. Untuk prosesor 68020/68030, dua 68881 coprocessor dan versi yang kompatibel dengan pin yang disempurnakan 68882 diproduksi sekaligus. Tetapi untuk mendapatkan peningkatan kinerja yang signifikan, kode untuk 68882 perlu dikompilasi secara berbeda dari untuk 68881. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sangat tepat untuk mengatakan bahwa Intel x86 masih memiliki masalah dengan koprosesor matematika - keakuratan perhitungan beberapa fungsi, misalnya, sinus pada beberapa argumen, sangat kecil, </font><font style="vertical-align: inherit;">terkadang tidak lebih dari 4 karakter. </font><font style="vertical-align: inherit;">Oleh karena itu, kompiler modern sering menghitung fungsi-fungsi seperti itu tanpa menggunakan jasa coprocessor.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Semikonduktor Nasional 32016 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah prosesor 32-bit nyata pertama yang diusulkan untuk digunakan di komputer pada tahun 1982. Prosesor ini awalnya direncanakan sebagai VAX-11 pada sebuah chip, tetapi karena ketidakmampuan untuk bernegosiasi dengan DEC, National Semiconductor (NS) harus membuat prosesor hanya bagian-bagian yang terpisah yang serupa. pada arsitektur VAX-11. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penggunaan memori virtual paged dimulai dengan prosesor ini - hari ini adalah teknologi yang dominan. Tetapi dukungan untuk memori virtual tidak dibangun ke dalam prosesor, tetapi membutuhkan coprocessor. Coprocessor terpisah juga diperlukan untuk bekerja dengan bilangan real.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sistem instruksi NS32016 sangat besar dan mirip dengan sistem instruksi VAX-11, khususnya, dengan tumpukan terpisah untuk bingkai subprogram. Bus alamat adalah 24-bit, yang memungkinkan Anda untuk menggunakan memori hingga 16 MB. Fitur 32016 adalah karya dengan bendera tanda. Selain bendera carry standar (yang juga dapat digunakan sebagai tanda untuk transisi bersyarat), melimpah, tanda, kesetaraan (atau nol), ada juga bendera L (kurang), artinya kurang seperti carry carry untuk perbandingan. Situasi transfer mirip dengan prosesor Motorola 680x0. Bendera melimpah untuk beberapa alasan disebut F. Ada bendera mode langkah-demi-langkah, mode istimewa dan (keunikan!) Tandai untuk memilih tumpukan saat ini. Saat melakukan instruksi aritmatika, flag dari tanda, nol, minoritas (L) tidak diatur, mereka ditetapkan hanya dengan perintah perbandingan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat menggunakan delapan register tujuan umum 32-bit. Selain itu, ada juga penghitung perintah, dua penunjuk tumpukan, penunjuk bingkai sub-program penunjuk, penunjuk basis program (ini adalah sesuatu yang unik), penunjuk basis modul (juga sesuatu yang sangat jarang), penunjuk ke tabel vektor interupsi, konfigurasi register dan register kondisi. Dalam hal kecepatan, NS32016 sebanding dengan 68.000.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32016, sejauh yang saya tahu, hanya digunakan dengan komputer pribadi BBC Micro sebagai prosesor kedua. </font><font style="vertical-align: inherit;">Itu adalah awalan yang sangat mahal dan bergengsi untuk tahun 1984. </font><font style="vertical-align: inherit;">Dimungkinkan untuk memesan prosesor dengan frekuensi 6, 8 dan 10 MHz. </font><font style="vertical-align: inherit;">Ada beberapa masalah teknis dengan yang terakhir dan itu sangat mahal. </font><font style="vertical-align: inherit;">Ada sangat sedikit perangkat lunak untuk 32016, hanya dibuat oleh Acorn, sistem operasi Unix seperti Panos dan Acorn BASIC. </font><font style="vertical-align: inherit;">BBC Micro tidak menggunakan chip MMU - meskipun bisa dihubungkan, tidak ada program untuk menggunakannya. </font><font style="vertical-align: inherit;">Coprosesor aritmatika bahkan tidak disediakan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prosesor yang sangat kompleks ini diketahui memiliki kesalahan perangkat keras serius yang telah diperbaiki selama bertahun-tahun.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lengan acorn </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ideologi 6502, yaitu, untuk membuatnya lebih sederhana, lebih murah, dan lebih baik, dilanjutkan dalam perkembangan yang hampir fantastis dari Acorn, prosesor ARM-1, dirilis pada tahun 1985, pada saat yang sama dengan keajaiban teknologi Intel, prosesor 80386. ARM terdiri dari urutan besarnya lebih kecil jumlah transistor dan karena itu mengkonsumsi energi lebih sedikit dan rata-rata jauh lebih cepat. Tentu saja, ARM tidak memiliki MMU atau bahkan operasi divisi dan multiplikasi, sehingga dalam beberapa perhitungan berdasarkan divisi 80386 bisa lebih cepat. Namun, keunggulan ARM begitu besar sehingga saat ini merupakan arsitektur prosesor yang paling masif. Lebih dari 100 miliar prosesor semacam itu telah dirilis.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengembangan ARM pada tahun 1983 dimulai setelah Acorn melakukan penelitian dengan prosesor 32016, yang menunjukkan bahwa, dalam banyak perhitungan, 6502 bisa setengah frekuensi operasi lebih cepat daripada ini, tampaknya, prosesor yang jauh lebih kuat. Kemudian 80286 sudah tersedia, yang menunjukkan kinerja yang sangat baik, tetapi Intel, mungkin merasakan potensi yang agak kecil dari perusahaan kecil Acorn, menolak untuk menyediakan prosesornya untuk pengujian. Pada saat yang sama, teknologi 80286 tidak ditutup seperti 80386 dan dipindahkan ke banyak perusahaan, sehingga sejarah masih menunggu perincian untuk diungkapkan dari kegagalan yang agak tidak biasa ini. Mungkin jika Intel diizinkan menggunakan prosesornya, maka Acorn akan menggunakannya, dan tidak akan mulai mengembangkan ARM.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ARM dikembangkan oleh hanya beberapa orang, dan menguji sistem komando menggunakan BBC Micro BASIC. Pengembangannya sendiri berlangsung di gedung bekas ruang utilitas, yang sering disebut gudang atau gudang. Debut prosesor ternyata agak gagal. Pada tahun 1986, set-top box Mikro BBC dengan nama sistem Evaluasi ARM dirilis, yang berisi tambahan prosesor 4 MB memori (ini banyak untuk tahun-tahun itu), yang membuat set-top box ini produk yang sangat mahal (harganya lebih dari Â£ 4.000, yaitu sekitar $ 6.000). Tentu saja, jika Anda membandingkannya dengan komputer pada waktu itu dengan kemampuan yang sebanding dalam kecepatan, maka awalannya ternyata menjadi urutan besarnya atau bahkan hampir dua lebih murah. Tetapi ada sangat sedikit program untuk sistem baru. Dan ini sedikit anehkarena sangat mungkin untuk mem-porting Unix ke sistem ini - maka banyak varian Unix tersedia yang tidak memerlukan MMU, ada varian Unix untuk PDP-11, 68000, 80186 dan bahkan 8088. Aneh bahwa di tahun 90-an Acorn Archimedes diangkut Linux Mungkin keterlambatan dengan diperkenalkannya Unix untuk ARM yang sebenarnya disebabkan oleh keengganan Acorn untuk mentransfer teknologi ARM ke perusahaan lain.</font></font><br><br><img src="http://www.computinghistory.org.uk/userdata/images/large/70/88/product-77088.jpg"><br> <i>    ARM</i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kebijakan pemasaran Acorn yang tidak berhasil menyebabkan perusahaan mengalami situasi keuangan yang sangat sulit pada tahun 1985. Acorn, selain ARM, juga mencoba melakukan pengembangan komputer yang mahal untuk bisnis, yang gagal, khususnya, karena kekurangan prosesor 32016 yang dipilih untuk mereka. Acorn Communicator juga tidak terlalu berhasil. Pengembangan komputer Master 512 yang relatif sukses, tetapi tidak cukup IBM PC kompatibel sangat mahal. Selain itu, banyak sumber daya keuangan dihabiskan dalam upaya yang gagal untuk memasuki pasar AS, dimana perusahaan Italia Olivetti, dengan komputernya yang agak sukses berdasarkan Intel 8086 dan 80286, diizinkan untuk masuk dalam kerangka permainan besar hipotetis untuk mengambil alih Acorn. By the way, setelah pengambilalihan Acorn,Peran Olivetti di pasar AS berkurang dengan cepat.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sudah sebagai bagian dari Olivetti Acorn telah mengembangkan chip ARM2 yang ditingkatkan dengan perintah multiplikasi bawaan, berdasarkan yang mana komputer pribadi Archimedes, yang kemudian luar biasa dengan kecepatannya, dibuat, model pertama yang tersedia pada tahun 1987. Namun, kontrol Olivetti berorientasi pada bekerja dengan komputer yang kompatibel dengan PC IBM dan Dia tidak ingin menggunakan sumber dayanya untuk menjual produk Acorn.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ARM menyediakan 16 register 32-bit untuk digunakan (sebenarnya ada lebih banyak dari mereka jika kita mempertimbangkan register untuk kebutuhan sistem). Salah satu register, R15, seperti arsitektur PDP-11, adalah penghitung perintah. Hampir semua operasi dilakukan dalam 1 siklus. Diperlukan lebih banyak langkah, khususnya, untuk transisi, multiplikasi, dan akses memori. Sebagai perbandingan, dengan prosesor utama tahun-tahun itu, ARM dibedakan oleh tidak adanya struktur khas seperti tumpukan. Tumpukan diimplementasikan, jika perlu, melalui salah satu register. Saat memanggil subrutin, stack tidak digunakan, sebagai gantinya, alamat pengirim disimpan dalam register yang dialokasikan untuknya. Skema seperti itu jelas tidak berfungsi untuk panggilan bersarang, di mana Anda harus mengatur tumpukan. Fitur unik ARM adalah kombinasi dari penghitung perintah, yaitu 26-bit, yang memungkinkan pengalamatan hingga 64 MB dengan register negara.Delapan bit dialokasikan untuk bendera dalam register gabungan ini, dua bit tambahan tambahan dalam register ini diperoleh karena fakta bahwa dua bit alamat yang lebih rendah tidak digunakan, karena kode harus disejajarkan di perbatasan kata 4-byte. Prosesor dapat mengakses kata-kata byte dan 4-byte, tidak dapat secara langsung mengakses data 16-bit. Instruksi data ARM adalah 3-alamat. Fitur karakteristik arsitektur RISC adalah penggunaan perintah tipe register-memory hanya untuk memuat dan membongkar data. ARM memiliki bit shifter built-in cepat (Barrel Shifter), yang memungkinkan Anda untuk menggeser nilai salah satu register dalam perintah beberapa kali tanpa biaya siklus clock. Sebagai contoh, mengalikan nilai register R0 dengan 65 dengan menempatkan hasil dalam register R1 dapat ditulis dengan satu perintah penambahan siklus tunggalmengalikan nilai register R0 dengan 65 dengan menempatkan hasilnya dalam register R1 dapat ditulis dengan satu perintah penambahan siklus tunggal</font></font><br><br><pre> <code class="plaintext">ADD R1, R0, R0 shl 6</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan mengalikan dengan 63 dengan perintah</font></font><br><br><pre> <code class="plaintext">RSB R1, R0, R0 shl 6</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sistem perintah memiliki pengurangan kembali, yang memungkinkan, khususnya, untuk memiliki minus unary sebagai kasus khusus dari perintah ini dan mempercepat prosedur pembagian. ARM memiliki fitur unik lain: semua instruksinya bersyarat. Ada 16 case (kombinasi flag) yang dilampirkan pada setiap instruksi. Instruksi dijalankan hanya jika set flag saat ini cocok dengan set dalam instruksi ini. Dalam prosesor arsitektur lain, eksekusi tersebut terjadi, sebagai suatu peraturan, hanya untuk transisi bersyarat. Fitur ARM ini memungkinkan dalam banyak kasus untuk menghindari operasi transisi yang lambat. Yang terakhir juga berkontribusi pada fakta bahwa ketika melakukan operasi aritmatika, Anda dapat menolak untuk mengatur bendera status. Dengan ARM, seperti prosesor 6809, Anda dapat menggunakan interupsi cepat dan reguler. Jugadalam mode interupsi, register dengan angka tinggi digantikan oleh register sistem, yang membuat penangan interupsi lebih kompak dan lebih cepat.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sistem instruksi ARM mengandung instruksi dasar yang jauh lebih sedikit daripada sistem instruksi prosesor x86. Tetapi instruksi itu sendiri di ARM sangat fleksibel dan kuat. Beberapa instruksi ARM yang sangat mudah dan kuat tidak memiliki analog untuk 80386, misalnya, RSB (reverse subtraction), BIC (DAN dengan inversi, PDP-11 memiliki perintah seperti itu), 4-address MLA (perkalian dengan penjumlahan), LDM dan STM ( memuat atau menurunkan beberapa register dari memori, mirip dengan perintah MOVEM untuk prosesor 68k). Hampir semua instruksi ARM adalah 3-address, dan hampir semua instruksi 80386 tidak memiliki lebih dari 2 operan. Sistem instruksi ARM lebih ortogonal - semua register dapat dipertukarkan, hanya register R14 dan R15 yang membuat beberapa pengecualian. Sebagian besar perintah ARM dapat membutuhkan 3-4 80386 perintah untuk emulasi mereka, dan sebagian besar 80386 perintah dapat ditiru dengan 2-3 perintah ARM. Menarikbahwa emulator IBM PC XT pada Acorn Archimedes perangkat keras komputer dengan prosesor 8 MHz bahkan lebih cepat daripada komputer PC XT yang sebenarnya. Pada komputer Commodore Amiga dengan prosesor 68000 pada 7 MHz, emulator hanya dapat bekerja pada kecepatan tidak lebih dari 10-15% dari PC XT nyata. Juga sangat menarik bahwa komputer NeXT pertama dengan 25 MHz 68030 menunjukkan kinerja perhitungan integer pada level ARM 8 MHz yang sama. Apple akan membuat komputer penerus Apple dalam proyek MÃ¶bius] [, tetapi ketika ternyata prototipe komputer ini dalam mode emulasi tidak hanya menyalip Apple] [, tetapi juga Macintosh berdasarkan prosesor 68k, proyek ditutup!Pada komputer Commodore Amiga dengan prosesor 68000 pada 7 MHz, emulator hanya dapat bekerja pada kecepatan tidak lebih dari 10-15% dari PC XT nyata. Juga sangat menarik bahwa komputer NeXT pertama dengan 25 MHz 68030 menunjukkan kinerja perhitungan integer pada level ARM 8 MHz yang sama. Apple akan membuat komputer penerus Apple dalam proyek MÃ¶bius] [, tetapi ketika ternyata prototipe komputer ini dalam mode emulasi tidak hanya menyalip Apple] [, tetapi juga Macintosh berdasarkan prosesor 68k, proyek ditutup!Pada komputer Commodore Amiga dengan prosesor 68000 pada 7 MHz, emulator hanya dapat bekerja pada kecepatan tidak lebih dari 10-15% dari PC XT nyata. Juga sangat menarik bahwa komputer NeXT pertama dengan 25 MHz 68030 menunjukkan kinerja perhitungan integer pada level ARM 8 MHz yang sama. Apple akan membuat komputer penerus Apple dalam proyek MÃ¶bius] [, tetapi ketika ternyata prototipe komputer ini dalam mode emulasi tidak hanya menyalip Apple] [, tetapi juga Macintosh berdasarkan prosesor 68k, proyek ditutup!bahwa prototipe komputer ini dalam mode emulasi menyalip tidak hanya Apple] [, tetapi juga Macintosh berdasarkan prosesor 68k, proyek ditutup!bahwa prototipe komputer ini dalam mode emulasi menyalip tidak hanya Apple] [, tetapi juga Macintosh berdasarkan prosesor 68k, proyek ditutup!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di antara kelemahan ARM, orang dapat memilih masalah memuat konstanta ke dalam register. Anda hanya dapat memuat 8 bit sekaligus, meskipun konstanta dapat dibalik dan digeser. Oleh karena itu, memuat konstanta 32-bit penuh dapat memakan waktu hingga 4 perintah. Anda dapat, tentu saja, memuat konstanta dari memori dengan satu perintah, tetapi muncul masalah menentukan alamat kuantitas ini, karena offset hanya bisa 12-bit. Kerugian lain dari ARM adalah kepadatan kode yang relatif rendah, yang membuat program agak lebih besar, dan yang paling penting mengurangi efisiensi cache prosesor. Namun, ini mungkin lebih merupakan konsekuensi dari kompiler berkualitas rendah untuk platform ini. Untuk waktu yang lama, kelemahan ARM yang signifikan adalah kurangnya dukungan built-in untuk manajemen memori (MMU) - dukungan ini, misalnya, diperlukan oleh Apple pada awal 90-an.Co-prosesor untuk bekerja dengan bilangan real untuk arsitektur ARM juga mulai digunakan dengan penundaan yang signifikan. ARM tidak memiliki alat debugging canggih yang dimiliki x86. Masih ada beberapa keanehan dalam bahasa assembler standar untuk ARM: adalah kebiasaan untuk menulis operasi bit shifter yang dipisahkan oleh koma. Jadi, bukannya bentuk yang sederhana</font></font><pre> <code class="plaintext">R1 shl 7</code> </pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Geser isi register R1 sebanyak 7 bit ke kiri - Anda perlu menulis </font></font><pre> <code class="plaintext">R1, shl 7</code> </pre>  . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sejak 1989, ARM3 dengan cache bawaan menjadi tersedia. </font><font style="vertical-align: inherit;">Pada tahun 1990, tim pengembangan ARM memisahkan diri dari Acorn dan menciptakan ARM Holding menggunakan Apple dan VLSI. </font><font style="vertical-align: inherit;">Salah satu alasan pemisahan ini adalah biaya pengembangan ARM yang terlalu tinggi, menurut manajemen Acorn-Olivetti. </font><font style="vertical-align: inherit;">Selanjutnya, Acorn tidak lagi berdiri sendiri, dan ARM Holding berubah menjadi perusahaan besar. </font><font style="vertical-align: inherit;">Pemisahan Acorn dan ARM Holding juga diprakarsai oleh keinginan Apple untuk memiliki prosesor ARM di komputer Newton dan tidak bergantung pada produsen komputer lain.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ARM menunjukkan kinerja pada data integer, melebihi 80486 pada frekuensi yang sama 10-20%! </font><font style="vertical-align: inherit;">Intel dapat mencapai manfaat menggunakan teknologi multiplikasi jam dan kemudian memperbaikinya dengan prosesor Pentium. </font><font style="vertical-align: inherit;">DEC StrongARM berhasil mendapatkan kembali kepemimpinan untuk waktu yang singkat pada tahun 1996, setelah itu teknologi ini dibeli oleh Intel, yang sejak itu menjadi produsen utama prosesor arsitektur ARM. </font><font style="vertical-align: inherit;">Dengan demikian, ada dua pusat pengembangan arsitektur ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengembangan lebih lanjut dari teknologi ARM juga sangat ingin tahu, tapi itu cerita lain. </font><font style="vertical-align: inherit;">Meskipun dapat disebutkan bahwa itu berkat saham di Holding ARM bahwa Apple di tahun 90-an dapat menghindari kebangkrutan.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beberapa kesimpulan, asumsi dan pertanyaan. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sulit untuk menghilangkan perasaan bahwa prosesor 8-bit ternyata hanya kebutuhan yang tidak diinginkan untuk karakter utama yang bertindak di tahun 70-an dan 80-an di panggung sejarah komputer. 8-beater 6502 8 paling sukses sebenarnya beku. Intel dan Motorola agak memperlambat pengembangan prosesor kecil mereka sendiri, dan menahan pengembang lain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya hampir yakin bahwa Amiga atau Atari ST akan bekerja lebih baik dan lebih cepat pada prosesor 4 MHz dengan alamat 20 atau 24-bit yang kompatibel dengan 6502 daripada dengan 68000. Bill Mensch baru-baru ini menyatakan bahwa 6502 pada 10 GHz tidak sulit dilakukan hari ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika seri Amstrad PCW, yang keberhasilannya dapat dibagikan oleh Commodore CBM II, mulai menggunakan z80 yang dioptimalkan pada frekuensi yang lebih tinggi, maka sangat mungkin seri ini relevan 10 tahun yang lalu.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akan seperti apa dunia jika ARM dibuat pada tahun 1982, yang sepenuhnya mungkin? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akan seperti apa komputer domestik jika mereka disalin dan dikembangkan bukan yang paling mahal, tetapi teknologi yang paling menjanjikan?</font></font><p></p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id410591/">https://habr.com/ru/post/id410591/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id410581/index.html">Penyalahgunaan alkohol adalah cara tercepat menuju demensia</a></li>
<li><a href="../id410583/index.html">Samsung Gear VR: tayangan setelah sebulan digunakan</a></li>
<li><a href="../id410585/index.html">Bagaimana menjadi pesulap (bagian 1)</a></li>
<li><a href="../id410587/index.html">Apple bermaksud membeli kobalt secara eksklusif dari perusahaan pertambangan</a></li>
<li><a href="../id410589/index.html">Ekosistem laut mampu beradaptasi dengan pemanasan global</a></li>
<li><a href="../id410593/index.html">Telegram melakukan putaran ICO yang lain</a></li>
<li><a href="../id410597/index.html">Perangkat rumah pintar lainnya</a></li>
<li><a href="../id410599/index.html">Gelombang pencurian peralatan dari ladang tambang menyapu Islandia</a></li>
<li><a href="../id410601/index.html">Apa itu robotika pendidikan saat ini</a></li>
<li><a href="../id410603/index.html">Manifesto of Propriety</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>