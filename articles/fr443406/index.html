<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìú üë©üèº‚Äç‚úàÔ∏è üéÜ Les 20 principales erreurs lors de l'utilisation du multithreading en C ++ et les moyens de les √©viter üëΩ ü§≥üèæ üöπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! J'attire votre attention sur une traduction de l'article ¬´Top 20 des erreurs de multithreading C ++ et comment les √©viter¬ª de Deb Halda...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Les 20 principales erreurs lors de l'utilisation du multithreading en C ++ et les moyens de les √©viter</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443406/">  Bonjour, Habr!  J'attire votre attention sur une traduction de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´Top 20 des erreurs de multithreading C ++ et comment les √©viter¬ª</a> de Deb Haldar. <br><br><img src="https://habrastorage.org/webt/wi/a8/4v/wia84vtxrf1vqym4rwoynnvtfw0.jpeg" title="KDPV. Sc√®ne du film ¬´La boucle du temps (2012)¬ª"><br>  <i>Sc√®ne du film ¬´La boucle du temps¬ª (2012)</i> <br><br>  Le multithreading est l'un des domaines les plus difficiles de la programmation, en particulier en C ++.  Au fil des ann√©es de d√©veloppement, j'ai fait de nombreuses erreurs.  Heureusement, la plupart d'entre eux ont √©t√© identifi√©s par un examen du code et des tests.  N√©anmoins, certains ont en quelque sorte gliss√© sur le productif, et nous avons d√ª √©diter les syst√®mes d'exploitation, ce qui est toujours cher. <br><br>  Dans cet article, j'ai essay√© de classer toutes les erreurs que je connais avec des solutions possibles.  Si vous avez connaissance d'autres √©cueils ou avez des suggestions pour r√©soudre les erreurs d√©crites, veuillez laisser vos commentaires sous l'article. <br><a name="habracut"></a><br><h3>  Erreur # 1: n'utilisez pas join () pour attendre les threads d'arri√®re-plan avant de quitter l'application </h3><br>  Si vous oubliez de rejoindre le flux ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">join ()</a> ) ou de le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©tacher</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">detach ()</a> ) (le rendre non joignable) avant la fin du programme, cela entra√Ænera un plantage.  (La traduction contiendra les mots join dans le contexte de <i>join ()</i> et <i>detach</i> dans le contexte de <i>detach ()</i> , bien que ce ne soit pas tout √† fait correct. En fait, <i>join ()</i> est le point auquel un thread d'ex√©cution attend l'ach√®vement d'un autre, et aucune jointure ou fusion de threads ne se produit [traducteur de commentaires]). <br><br>  Dans l'exemple ci-dessous, nous avons oubli√© d'ex√©cuter <i>join () du</i> thread t1 dans le thread principal: <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Launching Rocket"</font> <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">//t1.join(); //     join-     </font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br>  Pourquoi le programme s'est-il bloqu√©?!  Parce qu'√† la fin de la fonction <i>main ()</i> , la variable t1 est hors de port√©e et le destructeur de threads a √©t√© appel√©.  Le destructeur v√©rifie si le thread t1 est <i>joignable</i> .  Un thread peut √™tre <i>joint</i> s'il n'a pas √©t√© d√©tach√©.  Dans ce cas, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">std :: terminate</a> est appel√© dans son destructeur.  Voici ce que fait, par exemple, le compilateur MSVC ++. <br><br> <code>~thread <font color="#008000">(</font> <font color="#008000">)</font> _NOEXCEPT <br> <font color="#008000">{</font> <font color="#666666">// clean up</font> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> joinable <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> XSTD terminate <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  Il existe deux fa√ßons de r√©soudre le probl√®me, selon la t√¢che: <br><br>  1. Appelez <i>join () du</i> thread t1 dans le thread principal: <br><br> <code><font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//  join  t1,        </font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  2. D√©tachez le flux t1 du flux principal, laissez-le continuer √† fonctionner comme un flux ¬´diabolis√©¬ª: <br><br> <code><font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">detach</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//   t1   </font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br><h3>  Erreur n ¬∞ 2: essayer de joindre un fil qui a √©t√© pr√©c√©demment d√©tach√© </h3><br>  Si, √† un moment donn√© du travail du programme, vous avez un flux de <i>d√©tachement</i> , vous ne pouvez pas le rattacher au flux principal.  C'est une erreur tr√®s √©vidente.  Le probl√®me est que vous pouvez d√©tacher le flux, puis √©crire quelques centaines de lignes de code et essayer de le rattacher.  Apr√®s tout, qui se souvient qu'il a √©crit 300 lignes en arri√®re, non? <br><br>  Le probl√®me est que cela ne provoquera pas d'erreur de compilation, mais que le programme plantera au d√©marrage.  Par exemple: <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Launching Rocket"</font> <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">detach</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">//..... 100  - </font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">// CRASH !!!</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  La solution consiste √† toujours v√©rifier le thread pour <i>joinable ()</i> avant d'essayer de le joindre au thread appelant. <br><br> <code><font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">detach</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">//..... 100  - </font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> t1. <font color="#007788">joinable</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><h3>  Erreur # 3: Incompr√©hension selon laquelle std :: thread :: join () bloque le thread d'appel d'ex√©cution </h3><br>  Dans les applications r√©elles, vous devez souvent s√©parer les op√©rations ¬´de longue dur√©e¬ª de traitement des E / S r√©seau ou attendre qu'un utilisateur clique sur un bouton, etc.  Un appel √† <i>join ()</i> pour de tels flux de travail (par exemple, le thread de rendu de l'interface utilisateur) peut entra√Æner le blocage de l'interface utilisateur.  Il existe des m√©thodes de mise en ≈ìuvre plus adapt√©es. <br><br>  Par exemple, dans les applications GUI, un thread de travail, une fois termin√©, peut envoyer un message au thread d'interface utilisateur.  Le flux d'interface utilisateur a sa propre boucle de traitement des √©v√©nements tels que: d√©placer la souris, appuyer sur les touches, etc.  Cette boucle peut √©galement recevoir des messages des threads de travail et y r√©pondre sans avoir √† appeler la m√©thode blocking <i>join ()</i> . <br><br>  Pour cette raison, presque toutes les interactions utilisateur dans la plate-forme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WinRT</a> de Microsoft sont rendues asynchrones et aucune alternative synchrone n'est disponible.  Ces d√©cisions ont √©t√© prises pour garantir que les d√©veloppeurs utiliseront l'API qui offre la meilleure exp√©rience utilisateur possible.  Vous pouvez vous r√©f√©rer au manuel ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Modern C ++ et applications Windows Store</a> ¬ª pour plus d'informations sur ce sujet. <br><br><h3>  Erreur # 4: en supposant que les arguments de la fonction de flux sont pass√©s par r√©f√©rence par d√©faut </h3><br>  Les arguments de la fonction de flux sont pass√©s par valeur par d√©faut.  Si vous devez apporter des modifications aux arguments pass√©s, vous devez les passer par r√©f√©rence √† l'aide de la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">std :: ref ()</a> . <br><br>  Sous le spoiler, des exemples d'un autre article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C ++ 11 sur le multithreading Tutorial via Q&amp;A - Thread Management Basics (Deb Haldar)</a> , illustrant le passage de param√®tres [env.  traducteur]. <br><br><div class="spoiler">  <b class="spoiler_title">plus de d√©tails:</b> <div class="spoiler_text">  Lors de l'ex√©cution du code: <br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;string&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;functional&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> ChangeCurrentMissileTarget <font color="#008000">(</font> string <font color="#000040">&amp;</font> targetCity <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> targetCity <font color="#000080">=</font> <font color="#FF0000">"Metropolis"</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" Changing The Target City To "</font> <font color="#000080">&lt;&lt;</font> targetCity <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> string targetCity <font color="#000080">=</font> <font color="#FF0000">"Star City"</font> <font color="#008080">;</font> <br> thread t1 <font color="#008000">(</font> ChangeCurrentMissileTarget, targetCity <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Current Target City is "</font> <font color="#000080">&lt;&lt;</font> targetCity <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  Il sera affich√© dans le terminal: <br> <code>Changing The Target City To Metropolis <br> Current Target City is Star City</code> <br> <br>  Comme vous pouvez le voir, la valeur de la variable <i>targetCity</i> re√ßue par la fonction appel√©e dans le flux par r√©f√©rence n'a pas chang√©. <br><br>  R√©√©crivez le code en utilisant <i>std :: ref ()</i> pour passer l'argument: <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;string&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;functional&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> ChangeCurrentMissileTarget <font color="#008000">(</font> string <font color="#000040">&amp;</font> targetCity <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> targetCity <font color="#000080">=</font> <font color="#FF0000">"Metropolis"</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" Changing The Target City To "</font> <font color="#000080">&lt;&lt;</font> targetCity <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> string targetCity <font color="#000080">=</font> <font color="#FF0000">"Star City"</font> <font color="#008080">;</font> <br> thread t1 <font color="#008000">(</font> ChangeCurrentMissileTarget, std <font color="#008080">::</font> <font color="#007788">ref</font> <font color="#008000">(</font> targetCity <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Current Target City is "</font> <font color="#000080">&lt;&lt;</font> targetCity <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br>  Il produira: <br> <code>Changing The Target City To Metropolis <br> Current Target City is Metropolis</code> <br> <br>  Les modifications apport√©es dans le nouveau thread affecteront la valeur de la variable <i>targetCity</i> d√©clar√©e et initialis√©e dans la fonction <i>principale</i> . <br></div></div><br><h3>  Erreur # 5: Ne prot√©gez pas les donn√©es et les ressources partag√©es avec une section critique (par exemple, un mutex) </h3><br>  Dans un environnement multithread, g√©n√©ralement plusieurs threads rivalisent pour les ressources et les donn√©es partag√©es.  Souvent, cela conduit √† un √©tat incertain pour les ressources et les donn√©es, sauf lorsque leur acc√®s est prot√©g√© par un m√©canisme qui permet √† un seul thread d'ex√©cution d'effectuer des op√©rations sur elles √† tout moment. <br><br>  Dans l'exemple ci-dessous, <i>std :: cout</i> est une ressource partag√©e avec laquelle 6 threads fonctionnent (t1-t5 + main). <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;string&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;mutex&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> std <font color="#008080">::</font> <font color="#007788">mutex</font> mu <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Jupiter"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> thread t2 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Pluto"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> thread t3 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Moon"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> CallHome <font color="#008000">(</font> <font color="#FF0000">"Hello from Main/Earth"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> thread t4 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Uranus"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> thread t5 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Neptune"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t2. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t3. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t4. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t5. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  Si nous ex√©cutons ce programme, nous obtenons la conclusion: <br><br> <code>Thread 0x1000fb5c0 says Hello from Main/Earth <br> Thread Thread Thread 0x700005bd20000x700005b4f000 says says Thread Thread Hello from Pluto0x700005c55000Hello from Jupiter says 0x700005d5b000Hello from Moon <br> 0x700005cd8000 says says Hello from Uranus <br> <br> Hello from Neptune <br></code> <br><br>  En effet, cinq threads acc√®dent simultan√©ment au flux de sortie dans un ordre al√©atoire.  Pour rendre la conclusion plus pr√©cise, vous devez prot√©ger l'acc√®s √† la ressource partag√©e √† l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">std :: mutex</a> .  <i>Modifiez</i> simplement la fonction <i>CallHome ()</i> afin qu'il capture le mutex avant d'utiliser <i>std :: cout</i> et le lib√®re apr√®s. <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> mu. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> mu. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br><h3>  Erreur # 6: Oubliez de lib√©rer le verrou apr√®s avoir quitt√© la section critique </h3><br>  Dans le paragraphe pr√©c√©dent, vous avez vu comment prot√©ger une section critique avec un mutex.  Cependant, appeler les m√©thodes <i>lock ()</i> et <i>unlock ()</i> directement sur le mutex n'est pas l'option pr√©f√©r√©e car vous pouvez oublier de donner le verrou maintenu.  Que se passera-t-il ensuite?  Tous les autres threads qui attendent la lib√©ration de la ressource seront bloqu√©s √† l'infini et le programme peut se bloquer. <br><br>  Dans notre exemple synth√©tique, si vous avez oubli√© de d√©verrouiller le mutex dans l'appel de la fonction <i>CallHome ()</i> , le premier message du flux t1 sera √©mis vers le flux standard et le programme plantera.  Cela est d√ª au fait que le thread t1 a re√ßu un verrou mutex, et les threads restants attendent que ce verrou soit lib√©r√©. <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> mu. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#666666">//mu.unlock();     </font> <br> <font color="#008000">}</font></code> <br> <br>  Ce qui suit est la sortie de ce code - le programme s'est √©cras√©, affichant le seul message dans le terminal, et ne s'est pas termin√©: <br><br> <code>Thread 0x700005986000 says Hello from Pluto <br> <br></code> <br><br>  De telles erreurs se produisent souvent, c'est pourquoi il n'est pas souhaitable d'utiliser les m√©thodes <i>lock () / unlock ()</i> directement √† partir du mutex.  Utilisez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plut√¥t la</a> classe de mod√®le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">std :: lock_guard</a> , qui utilise l'idiome <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RAII</a> pour contr√¥ler la dur√©e de vie du verrou.  Lorsque l'objet <i>lock_guard</i> est cr√©√©, il essaie de reprendre le mutex.  Lorsque le programme quitte la port√©e de l'objet <i>lock_guard</i> , le destructeur est appel√©, ce qui lib√®re le mutex. <br><br>  Nous <i>r√©√©crivons la</i> fonction <i>CallHome () en</i> utilisant l'objet <i>std :: lock_guard</i> : <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//   </font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#666666">//  lock_guard    </font></code> <br> <br><h3>  Erreur n ¬∞ 7: rendre la taille de la section critique plus grande que n√©cessaire </h3><br>  Lorsqu'un thread s'ex√©cute √† l'int√©rieur d'une section critique, tous les autres qui tentent d'y entrer sont essentiellement bloqu√©s.  Nous devons conserver le moins d'instructions possible dans la section critique.  Pour illustrer, un exemple de mauvais code avec une grande section critique est donn√©: <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//   ,    std::cout</font> <br> <br> ReadFifyThousandRecords <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> <font color="#008000">}</font> <font color="#666666">//    lock_guard    mu </font></code> <br> <br>  La m√©thode <i>ReadFifyThousandRecords ()</i> ne modifie pas les donn√©es.  Il n'y a aucune raison de l'ex√©cuter sous verrou.  Si cette m√©thode est ex√©cut√©e pendant 10 secondes, en lisant 50 000 lignes de la base de donn√©es, tous les autres threads seront bloqu√©s inutilement pendant toute cette p√©riode.  Cela peut s√©rieusement affecter les performances du programme. <br><br>  La bonne solution serait de ne conserver dans la section critique que le travail avec <i>std :: cout</i> . <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> ReadFifyThousandRecords <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//         ..    </font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//   ,    std::cout</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> <font color="#008000">}</font> <font color="#666666">//     lock_guard    mu </font></code> <br> <br><h3>  Erreur n ¬∞ 8: prendre plusieurs verrous dans un ordre diff√©rent </h3><br><br>  Il s'agit de l'une des causes les plus courantes de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">blocage</a> , une situation dans laquelle les threads sont bloqu√©s √† l'infini en raison de l'attente de l'acc√®s aux ressources bloqu√©es par d'autres threads.  Prenons un exemple: <br><br><table><tbody><tr><th>  flux 1 </th><th>  flux 2 </th></tr><tr><td>  verrou A </td><td>  serrure B </td></tr><tr><td>  // ... quelques op√©rations </td><td>  // ... quelques op√©rations </td></tr><tr><td>  serrure B </td><td>  verrou A </td></tr><tr><td>  // ... quelques autres op√©rations </td><td>  // ... quelques autres op√©rations </td></tr><tr><td>  d√©verrouiller B </td><td>  d√©verrouiller A </td></tr><tr><td>  d√©verrouiller A </td><td>  d√©verrouiller B </td></tr></tbody></table><br>  Une situation peut se produire dans laquelle le thread 1 tentera de capturer le verrou B et sera bloqu√© car le thread 2 l'a d√©j√† captur√©.  Dans le m√™me temps, le deuxi√®me thread tente de capturer le verrou A, mais ne peut pas le faire, car il a √©t√© captur√© par le premier thread.  Le fil 1 ne peut pas lib√©rer le verrou A tant qu'il ne verrouille pas B, etc.  En d'autres termes, le programme se bloque. <br><br>  Cet exemple de code vous aidera √† reproduire le <i>blocage</i> : <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;string&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;mutex&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> std <font color="#008080">::</font> <font color="#007788">mutex</font> muA <font color="#008080">;</font> <br> std <font color="#008080">::</font> <font color="#007788">mutex</font> muB <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> CallHome_Th1 <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> muA. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">//  - </font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">milliseconds</font> <font color="#008000">(</font> <font color="#0000dd">100</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> muB. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> muB. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> muA. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">void</font> CallHome_Th2 <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> muB. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">// -  </font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">milliseconds</font> <font color="#008000">(</font> <font color="#0000dd">100</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> muA. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> muA. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> muB. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> CallHome_Th1, <font color="#FF0000">"Hello from Jupiter"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> thread t2 <font color="#008000">(</font> CallHome_Th2, <font color="#FF0000">"Hello from Pluto"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t2. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br>  Si vous ex√©cutez ce code, il se bloquera.  Si vous allez plus loin dans le d√©bogueur dans la fen√™tre du thread, vous verrez que le premier thread (appel√© depuis <i>CallHome_Th1 ()</i> ) tente d'obtenir un verrou sur le mutex B, tandis que le thread 2 (appel√© depuis <i>CallHome_Th2 ()</i> ) tente de bloquer le mutex A. Aucun des threads ne peut pas r√©ussir, ce qui conduit √† une impasse! <br><br> <a href=""><img src="https://habrastorage.org/webt/ud/kf/a5/udkfa53cvuh8xsrn8lljglb09fa.png"></a> <br>  (l'image est cliquable) <br><br>  Que pouvez-vous y faire?  La meilleure solution serait de restructurer le code afin que les verrous de verrouillage se produisent dans le m√™me ordre √† chaque fois. <br><br>  Selon la situation, vous pouvez utiliser d'autres strat√©gies: <br><br>  1. Utilisez la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">classe</a> wrapper <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">std :: scoped_lock</a> pour capturer conjointement plusieurs verrous: <br><br> <code>std <font color="#008080">::</font> <font color="#007788">scoped_lock</font> lock <font color="#008000">{</font> muA, muB <font color="#008000">}</font> <font color="#008080">;</font></code> <br> <br>  2. Utilisez la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">classe std :: timed_mutex</a> , dans laquelle vous pouvez sp√©cifier un d√©lai d'attente, apr√®s quoi le verrou sera lib√©r√© si la ressource n'est pas devenue disponible. <br><br> <code>std <font color="#008080">::</font> <font color="#007788">timed_mutex</font> m <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> DoSome <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">milliseconds</font> timeout <font color="#008000">(</font> <font color="#0000dd">100</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">while</font> <font color="#008000">(</font> <font color="#0000ff">true</font> <font color="#008000">)</font> <font color="#008000">{</font> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> m. <font color="#007788">try_lock_for</font> <font color="#008000">(</font> timeout <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">": acquire mutex successfully"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> m. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#0000ff">else</font> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">": can't  acquire mutex, do something else"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font></code> <br> <br><h3>  Erreur # 9: Essayer de saisir deux fois un verrou std :: mutex </h3><br>  Essayer de verrouiller le verrou deux fois entra√Ænera un comportement ind√©fini.  Dans la plupart des impl√©mentations de d√©bogage, cela se bloquera.  Par exemple, dans le code ci-dessous, <i>LaunchRocket ()</i> verrouille le mutex puis appelle <i>StartThruster ()</i> .  Ce qui est curieux, dans le code ci-dessus, vous ne rencontrerez pas ce probl√®me pendant le fonctionnement normal du programme, le probl√®me se produit uniquement lorsqu'une exception est lev√©e, qui s'accompagne d'un comportement ind√©fini ou que le programme se termine anormalement. <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;mutex&gt;</font> <br> <br> std <font color="#008080">::</font> <font color="#007788">mutex</font> mu <font color="#008080">;</font> <br> <br> <font color="#0000ff">static</font> <font color="#0000ff">int</font> counter <font color="#000080">=</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> StartThruster <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> <font color="#666666">// - </font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> ... <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Launching rocket"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <br> counter <font color="#000040">++</font> <font color="#008080">;</font> <br> StartThruster <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">thread</font> t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  Pour r√©soudre ce probl√®me, vous devez corriger le code de mani√®re √† emp√™cher la nouvelle r√©cup√©ration des verrous re√ßus pr√©c√©demment.  Vous pouvez utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">std :: recursive_mutex</a> comme solution de b√©quille, mais une telle solution indique presque toujours une mauvaise architecture du programme. <br><br><h3>  Erreur # 10: Utilisez des mutex lorsque les types std :: atomic sont suffisants </h3><br><br>  Lorsque vous devez modifier des types de donn√©es simples, par exemple, une valeur bool√©enne ou un compteur entier, l'utilisation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">std: atomic</a> donnera g√©n√©ralement de meilleures performances que l'utilisation de mutex. <br><br>  Par exemple, au lieu d'utiliser la construction suivante: <br><br> <code><font color="#0000ff">int</font> counter <font color="#008080">;</font> <br> ... <br> mu. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> counter <font color="#000040">++</font> <font color="#008080">;</font> <br> mu. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br></code> <br><br>  Il vaut mieux d√©clarer une variable comme <i>std :: atomic</i> : <br><br> <code>std <font color="#008080">::</font> <font color="#007788">atomic</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> counter <font color="#008080">;</font> <br> ... <br> <font color="#007788">counter</font> <font color="#000040">++</font> <font color="#008080">;</font></code> <br> <br>  Pour une comparaison d√©taill√©e de mutex et atomique, voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comparaison: programmation sans verrouillage avec atomics en C ++ 11 vs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mutex et serrures RW ¬ª</a> <br><br><h3>  Erreur # 11: cr√©er et d√©truire directement un grand nombre de threads, au lieu d'utiliser un pool de threads gratuits </h3><br>  La cr√©ation et la destruction de threads est une op√©ration co√ªteuse en termes de temps processeur.  Imaginez une tentative de cr√©ation d'un flux pendant que le syst√®me effectue des op√©rations de calcul intensif, par exemple, le rendu de graphiques ou la physique des jeux informatiques.  L'approche souvent utilis√©e pour de telles t√¢ches consiste √† cr√©er un pool de threads pr√©-allou√©s qui peuvent g√©rer des t√¢ches de routine, telles que l'√©criture sur le disque ou l'envoi de donn√©es sur le r√©seau tout au long du cycle de vie du processus. <br><br>  Un autre avantage du pool de threads par rapport √† la g√©n√©ration et √† la destruction de threads vous-m√™me est que vous n'avez pas √† vous soucier de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sursouscription des threads</a> (une situation dans laquelle le nombre de threads d√©passe le nombre de c≈ìurs disponibles et une partie importante du temps du processeur est consacr√©e √† changer de contexte [env. traducteur]).  Cela peut affecter les performances du syst√®me. <br><br>  De plus, l'utilisation du pool nous √©vite d'avoir √† g√©rer le cycle de vie des threads, ce qui se traduit finalement par un code plus compact avec moins d'erreurs. <br><br>  Les deux biblioth√®ques les plus populaires qui impl√©mentent le pool de threads sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Intel Thread Building Blocks (TBB)</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Microsoft Parallel Patterns Library (PPL)</a> . <br><br><h3>  Erreur n ¬∞ 12: ne g√®re pas les exceptions qui se produisent dans les threads d'arri√®re-plan </h3><br>  Les exceptions lev√©es dans un thread ne peuvent pas √™tre g√©r√©es dans un autre thread.  Imaginons que nous ayons une fonction qui l√®ve une exception.  Si nous ex√©cutons cette fonction dans un thread distinct se ramifiant √† partir du thread principal d'ex√©cution, et que nous attendons que nous interceptions toute exception lev√©e √† partir du thread suppl√©mentaire, cela ne fonctionnera pas.  Prenons un exemple: <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include&lt;iostream&gt;</font> <br> <font color="#339900">#include&lt;thread&gt;</font> <br> <font color="#339900">#include&lt;exception&gt;</font> <br> <font color="#339900">#include&lt;stdexcept&gt;</font> <br> <br> <font color="#0000ff">static</font> std <font color="#008080">::</font> <font color="#007788">exception_ptr</font> teptr <font color="#000080">=</font> <font color="#0000ff">nullptr</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">throw</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#008000">(</font> <font color="#FF0000">"Catch me in MAIN"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">thread</font> t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> <font color="#0000ff">const</font> std <font color="#008080">::</font> <font color="#007788">exception</font> <font color="#000040">&amp;</font> ex <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread exited with exception: "</font> <font color="#000080">&lt;&lt;</font> ex. <font color="#007788">what</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" <font color="#000099">\n</font> "</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  Lorsque ce programme est ex√©cut√©, il se bloque, cependant, le bloc catch dans la fonction main () ne s'ex√©cutera pas et ne g√®rera pas l'exception lev√©e dans le thread t1. <br><br>  La solution √† ce probl√®me consiste √† utiliser les fonctionnalit√©s de C ++ 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">std :: exception_ptr</a> est utilis√© pour g√©rer l'exception lev√©e dans le thread d'arri√®re-plan.  Voici les √©tapes √† suivre: <br><br><ul><li>  Cr√©er une instance globale de la classe <i>std :: exception_ptr</i> initialis√©e √† <i>nullptr</i> </li><li>  Dans une fonction qui s'ex√©cute dans un thread s√©par√©, g√©rez toutes les exceptions et d√©finissez la valeur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">std :: current_exception () de la</a> variable globale <i>std :: exception_ptr</i> d√©clar√©e √† l'√©tape pr√©c√©dente </li><li>  V√©rifier la valeur d'une variable globale √† l'int√©rieur du thread principal </li><li>  Si la valeur est d√©finie, utilisez la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">std :: rethrow_exception (exception_ptr p)</a> pour appeler √† plusieurs reprises l'exception pr√©c√©demment intercept√©e, en la passant par r√©f√©rence en tant que param√®tre </li></ul><br>  Le rappel d'une exception par r√©f√©rence ne se produit pas dans le thread dans lequel elle a √©t√© cr√©√©e, cette fonctionnalit√© est donc id√©ale pour g√©rer les exceptions dans diff√©rents threads. <br><br>  Dans le code ci-dessous, vous pouvez g√©rer en toute s√©curit√© l'exception lev√©e dans le thread d'arri√®re-plan. <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include&lt;iostream&gt;</font> <br> <font color="#339900">#include&lt;thread&gt;</font> <br> <font color="#339900">#include&lt;exception&gt;</font> <br> <font color="#339900">#include&lt;stdexcept&gt;</font> <br> <br> <font color="#0000ff">static</font> std <font color="#008080">::</font> <font color="#007788">exception_ptr</font> globalExceptionPtr <font color="#000080">=</font> <font color="#0000ff">nullptr</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">milliseconds</font> <font color="#008000">(</font> <font color="#0000dd">100</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">throw</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#008000">(</font> <font color="#FF0000">"Catch me in MAIN"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> ... <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#666666">//     </font> <br> globalExceptionPtr <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">current_exception</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">thread</font> t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> globalExceptionPtr <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">rethrow_exception</font> <font color="#008000">(</font> globalExceptionPtr <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> <font color="#0000ff">const</font> std <font color="#008080">::</font> <font color="#007788">exception</font> <font color="#000040">&amp;</font> ex <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread exited with exception: "</font> <font color="#000080">&lt;&lt;</font> ex. <font color="#007788">what</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" <font color="#000099">\n</font> "</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><h3>  Erreur # 13: Utilisez des threads pour simuler un fonctionnement asynchrone, au lieu d'utiliser std :: async </h3><br>  Si vous avez besoin du code pour ex√©cuter de mani√®re asynchrone, c'est-√†-dire  sans bloquer le thread principal d'ex√©cution, le meilleur choix serait d'utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">std :: async ()</a> .  Cela revient √† cr√©er un flux et √† passer le code n√©cessaire √† ex√©cuter dans ce flux via un pointeur vers une fonction ou un param√®tre sous la forme d'une fonction lambda.  Cependant, dans ce dernier cas, vous devez surveiller la cr√©ation, l'attachement / d√©tachement de ce thread, ainsi que la gestion de toutes les exceptions qui peuvent se produire dans ce thread.  Si vous utilisez <i>std :: async ()</i> , vous vous lib√©rez de ces probl√®mes et r√©duisez √©galement fortement vos chances de vous retrouver dans une <i>impasse</i> . <br><br>  Un autre avantage significatif de l'utilisation de <i>std :: async</i> est la possibilit√© de r√©cup√©rer le r√©sultat d'une op√©ration asynchrone sur le thread appelant en utilisant l'objet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">std :: future</a> .  Imaginez que nous ayons une fonction <i>ConjureMagic ()</i> qui retourne un int.  Nous pouvons d√©marrer une op√©ration asynchrone, qui d√©finira la valeur future sur le <i>futur</i> objet, une fois la t√¢che termin√©e, et nous pouvons extraire le r√©sultat de l'ex√©cution de cet objet dans le flux d'ex√©cution √† partir duquel l'op√©ration a √©t√© appel√©e. <br><br> <code><font color="#666666">//        future</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> asyncResult2 <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> <font color="#000040">&amp;</font> ConjureMagic <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#666666">//...  -   future   </font> <br> <br> <font color="#666666">//     future</font> <br> <font color="#0000ff">int</font> v <font color="#000080">=</font> asyncResult2. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font></code> <br> <br>  R√©cup√©rer le r√©sultat du thread en cours d'ex√©cution vers l'appelant est plus lourd.  Deux voies sont possibles: <br><br><ol><li>  Passer une r√©f√©rence √† la variable de sortie au flux dans lequel elle enregistrera le r√©sultat. </li><li>  Stockez le r√©sultat dans la variable de champ de l'objet de workflow, qui peut √™tre lue d√®s que le thread a termin√© son ex√©cution. </li></ol><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kurt Guntheroth a</a> constat√© qu'en termes de performances, la surcharge de cr√©ation d'un flux est 14 fois sup√©rieure √† celle de l'utilisation de l' <i>async</i> . <br><br>  Conclusion: utilisez <i>std :: async ()</i> par d√©faut jusqu'√† ce que vous trouviez des arguments solides en faveur de l'utilisation directe de <i>std :: thread</i> . <br><br><h3>  Erreur n ¬∞ 14: n'utilisez pas std :: launch :: async si l'asynchronie est requise </h3><br>  La fonction <i>std :: async ()</i> n'est pas tout √† fait le bon nom, car par d√©faut, elle peut ne pas s'ex√©cuter de mani√®re asynchrone! <br><br>  Il existe deux strat√©gies d'ex√©cution <i>std :: async</i> : <br><br><ol><li>  <i>std :: launch :: async</i> : la fonction pass√©e commence √† s'ex√©cuter imm√©diatement dans un thread s√©par√© </li><li>  <i>std :: launch :: deferred</i> : la fonction pass√©e ne d√©marre pas imm√©diatement, son lancement est retard√© avant que les appels <i>get ()</i> ou <i>wait () ne</i> soient effectu√©s sur l'objet <i>std :: future</i> , qui sera renvoy√© par l'appel <i>std :: async</i> .  Au lieu d'appeler ces m√©thodes, la fonction sera ex√©cut√©e de mani√®re synchrone. </li></ol><br>  Lorsque nous appelons <i>std :: async ()</i> avec des param√®tres par d√©faut, cela commence par une combinaison de ces deux param√®tres, ce qui conduit en fait √† un comportement impr√©visible.  Il existe un certain nombre d'autres difficult√©s associ√©es √† l'utilisation de <i>std: async ()</i> avec la strat√©gie de d√©marrage par d√©faut: <br><br><ul><li>  incapacit√© de pr√©dire l'acc√®s correct aux variables de flux locales </li><li>  une t√¢che asynchrone peut ne pas d√©marrer du tout car les appels aux m√©thodes <i>get ()</i> et <i>wait ()</i> peuvent ne pas √™tre appel√©s pendant l'ex√©cution du programme </li><li>  lorsqu'elles sont utilis√©es dans des boucles dans lesquelles la condition de sortie s'attend √† ce que l'objet std :: future soit pr√™t, ces boucles peuvent ne jamais se terminer, car le std :: future renvoy√© par l'appel √† std :: async peut d√©marrer dans un √©tat diff√©r√©. </li></ul><br>  Pour √©viter toutes ces difficult√©s, appelez <b>toujours</b> <i>std :: async</i> avec la politique de <i>lancement std :: launch :: async</i> . <br><br>  Ne faites pas ceci: <br><br> <code><font color="#666666">//  myFunction  std::async     </font> <br> <font color="#0000ff">auto</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> myFunction <font color="#008000">)</font> <font color="#008080">;</font></code> <br> <br>  Au lieu de cela, proc√©dez comme suit: <br><br> <code><font color="#666666">//  myFunction </font> <br> <font color="#0000ff">auto</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , myFunction <font color="#008000">)</font> <font color="#008080">;</font></code> <br> <br>  Ce point est examin√© plus en d√©tail dans le livre de Scott Meyers ¬´C ++ efficace et moderne¬ª. <br><br><h3>  Erreur # 15: Appel de la m√©thode get () d'un objet std :: future dans un bloc de code dont le temps d'ex√©cution est critique </h3><br>  Le code ci-dessous traite le r√©sultat obtenu √† partir de l'objet <i>std :: future</i> d'une op√©ration asynchrone.  Cependant, la <i>boucle while</i> sera verrouill√©e jusqu'√† ce que l'op√©ration asynchrone soit termin√©e (dans ce cas, pendant 10 secondes).  Si vous souhaitez utiliser cette boucle pour afficher des informations √† l'√©cran, cela peut entra√Æner des retards d√©sagr√©ables dans le rendu de l'interface utilisateur. <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;future&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , <font color="#008000">[</font> <font color="#008000">]</font> <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">seconds</font> <font color="#008000">(</font> <font color="#0000dd">10</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">8</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#666666">//     </font> <br> <font color="#0000ff">while</font> <font color="#008000">(</font> <font color="#0000ff">true</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#666666">//     </font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Rendering Data"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <font color="#0000ff">int</font> val <font color="#000080">=</font> myFuture. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//    10 </font> <br> <font color="#666666">//  -   Val</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  <b>Remarque</b> : un autre probl√®me du code ci-dessus est qu'il essaie d'acc√©der √† l'objet <i>std :: future</i> une deuxi√®me fois, bien que l'√©tat de l'objet <i>std :: future ait</i> √©t√© r√©cup√©r√© √† la premi√®re it√©ration de la boucle et n'a pas pu √™tre r√©cup√©r√©. <br><br>  La bonne solution serait de v√©rifier la validit√© de l'objet <i>std :: future</i> avant d'appeler la m√©thode <i>get ()</i> .  Ainsi, nous ne bloquons pas l'ach√®vement de la t√¢che asynchrone et n'essayons pas d'interroger l'objet <i>std :: future</i> d√©j√† extrait. <br><br>  Cet extrait de code vous permet de r√©aliser ceci: <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;future&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , <font color="#008000">[</font> <font color="#008000">]</font> <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">seconds</font> <font color="#008000">(</font> <font color="#0000dd">10</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">8</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#666666">//     </font> <br> <font color="#0000ff">while</font> <font color="#008000">(</font> <font color="#0000ff">true</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#666666">//     </font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Rendering Data"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> myFuture. <font color="#007788">valid</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">int</font> val <font color="#000080">=</font> myFuture. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//    10 </font> <br> <br> <font color="#666666">//   -   Val</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><h3>  ‚Ññ16:  ,  ,    ,        std::future::get() </h3><br>        ,   ,     <i>std::future::get()</i> ? <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;future&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , <font color="#008000">[</font> <font color="#008000">]</font> <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">throw</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#008000">(</font> <font color="#FF0000">"Catch me in MAIN"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">8</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> myFuture. <font color="#007788">valid</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">int</font> result <font color="#000080">=</font> myFuture. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>      ‚Äì   ! <br><br> ,           <i>get()</i>  <i>std::future </i> .    <i>get()</i>   ,      ,  <i>std::future</i>     . <br><br>       ,      <i>std::future::get()</i>  <i>try/catch</i> .     : <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;future&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , <font color="#008000">[</font> <font color="#008000">]</font> <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">throw</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#008000">(</font> <font color="#FF0000">"Catch me in MAIN"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">8</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> myFuture. <font color="#007788">valid</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">int</font> result <font color="#000080">=</font> myFuture. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> <font color="#0000ff">const</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#000040">&amp;</font> e <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Async task threw exception: "</font> <font color="#000080">&lt;&lt;</font> e. <font color="#007788">what</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><h3>  ‚Ññ17:  std::async,        </h3><br>  <i>std::async()</i>    ,  ,             . ,              ( Xbox). <br><br>        5-    . <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;windows.h&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Launching Rocket"</font> <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> DWORD result <font color="#000080">=</font> <font color="#008080">::</font> <font color="#007788">SetThreadIdealProcessor</font> <font color="#008000">(</font> t1. <font color="#007788">native_handle</font> <font color="#008000">(</font> <font color="#008000">)</font> , <font color="#0000dd">5</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">native_handle()</a>  <i>std::thread</i> ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Win32 API</a> .    ,    Win32 API,     <i>std::thread</i>  <i>std::async()</i> .    <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: async (),</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ces fonctions de base de la plateforme ne sont pas disponibles, ce qui rend cette m√©thode inadapt√©e aux t√¢ches plus complexes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une alternative consiste √† cr√©er </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: packaged_task</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et √† le d√©placer vers le thread d'ex√©cution souhait√© apr√®s avoir d√©fini les propri√©t√©s du thread.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erreur n ¬∞ 18: cr√©er beaucoup plus de threads ¬´en cours d'ex√©cution¬ª que de c≈ìurs disponibles </font></font></h3><br>          : ¬´¬ª  ¬´¬ª. <br><br>    100%      .         ,     .      ,          ‚Äì     -   . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les threads en attente utilisent seulement quelques cycles d'horloge sur lesquels ils sont ex√©cut√©s pendant qu'ils attendent des √©v√©nements syst√®me ou des E / S r√©seau, etc. Dans ce cas, la majeure partie du temps processeur disponible du noyau reste inutilis√©e. Un thread en attente peut traiter des donn√©es, tandis que les autres attendent que des √©v√©nements se d√©clenchent - c'est pourquoi il est avantageux de distribuer plusieurs threads en attente √† un c≈ìur. La planification de plusieurs threads en attente par c≈ìur peut fournir des performances de programme bien sup√©rieures. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alors, comment comprendre le nombre de threads en cours d'ex√©cution pris en charge par le syst√®me? Utilisez la m√©thode </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: thread :: hardware_concurrency ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cette fonction renvoie g√©n√©ralement le nombre de c≈ìurs de processeur, mais elle prend en compte les c≈ìurs qui se comportent comme deux c≈ìurs logiques ou plus en raison de</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hypertreading</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>               .          ,        . ,          ,      ‚Äî   .       ,         (-      ..),       .        ,        ,   ,       . <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erreur # 19: Utilisation du mot cl√© volatile pour la synchronisation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le mot-cl√© </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">volatile</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">avant de sp√©cifier le type d'une variable, ne rend pas les op√©rations sur cette variable atomiques ou thread-safe. </font><font style="vertical-align: inherit;">Ce que vous voulez probablement, c'est </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: atomic</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voir la discussion sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stackoverflow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour plus de d√©tails.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erreur n ¬∞ 20: utilisation de l'architecture sans verrouillage sauf en cas de n√©cessit√© </font></font></h3><br>    -,    .  ,    (lock free),         ,   ,  ,   . . ,    C ++,    ,  ,             ,         (     ,       !). <br><br>     C ++    ,       ,         ,            10 . <br><br>          ,     : <br><br><ul><li>         ,       ?  ,  ‚Äì  . </li><li>    ,         ?  ,      ? </li><li>          ? </li></ul><br> ,    , ,      ,      .         ,          19 , , ,       . <br><br> [. :    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">vovo4K</a>      .] </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443406/">https://habr.com/ru/post/fr443406/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443396/index.html">Impression 3D et airsoft: comment j'ai imprim√© ¬´drive¬ª</a></li>
<li><a href="../fr443398/index.html">Impl√©mentation de l'ERP dans les entreprises industrielles: Alevtina Svetozarovna et Excel contre les architectes s√©v√®res et l'usine anglaise</a></li>
<li><a href="../fr443400/index.html">Compter les bogues dans la calculatrice Windows</a></li>
<li><a href="../fr443402/index.html">Comment rendre les r√©visions de code plus rapides et plus efficaces</a></li>
<li><a href="../fr443404/index.html">Nouvel objectif de la NASA pour la recherche de civilisations extraterrestres: les signes technologiques</a></li>
<li><a href="../fr443408/index.html">Photons, quanta et √©tat de Fock: manipulations au niveau quantique avec un r√©sonateur radiofr√©quence</a></li>
<li><a href="../fr443412/index.html">Pourquoi les programmeurs continuent d'utiliser Java verbeux, bien qu'il existe un Python concis</a></li>
<li><a href="../fr443414/index.html">Panneau: quand les points d'arr√™t ne suffisent pas</a></li>
<li><a href="../fr443416/index.html">Winnti: une attaque contre les cha√Ænes d'approvisionnement - Les d√©veloppeurs de jeux asiatiques sont au premier plan</a></li>
<li><a href="../fr443422/index.html">Stockage flexible des donn√©es dans MySQL (JSON)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>