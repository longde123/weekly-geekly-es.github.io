<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😖 👩🏼‍🤝‍👩🏻 🧗🏻 我们教小猪们相信自己并飞翔 🤛🏽 🐳 🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在先前的一篇文章中，我谈到了如何使用面向功能和面向语言的编程方法为虚拟堆栈机构建程序执行程序。 该语言的数学结构基于半群和类半体的概念，为实现其翻译器提供了基本结构。 这种方法使我能够构建漂亮且可扩展的实现并打破掌声，但是观众提出的第一个问题使我离开了讲台，再次进入Emacs。 



 我进行了一...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们教小猪们相信自己并飞翔</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430956/"><p>在先前的一篇文章中，我谈到了如何使用面向功能和面向语言的编程方法为虚拟堆栈机构建程序执行程序。 该语言的数学结构基于半群和类半体的概念，为实现其翻译器提供了基本结构。 这种方法使我能够构建漂亮且可扩展的实现并打破掌声，但是观众提出的第一个问题使我离开了讲台，再次进入Emacs。 </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n2/ln/ne/n2lnneohm_d4rsc-qkw_n4cguyw.png" width="80%"></div><br><p> 我进行了一个简单的测试，并确保在仅使用堆栈的简单任务上，虚拟机可以正常运行，并且在使用“内存”（具有随机访问权限的阵列）时会出现大问题。 关于我们如何在不改变程序体系结构基本原理的情况下设法解决它们，并实现程序的千倍加速，将在本文中进行讨论。 </p><a name="habracut"></a><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.681ex" height="1.335ex" viewBox="0 -520.7 2445.9 574.6" role="img" focusable="false" style="vertical-align: -0.125ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMAIN-2217" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMAIN-2217" x="972" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMAIN-2217" x="1945" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>∗</mo><mtext>&nbsp;</mtext><mo>∗</mo><mtext>&nbsp;</mtext><mo>∗</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> * \ * \ * </script></p><br><p>  Haskell是一种特殊的语言，具有特殊的利基。 它的创建和开发的主要目标是使用通用语言来表达和测试函数式编程的思想。 这证明了其最引人注目的功能：懒惰，极度纯正，强调类型和对其进行操作。 它不是为日常开发而设计的，不是为工业编程设计的，也不是为广泛使用的。 如果您愿意的话，它确实可以用于在网络行业和数据处理中创建大型项目，这是开发人员的良好意愿，也是概念验证。 但是到目前为止，用Haskell编写的最重要，使用最广泛且功能惊人的产品是ghc编译器。 从其目的的角度来看，这是完全合理的-成为计算机科学领域的研究工具。 西蒙·佩顿-约翰逊（Simon Payton-Johnson）宣布的原则：“不惜一切代价避免成功”对于使该语言保持如此重要是必要的。  Haskell就像是开发半导体技术或纳米材料的研究中心实验室中的无菌室。 工作非常不便，并且在日常实践中也限制了行动自由，但是如果没有这些不便，并且不妥协地遵守各种限制，将无法观察和研究后来将成为工业发展基础的微妙影响。 同时，在行业中，仅在最必要的量中才需要无菌，这些实验的结果将以小工具的形式出现在我们的口袋里。 我们研究恒星和星系不是因为我们希望从中获得直接的收益，而是因为在这些不切实际的物体的规模上，量子和相对论效应变得可以观察和研究了，以至于后来我们可以利用这些知识来发展非常实用的东西。 因此，Haskell的“错误”行，不切实际的计算惰性，某些类型推断算法的刚性以及非常陡峭的输入曲线，最终使您无法轻松地在膝盖或操作系统上创建智能应用程序。 但是，镜头，单子函数，组合解析，monoid的广泛使用，自动定理证明的方法，声明性功能包管理器，线性和从属类型正在接近实际世界。 这在Python，Scala，Kotlin，F＃，Rust等语言的不那么恶劣的条件下找到了应用。 但是我不会使用任何这些奇妙的语言来教授函数式编程的原理：我将带学生到实验室，以生动干净的示例演示它的工作原理，然后您可以在工厂中看到这些原理的实际应用大型且难以理解但非常快的机器。 不惜一切代价避免成功是为了防止将咖啡机放入电子显微镜以使其普及。 在语言较酷的比赛中，Haskell总是会超出常规提名。 </p><br><p> 但是，这个人很虚弱，恶魔也生活在我体内，这使我想在他人面前比较，评估和捍卫“我最喜欢的语言”。 因此，在编写完一个基于单调式组合的机器的优雅实现之后，唯一的目的就是看这个想法是否对我有用，让我感到很沮丧的是，我意识到实现效果很好，但是效率很低！ 好像我真的要使用它来完成艰巨的任务，或者在可提供Python或Java虚拟机的市场上出售我的堆叠式计算机一样。 但是，该死的，关于整个过程开始的关于小猪的文章给出了如此可口的数字：小猪数百毫秒，Python几秒钟……而我美丽的类人猿在一小时内无法完成同一任务！ 我必须成功！ 我的显微镜能煮出的浓缩咖啡，不比学院走廊里的咖啡机差！ 水晶宫可以分散并发射到太空中！ </p><br><p> 但是，数学家天使问我，你准备放弃什么了？ 宫殿建筑的纯度和透明度？ 从程序到其他解决方案的同态性提供的灵活性和可扩展性？ 恶魔和天使都固执，我也允许自己生活的明智的道士提议走一条适合两者的道路，并尽可能长地走下去。 但是，其目的不是为了识别获胜者，而是为了了解路径本身，找出其前进的方向并获得新的经验。 因此，我知道优化的徒劳的悲伤和喜悦。 </p><br><p>在开始之前，我们补充说，在有效性方面进行<em>语言</em>比较是没有意义的。 您需要比较翻译器（解释器或编译器）或使用该语言的程序员的性能。 最后，例如通过用BASIC编写完整的C解释器，可以很容易地驳斥C程序最快的主张。 因此，我们不是在比较Haskell和javascript，而是在比较由<code>ghc</code>编译的翻译器执行的程序和在特定浏览器中执行的程序的性能。 所有猪的术语都来自有关堆叠式机器的鼓舞人心的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a> 。 随书附带的所有Haskell代码都可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">存储库中</a>研究。 </p><br><h3 id="vyhodim-iz-zony-komforta"> 我们离开舒适区 </h3><br><p> 起始位置将是以<abbr title="面向嵌入式领域的语言">EDSL</abbr>形式实现单面堆栈计算机-一种简单的小语言，它允许组合两个打扰基元来渲染虚拟堆栈计算机的程序。 他进入第二篇文章后，便给他起了<code>monopig</code>的名字。 这是基于这样的事实：用于堆叠机器的语言以连接操作和空操作为单位形成了一个<em>单面</em>体。 相应地，他本人以机器状态的类id变换的形式构建。 状态包括堆栈，向量形式的存储器（提供对元素的随机访问的结构），紧急停止标志和用于累积调试信息的单面电池。 整个结构沿着内构链从一个操作传递到另一个操作，从而执行计算过程。 程序<em>代码</em>的同构结构是从程序形成的结构中构造出来的，并且从其同构性变成其他有用的结构，这些结构代表了根据参数和内存数量对程序的要求。 构造的最后阶段是在Claysley类别中创建变换monoid，您可以将计算沉浸在任意monad中。 因此，机器具有输入输出和模糊计算的功能。 我们将从此实施开始。 她的代码可以在<a href="">这里</a>找到。 </p><br><p> 我们将在天真的实现Eratosthenes筛子时测试该程序的有效性，该方法将内存（数组）填充为零和一，以质数表示为零。 我们在<code>javascript</code>给出算法的过程代码： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> memSize = <span class="hljs-number"><span class="hljs-number">65536</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; memSize; i++) arr.push(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sieve</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n*n &lt; memSize) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!arr[n]) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = n; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (k &lt; memSize) { k+=n; arr[k] = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } n++; } }</code> </pre> <br><p> 该算法立即进行了稍微优化。 它消除了在已装满的存储单元中走错的情况。 我的数学家天使不同意<code>PorosenokVM</code>项目中一个示例的<em>真正</em>幼稚版本，因为此优化仅花费了五个堆栈语言指令。 这是算法转换为<code>monopig</code> ： </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">sieve</span></span> = push <span class="hljs-number"><span class="hljs-number">2</span></span> &lt;&gt; while (dup &lt;&gt; dup &lt;&gt; mul &lt;&gt; push memSize &lt;&gt; lt) (dup &lt;&gt; get &lt;&gt; branch mempty fill &lt;&gt; inc) &lt;&gt; pop fill = dup &lt;&gt; dup &lt;&gt; add &lt;&gt; while (dup &lt;&gt; push memSize &lt;&gt; lt) (dup &lt;&gt; push <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&gt; swap &lt;&gt; put &lt;&gt; exch &lt;&gt; add) &lt;&gt; pop</code> </pre> <br><p> 这是您可以使用与<code>monopig</code>相同的类型在惯用的Haskell上编写此算法的等效实现的<code>monopig</code> ： </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">sieve'</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> sieve' km | k*k &lt; memSize = sieve' (k+<span class="hljs-number"><span class="hljs-number">1</span></span>) $ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m ! k == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> fill' k (<span class="hljs-number"><span class="hljs-number">2</span></span>*k) m <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> m | otherwise = m fill' :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> fill' knm | n &lt; memSize = fill' k (n+k) $ m // [(n,<span class="hljs-number"><span class="hljs-number">1</span></span>)] | otherwise = m</code> </pre> <br><p> 它使用<code>Data.Vector</code>类型和工具来处理它，这对于Haskell的日常工作来说并不常见。 表情<code>m ! k</code>  <code>m ! k</code>返回向量<code>m</code>第<code>k</code>个元素，并且<code>m // [(n,1)]</code> -将数字<code>n</code>为1。我在这里写这个是因为即使我在Haskell工作，我也得去找他们寻求帮助。几乎每天 事实是，在功能实现中具有随机访问权限的结构效率低下，因此不受欢迎。 </p><br><p> 根据有关仔猪的文章中指定的竞争条件，该算法运行100次。 并且为了摆脱特定的计算机，让我们比较这三个程序的执行速度，将它们与在Chrome中运行的<code>javascript</code>程序的性能进行比较。 </p><br><p><img src="https://habrastorage.org/webt/ir/hi/mj/irhimjjtdgec7vw1vduvivmzonm.png"></p><br><p> 恐怖恐怖！  <code>monopig</code>不仅<code>monopig</code>降低了速度，因此本机版本也没有更好的表现！  Haskell当然很酷，但是不比在浏览器中运行的程序逊色吗？ 正如教练教导我们的那样，您不能那样生活，是时候离开Haskell为我们提供的舒适区了！ </p><br><h3 id="preodolevaem-len"> 克服懒惰 </h3><br><p> 让我们做对。 为此，请使用<code>-rtsopts</code>标志在<code>monopig</code>上编译程序，以<code>-rtsopts</code>运行时统计信息，并查看一次运行Eratosthenes筛子所需的内容： </p><br><pre> <code class="plaintext hljs">$ ghc -O -rtsopts ./Monopig4.hs [1 of 1] Compiling Main ( Monopig4.hs, Monopig4.o ) Linking Monopig4 ... $ ./Monopig4 -RTS -sstderr "Ok" 68,243,040,608 bytes allocated in the heap 6,471,530,040 bytes copied during GC 2,950,952 bytes maximum residency (30667 sample(s)) 42,264 bytes maximum slop 15 MB total memory in use (7 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 99408 colls, 0 par 2.758s 2.718s 0.0000s 0.0015s Gen 1 30667 colls, 0 par 57.654s 57.777s 0.0019s 0.0133s INIT time 0.000s ( 0.000s elapsed) MUT time 29.008s ( 29.111s elapsed) GC time 60.411s ( 60.495s elapsed) &lt;--   ! EXIT time 0.000s ( 0.000s elapsed) Total time 89.423s ( 89.607s elapsed) %GC time 67.6% (67.5% elapsed) Alloc rate 2,352,591,525 bytes per MUT second Productivity 32.4% of total user, 32.4% of total elapsed</code> </pre> <br><p> 最后一行告诉我们，该程序只有三分之一的时间用于生产计算。 其余时间，垃圾收集器从内存中运行并清理以进行惰性计算。 在童年时代我们被告知有多少次懒惰不好！ 在这里，Haskell的主要功能给我们带来了损害，试图创建数十亿个延迟向量和堆栈转换。 </p><br><p> 此时的数学家天使举起手指，高高兴兴地谈到自阿隆佐教堂时代以来存在一个定理，该定理指出计算策略不会影响其结果，这意味着出于效率考虑，我们可以自由选择它。 完全将计算更改为严格并不困难-签字<code>!</code> 声明堆栈和内存的类型，从而使这些字段严格。 </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stack</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">status</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memory</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">journal</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p> 我们将不会更改任何其他内容，并立即检查结果： </p><br><pre> <code class="plaintext hljs">$ ./Monopig41 +RTS -sstderr "Ok" 68,244,819,008 bytes allocated in the heap 7,386,896 bytes copied during GC 528,088 bytes maximum residency (2 sample(s)) 25,248 bytes maximum slop 16 MB total memory in use (14 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 129923 colls, 0 par 0.666s 0.654s 0.0000s 0.0001s Gen 1 2 colls, 0 par 0.001s 0.001s 0.0006s 0.0007s INIT time 0.000s ( 0.000s elapsed) MUT time 13.029s ( 13.048s elapsed) GC time 0.667s ( 0.655s elapsed) EXIT time 0.001s ( 0.001s elapsed) Total time 13.700s ( 13.704s elapsed) %GC time 4.9% (4.8% elapsed) Alloc rate 5,238,049,412 bytes per MUT second Productivity 95.1% of total user, 95.1% of total elapsed</code> </pre> <br><p> 生产力显着提高。 由于数据的不变性，总的内存成本仍然令人印象深刻，但是最重要的是，既然我们已经限制了数据的惰性，垃圾回收器就有机会变得懒惰，仅剩下5％的工作要做。 在评分中输入一个新条目。 </p><br><p><img src="https://habrastorage.org/webt/6z/z4/6j/6zz46jgmso3w95efydonusy8pok.png"></p><br><p> 好吧，严格的计算使我们更接近本机的Haskell代码的速度，该代码在没有任何虚拟机的情况下可耻地变慢了速度。 这意味着使用不变向量的开销<em>大大</em>超过了维护堆叠机器的成本。 这意味着该该告别存储的不变性了。 </p><br><h3 id="vpuskaem-izmeneniya-v-zhizn"> 让变化进入生活 </h3><br><p>  <code>Data.Vector</code>类型<code>Data.Vector</code>好的，但是使用它，我们以保留计算过程的纯净为名，花费了大量时间进行复制。 用<code>Data.Vector.Unpacked</code>类型代替它<code>Data.Vector.Unpacked</code>我们至少节省了结构的包装，但这并没有从根本上改变图片。 正确的解决方案是从计算机状态中删除内存，并使用Kleisley类别提供对外部向量的访问。 同时，除了纯矢量，还可以使用所谓的可变（可变）矢量<code>Data.Vector.Mutable</code> 。 </p><br><p> 我们将连接适当的模块，并考虑如何在干净的功能程序中处理可变数据。 </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad.Primitive <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Vector.Unboxed <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> V <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Vector.Unboxed.Mutable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> M</code> </pre> <br><p> 这些脏污类型应该与纯公众隔离。 它们包含在<code>PrimMonad</code>类的monad中（这些包含<code>ST</code>或<code>IO</code> ），其中干净的程序会仔细地将用水晶功能语言编写的动作指令插入珍贵的羊皮纸上。 因此，这些不洁动物的行为完全由正统的情况决定，并不危险。 并非我们机器上的所有程序都使用内存，因此无需将整个体系结构都沉浸在<code>IO</code> monad中。 连同<code>monopig</code>语言的干净子集<code>monopig</code>我们将创建四个提供对内存访问的指令，只有它们才能访问危险区域。 </p><br><p> 清洁机的类型越来越短： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stack</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">status</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">journal</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p> 程序设计者和程序本身几乎不会注意到这种变化，但是它们的类型将会变化。 此外，定义几种同义词来简化签名是有意义的。 </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> m = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MVector</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PrimState</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Logger</span></span></span><span class="hljs-class"> ma = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> m -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Code</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> a -&gt; m (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program'</span></span></span><span class="hljs-class"> ma = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Logger</span></span></span><span class="hljs-class"> ma -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> m -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class"> ma</span></span></code> </pre> <br><p> 构造函数将具有另一个表示内存访问的参数。 执行器将发生重大变化，尤其是那些保留了计算日志的执行器，因为现在他们需要询问变量向量的状态。 可以在存储库中查看和研究完整的<a href="">代码</a> ，但是在这里，我将提供最有趣的信息：用于处理内存的基本组件的实现，以演示如何完成此工作。 </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">geti</span></span> :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma geti i = programM (<span class="hljs-type"><span class="hljs-type">GETI</span></span> i) $ \mem -&gt; \s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= i &amp;&amp; i &lt; memSize) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeRead mem i setStack (x:s) vm <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> err <span class="hljs-string"><span class="hljs-string">"index out of range"</span></span> puti :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma puti i = programM (<span class="hljs-type"><span class="hljs-type">PUTI</span></span> i) $ \mem -&gt; \<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (x:s) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= i &amp;&amp; i &lt; memSize) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeWrite mem ix setStack s vm <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> err <span class="hljs-string"><span class="hljs-string">"index out of range"</span></span> _ -&gt; err <span class="hljs-string"><span class="hljs-string">"expected an element"</span></span> get :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma get = programM (<span class="hljs-type"><span class="hljs-type">GET</span></span>) $ \m -&gt; \<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (i:s) -&gt; \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.read mi setStack (x:s) vm _ -&gt; err <span class="hljs-string"><span class="hljs-string">"expected an element"</span></span> put :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma put = programM (<span class="hljs-type"><span class="hljs-type">PUT</span></span>) $ \m -&gt; \<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (i:x:s) -&gt; \vm -&gt; <span class="hljs-type"><span class="hljs-type">M</span></span>.write mix &gt;&gt; setStack s vm _ -&gt; err <span class="hljs-string"><span class="hljs-string">"expected two elemets"</span></span></code> </pre> <br><p> 优化器守护程序立即提供了节省检查内存中允许的索引值的更多信息，因为对于<code>puti</code>和<code>puti</code> <code>geti</code>索引在程序创建阶段就已知，并且可以预先消除不正确的值。 动态定义<code>put</code>和<code>get</code>命令的索引不能保证安全性，并且数学家天使不允许对其进行危险的调用。 </p><br><p> 将内存放在一个单独的参数中的所有这些大惊小怪似乎很复杂。 但是它非常清楚地表明，数据将按其位置进行更改- <em>它们应该在外部</em> 。 我提醒您，我们正在尝试将披萨送货员带到无菌实验室。 纯粹的功能知道如何处理它们，但是这些对象永远不会成为一流的公民，因此不值得在实验室里准备比萨。 </p><br><p> 让我们检查一下通过这些更改购买了什么： </p><br><pre> <code class="plaintext hljs">$ ./Monopig5 +RTS -sstderr "Ok" 9,169,192,928 bytes allocated in the heap 2,006,680 bytes copied during GC 529,608 bytes maximum residency (2 sample(s)) 25,248 bytes maximum slop 2 MB total memory in use (0 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 17693 colls, 0 par 0.094s 0.093s 0.0000s 0.0001s Gen 1 2 colls, 0 par 0.000s 0.000s 0.0002s 0.0003s INIT time 0.000s ( 0.000s elapsed) MUT time 7.228s ( 7.232s elapsed) GC time 0.094s ( 0.093s elapsed) EXIT time 0.000s ( 0.000s elapsed) Total time 7.325s ( 7.326s elapsed) %GC time 1.3% (1.3% elapsed) Alloc rate 1,268,570,828 bytes per MUT second Productivity 98.7% of total user, 98.7% of total elapsed</code> </pre> <br><p> 这已经是进步了！ 内存使用量减少了八倍，程序执行速度提高了180倍，垃圾收集器几乎完全没有工作。 </p><br><p><img src="https://habrastorage.org/webt/o7/cw/f8/o7cwf8ptddtz8x1gdy0lunionis.png"></p><br><p> 溶液出现<em>monopig st。</em>  <em>mut。</em>  ，它比<code>js</code>上的本机解决方案慢十倍，但除此之外，还使用可变向量在Haskell上的本机解决方案。 这是他的代码： </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fill'</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> (<span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span>) fill' knm | n &gt; memSize-k = return m | otherwise = <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeWrite mn <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt; fill' k (n+k) m sieve' :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> (<span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span>) sieve' km | k*k &lt; memSize = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeRead mk <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> fill' k (<span class="hljs-number"><span class="hljs-number">2</span></span>*k) m &gt;&gt;= sieve' (k+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sieve' (k+<span class="hljs-number"><span class="hljs-number">1</span></span>) m | otherwise = return m</code> </pre> <br><p> 它开始如下 </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> m &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.replicate memSize <span class="hljs-number"><span class="hljs-number">0</span></span> stimes <span class="hljs-number"><span class="hljs-number">100</span></span> (sieve' <span class="hljs-number"><span class="hljs-number">2</span></span> m &gt;&gt; return ()) print <span class="hljs-string"><span class="hljs-string">"Ok"</span></span></code> </pre> <br><p> 现在，Haskell终于表明他不是玩具语言。 您只需要明智地使用它。 顺便说一句，以上代码使用<code>IO ()</code>类型通过顺序执行程序<code>(&gt;&gt;)</code>的操作形成半组这一事实，并且借助<code>stimes</code>我们对测试问题的计算重复了100次。 </p><br><p> 现在很清楚，为什么不喜欢函数数组，为什么没人记得如何使用它们：Haskell程序员真正需要随机访问结构后，他立即将重点放在可变数据上，并在ST或IO monad中工作。 </p><br><p> 将命令的一部分带入一个特殊区域会引起同构合法性的质疑 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="20.072ex" height="2.419ex" viewBox="0 -780.1 8642 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-6C" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-6F" x="548" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-6E" x="1034" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-67" x="1634" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-6C" x="2115" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-65" x="2413" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-66" x="2880" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-74" x="3430" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-72" x="3792" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-69" x="4243" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-67" x="4589" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-68" x="5069" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-74" x="5646" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-61" x="6007" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-72" x="6537" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-72" x="6988" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-6F" x="7440" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-77" x="7925" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math></span></span><script type="math/tex" id="MathJax-Element-2"> \ longleftrightarrow </script>  <em>该程序</em> 。 毕竟，我们不能将代码同时转换为纯程序和单子程序，这不允许类型系统执行。 但是，类型类足够灵活，可以存在这种同构。 同态<em>码</em> <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="16.177ex" height="2.419ex" viewBox="0 -780.1 6965 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-6C" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-6F" x="548" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-6E" x="1034" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-67" x="1634" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-72" x="2115" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-69" x="2566" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-67" x="2912" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-68" x="3392" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-74" x="3969" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-61" x="4330" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-72" x="4860" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-72" x="5311" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-6F" x="5763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMATHI-77" x="6248" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> \ longrightarrow </script> 现在， <em>该程序</em>针对该语言的不同子集分为几种同构。 可以在程序的完整[code]（）中看到如何完成此操作。 </p><br><h3 id="ne-ostanavlivaysya-na-dostignutom"> 不要停在那里 </h3><br><p> 使用<code>{-# INLINE #-}</code>编译指示消除不必要的函数调用并直接嵌入其代码将有助于稍微改变程序的生产率。 此方法不适用于递归函数，但对于基本组件和设置器函数非常有用。 它将测试程序的执行时间减少了25％（请参见<a href="">Monopig51.hs</a> ）。 </p><br><p><img src="https://habrastorage.org/webt/0k/-l/hu/0k-lhu49_zsiihqoom7c5g0ize8.png"></p><br><p> 下一步的合理步骤是在不需要日志工具时将其删除。 在表示程序的同构状态的阶段，我们使用一个外部参数，该参数在启动时确定。 可以警告智能构造函数<code>program</code>和<code>programM</code> ，可能没有参数记录器。 在这种情况下，转换器代码不包含任何多余的内容：仅包含功能和检查计算机的状态。 </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">program</span></span> code f = programM code (const f) programM code f (<span class="hljs-type"><span class="hljs-type">Just</span></span> logger) mem = <span class="hljs-type"><span class="hljs-type">Program</span></span> . ([code],) . <span class="hljs-type"><span class="hljs-type">ActionM</span></span> $ \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> status vm <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; logger mem code =&lt;&lt; f mem (stack vm) vm _ -&gt; return vm programM code f _ mem = <span class="hljs-type"><span class="hljs-type">Program</span></span> . ([code],) . <span class="hljs-type"><span class="hljs-type">ActionM</span></span> $ \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> status vm <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; f mem (stack vm) vm _ -&gt; return vm</code> </pre> <br><p> 现在，执行函数必须不使用<code>none</code>存根而是使用<code>Maybe (Logger ma)</code>类型<code>Maybe (Logger ma)</code>显式指示是否存在日志。 为什么要这样做，因为如果有日志记录，程序组件将在执行之前“在最后一刻”找出来？ 在编写程序的阶段是否会缝制不必要的代码？  Haskell是一种懒惰的语言，在这里它会发挥作用。 在执行之前，最终代码针对特定任务进行了优化。 这种优化使程序执行时间又减少了40％（请参见<a href="">Monopig52.hs</a> ）。 </p><br><p><img src="https://habrastorage.org/webt/co/gd/vy/cogdvyw-zsyliuiwsmhxs5gadhe.png"></p><br><p> 至此，我们将完成加速单节仔猪的工作。 他已经足够快地奔跑，以使天使和恶魔都能平静下来。 当然，这不是C，我们仍然使用一个干净的列表作为堆栈，但是用数组替换它会导致对代码的彻底挖掘，并且拒绝在基本命令的定义中使用优雅的模板。 我想通过最少的更改来实现，主要是在类型级别上。 </p><br><p> 日志记录仍然存在一些问题。 简单地计算步数或使用堆栈效果很好（我们将日志字段设置为严格），但是将它们配对已经开始占用内存，您必须使用<code>seq</code>来烦扰一下，这已经很烦人了。 但是请告诉我，如果您可以在前数百个调试任务，谁将记录140亿步？ 因此，我不会花时间加速工作。 </p><br><p> 剩下的只是在关于仔猪的文章中补充说，作为优化计算的一种方法，给出了跟踪：代码的线性部分的分配， <em>跟踪可以</em>在其中绕过主命令分配周期（ <code>switch</code>块）执行计算的<em>跟踪</em> 。 在我们的情况下，程序组件的单调组合在从EDSL组件形成程序的过程中，或者在<code>fromCode</code>同态的操作过程中都会创建这样的痕迹。 可以说，这种优化方法是免费提供给我们的。 </p><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.681ex" height="1.335ex" viewBox="0 -520.7 2445.9 574.6" role="img" focusable="false" style="vertical-align: -0.125ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMAIN-2217" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMAIN-2217" x="972" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/430956/&amp;usg=ALkJrhhPCDqya6XnsaMe4HVd6_d9SA0xbQ#MJMAIN-2217" x="1945" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>∗</mo><mtext>&nbsp;</mtext><mo>∗</mo><mtext>&nbsp;</mtext><mo>∗</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-4"> * \ * \ * </script></p><br><p>  Haskell生态系统中有许多<code>Conduits</code>而快速的解决方案，例如<code>Conduits</code>或<code>Pipes</code>流，出色的<code>String</code>替换和灵活的XML创建者（例如blaze-html），以及<code>attoparsec</code>解析器是LL（∞）语法组合分析的标准。 所有这些对于正常操作都是必需的。 但是，更需要进行研究以做出这些决定。  Haskell一直是并且仍然是一种满足一般公众不需要的特定要求的研究工具。 我在堪察加看到，一架Mi-4直升机上的A是如何在争吵中关闭火柴盒的，在悬空时用轮子推着起落架。 可以做到，而且很酷，但这不是必须的。 </p><br><p> 但是，尽管如此，这很酷！ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN430956/">https://habr.com/ru/post/zh-CN430956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN430944/index.html">美国宇航局已决定参加迷你月球车比赛</a></li>
<li><a href="../zh-CN430948/index.html">通讯部提议加强对个人数据的控制</a></li>
<li><a href="../zh-CN430950/index.html">进行现代建造</a></li>
<li><a href="../zh-CN430952/index.html">电动汽车和混合动力汽车将不得不发出额外的声音：为什么需要这样做</a></li>
<li><a href="../zh-CN430954/index.html">Qt无处不在：WebAssembly和WebGL流</a></li>
<li><a href="../zh-CN430958/index.html">我们在Azure DevOps（VSTS）中使用单元测试启动容器</a></li>
<li><a href="../zh-CN430960/index.html">关于来自桌面展览的gamedev</a></li>
<li><a href="../zh-CN430962/index.html">Visual Studio Code中的Razor支持</a></li>
<li><a href="../zh-CN430964/index.html">陈述式思维</a></li>
<li><a href="../zh-CN430966/index.html">Atlassian Jira Software的常规冲刺</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>