<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🚒 🌐 👨🏿‍🌾 毁灭性的例外 👩‍❤️‍💋‍👩 😝 🏔️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="再一次说明为什么在析构函数中抛出异常不好 


 许多C ++专家（例如Herb Sutter ）告诉我们，在析构函数中抛出异常是不好的，因为您可以在堆栈升级期间已经抛出异常的情况下进入析构函数，并且如果此时抛出另一个异常，则将调用std作为结果。 ::终止（） 。 关于此主题的C ++ 17语言标...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>毁灭性的例外</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433944/"><h2 id="eschyo-raz-o-tom-pochemu-ploho-brosat-isklyucheniya-v-destruktorah"> 再一次说明为什么在析构函数中抛出异常不好 </h2><br><p> 许多C ++专家（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Herb Sutter</a> ）告诉我们，在析构函数中抛出异常是不好的，因为您可以在堆栈升级期间已经抛出异常的情况下进入析构函数，并且如果此时抛出另一个异常，则将调用<em>std</em>作为结果。 <em>::终止（）</em> 。 关于此主题的C ++ 17语言标准（以下称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">N4713</a>草案的免费版本）告诉我们以下内容： </p><a name="habracut"></a><br><blockquote>  <strong>18.5.1 std :: terminate（）函数[except.terminate]</strong> <br><br>  1在某些情况下，必须放弃异常处理，以减少不太细微的错误处理技术。  [注意： <br><br> 这些情况是： <br><br>  ... <br><br>  （1.4）当堆栈展开（18.2）期间对象的销毁因引发异常而终止时，或 <br><br>  ... <br><br>  -尾注] </blockquote><p> 让我们来看一个简单的例子： </p><br><pre><code class="plaintext hljs">#include &lt;iostream&gt; class PrintInDestructor { public: ~PrintInDestructor() noexcept { std::cerr &lt;&lt; "~PrintInDestructor() invoked\n"; } }; void throw_int_func() { std::cerr &lt;&lt; "throw_int_func() invoked\n"; throw 1; } class ThrowInDestructor { public: ~ThrowInDestructor() noexcept(false) { std::cerr &lt;&lt; "~ThrowInDestructor() invoked\n"; throw_int_func(); } private: PrintInDestructor member_; }; int main(int, char**) { try { ThrowInDestructor bad; throw "BANG!"; } catch (int i) { std::cerr &lt;&lt; "Catched int exception: " &lt;&lt; i &lt;&lt; "\n"; } catch (const char* c) { std::cerr &lt;&lt; "Catched const char* exception: " &lt;&lt; c &lt;&lt; "\n"; } catch (...) { std::cerr &lt;&lt; "Catched unknown exception\n"; } return 0; }</code> </pre> <br><p> 结果： </p><br><pre> <code class="plaintext hljs">~ThrowInDestructor() invoked throw_int_func() invoked ~PrintInDestructor() invoked terminate called after throwing an instance of 'int' Aborted</code> </pre> <br><p> 注意<em>PrintInDestructor</em>析构函数仍被调用，即 抛出第二个异常后，堆栈升级不会中断。 关于此主题的标准（相同的段落18.5.1）规定： </p><br><blockquote>  2 ...在没有找到匹配处理程序的情况下， <br> 在调用std :: terminate（）之前是否取消堆栈的堆栈是由实现定义的。 在 <br> 搜索处理程序（18.3）遇到函数的最外层块的情况 <br> 非抛出异常规范（18.4），由实现定义，堆栈是否解绕， <br> 在调用std :: terminate（）之前部分解开或根本不解开... </blockquote><p> 我在<strong>GCC</strong> （ <strong>8.2、7.3</strong> ）和<strong>Clang</strong> （ <strong>6.0、5.0</strong> ）的多个版本上测试了此示例，到处都在推广堆栈。 如果遇到实现定义不同的编译器，请在注释中写出。 </p><br><p> 还应注意，仅当从析构函数抛出异常时才取消堆栈堆栈时，才调用<em>std :: terminate（）</em> 。 如果析构函数内部有一个try / catch块可以捕获异常并且不会进一步抛出异常，则这不会中断外部异常堆栈的提升。 </p><br><pre> <code class="plaintext hljs">class ThrowCatchInDestructor { public: ~ThrowCatchInDestructor() noexcept(false) { try { throw_int_func(); } catch (int i) { std::cerr &lt;&lt; "Catched int in ~ThrowCatchInDestructor(): " &lt;&lt; i &lt;&lt; "\n"; } } private: PrintInDestructor member_; }; int main(int, char**) { try { ThrowCatchInDestructor good; std::cerr &lt;&lt; "ThrowCatchInDestructor instance created\n"; throw "BANG!"; } catch (int i) { std::cerr &lt;&lt; "Catched int exception: " &lt;&lt; i &lt;&lt; "\n"; } catch (const char* s) { std::cerr &lt;&lt; "Catched const char* exception: " &lt;&lt; s &lt;&lt; "\n"; } catch (...) { std::cerr &lt;&lt; "Catched unknown exception\n"; } return 0; }</code> </pre> <br><p> 显示 </p><br><pre> <code class="plaintext hljs">ThrowCatchInDestructor instance created throw_int_func() invoked Catched int in ~ThrowCatchInDestructor(): 1 ~PrintInDestructor() invoked Catched const char* exception: BANG!</code> </pre> <br><p> 如何避免不愉快的情况？ 从理论上讲，一切都很简单：永远不要在析构函数中抛出异常。 然而，实际上，精美而优雅地实现这一简单要求并不是那么简单。 </p><br><h2 id="esli-nelzya-no-ochen-hochetsya"> 如果不能，但真的想... </h2><br><blockquote> 我将立即注意到，我并不是想证明从析构函数引发异常的理由，并且紧跟Sutter，Meyers和其他C ++专家，我敦促您<strong>不要尝试</strong>这样做（至少在新代码中）。 但是，在实际操作中，程序员很可能会遇到遗留代码，这很难导致高标准。 另外，下面经常描述的技术在调试过程中会派上用场。 </blockquote><p> 例如，我们正在开发一个带有包装器类的库，该包装器用某种资源封装工作。 根据RAII的原则，我们在构造函数中获取资源，并且必须在析构函数中释放它。 但是，如果释放资源的尝试失败了怎么办？ 解决此问题的选项： </p><br><ul><li> 忽略该错误。 不好，因为我们隐藏了可能影响系统其他部分的问题。 </li><li> 写入日志。 总比忽略它更好，但仍然很糟糕，因为 我们的图书馆对使用它的系统中采用的日志记录政策一无所知。 可以将标准日志重定向到/ dev / null，因此，再次，我们将不会看到错误。 </li><li> 将资源的释放带到一个单独的函数中，该函数返回一个值或引发异常，并迫使类用户自行调用它。 这很糟糕，因为用户可能会完全忘记这样做，并且我们将收到资源泄漏。 </li><li> 引发异常。 在通常情况下是好的，因为 类用户可以捕获异常并以标准方式获取有关错误的信息。 升级堆栈时不好，因为 导致<em>std :: terminate（）</em> 。 </li></ul><br><p> 如何理解我们当前是否正在异常推进堆栈？ 在C ++中，有一个特殊的函数<em>std :: uncaught_exception（）</em> 。 有了它的帮助，我们可以在正常情况下安全地引发异常，或者做一些不太正确的事情，但不会导致堆栈提升期间引发异常。 </p><br><pre> <code class="plaintext hljs">class ThrowInDestructor { public: ~ThrowInDestructor() noexcept(false) { if (std::uncaught_exception()) { std::cerr &lt;&lt; "~ThrowInDestructor() stack unwinding, not throwing\n"; } else { std::cerr &lt;&lt; "~ThrowInDestructor() normal case, throwing\n"; throw_int_func(); } } private: PrintInDestructor member_; }; int main(int, char**) { try { ThrowInDestructor normal; std::cerr &lt;&lt; "ThrowInDestructor normal destruction\n"; } catch (int i) { std::cerr &lt;&lt; "Catched int exception: " &lt;&lt; i &lt;&lt; "\n"; } try { ThrowInDestructor stack_unwind; std::cerr &lt;&lt; "ThrowInDestructor stack unwinding\n"; throw "BANG!"; } catch (int i) { std::cerr &lt;&lt; "Catched int exception: " &lt;&lt; i &lt;&lt; "\n"; } catch (const char* s) { std::cerr &lt;&lt; "Catched const char* exception: " &lt;&lt; s &lt;&lt; "\n"; } catch (...) { std::cerr &lt;&lt; "Catched unknown exception\n"; } return 0; }</code> </pre> <br><p> 结果： </p><br><pre> <code class="plaintext hljs">ThrowInDestructor normal destruction ~ThrowInDestructor() normal case, throwing throw_int_func() invoked ~PrintInDestructor() invoked Catched int exception: 1 ThrowInDestructor stack unwinding ~ThrowInDestructor() stack unwinding, not throwing ~PrintInDestructor() invoked Catched const char* exception: BANG!</code> </pre> <br><p> 请注意，自C ++ Standard 17起， <em>不推荐使用</em> <em>std :: uncaught_exception（）</em>函数，因此，要编译该示例，必须禁止相应的编译（请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">带有示例示例</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">存储库</a> ）。 </p><br><p> 这个函数的问题是它检查我们是否正在异常旋转堆栈的过程中。 但是无法理解在堆栈升级过程中是否调用了当前析构函数。 结果，如果有堆栈提升，但是通常调用某些对象的析构函数，则<em>std :: uncaught_exception（）</em>仍将返回<em>true</em> 。 </p><br><pre> <code class="plaintext hljs">class MayThrowInDestructor { public: ~MayThrowInDestructor() noexcept(false) { if (std::uncaught_exception()) { std::cerr &lt;&lt; "~MayThrowInDestructor() stack unwinding, not throwing\n"; } else { std::cerr &lt;&lt; "~MayThrowInDestructor() normal case, throwing\n"; throw_int_func(); } } }; class ThrowCatchInDestructor { public: ~ThrowCatchInDestructor() noexcept(false) { try { MayThrowInDestructor may_throw; } catch (int i) { std::cerr &lt;&lt; "Catched int in ~ThrowCatchInDestructor(): " &lt;&lt; i &lt;&lt; "\n"; } } private: PrintInDestructor member_; }; int main(int, char**) { try { ThrowCatchInDestructor stack_unwind; std::cerr &lt;&lt; "ThrowInDestructor stack unwinding\n"; throw "BANG!"; } catch (int i) { std::cerr &lt;&lt; "Catched int exception: " &lt;&lt; i &lt;&lt; "\n"; } catch (const char* s) { std::cerr &lt;&lt; "Catched const char* exception: " &lt;&lt; s &lt;&lt; "\n"; } catch (...) { std::cerr &lt;&lt; "Catched unknown exception\n"; } return 0; }</code> </pre> <br><p> 结果： </p><br><pre> <code class="plaintext hljs">ThrowInDestructor stack unwinding ~MayThrowInDestructor() stack unwinding, not throwing ~PrintInDestructor() invoked Catched const char* exception: BANG!</code> </pre> <br><p> 在新的C ++ 17标准中，引入了<em>std :: uncaught_exceptions（）</em>函数来替换<em>std :: uncaught_exception（）</em> （请注意复数），该函数代替布尔值返回当前活动异常的数量（此处有详细说明）。 </p><br><p> 这就是通过<em>std :: uncaught_exceptions（）</em>解决上述问题的方法： </p><br><pre> <code class="plaintext hljs">class MayThrowInDestructor { public: MayThrowInDestructor() : exceptions_(std::uncaught_exceptions()) {} ~MayThrowInDestructor() noexcept(false) { if (std::uncaught_exceptions() &gt; exceptions_) { std::cerr &lt;&lt; "~MayThrowInDestructor() stack unwinding, not throwing\n"; } else { std::cerr &lt;&lt; "~MayThrowInDestructor() normal case, throwing\n"; throw_int_func(); } } private: int exceptions_; }; class ThrowCatchInDestructor { public: ~ThrowCatchInDestructor() noexcept(false) { try { MayThrowInDestructor may_throw; } catch (int i) { std::cerr &lt;&lt; "Catched int in ~ThrowCatchInDestructor(): " &lt;&lt; i &lt;&lt; "\n"; } } private: PrintInDestructor member_; }; int main(int, char**) { try { ThrowCatchInDestructor stack_unwind; std::cerr &lt;&lt; "ThrowInDestructor stack unwinding\n"; throw "BANG!"; } catch (int i) { std::cerr &lt;&lt; "Catched int exception: " &lt;&lt; i &lt;&lt; "\n"; } catch (const char* s) { std::cerr &lt;&lt; "Catched const char* exception: " &lt;&lt; s &lt;&lt; "\n"; } catch (...) { std::cerr &lt;&lt; "Catched unknown exception\n"; } return 0; }</code> </pre> <br><p> 结果： </p><br><pre> <code class="plaintext hljs">ThrowInDestructor stack unwinding ~MayThrowInDestructor() normal case, throwing throw_int_func() invoked Catched int in ~ThrowCatchInDestructor(): 1 ~PrintInDestructor() invoked Catched const char* exception: BANG!</code> </pre> <br><h2 id="kogda-ochen-ochen-hochetsya-vybrosit-srazu-neskolko-isklyucheniy"> 当我真的真的想一次抛出一些异常时 </h2><br><p>  <em>std :: uncaught_exceptions（）</em>避免调用<em>std ::终止（）</em> ，但无助于正确处理多个异常。 理想情况下，我希望有一种机制可以保存所有引发的异常，然后在一个地方处理它们。 </p><br><blockquote> 我想再次提醒我，我在下面提出的机制仅用于说明该概念，不建议在实际的工业代码中使用。 </blockquote><p> 这个想法的实质是捕获异常并将其保存在容器中，然后一次获取并处理它们。 为了保存异常对象，C ++具有特殊类型<em>std :: exception_ptr</em> 。 标准中的类型结构没有公开，但是可以说每个异常对象实际上是<em>shared_ptr</em> 。 </p><br><p> 然后如何处理这些异常？  <em>为此</em> ，有一个函数<em>std :: rethrow_exception（）</em> ，它接受一个指针<em>std :: exception_ptr</em>并引发相应的异常。 我们只需要使用相应的catch部分来捕获它并对其进行处理，之后我们就可以继续下一个异常对象。 </p><br><pre> <code class="plaintext hljs">using exceptions_queue = std::stack&lt;std::exception_ptr&gt;; // Get exceptions queue for current thread exceptions_queue&amp; get_queue() { thread_local exceptions_queue queue_; return queue_; } // Invoke functor and save exception in queue void safe_invoke(std::function&lt;void()&gt; f) noexcept { try { f(); } catch (...) { get_queue().push(std::current_exception()); } } class ThrowInDestructor { public: ~ThrowInDestructor() noexcept { std::cerr &lt;&lt; "~ThrowInDestructor() invoked\n"; safe_invoke([]() { throw_int_func(); }); } private: PrintInDestructor member_; }; int main(int, char**) { safe_invoke([]() { ThrowInDestructor bad; throw "BANG!"; }); auto&amp; q = get_queue(); while (!q.empty()) { try { std::exception_ptr ex = q.top(); q.pop(); if (ex != nullptr) { std::rethrow_exception(ex); } } catch (int i) { std::cerr &lt;&lt; "Catched int exception: " &lt;&lt; i &lt;&lt; "\n"; } catch (const char* s) { std::cerr &lt;&lt; "Catched const char* exception: " &lt;&lt; s &lt;&lt; "\n"; } catch (...) { std::cerr &lt;&lt; "Catched unknown exception\n"; } } return 0; }</code> </pre> <br><p> 结果： </p><br><pre> <code class="plaintext hljs">~ThrowInDestructor() invoked throw_int_func() invoked ~PrintInDestructor() invoked Catched const char* exception: BANG! Catched int exception: 1</code> </pre> <br><p> 在上面的示例中，堆栈用于保存异常对象，但是，将根据FIFO原理执行异常处理（也就是说，从逻辑上讲，这是队列-首先处理的异常将被首先处理）。 </p><br><h2 id="vyvody"> 结论 </h2><br><p> 在对象析构函数中引发异常确实不是一个好主意，在任何新代码中，我强烈建议不要通过声明<em>noexcept</em>析构函数来做到这一点。 但是，在遗留代码的支持和调试下，可能需要正确处理从析构函数抛出的异常，包括在堆栈提升期间，而现代C ++为我们提供了这种机制。 我希望本文中提出的想法可以帮助您走上这条艰难的道路。 </p><br><h2 id="ssylki"> 参考文献 </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">带有本文示例的存储库</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN433944/">https://habr.com/ru/post/zh-CN433944/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN433932/index.html">我们脚踏实地，处理输入数据</a></li>
<li><a href="../zh-CN433934/index.html">SAFe或规模化敏捷框架</a></li>
<li><a href="../zh-CN433936/index.html">在寻找给孩子的高科技礼物吗？ 想想一个游乐场，而不是一个围栏</a></li>
<li><a href="../zh-CN433938/index.html">Yandex和Google如何总结年度</a></li>
<li><a href="../zh-CN433940/index.html">AppStore中的Review多少钱</a></li>
<li><a href="../zh-CN433946/index.html">人工智能备忘单-丢弃多余的东西，教主要知识。 训练序列处理技术</a></li>
<li><a href="../zh-CN433948/index.html">如何使付款更方便：IaaS提供商的经验</a></li>
<li><a href="../zh-CN433952/index.html">从HPE选择SAP HANA解决方案的10个理由。 第二部分</a></li>
<li><a href="../zh-CN433954/index.html">八种音频技术和音频小工具将于2019年进入TECnology名人堂</a></li>
<li><a href="../zh-CN433956/index.html">Modders使用AI改善了游戏的质感</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>