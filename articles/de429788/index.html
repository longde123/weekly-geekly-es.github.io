<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚴🏻 🖐🏾 👩🏼‍💻 Ein weiterer Grund, warum Docker-Container verlangsamt werden 👸🏿 🚢 ✍🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im letzten Beitrag habe ich über Kubernetes gesprochen, wie ThoughtSpot es für seine eigenen Entwicklungsunterstützungsbedürfnisse verwendet. Heute mö...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ein weiterer Grund, warum Docker-Container verlangsamt werden</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/429788/"><p>  Im letzten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag habe</a> ich über Kubernetes gesprochen, wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ThoughtSpot</a> es für seine eigenen Entwicklungsunterstützungsbedürfnisse verwendet.  Heute möchte ich das Gespräch über eine kurze, aber nicht weniger interessante Debugging-Geschichte fortsetzen, die kürzlich stattgefunden hat.  Der Artikel basiert auf der Tatsache, dass Containerisierung! = Virtualisierung.  Darüber hinaus wird gezeigt, wie containerisierte Prozesse auch bei optimalen Einschränkungen der cgroup und hoher Maschinenleistung um Ressourcen konkurrieren. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/297/09a/dfa/29709adfa1fa1830ee869e441e343fcf.png" alt="Bild"></p><a name="habracut"></a><br><p>  Zuvor haben wir eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihe von Vorgängen im Zusammenhang mit der Entwicklung von b CI / CD</a> im internen Kubernetes-Cluster gestartet.  Alles wäre in Ordnung, aber wenn Sie eine "Docker" -Anwendung starten, sinkt die Leistung plötzlich dramatisch.  Wir waren nicht geizig: In jedem der Container gab es Einschränkungen hinsichtlich der Rechenleistung und des Arbeitsspeichers (5 CPU / 30 GB RAM), die durch die Pod-Konfiguration festgelegt wurden.  Auf einer virtuellen Maschine mit solchen Parametern würden alle unsere Anforderungen aus einem winzigen Datensatz (10 KB) für Tests fliegen.  In Docker &amp; Kubernetes mit 72 CPU / 512 GB RAM konnten wir jedoch 3-4 Kopien des Produkts starten, und dann wurden die Bremsen gestartet.  Anforderungen, die früher in ein paar Millisekunden abgeschlossen wurden, hingen jetzt 1-2 Sekunden lang, und dies verursachte alle Arten von Fehlern in der CI-Task-Pipeline.  Ich musste mich eng mit dem Debuggen befassen. </p><br><p>  In der Regel werden alle Arten von Konfigurationsfehlern beim Packen einer Anwendung in Docker vermutet.  Wir haben jedoch nichts gefunden, was zumindest zu einer Verlangsamung führen könnte (im Vergleich zu Installationen auf nackter Hardware oder virtuellen Maschinen).  Alles scheint richtig zu sein.  Als nächstes haben wir alle Arten von Tests aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sysbench-</a> Paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausprobiert</a> .  Wir haben die Leistung von CPU, Festplatte und Speicher überprüft - alles war das gleiche wie bei Bare Metal.  Einige Services unseres Produktspeichers enthalten detaillierte Informationen zu allen Aktionen: Sie können dann zur Profilerstellung verwendet werden.  Wenn eine Ressource (CPU, RAM, Festplatte, Netzwerk) knapp ist, tritt bei einigen Aufrufen in der Regel ein erheblicher Zeitfehler auf. Wir finden also heraus, was genau und wo langsamer wird.  In diesem Fall ist jedoch nichts passiert.  Die zeitlichen Proportionen unterschieden sich nicht von der Arbeitskonfiguration - mit dem einzigen Unterschied, dass jeder Anruf viel langsamer war als bei Bare Metal.  Nichts deutete auf die wahre Ursache des Problems hin.  Wir waren bereit aufzugeben, als wir dies plötzlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fanden</a> . </p><br><p>  In diesem Artikel analysiert der Autor einen ähnlichen mysteriösen Fall, in dem sich zwei prinzipielle Lichtprozesse gegenseitig töteten, wenn sie in Docker auf demselben Computer ausgeführt wurden, und die Ressourcenlimits auf sehr bescheidene Werte festgelegt wurden.  Wir haben zwei wichtige Schlussfolgerungen gezogen: </p><br><ol><li> Der Hauptgrund lag im Linux-Kernel selbst.  Aufgrund der Struktur von Dentry-Cache-Objekten im Kernel hat das Verhalten eines Prozesses den Aufruf des Kernels <code>__d_lookup_loop</code> stark <code>__d_lookup_loop</code> , was sich direkt auf die Leistung eines anderen Kernels <code>__d_lookup_loop</code> . </li><li>  Der Autor hat <code>perf</code> , um Fehler im Kernel zu erkennen.  Ein großartiges Debugging-Tool, das wir noch nie benutzt haben (was schade ist!). </li></ol><br><blockquote>  perf (manchmal auch als perf_events oder perf tools bezeichnet; früher bekannt als Performance Counters for Linux, PCL) ist ein Linux-Tool zur Leistungsanalyse, das ab Kernel Version 2.6.31 verfügbar ist.  Das Dienstprogramm zur Verwaltung des Benutzerbereichs perf steht über die Befehlszeile zur Verfügung und ist eine Sammlung von Unterbefehlen. </blockquote><br><blockquote>  Es führt eine statistische Profilerstellung des gesamten Systems (Kernel und Benutzerbereich) durch.  Dieses Tool unterstützt Hardware- und Software-Leistungsindikatoren (z. B. HRTimer) -Plattformen, Ablaufverfolgungspunkte und dynamische Beispiele (z. B. kprobes oder uprobes).  Im Jahr 2012 erkannten zwei IBM-Ingenieure perf (zusammen mit OProfile) als eines der beiden am häufigsten verwendeten Tools zur Erstellung von Leistungsindikatoren unter Linux an. </blockquote><p>  Also dachten wir: Vielleicht haben wir das Gleiche?  Wir haben Hunderte verschiedener Prozesse in Containern gestartet und alle hatten den gleichen Kern.  Wir spürten, dass wir die Spur angegriffen hatten!  Mit <code>perf</code> bewaffnet wiederholten wir das Debuggen und warteten am Ende auf eine höchst interessante Entdeckung. </p><br><p>  Unten finden Sie die <code>perf</code> Einträge der ersten 10 Sekunden von ThoughtSpot, die auf einer gesunden (schnellen) Maschine (links) und im Container (rechts) ausgeführt werden. <br><img src="https://habrastorage.org/getpro/habr/post_images/82a/5a4/2a3/82a5a42a3c8de024901a4d21108469a4.png" alt="Bild"></p><br><p>  Es ist sofort klar, dass rechts die ersten 5 Aufrufe mit dem Kernel verbunden sind.  Die Zeit wird hauptsächlich für den Kernel-Speicherplatz aufgewendet, während sie sich links befindet. Die meiste Zeit wird für unsere eigenen Prozesse aufgewendet, die im Benutzerbereich ausgeführt werden.  Das Interessanteste ist jedoch, dass der Aufruf von <code>posix_fadvise</code> die ganze Zeit dauert. </p><br><blockquote>  Programme verwenden posix_fadvise () und erklären ihre Absicht, in Zukunft nach einem bestimmten Muster auf Dateidaten zuzugreifen.  Dies gibt dem Kernel die Möglichkeit, die notwendige Optimierung durchzuführen. </blockquote><p>  Der Aufruf wird für alle Situationen verwendet und gibt daher die Ursache des Problems nicht explizit an.  Beim Durchsuchen des Codes fand ich jedoch nur einen Ort, der theoretisch jeden Prozess im System betraf: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/12d/2ef/c14/12d2efc144b5e9e9babfb05180726c7b.png" alt="Bild"></p><br><p>  Dies ist eine Protokollierungsbibliothek eines Drittanbieters namens <code>glog</code> .  Wir haben es für das Projekt verwendet.  Insbesondere ist diese Zeile (in <code>LogFileObject::Write</code> ) wahrscheinlich der kritischste Pfad der gesamten Bibliothek.  Es wird für alle Ereignisse "Protokoll zu Datei" (Protokoll zu Datei) und viele Instanzen unseres Produktprotokolls ziemlich oft aufgerufen.  Ein kurzer Blick auf den Quellcode legt nahe, dass der Fadvise-Teil durch Setzen des Parameters <code>--drop_log_memory=false</code> deaktiviert werden kann: </p><br><pre> <code class="hljs php"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file_length_ &gt;= logging::kPageSize) { <span class="hljs-comment"><span class="hljs-comment">// don't evict the most recent page uint32 len = file_length_ &amp; ~(logging::kPageSize — 1); posix_fadvise(fileno(file_), 0, len, POSIX_FADV_DONTNEED); } }</span></span></code> </pre> <br><p>  was wir natürlich getan haben und ... im Bullauge! </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/07c/945/bb2/07c945bb2d23ede3c4bf64823120d2a3.png" alt="Bild"></p><br><p>  Was früher ein paar Sekunden dauerte, ist jetzt in <b>8</b> (acht!) Millisekunden erledigt.  Ein wenig googeln, fanden wir dies: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://issues.apache.org/jira/browse/MESOS-920</a> und auch dies: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/google/glog/pull/145</a> , was erneut bestätigt wurde unsere Vermutung über die wahre Ursache der Hemmung.  Höchstwahrscheinlich passierte dasselbe auf der virtuellen Maschine / dem Bare-Metal-System, aber da wir 1 Kopie des Prozesses pro Maschine / Kernel hatten, war die Intensität der Fadvise-Anrufe viel geringer, was den Mangel an zusätzlichem Ressourcenverbrauch erklärte.  Als wir die Protokollierungsprozesse um das 3-4-fache erhöhten und einen gemeinsamen Kern für sie hervorhoben, stellten wir fest, dass Fadvise wirklich ins Stocken geriet. </p><br><p>  Und zum Schluss: </p><br><p>  Diese Informationen sind nicht neu, aber aus irgendeinem Grund vergessen viele Menschen die Hauptsache: In Fällen mit Containern konkurrieren „isolierte“ Prozesse um <b>alle Kernressourcen</b> und nicht nur um <b>CPU</b> , <b>RAM</b> , <b>Speicherplatz</b> und <b>Netzwerk</b> .  Und da der Kernel eine äußerst komplexe Struktur ist, können Abstürze überall auftreten (wie zum Beispiel in <code>__d_lookup_loop</code> aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sysdig-Artikel</a> ).  Dies bedeutet jedoch nicht, dass Container schlechter oder besser sind als herkömmliche Virtualisierung.  Sie sind ein hervorragendes Werkzeug, um ihre Aufgaben zu lösen.  Denken Sie daran: Der Kernel ist eine gemeinsam genutzte Ressource und bereiten Sie sich darauf vor, unerwartete Konflikte im Kernelbereich zu debuggen.  Darüber hinaus bieten solche Konflikte Angreifern eine hervorragende Gelegenheit, die „verdünnte“ Isolation zu durchbrechen und verborgene Kanäle zwischen den Containern zu schaffen.  Und schließlich gibt es <code>perf</code> - ein hervorragendes Tool, das zeigt, was im System passiert, und hilft, Leistungsprobleme zu beheben.  Wenn Sie hochgeladene Anwendungen in Docker ausführen möchten, nehmen Sie sich Zeit, um <code>perf</code> zu lernen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de429788/">https://habr.com/ru/post/de429788/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de429776/index.html">Zusammenfassung des Berichts „Monolith für Hunderte von Client-Versionen“ (HL2018, Badoo, Vladimir Yants)</a></li>
<li><a href="../de429778/index.html">Sprachschnittstellenkonzept des Computersystems zur Unterstützung von Menschen mit Sprachbehinderungen</a></li>
<li><a href="../de429780/index.html">Modernes C ++! = (Meist) neuer Standard</a></li>
<li><a href="../de429782/index.html">Die Geschichte, wie wir Tests 12 Mal beschleunigt haben</a></li>
<li><a href="../de429786/index.html">Fast Sin and Cos auf eingebettetem ASM für Delphi</a></li>
<li><a href="../de429790/index.html">Julia und die Bewegung eines geladenen Teilchens in einem elektromagnetischen Feld</a></li>
<li><a href="../de429792/index.html">Physikbasierte künstliche Intelligenz kann auf die Gesetze imaginärer Universen schließen</a></li>
<li><a href="../de429794/index.html">Google spricht über ein exponentielles KI-Wachstum, das die Art des Computing verändert</a></li>
<li><a href="../de429796/index.html">Wie DeviceLock DLP vertrauliche Datenlecks auf GitHub verhindert</a></li>
<li><a href="../de429798/index.html">Verkauf von Plug-in-Elektrofahrzeugen in den USA (mit Grafiken): Oktober 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>