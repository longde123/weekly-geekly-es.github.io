<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö¥üèª üñêüèæ üë©üèº‚Äçüíª Ein weiterer Grund, warum Docker-Container verlangsamt werden üë∏üèø üö¢ ‚úçüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im letzten Beitrag habe ich √ºber Kubernetes gesprochen, wie ThoughtSpot es f√ºr seine eigenen Entwicklungsunterst√ºtzungsbed√ºrfnisse verwendet. Heute m√∂...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ein weiterer Grund, warum Docker-Container verlangsamt werden</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/429788/"><p>  Im letzten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag habe</a> ich √ºber Kubernetes gesprochen, wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ThoughtSpot</a> es f√ºr seine eigenen Entwicklungsunterst√ºtzungsbed√ºrfnisse verwendet.  Heute m√∂chte ich das Gespr√§ch √ºber eine kurze, aber nicht weniger interessante Debugging-Geschichte fortsetzen, die k√ºrzlich stattgefunden hat.  Der Artikel basiert auf der Tatsache, dass Containerisierung! = Virtualisierung.  Dar√ºber hinaus wird gezeigt, wie containerisierte Prozesse auch bei optimalen Einschr√§nkungen der cgroup und hoher Maschinenleistung um Ressourcen konkurrieren. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/297/09a/dfa/29709adfa1fa1830ee869e441e343fcf.png" alt="Bild"></p><a name="habracut"></a><br><p>  Zuvor haben wir eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihe von Vorg√§ngen im Zusammenhang mit der Entwicklung von b CI / CD</a> im internen Kubernetes-Cluster gestartet.  Alles w√§re in Ordnung, aber wenn Sie eine "Docker" -Anwendung starten, sinkt die Leistung pl√∂tzlich dramatisch.  Wir waren nicht geizig: In jedem der Container gab es Einschr√§nkungen hinsichtlich der Rechenleistung und des Arbeitsspeichers (5 CPU / 30 GB RAM), die durch die Pod-Konfiguration festgelegt wurden.  Auf einer virtuellen Maschine mit solchen Parametern w√ºrden alle unsere Anforderungen aus einem winzigen Datensatz (10 KB) f√ºr Tests fliegen.  In Docker &amp; Kubernetes mit 72 CPU / 512 GB RAM konnten wir jedoch 3-4 Kopien des Produkts starten, und dann wurden die Bremsen gestartet.  Anforderungen, die fr√ºher in ein paar Millisekunden abgeschlossen wurden, hingen jetzt 1-2 Sekunden lang, und dies verursachte alle Arten von Fehlern in der CI-Task-Pipeline.  Ich musste mich eng mit dem Debuggen befassen. </p><br><p>  In der Regel werden alle Arten von Konfigurationsfehlern beim Packen einer Anwendung in Docker vermutet.  Wir haben jedoch nichts gefunden, was zumindest zu einer Verlangsamung f√ºhren k√∂nnte (im Vergleich zu Installationen auf nackter Hardware oder virtuellen Maschinen).  Alles scheint richtig zu sein.  Als n√§chstes haben wir alle Arten von Tests aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sysbench-</a> Paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausprobiert</a> .  Wir haben die Leistung von CPU, Festplatte und Speicher √ºberpr√ºft - alles war das gleiche wie bei Bare Metal.  Einige Services unseres Produktspeichers enthalten detaillierte Informationen zu allen Aktionen: Sie k√∂nnen dann zur Profilerstellung verwendet werden.  Wenn eine Ressource (CPU, RAM, Festplatte, Netzwerk) knapp ist, tritt bei einigen Aufrufen in der Regel ein erheblicher Zeitfehler auf. Wir finden also heraus, was genau und wo langsamer wird.  In diesem Fall ist jedoch nichts passiert.  Die zeitlichen Proportionen unterschieden sich nicht von der Arbeitskonfiguration - mit dem einzigen Unterschied, dass jeder Anruf viel langsamer war als bei Bare Metal.  Nichts deutete auf die wahre Ursache des Problems hin.  Wir waren bereit aufzugeben, als wir dies pl√∂tzlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fanden</a> . </p><br><p>  In diesem Artikel analysiert der Autor einen √§hnlichen mysteri√∂sen Fall, in dem sich zwei prinzipielle Lichtprozesse gegenseitig t√∂teten, wenn sie in Docker auf demselben Computer ausgef√ºhrt wurden, und die Ressourcenlimits auf sehr bescheidene Werte festgelegt wurden.  Wir haben zwei wichtige Schlussfolgerungen gezogen: </p><br><ol><li> Der Hauptgrund lag im Linux-Kernel selbst.  Aufgrund der Struktur von Dentry-Cache-Objekten im Kernel hat das Verhalten eines Prozesses den Aufruf des Kernels <code>__d_lookup_loop</code> stark <code>__d_lookup_loop</code> , was sich direkt auf die Leistung eines anderen Kernels <code>__d_lookup_loop</code> . </li><li>  Der Autor hat <code>perf</code> , um Fehler im Kernel zu erkennen.  Ein gro√üartiges Debugging-Tool, das wir noch nie benutzt haben (was schade ist!). </li></ol><br><blockquote>  perf (manchmal auch als perf_events oder perf tools bezeichnet; fr√ºher bekannt als Performance Counters for Linux, PCL) ist ein Linux-Tool zur Leistungsanalyse, das ab Kernel Version 2.6.31 verf√ºgbar ist.  Das Dienstprogramm zur Verwaltung des Benutzerbereichs perf steht √ºber die Befehlszeile zur Verf√ºgung und ist eine Sammlung von Unterbefehlen. </blockquote><br><blockquote>  Es f√ºhrt eine statistische Profilerstellung des gesamten Systems (Kernel und Benutzerbereich) durch.  Dieses Tool unterst√ºtzt Hardware- und Software-Leistungsindikatoren (z. B. HRTimer) -Plattformen, Ablaufverfolgungspunkte und dynamische Beispiele (z. B. kprobes oder uprobes).  Im Jahr 2012 erkannten zwei IBM-Ingenieure perf (zusammen mit OProfile) als eines der beiden am h√§ufigsten verwendeten Tools zur Erstellung von Leistungsindikatoren unter Linux an. </blockquote><p>  Also dachten wir: Vielleicht haben wir das Gleiche?  Wir haben Hunderte verschiedener Prozesse in Containern gestartet und alle hatten den gleichen Kern.  Wir sp√ºrten, dass wir die Spur angegriffen hatten!  Mit <code>perf</code> bewaffnet wiederholten wir das Debuggen und warteten am Ende auf eine h√∂chst interessante Entdeckung. </p><br><p>  Unten finden Sie die <code>perf</code> Eintr√§ge der ersten 10 Sekunden von ThoughtSpot, die auf einer gesunden (schnellen) Maschine (links) und im Container (rechts) ausgef√ºhrt werden. <br><img src="https://habrastorage.org/getpro/habr/post_images/82a/5a4/2a3/82a5a42a3c8de024901a4d21108469a4.png" alt="Bild"></p><br><p>  Es ist sofort klar, dass rechts die ersten 5 Aufrufe mit dem Kernel verbunden sind.  Die Zeit wird haupts√§chlich f√ºr den Kernel-Speicherplatz aufgewendet, w√§hrend sie sich links befindet. Die meiste Zeit wird f√ºr unsere eigenen Prozesse aufgewendet, die im Benutzerbereich ausgef√ºhrt werden.  Das Interessanteste ist jedoch, dass der Aufruf von <code>posix_fadvise</code> die ganze Zeit dauert. </p><br><blockquote>  Programme verwenden posix_fadvise () und erkl√§ren ihre Absicht, in Zukunft nach einem bestimmten Muster auf Dateidaten zuzugreifen.  Dies gibt dem Kernel die M√∂glichkeit, die notwendige Optimierung durchzuf√ºhren. </blockquote><p>  Der Aufruf wird f√ºr alle Situationen verwendet und gibt daher die Ursache des Problems nicht explizit an.  Beim Durchsuchen des Codes fand ich jedoch nur einen Ort, der theoretisch jeden Prozess im System betraf: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/12d/2ef/c14/12d2efc144b5e9e9babfb05180726c7b.png" alt="Bild"></p><br><p>  Dies ist eine Protokollierungsbibliothek eines Drittanbieters namens <code>glog</code> .  Wir haben es f√ºr das Projekt verwendet.  Insbesondere ist diese Zeile (in <code>LogFileObject::Write</code> ) wahrscheinlich der kritischste Pfad der gesamten Bibliothek.  Es wird f√ºr alle Ereignisse "Protokoll zu Datei" (Protokoll zu Datei) und viele Instanzen unseres Produktprotokolls ziemlich oft aufgerufen.  Ein kurzer Blick auf den Quellcode legt nahe, dass der Fadvise-Teil durch Setzen des Parameters <code>--drop_log_memory=false</code> deaktiviert werden kann: </p><br><pre> <code class="hljs php"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file_length_ &gt;= logging::kPageSize) { <span class="hljs-comment"><span class="hljs-comment">// don't evict the most recent page uint32 len = file_length_ &amp; ~(logging::kPageSize ‚Äî 1); posix_fadvise(fileno(file_), 0, len, POSIX_FADV_DONTNEED); } }</span></span></code> </pre> <br><p>  was wir nat√ºrlich getan haben und ... im Bullauge! </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/07c/945/bb2/07c945bb2d23ede3c4bf64823120d2a3.png" alt="Bild"></p><br><p>  Was fr√ºher ein paar Sekunden dauerte, ist jetzt in <b>8</b> (acht!) Millisekunden erledigt.  Ein wenig googeln, fanden wir dies: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://issues.apache.org/jira/browse/MESOS-920</a> und auch dies: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/google/glog/pull/145</a> , was erneut best√§tigt wurde unsere Vermutung √ºber die wahre Ursache der Hemmung.  H√∂chstwahrscheinlich passierte dasselbe auf der virtuellen Maschine / dem Bare-Metal-System, aber da wir 1 Kopie des Prozesses pro Maschine / Kernel hatten, war die Intensit√§t der Fadvise-Anrufe viel geringer, was den Mangel an zus√§tzlichem Ressourcenverbrauch erkl√§rte.  Als wir die Protokollierungsprozesse um das 3-4-fache erh√∂hten und einen gemeinsamen Kern f√ºr sie hervorhoben, stellten wir fest, dass Fadvise wirklich ins Stocken geriet. </p><br><p>  Und zum Schluss: </p><br><p>  Diese Informationen sind nicht neu, aber aus irgendeinem Grund vergessen viele Menschen die Hauptsache: In F√§llen mit Containern konkurrieren ‚Äûisolierte‚Äú Prozesse um <b>alle Kernressourcen</b> und nicht nur um <b>CPU</b> , <b>RAM</b> , <b>Speicherplatz</b> und <b>Netzwerk</b> .  Und da der Kernel eine √§u√üerst komplexe Struktur ist, k√∂nnen Abst√ºrze √ºberall auftreten (wie zum Beispiel in <code>__d_lookup_loop</code> aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sysdig-Artikel</a> ).  Dies bedeutet jedoch nicht, dass Container schlechter oder besser sind als herk√∂mmliche Virtualisierung.  Sie sind ein hervorragendes Werkzeug, um ihre Aufgaben zu l√∂sen.  Denken Sie daran: Der Kernel ist eine gemeinsam genutzte Ressource und bereiten Sie sich darauf vor, unerwartete Konflikte im Kernelbereich zu debuggen.  Dar√ºber hinaus bieten solche Konflikte Angreifern eine hervorragende Gelegenheit, die ‚Äûverd√ºnnte‚Äú Isolation zu durchbrechen und verborgene Kan√§le zwischen den Containern zu schaffen.  Und schlie√ülich gibt es <code>perf</code> - ein hervorragendes Tool, das zeigt, was im System passiert, und hilft, Leistungsprobleme zu beheben.  Wenn Sie hochgeladene Anwendungen in Docker ausf√ºhren m√∂chten, nehmen Sie sich Zeit, um <code>perf</code> zu lernen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de429788/">https://habr.com/ru/post/de429788/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de429776/index.html">Zusammenfassung des Berichts ‚ÄûMonolith f√ºr Hunderte von Client-Versionen‚Äú (HL2018, Badoo, Vladimir Yants)</a></li>
<li><a href="../de429778/index.html">Sprachschnittstellenkonzept des Computersystems zur Unterst√ºtzung von Menschen mit Sprachbehinderungen</a></li>
<li><a href="../de429780/index.html">Modernes C ++! = (Meist) neuer Standard</a></li>
<li><a href="../de429782/index.html">Die Geschichte, wie wir Tests 12 Mal beschleunigt haben</a></li>
<li><a href="../de429786/index.html">Fast Sin and Cos auf eingebettetem ASM f√ºr Delphi</a></li>
<li><a href="../de429790/index.html">Julia und die Bewegung eines geladenen Teilchens in einem elektromagnetischen Feld</a></li>
<li><a href="../de429792/index.html">Physikbasierte k√ºnstliche Intelligenz kann auf die Gesetze imagin√§rer Universen schlie√üen</a></li>
<li><a href="../de429794/index.html">Google spricht √ºber ein exponentielles KI-Wachstum, das die Art des Computing ver√§ndert</a></li>
<li><a href="../de429796/index.html">Wie DeviceLock DLP vertrauliche Datenlecks auf GitHub verhindert</a></li>
<li><a href="../de429798/index.html">Verkauf von Plug-in-Elektrofahrzeugen in den USA (mit Grafiken): Oktober 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>