<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òòÔ∏è ‚õ©Ô∏è üíµ Analysieren und Arbeiten mit Codable in Swift 4 ü§úüèø üç∏ ‚èØÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das JSON-Format erfreut sich gro√üer Beliebtheit und wird normalerweise f√ºr die Daten√ºbertragung und die Ausf√ºhrung von Abfragen in Client-Server-Anwen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analysieren und Arbeiten mit Codable in Swift 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414221/"><img src="https://habrastorage.org/webt/ps/2a/r0/ps2ar08o0byyxycknlktyhdafoq.jpeg"><br><br>  Das JSON-Format erfreut sich gro√üer Beliebtheit und wird normalerweise f√ºr die Daten√ºbertragung und die Ausf√ºhrung von Abfragen in Client-Server-Anwendungen verwendet.  F√ºr die JSON-Analyse sind Codierungs- / Decodierungswerkzeuge dieses Formats erforderlich, die von Apple k√ºrzlich aktualisiert wurden.  In diesem Artikel werden wir uns mit JSON-Analysemethoden unter Verwendung des <i>Decodable-</i> Protokolls <i>befassen</i> , das neue <i>Codable-</i> Protokoll mit dem Vorg√§nger- <i>NSCoding vergleichen</i> , die Vor- und Nachteile bewerten, alles <i>anhand</i> spezifischer Beispiele analysieren und auch einige Funktionen ber√ºcksichtigen, die bei der Implementierung der Protokolle auftreten. <br><a name="habracut"></a><br><br>  <b>Was ist codierbar?</b> <br><br>  Auf der WWDC2017 stellte Apple zusammen mit der neuen Version von Swift 4 neue Tools zur Datencodierung / -decodierung vor, die von den folgenden drei Protokollen implementiert werden: <br><br>  - <b>Codierbar</b> <br>  - <b>Codierbar</b> <br>  - <b>Dekodierbar</b> <br><br>  In den meisten F√§llen werden diese Protokolle f√ºr die Arbeit mit JSON verwendet. Dar√ºber hinaus werden sie jedoch auch zum Speichern von Daten auf der Festplatte, zum √úbertragen √ºber das Netzwerk usw. verwendet.  Encodable wird verwendet, um Swift-Datenstrukturen in JSON-Objekte zu konvertieren, w√§hrend Decodable im Gegensatz dazu hilft, JSON-Objekte in Swift-Datenmodelle zu konvertieren.  Das codierbare Protokoll kombiniert die beiden vorherigen und ist ihre Typealien: <br><br><pre><code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Codable</span></span> = <span class="hljs-type"><span class="hljs-type">Encodable</span></span> &amp; <span class="hljs-type"><span class="hljs-type">Decodable</span></span></code> </pre> <br><br>  Um diesen Protokollen zu entsprechen, m√ºssen Datentypen die folgenden Methoden implementieren: <br><br>  <i>Codierbar</i> <br>  encode (to :) - codiert das Datenmodell in den angegebenen Encodertyp <br><br>  <i>Dekodierbar</i> <br>  init (from :) - initialisiert das Datenmodell vom bereitgestellten Decoder <br><br>  <i>Codierbar</i> <br>  codieren (zu :) <br>  init (von :) <br><br>  <b>Ein einfacher Anwendungsfall</b> <br><br>  Betrachten Sie nun ein einfaches Beispiel f√ºr die Verwendung von <i>Codable</i> , da es sowohl <i>Encodable</i> als auch <i>Decodable implementiert</i> . In diesem Beispiel k√∂nnen Sie sofort alle Protokollfunktionen sehen.  Angenommen, wir haben die einfachste JSON-Datenstruktur: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Nike shoes"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"price"</span></span>: <span class="hljs-number"><span class="hljs-number">10.5</span></span>, <span class="hljs-attr"><span class="hljs-attr">"quantity"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br><br>  Das Datenmodell f√ºr die Arbeit mit diesem JSON sieht folgenderma√üen aus: <br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title:<span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> price:<span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> quantity:<span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKeys</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> title <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> price <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> quantity } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to encoder: Encoder)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container = encoder.container(keyedBy: <span class="hljs-type"><span class="hljs-type">CodingKeys</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.encode(title, forKey: .title) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.encode(price, forKey: .price) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.encode(quantity, forKey: .quantity) } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(from decoder: <span class="hljs-type"><span class="hljs-type">Decoder</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> decoder.container(keyedBy: <span class="hljs-type"><span class="hljs-type">CodingKeys</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) title = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.decode(<span class="hljs-type"><span class="hljs-type">String</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .title) price = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.decode(<span class="hljs-type"><span class="hljs-type">Double</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .price) quantity = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.decode(<span class="hljs-type"><span class="hljs-type">Int</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .quantity) } }</code> </pre><br><br>  Beide notwendigen Methoden sind implementiert, die Aufz√§hlung wird auch beschrieben, um die Liste der Codierungs- / Decodierungsfelder zu bestimmen.  Tats√§chlich kann das Schreiben erheblich vereinfacht werden, da <i>Codable</i> die <i>automatische Generierung</i> der Methoden encode (to :) und init (from :) sowie die erforderliche Aufz√§hlung unterst√ºtzt.  Das hei√üt, in diesem Fall k√∂nnen Sie die Struktur wie folgt schreiben: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title:<span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> price:<span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> quantity:<span class="hljs-type"><span class="hljs-type">Int</span></span> }</code> </pre> <br><br>  Extrem einfach und minimalistisch.  Vergessen Sie nur nicht, dass eine so pr√§zise Aufnahme nicht funktioniert, wenn: <br><br>  - Die <i>Struktur Ihres Datenmodells unterscheidet sich von der, die Sie codieren / decodieren m√∂chten</i> <br><br>  - <i>M√∂glicherweise m√ºssen Sie neben den Eigenschaften Ihres Datenmodells weitere Eigenschaften codieren / decodieren</i> <br><br>  - <i>Einige Eigenschaften Ihres Datenmodells unterst√ºtzen das codierbare Protokoll m√∂glicherweise nicht.</i>  <i>In diesem Fall m√ºssen Sie sie vom / zum codierbaren Protokoll konvertieren</i> <br><br>  - <i>falls die Variablennamen im Datenmodell und die Feldnamen im Container nicht mit Ihnen √ºbereinstimmen</i> <br><br>  Da wir bereits die einfachste Definition eines Datenmodells in Betracht gezogen haben, lohnt es sich, ein kleines Beispiel f√ºr seine praktische Verwendung zu geben: <br><br>  In einer Zeile k√∂nnen Sie also die Serverantwort im JSON-Format analysieren: <br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> product: <span class="hljs-type"><span class="hljs-type">Product</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>! <span class="hljs-type"><span class="hljs-type">JSONDecoder</span></span>().decode(<span class="hljs-type"><span class="hljs-type">Product</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: data)</code> </pre> <br><br>  Im Gegensatz dazu erstellt der folgende Code ein JSON-Objekt aus dem Datenmodell: <br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> productObject = <span class="hljs-type"><span class="hljs-type">Product</span></span>(title: <span class="hljs-string"><span class="hljs-string">"Cheese"</span></span>, price: <span class="hljs-number"><span class="hljs-number">10.5</span></span>, quantity: <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> encodedData = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-type"><span class="hljs-type">JSONEncoder</span></span>().encode(productObject)</code> </pre> <br><br>  Alles ist sehr bequem und schnell.  <i>Nachdem Sie</i> die Datenmodelle korrekt beschrieben und <i>codierbar gemacht haben</i> , k√∂nnen Sie Daten buchst√§blich in einer Zeile codieren / decodieren.  Wir haben jedoch das einfachste Datenmodell betrachtet, das eine kleine Anzahl von Feldern eines einfachen Typs enth√§lt.  Betrachten Sie die m√∂glichen Probleme: <br><br>  <b>Nicht alle Felder im Datenmodell sind codierbar.</b> <br><br>  Damit Ihr Datenmodell das <i>codierbare</i> Protokoll implementieren kann <i>, m√ºssen</i> alle Felder des Modells dieses Protokoll unterst√ºtzen.  Standardm√§√üig unterst√ºtzt das <i>Codable-</i> Protokoll die folgenden Datentypen: <i>String, Int, Double, Data, URL</i> .  <i>Codable</i> unterst√ºtzt auch <i>Array, Dictionary, Optional</i> , jedoch nur, wenn sie <i>codierbare</i> Typen enthalten.  Wenn einige Eigenschaften des Datenmodells nicht <i>Codable</i> entsprechen, <i>m√ºssen</i> sie <i>dorthin</i> gebracht werden. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pet</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> age: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> type: <span class="hljs-type"><span class="hljs-type">PetType</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKeys</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> age <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> type } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(from decoder: <span class="hljs-type"><span class="hljs-type">Decoder</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> { . . . } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to encoder: Encoder)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> { . . . } }</code> </pre> <br><br>  Wenn wir in unserem <i>codierbaren</i> Datenmodell einen benutzerdefinierten Typ verwenden, z. B. <i>PetType</i> , und ihn codieren / decodieren m√∂chten, muss er auch dessen Init und Codierung implementieren. <br><br>  <b>Das Datenmodell stimmt nicht mit JSON-Feldern √ºberein</b> <br><br>  Wenn in Ihrem Datenmodell 3 Felder definiert sind und 5 Felder im JSON-Objekt zu Ihnen kommen, von denen 2 zus√§tzlich zu 3 sind, √§ndert sich beim Parsen nichts. Sie erhalten nur Ihre 3 Felder aus diesen 5. Wenn das Gegenteil passiert Situation und im JSON-Objekt gibt es mindestens ein Feld des Datenmodells, ein Laufzeitfehler wird auftreten. <br>  Wenn einige Felder in einem JSON-Objekt optional sind und regelm√§√üig fehlen, m√ºssen Sie sie in diesem Fall optional machen: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> productTypeId: <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> art: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> price: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currencyId: <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> brandId: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> brand: <span class="hljs-type"><span class="hljs-type">Brand?</span></span> }</code> </pre> <br><br>  <b>Verwendung komplexerer JSON-Strukturen</b> <br><br>  Oft ist die Serverantwort ein Array von Entit√§ten, dh Sie fordern beispielsweise eine Liste von Gesch√§ften an und erhalten eine Antwort in der Form: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"items"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"link"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://www.youtube.com/watch?v=Myp6rSeCMUw"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"created_at"</span></span>: <span class="hljs-number"><span class="hljs-number">1497868174</span></span>, <span class="hljs-attr"><span class="hljs-attr">"previewImage"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://img.youtube.com/vi/Myp6rSeCMUw/mqdefault.jpg"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"  2"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"link"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://www.youtube.com/watch?v=wsCEuNJmvd8"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"created_at"</span></span>: <span class="hljs-number"><span class="hljs-number">1525952040</span></span>, <span class="hljs-attr"><span class="hljs-attr">"previewImage"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://img.youtube.com/vi/wsCEuNJmvd8/mqdefault.jpg"</span></span> } ] }</code> </pre><br>  In diesem Fall k√∂nnen Sie es einfach als Array von <i>Shop-</i> Entit√§ten schreiben und dekodieren. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShopListResponse</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Decodable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKeys</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> items } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> items: [<span class="hljs-type"><span class="hljs-type">Shop</span></span>] }</code> </pre> <br><br>  In diesem Beispiel funktioniert die automatische Funktion <i>init.</i> Wenn Sie jedoch selbst eine Dekodierung schreiben m√∂chten, m√ºssen Sie den dekodierten Typ als Array angeben: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.items = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.decode([<span class="hljs-type"><span class="hljs-type">Shop</span></span>].<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .items)</code> </pre> <br><br>  Die <i>Shop-</i> Struktur sollte auch das <i>Decodable-</i> Protokoll implementieren <i>.</i> <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shop</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Decodable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id: <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> address: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shortAddress: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> createdAt: <span class="hljs-type"><span class="hljs-type">Date?</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKeys</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> title <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> address <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> shortAddress = <span class="hljs-string"><span class="hljs-string">"short_address"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> createdAt = <span class="hljs-string"><span class="hljs-string">"created_at"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(from decoder: <span class="hljs-type"><span class="hljs-type">Decoder</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> decoder.container(keyedBy: <span class="hljs-type"><span class="hljs-type">CodingKeys</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.id = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? container.decode(<span class="hljs-type"><span class="hljs-type">Int</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .id) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.title = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? container.decode(<span class="hljs-type"><span class="hljs-type">String</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .title) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.address = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? container.decode(<span class="hljs-type"><span class="hljs-type">String</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .address) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.shortAddress = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? container.decode(<span class="hljs-type"><span class="hljs-type">String</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .shortAddress) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.createdAt = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? container.decode(<span class="hljs-type"><span class="hljs-type">Date</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .createdAt) } }</code> </pre> <br><br>  Das Parsen dieses Arrays von Elementen sieht folgenderma√üen aus: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parsedResult: <span class="hljs-type"><span class="hljs-type">ShopListResponse</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-type"><span class="hljs-type">JSONDecoder</span></span>().decode(<span class="hljs-type"><span class="hljs-type">ShopListResponse</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, from: data)</code> </pre> <br><br>  Auf diese Weise k√∂nnen Sie problemlos mit Arrays von Datenmodellen arbeiten und diese in anderen Modellen verwenden. <br><br>  <b>Datumsformat</b> <br><br>  In diesem Beispiel gibt es noch eine Nuance. Hier haben wir zuerst die Verwendung des <i>Datums-</i> Typs <i>festgestellt</i> .  Bei Verwendung dieses Typs k√∂nnen Probleme mit der Datumscodierung auftreten, und normalerweise stimmt dieses Problem mit dem Backend √ºberein.  Das Standardformat ist <i>.deferToDate</i> : <br><br><pre> <code class="hljs vbscript">struct MyDate : Encodable { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myDate = MyDate(<span class="hljs-built_in"><span class="hljs-built_in">date</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>()) try! encoder.encode(foo)</code> </pre> <br><br>  <i>myDate</i> sieht folgenderma√üen aus: <br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"date"</span></span> : <span class="hljs-number"><span class="hljs-number">519751611.12542897</span></span> }</code> </pre> <br><br>  Wenn wir beispielsweise das <i>.iso8601-</i> Format verwenden m√ºssen, k√∂nnen wir das Format mithilfe der <i>dateEncodingStrategy-</i> Eigenschaft einfach √§ndern: <br><br><pre> <code class="hljs">encoder.dateEncodingStrategy = .iso8601</code> </pre> <br><br>  Jetzt sieht das Datum folgenderma√üen aus: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"date"</span></span> : <span class="hljs-string"><span class="hljs-string">"2017-06-21T15:29:32Z"</span></span> }</code> </pre><br>  Sie k√∂nnen auch ein benutzerdefiniertes Datumsformat verwenden oder sogar Ihren eigenen Datumsdecoder mit den folgenden Formatierungsoptionen schreiben: <br><br>  <i>.formatiert (DateFormatter)</i> - ein eigenes <i>Datumsdecoderformat</i> <br>  <i>.custom ((Date, Encoder) throw -&gt; Void)</i> - Erstellen Sie Ihr eigenes <i>Datumsdecodierungsformat</i> vollst√§ndig <br><br>  <b>Verschachtelte Objekte analysieren</b> <br><br>  Wir haben bereits untersucht, wie Sie Datenmodelle in anderen Modellen verwenden k√∂nnen. Manchmal ist es jedoch erforderlich, die in anderen Feldern enthaltenen JSON-Felder zu analysieren, ohne ein separates Datenmodell zu verwenden.  Das Problem wird klarer, wenn wir es anhand eines Beispiels betrachten.  Wir haben den folgenden JSON: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">349</span></span>, <span class="hljs-attr"><span class="hljs-attr">"art"</span></span>: <span class="hljs-string"><span class="hljs-string">"M0470500"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"- Vichy 50 "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ratings"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"average_rating"</span></span>: <span class="hljs-number"><span class="hljs-number">4.1034</span></span>, <span class="hljs-attr"><span class="hljs-attr">"votes_count"</span></span>: <span class="hljs-number"><span class="hljs-number">29</span></span> } }</code> </pre> <br><br>  Wir m√ºssen die <i>Felder</i> <i>"Durchschnitt"</i> und <i>"Stimmenzahl" analysieren</i> . Dies kann auf zwei Arten gel√∂st werden: Erstellen Sie entweder ein Bewertungsdatenmodell mit zwei Feldern und speichern Sie die Daten darin, oder Sie k√∂nnen <i>nestedContainer verwenden</i> .  Wir haben bereits den ersten Fall besprochen, und die Verwendung des zweiten wird folgenderma√üen aussehen: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Decodable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> art: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> votesCount: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> averageRating: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKeys</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> art <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> title <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ratings } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RatingsCodingKeys</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> votesCount = <span class="hljs-string"><span class="hljs-string">"votes_count"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> averageRating = <span class="hljs-string"><span class="hljs-string">"average_rating"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(from decoder: <span class="hljs-type"><span class="hljs-type">Decoder</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> decoder.container(keyedBy: <span class="hljs-type"><span class="hljs-type">CodingKeys</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.id = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.decode(<span class="hljs-type"><span class="hljs-type">Int</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .id) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.art = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? container.decode(<span class="hljs-type"><span class="hljs-type">String</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .art) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.title = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? container.decode(<span class="hljs-type"><span class="hljs-type">String</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .title) <span class="hljs-comment"><span class="hljs-comment">// Nested ratings let ratingsContainer = try container.nestedContainer(keyedBy: RatingsCodingKeys.self, forKey: .ratings) self.votesCount = try ratingsContainer.decode(Int.self, forKey: .votesCount) self.averageRating = try ratingsContainer.decode(Double.self, forKey: .averageRating) } }</span></span></code> </pre> <br><br>  Das hei√üt, dieses Problem wird gel√∂st, indem ein weiterer zus√§tzlicher Container mit <i>nestedContainter</i> und dessen weiterer Analyse erstellt wird.  Diese Option ist praktisch, wenn die Anzahl der verschachtelten Felder nicht so gro√ü ist. Andernfalls ist es besser, ein zus√§tzliches Datenmodell zu verwenden. <br><br>  <b>Nicht √ºbereinstimmende JSON-Feldnamen und Datenmodelleigenschaften</b> <br><br>  Wenn Sie darauf achten, wie die Aufz√§hlungen in unseren Datenmodellen definiert sind, k√∂nnen Sie sehen, dass den Elementen der Aufz√§hlungen manchmal eine Zeichenfolge zugewiesen wird, die den Standardwert √§ndert, zum Beispiel: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RatingsCodingKeys</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> votesCount = <span class="hljs-string"><span class="hljs-string">"votes_count"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> averageRating = <span class="hljs-string"><span class="hljs-string">"average_rating"</span></span> }</code> </pre> <br><br>  Dies geschieht, um die Namen der Modellvariablen und JSON-Felder korrekt abzugleichen.  Dies ist normalerweise f√ºr Felder erforderlich, deren Name aus mehreren W√∂rtern besteht, und in JSON werden sie durch Unterstriche getrennt.  Im Prinzip ist eine solche Neudefinition der Aufz√§hlung am beliebtesten und sieht einfach aus, aber selbst dann hat Apple eine elegantere L√∂sung gefunden.  Dieses Problem kann mit <i>keyDecodingStrategy</i> in einer Zeile <i>gel√∂st werden</i> .  Diese Funktion wurde in Swift 4.1 angezeigt <br><br>  Angenommen, Sie haben einen JSON der Form: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> jsonString = <span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">" [ { "</span></span>name<span class="hljs-string"><span class="hljs-string">": "</span></span>MacBook Pro<span class="hljs-string"><span class="hljs-string">", "</span></span>screen_size<span class="hljs-string"><span class="hljs-string">": 15, "</span></span>cpu_count<span class="hljs-string"><span class="hljs-string">": 4 }, { "</span></span>name<span class="hljs-string"><span class="hljs-string">": "</span></span>iMac Pro<span class="hljs-string"><span class="hljs-string">", "</span></span>screen_size<span class="hljs-string"><span class="hljs-string">": 27, "</span></span>cpu_count<span class="hljs-string"><span class="hljs-string">": 18 } ] "</span></span><span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> jsonData = Data(jsonString.utf8)</code> </pre> <br><br>  Erstellen wir ein Datenmodell daf√ºr: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mac</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> screenSize: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cpuCount: <span class="hljs-type"><span class="hljs-type">Int</span></span> }</code> </pre><br>  Variablen im Modell werden gem√§√ü der Vereinbarung aufgezeichnet, beginnen mit einem Kleinbuchstaben und jedes Wort beginnt mit einem Gro√übuchstaben (dem sogenannten <i>camelCase</i> ).  In JSON werden Felder jedoch mit Unterstrichen geschrieben (dem sogenannten <i>snake_case</i> ).  Damit das Parsen erfolgreich ist, m√ºssen wir entweder eine Aufz√§hlung im Datenmodell definieren, in der die Entsprechung der Namen der JSON-Felder mit den Namen der Variablen hergestellt wird, oder es wird ein Laufzeitfehler angezeigt.  Jetzt ist es jedoch m√∂glich, <i>keyDecodingStrategy</i> einfach zu definieren <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> decoder = <span class="hljs-type"><span class="hljs-type">JSONDecoder</span></span>() decoder.keyDecodingStrategy = .convertFromSnakeCase <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> macs = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> decoder.decode([<span class="hljs-type"><span class="hljs-type">Mac</span></span>].<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, from: jsonData) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(error.localizedDescription) }</code> </pre> <br><br>  F√ºr die <i>Codierungsfunktion</i> k√∂nnen Sie dementsprechend die inverse Transformation verwenden: <br><br><pre> <code class="hljs">encoder.keyEncodingStrategy = .convertToSnakeCase</code> </pre> <br><br>  Es ist auch m√∂glich, <i>keyDecodingStrategy</i> mithilfe des folgenden Abschlusses anzupassen: <br><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> jsonDecoder = JSONDecoder() jsonDecoder.keyDecodingStrategy = .custom { keys -&gt; CodingKey <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key = keys.last!.stringValue.split(separator: <span class="hljs-string"><span class="hljs-string">"-"</span></span>).joined() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PersonKey(stringValue: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(key))! }</code> </pre> <br><br>  Dieser Eintrag erm√∂glicht beispielsweise die Verwendung des Trennzeichens "-" f√ºr JSON.  Ein Beispiel f√ºr den verwendeten JSON: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"first-Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Taylor"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"last-Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Swift"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"age"</span></span>: <span class="hljs-number"><span class="hljs-number">28</span></span> }</code> </pre><br>  Daher kann eine zus√§tzliche Definition einer Aufz√§hlung h√§ufig vermieden werden. <br><br>  <b>Fehlerbehandlung</b> <br><br>  Wenn Sie JSON analysieren und Daten von einem Format in ein anderes konvertieren, sind Fehler unvermeidlich. Schauen wir uns also die Optionen f√ºr die Behandlung verschiedener Fehlertypen an.  Beim Decodieren sind folgende Fehlertypen m√∂glich: <br><br><ul><li>  <i>DecodingError.dataCorrupted (DecodingError.Context)</i> - Daten sind besch√§digt.  Normalerweise bedeutet dies, dass die Daten, die Sie dekodieren m√∂chten, nicht mit dem erwarteten Format √ºbereinstimmen. Beispielsweise haben Sie anstelle des erwarteten JSON ein v√∂llig anderes Format erhalten. </li><li>  <i>DecodingError.keyNotFound (CodingKey, DecodingError.Context)</i> - Das angeforderte Feld wurde nicht gefunden.  Bedeutet, dass das Feld, das Sie erwartet haben, fehlt </li><li>  <i>DecodingError.typeMismatch (Any.Type, DecodingError.Context)</i> - Typ Mismatch.  Wenn der Datentyp im Modell nicht mit dem Typ des empfangenen Felds √ºbereinstimmt </li><li>  <i>DecodingError.valueNotFound (Any.Type, DecodingError.Context)</i> - fehlender Wert f√ºr ein bestimmtes Feld.  Das Feld, das Sie im Datenmodell definiert haben, konnte nicht initialisiert werden. Wahrscheinlich ist dieses Feld in den empfangenen Daten gleich Null.  Dieser Fehler tritt nur bei nicht optionalen Feldern auf. Wenn das Feld keinen Wert haben muss, vergessen Sie nicht, es optional zu machen. </li></ul><br><br>  Beim Codieren von Daten ist ein Fehler m√∂glich: <br><br>  <i>EncodingError.invalidValue (Any.Type, DecodingError.Context)</i> - Das Datenmodell konnte nicht in ein bestimmtes Format konvertiert werden <br><br>  Ein Beispiel f√ºr die Fehlerbehandlung beim Parsen von JSON: <br><br><pre> <code class="hljs swift"> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> decoder = <span class="hljs-type"><span class="hljs-type">JSONDecoder</span></span>() <span class="hljs-number"><span class="hljs-number">_</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> decoder.decode(businessReviewResponse.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, from: data) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.dataCorrupted(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context) { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.dataCorrupted(context)) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.keyNotFound(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context) { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.keyNotFound(key,context)) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.typeMismatch(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context) { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.typeMismatch(type,context)) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.valueNotFound(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context) { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.valueNotFound(value,context)) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error{ <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(error) }</code> </pre> <br><br>  Die Fehlerverarbeitung ist nat√ºrlich besser, um eine separate Funktion einzurichten, aber hier wird aus Gr√ºnden der Klarheit die Fehleranalyse zusammen mit dem Parsen durchgef√ºhrt.  Die Fehlerausgabe, wenn f√ºr das Feld "Produkt" kein Wert vorhanden ist, sieht beispielsweise folgenderma√üen aus: <br><br><img src="https://habrastorage.org/webt/vs/1k/ej/vs1kejm3b5lnxigx-aulilgvvqu.jpeg" alt="Bild"><br><br>  <b>Vergleich von codierbarer und NSCoding</b> <br><br>  Nat√ºrlich ist das codierbare Protokoll ein gro√üer Fortschritt beim Codieren / Decodieren von Daten, aber das NSCoding-Protokoll existierte zuvor.  Versuchen wir, sie zu vergleichen und herauszufinden, welche Vorteile Codable hat: <br><br><ul><li>  Bei Verwendung des <i>NSCoding-</i> Protokolls muss das Objekt eine Unterklasse von <i>NSObject sein</i> , was automatisch impliziert, dass unser Datenmodell eine Klasse sein sollte.  In <i>Codable</i> ist keine Vererbung erforderlich. Das Datenmodell kann sowohl <i>Klasse als auch Struktur und Aufz√§hlung sein</i> . </li><li>  Wenn Sie separate Codierungs- und Decodierungsfunktionen ben√∂tigen, z. B. beim Parsen von √ºber die API empfangenen JSON-Daten, k√∂nnen Sie nur ein <i>decodierbares</i> Protokoll verwenden.  Das hei√üt, es besteht keine Notwendigkeit, die manchmal unn√∂tigen <i>Init-</i> oder <i>Codierungsmethoden</i> zu implementieren. </li><li>  Codable kann automatisch die erforderlichen <i>Init-</i> und <i>Codierungsmethoden</i> sowie die optionale <i>CodingKeys-</i> Aufz√§hlung <i>generieren</i> .  Dies funktioniert nat√ºrlich nur, wenn Sie einfache Felder in der Datenstruktur haben, andernfalls ist eine zus√§tzliche Anpassung erforderlich.  In den meisten F√§llen, insbesondere f√ºr grundlegende Datenstrukturen, k√∂nnen Sie die automatische Generierung verwenden, insbesondere wenn Sie <i>keyDecodingStrategy</i> neu <i>definieren</i> . Dies ist praktisch und reduziert unn√∂tigen Code. </li></ul><br><br>  Mit den <i>Protokollen</i> <i>Codable, Decodable</i> und <i>Encodable</i> konnten wir einen weiteren Schritt zur Bequemlichkeit der Datenkonvertierung unternehmen. Neue, flexiblere Parsing-Tools <i>wurden angezeigt,</i> die Codemenge wurde reduziert und ein Teil der Konvertierungsprozesse wurde automatisiert.  Protokolle werden nativ in Swift 4 implementiert und erm√∂glichen es, die Verwendung von Bibliotheken von Drittanbietern wie <i>SwiftyJSON zu reduzieren</i> und gleichzeitig die Benutzerfreundlichkeit zu <i>gew√§hrleisten</i> .  Protokolle erm√∂glichen es auch, die Codestruktur ordnungsgem√§√ü zu organisieren, indem Datenmodelle und Methoden f√ºr die Arbeit mit ihnen in separate Module unterteilt werden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414221/">https://habr.com/ru/post/de414221/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414211/index.html">Entwicklung eines TELNET-Servers auf Basis von W5500 und ATMEGA8</a></li>
<li><a href="../de414213/index.html">Eins zwei drei! Chatbot von Google Sheets am Beispiel eines PvP-Spiels f√ºr Alice</a></li>
<li><a href="../de414215/index.html">Benutzerdefinierte Bl√∂cke in Chips (Silicon IP): So funktioniert es</a></li>
<li><a href="../de414217/index.html">Lokale Vertex-Smartphones: zuerst in der Qualit√§t, zuerst in den Chips, zuerst im Design</a></li>
<li><a href="../de414219/index.html">Die Erfahrung mit der Nutzung von Solarenergie in der Region Moskau: f√ºr, gegen und wer sie braucht</a></li>
<li><a href="../de414223/index.html">C #: Abw√§rtskompatibilit√§t und √úberlastung</a></li>
<li><a href="../de414225/index.html">Erstellen eines eigenen Netzwerks von hausgemachten Ger√§ten basierend auf Arduino (Teil 1)</a></li>
<li><a href="../de414227/index.html">Eine neue Studie zu Telegrammindikatoren nach dem Blockieren: Abonnenten wachsen, Abdeckung sinkt</a></li>
<li><a href="../de414229/index.html">Analyse verschiedener IT-Schulungsmethoden</a></li>
<li><a href="../de414231/index.html">Wie ich einen v√∂llig leisen Computer gemacht habe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>