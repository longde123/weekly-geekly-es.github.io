<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔩 👈 ♻️ Mengapa Kubernet begitu rumit dengan repositori? 🏭 👨🏿‍💻 🕴🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ketika orkestra kontainer seperti Kubernetes tiba, pendekatan untuk mengembangkan dan menggunakan aplikasi berubah secara dramatis. Layanan Microsoft ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengapa Kubernet begitu rumit dengan repositori?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/441222/"><p><img src="https://habrastorage.org/webt/3w/v4/sh/3wv4sha9sfamx7elh4imtocvesm.jpeg"></p><br><p>  Ketika orkestra kontainer seperti Kubernetes tiba, pendekatan untuk mengembangkan dan menggunakan aplikasi berubah secara dramatis.  Layanan Microsoft telah muncul, dan untuk pengembang, logika aplikasi tidak lagi terhubung dengan infrastruktur: buat aplikasi untuk Anda sendiri dan tawarkan fungsi baru. </p><br><p>  Kubernet abstrak dari komputer fisik yang dikontrolnya.  Katakan saja berapa banyak memori dan kekuatan pemrosesan yang Anda butuhkan - dan Anda akan mendapatkan segalanya.  Infrastruktur?  Tidak, tidak terdengar. </p><br><p>  Mengelola gambar Docker, Kubernetes, dan aplikasi membuatnya portabel.  Setelah mengembangkan aplikasi kontainer dengan Kubernetes, Anda dapat menyebarkannya di mana saja: ke cloud terbuka, secara lokal atau ke lingkungan hybrid - tanpa mengubah kode. </p><br><p>  Kami menyukai Kubernet untuk skalabilitas, portabilitas, dan pengelolaan, tetapi tidak menyimpan keadaan.  Tetapi kami memiliki hampir semua aplikasi stateful, yaitu, mereka membutuhkan penyimpanan eksternal. </p><a name="habracut"></a><br><p>  Kubernetes memiliki arsitektur yang sangat dinamis.  Wadah dibuat dan dihancurkan tergantung pada beban dan instruksi dari pengembang.  Polong dan wadah adalah penyembuhan dan replikasi diri.  Mereka pada dasarnya fana. </p><br><p>  <strong>Penyimpanan eksternal terlalu sulit untuk variabilitas seperti itu.</strong>  <strong>Itu tidak mematuhi aturan penciptaan dan penghancuran yang dinamis.</strong> </p><br><p> Hanya perlu menggunakan aplikasi stateful di infrastruktur lain: di cloud lain di sana, secara lokal atau dalam model hybrid - bagaimana ia memiliki masalah portabilitas.  Penyimpanan eksternal dapat diikat ke cloud tertentu. </p><br><p>  Tetapi hanya di penyimpanan ini untuk aplikasi cloud iblis sendiri akan mematahkan kakinya.  Dan pahami makna fiktif dan makna <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terminologi penyimpanan di Kubernetes</a></strong> .  Dan ada repositori Kubernet sendiri, platform open source, layanan terkelola atau berbayar ... </p><br><p>  Berikut adalah beberapa contoh <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyimpanan cloud CNCF</a></strong> : </p><br><p><img src="https://habrastorage.org/webt/cm/wl/ov/cmwlovlr6qt3qcicg0sm5acufvw.png"></p><br><p>  Tampaknya menyebarkan database di Kubernetes - Anda hanya perlu memilih solusi yang sesuai, kemas dalam wadah untuk bekerja pada disk lokal dan menyebarkannya ke cluster sebagai beban kerja berikutnya.  Tetapi database memiliki kekhasan tersendiri, jadi berpikir bukanlah es. </p><br><p>  Kontainer - mereka begitu berbatu sehingga mereka tidak mempertahankan negara mereka.  Itu sebabnya mereka sangat mudah untuk memulai dan berhenti.  Dan karena tidak ada apa pun untuk disimpan dan ditransfer, cluster tidak repot dengan operasi baca dan salin. </p><br><p>  Anda harus menyimpan status dengan database.  Jika database yang digunakan untuk cluster dalam wadah tidak bermigrasi di mana pun dan tidak memulai terlalu sering, fisika penyimpanan data ikut berperan.  Idealnya, kontainer yang menggunakan data harus dalam perapian yang sama dengan database. </p><br><p>  Dalam beberapa kasus, basis data, tentu saja, dapat digunakan untuk suatu wadah.  Dalam lingkungan pengujian atau dalam tugas-tugas di mana ada sedikit data, basis data nyaman hidup dalam kelompok. </p><br><p>  <strong>Produksi biasanya memerlukan penyimpanan eksternal.</strong> </p><br><p>  Kubernet berkomunikasi dengan repositori melalui antarmuka bidang kontrol.  Mereka menautkan Kubernetes ke penyimpanan eksternal.  Penyimpanan eksternal yang melekat pada Kubernet disebut plugins volume.  Dengan mereka, Anda dapat menyimpan dan memindahkan penyimpanan secara abstrak. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Plugin volume yang digunakan untuk dibuat</a></strong> , ditautkan, dikompilasi, dan dikirim menggunakan basis kode Kubernetes.  Pengembang ini sangat terbatas dan memerlukan pemeliharaan tambahan: jika Anda ingin menambah repositori baru, silakan ubah basis kode Kubernetes. </p><br><p>  Sekarang gunakan plugin volume ke kluster - Saya tidak mau.  Dan Anda tidak perlu menggali basis kode.  Terima kasih kepada CSI dan Flexvolume. </p><br><p><img src="https://habrastorage.org/webt/ug/r7/m4/ugr7m4uco1skczyasqf7xf3op3y.png"></p><br><h3 id="sobstvennoe-hranilische-kubernetes">  Penyimpanan Asli Kubernetes </h3><br><p>  Bagaimana Kubernet mengatasi masalah penyimpanan?  Ada beberapa solusi: opsi singkat, penyimpanan persisten dalam volume persisten, kueri Klaim Volume Persisten, kelas penyimpanan, atau StatefulSets.  Cari tahu, secara umum. </p><br><p>  Persistent Volume (PV) adalah unit penyimpanan yang disiapkan oleh administrator.  Mereka tidak bergantung pada perapian dan kehidupan singkat mereka. </p><br><p>  Klaim Volume Persisten (PVC) adalah permintaan penyimpanan, mis. PV.  Dengan PVC, Anda dapat mengikat penyimpanan ke sebuah simpul, dan simpul ini akan menggunakannya. </p><br><p>  Anda dapat bekerja dengan penyimpanan secara statis atau dinamis. </p><br><p>  Dengan pendekatan statis, administrator menyiapkan PV yang seharusnya dilayani terlebih dahulu, sebelum permintaan, dan PV ini secara manual terikat ke pod tertentu menggunakan PVC eksplisit. </p><br><p>  Dalam praktiknya, PV yang didefinisikan secara khusus tidak kompatibel dengan struktur portabel Kubernetes - penyimpanan tergantung pada lingkungan, seperti AWS EBS atau drive permanen GCE.  Untuk mengikat secara manual, Anda perlu menunjuk ke repositori tertentu di file YAML. </p><br><p>  Pendekatan statis umumnya bertentangan dengan filosofi Kubernetes: CPU dan memori tidak dialokasikan sebelumnya dan tidak terikat pada polong atau wadah.  Mereka dikeluarkan secara dinamis. </p><br><p>  Untuk penyediaan dinamis, kami menggunakan kelas penyimpanan.  Administrator cluster tidak perlu membuat PV terlebih dahulu.  Ini menciptakan beberapa profil penyimpanan, seperti templat.  Ketika pengembang membuat permintaan PVC, pada saat permintaan tersebut, salah satu pola ini dibuat dan dilampirkan ke perapian. </p><br><p><img src="https://habrastorage.org/webt/id/9q/mj/id9qmjxqf7tqnki0xc_1a710seg.png"></p><br><p>  Jadi, dalam istilah yang paling umum, Kubernetes bekerja dengan penyimpanan eksternal.  Ada banyak pilihan lain. </p><br><h3 id="csi--container-storage-interface">  CSI - Antarmuka Penyimpanan Kontainer </h3><br><p>  Ada hal seperti itu - <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Antarmuka Penyimpanan Kontainer</a></strong> .  CSI dibuat oleh kelompok kerja kubah CNCF, yang memutuskan untuk mendefinisikan antarmuka penyimpanan kontainer standar sehingga driver vault bekerja dengan orkestra apa pun. </p><br><p>  Spesifikasi CSI sudah disesuaikan untuk Kubernetes, dan ada <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">banyak plugin driver</a></strong> untuk penerapan di cluster Kubernetes.  Anda harus mengakses repositori melalui driver volume yang sesuai dengan CSI - gunakan <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tipe</a></strong> volume <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">csi</a></strong> di Kubernetes. </p><br><p>  Dengan CSI, penyimpanan dapat dianggap sebagai beban kerja lain untuk kontainerisasi dan penyebaran ke kluster Kubernetes. </p><br><p>  Untuk lebih jelasnya, dengarkan <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jie Yu berbicara tentang CSI di podcast kami</a></strong> . </p><br><h3 id="opensors-proekty">  Proyek sumber terbuka </h3><br><p>  Alat dan proyek untuk teknologi cloud dengan cepat berlipat ganda, dan bagian yang adil dari proyek sumber terbuka - yang logis - menyelesaikan salah satu masalah produksi utama: bekerja dengan penyimpanan dalam arsitektur cloud. </p><br><p>  Yang paling populer di antara mereka adalah Ceph dan Rook. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ceph</a></strong> adalah kluster penyimpanan terdistribusi yang dikelola secara dinamis dengan penskalaan horizontal.  Ceph menyediakan abstraksi logis untuk sumber daya penyimpanan.  Ia tidak memiliki satu titik kegagalan, ia mengelola dirinya sendiri dan bekerja berdasarkan perangkat lunak.  Ceph menyediakan antarmuka untuk menyimpan blok, objek, dan file secara bersamaan untuk satu cluster penyimpanan. </p><br><p>  Ceph memiliki arsitektur yang sangat kompleks dengan RADOS, pustakawan, RADOSGW, RDB, algoritma CRUSH dan berbagai komponen (monitor, OSD, MDS).  Mari kita tidak masuk jauh ke dalam arsitektur, cukup untuk memahami bahwa Ceph adalah cluster penyimpanan terdistribusi yang menyederhanakan skalabilitas, menghilangkan satu titik kegagalan tanpa mengorbankan kinerja dan menyediakan penyimpanan tunggal dengan akses ke objek, blok, dan file. </p><br><p>  Secara alami, Ceph diadaptasi untuk cloud.  Anda bisa menggunakan cluster Ceph dengan cara yang berbeda, misalnya, menggunakan Ansible atau ke cluster Kubernetes melalui CSI dan PVC. </p><br><p><img src="https://habrastorage.org/webt/g9/kn/ft/g9knft3jj1y3hw8u2v-4jzoa26k.png"><br>  <em>Arsitektur Ceph</em> </p><br><p>  Rook adalah proyek lain yang menarik dan populer.  Ini menggabungkan Kubernetes dengan komputasi dan Ceph dengan repositori menjadi satu cluster. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rook</a></strong> adalah orkestrator penyimpanan cloud yang melengkapi Kubernetes.  Mereka mengemas Ceph ke dalam wadah dengannya dan menggunakan logika manajemen kluster untuk operasi Ceph yang andal di Kubernetes.  Rook mengotomatiskan penyebaran, bootstrap, tuning, penskalaan, penyeimbangan ulang - secara umum, semua yang dilakukan admin cluster. </p><br><p>  Dengan Rook, cluster Ceph dapat digunakan dari yaml, seperti Kubernetes.  Dalam file ini, administrator menguraikan apa yang dia butuhkan di cluster.  Rook meluncurkan sebuah cluster dan mulai memantau secara aktif.  Ini adalah sesuatu seperti operator atau pengontrol - ini memastikan bahwa semua persyaratan dari yaml terpenuhi.  Rook berfungsi dengan siklus sinkronisasi - ia melihat keadaan dan mengambil tindakan jika ada penyimpangan. </p><br><p>  Dia tidak memiliki kondisi permanen dan tidak perlu dikendalikan.  Itu ada dalam semangat Kubernetes. </p><br><p><img src="https://habrastorage.org/webt/ep/qx/qk/epqxqk5iecbwcekk88ac8tjxih4.png"></p><br><p>  Rook, yang menggabungkan Ceph dan Kubernetes, adalah salah satu solusi penyimpanan cloud paling populer: 4.000 bintang di Github, 16,3 juta unduhan dan lebih dari seratus kontributor. <br>  Proyek Rook telah diterima di CNCF, <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dan baru-baru ini berakhir di inkubator</a></strong> . </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bassam Tabara</a></strong> akan memberi tahu Anda lebih banyak tentang Rook <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di episode repositori Kubernetes kami</a></strong> . <br>  Jika aplikasi memiliki masalah, Anda perlu mengetahui persyaratan dan membuat sistem atau mengambil alat yang diperlukan.  Ini juga berlaku untuk penyimpanan cloud.  Dan meskipun masalahnya bukan dari yang sederhana, alat dan pendekatan telah gagal.  Teknologi cloud terus berkembang, dan solusi baru pasti akan menunggu kita. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id441222/">https://habr.com/ru/post/id441222/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id441212/index.html">Bekerja dengan perlindungan informasi kriptografis dan operator kunci perangkat keras di Linux</a></li>
<li><a href="../id441214/index.html">Panduan Pengguna Kibana. Visualisasi. Bagian 1</a></li>
<li><a href="../id441216/index.html">Cermin hitam atau iklan Picooc?</a></li>
<li><a href="../id441218/index.html">OpenAI Gym + ROS + Gazebo: melatih robot mandiri di rumah. Bagian 1</a></li>
<li><a href="../id441220/index.html">Analisis serangan massal terbaru dengan penangkapan DNS</a></li>
<li><a href="../id441224/index.html">Buat contoh Augmented Faces ARCore di Unity</a></li>
<li><a href="../id441226/index.html">Forbes menerbitkan daftar perusahaan Internet Rusia paling mahal di tahun 2019</a></li>
<li><a href="../id441234/index.html">Efek penyaringan SVG. Bagian 6. Membuat tekstur dengan feTurbulence</a></li>
<li><a href="../id441236/index.html">Habraiting 2018: bahan terbaik untuk 2018</a></li>
<li><a href="../id441238/index.html">Memprogram Bahasa Inggris</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>