<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¥üèø üõ∑ üîΩ So rollen Sie Updates in der Produktion automatisch ‚è™ üç≥ üßöüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Starten der neuen Version im Kampfeinsatz ist immer ein nerv√∂ses Ereignis. Besonders wenn der Prozess viele manuelle Operationen beinhaltet. Der m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So rollen Sie Updates in der Produktion automatisch</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/436670/">  Das Starten der neuen Version im Kampfeinsatz ist immer ein nerv√∂ses Ereignis.  Besonders wenn der Prozess viele manuelle Operationen beinhaltet.  Der menschliche Faktor ist eine schreckliche Sache.  ‚ÄûEs w√§re sch√∂n, diesen Prozess zu automatisieren‚Äú - diese Idee ist so alt wie die gesamte IT-Welt.  Und daf√ºr gibt es einen Begriff - Continuous Deployment.  Ja, das Problem ist, dass es keine eindeutige M√∂glichkeit gibt, diese kontinuierliche Bereitstellung zu konfigurieren.  Dieser Prozess ist sehr stark an den technologischen Stapel des Projekts und seiner Umgebung gebunden. <br><br>  In diesem Artikel m√∂chte ich praktische Erfahrungen beim Einrichten automatischer Systemaktualisierungen teilen, ohne den Betrieb f√ºr eine bestimmte technologische Umgebung zu unterbrechen, n√§mlich: Die Webanwendung ASP.NET MVC + Azure SQL + Entity Framework im Code First-Modus hat die Anwendung in Azure als App Service bereitgestellt Die Montage und Bereitstellung erfolgt √ºber Azure DevOps (ehemals Visual Studio Team Services). <br><br><img src="https://habrastorage.org/webt/ji/6o/8j/ji6o8j6s6ignpfqyorvdmaxcotk.jpeg"><a name="habracut"></a><br><br>  Auf den ersten Blick ist alles sehr einfach. Azure App Service hat das Konzept eines Bereitstellungssteckplatzes. Laden Sie dort die neue Version herunter und aktivieren Sie sie.  Es w√§re jedoch einfach, wenn das Projekt auf einem nicht relationalen DBMS basieren w√ºrde, in dem es kein starres Datenschema gibt.  In diesem Fall ja - nur die neue Version nimmt Verkehr und Voila auf.  Bei einem relationalen DBMS ist jedoch alles etwas komplizierter. <br><br>  Die Hauptfaktoren, die uns daran hindern, eine kontinuierliche Bereitstellung f√ºr unseren Technologie-Stack zu implementieren, sind folgende: <br><br><ul><li>  Die alte Version der Anwendung kann nicht mit der neuen Datenbankstruktur arbeiten </li><li>  Das Aktualisieren der Datenbankstruktur kann viel Zeit in Anspruch nehmen und ist mit der Anwendung selbst √ºber den automatischen Migrationsmechanismus nicht immer m√∂glich. </li></ul><br>  Ich werde es erkl√§ren.  Angenommen, Sie haben eine neue Version in einem parallelen Steckplatz oder in einem Sicherungsdatenzentrum bereitgestellt und die Anwendung von Migrationen gestartet.  Nehmen wir an, wir haben drei Migrationen, und, entsetzt, zwei sind gerollt, und die dritte ist gefallen.  In diesem Moment passiert nichts mit den Arbeitsservern. Das Entity Framework √ºberpr√ºft die Version nicht f√ºr jede Anforderung, aber Sie k√∂nnen das Problem wahrscheinlich nicht schnell l√∂sen.  Zu diesem Zeitpunkt kann sich die Belastung der Anwendung erh√∂hen, und die Plattform startet eine zus√§tzliche Instanz der Anwendung f√ºr Sie, und sie wird nat√ºrlich nicht gestartet, da sich die Datenbankstruktur ge√§ndert hat.  Ein erheblicher Teil der Benutzer erh√§lt Fehler.  Daher ist das Risiko einer automatischen Anwendung von Migrationen gro√ü. <br><br><img src="https://habrastorage.org/webt/zv/kf/xv/zvkfxv1rthfzrgpmduxbjkv8ods.png"><br><br>  Was den zweiten Punkt betrifft, kann Ihre Migration eine Art von Befehlen enthalten, deren Ausf√ºhrungszeit 30 Sekunden √ºberschreitet und deren Standardprozedur mit dem Timeout abf√§llt.  Zus√§tzlich zu diesen Punkten gef√§llt mir pers√∂nlich nicht, dass Sie bei automatischen Migrationen gezwungen sind, einen Teil der Infrastruktur auf eine neue Version zu aktualisieren.  Und wenn dies f√ºr einen Modus mit Slots in Azure nicht so be√§ngstigend ist, erhalten Sie f√ºr einen Modus mit einem Backup-Rechenzentrum einen Teil der Infrastruktur mit einer bekannterma√üen nicht funktionsf√§higen Anwendung.  Es ist alles gef√§hrlich, es wird im ung√ºnstigsten Moment schie√üen. <br><br><h2>  Was tun? </h2><br>  Beginnen wir mit dem Schwierigsten - mit der Datenbank.  Es w√§re also sch√∂n, die Datenbankstruktur irgendwie automatisch zu aktualisieren, damit die alten Versionen der Anwendung weiterhin funktionieren.  Dar√ºber hinaus w√§re es sch√∂n zu ber√ºcksichtigen, dass es solche Aktualisierungen gibt, bei denen ein separater Befehl f√ºr eine betr√§chtliche Zeit ausgef√ºhrt werden kann. Dies bedeutet, dass wir die Datenbank nicht mithilfe der integrierten Mechanismen aktualisieren m√ºssen, sondern indem Sie ein separates SQL-Skript ausf√ºhren.  Frage: Wie bereite ich es vor?  Sie k√∂nnen dieses Prozesshandbuch erstellen.  Wenn Sie eine separate Release Manager-Rolle im Team haben, k√∂nnen Sie diese zwingen, den Befehl in Visual Studio auszuf√ºhren: <br><br><pre><code class="cpp hljs">update-database -script</code> </pre> <br>  Sie generiert ein Skript und diese Person legt dieses Skript in einem bestimmten Projektordner ab.  Aber Sie m√ºssen zugeben, dass dies immer noch unpraktisch ist, zum einen der menschliche Faktor und zum anderen unn√∂tige Schwierigkeiten, wenn zwischen den Releases mehr als eine Migration stattgefunden hat.  Oder aus irgendeinem Grund wurde eine Version auf dem Zielsystem √ºbersprungen.  Wir m√ºssen einen komplizierten Garten anlegen, in dem nachverfolgt wird, welche Migrationen bereits vorhanden sind und welche gestartet werden m√ºssen.  Es ist schwierig und vor allem ist dies das gleiche Fahrrad, das bereits im Migrationsmechanismus hergestellt wurde. <br><br>  Und es ist richtig, den Skriptgenerierungs- und -ausf√ºhrungsprozess in den Release-Berechnungsprozess einzubauen.  Um ein Migrationsskript zu generieren, k√∂nnen Sie das Dienstprogramm migrate.exe verwenden, das im Entity Framework enthalten ist.  Ich mache Sie darauf aufmerksam, dass Sie Entity Framework Version 6.2 oder h√∂her ben√∂tigen, da die Option zur Skriptgenerierung in diesem Dienstprogramm erst im April 2017 angezeigt wurde.  Der Dienstprogrammaufruf sieht folgenderma√üen aus: <br><br><pre> <code class="cpp hljs">migrate.exe Context.dll /connectionString=<span class="hljs-string"><span class="hljs-string">"Data Source=localhost;Initial Catalog=myDB;User Id=sa;Password=myPassword;"</span></span> /connectionProviderName=<span class="hljs-string"><span class="hljs-string">"System.Data.SqlClient"</span></span> /sc /startUpDirectory=<span class="hljs-string"><span class="hljs-string">"c:\projects\MyProject\bin\Release"</span></span> /verbose</code> </pre> <br>  Der Name der Assembly wird angegeben, in dem sich Ihr Kontext befindet, die Verbindungszeichenfolge zur Zieldatenbank, der Anbieter und vor allem das Startverzeichnis, das sowohl die Assembly mit dem Kontext als auch die Entity Framework-Assembly enth√§lt.  Experimentieren Sie nicht mit den Namen des Arbeitsverzeichnisses, seien Sie einfacher.  Wir sind auf die Tatsache gesto√üen, dass migrate.exe das Verzeichnis nicht lesen konnte, in dessen Namen Leerzeichen und Zeichen ohne Buchstaben vorhanden waren. <br><br>  Hier ist ein wichtiger Exkurs notwendig.  Tatsache ist, dass nach Ausf√ºhrung des obigen Befehls ein einzelnes SQL-Skript generiert wird, das alle Befehle f√ºr alle Migrationen enth√§lt, die auf die Zieldatenbank angewendet werden m√ºssen.  F√ºr Microsoft SQL Server ist dies nicht sehr gut.  Tatsache ist, dass der Server Befehle ohne das GO-Trennzeichen als einzelnes Paket ausf√ºhrt und einige Vorg√§nge nicht zusammen in einem einzelnen Paket ausgef√ºhrt werden k√∂nnen. <br><br>  In einigen F√§llen funktioniert es beispielsweise nicht, einer Tabelle ein Feld hinzuzuf√ºgen und sofort einen Index f√ºr diese Tabelle mit einem neuen Feld zu erstellen.  Dies reicht jedoch nicht aus. Einige Befehle erfordern bestimmte Umgebungseinstellungen, wenn das Skript ausgef√ºhrt wird.  Solche Einstellungen sind standardm√§√üig aktiviert, wenn Sie √ºber SQL Server Management Studio eine Verbindung zu SQL Server herstellen. Wenn das Skript jedoch √ºber das Konsolendienstprogramm SQLCMD ausgef√ºhrt wird, m√ºssen sie manuell festgelegt werden.  Um all dies zu ber√ºcksichtigen, m√ºssen Sie den Prozess zum Generieren des Migrationsskripts mit einer Datei √§ndern.  Erstellen Sie dazu neben dem Datumskontext eine zus√§tzliche Klasse, die alles tut, was Sie brauchen: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MigrationScriptBuilder</span></span></span><span class="hljs-class"> :</span></span> SqlServerMigrationSqlGenerator { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> override IEnumerable&lt;MigrationStatement&gt; Generate(IEnumerable&lt;MigrationOperation&gt; migrationOperations, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> providerManifestToken) { var statements = base.Generate(migrationOperations, providerManifestToken); var result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;MigrationStatement&gt;(); result.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MigrationStatement { Sql = <span class="hljs-string"><span class="hljs-string">"SET QUOTED_IDENTIFIER ON;"</span></span> }); foreach (var item in statements) { item.BatchTerminator = <span class="hljs-string"><span class="hljs-string">"GO"</span></span>; result.Add(item); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } }</code> </pre><br>  Damit das Entity Framework es verwenden kann, registrieren Sie es in der Konfigurationsklasse, die sich normalerweise im Ordner "Migrationen" befindet: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configuration</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ SetSqlGenerator(<span class="hljs-string"><span class="hljs-string">"System.Data.SqlClient"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MigrationScriptBuilder()); ‚Ä¶. }</code> </pre><br>  Danach enth√§lt das resultierende Migrationsskript zwischen den einzelnen Anweisungen GO und am Anfang der Datei SET QUOTED_IDENTIFIER ON. <br><br>  Hurra, die Vorbereitung ist abgeschlossen, es bleibt die Konfiguration des Prozesses selbst.  Im Allgemeinen ist dies im Rahmen des Freigabeprozesses in Azure DevOps (VSTS / TFS) bereits recht einfach.  Wir m√ºssen ein PowerShell-Skript wie folgt erstellen: <br><br><pre> <code class="cpp hljs">param ( [<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>] [Parameter(Mandatory=$<span class="hljs-literal"><span class="hljs-literal">true</span></span>)] $dbserver, [<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>] [Parameter(Mandatory=$<span class="hljs-literal"><span class="hljs-literal">true</span></span>)] $dbname, [<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>] [Parameter(Mandatory=$<span class="hljs-literal"><span class="hljs-literal">true</span></span>)] $dbserverlogin, [<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>] [Parameter(Mandatory=$<span class="hljs-literal"><span class="hljs-literal">true</span></span>)] $dbserverpassword, [<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>] [Parameter(Mandatory=$<span class="hljs-literal"><span class="hljs-literal">true</span></span>)] $rootPath, [<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>] [Parameter(Mandatory=$<span class="hljs-literal"><span class="hljs-literal">true</span></span>)] $buildAliasName, [<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>] [Parameter(Mandatory=$<span class="hljs-literal"><span class="hljs-literal">true</span></span>)] $contextFilesLocation, ) Write-Host <span class="hljs-string"><span class="hljs-string">"Generating migration script..."</span></span> $fullpath=<span class="hljs-string"><span class="hljs-string">"$rootPath\$buildAliasName\$contextFilesLocation"</span></span> Write-Host $fullpath &amp; <span class="hljs-string"><span class="hljs-string">"$fullpath\migrate.exe"</span></span> Context.dll /connectionProviderName=<span class="hljs-string"><span class="hljs-string">"System.Data.SqlClient"</span></span> /connectionString=<span class="hljs-string"><span class="hljs-string">"Server=tcp:$dbserver.database.windows.net,1433;Initial Catalog=$dbname;Persist Security Info=False;User ID=$dbserverlogin;Password=$dbserverpassword;MultipleActiveResultSets=False;Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;"</span></span> /startUpDirectory=$fullpath /verbose /scriptFile=<span class="hljs-number"><span class="hljs-number">1.</span></span>SQL Write-Host <span class="hljs-string"><span class="hljs-string">"Running migration script..."</span></span> &amp; <span class="hljs-string"><span class="hljs-string">"SQLCMD"</span></span> -S <span class="hljs-string"><span class="hljs-string">"$dbserver.database.windows.net"</span></span> -U $dbserverlogin@$dbserver -P $dbserverpassword -d $dbname -i <span class="hljs-number"><span class="hljs-number">1.</span></span>SQL Write-Host <span class="hljs-string"><span class="hljs-string">"====Finished with migration script===="</span></span></code> </pre><br>  F√ºgen Sie die PowerShell-Skriptausf√ºhrungseinheit zum Release-Berechnungsprozess hinzu.  Der Block und seine Einstellungen k√∂nnen folgenderma√üen aussehen: <br><br><img src="https://habrastorage.org/webt/2u/j4/vg/2uj4vgqd6vsvkmwpbdx2afxinho.png"><br><br>  Das PowerShell-Setup sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><img src="https://habrastorage.org/webt/p4/lg/47/p4lg47g_ympywrtn6ewk-wmgp8g.png"><br><br>  Es ist wichtig, nicht zu vergessen, die Datei migrate.exe aus dem Ordner &lt;IhrProjekt&gt; /packages/EntityFramework.6.2.0/tools/ zum Projekt hinzuzuf√ºgen und die Eigenschaft Immer kopieren festzulegen, damit dieses Dienstprogramm beim Erstellen des Projekts in das Ausgabeverzeichnis kopiert wird und Sie darauf zugreifen k√∂nnen Azure DevOps-Version. <br><br>  <b>Die Nuance</b> .  Wenn Ihr Projekt bei der Bereitstellung f√ºr Azure App Service auch WebJob verwendet, ist das Hinzuf√ºgen von Migrate.exe zu Ihrem Projekt nicht sicher.  Wir sind mit der Tatsache konfrontiert, dass in dem Ordner, in dem Ihr WebJob ver√∂ffentlicht wird, die Azure-Plattform dumm die erste Exe-Datei startet, die auftaucht.  Und wenn Ihr WebJob sp√§ter alphabetisch kostet migrate.exe (und wir haben es getan), versucht es, migrate.exe anstelle Ihres Projekts auszuf√ºhren! <br><br>  Wir haben also gelernt, wie die Datenbankversion durch Generieren eines Skripts w√§hrend des Ver√∂ffentlichungsprozesses aktualisiert wird. Das Einfache ist: Deaktivieren Sie die √úberpr√ºfung der Migrationsversion, damit die alte Version unseres Codes weiterhin funktioniert, wenn beim Ausf√ºhren des Skripts Fehler auftreten.  Ich denke, es besteht kein Grund zu sagen, dass Ihre Migrationen zerst√∂rungsfrei sein sollten.  Das hei√üt,  √Ñnderungen an der Datenbankstruktur sollten die Leistung der vorherigen Version nicht beeintr√§chtigen, aber besser als die beiden vorherigen.  Um die √úberpr√ºfung zu deaktivieren, m√ºssen Sie Web.config nur den folgenden Block hinzuf√ºgen: <br><br><pre> <code class="cpp hljs"> &lt;entityFramework&gt; &lt;contexts&gt; &lt;context type=<span class="hljs-string"><span class="hljs-string">"&lt;full namespace for your DataContext class&gt;, MyAssembly"</span></span> disableDatabaseInitialization=<span class="hljs-string"><span class="hljs-string">"true"</span></span>/&gt; &lt;/contexts&gt; &lt;/entityFramework&gt;</code> </pre><br>  Wobei der <code>full namespace for your DataContext class</code> der vollst√§ndige Namespace f√ºr Ihren Nachkommen von DbContext ist und MyAssembly der Name der Assembly ist, in der sich Ihr Kontext befindet. <br><br>  Und schlie√ülich ist es f√ºr uns √§u√üerst w√ºnschenswert, sicherzustellen, dass sich die Anwendung erw√§rmt, bevor Benutzer auf die neue Version umgestellt werden.  F√ºgen Sie dazu web.config einen speziellen Block mit Links hinzu, die Ihre Anwendung w√§hrend des Initialisierungsprozesses automatisch beendet: <br><br><pre> <code class="cpp hljs"> &lt;system.webServer&gt; &lt;applicationInitialization doAppInitAfterRestart=<span class="hljs-string"><span class="hljs-string">"true"</span></span>&gt; &lt;add initializationPage=<span class="hljs-string"><span class="hljs-string">"/"</span></span> hostName=<span class="hljs-string"><span class="hljs-string">""</span></span> /&gt; &lt;/applicationInitialization&gt; &lt;/system.webServer&gt;</code> </pre><br>  Sie k√∂nnen mehrere Links hinzuf√ºgen, indem Sie einfach <code>/&gt;</code> hinzuf√ºgen <code>/&gt;</code> Es wird argumentiert, dass die Plattform in Azure beim Wechseln der Slots auf die Initialisierung der Anwendung wartet und erst dann den Datenverkehr auf die neue Version umschaltet. <br><br><h2>  Aber was ist mit einem Projekt auf .NET Core? </h2><br>  Alles ist viel einfacher und gleichzeitig anders.  Ein Migrationsskript kann mit regul√§ren Tools erstellt werden, basiert jedoch nicht auf der fertigen Assembly, sondern auf der Projektdatei.  Daher sollte das Skript als Teil des Projektassemblierungsprozesses erstellt und als Assemblierungsartefakt enthalten sein.  In diesem Fall enth√§lt das Skript alle Befehle aller Migrationen ab Beginn der Zeit.  Hierbei gibt es keine Probleme, da das Skript idempotent ist, d.h.  Es kann wiederholt ohne Konsequenzen auf die Zielbasis angewendet werden.  Dies hat eine weitere n√ºtzliche Konsequenz: Wir m√ºssen den Skriptgenerierungsprozess nicht √§ndern, um die Befehle in Pakete zu unterteilen. Daf√ºr wurde bereits alles getan. <br><br>  Nun, speziell sehen die Schritte des Prozesses so aus.  F√ºgen Sie im Erstellungsprozess die Aufgabe hinzu: <br><br><img src="https://habrastorage.org/webt/uy/rx/xj/uyrxxj48kzjdv85qlcugbuhnhge.png"><br><br>  Wir konfigurieren es so, dass eine Datei mit Migrationen generiert wird: <br><br><img src="https://habrastorage.org/webt/hr/mu/om/hrmuom6-wjvv4xak07ewe2_bsxw.png"><br><br>  Vergessen Sie nicht, dem PowerShell-Projekt ein Skript hinzuzuf√ºgen, das die Migration (oben beschrieben) und die Migrationsdatei selbst ausf√ºhrt.  Nach dem Erstellen des Projekts sehen die Artefakte m√∂glicherweise ungef√§hr so ‚Äã‚Äãaus (zus√§tzlich zum eigentlichen Archiv mit der Assembly gibt es ein zus√§tzliches PS-Skript und ein SQL-Skript mit Migrationen): <br><br><img src="https://habrastorage.org/webt/hj/m9/j4/hjm9j4emze4vu_ceybuwjkyrafe.png"><br><br>  Es bleibt nur im entsprechenden Release-Schritt, die Ausf√ºhrung dieses PowerShell-Skripts auf die oben beschriebene Weise zu konfigurieren. <br><br><h2>  √úber den Autor </h2><br><img src="https://habrastorage.org/webt/ok/i5/ug/oki5uge-jvjl3pkerhoipjvjvyc.jpeg" align="left" width="120">  Pavel Kutakov ist Experte f√ºr Cloud-Technologien, Entwickler und Architekt von Softwaresystemen in verschiedenen Gesch√§ftsbereichen - vom weltweiten Bank-IP von den USA √ºber Papua-Neuguinea bis hin zu einer Cloud-L√∂sung f√ºr den nationalen Lotteriebetreiber. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436670/">https://habr.com/ru/post/de436670/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436658/index.html">Die Zukunft des Einzelhandels: Wichtige digitale Trends basierend auf der Big Show 2019 von NRF Retail</a></li>
<li><a href="../de436660/index.html">Die VS Code Roadmap 2019 - ENTWURF</a></li>
<li><a href="../de436662/index.html">1. Februar 2019 Ihre Website funktioniert m√∂glicherweise nicht mehr</a></li>
<li><a href="../de436664/index.html">Einf√ºhrung in die .NET Community Standup-Serie</a></li>
<li><a href="../de436668/index.html">K√∂nnen Statistiken mit einer kleinen Datenmenge gelesen werden?</a></li>
<li><a href="../de436674/index.html">Reverse Engineering Fantastic Dizzy</a></li>
<li><a href="../de436676/index.html">Wie man das ganze Land DDoS</a></li>
<li><a href="../de436682/index.html">Erstellen Sie kein eigenes JL (DSL), um die Funktionalit√§t der Anwendung zu erweitern</a></li>
<li><a href="../de436684/index.html">Jubil√§um Android 10 (Q). Was ist jetzt bekannt?</a></li>
<li><a href="../de436686/index.html">JPEG aus der 3D-Welt. Was ist glTF?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>