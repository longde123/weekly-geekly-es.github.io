<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëò üë©üèæ‚Äçü§ù‚Äçüë®üèª üì¥ System.IO.Pipelines: Hochleistungs-E / A in .NET üàÅ ‚ùî ‚ô†Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="System.IO.Pipelines ist eine neue Bibliothek, die die Organisation von Code in .NET vereinfacht. Es ist schwierig, eine hohe Leistung und Genauigkeit ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>System.IO.Pipelines: Hochleistungs-E / A in .NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/423105/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">System.IO.Pipelines</a> ist eine neue Bibliothek, die die Organisation von Code in .NET vereinfacht.  Es ist schwierig, eine hohe Leistung und Genauigkeit sicherzustellen, wenn Sie mit komplexem Code arbeiten m√ºssen.  Die Aufgabe von System.IO.Pipelines besteht darin, den Code zu vereinfachen.  Weitere Details unter dem Schnitt! <br><br><img src="https://habrastorage.org/webt/nq/me/p-/nqmep-tqvyyv5nlkpcxjnmlw8z4.jpeg"><a name="habracut"></a><br><br>  Die Bibliothek entstand aus den Bem√ºhungen des .NET Core-Entwicklungsteams, Kestrel zu einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der schnellsten Webserver der Branche zu machen</a> .  Es wurde urspr√ºnglich als Teil der Kestrel-Implementierung konzipiert, hat sich jedoch zu einer wiederverwendbaren API entwickelt, die in Version 2.1 als erstklassige BCL-API (System.IO.Pipelines) verf√ºgbar ist. <br><br><h2>  Welche Probleme l√∂st sie? </h2><br>  Um Daten aus einem Stream oder Socket richtig zu analysieren, m√ºssen Sie eine gro√üe Menge Standardcode schreiben.  Gleichzeitig gibt es viele Fallstricke, die den Code selbst und seine Unterst√ºtzung erschweren. <br><br><h2>  Welche Schwierigkeiten treten heute auf? </h2><br>  Beginnen wir mit einer einfachen Aufgabe.  Wir m√ºssen einen TCP-Server schreiben, der zeilengetrennte Nachrichten (\ n) vom Client empf√§ngt. <br><br><h2>  TCP-Server mit NetworkStream </h2><br>  ABWEICHUNG: Wie bei jeder Aufgabe, die eine hohe Leistung erfordert, sollte jeder spezifische Fall anhand der Funktionen Ihrer Anwendung ber√ºcksichtigt werden.  Es ist m√∂glicherweise nicht sinnvoll, Ressourcen f√ºr die Verwendung verschiedener Ans√§tze aufzuwenden, die sp√§ter erl√§utert werden, wenn der Umfang der Netzwerkanwendung nicht sehr gro√ü ist. <br><br>  Normaler .NET-Code vor der Verwendung von Pipelines sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessLinesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NetworkStream stream</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> stream.ReadAsync(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, buffer.Length); <span class="hljs-comment"><span class="hljs-comment">// Process a single line from the buffer ProcessLine(buffer); }</span></span></code> </pre> <br>  siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sample1.cs</a> auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github</a> <br><br>  Dieser Code funktioniert wahrscheinlich mit lokalen Tests, weist jedoch eine Reihe von Fehlern auf: <br><br><ul><li>  M√∂glicherweise wird nach einem einzelnen Aufruf von ReadAsync nicht die gesamte Nachricht empfangen (bis zum Ende der Zeile). </li><li>  Das Ergebnis der Methode stream.ReadAsync () wird ignoriert - die tats√§chlich in den Puffer √ºbertragene Datenmenge. </li><li>  Der Code behandelt nicht den Empfang mehrerer Zeilen in einem einzelnen ReadAsync-Aufruf. </li></ul><br>  Dies sind die h√§ufigsten Fehler beim Lesen von Streaming-Daten.  Um sie zu vermeiden, m√ºssen Sie eine Reihe von √Ñnderungen vornehmen: <br><br><ul><li>  Sie m√ºssen die eingehenden Daten puffern, bis eine neue Zeile gefunden wird. </li><li>  Es ist notwendig, alle an den Puffer zur√ºckgegebenen Zeilen zu analysieren. </li></ul><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessLinesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NetworkStream stream</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesBuffered = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesConsumed = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesRead = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> stream.ReadAsync(buffer, bytesBuffered, buffer.Length - bytesBuffered); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bytesRead == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// EOF break; } // Keep track of the amount of buffered bytes bytesBuffered += bytesRead; var linePosition = -1; do { // Look for a EOL in the buffered data linePosition = Array.IndexOf(buffer, (byte)'\n', bytesConsumed, bytesBuffered - bytesConsumed); if (linePosition &gt;= 0) { // Calculate the length of the line based on the offset var lineLength = linePosition - bytesConsumed; // Process the line ProcessLine(buffer, bytesConsumed, lineLength); // Move the bytesConsumed to skip past the line we consumed (including \n) bytesConsumed += lineLength + 1; } } while (linePosition &gt;= 0); } }</span></span></code> </pre> <br>  siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sample2.cs</a> auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github</a> <br><br>  Ich wiederhole: Dies k√∂nnte mit lokalen Tests funktionieren, aber manchmal gibt es Zeichenfolgen, die l√§nger als 1 KB (1024 Byte) sind.  Der Eingabepuffer muss vergr√∂√üert werden, bis eine neue Zeile gefunden wird. <br><br>  Au√üerdem sammeln wir Puffer in einem Array, wenn wir lange Zeichenfolgen verarbeiten.  Wir k√∂nnen diesen Prozess mit ArrayPool verbessern, wodurch eine Neuzuweisung von Puffern w√§hrend der Analyse langer Zeilen vom Client vermieden wird. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessLinesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NetworkStream stream</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] buffer = ArrayPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;.Shared.Rent(<span class="hljs-number"><span class="hljs-number">1024</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesBuffered = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesConsumed = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Calculate the amount of bytes remaining in the buffer var bytesRemaining = buffer.Length - bytesBuffered; if (bytesRemaining == 0) { // Double the buffer size and copy the previously buffered data into the new buffer var newBuffer = ArrayPool&lt;byte&gt;.Shared.Rent(buffer.Length * 2); Buffer.BlockCopy(buffer, 0, newBuffer, 0, buffer.Length); // Return the old buffer to the pool ArrayPool&lt;byte&gt;.Shared.Return(buffer); buffer = newBuffer; bytesRemaining = buffer.Length - bytesBuffered; } var bytesRead = await stream.ReadAsync(buffer, bytesBuffered, bytesRemaining); if (bytesRead == 0) { // EOF break; } // Keep track of the amount of buffered bytes bytesBuffered += bytesRead; do { // Look for a EOL in the buffered data linePosition = Array.IndexOf(buffer, (byte)'\n', bytesConsumed, bytesBuffered - bytesConsumed); if (linePosition &gt;= 0) { // Calculate the length of the line based on the offset var lineLength = linePosition - bytesConsumed; // Process the line ProcessLine(buffer, bytesConsumed, lineLength); // Move the bytesConsumed to skip past the line we consumed (including \n) bytesConsumed += lineLength + 1; } } while (linePosition &gt;= 0); } }</span></span></code> </pre> <br>  <i>siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sample3.cs</a> auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github</a></i> <br><br>  Der Code funktioniert, aber jetzt hat sich die Puffergr√∂√üe ge√§ndert. Infolgedessen werden viele Kopien davon angezeigt.  Es wird auch mehr Speicher verwendet, da die Logik den Puffer nach der Verarbeitung der Zeilen nicht reduziert.  Um dies zu vermeiden, k√∂nnen Sie die Liste der Puffer speichern, anstatt die Gr√∂√üe des Puffers jedes Mal zu √§ndern, wenn eine Zeichenfolge l√§nger als 1 KB ankommt. <br><br>  Au√üerdem erh√∂hen wir die Puffergr√∂√üe von 1 KB erst, wenn sie vollst√§ndig leer ist.  Dies bedeutet, dass wir immer kleinere Puffer an ReadAsync √ºbertragen. Dadurch steigt die Anzahl der Aufrufe an das Betriebssystem. <br><br>  Wir werden versuchen, dies zu beseitigen und einen neuen Puffer zuweisen, sobald die Gr√∂√üe des vorhandenen Puffers weniger als 512 Byte betr√§gt: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BufferSegment</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] Buffer { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Remaining =&gt; Buffer.Length - Count; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessLinesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NetworkStream stream</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minimumBufferSize = <span class="hljs-number"><span class="hljs-number">512</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> segments = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;BufferSegment&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesConsumed = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesConsumedBufferIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> segment = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferSegment { Buffer = ArrayPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;.Shared.Rent(<span class="hljs-number"><span class="hljs-number">1024</span></span>) }; segments.Add(segment); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Calculate the amount of bytes remaining in the buffer if (segment.Remaining &lt; minimumBufferSize) { // Allocate a new segment segment = new BufferSegment { Buffer = ArrayPool&lt;byte&gt;.Shared.Rent(1024) }; segments.Add(segment); } var bytesRead = await stream.ReadAsync(segment.Buffer, segment.Count, segment.Remaining); if (bytesRead == 0) { break; } // Keep track of the amount of buffered bytes segment.Count += bytesRead; while (true) { // Look for a EOL in the list of segments var (segmentIndex, segmentOffset) = IndexOf(segments, (byte)'\n', bytesConsumedBufferIndex, bytesConsumed); if (segmentIndex &gt;= 0) { // Process the line ProcessLine(segments, segmentIndex, segmentOffset); bytesConsumedBufferIndex = segmentOffset; bytesConsumed = segmentOffset + 1; } else { break; } } // Drop fully consumed segments from the list so we don't look at them again for (var i = bytesConsumedBufferIndex; i &gt;= 0; --i) { var consumedSegment = segments[i]; // Return all segments unless this is the current segment if (consumedSegment != segment) { ArrayPool&lt;byte&gt;.Shared.Return(consumedSegment.Buffer); segments.RemoveAt(i); } } } } (int segmentIndex, int segmentOffest) IndexOf(List&lt;BufferSegment&gt; segments, byte value, int startBufferIndex, int startSegmentOffset) { var first = true; for (var i = startBufferIndex; i &lt; segments.Count; ++i) { var segment = segments[i]; // Start from the correct offset var offset = first ? startSegmentOffset : 0; var index = Array.IndexOf(segment.Buffer, value, offset, segment.Count - offset); if (index &gt;= 0) { // Return the buffer index and the index within that segment where EOL was found return (i, index); } first = false; } return (-1, -1); }</span></span></code> </pre> <br>  <i>siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sample4.cs</a> auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github</a></i> <br><br>  Infolgedessen ist der Code erheblich kompliziert.  W√§hrend der Suche nach dem Trennzeichen verfolgen wir die gef√ºllten Puffer.  Verwenden Sie dazu eine Liste, in der gepufferte Daten angezeigt werden, wenn Sie nach einem neuen Zeilentrennzeichen suchen.  Infolgedessen akzeptieren ProcessLine und IndexOf List anstelle von Byte [], Offset und Count.  Die Parsing-Logik beginnt mit der Verarbeitung eines oder mehrerer Segmente des Puffers. <br><br>  Und jetzt verarbeitet der Server Teilnachrichten und verwendet gemeinsam genutzten Speicher, um den Gesamtspeicherverbrauch zu reduzieren.  Es m√ºssen jedoch einige √Ñnderungen vorgenommen werden: <br><br><ol><li>  Von ArrayPoolbyte verwenden wir nur Byte [] - standardm√§√üig verwaltete Arrays.  Mit anderen Worten, wenn die ReadAsync- oder WriteAsync-Funktionen ausgef√ºhrt werden, ist die G√ºltigkeitsdauer der Puffer an den Zeitpunkt der asynchronen Operation gebunden (um mit den E / A-APIs des Betriebssystems zu interagieren).  Da der angeheftete Speicher nicht verschoben werden kann, wirkt sich dies auf die Leistung des Garbage Collector aus und kann zu einer Fragmentierung des Arrays f√ºhren.  M√∂glicherweise m√ºssen Sie die Implementierung des Pools √§ndern, je nachdem, wie lange asynchrone Vorg√§nge auf die Ausf√ºhrung warten. </li><li>  Der Durchsatz kann verbessert werden, indem die Verbindung zwischen Lese- und Prozesslogik unterbrochen wird.  Wir erhalten den Effekt der Stapelverarbeitung, und jetzt kann die Analyselogik gro√üe Datenmengen lesen, gro√üe Pufferbl√∂cke verarbeiten, anstatt einzelne Zeilen zu analysieren.  Dadurch wird der Code noch komplizierter: <br><br><ul><li>  Sie m√ºssen zwei Zyklen erstellen, die unabh√§ngig voneinander arbeiten.  Der erste liest Daten aus dem Socket und der zweite analysiert die Puffer. </li><li>  Was ben√∂tigt wird, ist eine M√∂glichkeit, der Parsing-Logik mitzuteilen, dass die Daten verf√ºgbar werden. </li><li>  Es muss auch ermittelt werden, was passiert, wenn die Schleife Daten zu schnell aus dem Socket liest.  Wir brauchen eine M√∂glichkeit, den Lesezyklus anzupassen, wenn die Parsing-Logik nicht mith√§lt.  Dies wird √ºblicherweise als "Durchflussregelung" oder "Durchflusswiderstand" bezeichnet. </li><li>  Wir m√ºssen sicherstellen, dass die Daten sicher √ºbertragen werden.  Jetzt wird der Puffersatz sowohl vom Lesezyklus als auch vom Analysezyklus verwendet, da sie in verschiedenen Threads unabh√§ngig voneinander arbeiten. </li><li>  Die Speicherverwaltungslogik ist auch an zwei verschiedenen Codeteilen beteiligt: ‚Äã‚ÄãAusleihen von Daten aus dem Pufferpool, der Daten aus dem Socket liest, und Zur√ºckkehren aus dem Pufferpool, der die Parsing-Logik darstellt. </li><li>  Man muss √§u√üerst vorsichtig sein, wenn man nach dem Ausf√ºhren der Parsing-Logik Puffer zur√ºckgibt.  Andernfalls besteht die M√∂glichkeit, dass wir den Puffer zur√ºckgeben, in den die Socket-Leselogik noch geschrieben wird. </li></ul></li></ol><br>  Die Komplexit√§t beginnt durch das Dach zu gehen (und das ist bei weitem nicht alles!).  Um ein Hochleistungsnetzwerk zu erstellen, m√ºssen Sie sehr komplexen Code schreiben. <br><br>  Der Zweck von System.IO.Pipelines besteht darin, dieses Verfahren zu vereinfachen. <br><br><h4>  TCP-Server und System.IO.Pipelines </h4><br>  Mal sehen, wie System.IO.Pipelines funktioniert: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessLinesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Socket socket</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); Task writing = FillPipeAsync(socket, pipe.Writer); Task reading = ReadPipeAsync(pipe.Reader); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.WhenAll(reading, writing); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillPipeAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Socket socket, PipeWriter writer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minimumBufferSize = <span class="hljs-number"><span class="hljs-number">512</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Allocate at least 512 bytes from the PipeWriter Memory&lt;byte&gt; memory = writer.GetMemory(minimumBufferSize); try { int bytesRead = await socket.ReceiveAsync(memory, SocketFlags.None); if (bytesRead == 0) { break; } // Tell the PipeWriter how much was read from the Socket writer.Advance(bytesRead); } catch (Exception ex) { LogError(ex); break; } // Make the data available to the PipeReader FlushResult result = await writer.FlushAsync(); if (result.IsCompleted) { break; } } // Tell the PipeReader that there's no more data coming writer.Complete(); } async Task ReadPipeAsync(PipeReader reader) { while (true) { ReadResult result = await reader.ReadAsync(); ReadOnlySequence&lt;byte&gt; buffer = result.Buffer; SequencePosition? position = null; do { // Look for a EOL in the buffer position = buffer.PositionOf((byte)'\n'); if (position != null) { // Process the line ProcessLine(buffer.Slice(0, position.Value)); // Skip the line + the \n character (basically position) buffer = buffer.Slice(buffer.GetPosition(1, position.Value)); } } while (position != null); // Tell the PipeReader how much of the buffer we have consumed reader.AdvanceTo(buffer.Start, buffer.End); // Stop reading if there's no more data coming if (result.IsCompleted) { break; } } // Mark the PipeReader as complete reader.Complete(); }</span></span></code> </pre> <br>  <i>siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sample5.cs</a> auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github</a></i> <br><br>  Die Pipeline-Version unseres Zeilenlesers verf√ºgt √ºber zwei Schleifen: <br><br><ul><li>  FillPipeAsync liest aus dem Socket und schreibt in PipeWriter. </li><li>  ReadPipeAsync liest aus PipeReader und analysiert eingehende Zeilen. </li></ul><br>  Im Gegensatz zu den ersten Beispielen gibt es keine speziell zugewiesenen Puffer.  Dies ist eine der Hauptfunktionen von System.IO.Pipelines.  Alle Pufferverwaltungsaufgaben werden an die PipeReader / PipeWriter-Implementierungen √ºbertragen. <br><br>  Das Verfahren ist vereinfacht: Wir verwenden den Code nur f√ºr die Gesch√§ftslogik, anstatt eine komplexe Pufferverwaltung zu implementieren. <br><br>  In der ersten Schleife wird PipeWriter.GetMemory (int) zuerst aufgerufen, um eine bestimmte Speichermenge vom Hauptschreiber abzurufen.  Dann wird PipeWriter.Advance (int) aufgerufen, das PipeWriter mitteilt, wie viele Daten tats√§chlich in den Puffer geschrieben werden.  Darauf folgt ein Aufruf von PipeWriter.FlushAsync (), damit PipeReader auf die Daten zugreifen kann. <br><br>  Die zweite Schleife verbraucht die Puffer, die von PipeWriter geschrieben, aber urspr√ºnglich vom Socket empfangen wurden.  Wenn die Anforderung an PipeReader.ReadAsync () zur√ºckgegeben wird, erhalten wir ein ReadResult, das zwei wichtige Nachrichten enth√§lt: Daten, die in der Form ReadOnlySequence gelesen werden, sowie den logischen Datentyp IsCompleted, der dem Leser mitteilt, ob der Writer die Arbeit beendet hat (EOF).  Wenn der Zeilenabschluss (EOL) gefunden und die Zeichenfolge analysiert wurde, teilen wir den Puffer in Teile auf, um das bereits verarbeitete Fragment zu √ºberspringen.  Danach wird PipeReader.AdvanceTo aufgerufen und teilt PipeReader mit, wie viele Daten verbraucht wurden. <br><br>  Am Ende jedes Zyklus sind sowohl der Leser als auch der Schreiber fertig.  Infolgedessen gibt der Hauptkanal den gesamten zugewiesenen Speicher frei. <br><br><h2>  System.io.pipelines </h2><br><h4>  Teillesung </h4><br>  Neben der Speicherverwaltung erf√ºllt System.IO.Pipelines eine weitere wichtige Funktion: Es scannt die Daten im Kanal, verbraucht sie jedoch nicht. <br><br>  PipeReader verf√ºgt √ºber zwei Haupt-APIs: ReadAsync und AdvanceTo.  ReadAsync empf√§ngt Daten vom Kanal. AdvanceTo teilt PipeReader mit, dass diese Puffer vom Reader nicht mehr ben√∂tigt werden, sodass Sie sie entfernen k√∂nnen (z. B. sie an den Hauptpufferpool zur√ºckgeben). <br><br>  Das Folgende ist ein Beispiel eines HTTP-Analysators, der Daten aus Teilkanaldatenpuffern liest, bis er eine geeignete Startzeile empf√§ngt. <br><br><img src="https://habrastorage.org/webt/9c/lp/d8/9clpd8h1r6b1m1jrwultkuggw6i.png"><br><br><h2>  ReadOnlySequenceT </h2><br>  Die Kanalimplementierung speichert eine Liste verwandter Puffer, die zwischen PipeWriter und PipeReader √ºbergeben werden.  PipeReader.ReadAsync macht ReadOnlySequence verf√ºgbar, einen neuen BCL-Typ, der aus einem oder mehreren ReadOnlyMemory &lt;T&gt; -Segmenten besteht.  Es √§hnelt Span oder Memory, wodurch wir die M√∂glichkeit haben, Arrays und Strings zu betrachten. <br><br><img src="https://habrastorage.org/webt/79/y0/kw/79y0kwylohggq941soblji6qd2o.png"><br><br>  Innerhalb des Kanals gibt es Zeiger, die anzeigen, wo sich der Leser und der Schreiber im allgemeinen Satz hervorgehobener Daten befinden, und die sie auch beim Schreiben und Lesen von Daten aktualisieren.  SequencePosition ist ein einzelner Punkt in einer verkn√ºpften Liste von Puffern und wird verwendet, um ReadOnlySequence &lt;T&gt; effizient zu trennen. <br><br>  Da ReadOnlySequence &lt;T&gt; ein oder mehrere Segmente unterst√ºtzt, besteht die Standardoperation der Hochleistungslogik darin, schnelle und langsame Pfade basierend auf der Anzahl der Segmente zu trennen. <br><br>  Als Beispiel sehen Sie hier eine Funktion, die ASCII ReadOnlySequence in eine Zeichenfolge konvertiert: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAsciiString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReadOnlySequence&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; buffer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer.IsSingleSegment) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Encoding.ASCII.GetString(buffer.First.Span); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Create((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)buffer.Length, buffer, (span, sequence) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> segment <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sequence) { Encoding.ASCII.GetChars(segment.Span, span); span = span.Slice(segment.Length); } }); }</code> </pre> <br>  siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sample6.cs</a> auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github</a> <br><br><h4>  Durchflusswiderstand und Durchflussregelung </h4><br>  Im Idealfall arbeiten Lesen und Analyse zusammen: Der Lesestream verbraucht Daten aus dem Netzwerk und legt sie in Puffer, w√§hrend der Analysestream geeignete Datenstrukturen erstellt.  Die Analyse dauert normalerweise l√§nger als nur das Kopieren von Datenbl√∂cken aus dem Netzwerk.  Infolgedessen kann der Lesestream den Analysestream leicht √ºberlasten.  Daher wird der Lesestream gezwungen sein, entweder zu verlangsamen oder mehr Speicher zu verbrauchen, um Daten f√ºr den Analysestream zu speichern.  Um eine optimale Leistung zu gew√§hrleisten, ist ein Gleichgewicht zwischen der Pausenfrequenz und der Zuweisung einer gro√üen Speichermenge erforderlich. <br><br>  Um dieses Problem zu l√∂sen, verf√ºgt die Pipeline √ºber zwei Funktionen zur Datenflusssteuerung: PauseWriterThreshold und ResumeWriterThreshold.  PauseWriterThreshold bestimmt, wie viele Daten gepuffert werden m√ºssen, bevor PipeWriter.FlushAsync angehalten wird.  ResumeWriterThreshold bestimmt, wie viel Speicher der Leser verbrauchen kann, bevor der Rekorder den Betrieb wieder aufnimmt. <br><br><img src="https://habrastorage.org/webt/qf/yj/5u/qfyj5u6aahkadlp8nk1gtc9bqr4.png"><br><br>  PipeWriter.FlushAsync ‚Äûsperrt‚Äú, wenn die Datenmenge im Pipeline-Stream den in PauseWriterThreshold festgelegten Grenzwert √ºberschreitet, und ‚Äûentsperrt‚Äú, wenn der in ResumeWriterThreshold festgelegte Grenzwert unterschritten wird.  Um ein √úberschreiten der Verbrauchsgrenze zu verhindern, werden nur zwei Werte verwendet. <br><br><h4>  E / A-Planung </h4><br>  Bei Verwendung von async / await werden nachfolgende Vorg√§nge normalerweise entweder in den Pool-Threads oder im aktuellen SynchronizationContext aufgerufen. <br><br>  Bei der Ausf√ºhrung von E / A ist es sehr wichtig, sorgf√§ltig zu √ºberwachen, wo sie ausgef√ºhrt werden, um den Prozessor-Cache besser nutzen zu k√∂nnen.  Dies ist wichtig f√ºr Hochleistungsanwendungen wie Webserver.  System.IO.Pipelines verwendet den PipeScheduler, um zu bestimmen, wo asynchrone R√ºckrufe ausgef√ºhrt werden sollen.  Auf diese Weise k√∂nnen Sie sehr genau steuern, welche Streams f√ºr E / A verwendet werden sollen. <br><br>  Ein Beispiel f√ºr eine praktische Anwendung ist der Kestrel Libuv-Transport, bei dem E / A-R√ºckrufe auf dedizierten Kan√§len der Ereignisschleife ausgef√ºhrt werden. <br><br><h2>  Die PipeReader-Vorlage bietet weitere Vorteile. </h2><br><ul><li>  Einige Basissysteme unterst√ºtzen "Warten ohne Pufferung": Sie m√ºssen keinen Puffer zuweisen, bis verf√ºgbare Daten im Basissystem angezeigt werden.  Unter Linux mit epoll k√∂nnen Sie also keinen Lesepuffer bereitstellen, bis die Daten bereit sind.  Dies vermeidet die Situation, in der viele Threads auf Daten warten und Sie sofort eine gro√üe Menge an Speicher reservieren m√ºssen. </li><li>  Die Standard-Pipeline erleichtert das Schreiben von Komponententests f√ºr Netzwerkcode: Die Analyselogik ist vom Netzwerkcode getrennt, und Komponententests f√ºhren diese Logik nur in Puffern im Speicher aus, anstatt sie direkt aus dem Netzwerk zu verbrauchen.  Es macht es auch einfach, komplexe Muster durch Senden von Teildaten zu testen.  ASP.NET Core verwendet es, um verschiedene Aspekte der http-Parsing-Tools von Kestrel zu testen. </li><li>  Systeme, mit denen Benutzercode die Hauptpuffer des Betriebssystems verwenden kann (z. B. registrierte Windows-E / A-APIs), eignen sich zun√§chst f√ºr die Verwendung von Pipelines, da die PipeReader-Implementierung immer Puffer bereitstellt. </li></ul><br><h4>  Andere verwandte Typen </h4><br>  Wir haben System.IO.Pipelines auch eine Reihe neuer einfacher BCL-Typen hinzugef√ºgt: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MemoryPoolT</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IMemoryOwnerT</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MemoryManagerT</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ArrayPoolT</a> wurde in .NET Core 1.0 hinzugef√ºgt, und in .NET Core 2.1 gibt es jetzt eine allgemeinere abstrakte Darstellung f√ºr einen Pool, der mit jedem MemoryT funktioniert.  Wir erhalten einen Erweiterungspunkt, mit dem wir erweiterte Verteilungsstrategien sowie die Verwaltung von Steuerpuffern implementieren k√∂nnen (verwenden Sie beispielsweise vordefinierte Puffer anstelle von ausschlie√ülich verwalteten Arrays). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IBufferWriterT</a> ist ein Empf√§nger zum Aufzeichnen synchronisierter gepufferter Daten (implementiert von PipeWriter). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IValueTaskSource</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ValueTaskT gibt</a> es seit der Ver√∂ffentlichung von .NET Core 1.1, aber in .NET Core 2.1 wurden √§u√üerst effektive Tools erworben, die unterbrechungsfreie asynchrone Vorg√§nge ohne Verteilung erm√∂glichen.  Weitere Informationen finden Sie hier. </li></ul><br><h2>  Wie benutzt man F√∂rderer? </h2><br>  Die APIs befinden sich im Nuget-Paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">System.IO.Pipelines</a> . <br><br>  Ein Beispiel f√ºr eine .NET Server 2.1-Serveranwendung, die Pipelines zum Verarbeiten von Kleinbuchstaben verwendet (aus dem obigen Beispiel), finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Es kann mit dotnet run (oder Visual Studio) gestartet werden.  In diesem Beispiel wird erwartet, dass Daten vom Socket an Port 8087 √ºbertragen werden. Anschlie√üend werden empfangene Nachrichten in die Konsole geschrieben.  Sie k√∂nnen einen Client wie Netcat oder Putty verwenden, um eine Verbindung zu Port 8087 herzustellen.  Senden Sie eine Nachricht in Kleinbuchstaben und sehen Sie, wie es funktioniert. <br><br>  Derzeit l√§uft die Pipeline auf Kestrel und SignalR, und wir hoffen, dass sie in Zukunft in vielen Netzwerkbibliotheken und Komponenten der .NET-Community eine breitere Anwendung finden wird. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423105/">https://habr.com/ru/post/de423105/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423093/index.html">Wir erh√∂hen die Zuf√§lligkeit der Tatsache, dass [wahrscheinlich] [fast] zuf√§llig</a></li>
<li><a href="../de423095/index.html">Was ist neu bei Apple Presentation?</a></li>
<li><a href="../de423097/index.html">Aufgaben und L√∂sungen f√ºr PostgreSQL Fighter</a></li>
<li><a href="../de423101/index.html">Bereitstellen von LINSTOR Storage f√ºr Proxmox</a></li>
<li><a href="../de423103/index.html">Python-Podcasts: Das ist alles, was wir gefunden haben</a></li>
<li><a href="../de423107/index.html">Wir laden Sie zum Go in Production Meeting ein</a></li>
<li><a href="../de423109/index.html">Was Apple eingef√ºhrt hat und was iOS-Entwickler dar√ºber denken</a></li>
<li><a href="../de423115/index.html">Verbesserte Effekte mit dem Mischmodus f√ºr CSS-Hintergrundebenen</a></li>
<li><a href="../de423117/index.html">L√§nger leben oder langsamer √§lter werden: ein technologischer Ansatz f√ºr das Alter</a></li>
<li><a href="../de423119/index.html">DIY TTL Arcade-Maschine ... im Jahr 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>