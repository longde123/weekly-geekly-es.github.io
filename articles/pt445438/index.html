<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèæ‚Äçü§ù‚Äçüßëüèª üë®‚Äçüëß‚Äçüë¶ üïã Familiaridade com elementos iluminados e componentes da Web com base nele ü§≤ üèåÔ∏è ü§∑üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em um ponto, tive que me familiarizar com os componentes da Web com urg√™ncia e encontrar uma maneira de desenvolver convenientemente usando-os. Eu pre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Familiaridade com elementos iluminados e componentes da Web com base nele</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445438/"><p>  Em um ponto, tive que me familiarizar com os componentes da Web com urg√™ncia e encontrar uma maneira de desenvolver convenientemente usando-os.  Eu pretendo escrever uma s√©rie de artigos que <br>  de alguma forma, organizar o conhecimento de componentes da web, elemento iluminado e fornecer uma breve introdu√ß√£o a essa tecnologia para outros. <a name="habracut"></a>  N√£o sou especialista nesta tecnologia e aceitarei com prazer qualquer feedback. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">lit-element</a> √© um inv√≥lucro (modelo b√°sico) para componentes da web nativos.  Ele implementa muitos m√©todos convenientes que n√£o est√£o na especifica√ß√£o.  Devido √† sua proximidade com a implementa√ß√£o nativa, o lit-element mostra resultados muito bons em v√°rias <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">refer√™ncias em</a> rela√ß√£o a outras abordagens (a partir de 06/02/2019). </p><br><p>  B√¥nus que vejo ao usar o lit-element como uma classe base de componentes da web: </p><br><ol><li>  Essa tecnologia j√° implementa a segunda vers√£o e ‚Äúadoeceu com doen√ßas da inf√¢ncia‚Äù, peculiares aos instrumentos que acabaram de aparecer. </li><li>  A montagem pode ser realizada tanto em pol√≠mero quanto em webpack, texto datilografado, rollup etc., permitindo incorporar elementos iluminados em qualquer projeto moderno sem problemas. </li><li>  O elemento lit tem um sistema muito conveniente de trabalhar com propriedades em termos de digitar, iniciar e converter valores. </li><li>  o elemento lit implementa quase a mesma l√≥gica que a rea√ß√£o, ou seja,  fornece o m√≠nimo - um modelo √∫nico para a constru√ß√£o de componentes e sua renderiza√ß√£o e n√£o limita o desenvolvedor a escolher um ecossistema e bibliotecas adicionais. </li></ol><br><p>  Crie um componente da web simples no elemento iluminado.  Vamos voltar para a documenta√ß√£o.  Precisamos do seguinte: </p><br><ol><li>  Adicione pacote npm com elemento lit √† nossa montagem <br><br><pre><code class="plaintext hljs">npm install --save lit-element</code> </pre> </li><li>  Crie nosso componente. </li></ol><br><p>  Por exemplo, precisamos criar um componente da web inicializado na tag <code>my-component</code> .  Para fazer isso, crie o arquivo js <code>my-component.js</code> e defina seu modelo b√°sico: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//       lit-element import { } from ''; //      class MyComponent { } //      customElements.define();</span></span></code> </pre><br><p>  Primeiro, importamos nosso modelo b√°sico: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { LitElement, html } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// LitElement -    ()   - // html -  lit-html,     ,  //    html   </span></span></code> </pre><br><p>  Em segundo lugar, crie o pr√≥prio componente da Web usando <code>LitElement</code> </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,    //  LitElement    HTMLElement class MyComponent extends LitElement { //    LitElement   //      constructor  connectedCallback //           //    ,       // shadowDOM   {mode: 'open'} render() { return html`&lt;p&gt;Hello World!&lt;/p&gt;` } }</span></span></code> </pre><br><p>  E a √∫ltima coisa √© registrar o componente da web no navegador </p><br><pre> <code class="javascript hljs">customElements.define(<span class="hljs-string"><span class="hljs-string">'my-component'</span></span>, MyComponent);</code> </pre><br><p>  Como resultado, obtemos o seguinte: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { LitElement, html } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LitElement</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> html<span class="hljs-string"><span class="hljs-string">`&lt;p&gt;Hello World!&lt;/p&gt;`</span></span> } } customElements.define(<span class="hljs-string"><span class="hljs-string">'my-component'</span></span>, MyComponent);</code> </pre><br><p>  Se voc√™ excluir a necessidade de conectar o <code>my-component.js</code> ao html, √© isso.  O componente mais simples est√° pronto. </p><br><p>  Proponho n√£o reinventar a roda e fazer a montagem final do ac√∫mulo de elementos iluminados.  Siga as instru√ß√µes: </p><br><pre> <code class="plaintext hljs">git clone https://github.com/PolymerLabs/lit-element-build-rollup.git cd lit-element-build-rollup npm install npm run build npm run start</code> </pre><br><p>  Ap√≥s a conclus√£o de todos os comandos, vamos para a p√°gina no navegador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http: // localhost: 5000 /</a> . </p><br><p>  Se dermos uma olhada em html, veremos que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">webcomponents-loader.js</a> est√° na frente da tag de fechamento.  Este √© um conjunto de polyfills para componentes da web e, para opera√ß√£o entre navegadores do componente da web, √© desej√°vel que esse polyfill esteja presente.  Vamos dar uma olhada na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tabela de navegadores</a> que implementam todos os padr√µes para trabalhar com componentes da Web. Ele diz que o EDGE ainda n√£o implementa totalmente os padr√µes (estou em sil√™ncio sobre o IE11, que ainda precisa ser suportado). </p><br><img src="https://habrastorage.org/webt/q1/g2/6w/q1g26wcj65en1zl0z0d4d2ar67c.png"><br><p>  Foram implementadas 2 op√ß√µes para este polyfill: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">webcomponents-bundle.js</a> - esta vers√£o cont√©m todas as op√ß√µes poss√≠veis para o polyfill, todas iniciadas, mas cada polyfill funcionar√° apenas com base nos sinais detectados. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O webcomponents-loader.js</a> √© um carregador de inicializa√ß√£o m√≠nimo que, com base nos sintomas detectados, carrega os polyfills necess√°rios </li></ol><br><p>  Tamb√©m pe√ßo que voc√™ preste aten√ß√£o em outro polyfill - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">custom-elements-es5-adapter.js</a> .  De acordo com a especifica√ß√£o, apenas as classes ES6 podem ser adicionadas ao customElements.define nativo.  Para um melhor desempenho, o c√≥digo ES6 deve ser passado apenas para os navegadores que o suportam e o ES5 para todos os outros.  Isso nem sempre √© poss√≠vel, portanto, para uma melhor compatibilidade entre navegadores, √© recomend√°vel que todo o c√≥digo ES6 seja convertido em ES5.  Mas, nesse caso, os componentes da web no ES5 n√£o poder√£o funcionar nos navegadores.  Para resolver esse problema, h√° custom-elements-es5-adapter.js. </p><br><p>  Agora vamos abrir o arquivo <code>./src/my-element.js</code> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {html, LitElement, property} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LitElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// @property - ,    babel  ts //         //  ,   @property({type: String}) myProp = 'stuff'; render() { return html` &lt;p&gt;Hello World&lt;/p&gt; ${this.myProp} `; } } customElements.define('my-element', MyElement);</span></span></code> </pre><br><p>  O mecanismo de modelo lit-html pode processar uma sequ√™ncia de maneira diferente.  Vou lhe dar v√°rias op√ß√µes: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  : html`&lt;div&gt;Hi&lt;/div&gt;` // : html`&lt;div&gt;${this.disabled ? 'Off' : 'On'}&lt;/div&gt;` // : html`&lt;x-foo .bar="${this.bar}"&gt;&lt;/x-foo&gt;` // : html`&lt;div class="${this.color} special"&gt;&lt;/div&gt;` //   boolean,  checked === false, //        HTML: html`&lt;input type="checkbox" ?checked=${checked}&gt;` //  : html`&lt;button @click="${this._clickHandler}"&gt;&lt;/button&gt;`</span></span></code> </pre><br><p>  Dicas para otimizar a fun√ß√£o render (): </p><br><ul><li>  n√£o deve alterar o estado de um elemento, </li><li>  n√£o deve ter efeitos colaterais, </li><li>  deve depender apenas das propriedades do elemento, </li><li>  deve retornar o mesmo resultado ao transmitir os mesmos valores. </li></ul><br><p>  N√£o atualize o DOM fora da fun√ß√£o render (). </p><br><p>  O Lit-html √© respons√°vel por renderizar o elemento lit - essa √© uma maneira declarativa de descrever como o componente da web deve ser exibido.  O lit-html garante atualiza√ß√µes r√°pidas, alterando apenas as partes do DOM que precisam ser alteradas. </p><br><p>  Quase todo esse c√≥digo estava em um exemplo simples, mas o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">decorador</a> <code>@property</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">foi</a> adicionado √† propriedade <code>myProp</code> .  Esse decorador indica que estamos esperando um atributo chamado <code>myprop</code> em nosso <code>my-element</code> .  Se nenhum desses atributos estiver definido, o valor da sequ√™ncia ser√° definido como <code>stuff</code> por padr√£o. </p><br><pre> <code class="html hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!--  myProp  ,       -   'stuff' --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-element</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-element</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--  myprop         lowerCamelCase .. myProp   -      'else' --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-element</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">myprop</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"else"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-element</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><p>  O lit-element fornece duas maneiras de trabalhar com a <code>property</code> : </p><br><ol><li>  Atrav√©s do decorador. </li><li>  Via <code>properties</code> est√°ticas de um getter. </li></ol><br><p>  A primeira op√ß√£o permite especificar cada propriedade separadamente: </p><br><pre> <code class="javascript hljs">@property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>}) prop1 = <span class="hljs-string"><span class="hljs-string">''</span></span>; @property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>}) prop2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; @property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>}) prop3 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; @property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>}) prop4 = []; @property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>}) prop5 = {};</code> </pre><br><p>  O segundo √© especificar tudo em um s√≥ lugar, mas, neste caso, se a propriedade tiver um valor padr√£o, ela dever√° ser escrita no m√©todo construtor da classe: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get properties() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">prop1</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>}, <span class="hljs-attr"><span class="hljs-attr">prop2</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>}, <span class="hljs-attr"><span class="hljs-attr">prop3</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>}, <span class="hljs-attr"><span class="hljs-attr">prop4</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>}, <span class="hljs-attr"><span class="hljs-attr">prop5</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>} }; } <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop1 = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop3 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop4 = []; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop5 = {}; }</code> </pre><br><p>  A API para trabalhar com propriedades no elemento lit √© bastante extensa: </p><br><ul><li>  <b>atributo</b> : se uma propriedade pode se tornar um atributo observ√°vel.  Se <code>false</code> , o atributo ser√° exclu√≠do da observa√ß√£o; nenhum getter ser√° criado para ele.  Se <code>true</code> ou <code>attribute</code> ausente, a propriedade especificada no getter no formato lowerCamelCase corresponder√° ao atributo no formato da sequ√™ncia.  Se uma sequ√™ncia for especificada, por exemplo, <code>my-prop</code> , ela corresponder√° com o mesmo nome nos atributos. </li><li>  <b>conversor</b> : cont√©m uma descri√ß√£o de como converter um valor de / para um atributo / propriedade.  O valor pode ser uma fun√ß√£o que funciona para serializar e desserializar o valor, ou pode ser um objeto com as teclas <code>toAttribute</code> e <code>toAttribute</code> ; essas chaves cont√™m fun√ß√µes separadas para a convers√£o dos valores.  Por padr√£o, a propriedade cont√©m uma convers√£o para os tipos base <code>Boolean</code> , <code>String</code> , <code>Number</code> , <code>Object</code> e <code>Array</code> .  As regras de convers√£o est√£o listadas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </li><li>  <b>tipo</b> : indica um dos tipos de base que esta propriedade conter√°.  √â usado como uma "dica" para o conversor sobre o tipo que a propriedade deve conter. </li><li>  <b>refletir</b> : indica se o atributo deve ser associado √† propriedade ( <code>true</code> ) e alterado de acordo com as regras do <code>type</code> e do <code>converter</code> . </li><li>  <b>hasChanged</b> : cada propriedade possui, cont√©m uma fun√ß√£o que determina se h√° uma altera√ß√£o entre o antigo e o novo valor, respectivamente, retorna um <code>Boolean</code> .  Se <code>true</code> , ele come√ßa a atualizar o item. </li><li>  <b>noAccessor</b> : esta propriedade aceita um <code>Boolean</code> e o padr√£o √© <code>false</code> .  Pro√≠be a gera√ß√£o de getters e setters para cada propriedade para acess√°-los da classe.  Isso n√£o cancela a convers√£o. </li></ul><br><p>  Vamos fazer um exemplo hipot√©tico: escreveremos um componente da web que cont√©m um par√¢metro que cont√©m uma string. Essa palavra deve ser desenhada na tela, na qual cada letra √© maior que a anterior. <br></p><br><pre> <code class="html hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- index.html --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ladder-of-letters</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">letters</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">""</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ladder-of-letters</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//ladder-of-letters.js import {html, LitElement, property} from 'lit-element'; class LadderOfLetters extends LitElement { @property({ type: Array, converter: { fromAttribute: (val) =&gt; { // console.log('in fromAttribute', val); return val.split(''); } }, hasChanged: (value, oldValue) =&gt; { if(value === undefined || oldValue === undefined) { return false; } // console.log('in hasChanged', value, oldValue.join('')); return value !== oldValue; }, reflect: true }) letters = []; changeLetter() { this.letters = ['','','','','']; } render() { // console.log('in render', this.letters); //    ,    //        return html` &lt;div&gt;${this.letters.map((i, idx) =&gt; html`&lt;span style="font-size: ${idx + 2}em"&gt;${i}&lt;/span&gt;`)}&lt;/div&gt; // @click     ,     //   'click'    &lt;button @click=${this.changeLetter}&gt;  ''&lt;/button&gt; `; } } customElements.define('ladder-of-letters', LadderOfLetters);</span></span></code> </pre><br><p>  no final, temos: </p><br><img src="https://habrastorage.org/webt/fu/jt/ka/fujtka5wih6jghe9wfdwktv8pqw.png"><br><p>  quando o bot√£o foi clicado, a propriedade foi alterada, o que causou a verifica√ß√£o primeiro e depois foi enviada para redesenho. </p><br><img src="https://habrastorage.org/webt/sx/wi/bs/sxwibswpdvdynof2p9adjxt2ysq.png"><br><p>  e usando <code>reflect</code> tamb√©m podemos ver altera√ß√µes html </p><br><img src="https://habrastorage.org/webt/z1/oy/i9/z1oyi9lbcznkigdcmr7acffgsca.png"><br><p>  Se voc√™ alterar esse atributo com c√≥digo fora deste componente da web, tamb√©m causaremos um redesenho do componente da web. </p><br><p>  Agora considere o estilo do componente.  Temos duas maneiras de estilizar o elemento iluminado: </p><br><ol><li>  Estilo adicionando uma marca de estilo ao m√©todo de renderiza√ß√£o <br><br><pre> <code class="javascript hljs">render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> html<span class="hljs-string"><span class="hljs-string">` &lt;style&gt; p { color: green; } &lt;/style&gt; &lt;p&gt;Hello World&lt;/p&gt; `</span></span>; }</code> </pre><br><img src="https://habrastorage.org/webt/6r/70/ba/6r70bawofzxkhbtbx8pif2fu_au.png"><br></li><li>  Via <code>styles</code> getter est√°tico <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {html, LitElement, css} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LitElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get styles() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ css<span class="hljs-string"><span class="hljs-string">` p { color: red; } `</span></span> ]; } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> html<span class="hljs-string"><span class="hljs-string">` &lt;p&gt;Hello World&lt;/p&gt; `</span></span>; } } customElements.define(<span class="hljs-string"><span class="hljs-string">'my-element'</span></span>, MyElement);</code> </pre><br></li></ol><br><p>  Como resultado, conclu√≠mos que uma tag com estilos n√£o √© criada, mas √© gravada ( <code>&gt;= Chrome 73</code> ) no <code>Shadow DOM</code> elemento, de acordo com a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">especifica√ß√£o</a> .  Isso melhora o desempenho com um grande n√∫mero de elementos, porque  ao registrar um novo componente, ele j√° sabe quais propriedades seus estilos determinam; eles n√£o precisam ser registrados todas as vezes e recontados. </p><br><img src="https://habrastorage.org/webt/tc/ew/rs/tcewrs9bnnmopzuprmi3kgapbam.png"><br><br><p>  Al√©m disso, se essa especifica√ß√£o n√£o for suportada, uma tag de <code>style</code> regular ser√° criada no componente. </p><br><img src="https://habrastorage.org/webt/ah/kl/9h/ahkl9hm7c8wmkevk8fctarpkdao.png"><br><br><p>  Al√©m disso, n√£o esque√ßa que dessa maneira tamb√©m podemos separar quais estilos ser√£o adicionados e calculados na p√°gina.  Por exemplo, para usar consultas de m√≠dia n√£o em css, mas em JS e implementar apenas o estilo desejado, por exemplo (isso √© selvagem, mas precisa ser): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get styles() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mobileStyle = css<span class="hljs-string"><span class="hljs-string">`p { color: red; }`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> desktopStyle = css<span class="hljs-string"><span class="hljs-string">`p { color: green; }`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.matchMedia(<span class="hljs-string"><span class="hljs-string">"(min-width: 400px)"</span></span>).matches ? desktopStyle : mobileStyle ]; }</code> </pre><br><p>  Dessa forma, veremos isso se o usu√°rio efetuou logon em um dispositivo com uma largura de tela superior a 400px. </p><br><img src="https://habrastorage.org/webt/k5/cu/it/k5cuitrmqpwb-76qid-1qamtpuw.png"><br><p>  E isso √© se o usu√°rio visitou o site a partir de um dispositivo com uma largura inferior a 400px. </p><br><img src="https://habrastorage.org/webt/z-/jy/jw/z-jyjw7canilafm3cmsjfuxtv6g.png"><br><p>  Minha opini√£o: praticamente n√£o existe um caso adequado quando um usu√°rio, trabalhando em um dispositivo m√≥vel, de repente enfrenta um monitor completo com uma largura de tela de 1920 px.  Adicione a isso o carregamento lento dos componentes.  Como resultado, obtemos uma frente muito otimizada com renderiza√ß√£o r√°pida de componentes.  O √∫nico problema √© a dificuldade em apoiar. </p><br><p>  Agora, proponho me familiarizar com os m√©todos do ciclo de vida do elemento iluminado: </p><br><ul><li>  <b>render ()</b> : implementa uma descri√ß√£o do elemento DOM usando <code>lit-html</code> .  Idealmente, a fun√ß√£o <code>render</code> √© uma fun√ß√£o pura que usa apenas as propriedades atuais do elemento.  O m√©todo <code>render()</code> √© chamado pela fun√ß√£o <code>update()</code> . </li><li>  <b>shouldUpdate (modifiedProperties)</b> : implementado se for necess√°rio controlar a atualiza√ß√£o e a renderiza√ß√£o, quando as propriedades foram alteradas ou <code>requestUpdate()</code> chamado.  O argumento para a fun√ß√£o <code>changedProperties</code> √© um <code>Map</code> cont√©m chaves para as propriedades alteradas.  Por padr√£o, esse m√©todo sempre retorna <code>true</code> , mas a l√≥gica do m√©todo pode ser alterada para controlar a atualiza√ß√£o do componente. </li><li>  <b>performUpdate ()</b> : implementado para controlar o tempo de atualiza√ß√£o, por exemplo, para integrar-se ao planejador. </li><li>  <b>update (modifiedProperties)</b> : esse m√©todo chama <code>render()</code> .  Tamb√©m atualiza os atributos de um elemento de acordo com o valor da propriedade.  Definir propriedades dentro deste m√©todo n√£o causar√° outra atualiza√ß√£o. </li><li>  <b>firstUpdated (modifiedProperties)</b> : chamado ap√≥s a primeira atualiza√ß√£o do elemento DOM imediatamente antes da chamada <code>updated()</code> .  Esse m√©todo pode ser √∫til para capturar links para n√≥s est√°ticos visualizados com os quais voc√™ precisa trabalhar diretamente, por exemplo, em <code>updated()</code> . </li><li>  <b>updated (modifiedProperties)</b> : chamado sempre que o DOM de um item √© atualizado e exibido.  Uma implementa√ß√£o para executar tarefas ap√≥s a atualiza√ß√£o por meio da API DOM, por exemplo, com foco em um elemento. </li><li>  <b>requestUpdate (name, oldValue)</b> : chama uma solicita√ß√£o de atualiza√ß√£o ass√≠ncrona para um item.  Isso deve ser chamado quando o item precisar ser atualizado com base em algum estado n√£o causado pela configura√ß√£o da propriedade. </li><li>  <b>createRenderRoot ()</b> : por padr√£o, cria uma raiz de sombra para o item.  Se o uso do Shadow DOM n√£o for necess√°rio, o m√©todo deve retornar <code>this</code> . </li></ul><br><p>  Como o elemento √© atualizado: </p><br><ul><li>  A propriedade recebe um novo valor. </li><li>  Se a propriedade <code>hasChanged(value, oldValue)</code> retornar <code>false</code> , o item n√£o ser√° atualizado.  Caso contr√°rio, uma atualiza√ß√£o √© planejada chamando <code>requestUpdate()</code> . </li><li>  <b>requestUpdate ()</b> : atualiza o elemento ap√≥s microtask (no final do loop de eventos e antes do pr√≥ximo redesenho). </li><li>  <b>performUpdate ()</b> : a atualiza√ß√£o est√° em andamento e continua com o restante da API de atualiza√ß√£o. </li><li>  <b>shouldUpdate (modifiedProperties)</b> : a atualiza√ß√£o continuar√° se <code>true</code> retornado. </li><li>  <b>firstUpdated (modifiedProperties)</b> : chamado quando o item √© atualizado pela primeira vez, imediatamente antes de chamar <code>updated()</code> . </li><li>  <b>update (modifiedProperties)</b> : atualiza o item.  Alterar propriedades neste m√©todo n√£o causa outra atualiza√ß√£o. <br><ul><li>  <b>render ()</b> : retorna um modelo <code>lit-html</code> para renderizar um elemento no DOM.  Alterar propriedades neste m√©todo n√£o causa outra atualiza√ß√£o. </li></ul><br></li><li>  <b>updated (modifiedProperties)</b> : chamado sempre que um item √© atualizado. </li></ul><br><p>  Para entender todas as nuances do ciclo de vida do componente, aconselho a consultar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> . </p><br><p>  No trabalho, tenho um projeto no Adobe Experience Manager (AEM), na sua cria√ß√£o, o usu√°rio pode arrastar e soltar componentes na p√°gina e, de acordo com a ideologia do AEM, esse componente cont√©m uma tag de <code>script</code> que cont√©m tudo o que √© necess√°rio para implementar a l√≥gica desse componente.  Mas, de fato, essa abordagem deu origem a muitos recursos e dificuldades de bloqueio na implementa√ß√£o da frente nesse sistema.  Para implementar a frente, os componentes da web foram escolhidos como uma maneira de n√£o alterar a renderiza√ß√£o do servidor (o que ele fez muito bem), al√©m de enriquecer a implementa√ß√£o antiga com uma nova abordagem suavemente, bit a bit.  Na minha opini√£o, existem v√°rias op√ß√µes para implementar o carregamento de componentes da Web para esse sistema: coletar um pacote (que pode se tornar muito grande) ou dividi-lo em peda√ßos (s√£o necess√°rios muitos arquivos pequenos, √© necess√°rio carregamento din√¢mico) ou usar a abordagem atual para incorporar um script em cada um componente que √© renderizado no lado do servidor (eu realmente n√£o quero voltar a isso).  Na minha opini√£o, a primeira e a terceira op√ß√£o n√£o s√£o uma op√ß√£o.  Para o segundo, voc√™ precisa de um carregador de inicializa√ß√£o din√¢mico, como no est√™ncil.  Mas para o elemento iluminado na "caixa" isso n√£o √© fornecido.  Houve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma tentativa</a> dos desenvolvedores de elementos iluminados de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">criar um carregador din√¢mico</a> , mas √© um experimento e n√£o √© recomend√°vel us√°-lo na produ√ß√£o.  Tamb√©m dos desenvolvedores de elementos iluminados, h√° um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">problema</a> no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reposit√≥rio de especifica√ß√µes de componentes da Web</a> com uma proposta para adicionar √† especifica√ß√£o a capacidade de carregar dinamicamente os js necess√°rios para o componente da Web com base na marca√ß√£o html na p√°gina.  E, na minha opini√£o, essa ferramenta nativa √© uma ideia muito boa que permitir√° criar um ponto de inicializa√ß√£o de componentes da Web e simplesmente adicion√°-lo a todas as p√°ginas do site. </p><br><p>  Para carregar dinamicamente componentes da Web de elementos iluminados dinamicamente com os caras do PolymerLabs, foi desenvolvido <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um elemento de divis√£o</a> .  Esta √© uma solu√ß√£o experimental.  Funciona da seguinte maneira: </p><br><ul><li>  Para criar um SplitElement, voc√™ escreve duas defini√ß√µes de elementos em dois m√≥dulos. </li><li>  Um deles √© um esbo√ßo, que define as partes carregadas de um elemento: geralmente esse √© o nome e as propriedades.  As propriedades devem ser definidas com um stub para que o elemento lit possa gerar atributos observ√°veis ‚Äã‚Äãem tempo h√°bil para chamar <code>customElements.define()</code> . </li><li>  O stub tamb√©m deve ter um m√©todo de carregamento ass√≠ncrono est√°tico que retorna uma classe de implementa√ß√£o. </li><li>  Outra classe √© a "implementa√ß√£o", que cont√©m todo o resto. </li><li>  O construtor <code>SplitElement</code> carrega a classe de implementa√ß√£o e executa <code>upgrade()</code> . </li></ul><br><p>  Exemplo de stub: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {SplitElement, property} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../split-element.js'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SplitElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// MyElement    load   //      connectedCallback()   static async load() { //        //      MyElement return (await import('./my-element-impl.js')).MyElementImpl; } //      //   - @property() message: string; } customElements.define('my-element', MyElement);</span></span></code> </pre><br><p>  Exemplo de implementa√ß√£o: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {MyElement} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./my-element.js'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {html} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../split-element.js'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// MyElementImpl  render    - export class MyElementImpl extends MyElement { render() { return html` &lt;h1&gt;I've been upgraded&lt;/h1&gt; My message is ${this.message}. `; } }</span></span></code> </pre><br><p>  Exemplo de SplitElement no ES6: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {LitElement, html} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    LitElement  SplitElement //       export class SplitElement extends LitElement { static load; static _resolveLoaded; static _rejectLoaded; static _loadedPromise; static implClass; static loaded() { if (!this.hasOwnProperty('_loadedPromise')) { this._loadedPromise = new Promise((resolve, reject) =&gt; { this._resolveLoaded = resolve; this._rejectLoaded = reject; }); } return this._loadedPromise; } //      - //      static _upgrade(element, klass) { SplitElement._upgradingElement = element; Object.setPrototypeOf(element, klass.prototype); new klass(); SplitElement._upgradingElement = undefined; element.requestUpdate(); if (element.isConnected) { element.connectedCallback(); } } static _upgradingElement; constructor() { if (SplitElement._upgradingElement !== undefined) { return SplitElement._upgradingElement; } super(); const ctor = this.constructor; if (ctor.hasOwnProperty('implClass')) { //   ,   ctor._upgrade(this, ctor.implClass); } else { //    if (typeof ctor.load !== 'function') { throw new Error('A SplitElement must have a static `load` method'); } (async () =&gt; { ctor.implClass = await ctor.load(); ctor._upgrade(this, ctor.implClass); })(); } } //       render() { return html``; } }</span></span></code> </pre><br><p>  Se voc√™ ainda estiver usando a montagem sugerida acima no Rollup, certifique-se de definir o babel para poder manipular importa√ß√µes din√¢micas </p><br><pre> <code class="plaintext hljs">npm install @babel/plugin-syntax-dynamic-import</code> </pre> <br><p>  E nas configura√ß√µes .babelrc adicione </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"plugins"</span></span>: [<span class="hljs-string"><span class="hljs-string">"@babel/plugin-syntax-dynamic-import"</span></span>] }</code> </pre><br><p>  Aqui fiz um pequeno exemplo da implementa√ß√£o de componentes da Web com carregamento atrasado: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/malay76a/elbrus-split-litelement-web-components</a> </p><br><p>  Tentei aplicar a abordagem de carregamento din√¢mico de componentes da web, cheguei √† seguinte conclus√£o: a ferramenta est√° funcionando bem, √© necess√°rio coletar todas as defini√ß√µes de componentes da web em um arquivo e conectar a descri√ß√£o do pr√≥prio componente atrav√©s de peda√ßos separadamente.  Sem o http2, essa abordagem n√£o funciona, porque  Um conjunto muito grande de arquivos pequenos que descrevem os componentes √© formado.  Com base no princ√≠pio do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">design at√¥mico</a> , a importa√ß√£o de √°tomos deve ser determinada no corpo, mas o corpo j√° deve estar conectado como um componente separado.  Um dos gargalos √© que o usu√°rio receber√° muitas defini√ß√µes de elementos do usu√°rio no navegador que ser√£o inicializadas de uma maneira ou de outra no navegador e o estado inicial ser√° determinado.  Essa solu√ß√£o √© redundante.  Uma das op√ß√µes para uma solu√ß√£o simples para o carregador de componentes √© o seguinte algoritmo: </p><br><ol><li>  carregar os utilit√°rios necess√°rios, </li><li>  carregar polyfills, </li><li>  montar elementos personalizados a partir do light DOM: <br><ol><li>  todos os elementos DOM que cont√™m um h√≠fen no nome da tag s√£o selecionados </li><li>  a lista √© filtrada e √© formada uma lista dos primeiros elementos. </li></ol></li><li>       : <br><ol><li>    Intersection Observer, </li><li>        +- 100px      import. </li></ol></li><li><ol><li>     3       shadowDOM, </li><li>  ,   shadowDOM  ,     ,  import   JS. </li></ol><br></li></ol><br><p>      -  lit-element        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">open-wc.org</a> .        webpack  rollup,    -      storybook,          IDE. </p><br><h2>  : </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Let's Build Web Components! Part 5: LitElement</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Web Component Essentials</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A night experimenting with Lit-HTML‚Ä¶</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LitElement To Do App</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LitElement app tutorial part 1: Getting started</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LitElement tutorial part 2: Templating, properties, and events</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LitElement tutorial part 3: State management with Redux</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LitElement tutorial part 4: Navigation and code splitting</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LitElement tutorial part 5: PWA and offline</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Lit-html workshop</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Awesome lit-html</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt445438/">https://habr.com/ru/post/pt445438/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt445426/index.html">Otimiza√ß√£o para PostgreSQL servindo aplica√ß√£o Rails</a></li>
<li><a href="../pt445428/index.html">Wi-Fi de alta qualidade - a base da hospitalidade moderna e o motor dos neg√≥cios</a></li>
<li><a href="../pt445432/index.html">Gerenciador de Pacotes Unity</a></li>
<li><a href="../pt445434/index.html">Melhor Pior Emprego do Mundo: Procurando um Habraautor</a></li>
<li><a href="../pt445436/index.html">Reciclagem no DevOps - para o que se preparar</a></li>
<li><a href="../pt445440/index.html">Revis√£o de c√≥digo: dicas ruins para colaborador e revisor</a></li>
<li><a href="../pt445444/index.html">Atualiza√ß√£o de m√≥dulos solares de alto desempenho da REC e Trina (Solar)</a></li>
<li><a href="../pt445446/index.html">Como usamos a replica√ß√£o adiada para recupera√ß√£o de desastres com o PostgreSQL</a></li>
<li><a href="../pt445448/index.html">Configurando o recebimento autom√°tico de certificados letsencrypt usando o docker no linux</a></li>
<li><a href="../pt445450/index.html">Extens√£o do navegador para toster.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>