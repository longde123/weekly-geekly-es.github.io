<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏾‍🤝‍🧑🏻 👨‍👧‍👦 🕋 Familiaridade com elementos iluminados e componentes da Web com base nele 🤲 🏌️ 🤷🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em um ponto, tive que me familiarizar com os componentes da Web com urgência e encontrar uma maneira de desenvolver convenientemente usando-os. Eu pre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Familiaridade com elementos iluminados e componentes da Web com base nele</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445438/"><p>  Em um ponto, tive que me familiarizar com os componentes da Web com urgência e encontrar uma maneira de desenvolver convenientemente usando-os.  Eu pretendo escrever uma série de artigos que <br>  de alguma forma, organizar o conhecimento de componentes da web, elemento iluminado e fornecer uma breve introdução a essa tecnologia para outros. <a name="habracut"></a>  Não sou especialista nesta tecnologia e aceitarei com prazer qualquer feedback. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">lit-element</a> é um invólucro (modelo básico) para componentes da web nativos.  Ele implementa muitos métodos convenientes que não estão na especificação.  Devido à sua proximidade com a implementação nativa, o lit-element mostra resultados muito bons em várias <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">referências em</a> relação a outras abordagens (a partir de 06/02/2019). </p><br><p>  Bônus que vejo ao usar o lit-element como uma classe base de componentes da web: </p><br><ol><li>  Essa tecnologia já implementa a segunda versão e “adoeceu com doenças da infância”, peculiares aos instrumentos que acabaram de aparecer. </li><li>  A montagem pode ser realizada tanto em polímero quanto em webpack, texto datilografado, rollup etc., permitindo incorporar elementos iluminados em qualquer projeto moderno sem problemas. </li><li>  O elemento lit tem um sistema muito conveniente de trabalhar com propriedades em termos de digitar, iniciar e converter valores. </li><li>  o elemento lit implementa quase a mesma lógica que a reação, ou seja,  fornece o mínimo - um modelo único para a construção de componentes e sua renderização e não limita o desenvolvedor a escolher um ecossistema e bibliotecas adicionais. </li></ol><br><p>  Crie um componente da web simples no elemento iluminado.  Vamos voltar para a documentação.  Precisamos do seguinte: </p><br><ol><li>  Adicione pacote npm com elemento lit à nossa montagem <br><br><pre><code class="plaintext hljs">npm install --save lit-element</code> </pre> </li><li>  Crie nosso componente. </li></ol><br><p>  Por exemplo, precisamos criar um componente da web inicializado na tag <code>my-component</code> .  Para fazer isso, crie o arquivo js <code>my-component.js</code> e defina seu modelo básico: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//       lit-element import { } from ''; //      class MyComponent { } //      customElements.define();</span></span></code> </pre><br><p>  Primeiro, importamos nosso modelo básico: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { LitElement, html } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// LitElement -    ()   - // html -  lit-html,     ,  //    html   </span></span></code> </pre><br><p>  Em segundo lugar, crie o próprio componente da Web usando <code>LitElement</code> </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,    //  LitElement    HTMLElement class MyComponent extends LitElement { //    LitElement   //      constructor  connectedCallback //           //    ,       // shadowDOM   {mode: 'open'} render() { return html`&lt;p&gt;Hello World!&lt;/p&gt;` } }</span></span></code> </pre><br><p>  E a última coisa é registrar o componente da web no navegador </p><br><pre> <code class="javascript hljs">customElements.define(<span class="hljs-string"><span class="hljs-string">'my-component'</span></span>, MyComponent);</code> </pre><br><p>  Como resultado, obtemos o seguinte: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { LitElement, html } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LitElement</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> html<span class="hljs-string"><span class="hljs-string">`&lt;p&gt;Hello World!&lt;/p&gt;`</span></span> } } customElements.define(<span class="hljs-string"><span class="hljs-string">'my-component'</span></span>, MyComponent);</code> </pre><br><p>  Se você excluir a necessidade de conectar o <code>my-component.js</code> ao html, é isso.  O componente mais simples está pronto. </p><br><p>  Proponho não reinventar a roda e fazer a montagem final do acúmulo de elementos iluminados.  Siga as instruções: </p><br><pre> <code class="plaintext hljs">git clone https://github.com/PolymerLabs/lit-element-build-rollup.git cd lit-element-build-rollup npm install npm run build npm run start</code> </pre><br><p>  Após a conclusão de todos os comandos, vamos para a página no navegador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http: // localhost: 5000 /</a> . </p><br><p>  Se dermos uma olhada em html, veremos que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">webcomponents-loader.js</a> está na frente da tag de fechamento.  Este é um conjunto de polyfills para componentes da web e, para operação entre navegadores do componente da web, é desejável que esse polyfill esteja presente.  Vamos dar uma olhada na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tabela de navegadores</a> que implementam todos os padrões para trabalhar com componentes da Web. Ele diz que o EDGE ainda não implementa totalmente os padrões (estou em silêncio sobre o IE11, que ainda precisa ser suportado). </p><br><img src="https://habrastorage.org/webt/q1/g2/6w/q1g26wcj65en1zl0z0d4d2ar67c.png"><br><p>  Foram implementadas 2 opções para este polyfill: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">webcomponents-bundle.js</a> - esta versão contém todas as opções possíveis para o polyfill, todas iniciadas, mas cada polyfill funcionará apenas com base nos sinais detectados. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O webcomponents-loader.js</a> é um carregador de inicialização mínimo que, com base nos sintomas detectados, carrega os polyfills necessários </li></ol><br><p>  Também peço que você preste atenção em outro polyfill - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">custom-elements-es5-adapter.js</a> .  De acordo com a especificação, apenas as classes ES6 podem ser adicionadas ao customElements.define nativo.  Para um melhor desempenho, o código ES6 deve ser passado apenas para os navegadores que o suportam e o ES5 para todos os outros.  Isso nem sempre é possível, portanto, para uma melhor compatibilidade entre navegadores, é recomendável que todo o código ES6 seja convertido em ES5.  Mas, nesse caso, os componentes da web no ES5 não poderão funcionar nos navegadores.  Para resolver esse problema, há custom-elements-es5-adapter.js. </p><br><p>  Agora vamos abrir o arquivo <code>./src/my-element.js</code> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {html, LitElement, property} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LitElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// @property - ,    babel  ts //         //  ,   @property({type: String}) myProp = 'stuff'; render() { return html` &lt;p&gt;Hello World&lt;/p&gt; ${this.myProp} `; } } customElements.define('my-element', MyElement);</span></span></code> </pre><br><p>  O mecanismo de modelo lit-html pode processar uma sequência de maneira diferente.  Vou lhe dar várias opções: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  : html`&lt;div&gt;Hi&lt;/div&gt;` // : html`&lt;div&gt;${this.disabled ? 'Off' : 'On'}&lt;/div&gt;` // : html`&lt;x-foo .bar="${this.bar}"&gt;&lt;/x-foo&gt;` // : html`&lt;div class="${this.color} special"&gt;&lt;/div&gt;` //   boolean,  checked === false, //        HTML: html`&lt;input type="checkbox" ?checked=${checked}&gt;` //  : html`&lt;button @click="${this._clickHandler}"&gt;&lt;/button&gt;`</span></span></code> </pre><br><p>  Dicas para otimizar a função render (): </p><br><ul><li>  não deve alterar o estado de um elemento, </li><li>  não deve ter efeitos colaterais, </li><li>  deve depender apenas das propriedades do elemento, </li><li>  deve retornar o mesmo resultado ao transmitir os mesmos valores. </li></ul><br><p>  Não atualize o DOM fora da função render (). </p><br><p>  O Lit-html é responsável por renderizar o elemento lit - essa é uma maneira declarativa de descrever como o componente da web deve ser exibido.  O lit-html garante atualizações rápidas, alterando apenas as partes do DOM que precisam ser alteradas. </p><br><p>  Quase todo esse código estava em um exemplo simples, mas o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">decorador</a> <code>@property</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">foi</a> adicionado à propriedade <code>myProp</code> .  Esse decorador indica que estamos esperando um atributo chamado <code>myprop</code> em nosso <code>my-element</code> .  Se nenhum desses atributos estiver definido, o valor da sequência será definido como <code>stuff</code> por padrão. </p><br><pre> <code class="html hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!--  myProp  ,       -   'stuff' --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-element</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-element</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--  myprop         lowerCamelCase .. myProp   -      'else' --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-element</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">myprop</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"else"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-element</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><p>  O lit-element fornece duas maneiras de trabalhar com a <code>property</code> : </p><br><ol><li>  Através do decorador. </li><li>  Via <code>properties</code> estáticas de um getter. </li></ol><br><p>  A primeira opção permite especificar cada propriedade separadamente: </p><br><pre> <code class="javascript hljs">@property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>}) prop1 = <span class="hljs-string"><span class="hljs-string">''</span></span>; @property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>}) prop2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; @property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>}) prop3 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; @property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>}) prop4 = []; @property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>}) prop5 = {};</code> </pre><br><p>  O segundo é especificar tudo em um só lugar, mas, neste caso, se a propriedade tiver um valor padrão, ela deverá ser escrita no método construtor da classe: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get properties() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">prop1</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>}, <span class="hljs-attr"><span class="hljs-attr">prop2</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>}, <span class="hljs-attr"><span class="hljs-attr">prop3</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>}, <span class="hljs-attr"><span class="hljs-attr">prop4</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>}, <span class="hljs-attr"><span class="hljs-attr">prop5</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>} }; } <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop1 = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop3 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop4 = []; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop5 = {}; }</code> </pre><br><p>  A API para trabalhar com propriedades no elemento lit é bastante extensa: </p><br><ul><li>  <b>atributo</b> : se uma propriedade pode se tornar um atributo observável.  Se <code>false</code> , o atributo será excluído da observação; nenhum getter será criado para ele.  Se <code>true</code> ou <code>attribute</code> ausente, a propriedade especificada no getter no formato lowerCamelCase corresponderá ao atributo no formato da sequência.  Se uma sequência for especificada, por exemplo, <code>my-prop</code> , ela corresponderá com o mesmo nome nos atributos. </li><li>  <b>conversor</b> : contém uma descrição de como converter um valor de / para um atributo / propriedade.  O valor pode ser uma função que funciona para serializar e desserializar o valor, ou pode ser um objeto com as teclas <code>toAttribute</code> e <code>toAttribute</code> ; essas chaves contêm funções separadas para a conversão dos valores.  Por padrão, a propriedade contém uma conversão para os tipos base <code>Boolean</code> , <code>String</code> , <code>Number</code> , <code>Object</code> e <code>Array</code> .  As regras de conversão estão listadas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </li><li>  <b>tipo</b> : indica um dos tipos de base que esta propriedade conterá.  É usado como uma "dica" para o conversor sobre o tipo que a propriedade deve conter. </li><li>  <b>refletir</b> : indica se o atributo deve ser associado à propriedade ( <code>true</code> ) e alterado de acordo com as regras do <code>type</code> e do <code>converter</code> . </li><li>  <b>hasChanged</b> : cada propriedade possui, contém uma função que determina se há uma alteração entre o antigo e o novo valor, respectivamente, retorna um <code>Boolean</code> .  Se <code>true</code> , ele começa a atualizar o item. </li><li>  <b>noAccessor</b> : esta propriedade aceita um <code>Boolean</code> e o padrão é <code>false</code> .  Proíbe a geração de getters e setters para cada propriedade para acessá-los da classe.  Isso não cancela a conversão. </li></ul><br><p>  Vamos fazer um exemplo hipotético: escreveremos um componente da web que contém um parâmetro que contém uma string. Essa palavra deve ser desenhada na tela, na qual cada letra é maior que a anterior. <br></p><br><pre> <code class="html hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- index.html --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ladder-of-letters</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">letters</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">""</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ladder-of-letters</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//ladder-of-letters.js import {html, LitElement, property} from 'lit-element'; class LadderOfLetters extends LitElement { @property({ type: Array, converter: { fromAttribute: (val) =&gt; { // console.log('in fromAttribute', val); return val.split(''); } }, hasChanged: (value, oldValue) =&gt; { if(value === undefined || oldValue === undefined) { return false; } // console.log('in hasChanged', value, oldValue.join('')); return value !== oldValue; }, reflect: true }) letters = []; changeLetter() { this.letters = ['','','','','']; } render() { // console.log('in render', this.letters); //    ,    //        return html` &lt;div&gt;${this.letters.map((i, idx) =&gt; html`&lt;span style="font-size: ${idx + 2}em"&gt;${i}&lt;/span&gt;`)}&lt;/div&gt; // @click     ,     //   'click'    &lt;button @click=${this.changeLetter}&gt;  ''&lt;/button&gt; `; } } customElements.define('ladder-of-letters', LadderOfLetters);</span></span></code> </pre><br><p>  no final, temos: </p><br><img src="https://habrastorage.org/webt/fu/jt/ka/fujtka5wih6jghe9wfdwktv8pqw.png"><br><p>  quando o botão foi clicado, a propriedade foi alterada, o que causou a verificação primeiro e depois foi enviada para redesenho. </p><br><img src="https://habrastorage.org/webt/sx/wi/bs/sxwibswpdvdynof2p9adjxt2ysq.png"><br><p>  e usando <code>reflect</code> também podemos ver alterações html </p><br><img src="https://habrastorage.org/webt/z1/oy/i9/z1oyi9lbcznkigdcmr7acffgsca.png"><br><p>  Se você alterar esse atributo com código fora deste componente da web, também causaremos um redesenho do componente da web. </p><br><p>  Agora considere o estilo do componente.  Temos duas maneiras de estilizar o elemento iluminado: </p><br><ol><li>  Estilo adicionando uma marca de estilo ao método de renderização <br><br><pre> <code class="javascript hljs">render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> html<span class="hljs-string"><span class="hljs-string">` &lt;style&gt; p { color: green; } &lt;/style&gt; &lt;p&gt;Hello World&lt;/p&gt; `</span></span>; }</code> </pre><br><img src="https://habrastorage.org/webt/6r/70/ba/6r70bawofzxkhbtbx8pif2fu_au.png"><br></li><li>  Via <code>styles</code> getter estático <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {html, LitElement, css} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LitElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get styles() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ css<span class="hljs-string"><span class="hljs-string">` p { color: red; } `</span></span> ]; } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> html<span class="hljs-string"><span class="hljs-string">` &lt;p&gt;Hello World&lt;/p&gt; `</span></span>; } } customElements.define(<span class="hljs-string"><span class="hljs-string">'my-element'</span></span>, MyElement);</code> </pre><br></li></ol><br><p>  Como resultado, concluímos que uma tag com estilos não é criada, mas é gravada ( <code>&gt;= Chrome 73</code> ) no <code>Shadow DOM</code> elemento, de acordo com a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">especificação</a> .  Isso melhora o desempenho com um grande número de elementos, porque  ao registrar um novo componente, ele já sabe quais propriedades seus estilos determinam; eles não precisam ser registrados todas as vezes e recontados. </p><br><img src="https://habrastorage.org/webt/tc/ew/rs/tcewrs9bnnmopzuprmi3kgapbam.png"><br><br><p>  Além disso, se essa especificação não for suportada, uma tag de <code>style</code> regular será criada no componente. </p><br><img src="https://habrastorage.org/webt/ah/kl/9h/ahkl9hm7c8wmkevk8fctarpkdao.png"><br><br><p>  Além disso, não esqueça que dessa maneira também podemos separar quais estilos serão adicionados e calculados na página.  Por exemplo, para usar consultas de mídia não em css, mas em JS e implementar apenas o estilo desejado, por exemplo (isso é selvagem, mas precisa ser): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get styles() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mobileStyle = css<span class="hljs-string"><span class="hljs-string">`p { color: red; }`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> desktopStyle = css<span class="hljs-string"><span class="hljs-string">`p { color: green; }`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.matchMedia(<span class="hljs-string"><span class="hljs-string">"(min-width: 400px)"</span></span>).matches ? desktopStyle : mobileStyle ]; }</code> </pre><br><p>  Dessa forma, veremos isso se o usuário efetuou logon em um dispositivo com uma largura de tela superior a 400px. </p><br><img src="https://habrastorage.org/webt/k5/cu/it/k5cuitrmqpwb-76qid-1qamtpuw.png"><br><p>  E isso é se o usuário visitou o site a partir de um dispositivo com uma largura inferior a 400px. </p><br><img src="https://habrastorage.org/webt/z-/jy/jw/z-jyjw7canilafm3cmsjfuxtv6g.png"><br><p>  Minha opinião: praticamente não existe um caso adequado quando um usuário, trabalhando em um dispositivo móvel, de repente enfrenta um monitor completo com uma largura de tela de 1920 px.  Adicione a isso o carregamento lento dos componentes.  Como resultado, obtemos uma frente muito otimizada com renderização rápida de componentes.  O único problema é a dificuldade em apoiar. </p><br><p>  Agora, proponho me familiarizar com os métodos do ciclo de vida do elemento iluminado: </p><br><ul><li>  <b>render ()</b> : implementa uma descrição do elemento DOM usando <code>lit-html</code> .  Idealmente, a função <code>render</code> é uma função pura que usa apenas as propriedades atuais do elemento.  O método <code>render()</code> é chamado pela função <code>update()</code> . </li><li>  <b>shouldUpdate (modifiedProperties)</b> : implementado se for necessário controlar a atualização e a renderização, quando as propriedades foram alteradas ou <code>requestUpdate()</code> chamado.  O argumento para a função <code>changedProperties</code> é um <code>Map</code> contém chaves para as propriedades alteradas.  Por padrão, esse método sempre retorna <code>true</code> , mas a lógica do método pode ser alterada para controlar a atualização do componente. </li><li>  <b>performUpdate ()</b> : implementado para controlar o tempo de atualização, por exemplo, para integrar-se ao planejador. </li><li>  <b>update (modifiedProperties)</b> : esse método chama <code>render()</code> .  Também atualiza os atributos de um elemento de acordo com o valor da propriedade.  Definir propriedades dentro deste método não causará outra atualização. </li><li>  <b>firstUpdated (modifiedProperties)</b> : chamado após a primeira atualização do elemento DOM imediatamente antes da chamada <code>updated()</code> .  Esse método pode ser útil para capturar links para nós estáticos visualizados com os quais você precisa trabalhar diretamente, por exemplo, em <code>updated()</code> . </li><li>  <b>updated (modifiedProperties)</b> : chamado sempre que o DOM de um item é atualizado e exibido.  Uma implementação para executar tarefas após a atualização por meio da API DOM, por exemplo, com foco em um elemento. </li><li>  <b>requestUpdate (name, oldValue)</b> : chama uma solicitação de atualização assíncrona para um item.  Isso deve ser chamado quando o item precisar ser atualizado com base em algum estado não causado pela configuração da propriedade. </li><li>  <b>createRenderRoot ()</b> : por padrão, cria uma raiz de sombra para o item.  Se o uso do Shadow DOM não for necessário, o método deve retornar <code>this</code> . </li></ul><br><p>  Como o elemento é atualizado: </p><br><ul><li>  A propriedade recebe um novo valor. </li><li>  Se a propriedade <code>hasChanged(value, oldValue)</code> retornar <code>false</code> , o item não será atualizado.  Caso contrário, uma atualização é planejada chamando <code>requestUpdate()</code> . </li><li>  <b>requestUpdate ()</b> : atualiza o elemento após microtask (no final do loop de eventos e antes do próximo redesenho). </li><li>  <b>performUpdate ()</b> : a atualização está em andamento e continua com o restante da API de atualização. </li><li>  <b>shouldUpdate (modifiedProperties)</b> : a atualização continuará se <code>true</code> retornado. </li><li>  <b>firstUpdated (modifiedProperties)</b> : chamado quando o item é atualizado pela primeira vez, imediatamente antes de chamar <code>updated()</code> . </li><li>  <b>update (modifiedProperties)</b> : atualiza o item.  Alterar propriedades neste método não causa outra atualização. <br><ul><li>  <b>render ()</b> : retorna um modelo <code>lit-html</code> para renderizar um elemento no DOM.  Alterar propriedades neste método não causa outra atualização. </li></ul><br></li><li>  <b>updated (modifiedProperties)</b> : chamado sempre que um item é atualizado. </li></ul><br><p>  Para entender todas as nuances do ciclo de vida do componente, aconselho a consultar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação</a> . </p><br><p>  No trabalho, tenho um projeto no Adobe Experience Manager (AEM), na sua criação, o usuário pode arrastar e soltar componentes na página e, de acordo com a ideologia do AEM, esse componente contém uma tag de <code>script</code> que contém tudo o que é necessário para implementar a lógica desse componente.  Mas, de fato, essa abordagem deu origem a muitos recursos e dificuldades de bloqueio na implementação da frente nesse sistema.  Para implementar a frente, os componentes da web foram escolhidos como uma maneira de não alterar a renderização do servidor (o que ele fez muito bem), além de enriquecer a implementação antiga com uma nova abordagem suavemente, bit a bit.  Na minha opinião, existem várias opções para implementar o carregamento de componentes da Web para esse sistema: coletar um pacote (que pode se tornar muito grande) ou dividi-lo em pedaços (são necessários muitos arquivos pequenos, é necessário carregamento dinâmico) ou usar a abordagem atual para incorporar um script em cada um componente que é renderizado no lado do servidor (eu realmente não quero voltar a isso).  Na minha opinião, a primeira e a terceira opção não são uma opção.  Para o segundo, você precisa de um carregador de inicialização dinâmico, como no estêncil.  Mas para o elemento iluminado na "caixa" isso não é fornecido.  Houve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma tentativa</a> dos desenvolvedores de elementos iluminados de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">criar um carregador dinâmico</a> , mas é um experimento e não é recomendável usá-lo na produção.  Também dos desenvolvedores de elementos iluminados, há um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">problema</a> no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">repositório de especificações de componentes da Web</a> com uma proposta para adicionar à especificação a capacidade de carregar dinamicamente os js necessários para o componente da Web com base na marcação html na página.  E, na minha opinião, essa ferramenta nativa é uma ideia muito boa que permitirá criar um ponto de inicialização de componentes da Web e simplesmente adicioná-lo a todas as páginas do site. </p><br><p>  Para carregar dinamicamente componentes da Web de elementos iluminados dinamicamente com os caras do PolymerLabs, foi desenvolvido <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um elemento de divisão</a> .  Esta é uma solução experimental.  Funciona da seguinte maneira: </p><br><ul><li>  Para criar um SplitElement, você escreve duas definições de elementos em dois módulos. </li><li>  Um deles é um esboço, que define as partes carregadas de um elemento: geralmente esse é o nome e as propriedades.  As propriedades devem ser definidas com um stub para que o elemento lit possa gerar atributos observáveis ​​em tempo hábil para chamar <code>customElements.define()</code> . </li><li>  O stub também deve ter um método de carregamento assíncrono estático que retorna uma classe de implementação. </li><li>  Outra classe é a "implementação", que contém todo o resto. </li><li>  O construtor <code>SplitElement</code> carrega a classe de implementação e executa <code>upgrade()</code> . </li></ul><br><p>  Exemplo de stub: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {SplitElement, property} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../split-element.js'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SplitElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// MyElement    load   //      connectedCallback()   static async load() { //        //      MyElement return (await import('./my-element-impl.js')).MyElementImpl; } //      //   - @property() message: string; } customElements.define('my-element', MyElement);</span></span></code> </pre><br><p>  Exemplo de implementação: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {MyElement} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./my-element.js'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {html} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../split-element.js'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// MyElementImpl  render    - export class MyElementImpl extends MyElement { render() { return html` &lt;h1&gt;I've been upgraded&lt;/h1&gt; My message is ${this.message}. `; } }</span></span></code> </pre><br><p>  Exemplo de SplitElement no ES6: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {LitElement, html} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    LitElement  SplitElement //       export class SplitElement extends LitElement { static load; static _resolveLoaded; static _rejectLoaded; static _loadedPromise; static implClass; static loaded() { if (!this.hasOwnProperty('_loadedPromise')) { this._loadedPromise = new Promise((resolve, reject) =&gt; { this._resolveLoaded = resolve; this._rejectLoaded = reject; }); } return this._loadedPromise; } //      - //      static _upgrade(element, klass) { SplitElement._upgradingElement = element; Object.setPrototypeOf(element, klass.prototype); new klass(); SplitElement._upgradingElement = undefined; element.requestUpdate(); if (element.isConnected) { element.connectedCallback(); } } static _upgradingElement; constructor() { if (SplitElement._upgradingElement !== undefined) { return SplitElement._upgradingElement; } super(); const ctor = this.constructor; if (ctor.hasOwnProperty('implClass')) { //   ,   ctor._upgrade(this, ctor.implClass); } else { //    if (typeof ctor.load !== 'function') { throw new Error('A SplitElement must have a static `load` method'); } (async () =&gt; { ctor.implClass = await ctor.load(); ctor._upgrade(this, ctor.implClass); })(); } } //       render() { return html``; } }</span></span></code> </pre><br><p>  Se você ainda estiver usando a montagem sugerida acima no Rollup, certifique-se de definir o babel para poder manipular importações dinâmicas </p><br><pre> <code class="plaintext hljs">npm install @babel/plugin-syntax-dynamic-import</code> </pre> <br><p>  E nas configurações .babelrc adicione </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"plugins"</span></span>: [<span class="hljs-string"><span class="hljs-string">"@babel/plugin-syntax-dynamic-import"</span></span>] }</code> </pre><br><p>  Aqui fiz um pequeno exemplo da implementação de componentes da Web com carregamento atrasado: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/malay76a/elbrus-split-litelement-web-components</a> </p><br><p>  Tentei aplicar a abordagem de carregamento dinâmico de componentes da web, cheguei à seguinte conclusão: a ferramenta está funcionando bem, é necessário coletar todas as definições de componentes da web em um arquivo e conectar a descrição do próprio componente através de pedaços separadamente.  Sem o http2, essa abordagem não funciona, porque  Um conjunto muito grande de arquivos pequenos que descrevem os componentes é formado.  Com base no princípio do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">design atômico</a> , a importação de átomos deve ser determinada no corpo, mas o corpo já deve estar conectado como um componente separado.  Um dos gargalos é que o usuário receberá muitas definições de elementos do usuário no navegador que serão inicializadas de uma maneira ou de outra no navegador e o estado inicial será determinado.  Essa solução é redundante.  Uma das opções para uma solução simples para o carregador de componentes é o seguinte algoritmo: </p><br><ol><li>  carregar os utilitários necessários, </li><li>  carregar polyfills, </li><li>  montar elementos personalizados a partir do light DOM: <br><ol><li>  todos os elementos DOM que contêm um hífen no nome da tag são selecionados </li><li>  a lista é filtrada e é formada uma lista dos primeiros elementos. </li></ol></li><li>       : <br><ol><li>    Intersection Observer, </li><li>        +- 100px      import. </li></ol></li><li><ol><li>     3       shadowDOM, </li><li>  ,   shadowDOM  ,     ,  import   JS. </li></ol><br></li></ol><br><p>      -  lit-element        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">open-wc.org</a> .        webpack  rollup,    -      storybook,          IDE. </p><br><h2>  : </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Let's Build Web Components! Part 5: LitElement</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Web Component Essentials</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A night experimenting with Lit-HTML…</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LitElement To Do App</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LitElement app tutorial part 1: Getting started</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LitElement tutorial part 2: Templating, properties, and events</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LitElement tutorial part 3: State management with Redux</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LitElement tutorial part 4: Navigation and code splitting</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LitElement tutorial part 5: PWA and offline</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Lit-html workshop</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Awesome lit-html</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt445438/">https://habr.com/ru/post/pt445438/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt445426/index.html">Otimização para PostgreSQL servindo aplicação Rails</a></li>
<li><a href="../pt445428/index.html">Wi-Fi de alta qualidade - a base da hospitalidade moderna e o motor dos negócios</a></li>
<li><a href="../pt445432/index.html">Gerenciador de Pacotes Unity</a></li>
<li><a href="../pt445434/index.html">Melhor Pior Emprego do Mundo: Procurando um Habraautor</a></li>
<li><a href="../pt445436/index.html">Reciclagem no DevOps - para o que se preparar</a></li>
<li><a href="../pt445440/index.html">Revisão de código: dicas ruins para colaborador e revisor</a></li>
<li><a href="../pt445444/index.html">Atualização de módulos solares de alto desempenho da REC e Trina (Solar)</a></li>
<li><a href="../pt445446/index.html">Como usamos a replicação adiada para recuperação de desastres com o PostgreSQL</a></li>
<li><a href="../pt445448/index.html">Configurando o recebimento automático de certificados letsencrypt usando o docker no linux</a></li>
<li><a href="../pt445450/index.html">Extensão do navegador para toster.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>