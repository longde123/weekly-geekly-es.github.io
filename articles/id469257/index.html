<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶ã üèÇüèæ üïµüèº Kami mengintegrasikan perintah Linux di Windows menggunakan PowerShell dan WSL üë©üèª‚Äçüè≠ üå∂Ô∏è ü§æüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pertanyaan umum pengembang Windows: "Mengapa masih belum ada di sini < LINUX> ?". Apakah itu less gulir kuat atau alat grep atau sed biasa, pengembang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami mengintegrasikan perintah Linux di Windows menggunakan PowerShell dan WSL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469257/"> Pertanyaan umum pengembang Windows: "Mengapa masih belum ada di sini <code>&lt;    LINUX&gt;</code> ?".  Apakah itu <code>less</code> gulir kuat atau alat <code>grep</code> atau <code>sed</code> biasa, pengembang Windows ingin akses mudah ke perintah ini dalam pekerjaan sehari-hari. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Windows Subsystem untuk Linux (WSL)</a> telah mengambil langkah besar dalam hal ini.  Ini memungkinkan Anda untuk memanggil perintah Linux dari Windows, memeriksa mereka melalui <code>wsl.exe</code> (misalnya, <code>wsl ls</code> ).  Meskipun ini merupakan peningkatan yang signifikan, opsi ini menderita sejumlah kerugian. <br><a name="habracut"></a><br><ul><li>  Penambahan <code>wsl</code> di mana-mana melelahkan dan tidak wajar. <br></li><li>  Jalur Windows dalam argumen tidak selalu berfungsi, karena garis miring terbalik ditafsirkan sebagai karakter pelarian, bukan pemisah direktori. <br></li><li>  Jalur Windows dalam argumen tidak diterjemahkan ke titik pemasangan yang sesuai di WSL. <br></li><li>  Pengaturan default di profil WSL dengan alias dan variabel lingkungan tidak diperhitungkan. <br></li><li>  Penyelesaian jalur Linux tidak didukung. <br></li><li>  Penyelesaian perintah tidak didukung. <br></li><li>  Penyelesaian argumen tidak didukung. </li></ul><br>  Akibatnya, perintah Linux dianggap di bawah Windows sebagai warga negara kelas dua - dan mereka lebih sulit digunakan daripada tim asli.  Untuk menyamakan hak mereka, Anda harus menyelesaikan masalah ini. <br><br><h1>  Kerang PowerShell </h1><br>  Menggunakan pembungkus fungsi PowerShell, kita dapat menambahkan penyelesaian perintah dan menghilangkan kebutuhan untuk awalan <code>wsl</code> dengan menerjemahkan jalur Windows ke jalur WSL.  Persyaratan dasar untuk kerang: <br><br><ul><li>  Setiap perintah Linux harus memiliki satu shell fungsi dengan nama yang sama. <br></li><li>  Shell harus mengenali jalur Windows yang dilewati sebagai argumen dan mengubahnya menjadi jalur WSL. <br></li><li>  Shell harus memanggil <code>wsl</code> dengan perintah Linux yang sesuai untuk input pipa apa pun dan meneruskan argumen baris perintah yang diteruskan ke fungsi tersebut. </li></ul><br>  Karena templat ini dapat diterapkan pada perintah apa pun, kami dapat mengabstraksi definisi shell ini dan secara dinamis menghasilkannya dari daftar perintah yang akan diimpor. <br><br><pre> <code class="plaintext hljs"># The commands to import. $commands = "awk", "emacs", "grep", "head", "less", "ls", "man", "sed", "seq", "ssh", "tail", "vim" # Register a function for each command. $commands | ForEach-Object { Invoke-Expression @" Remove-Alias $_ -Force -ErrorAction Ignore function global:$_() { for (`$i = 0; `$i -lt `$args.Count; `$i++) { # If a path is absolute with a qualifier (eg C:), run it through wslpath to map it to the appropriate mount point. if (Split-Path `$args[`$i] -IsAbsolute -ErrorAction Ignore) { `$args[`$i] = Format-WslArgument (wsl.exe wslpath (`$args[`$i] -replace "\\", "/")) # If a path is relative, the current working directory will be translated to an appropriate mount point, so just format it. } elseif (Test-Path `$args[`$i] -ErrorAction Ignore) { `$args[`$i] = Format-WslArgument (`$args[`$i] -replace "\\", "/") } } if (`$input.MoveNext()) { `$input.Reset() `$input | wsl.exe $_ (`$args -split ' ') } else { wsl.exe $_ (`$args -split ' ') } } "@ }</code> </pre> <br>  Daftar <code>$command</code> mendefinisikan perintah untuk mengimpor.  Kemudian kami secara dinamis menghasilkan pembungkus fungsi untuk masing-masing dari mereka menggunakan perintah <code>Invoke-Expression</code> (pertama menghapus alias yang akan bertentangan dengan fungsi). <br><br>  Fungsi iterates atas argumen baris perintah, menentukan jalur Windows menggunakan perintah <code>Split-Path</code> dan <code>Test-Path</code> , dan kemudian mengubah jalur ini ke jalur WSL.  Kita menjalankan path melalui fungsi helper <code>Format-WslArgument</code> , yang akan kita definisikan nanti.  Itu lolos dari karakter khusus, seperti spasi dan tanda kurung, yang kalau tidak akan disalahartikan. <br><br>  Akhirnya, kami meneruskan input <code>wsl</code> dan argumen baris perintah apa pun ke <code>wsl</code> . <br><br>  Menggunakan pembungkus ini, Anda dapat memanggil perintah Linux favorit Anda dengan cara yang lebih alami tanpa menambahkan awalan <code>wsl</code> dan tanpa khawatir tentang bagaimana jalur dikonversi: <br><br><ul><li> <code>man bash</code> <br> </li><li> <code>less -i $profile.CurrentUserAllHosts</code> <br> </li><li> <code>ls -Al C:\Windows\ | less</code> <br> </li><li> <code>grep -Ein error *.log</code> <br> </li><li> <code>tail -f *.log</code> </li> </ul><br>  Set perintah dasar ditampilkan di sini, tetapi Anda dapat membuat shell untuk perintah Linux apa saja dengan hanya menambahkannya ke daftar.  Jika Anda menambahkan kode ini ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">profil</a> PowerShell Anda, perintah ini akan tersedia untuk Anda di setiap sesi PowerShell, seperti halnya perintah asli! <br><br><h1>  Opsi default </h1><br>  Di Linux, biasanya untuk mendefinisikan alias dan / atau variabel lingkungan di profil (profil login), mengatur parameter default untuk perintah yang sering digunakan (misalnya, <code>alias ls=ls -AFh</code> atau <code>export LESS=-i</code> ).  Salah satu kelemahan <code>wsl.exe</code> shell <code>wsl.exe</code> non-interaktif adalah bahwa profil tidak dimuat, oleh karena itu opsi ini tidak tersedia secara default (mis., <code>ls</code> di WSL dan <code>wsl ls</code> akan berperilaku berbeda dengan alias yang ditentukan di atas). <br><br>  PowerShell menyediakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">$ PSDefaultParameterValues</a> , mekanisme standar untuk mendefinisikan parameter default, tetapi hanya untuk cmdlet dan fungsi lanjutan.  Tentu saja, Anda dapat membuat fungsi-fungsi lanjutan dari shell kami, tetapi ini menimbulkan komplikasi yang tidak perlu (misalnya, PowerShell cocok dengan nama parameter parsial (misalnya, <code>-ArgumentList</code> dengan <code>-ArgumentList</code> ), yang akan bertentangan dengan perintah Linux yang menerima nama parsial sebagai argumen), dan sintaks untuk menentukan nilai-nilai default tidak akan menjadi yang paling cocok (untuk mendefinisikan argumen default, diperlukan nama parameter pada kunci, dan bukan hanya nama perintah). <br><br>  Namun, dengan sedikit modifikasi pada shell kami, kami dapat mengimplementasikan model yang mirip dengan <code>$PSDefaultParameterValues</code> dan mengaktifkan opsi default untuk perintah Linux! <br><br><pre> <code class="plaintext hljs">function global:$_() { ‚Ä¶ `$defaultArgs = ((`$WslDefaultParameterValues.$_ -split ' '), "")[`$WslDefaultParameterValues.Disabled -eq `$true] if (`$input.MoveNext()) { `$input.Reset() `$input | wsl.exe $_ `$defaultArgs (`$args -split ' ') } else { wsl.exe $_ `$defaultArgs (`$args -split ' ') } }</code> </pre> <br>  Dengan <code>$WslDefaultParameterValues</code> ke baris perintah, kami mengirim parameter melalui <code>wsl.exe</code> .  Berikut ini menunjukkan cara menambahkan instruksi ke profil PowerShell untuk mengonfigurasi pengaturan default.  Sekarang kita bisa melakukannya! <br><br><pre> <code class="plaintext hljs">$WslDefaultParameterValues["grep"] = "-E" $WslDefaultParameterValues["less"] = "-i" $WslDefaultParameterValues["ls"] = "-AFh --group-directories-first"</code> </pre> <br>  Karena parameter dimodelkan setelah <code>$PSDefaultParameterValues</code> , Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dengan mudah mematikannya</a> sementara dengan mengatur kunci <code>"Disabled"</code> menjadi <code>$true</code> .  Keuntungan tambahan dari tabel hash yang terpisah adalah kemampuan untuk menonaktifkan <code>$WslDefaultParameterValues</code> secara terpisah dari <code>$PSDefaultParameterValues</code> . <br><br><h1>  Penyelesaian Argumen </h1><br>  PowerShell memungkinkan mendaftarkan terminator argumen menggunakan perintah <code>Register-ArgumentCompleter</code> .  Bash memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alat penyelesaian yang</a> kuat dan dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diprogram</a> .  WSL memungkinkan Anda untuk memanggil bash dari PowerShell.  Jika kita dapat mendaftarkan terminator argumen untuk pembungkus fungsi PowerShell kita dan memanggil bash untuk membuat terminasi, maka kita mendapatkan penyelesaian penuh argumen dengan presisi yang sama seperti di bash itu sendiri! <br><br><pre> <code class="plaintext hljs"># Register an ArgumentCompleter that shims bash's programmable completion. Register-ArgumentCompleter -CommandName $commands -ScriptBlock { param($wordToComplete, $commandAst, $cursorPosition) # Map the command to the appropriate bash completion function. $F = switch ($commandAst.CommandElements[0].Value) { {$_ -in "awk", "grep", "head", "less", "ls", "sed", "seq", "tail"} { "_longopt" break } "man" { "_man" break } "ssh" { "_ssh" break } Default { "_minimal" break } } # Populate bash programmable completion variables. $COMP_LINE = "`"$commandAst`"" $COMP_WORDS = "('$($commandAst.CommandElements.Extent.Text -join "' '")')" -replace "''", "'" for ($i = 1; $i -lt $commandAst.CommandElements.Count; $i++) { $extent = $commandAst.CommandElements[$i].Extent if ($cursorPosition -lt $extent.EndColumnNumber) { # The cursor is in the middle of a word to complete. $previousWord = $commandAst.CommandElements[$i - 1].Extent.Text $COMP_CWORD = $i break } elseif ($cursorPosition -eq $extent.EndColumnNumber) { # The cursor is immediately after the current word. $previousWord = $extent.Text $COMP_CWORD = $i + 1 break } elseif ($cursorPosition -lt $extent.StartColumnNumber) { # The cursor is within whitespace between the previous and current words. $previousWord = $commandAst.CommandElements[$i - 1].Extent.Text $COMP_CWORD = $i break } elseif ($i -eq $commandAst.CommandElements.Count - 1 -and $cursorPosition -gt $extent.EndColumnNumber) { # The cursor is within whitespace at the end of the line. $previousWord = $extent.Text $COMP_CWORD = $i + 1 break } } # Repopulate bash programmable completion variables for scenarios like '/mnt/c/Program Files'/&lt;TAB&gt; where &lt;TAB&gt; should continue completing the quoted path. $currentExtent = $commandAst.CommandElements[$COMP_CWORD].Extent $previousExtent = $commandAst.CommandElements[$COMP_CWORD - 1].Extent if ($currentExtent.Text -like "/*" -and $currentExtent.StartColumnNumber -eq $previousExtent.EndColumnNumber) { $COMP_LINE = $COMP_LINE -replace "$($previousExtent.Text)$($currentExtent.Text)", $wordToComplete $COMP_WORDS = $COMP_WORDS -replace "$($previousExtent.Text) '$($currentExtent.Text)'", $wordToComplete $previousWord = $commandAst.CommandElements[$COMP_CWORD - 2].Extent.Text $COMP_CWORD -= 1 } # Build the command to pass to WSL. $command = $commandAst.CommandElements[0].Value $bashCompletion = ". /usr/share/bash-completion/bash_completion 2&gt; /dev/null" $commandCompletion = ". /usr/share/bash-completion/completions/$command 2&gt; /dev/null" $COMPINPUT = "COMP_LINE=$COMP_LINE; COMP_WORDS=$COMP_WORDS; COMP_CWORD=$COMP_CWORD; COMP_POINT=$cursorPosition" $COMPGEN = "bind `"set completion-ignore-case on`" 2&gt; /dev/null; $F `"$command`" `"$wordToComplete`" `"$previousWord`" 2&gt; /dev/null" $COMPREPLY = "IFS=`$'\n'; echo `"`${COMPREPLY[*]}`"" $commandLine = "$bashCompletion; $commandCompletion; $COMPINPUT; $COMPGEN; $COMPREPLY" -split ' ' # Invoke bash completion and return CompletionResults. $previousCompletionText = "" (wsl.exe $commandLine) -split '\n' | Sort-Object -Unique -CaseSensitive | ForEach-Object { if ($wordToComplete -match "(.*=).*") { $completionText = Format-WslArgument ($Matches[1] + $_) $true $listItemText = $_ } else { $completionText = Format-WslArgument $_ $true $listItemText = $completionText } if ($completionText -eq $previousCompletionText) { # Differentiate completions that differ only by case otherwise PowerShell will view them as duplicate. $listItemText += ' ' } $previousCompletionText = $completionText [System.Management.Automation.CompletionResult]::new($completionText, $listItemText, 'ParameterName', $completionText) } } # Helper function to escape characters in arguments passed to WSL that would otherwise be misinterpreted. function global:Format-WslArgument([string]$arg, [bool]$interactive) { if ($interactive -and $arg.Contains(" ")) { return "'$arg'" } else { return ($arg -replace " ", "\ ") -replace "([()|])", ('\$1', '`$1')[$interactive] } }</code> </pre> <br>  Kode ini sedikit ketat tanpa memahami beberapa bash internal, tetapi pada dasarnya kami melakukan hal berikut: <br><br><ul><li>  Kami mendaftarkan finalizer argumen untuk semua pembungkus fungsi kami dengan meneruskan daftar <code>$commands</code> ke parameter <code>-CommandName</code> untuk <code>Register-ArgumentCompleter</code> . <br></li><li>  Kami memetakan setiap perintah ke fungsi shell yang digunakan bash untuk pelengkapan otomatis (bash menggunakan <code>$F</code> untuk menentukan spesifikasi pelengkapan otomatis, singkatan dari <code>complete -F &lt;FUNCTION&gt;</code> ). <br></li><li>  Konversikan argumen PowerShell <code>$wordToComplete</code> , <code>$commandAst</code> dan <code>$cursorPosition</code> ke format yang diharapkan oleh fungsi penyelesaian bash sesuai dengan spesifikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyelesaian</a> bash yang dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diprogram</a> . <br></li><li>  Kami menyusun baris perintah untuk mentransfer ke <code>wsl.exe</code> , yang memastikan pengaturan lingkungan yang benar, memanggil fungsi pelengkapan otomatis yang sesuai dan menampilkan hasilnya dengan jeda baris. <br></li><li>  Kemudian kita memanggil <code>wsl</code> dengan baris perintah, memisahkan output dengan pemisah baris dan menghasilkan <code>CompletionResults</code> untuk masing-masing, mengurutkan mereka dan melarikan diri karakter seperti spasi dan tanda kurung yang seharusnya akan disalahartikan. </li></ul><br>  Akibatnya, shell perintah Linux kami akan menggunakan pelengkapan otomatis yang persis sama seperti di bash!  Sebagai contoh: <br><br><ul><li> <code>ssh -c &lt;TAB&gt; -J &lt;TAB&gt; -m &lt;TAB&gt; -O &lt;TAB&gt; -o &lt;TAB&gt; -Q &lt;TAB&gt; -w &lt;TAB&gt; -b &lt;TAB&gt;</code> </li> </ul><br>  Setiap pelengkapan otomatis memberikan nilai khusus untuk argumen sebelumnya, membaca data konfigurasi, seperti host yang dikenal, dari WSL! <br><br>  <code>&lt;TAB&gt;</code> akan menggilir parameter.  <code>&lt;Ctrl + &gt;</code> akan menampilkan semua opsi yang tersedia. <br><br>  Juga, karena bash autocomplete sekarang berfungsi dengan kami, Anda dapat autocomplete path Linux langsung di PowerShell! <br><br><ul><li> <code>less /etc/&lt;TAB&gt;</code> <br> </li><li> <code>ls /usr/share/&lt;TAB&gt;</code> <br> </li><li> <code>vim ~/.bash&lt;TAB&gt;</code> </li> </ul><br>  Dalam kasus di mana bash pelengkapan otomatis gagal, PowerShell kembali ke sistem default dengan jalur Windows.  Dengan demikian, dalam praktiknya, Anda dapat secara bersamaan menggunakan itu dan cara-cara lain sesuai kebijaksanaan Anda. <br><br><h1>  Kesimpulan </h1><br>  Dengan PowerShell dan WSL, kita dapat mengintegrasikan perintah Linux ke Windows sebagai aplikasi asli.  Tidak perlu mencari Win32 builds atau utilitas Linux atau mengganggu alur kerja dengan beralih ke shell Linux.  Cukup <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">instal WSL</a> , konfigurasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">profil PowerShell Anda</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">daftarkan perintah yang ingin Anda impor</a> !  Pelengkapan otomatis kaya untuk parameter perintah dan jalur untuk file Linux dan Windows adalah fungsi yang bahkan tidak ditemukan dalam perintah Windows asli hari ini. <br><br>  Kode sumber lengkap yang dijelaskan di atas, serta rekomendasi tambahan untuk memasukkannya dalam alur kerja tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Perintah Linux apa yang menurut Anda paling berguna?  Apa hal-hal akrab lainnya yang hilang saat bekerja di Windows?  Tulis di komentar atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di GitHub</a> ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id469257/">https://habr.com/ru/post/id469257/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id469235/index.html">Troldesh dalam topeng baru: gelombang distribusi massa berikutnya dari virus ransomware</a></li>
<li><a href="../id469237/index.html">Transformasi Kode Android</a></li>
<li><a href="../id469245/index.html">Solstice mengembangkan ide proyek kelompok untuk mendapatkan energi matahari dari atap rumah</a></li>
<li><a href="../id469249/index.html">Nitter, antarmuka alternatif untuk Twitter</a></li>
<li><a href="../id469253/index.html">Berapa biaya aplikasi untuk membangun</a></li>
<li><a href="../id469259/index.html">Perubahan iklim: kami menganalisis suhu di berbagai kota selama 100 tahun terakhir</a></li>
<li><a href="../id469263/index.html">Mengapa karma pada Habr√© baik?</a></li>
<li><a href="../id469265/index.html">Mengakses Akses Intel Neural Computer Stick melalui REST</a></li>
<li><a href="../id469267/index.html">Menangani panggilan sistem menggunakan LD_PRELOAD dengan satu titik masuk</a></li>
<li><a href="../id469271/index.html">Serialisasi dan Deserializing .NET Core vs Go Data</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>