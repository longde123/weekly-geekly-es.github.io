<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚱 👐 💇🏽 Kesalahpahaman untuk pengembang C # pemula. Mencoba menjawab pertanyaan standar 🥇 🧖🏿 🐍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini saya berkesempatan untuk mengobrol dengan sejumlah besar pengembang C # pemula. Banyak dari mereka yang tertarik dengan bahasa dan platf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kesalahpahaman untuk pengembang C # pemula. Mencoba menjawab pertanyaan standar</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463213/">  Baru-baru ini saya berkesempatan untuk mengobrol dengan sejumlah besar pengembang C # pemula.  Banyak dari mereka yang tertarik dengan bahasa dan platform, dan ini sangat keren.  Di antara junior hijau obskurantisme tersebar luas tentang hal-hal yang jelas (hanya membaca buku tentang ingatan).  Dan ini juga mendorong saya untuk membuat artikel ini.  Artikel ini terutama ditujukan untuk pengembang pemula, tapi saya pikir banyak fakta akan berguna untuk melatih para insinyur.  Yah, kesalahan yang paling jelas dan tidak menarik, tentu saja, dihilangkan.  Inilah yang paling menarik dan penting, terutama dari sudut pandang lulus wawancara. <br><br><div style="text-align:center;"><img width="300" src="https://habrastorage.org/webt/_q/a5/nc/_qa5ncp0f-7ydqssgacmzqevk30.png"></div><br><a name="habracut"></a><br><h3>  # 1  Mantra tentang 3 generasi dalam situasi apa pun </h3><br>  Ini lebih tidak akurat daripada kesalahan.  Pertanyaan tentang "pengumpul sampah di C #" untuk pengembang telah menjadi pertanyaan klasik dan sedikit orang akan mulai menjawab dengan cerdas tentang konsep generasi.  Namun, untuk beberapa alasan, beberapa orang memperhatikan fakta bahwa pengumpul sampah yang hebat dan mengerikan adalah bagian dari runtime.  Oleh karena itu, saya akan menjelaskan bahwa itu bukan jari, dan akan bertanya seperti apa lingkungan runtime yang terlibat.  Untuk kueri "pengumpul sampah di c #", lebih dari banyak informasi serupa dapat ditemukan di Internet.  Namun, beberapa orang menyebutkan bahwa informasi ini merujuk pada <i>CLR / CoreCLR</i> (sebagai aturan).  Tapi jangan lupa tentang Mono, runtime yang ringan, fleksibel, dan tertanam yang telah menempati ceruknya dalam pengembangan ponsel (Unity, Xamarin) dan digunakan di Blazor.  Dan untuk masing-masing pengembang, saya akan menyarankan Anda untuk menanyakan tentang detail perangkat perakitan di Mono.  Misalnya, atas permintaan "generasi pengumpul sampah mono", Anda dapat melihat bahwa hanya ada dua generasi - <b>pembibitan</b> dan <b>generasi tua</b> (dalam pengumpul sampah baru dan modis - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SGen</a> ). <br><br><h3>  # 2  Mantra tentang 2 tahap pengumpulan sampah dalam situasi apa pun </h3><br>  Belum lama berselang, sumber-sumber pengumpul sampah disembunyikan dari semua orang.  Namun, minat pada struktur internal platform selalu.  Karena itu, informasi diekstraksi dengan cara yang berbeda.  Dan beberapa ketidakakuratan dalam rekayasa balik kolektor menyebabkan mitos bahwa kolektor bekerja dalam 2 tahap: penandaan dan pembersihan.  Atau bahkan lebih buruk lagi, 3 tahap - menandai, membersihkan, kompresi. <br><br>  Namun, semuanya berubah <s>ketika orang-orang api melepaskan perang</s> dengan munculnya <i>CoreCLR</i> dan kode sumber untuk kolektor.  Kode kompiler untuk CoreCLR diambil seluruhnya dari versi CLR.  Tidak ada yang menulisnya dari awal, masing-masing, hampir semua yang dapat dipelajari dari kode sumber CoreCLR akan berlaku untuk CLR juga.  Sekarang, untuk memahami cara kerja sesuatu, buka saja github dan temukan di kode sumber atau baca <a href="">readme</a> .  Di sana Anda dapat melihat bahwa ada 5 fase: menandai, merencanakan, memperbarui tautan, memadatkan (penghapusan dengan relokasi) dan penghapusan tanpa relokasi (ini sulit untuk diterjemahkan).  Tetapi secara formal dapat dibagi menjadi 3 tahap - penandaan, perencanaan, pembersihan. <br><br>  Pada <b>tahap penandaan,</b> ternyata benda mana yang tidak boleh dikumpulkan oleh pengumpul. <br>  Pada <b>tahap perencanaan,</b> berbagai indikator dari kondisi memori saat ini dihitung dan data yang diperlukan pada tahap pembersihan dikumpulkan.  Berkat informasi yang diterima pada tahap ini, keputusan dibuat tentang perlunya pemadatan (defragmentasi), juga menghitung berapa banyak yang Anda butuhkan untuk memindahkan objek, dll. <br><br>  Dan pada <b>tahap pembersihan</b> , tergantung pada kebutuhan untuk pemadatan, tautan dapat diperbarui dan dipadatkan atau dihapus tanpa bergerak. <br><br><h3>  # 3  Mengalokasikan memori pada heap secepat di stack </h3><br>  Sekali lagi, ketidakakuratan dan bukannya ketidakbenaran mutlak.  Dalam kasus umum, tentu saja, perbedaan kecepatan alokasi memori minimal.  Memang, dalam kasus terbaik, dengan <i>alokasi bump pointer</i> , alokasi memori hanyalah pergeseran pointer, seperti pada stack.  Namun, faktor-faktor seperti menetapkan objek baru ke bidang lama (yang akan mempengaruhi <i>penghalang tulis</i> , memperbarui <i>tabel kartu</i> - mekanisme yang memungkinkan Anda untuk melacak tautan dari generasi yang lebih tua ke yang lebih muda), keberadaan finalizer (Anda harus menambahkan jenis ke antrian yang sesuai) dapat mempengaruhi alokasi memori pada tumpukan. dan lain-lain. Mungkin juga bahwa objek akan direkam di salah satu lubang bebas di tumpukan (setelah perakitan tanpa defragmentasi).  Dan menemukan lubang seperti itu, meskipun cepat, jelas lebih lambat daripada pergeseran pointer sederhana.  Yah, tentu saja, setiap objek yang dibuat membawa pengumpulan sampah berikutnya lebih dekat.  Dan dalam prosedur selanjutnya untuk mengalokasikan memori, itu bisa terjadi.  Yang, tentu saja, akan memakan waktu. <br><br><h3>  # 4  Definisi referensi, tipe dan kemasan yang bermakna melalui konsep tumpukan dan tumpukan </h3><br>  Klasik yang benar, yang, untungnya, tidak begitu umum. <br><br>  Jenis referensi terletak di heap.  Signifikan pada tumpukan.  Tentunya banyak yang sudah sering mendengar definisi ini.  Tapi ini tidak hanya kebenaran parsial, jadi mendefinisikan konsep melalui abstraksi yang bocor bukanlah ide yang baik.  Untuk semua definisi, saya sarankan Anda merujuk ke standar CLI - <b>ECMA 335</b> .  Pertama, perlu diklarifikasi bahwa tipe menggambarkan nilai.  Jadi, tipe referensi didefinisikan sebagai berikut - nilai yang dijelaskan oleh tipe referensi (tautan) menunjukkan <b>lokasi</b> nilai lain.  Untuk tipe yang signifikan, nilai yang dideskripsikan olehnya adalah otonom (mandiri).  Tentang di mana ini atau jenis kata-kata itu berada.  Ini adalah abstraksi yang bocor yang harus Anda ketahui. <br><br>  Jenis yang signifikan dapat ditemukan: <br><br><ol><li>  Dalam memori dinamis (tumpukan), jika itu adalah bagian dari objek yang terletak di tumpukan, atau dalam kasus kemasan; </li><li>  Pada stack, jika itu adalah variabel lokal / argumen / nilai pengembalian metode; </li><li>  Dalam register, jika memungkinkan ukuran tipe yang signifikan dan kondisi lainnya. </li></ol><br>  Jenis referensi, yaitu nilai yang menjadi titik tautan, saat ini berada di heap. <br><br>  Tautan itu sendiri dapat ditempatkan di tempat yang sama dengan tipe signifikan. <br><br>  Pengemasan juga tidak ditentukan melalui lokasi penyimpanan.  Pertimbangkan contoh singkat. <br><br><div class="spoiler">  <b class="spoiler_title">Kode C #</b> <div class="spoiler_text"><pre><code class="plaintext hljs">public struct MyStruct { public int justField; } public class MyClass { public MyStruct justStruct; } public static void Main() { MyClass instance = new MyClass(); object boxed = instance.justStruct; }</code> </pre> <br></div></div><br>  Dan kode IL yang sesuai untuk metode Utama <br><br><div class="spoiler">  <b class="spoiler_title">Kode IL</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> 1: nop 2: newobj instance void C/MyClass::.ctor() 3: stloc.0 4: ldloc.0 5: ldfld valuetype C/MyStruct C/MyClass::justStruct 6: box C/MyStruct 7: stloc.1 8: ret</code> </pre><br></div></div><br>  Karena tipe signifikan adalah bagian dari referensi, jelas bahwa itu akan ditempatkan di heap.  Dan baris keenam memperjelas bahwa kita berurusan dengan pengemasan.  Dengan demikian, definisi khas "menyalin dari tumpukan ke tumpukan" gagal. <br><br>  Untuk menentukan apa paket itu, sebagai permulaan, perlu dikatakan bahwa untuk setiap tipe signifikan, CTS (sistem tipe umum) mendefinisikan tipe referensi, yang disebut tipe paket.  Jadi, <b>pengemasan</b> adalah operasi pada tipe signifikan yang menciptakan nilai dari tipe paket yang sesuai yang mengandung salinan bitwise dari nilai asli. <br><br><h3>  # 4  Acara - mekanisme terpisah </h3><br>  Peristiwa ada dari versi pertama bahasa dan pertanyaan tentang mereka jauh lebih umum daripada peristiwa itu sendiri.  Namun, perlu dipahami dan mengetahui apa itu, karena mekanisme ini memungkinkan Anda untuk menulis kode yang sangat longgar, yang kadang-kadang berguna. <br><br>  Sayangnya, seringkali suatu peristiwa dipahami sebagai instrumen, jenis, mekanisme yang terpisah.  Ini terutama difasilitasi oleh tipe dari BCL <i>EventHandler</i> , yang namanya menunjukkan bahwa itu adalah sesuatu yang terpisah. <br><br>  Mendefinisikan suatu acara harus dimulai dengan mendefinisikan properti.  Saya telah lama menggambar analogi seperti itu untuk diri saya sendiri, dan baru-baru ini melihat bahwa analog itu diambil dalam spesifikasi CLI. <br><br>  Properti mendefinisikan nilai yang disebutkan dan metode yang mengaksesnya.  Itu terdengar sangat jelas.  Kami lolos ke acara.  CTS mendukung acara serta properti, TETAPI metode untuk akses berbeda dan termasuk metode untuk berlangganan dan berhenti berlangganan dari suatu acara.  Dari spesifikasi bahasa C #, kelas mendefinisikan acara ... yang mengingatkan pada deklarasi lapangan dengan penambahan kata kunci acara.  Jenis deklarasi ini haruslah tipe delegasi.  Berkat standar CLI untuk definisi. <br><br>  Jadi, ini berarti bahwa acara tersebut tidak lebih dari delegasi yang memaparkan hanya sebagian dari fungsi delegasi - menambahkan delegasi lain ke daftar untuk dieksekusi, menghapusnya dari daftar ini.  Di dalam kelas, acara ini tidak berbeda dengan bidang tipe delegasi sederhana. <br><br><h3>  # 5  Sumber daya yang dikelola dan tidak dikelola.  Finalizers dan IDisposable </h3><br>  Ada kebingungan mutlak ketika berhadapan dengan sumber daya ini.  Ini sebagian besar difasilitasi oleh Internet dengan seribu artikel tentang penerapan pola Buang yang benar.  Sebenarnya, tidak ada yang kriminal dalam pola ini - metode templat yang dimodifikasi untuk kasus tertentu.  Tetapi pertanyaannya adalah apakah itu diperlukan?  Untuk beberapa alasan, beberapa orang memiliki keinginan yang tak tertahankan untuk menerapkan finalizer untuk setiap bersin.  Kemungkinan besar, alasan untuk ini bukanlah pemahaman penuh tentang apa "sumber daya yang tidak dikelola" itu.  Dan garis-garis tentang fakta bahwa dalam finalizer, sebagai suatu peraturan, sumber daya yang tidak dikelola dilepaskan karena pemahaman yang tidak lengkap ini, melewati dan tidak tetap berada di kepala. <br><br>  <b>Sumber</b> daya yang tidak dikelola adalah sumber daya yang tidak dikelola (betapapun anehnya).  <b>Sumber daya yang dikelola</b> , pada gilirannya, adalah <b>sumber daya</b> yang dialokasikan dan dirilis oleh CLI secara otomatis melalui proses yang disebut pengumpulan sampah.  Saya dengan berani menghapus definisi ini dari standar CLI.  Tetapi jika Anda mencoba menjelaskan secara lebih sederhana, sumber daya yang tidak dikelola adalah sumber yang tidak diketahui oleh pemulung.  (Secara tegas, kami dapat memberi informasi kepada kolektor tentang sumber daya tersebut menggunakan GC.AddMemoryPressure dan GC.RemoveMemoryPressure, ini dapat memengaruhi penyetelan internal kolektor).  Karenanya, dia tidak akan dapat mengurus pembebasan mereka sendiri, dan oleh karena itu kita harus melakukannya untuknya.  Dan mungkin ada banyak pendekatan untuk ini.  Dan agar kode tidak menyilaukan dengan keragaman imajinasi pengembang, 2 pendekatan yang diterima secara umum digunakan. <br><br><ol><li>  Antarmuka IDisposable (dan versi asinkron dari IAsyncDisposable).  Itu dipantau oleh semua penganalisa kode, jadi sulit untuk melupakan panggilannya.  Menyediakan metode tunggal - Buang.  Dan dukungan kompiler adalah pernyataan using.  Calon yang sangat baik untuk badan metode Buang adalah memanggil metode serupa dari salah satu bidang di kelas atau untuk melepaskan sumber daya yang tidak dikelola.  Dipanggil secara eksplisit oleh pengguna kelas.  Kehadiran antarmuka ini di kelas menyiratkan bahwa setelah menyelesaikan pekerjaan dengan instance, Anda perlu memanggil metode ini. <br></li><li>  Finalizer  Pada intinya adalah asuransi.  Diminta secara implisit, pada waktu yang tidak ditentukan, selama pengumpulan sampah.  Memperlambat alokasi memori, pengumpul sampah, memperpanjang umur objek setidaknya sampai bangunan berikutnya, atau bahkan lebih lama, tetapi itu disebut dengan sendirinya, bahkan jika tidak ada yang memanggilnya.  Karena sifatnya yang non-deterministik, hanya sumber daya yang tidak dikelola yang harus dibebaskan di dalamnya.  Anda juga dapat menemukan contoh di mana finalizer digunakan untuk menghidupkan kembali objek dan mengatur kumpulan objek dengan cara ini.  Namun, implementasi kumpulan objek seperti itu jelas merupakan ide yang buruk.  Seperti mencoba masuk, melempar pengecualian, mengakses database dan ribuan tindakan serupa. <br></li></ol><br>  Dan Anda dapat dengan mudah membayangkan situasi ketika menulis perpustakaan penting untuk kinerja, yang secara internal menggunakan sumber daya yang tidak dikelola, yang dapat ditangani hanya dengan penanganan yang kompeten dari sumber daya ini, membebaskan memori dengan hati-hati secara manual.  Saat menulis perpustakaan berkinerja tinggi, OOP, dukungan, dan yang lainnya menyukainya, berjalan di pinggir jalan. <br><br>  Dan bertentangan dengan pernyataan bahwa Buang melanggar konsep di mana CLR akan melakukan segalanya untuk kita, memaksa kita untuk melakukan sesuatu sendiri, mengingat sesuatu, dll., Saya akan mengatakan yang berikut.  Ketika bekerja dengan sumber daya yang tidak dikelola, Anda harus siap bahwa mereka tidak dikelola oleh orang lain selain Anda.  Dan secara umum, situasi di mana sumber daya ini akan digunakan dalam perusahaan hampir tidak pernah ditemukan.  Dan dalam kebanyakan kasus, Anda bisa bertahan dengan kelas pembungkus yang indah, seperti SafeHandle, yang menyediakan finalisasi sumber daya yang kritis, mencegah perakitan prematur mereka. <br><br>  Jika, karena satu dan lain alasan, ada banyak sumber daya dalam aplikasi Anda yang memerlukan langkah tambahan untuk membebaskan, maka Anda harus melihat pada pola JetBrains yang sangat baik, Lifetime.  Tapi Anda tidak boleh menggunakannya saat Anda melihat objek IDisposable pertama. <br><br><h3>  # 6  Stream stack, stack panggilan, tumpukan komputasi dan <pre>  Stack &lt;T&gt; </pre></h3><br>  Paragraf terakhir menambahkan tawa demi itu, saya tidak berpikir bahwa ada orang yang menghubungkan yang terakhir dengan yang sebelumnya.  Namun, ada banyak kebingungan tentang apa aliran stack, tumpukan panggilan, dan tumpukan komputasi. <br><br>  <b>Tumpukan panggilan</b> adalah struktur data, yaitu tumpukan, untuk menyimpan alamat kembali, untuk kembali dari fungsi.  Tumpukan panggilan adalah konsep yang lebih logis.  Itu tidak mengatur di mana dan bagaimana informasi harus disimpan untuk dikembalikan.  Ternyata tumpukan panggilan adalah tumpukan yang paling umum dan asli yaitu.  Stack (lelucon).  Variabel lokal disimpan di dalamnya, parameter dilewatkan, dan alamat pengirim disimpan di dalamnya ketika instruksi CALL dan interupsi dipanggil, yang selanjutnya digunakan oleh instruksi RET untuk kembali dari fungsi / interupsi.  Silakan.  Salah satu lelucon utama aliran adalah pointer ke instruksi, yang dieksekusi lebih lanjut.  Sebuah utas pada gilirannya mengeksekusi instruksi yang menggabungkan fungsi.  Dengan demikian, setiap utas memiliki tumpukan panggilan.  Dengan demikian, ternyata tumpukan aliran adalah tumpukan panggilan.  Yaitu, tumpukan panggilan dari aliran ini.  Secara umum, ini juga disebut dengan nama lain: tumpukan perangkat lunak, tumpukan mesin. <br><br>  Itu dianggap secara rinci dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya</a> . <br>  Juga, definisi tumpukan panggilan digunakan untuk menunjukkan rantai panggilan metode tertentu dalam bahasa tertentu. <br><br>  <b>Tumpukan komputasi (tumpukan evaluasi)</b> .  Seperti yang Anda ketahui, kode C # dikompilasi menjadi kode IL, yang merupakan bagian dari DLL yang dihasilkan (dalam kasus paling umum).  Dan tepat di jantung runtime yang menyerap DLL kami dan mengeksekusi kode IL adalah mesin stack.  Hampir semua instruksi IL beroperasi dengan tumpukan tertentu.  Sebagai contoh, <i>ldloc</i> memuat variabel lokal di bawah indeks spesifik ke stack.  Di sini, tumpukan mengacu pada tumpukan virtual tertentu, karena pada akhirnya variabel ini dapat dengan probabilitas tinggi berada dalam register.  Aritmatika, logis, dan instruksi IL lainnya beroperasi pada variabel dari stack dan meletakkan hasilnya di sana.  Artinya, perhitungan dilakukan melalui tumpukan ini.  Jadi, ternyata tumpukan komputasi adalah abstraksi dalam runtime.  Omong-omong, banyak mesin virtual berbasis stack. <br><br><h3>  # 7  Lebih banyak utas - kode lebih cepat </h3><br>  Tampaknya secara intuitif bahwa pemrosesan data secara paralel akan lebih cepat daripada secara bergantian.  Oleh karena itu, dipersenjatai dengan pengetahuan tentang bekerja dengan utas, banyak yang mencoba untuk memparalelkan setiap siklus dan perhitungan.  Hampir semua orang sudah tahu tentang overhead, yang berkontribusi pada pembuatan utas, sehingga mereka menggunakan utas dari <i>ThreadPool</i> dan <i>Tugas</i> terkenal.  Tetapi overhead menciptakan aliran jauh dari akhir.  Di sini kita berhadapan dengan abstraksi lain yang bocor, mekanisme yang digunakan prosesor untuk meningkatkan kinerja - cache.  Dan seperti yang sering terjadi, cache adalah blade bermata dua.  Di satu sisi, itu secara signifikan mempercepat pekerjaan dengan akses berurutan ke data dari satu aliran.  Tetapi di sisi lain, ketika beberapa utas bekerja, bahkan tanpa perlu menyinkronkannya, cache tidak hanya tidak membantu, tetapi juga memperlambat kerja.  Waktu tambahan dihabiskan untuk pembatalan cache, mis.  memelihara data yang relevan.  Dan jangan meremehkan masalah ini, yang awalnya tampak seperti hal sepele.  Algoritma cache-efisien akan mengeksekusi satu thread lebih cepat daripada algoritma multi-threaded, di mana cache digunakan secara tidak efisien. <br><br>  Juga mencoba bekerja dengan drive dari banyak utas adalah bunuh diri.  Disk sudah menjadi faktor penghambat dalam banyak program yang bekerja dengannya.  Jika Anda mencoba mengatasinya dari banyak utas, maka Anda harus melupakan kecepatan. <br><br>  Untuk semua definisi, saya sarankan menghubungi di sini: <br><br>  Spesifikasi Bahasa C # - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ECMA-334</a> <br>  Sumber yang bagus: <br>  Konrad Kokosa - Manajemen Memori NET. Pro <br>  Spesifikasi CLI - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ECMA-335</a> <br>  Pengembang CoreCLR tentang runtime - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Book Of The Runtime</a> <br>  Dari Stanislav Sidristy tentang finalisasi dan lainnya - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">.NET Platform Architecture</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463213/">https://habr.com/ru/post/id463213/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463195/index.html">Apa yang terjadi dengan Internet Tele2</a></li>
<li><a href="../id463197/index.html">Blazor + MVVM = Silverlight menyerang balik karena kejahatan kuno tidak terkalahkan</a></li>
<li><a href="../id463203/index.html">Beban waktu yang berat. Yandex melaporkan kesalahan umum dalam bekerja dengan waktu</a></li>
<li><a href="../id463205/index.html">Awalnya tidak dapat dioperasikan: cara bertahan dengan laptop di Windows 10 dan drive 32-gigabyte</a></li>
<li><a href="../id463207/index.html">Pengembangan chatbot (telegram + youtube)</a></li>
<li><a href="../id463215/index.html">Para insinyur dan arsitek sudah merancang permukiman bulan</a></li>
<li><a href="../id463221/index.html">Watching the Sun: 5 jenis gadget, dari $ 5 hingga $ 5.000</a></li>
<li><a href="../id463229/index.html">Jetpacks in Culture: Cinema</a></li>
<li><a href="../id463231/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 14. VTP, Pemangkasan, dan VLAN Asli</a></li>
<li><a href="../id463233/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 15. Komunikasi Lambat dan Keamanan Pelabuhan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>