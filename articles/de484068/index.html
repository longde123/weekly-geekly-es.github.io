<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíõ ü¶ê üåπ gRPC als dienst√ºbergreifendes Kommunikationsprotokoll. Yandex-Bericht üöé üíÉüèø üë®üèº‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="gRPC ist ein Open Source Framework f√ºr Remote Procedure Calls. In Yandex.Market wird gRPC als bequemere Alternative zu REST verwendet. Sergey Fedoseen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>gRPC als dienst√ºbergreifendes Kommunikationsprotokoll. Yandex-Bericht</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/484068/"> gRPC ist ein Open Source Framework f√ºr Remote Procedure Calls.  In Yandex.Market wird gRPC als bequemere Alternative zu REST verwendet.  Sergey Fedoseenkov, der den Tool-Entwicklungsdienst f√ºr Market-Partner leitet, teilte seine Erfahrungen mit der Verwendung von gRPC als Protokoll f√ºr die Erstellung von Integrationen zwischen Java- und C ++ - Diensten.  In diesem Bericht erfahren Sie, wie Sie h√§ufige Probleme vermeiden, wenn Sie mit der Verwendung von gRPC nach REST beginnen, wie Sie Fehler zur√ºckgeben, die Ablaufverfolgung implementieren, Abfragen debuggen und Clientaufrufe testen.  <a href="https://habr.com/ru/company/yandex/blog/484068">Am Ende</a> gibt es eine inoffizielle Aufzeichnung des Berichts. <br><br>  - Zun√§chst m√∂chte ich Ihnen einige Fakten zu Yandex.Market vorstellen, die als Teil des Berichts n√ºtzlich sein werden.  Erste Tatsache: Wir schreiben Dienstleistungen in verschiedenen Sprachen.  Dies stellt Kundenanforderungen an Dienstleistungen. <br><a name="habracut"></a><br>  Und wenn wir einen Service in Java haben, w√§re es sch√∂n, wenn der Client daf√ºr zum Beispiel auch ein Plus oder ein kleines w√§re. <br><br><img src="https://habrastorage.org/webt/fk/km/ek/fkkmekzj1zv6uobtlxcypvjb5bq.jpeg"><br><br>  Alle Dienste, die wir haben, sind unabh√§ngig, es gibt keine geplanten gro√üen Releases des gesamten Marktes.  Microservices werden eigenst√§ndig freigegeben, und Abw√§rtskompatibilit√§t ist uns hier wichtig, damit das Protokoll dies unterst√ºtzt. <br><br>  Die dritte Tatsache: Wir haben sowohl synchrone als auch asynchrone Integration.  In dem Bericht werde ich haupts√§chlich √ºber Synchron sprechen. <br><br>  Was haben wir benutzt?  Die Basis unserer Integrationen sind jetzt nat√ºrlich REST oder REST-√§hnliche Services, die XML / JSON √ºber HTTP 1.1 austauschen.  Es gibt auch XML-RPC - wir verwenden es haupts√§chlich bei der Integration in Python-Code, dh Python verf√ºgt √ºber einen integrierten XML-RPC-Server.  Es ist praktisch genug, um es dort bereitzustellen, und wir unterst√ºtzen es. <br><br>  Wir hatten einmal CORBA.  Zum Gl√ºck haben wir es aufgegeben.  Jetzt meistens REST und XML / JSON √ºber HTTP. <br><br><img src="https://habrastorage.org/webt/mw/we/q6/mwweq653dwqkzn9afcvtqt3temm.jpeg"><br><br>  Synchrone Integrationen haben Probleme mit vorhandenen Protokollen.  Wir sto√üen auf solche Probleme und versuchen, sie mit gRPC zu behandeln.  Was sind diese Probleme?  Wie gesagt, ich m√∂chte Kunden in verschiedenen Sprachen haben.  Es ist ratsam, dass sie immer noch nicht von uns selbst geschrieben werden m√ºssen.  Und im Allgemeinen w√§re es cool, wenn der Client sowohl synchron als auch asynchron sein k√∂nnte - abh√§ngig von den Zielen des Benutzers des Dienstes. <br><br>  Ich m√∂chte auch das Protokoll, das wir verwenden, um die Abw√§rtskompatibilit√§t gut genug zu unterst√ºtzen: Dies ist bei parallelen unabh√§ngigen Releases sehr wichtig.  Alle unsere Releases sind abw√§rtskompatibel, wir brechen das Feedback nicht.  Wenn Sie es kaputt gemacht haben, ist dies ein Fehler und Sie m√ºssen es nur so schnell wie m√∂glich beheben. <br><br>  Ein koh√§renter Ansatz f√ºr die Fehlerbehandlung ist ebenfalls erforderlich: Jeder, der REST-Services bereitgestellt hat, wei√ü, dass Sie nicht nur den HTTP-Status verwenden k√∂nnen.  Sie erlauben in der Regel keine detaillierte Beschreibung des Problems, Sie m√ºssen einige ihrer Status, ihre Details eingeben.  In REST-Services f√ºhrt jeder seine eigene Implementierung dieser Fehler ein, jedes Mal, wenn Sie anders damit arbeiten m√ºssen.  Dies ist nicht immer bequem. <br><br>  Ich h√§tte auch gerne ein Timeout-Management auf der Client-Seite.  Auch hier haben diejenigen, die mit HTTP arbeiten, Verst√§ndnis daf√ºr, dass der Client nicht mehr auf den Abschluss der Anforderung wartet, wenn auf der Clientseite eine Zeit√ºberschreitung festgelegt wird und diese abl√§uft, der Server jedoch nichts dar√ºber wei√ü und die Ausf√ºhrung fortsetzt.  Dar√ºber hinaus gibt es in der Mitte verschiedene Proxys, die globale Timeouts festlegen.  Und der Client kann einfach nichts √ºber sie wissen und konfigurieren ist nicht immer trivial. <br><br>  Und schlie√ülich das Problem der Dokumentation.  Es ist nicht immer klar, woher die Dokumentation f√ºr REST-Ressourcen oder f√ºr bestimmte Methoden stammt, welche Parameter sie akzeptieren, welche Stelle √ºbertragen werden kann und wie diese Dokumentation mit den Verbrauchern des Dienstes kommuniziert wird.  Es ist klar, dass es Swagger gibt, aber auch damit ist nicht alles trivial. <br><br><h3>  gRPC  Theorie </h3><br>  Ich m√∂chte √ºber den theoretischen Teil von gRPC sprechen - was ist das, was sind die Ideen.  Und dann werden wir weiter √ºben. <br><br><img src="https://habrastorage.org/webt/4t/ly/cn/4tlycnzym8eeecxp8_-j2fwedwe.jpeg"><br><br>  Im Allgemeinen ist gRPC eine abstrakte Spezifikation.  Es beschreibt einen abstrakten RPC (Remote Procedure Call), dh einen Remote Procedure Call mit bestimmten Eigenschaften.  Jetzt werden wir sie auflisten.  Die erste Eigenschaft ist die Unterst√ºtzung von Einzelanrufen und Streaming.  Das hei√üt, alle Dienste, die diese Spezifikation implementieren, unterst√ºtzen beide Optionen.  Das n√§chste Element ist die Verf√ºgbarkeit von Metadaten, dh, dass Sie zusammen mit der Nutzlast eine Art von Metadaten √ºbergeben k√∂nnen - bedingt Header.  Und - Unterst√ºtzung f√ºr die Stornierung einer Anfrage und Timeouts aus der Box. <br><br>  Es wird auch davon ausgegangen, dass die Beschreibung der Nachrichten und der Dienste selbst √ºber eine bestimmte Schnittstellendefinitionssprache oder IDL erfolgt.  Die Spezifikation beschreibt auch das Wire-Protokoll √ºber HTTP / 2, dh, gRPC geht davon aus, dass es nur √ºber HTTP / 2 funktioniert. <br><br><img src="https://habrastorage.org/webt/e0/s9/5n/e0s95ncgptmoczazqnei0yns3b4.jpeg"><br><br>  In den meisten F√§llen wird eine typische gRPC-Implementierung verwendet.  Wir benutzen es auch, und jetzt werden wir es sehen.  Das Protoformat wird als IDL verwendet.  Mit dem gRPC-Plugin f√ºr den Protocompiler k√∂nnen Sie die Quellen der generierten Dienste aus der Protobeschreibung abrufen.  Und es gibt Laufzeitbibliotheken in verschiedenen Sprachen - Java, C ++, Python.  Im Allgemeinen werden fast alle g√§ngigen Sprachen unterst√ºtzt, f√ºr die Laufzeitbibliotheken existieren.  Und als Nachrichten, die zwischen Diensten ausgetauscht werden, wird eine Protonachricht verwendet, stilisierte Nachrichten gem√§√ü dem Protobuf-Schema. <br><br><img src="https://habrastorage.org/webt/wy/zp/bh/wyzpbhu3uhozqntsux32nyvpejw.jpeg"><br><br>  Ich m√∂chte ein wenig auf einige Besonderheiten eingehen.  Hier sind sie.  Starke Typisierung, dh eine Protonachricht, ist eine stark typisierte Nachricht.  Diejenigen, die einmal mit protobuf gearbeitet haben, wissen, dass Sie dort Felder in Ihrer Nachricht mit Typen beschreiben k√∂nnen.  Typen bestehen sowohl aus primitiven als auch aus String-Byte-Arrays.  Sie k√∂nnen skalar sein, k√∂nnen Vektor sein.  Tats√§chlich k√∂nnen Nachrichten als ein Feld andere Nachrichten enthalten, was sehr praktisch ist, im Allgemeinen kann jedes Modell dargestellt werden. <br><br><img src="https://habrastorage.org/webt/29/oz/e6/29oze6gv_s9vazqemxztvqyrrbs.jpeg"><br><br>  Informationen zur Abw√§rtskompatibilit√§t  Ich m√∂chte darauf hinweisen, dass Proto IDL ein Format ist, in dem die Abw√§rtskompatibilit√§t standardm√§√üig eingerichtet ist, dh es wurde mit einem R√ºckstand an Abw√§rtskompatibilit√§t konzipiert, und Google hat eine Version von Proto3 ver√∂ffentlicht, die im Vergleich zu Proto2 die Abw√§rtskompatibilit√§t weiter verbessert.  Dar√ºber hinaus gibt es eine Vielzahl von Spezifikationen, wie und was ge√§ndert werden kann, damit die Abw√§rtskompatibilit√§t in einigen nicht trivialen F√§llen erhalten bleibt. <br><br>  Es gibt die M√∂glichkeit von Standardwerten, Sie k√∂nnen neue Felder hinzuf√ºgen und der Verbraucher muss tats√§chlich nichts √§ndern.  Alle Felder in proto3 sind optional und k√∂nnen beispielsweise gel√∂scht werden, und der Zugriff auf das entfernte Feld verursacht keine Fehler auf dem Client. <br><br><img src="https://habrastorage.org/webt/dl/ws/kh/dlwskhpcodspqbqkwe-q1ihxaas.jpeg"><br><br>  Eine weitere gRPC-Funktion besteht darin, dass der Client und der Server mithilfe des Protocompilers und des gRPC-Plugins basierend auf der Protobeschreibung generiert werden.  Es besteht die M√∂glichkeit, zu dem Zeitpunkt, an dem der Code geschrieben wird, auszuw√§hlen, welcher Client verwendet wird.  W√§hlen Sie also einen asynchronen oder synchronen Client, je nachdem, welchen Code Sie schreiben.  Ein asynchroner Client eignet sich beispielsweise sehr gut f√ºr reaktiven Code.  Und diese Gelegenheit ist f√ºr jede Sprache.  Das hei√üt, sobald Sie eine Protobeschreibung geschrieben haben, k√∂nnen Sie einen Client f√ºr jede Sprache generieren, und Sie m√ºssen sie nicht mehr separat entwickeln.  Sie k√∂nnen die Schnittstelle f√ºr Ihren Dienst einfach als Protobeschreibung verteilen.  Jeder Verbraucher kann einen Kunden f√ºr sich selbst generieren. <br><br><img src="https://habrastorage.org/webt/ny/at/qr/nyatqr7l4jcnnxrzwudubg0u_wc.jpeg"><br><br>  √úber die Stornierung der Anfrage und Fristen m√∂chte ich darauf hinweisen, dass die Anfrage auf dem Server und auf dem Client storniert werden kann.  Wenn wir das alles verstehen, m√ºssen wir die Anfrage nicht weiter bearbeiten, dann k√∂nnen wir sie stornieren.  Auf Anfrage kann ein Timeout eingestellt werden.  In gRPC verwenden die meisten Laufzeitbibliotheken eine Frist als Zeitlimitbegriff.  Tats√§chlich ist es aber dasselbe.  Dies ist die Zeit, zu der die Anforderung abgeschlossen werden sollte. <br><br>  Und das Interessanteste ist, dass der Server sowohl √ºber das Abbrechen der Anforderung als auch √ºber das Ablaufen des Timeouts informiert werden kann und die Ausf√ºhrung der Anforderung auf seiner Seite beendet.  Das ist sehr cool, es scheint mir, dass es nirgendwo anders viel gibt. <br><br>  In Bezug auf die Dokumentation wollte ich festhalten, dass dies regul√§rer Code ist, da das Protoformat in der IDL f√ºr gRPC verwendet wird.  Dort k√∂nnen Sie Kommentare schreiben, auch sehr ausf√ºhrliche.  Und Sie m√ºssen verstehen, dass Ihre Benutzer, um sich in Ihren Service integrieren zu k√∂nnen, dieses Protoformat bei sich zu Hause haben m√ºssen. Es wird ihnen zusammen mit Kommentaren angezeigt und sie werden nicht woanders liegen.  Es ist sehr bequem.  Und Sie k√∂nnen diese Beschreibung erweitern, das hei√üt, sie ist so praktisch, dass die Dokumentation neben dem Code steht, √§hnlich wie sie neben den Methoden in Form von Javadoc oder anderen Kommentaren stehen kann. <br><br><h3>  gRPC unary call.  √úbe </h3><br>  Gehen wir weiter, schauen wir uns ein wenig √úbung an.  Das grundlegendste Beispiel f√ºr die Verwendung von gRPC ist der sogenannte un√§re Anruf oder Einzelanruf.  Dies ist ein klassisches Schema. Wir senden eine Anfrage an den Server und erhalten eine Antwort vom Server.  Es sieht so aus, als ob dies in HTTP funktioniert. <br><br><img src="https://habrastorage.org/webt/dd/lh/kd/ddlhkdqueihh4_s65obi4t9qxns.jpeg"><br><br>  Betrachten Sie das Beispiel des Echo-Dienstes, den wir ausf√ºhren.  Der Server wird in Plus geschrieben, der Client in Java.  Hier wurde die klassische Ausgleichsschaltung verwendet.  Das hei√üt, der Client wendet sich an den Balancer. Anschlie√üend w√§hlt der Balancer bereits ein bestimmtes Backend f√ºr die Verarbeitung der Anforderung aus. <br><br>  Ich wollte aufpassen - da gRPC √ºber HTTP / 2 funktioniert, wird eine TCP-Verbindung verwendet.  Und weiter gehen verschiedene Str√∂me durch.  Hier k√∂nnen Sie sehen, dass die Verbindung zwischen dem Client und dem Balancer einmal hergestellt wird und dauerhaft besteht. Anschlie√üend verteilt der Balancer die Last f√ºr jeden Aufruf auf verschiedene Backends.  Wenn Sie schauen, passiert es so und so, wenn die Nachrichten verteilt werden. <br><br><img src="https://habrastorage.org/webt/yc/tn/fe/yctnfe9-06tb1-en3lvbxlmqbsu.jpeg"><br><br>  Hier ist ein Beispielcode f√ºr unsere Protodatei.  Sie k√∂nnen feststellen, dass wir zuerst die Nachricht beschreiben, das hei√üt, wir haben EchoRequest und EchoResponse.  Es gibt nur ein Zeichenfolgenfeld, in dem die Nachricht gespeichert wird. <br><br>  Im zweiten Schritt beschreiben wir unser Vorgehen.  Die Eingabeprozedur akzeptiert EchoRequest, gibt EchoResponse als Ergebnis zur√ºck, alles ist ziemlich trivial.  Dies ist die Beschreibung des gRPC-Dienstes und der Nachrichten, die verfolgt werden. <br><br><br><img src="https://habrastorage.org/webt/yo/ti/mi/yotimiyugzrzit8vy2xdfn-yely.jpeg"><br><br>  Mal sehen, wie das zum Beispiel bei Pluspunkten l√§uft.  Der Zusammenbau erfolgt in drei Schritten.  In der ersten Phase besteht unsere Aufgabe darin, Nachrichtenquellen zu generieren.  Hier machen wir das mit diesem Team.  Wir rufen den Proto-Compiler auf, √ºbergeben die Proto-Datei an die Eingabe und geben an, wo die Ausgabedateien abgelegt werden sollen. <br><br>  Die zweite Mannschaft.  Auf die gleiche Weise generieren wir auch Dienstleistungen.  Der einzige Unterschied zum vorherigen Befehl besteht darin, dass wir das Plugin √ºbergeben und basierend auf der Beschreibung, die im Protoformat vorliegt, Dienste generieren. <br><br>  Der dritte Schritt - wir sammeln all dies in einem Binar, damit unser Server gestartet werden kann. <br><br>  Ein zus√§tzliches Flag wird an den Linker √ºbergeben und hei√üt grpc ++ _ reflection.  Ich m√∂chte darauf hinweisen, dass der gRPC-Server √ºber eine solche Funktion verf√ºgt, die Serverreflexion.  Hier k√∂nnen Sie herausfinden, welche Art von Diensten, RPC-Aufrufen und Nachrichten der Dienst hat.  Standardm√§√üig ist es deaktiviert, und Sie k√∂nnen nur dann auf den Dienst zugreifen, wenn Sie √ºber ein Protoformat verf√ºgen.  Zum Debuggen ist es beispielsweise sehr praktisch, ohne das vorhandene Protoformat den Server mit der Reflektionsfunktion einzuschalten und sofort Informationen zu erhalten. <br><br><br><img src="https://habrastorage.org/webt/yl/h-/fw/ylh-fw1j3sykaipf5_4c3zvvhgi.jpeg"><br><br>  Betrachten wir nun die Implementierung.  Die Implementierung ist ebenfalls minimalistisch.  Das hei√üt, unsere Hauptaufgabe ist es, den erzeugten Echo-Dienst zu implementieren.  Es gibt eine getEcho-Methode.  Es werden nur Nachrichten generiert und zur√ºckgesendet.  Status OK - Erfolgsstatus. <br><br>  Als n√§chstes erstellen wir ServerBuilder, registrieren unseren Service darin, den wir etwas h√∂her gebaut haben. <br><br><br><img src="https://habrastorage.org/webt/u8/6l/yz/u86lyzlselt_gi1khgl7l5umzw8.jpeg"><br><br>  Jetzt fangen wir einfach an und warten auf eingehende Anfragen. <br><br><br><img src="https://habrastorage.org/webt/bd/v9/bl/bdv9blqsyc3gbw-atarolnny0ha.jpeg"><br><br><br>  Nun sehen wir uns den Client in Java an.  Wir sammeln gradle.  Unsere Aufgabe ist es, zuerst das protobuf-Plugin zu verbinden. <br><br>  Es gibt eine Reihe grundlegender Abh√§ngigkeiten, die wir f√ºr unseren Service ziehen m√ºssen. Sie werden in der Kompilierungsphase ben√∂tigt. <br><br>  Ich m√∂chte auch erw√§hnen, dass es eine Laufzeitbibliothek gibt.  F√ºr Java wird netty als Server und Client verwendet, es unterst√ºtzt HTTP / 2, es ist sehr praktisch und leistungsstark. <br><br>  Als n√§chstes konfigurieren wir den Protocompiler.  Der Compiler selbst muss nicht lokal f√ºr Java installiert werden, sondern kann aus Artefakten entnommen werden. <br><br>  Gleiches gilt f√ºr Plugins.  F√ºr Java ist dies lokal nicht erforderlich.  Sie k√∂nnen ein Artefakt ziehen.  Und es ist wichtig, es einfach so zu konfigurieren, dass es f√ºr alle Shuffles auch aufgerufen wird, sodass Stubs generiert werden. <br><br><br><img src="https://habrastorage.org/webt/iu/n7/v6/iun7v66-lubn0f1qrwb1napvw6s.jpeg"><br><br><br>  Kommen wir zum Java-Code.  Hier sind wir die Ersten, die den Stub unseres Dienstes erstellen.  Das ist unsere Aufgabe f√ºr Java, Channel bereitzustellen.  Es gibt einen ChannelBuilder in der Laufzeitbibliothek, mit dem wir diesen Channel erstellen k√∂nnen.  Hier haben wir der Einfachheit halber den einfachen Text manuell aktiviert, aber HTTP2 und gRPC verschl√ºsseln standardm√§√üig alles und verwenden TLS. <br><br>  Wir haben einen Stub unseres Clients, hier wird ein synchroner Client generiert.  Auf die gleiche Weise k√∂nnen Sie einen asynchronen Client generieren, es gibt andere Optionen. <br><br>  Als n√§chstes erstellen wir unsere Protobuff-Anfrage, das hei√üt, wir konstruieren eine Protobuff-Nachricht. <br><br><br><img src="https://habrastorage.org/webt/kn/qo/1u/knqo1uengqboh-vagqyfyipqvrs.jpeg"><br><br><br>  Das ist alles, senden Sie es, auf unserem Client rufen wir getEcho auf und drucken das Ergebnis aus.  Alles ist einfach.  Wie Sie sehen, wird eine Menge Code ben√∂tigt, und die Integration wird erstellt. <br><br><h3>  gRPC-Streaming.  √úbe </h3><br>  Schauen wir uns jetzt eine etwas fortgeschrittenere Sache an, das ist Streaming.  Ich werde Ihnen erkl√§ren, wie es funktioniert, und sp√§ter werde ich Ihnen erkl√§ren, wie Sie es verwenden. <br><br><img src="https://habrastorage.org/webt/ly/pu/15/lypu157vtebmx4q8sw11d70gemo.jpeg"><br><br>  Der Streaming-Client-Server sieht architektonisch ungef√§hr gleich aus.  Das hei√üt, wir haben eine best√§ndige Verbindung zwischen dem Client und dem Balancer.  Dann beginnen die Differenzen.  Das Wesentliche beim Streaming ist, dass der Client an ein endg√ºltiges Backend angeschlossen ist und die Verbindung √ºber gespeichert wird.  Das hei√üt, es geht so weiter.  Und so.  An dieser Stelle m√∂chte ich gesondert darauf hinweisen, dass die Verwendung eines Balancers f√ºr das Streaming nicht typisch ist. Sie m√ºssen also verstehen, dass Streaming-Anforderungen sehr langlebig sein k√∂nnen.  Das hei√üt, Sie k√∂nnen sie f√ºr eine lange Zeit √∂ffnen und Nachrichten austauschen.  Und diese Nachrichten werden durch den Balancer geleitet, gehen aber in der Tat immer zum gleichen Backend.  Und es ist nicht ganz klar, warum es √ºberhaupt gebraucht wird. <br><br>  Eine g√§ngige Praxis besteht darin, dass die Dienstermittlung verwendet wird, wenn ein Dienst beispielsweise nur Streaming oder haupts√§chlich Streaming ist.  GRPC verf√ºgt √ºber einen Erweiterungspunkt, an dem die Serviceerkennung eingebettet werden kann. <br><br><img src="https://habrastorage.org/webt/dm/5f/lq/dm5flqilbfrmpdwlz-xi-0dn9nw.jpeg"><br><br>  Was brauchen wir, um Streaming-Dienste zu implementieren?  Wir haben das gleiche Protoformat.  Wir f√ºgen einen weiteren RPC hinzu. Hier k√∂nnen Sie feststellen, dass wir vor der Anforderung und vor der Antwort zwei Schl√ºsselw√∂rter hinzugef√ºgt haben.  Daher deklarieren wir die Streams EchoRequest und EchoResponse. <br><br><br><img src="https://habrastorage.org/webt/y7/ji/8i/y7ji8idykqbfsumuuj91t1fwwde.jpeg"><br><br>  Das Interessantere beginnt.  Unsere Zusammenstellung √§ndert sich in keiner Weise, damit Streaming-Dienste funktionieren.  Unsere n√§chste Aufgabe ist es, unsere neue Methode in unserem Echo-Dienst zu √ºberschreiben, der mit Streams funktioniert.  Beim Server ist das alles etwas einfacher.  Das hei√üt, wir k√∂nnen st√§ndig aus dem Stream lesen und etwas beantworten.  Wir k√∂nnen asynchron antworten.  Das hei√üt, sie sind unabh√§ngig, Stream zum Schreiben und Stream zum Lesen, und hier ist f√ºr ein einfaches Szenario alles einfach. <br><br><img src="https://habrastorage.org/webt/vv/ih/as/vvihasd7g8s9s8jfxte2lgdkae0.jpeg"><br><br>  Hier ist jetzt die Lekt√ºre, hier ist die Aufnahme. <br><br><br><img src="https://habrastorage.org/webt/v_/rb/l_/v_rbl_m4pyxndxrkveev_ibze2q.jpeg"><br><br>  Bei Java-Clients sind die Dinge etwas komplizierter.  Dort k√∂nnen Sie keine synchrone API verwenden, das hei√üt, sie funktioniert nur nicht mit Streams.  Und dort wird die asynchrone API verwendet.  Das hei√üt, unsere Aufgabe ist es, das Observer-Template zu implementieren.  Dort gibt es eine StreamObserver-Schnittstelle.  Es enth√§lt drei Methoden: onNext, onCompleted und onError.  Der Einfachheit halber habe ich hier nur onNext implementiert.  Es zuckt nur, wenn die Antwort vom Server kommt. <br><br><br><img src="https://habrastorage.org/webt/o5/ma/2r/o5ma2rsuawum-empf1enylvayos.jpeg"><br><br>  Hier habe ich gerade eine Warteschlange f√ºr den Nachrichtenaustausch zwischen Threads eingerichtet. <br><br><img src="https://habrastorage.org/webt/wt/pu/zd/wtpuzdzh5dlmkgdxqpkieddlegg.jpeg"><br><br>  Was ist der unterschied  Anstelle von blockingStub machen wir einfach newStub.  Dies ist eine asynchrone Implementierung, die nur mit Observer funktioniert.  Tats√§chlich k√∂nnen Sie unit√§re Anrufe bei Observer t√§tigen, was jedoch nicht so praktisch ist.  Zumindest nutzen wir es nicht so aktiv. <br><br>  Als n√§chstes konstruieren wir unseren Observer. <br><br>  Und wir machen unseren RPC-Aufruf.  Wir √ºbergeben den ResponseObserver an die Eingabe und geben am Ausgang den RequestObserver an uns aus.  Au√üerdem k√∂nnen wir √ºber RequestObserver Anrufe t√§tigen und so Nachrichten an den Server senden.  Und unser ResponseObserver zuckt und verarbeitet Nachrichten. <br><br>  Hier ist ein Beispiel.  Wir telefonieren nur.  Rufen Sie onNext an, √ºbergeben Sie dort Request. <br><br>  Weiter von der Warteschlange warten wir, bis der Server antwortet und druckt. <br><br><br><img src="https://habrastorage.org/webt/bg/ta/hq/bgtahqaqbyqbzp72lhix4tzsmii.jpeg"><br><br><br>  Ich m√∂chte darauf hinweisen, dass unsere Aufgabe hier als Verantwortlicher f√ºr die Implementierung des Streamings darin besteht, das Schlie√üen dieses RequestObservers korrekt zu handhaben.  Das hei√üt, im Fehlerfall m√ºssen wir die onError-Methode aufrufen. Wenn wir glauben, dass der Stream geschlossen werden kann, m√ºssen wir bei erfolgreichem Abschluss die onCompleted-Methode aufrufen. <br><br><img src="https://habrastorage.org/webt/js/4a/ze/js4aze1vr9sb4t9clbpq0obdywy.jpeg"><br><br>  Wir ziehen weiter.  Was sind die Streaming-Anwendungen?  Dies ist eine fortgeschrittenere Sache, nicht die Tatsache, dass es f√ºr jeden direkt n√ºtzlich ist, sondern wird manchmal verwendet.  Das hei√üt, das erste ist das Herunterladen und Hochladen einiger gro√üer Datenmengen.  Der Server oder Client kann in einigen Abschnitten Daten produzieren.  Diese Teile sind m√∂glicherweise bereits auf dem Client oder auf dem Server gruppiert.  Das hei√üt, Sie k√∂nnen hier bereits zus√§tzliche Optimierungen vornehmen. <br><br>  Das Streaming-Schema eignet sich auch gut f√ºr Server-Push.  Sie m√ºssen verstehen, dass ich bei bidirektionalem Streaming die extremste Option in Betracht gezogen habe.  Und vielleicht in eine Richtung streamen.  Zum Beispiel von Client zu Server oder von Server zu Client.  Wenn ein Server mit einem Client verbunden ist, k√∂nnen wir eine Verbindung zu einem Server herstellen, der Pushies an uns sendet. Hierzu m√ºssen wir keine regelm√§√üigen Abfragen durchf√ºhren. <br><br>  Der n√§chste Vorteil des Streamings ist die Bindung an einen Computer.  Wie ich bereits sagte, wird eine End-to-End-Verbindung f√ºr alle Nachrichten im Stream hergestellt, und diese Verbindung wird an einen Computer gebunden, und es wird definitiv nirgendwo gewechselt.  Daher ist es zum einen m√∂glich, etwas zu vereinfachen, eine Art Interserver-Synchronisation durchzuf√ºhren, und zum anderen k√∂nnen Sie auch Transaktionen durchf√ºhren. <br><br>  Und bidirektionales Streaming, nur ein Beispiel, das ich gezeigt habe, ist die M√∂glichkeit, einige meiner eigenen Protokolle zu erstellen.  Interessant genug, was.  Wir haben interne Warteschlangen in Yandex, die nur bidirektionales Streaming verwenden.  Und wenn pl√∂tzlich jemand solche Aufgaben hat, dann eine gute Gelegenheit, sie zu nutzen. <br><br>  Ich m√∂chte auch aufpassen, ich habe fr√ºher √ºber Metadaten gesprochen.            .            . ,     -   ,      ,      .      .  gRPC    . <br><br><h3>   </h3><br>  ,      gRPC. <br><br><img src="https://habrastorage.org/webt/wl/un/lo/wlunloh9hz1t6cklr4zaqzketmm.jpeg"><br><br>     ,   .   -  .   gRPC    . , ,  ,   , ,   .   ,    runtime- .  ,   .      ,   OK,       runtime- . <br><br> ,  Java      .                    .  google.rpc.Status  3 :  ,   .     ,   .        ,    .  ‚Äî  ,      ,    . <br><br>      error details,   ,   .   : ,   , , stack traces,      .   ,    . <br><br>    ‚Äî   ,  HTTP   ,     ?       .     BadRequest   .   ,     ,      error details,   . <br><br>   .   , , BadRequest  -  (   ),     - error detail.       , ,      ,   - .    ,    . <br><br><img src="https://habrastorage.org/webt/dk/dn/zl/dkdnzlcnav_kpnc7e29mv7j5hqa.jpeg"><br><br>       .  .   ,    , ,     .   - -   ,  - - ,     ,  .       .  , , Zipkin.   ,  HTTP    ,  ‚Äî  metadata.         . <br><br>       ,   .       ,        - ,    ,    ,     . <br><br>     runtime-,           - ,   .  Java  ClientInterceptor  ServerInterceptor.  ,    ,   . ,   ,  ,       ,    ,   - . ,  - API - .    ,  ,  , ,   - .  ,     gRPC,      ,  - .       ,  ,   - , ,  ,  . <br><br><img src="https://habrastorage.org/webt/fy/8u/iz/fy8uiztm6gwxntcvzc8m0qdcply.jpeg"><br><br>   -   .     -.   Java  .       ,       ,    -  .   -  ,     . <br><br><img src="https://habrastorage.org/webt/sb/zx/th/sbzxthmnnf_fh8iyxl9ghv02s4y.jpeg"><br><br>  .   gRPC ‚Äî  . HTTP/2  .   -   ,   ?    : , .    .   ,    gRPC   grpc_cli,  curl.   ,      . , -,  .    ,    gRPC    ,       . <br><br>    ,  evans.   ,    CLI:   ,     ,  ,  .  ,   .  - , ,  ,   , ,  . <br><br>  -  UI ‚Äî ,   Postman, ‚Äî  BloomRPC.     Postman .  Postman, , ,    .   , BloomRPC ,   . <br><br>  -  ,   .  , ,     grpc_cli.          .   ,   .  ,   ,  .       ,       .  , - -  .    ‚Äî . <br><br><img src="https://habrastorage.org/webt/7y/oe/w3/7yoew3fwgydkvdgiaxm1acueyki.jpeg"><br><br> ,     ,    gRPC.       . -    , -  ,  .  Swagger. ,    HTTP/1    .     OpenAPI   ,        .       . ,        HTTP/2,  Swagger ‚Äî   . <br><br> WSDL ‚Äî  ,  .   .       Swagger,     ,   .    .   -. <br><br>  ,  , ,       ,  JAX-RS,   Java  .    . <br><br>     Twirp.   ?     Go,     .     . ,  ,   Go ,   gRPC  Twirp.   ?  ,  gRPC ‚Äî   ,   , ,  IDL .     proto-  ,        gRPC-.      protoc,       ,       . <br><br>  Twirp     .   proto-      ,    HTTP/1.1    ,   JSON.    ,  Twirp      Go.       ,    ,   Java      Jetty.    ,    . <br><br><img src="https://habrastorage.org/webt/fn/p3/bi/fnp3bihwdt68ttten4_mpx7qal4.jpeg"><br><br>     ? gRPC ‚Äî    REST   .    ,     ,   , ,  HTTP/2 balancer.   service discovery,    . gRPC ,   .    . <br><br>      gRPC ‚Äî  ,  .   CLI,   UI. ,        . <br><br>    ,      gRPC.  inter-process-. , sidecar pattern.  ,          .      ,    . ,   -.    -     ,              ,     -.              .      ,  , ,    ,     - . <br><br> ,       .  gRPC    .   ,  .    ,   unary-.         ,      . <br><br>   : <br> ‚Äî <a href="https://grpc.io/">C  gRPC</a> ‚Äî   , .  ,    , ,      . <br> ‚Äî <a href="https://github.com/grpc-ecosystem/awesome-grpc">Awesome gRPC</a> ‚Äî   GitHub      .      ,    ,   , .  .    ‚Äî  ,  . <br><br>       ,   .      .       <a href="https://github.com/homer-j/grpc-examples"> </a> .  Vielen Dank! <br><br><a name="video1"></a><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/AciUs4Yq7oU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484068/">https://habr.com/ru/post/de484068/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484052/index.html">Aufgaben f√ºr die Mondbasis</a></li>
<li><a href="../de484056/index.html">Brauchen Sie f√ºr Ihr Projekt wirklich Tests?</a></li>
<li><a href="../de484062/index.html">Englisch lernen mit MEMASICS</a></li>
<li><a href="../de484064/index.html">Wie bereite ich ein Spiel f√ºr die Lokalisierung vor? 10 Grundregeln</a></li>
<li><a href="../de484066/index.html">Geld gegen Team. Nicht die offensichtlichsten Aspekte des Verh√§ltnisses von Unternehmern, Gr√ºndern und Investoren</a></li>
<li><a href="../de484070/index.html">Wie wir ein Betrugsbek√§mpfungssystem in vier H√§nden und drei K√∂pfen geschrieben haben</a></li>
<li><a href="../de484072/index.html">5. Fortinet Getting Started v6.0. NAT</a></li>
<li><a href="../de484076/index.html">Speicherort f√ºr Kryptow√§hrung: Besteuerung von Kryptow√§hrungen in verschiedenen L√§ndern</a></li>
<li><a href="../de484084/index.html">1C-Bitrix und ein Versuch, es einzuf√ºhren</a></li>
<li><a href="../de484088/index.html">Passwort-Hit-Parade (Analyse von ~ 5 Milliarden Passw√∂rtern nach Undichtigkeiten)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>