<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍✈️ 🛌🏼 ⛩️ NgRx鸭| 动态立面 🚵🏻 👨🏼‍⚕️ 👨‍👩‍👦‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="改善开发经验 





 在与来自不同公司的同事交谈时，我注意到有很多团队喜欢NgRx。 在我们的讨论中，这种想法并没有离开我： 


 “维护更少的代码，并更多地遵循写作指南，以方便后续扩展，将是很好的 。 ” 


 这促使我开始探索各种Redux重构技术。 我观看了视频，阅读了Redux的文...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>NgRx鸭| 动态立面</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485080/"><h2 id="usovershenstvovanie-opyta-razrabotki"> 改善开发经验 </h2><br><p><img src="https://habrastorage.org/webt/ph/td/hc/phtdhcenn6zg36mh6etbljvnyai.jpeg"></p><br><p> 在与来自不同公司的同事交谈时，我注意到有很多团队喜欢NgRx。 在我们的讨论中，这种想法并没有离开我： </p><br><p>  <em>“维护更少的代码，并更多地遵循写作指南，以方便后续扩展，将是很好的</em> 。 <em>”</em> </p><br><p> 这促使我开始探索各种Redux重构技术。 我观看了视频，阅读了Redux的文章和文档。 最后，我为NgRx编写了一个名为<a href="https://www.npmjs.com/package/%40co-it/ngrx-ducks">NgRx Ducks</a>的插件 </p><a name="habracut"></a><br><h3 id="celi"> 目标 </h3><br><p> 基本上，创建<strong>ngrx-ducks是</strong>为了简化使用NgRx的工作。 </p><br><ol><li> 使用<strong>Decorator API</strong>简化了动作处理，从而减少了同时配置<strong>Reducer</strong>和动作<strong>创建者</strong>所需编写的代码量。  NgRx Ducks自动<em>生成动作创建者和减速器功能</em> 。 </li><li> 技术支持较少，因为您无需编写枚举或<strong>联合类型</strong> 。 </li><li> 借助直观的类型化API，您可以将其用作<strong>可注入服务</strong> ，从而提供更清晰的应用程序逻辑，该API为您设置了与商店的交互。 </li></ol><br><h3 id="kak-ono-rabotaet"> 如何运作？ </h3><br><p> 该库是NgRx上的额外层。 它会自动为您创建动作创建者和化简功能。 此外，您还将获得可以在组件中使用的服务。 该服务提供了严格类型化的API，该API允许调度操作和从存储中选择数据。 </p><br><p>  NgRx Ducks库不会修改现有的NgRx行为。 它仅控制可观察的存储库和<em>调度</em>方法。 </p><br><p><img src="https://habrastorage.org/webt/ir/1l/_b/ir1l_b0lenbapynhikr0s1jpkoc.png"></p><br><blockquote> 由于NgRx Ducks仅依赖于<em>分发</em> ，并且存储库提供了可观察的事实，因此即使版本中有重大更改，NgRx Ducks仍与NgRx兼容。 </blockquote><br><h3 id="ustanovka"> 安装方式 </h3><br><p>  NgRx Ducks与现有NgRx项目无缝集成。 只需安装npm软件包，即可开始使用。 </p><br><pre><code class="bash hljs">npm install @co-it/ngrx-ducks <span class="hljs-comment"><span class="hljs-comment">#  yarn add @co-it/ngrx-ducks</span></span></code> </pre> <br><h3 id="decorator-api"> 装饰器API </h3><br><p>  NgRx Ducks的主要思想是将动作类型和更改器逻辑（ <em>也称为reducers</em> ）结合起来。 因此，添加了<strong>@Ducksify</strong>装饰器以注释常规类。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Ducksify } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@co-it/ngrx-ducks'</span></span>; @Ducksify&lt;number&gt;({ <span class="hljs-attr"><span class="hljs-attr">initialState</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> <br><p> 装饰器允许您指定状态的<em>initialState</em> 。 传递initialState可使NgRx Ducks稍后自动生成reducer函数。 </p><br><p> 现在，您可以将变异逻辑放在类中。 不再需要编写<strong>switch-case表达式</strong> 。 相反，我们使用<strong><a href="https://habr.com/ru/users/action/" class="user_link">动作</a></strong>装饰器在动作类型和变异逻辑之间创建映射。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Action, Ducksify } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@co-it/ngrx-ducks'</span></span>; @Ducksify&lt;number&gt;({ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> </span></span>{ @Action(<span class="hljs-string"><span class="hljs-string">'[Counter] Increase by passed value'</span></span>) increaseBy(state: number, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: number): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state + payload; } }</code> </pre> <br><p>  NgRx Ducks用相应的变异逻辑映射每个动作。  Duck包含生成减速器功能的所有必要信息。 </p><br><h3 id="funkciya-redyusera"> 减速器功能 </h3><br><p> 减速器功能是使用NgRx Ducks自动生成的。  <strong>reducerFrom</strong>工厂将创建一个查找表，以将每种操作类型映射到其对应的变异逻辑。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { reducerFrom, DucksifiedAction, ... } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@co-it/ngrx-ducks'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reducer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> state: number, action: DucksifiedAction</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">number</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reducerFrom(Counter)(state, action); }</code> </pre> <br><p> 您仍然需要将<strong>reducerFrom</strong>包装在导出的函数中，以与<a href="https://angular.io/guide/aot-compiler">AoT</a>编译器一起正常工作。 </p><br><p> 必须使用NgRx将生成的reducer添加到<strong>ActionReducerMap</strong>中（ <em>请参见下面的示例</em> ）。 </p><br><h3 id="utinaya-sila"> 鸭威！ </h3><br><p> 最有趣的还没到！  NgRx鸭子的目标是简化与仓库的交互。 通过自动生成reducer功能，一切都很好，让我们看一下也在此处创建的<strong>动态外观</strong> 。 </p><br><blockquote>  <strong>@Ducksify</strong>装饰器还负责将您的鸭子作为<strong>服务</strong>注册到Angular IoC容器中。 这意味着您可以将鸭子嵌入组件中！ </blockquote><br><h4 id="dispatching-ekshenov-v-hranilische"> 保管箱动作分派 </h4><br><p>  NgRx Ducks为Duck添加了一些修复程序，这些修复程序使您可以使用简单的函数调用而不是手动分派操作。 您可以在组件内部获得类型化的API。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Duck } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@co-it/ngrx-ducks'</span></span>; @Component({ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CounterComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(@Inject(Counter) private _counter: Duck&lt;Counter&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counter.incrementBy(<span class="hljs-number"><span class="hljs-number">42</span></span>); } }</code> </pre> <br><p> 您实现的是<em>Duck，而不是Counter。</em>  <em>Duck会自动为crementBy创建一个动作创建器，该动作创建器将使用传递的值（有效负载）来分派动作。</em>  <em>由于具有动态TypeScript类型，因此您可以在IDE中立即获得自动完成功能。</em> <br></p><p><img src="https://habrastorage.org/webt/qr/xc/nm/qrxcnmafxyodeigdatgq0ea5too.gif"></p><br><p> 简而言之，NgRx Ducks使处理动作的整个过程自动化。 您只需在Duck中配置一次操作，然后再使用为您自动生成和更新的类型化动态外观。 </p><br><h4 id="vyborka-dannyh-iz-hranilischa"> 从存储中检索数据 </h4><br><p>  Duck使用NgRx选择器从存储读取数据。 每只鸭子都有一个接受选择器的助手选择。 </p><br><p> 让我们想象一下，我们的Counter是使用“ <em>counter</em> ”键注册为NgRx函数的。 这将允许我们进行以下选择器设置。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { createFeatureSelector, createSelector} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@ngrx/store'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> visitCounter = createFeatureSelector&lt;number&gt;(<span class="hljs-string"><span class="hljs-string">'counter'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = createFeatureSelector&lt;number&gt;(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">count</span></span></span><span class="hljs-function"> =&gt;</span></span> count); @Component({ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CounterComponent</span></span></span><span class="hljs-class"> </span></span>{ count$: Observable&lt;number&gt;;<span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(@Inject(Counter) private _counter: Duck&lt;Counter&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.count$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counter.pick(count); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counter.incrementBy(<span class="hljs-number"><span class="hljs-number">42</span></span>); } }</code> </pre> <br><p> 您可以在<a href="https://stackblitz.com/edit/ngrx-ducks-simple%3Fembed%3D1%255E_%255Eamp%255E_%255Efile%3Dsrc/app/counter/counter.component.ts">stackblitz.io上</a>观看演示。 </p><br><p>  Duck允许触发状态突变和从存储库查询数据。 您只需要一个“已利用”服务，该服务就可以设置一个方便的API与存储进行交互。 </p><br><h3 id="i-nakonec"> 最后 </h3><br><p>  NgRx Ducks还可以与Effects无缝集成！ 但是我们将仅在下一篇文章中对此进行详细分析。 </p><br><p>  <em>如果您希望现在就找到它，可以参考复杂的示例，该示例也可以在<a href="https://stackblitz.com/edit/ngrx-ducks%3Fctl%3D1%255E_%255Eamp%255E_%255Eembed%3D1%255E_%255Eamp%255E_%255Efile%3Dsrc/app/counter/counter.component.html">stackblitz.io中找到。</a></em> </p><br><h3 id="tldr">  TL; DR </h3><br><ul><li>  NgRx鸭子作为NgRx之上的额外层。 </li><li> 您可以轻松地将NgRx Ducks集成到现有项目中。 </li><li> 鸭 <br>  ... 自动生成动作创建者和化简函数 <br>  。...使动作枚举器和联合类型不必要 <br>  ... 它是一个动态外观，可以嵌入到组件中 <br>  。...提供动态类型的自调度；抱歉的操作 <br>  ... 允许使用pick-API从存储中读取数据 <br>  。...可以由Effects使用（请参见<a href="https://stackblitz.com/edit/ngrx-ducks">Demo</a> ）。 </li></ul><br><h4 id="vot-i-vse-rebyata"> 伙计们！ </h4><br><p> 希望我能说服您尝试<a href="https://www.npmjs.com/package/%40co-it/ngrx-ducks">NgRx Ducks</a> 。 另外，我想知道您对这个库的看法。 如果您有任何想法，只需在<a href="https://github.com/co-it/co-it/issues">GitHub上</a>编写 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN485080/">https://habr.com/ru/post/zh-CN485080/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN485058/index.html">“验证时钟”：关于新服务器时间同步协议的已知信息</a></li>
<li><a href="../zh-CN485068/index.html">TypeScript的简洁代码-第2部分</a></li>
<li><a href="../zh-CN485070/index.html">Andrew Eun，“机器学习的热情”。 第36-46章的翻译</a></li>
<li><a href="../zh-CN485074/index.html">如何不死于一个项目或5个生活技巧</a></li>
<li><a href="../zh-CN485078/index.html">困难，脆弱，配置不足：2020年网络威胁</a></li>
<li><a href="../zh-CN485084/index.html">浮游生物办公室-演变</a></li>
<li><a href="../zh-CN485088/index.html">回顾性耙。 自制解决方案如何比付费解决方案更好</a></li>
<li><a href="../zh-CN485090/index.html">效率的秘诀是质量准则，而不是有效的经理</a></li>
<li><a href="../zh-CN485092/index.html">验证iOS应用程序中的数据</a></li>
<li><a href="../zh-CN485094/index.html">使用Spring Boot的微服务。 第3部分。创建货币转换微服务</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>