<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚗 👏🏿 👨🏼‍🍳 Intel Dunia Virtual. Berlatih 👩🏽‍🎤 👩🏿‍🤝‍👨🏾 ㊙️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel ini saya ingin mempertimbangkan aspek praktis untuk membuat hypervisor sederhana berdasarkan teknologi virtualisasi perangkat keras Intel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Intel Dunia Virtual. Berlatih</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419065/">  Pada artikel ini saya ingin mempertimbangkan aspek praktis untuk membuat hypervisor <u>sederhana</u> berdasarkan teknologi virtualisasi perangkat keras Intel VMX. <br><br>  Virtualisasi perangkat keras adalah bidang pemrograman sistem yang agak sempit dan tidak memiliki komunitas besar di Rusia.  Saya berharap bahwa materi dalam artikel ini akan membantu mereka yang ingin menemukan virtualisasi perangkat keras dan kemungkinan yang disediakannya.  Seperti yang dikatakan di awal, saya ingin mempertimbangkan hanya aspek praktis tanpa menyelam ke dalam teori, sehingga diasumsikan bahwa pembaca akrab dengan arsitektur x86-64 dan setidaknya memiliki gagasan umum tentang mekanisme VMX.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber untuk artikel</a> . <br><br>  Mari kita mulai dengan menetapkan sasaran untuk hypervisor: <br><a name="habracut"></a><br><ol><li>  Berjalan sebelum memuat OS tamu </li><li>  Dukungan untuk satu prosesor logis dan 4 GB memori fisik tamu </li><li>  Memastikan bahwa OS tamu berfungsi dengan baik dengan perangkat yang diproyeksikan di area memori fisik </li><li>  Pemrosesan VMexits </li><li>  OS Tamu dari perintah pertama harus dijalankan di lingkungan virtual. </li><li>  Mengeluarkan informasi debugging melalui port COM (metode universal, mudah diterapkan) </li></ol><br>  Sebagai OS tamu, saya memilih Windows 7 x32, di mana batasan berikut ditetapkan: <br><br><ul><li>  Hanya satu inti CPU yang terlibat </li><li>  Opsi PAE dinonaktifkan yang memungkinkan OS 32-bit untuk menggunakan jumlah memori fisik lebih dari 4GB </li><li>  BIOS dalam mode lama, UEFI dinonaktifkan </li></ul><br><h3>  Deskripsi bootloader </h3><br>  Agar hypervisor mulai ketika PC mulai, saya memilih cara termudah, yaitu, saya menuliskan bootloader saya di sektor MBR dari disk tempat OS tamu diinstal.  Itu juga perlu untuk menempatkan kode hypervisor di suatu tempat pada disk.  Dalam kasus saya, MBR asli membaca bootloader mulai dari sektor 2048, yang memberikan area bebas bersyarat untuk penulisan hingga (2047 * 512) Kb.  Ini lebih dari cukup untuk mengakomodasi semua komponen hypervisor. <br><br>  Di bawah ini adalah tata letak hypervisor pada disk, semua nilai diatur dalam sektor. <br><br><img src="https://habrastorage.org/webt/ek/tv/_z/ektv_zcfq5gcq4bslygiyc2lbqc.jpeg"><br><br>  Proses unduhan adalah sebagai berikut: <br><br><img src="https://habrastorage.org/webt/ba/ej/ae/baejaecukny9u7mi6b8udh9crfo.jpeg"><br><ol><li>  loader.mbr membaca kode loader loader.main dari disk dan mentransfer kontrol untuk itu. </li><li>  loader.main beralih ke mode lama, dan kemudian membaca tabel elemen loadload.table, berdasarkan yang memuat lebih lanjut komponen hypervisor ke dalam memori dilakukan. </li><li>  Setelah bootloader selesai bekerja di memori fisik di alamat 0x100000000 ada kode hypervisor, alamat ini dipilih sehingga rentang dari 0 hingga 0xFFFFFFFFFF dapat digunakan untuk pemetaan langsung ke memori fisik tamu. </li><li>  Windows mbr asli boot di alamat fisik 0x7C00. </li></ol><br>  Saya ingin menarik perhatian pada kenyataan bahwa bootloader setelah beralih ke mode lama tidak dapat lagi menggunakan layanan BIOS untuk bekerja dengan disk fisik, jadi saya menggunakan "Advance Host Controller Interface" untuk membaca disk. <br><br>  Lebih detail tentang yang dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h3>  Deskripsi Pekerjaan Hypervisor </h3><br>  Setelah hypervisor menerima kontrol, tugas pertamanya adalah menginisialisasi lingkungan di mana ia harus bekerja, untuk melakukan ini, fungsinya disebut secara berurutan: <br><br><ul><li>  <b>InitLongModeGdt ()</b> - membuat dan memuat tabel 4 deskriptor: NULL, CS64, DS64, TSS64 </li><li>  <b>InitLongModeIdt (isr_vector)</b> - menginisialisasi 32 vektor interupsi pertama oleh penangan umum, atau lebih tepatnya, rintisannya <br></li><li>  <b>InitLongModeTSS ()</b> - menginisialisasi segmen status tugas </li><li>  <b>InitLongModePages ()</b> - inisialisasi paging: <br><br>  [0x00000000 - 0xFFFFFFFF] - ukuran halaman 2MB, cacat cache; <br>  [0x100000000 - 0x13FFFFFFF] - ukuran halaman 2 MB, tulis balasan cache, halaman global; <br>  [0x140000000 - n] - tidak ada; </li><li>  <b>InitControlAndSegmenRegs ()</b> - memuat ulang register segmen </li></ul><br>  Selanjutnya, Anda perlu memastikan bahwa prosesor mendukung VMX, verifikasi dilakukan oleh fungsi <b>CheckVMXConditions ()</b> : <br><br><ul><li>  CPUID.1: ECX.VMX [bit 5] harus diatur ke 1 </li><li>  Dalam register MSR, IA32_FEATURE_CONTROL bit 2 harus disetel - memungkinkan VMXON di luar operasi SMX dan bit 0 - Lock (relevan ketika debugging di Bochs) </li></ul><br>  Jika semuanya beres dan hypervisor berjalan pada prosesor yang mendukung virtualisasi perangkat keras, buka inisialisasi awal VMX, lihat fungsi <b>InitVMX ()</b> : <br><br><ul><li>  Area memori yang diciptakan VMXON dan VMCS (struktur data kontrol mesin virtual) berukuran 4.096 byte.  Pengidentifikasi revisi VMCS yang diambil dari MSR IA32_VMX_BASIC direkam dalam 31 bit pertama dari setiap area. </li><li>  Diperiksa bahwa dalam sistem register CR0 dan CR4 semua bit diatur sesuai dengan persyaratan VMX. </li><li>  Prosesor logis dimasukkan ke mode root vmx oleh perintah VMXON (alamat fisik wilayah VMXON sebagai argumen). </li><li>  Perintah VMCLEAR (VMCS) menetapkan status peluncuran VMCS ke Clear, dan perintah tersebut menetapkan nilai-nilai khusus implementasi ke VMCS. </li><li>  Perintah VMPTRLD (VMCS) memuat alamat VMCS saat ini yang dilewatkan sebagai argumen ke pointer-VMCS saat ini. </li></ul><br>  Eksekusi OS tamu akan dimulai dalam mode nyata dari alamat 0x7C00 di mana, seperti yang kita ingat, loader.main loader menempatkan win7.mbr.  Untuk membuat ulang lingkungan virtual yang identik dengan yang di mana mbr biasanya dieksekusi, fungsi <b>InitGuestRegisterState () dipanggil,</b> yang menetapkan register non-root vmx sebagai berikut: <br><br><pre><code class="hljs pgsql">CR0 = <span class="hljs-number"><span class="hljs-number">0x10</span></span> CR3 = <span class="hljs-number"><span class="hljs-number">0</span></span> CR4 = <span class="hljs-number"><span class="hljs-number">0</span></span> DR7 = <span class="hljs-number"><span class="hljs-number">0</span></span> RSP = <span class="hljs-number"><span class="hljs-number">0xFFD6</span></span> RIP = <span class="hljs-number"><span class="hljs-number">0x7C00</span></span> RFLAGS = <span class="hljs-number"><span class="hljs-number">0x82</span></span> ES.base = <span class="hljs-number"><span class="hljs-number">0</span></span> CS.base = <span class="hljs-number"><span class="hljs-number">0</span></span> SS.base = <span class="hljs-number"><span class="hljs-number">0</span></span> DS.base = <span class="hljs-number"><span class="hljs-number">0</span></span> FS.base = <span class="hljs-number"><span class="hljs-number">0</span></span> GS.base = <span class="hljs-number"><span class="hljs-number">0</span></span> LDTR.base = <span class="hljs-number"><span class="hljs-number">0</span></span> TR.base = <span class="hljs-number"><span class="hljs-number">0</span></span> ES.<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> = <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span> CS.<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> = <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> SS.<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> = <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> DS.<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> = <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span> FS.<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> = <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> GS.<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> = <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> LDTR.<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> = <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> TR.<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> = <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> ES.<span class="hljs-keyword"><span class="hljs-keyword">access</span></span> rights = <span class="hljs-number"><span class="hljs-number">0xF093</span></span> CS.<span class="hljs-keyword"><span class="hljs-keyword">access</span></span> rights = <span class="hljs-number"><span class="hljs-number">0x93</span></span> SS.<span class="hljs-keyword"><span class="hljs-keyword">access</span></span> rights = <span class="hljs-number"><span class="hljs-number">0x93</span></span> DS.<span class="hljs-keyword"><span class="hljs-keyword">access</span></span> rights = <span class="hljs-number"><span class="hljs-number">0xF093</span></span> FS.<span class="hljs-keyword"><span class="hljs-keyword">access</span></span> rights = <span class="hljs-number"><span class="hljs-number">0x93</span></span> GS.<span class="hljs-keyword"><span class="hljs-keyword">access</span></span> rights = <span class="hljs-number"><span class="hljs-number">0x93</span></span> LDTR.<span class="hljs-keyword"><span class="hljs-keyword">access</span></span> rights = <span class="hljs-number"><span class="hljs-number">0x82</span></span> TR.<span class="hljs-keyword"><span class="hljs-keyword">access</span></span> rights = <span class="hljs-number"><span class="hljs-number">0x8B</span></span> ES.selector = <span class="hljs-number"><span class="hljs-number">0</span></span> CS.selector = <span class="hljs-number"><span class="hljs-number">0</span></span> SS.selector = <span class="hljs-number"><span class="hljs-number">0</span></span> DS.selector = <span class="hljs-number"><span class="hljs-number">0</span></span> FS.selector = <span class="hljs-number"><span class="hljs-number">0</span></span> GS.selector = <span class="hljs-number"><span class="hljs-number">0</span></span> LDTR.selector = <span class="hljs-number"><span class="hljs-number">0</span></span> TR.selector = <span class="hljs-number"><span class="hljs-number">0</span></span> GDTR.base = <span class="hljs-number"><span class="hljs-number">0</span></span> IDTR.base = <span class="hljs-number"><span class="hljs-number">0</span></span> GDTR.<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> IDTR.<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> = <span class="hljs-number"><span class="hljs-number">0x3FF</span></span></code> </pre> <br>  Perlu dicatat bahwa bidang batas cache deskriptor untuk register segmen DS dan ES adalah 0xFFFFFFFF.  Ini adalah contoh penggunaan mode tidak nyata - fitur prosesor x86 yang memungkinkan Anda untuk melewati batas segmen dalam mode nyata.  Anda dapat membaca lebih lanjut tentang ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Saat berada dalam mode bukan-root vmx, OS tamu dapat menghadapi situasi di mana perlu untuk mengembalikan kontrol ke host dalam mode root vmx.  Dalam kasus ini, keluar VM terjadi selama kondisi saat ini dari vmx non-root disimpan dan vmx-root dimuat.  Inisialisasi vmx-root dilakukan oleh fungsi <b>InitHostStateArea ()</b> , yang menetapkan nilai register berikut: <br><br><pre> <code class="hljs cs">CR0 = <span class="hljs-number"><span class="hljs-number">0x80000039</span></span> CR3 = PML4_addr CR4 = <span class="hljs-number"><span class="hljs-number">0x420A1</span></span> RSP =     STACK64 RIP =   VMEXIT_handler ES.selector = <span class="hljs-number"><span class="hljs-number">0x10</span></span> CS.selector = <span class="hljs-number"><span class="hljs-number">0x08</span></span> SS.selector = <span class="hljs-number"><span class="hljs-number">0x10</span></span> DS.selector = <span class="hljs-number"><span class="hljs-number">0x10</span></span> FS.selector = <span class="hljs-number"><span class="hljs-number">0x10</span></span> GS.selector = <span class="hljs-number"><span class="hljs-number">0x10</span></span> TR.selector = <span class="hljs-number"><span class="hljs-number">0x18</span></span> TR.<span class="hljs-keyword"><span class="hljs-keyword">base</span></span> =  TSS GDTR.<span class="hljs-keyword"><span class="hljs-keyword">base</span></span> =  GDT64 IDTR.<span class="hljs-keyword"><span class="hljs-keyword">base</span></span> =  IDTR</code> </pre> <br>  Selanjutnya, penciptaan ruang alamat fisik tamu <b>dilakukan (</b> fungsi <b>InitEPT ()</b> ).  Ini adalah salah satu momen paling penting ketika membuat hypervisor, karena ukuran atau tipe pengaturan yang salah pada salah satu lokasi memori dapat menyebabkan kesalahan yang mungkin tidak langsung terwujud, tetapi dengan probabilitas tinggi akan menyebabkan rem atau pembekuan OS tamu yang tidak terduga.  Secara umum, ada sedikit kesenangan di sini dan lebih baik membayar perhatian yang cukup untuk menyetel memori. <br><br>  Gambar berikut menunjukkan model ruang alamat fisik tamu: <br><br><img src="https://habrastorage.org/webt/lm/7b/ll/lm7bllv6hrh9kjv4aoopbzapz1q.jpeg"><br><br>  Jadi apa yang kita lihat di sini: <br><br><ul><li>  [0 - 0xFFFFFFFF] seluruh rentang ruang alamat tamu.  Tipe Default: tulis kembali </li><li>  [0xA0000 - 0xBFFFFF] - Ram video.  Ketik: tidak mudah terbakar </li><li>  [0xBA647000 - 0xFFFFFFFF] - Perangkat ram.  Ketik: tidak mudah terbakar </li><li>  [0x0000000 - 0xCFFFFFFF] - Video ram.  Jenis: tulis kombinasi </li><li>  [0xD0000000 - 0xD1FFFFFF] - Video ram.  Jenis: tulis kombinasi </li><li>  [0xFA000000 - 0xFAFFFFFF] - Ram video.  Jenis: tulis kombinasi </li></ul><br>  Saya mengambil informasi untuk membuat area seperti itu dari utilitas RAMMap (tab Physical Ranges). Saya juga menggunakan data dari Windows Device Manager.  Tentu saja, pada PC lain, kisaran alamat cenderung berbeda.  Adapun tipe memori tamu, dalam implementasi saya, tipe ditentukan hanya oleh nilai yang ditentukan dalam tabel EPT.  Ini sederhana, tetapi tidak sepenuhnya benar, dan secara umum jenis memori yang ingin diinstal oleh OS tamu di halamannya harus diperhitungkan. <br><br>  Setelah pembuatan ruang alamat tamu selesai, Anda dapat melanjutkan ke <b>pengaturan</b> bidang kontrol Eksekusi VM <b>(InitExecutionControlFields ()</b> fungsi).  Ini adalah seperangkat opsi yang cukup besar yang memungkinkan Anda untuk mengatur kondisi operasi OS tamu dalam mode bukan-root vmx.  Anda dapat, misalnya, melacak panggilan ke port input / output atau memantau perubahan dalam register MSR.  Tetapi dalam kasus kami, saya hanya menggunakan kemampuan untuk mengontrol pengaturan bit tertentu dalam register CR0.  Faktanya adalah bahwa 30 (CD) dan 29 (NW) bit adalah umum untuk kedua mode vmx non-root dan vmx root, dan jika OS tamu menetapkan bit-bit ini ke 1 ini akan berdampak negatif pada kinerja. <br><br>  Proses mengkonfigurasi hypervisor hampir selesai, tetap hanya untuk menetapkan kontrol atas transisi ke mode tamu vmx non-root dan kembali ke mode host vmx root.  Pengaturan diatur dalam fungsi: <br><br>  <b>Pengaturan InitVMEntryControl ()</b> untuk transisi ke vmx non-root: <br><br><ul><li>  Muat Tamu IA32_EFER </li><li>  Muat Tamu IA32_PAT </li><li>  Muat Tamu MSR (IA32_MTRR_PHYSBASE0, IA32_MTRR_PHYSMASK0, IA32_MTRR_DEF_TYPE) </li></ul><br>  <b>Pengaturan InitVMExitControl ()</b> untuk beralih ke root vmx: <br><br><ul><li>  Muat Host IA32_EFER; </li><li>  Simpan Tamu IA32_EFER; </li><li>  Muat Host IA32_PAT; </li><li>  Simpan Tamu IA32_PAT; </li><li>  Host.CS.L = 1, Host.IA32_EFER.LME = 1, Host.IA32_EFER.LMA = 1; </li><li>  Simpan MSR Tamu (IA32_MTRR_PHYSBASE0, IA32_MTRR_PHYSMASK0, IA32_MTRR_DEF_TYPE); </li><li>  Muat Host MSR (IA32_MTRR_PHYSBASE0, IA32_MTRR_PHYSMASK0, IA32_MTRR_DEF_TYPE); </li></ul><br>  Sekarang setelah semua pengaturan selesai, fungsi <b>VMLaunch () menempatkan</b> prosesor dalam mode non-root vmx dan OS tamu mulai berjalan.  Seperti yang saya sebutkan sebelumnya, kondisi dapat diatur dalam pengaturan kontrol eksekusi vm, dalam hal ini hypervisor akan mengembalikan kontrol ke dirinya sendiri dalam mode root vmx.  Dalam contoh sederhana saya, saya memberikan OS tamu sepenuhnya kebebasan untuk bertindak, namun, dalam beberapa kasus, hypervisor masih perlu campur tangan dan menyesuaikan OS. <br><br><ol><li>  Jika OS tamu mencoba untuk mengubah bit CD dan NW dalam register CR0, VM Exit handler <br>  mengoreksi data yang direkam dalam CR0.  Bidang bayangan baca CR0 juga dimodifikasi sehingga saat membaca CR0 OS tamu menerima nilai yang direkam. </li><li>  Menjalankan perintah xsetbv.  Perintah ini selalu memanggil VM Exit, terlepas dari pengaturannya, jadi saya baru saja menambahkan eksekusi dalam mode root vmx. </li><li>  Menjalankan perintah dewa asmara.  Perintah ini juga memanggil keluar VM tanpa syarat.  Tapi saya membuat perubahan kecil pada penangannya.  Jika nilai dalam argumen eax adalah 0x80000002 - 0x80000004, cpuid tidak akan mengembalikan nama merek prosesor, tetapi baris: <i>VMX Study Core :)</i> Hasilnya dapat dilihat pada tangkapan layar: </li></ol><br><img src="https://habrastorage.org/webt/gx/br/cg/gxbrcgcfoiara6ivchp_lm0hgja.jpeg"><br><br><h3>  Ringkasan </h3><br>  Hypervisor yang ditulis sebagai contoh untuk artikel ini cukup mampu mendukung operasi OS tamu yang stabil, meskipun tentu saja itu bukan solusi yang lengkap.  Intel VT-d tidak digunakan, dukungan untuk hanya satu prosesor logis diterapkan, tidak ada kontrol atas gangguan dan pengoperasian perangkat periferal.  Secara umum, saya tidak menggunakan hampir apa pun dari set alat yang kaya yang disediakan Intel untuk virtualisasi perangkat keras.  Namun, jika komunitas tertarik, saya akan terus menulis tentang Intel VMX, terutama karena ada sesuatu untuk ditulis. <br><br>  Ya, saya hampir lupa, nyaman untuk men-debug hypervisor dan komponennya menggunakan Bochs.  Pada awalnya itu adalah alat yang sangat diperlukan.  Sayangnya, mengunduh hypervisor di Bochs berbeda dengan mengunduh ke PC fisik.  Pada suatu waktu, saya membuat majelis khusus untuk menyederhanakan proses ini, saya akan mencoba untuk menertibkan sumber dan menyatukannya dengan proyek dalam waktu dekat. <br><br>  Itu saja.  Terima kasih atas perhatian anda </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419065/">https://habr.com/ru/post/id419065/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419051/index.html">Bagaimana Flant Membantu Pemula</a></li>
<li><a href="../id419053/index.html">Menguji Teknologi Cache Adaptec RAID</a></li>
<li><a href="../id419055/index.html">Dalam teori string, Anda dapat bertahan dengan alam semesta yang jauh lebih sedikit.</a></li>
<li><a href="../id419061/index.html">Apa yang Baru di GoLand 2018.2</a></li>
<li><a href="../id419063/index.html">Otomatisasi mendapatkan informasi dari USRLE menggunakan Freepascal</a></li>
<li><a href="../id419067/index.html">Cara menjual data pribadi, atau mengapa sulit memberi label harga pada informasi</a></li>
<li><a href="../id419069/index.html">Pemanasan global akan membuat dunia kita lebih hijau, tetapi jangan bersukacita</a></li>
<li><a href="../id419071/index.html">Mengikuti hack tp-link</a></li>
<li><a href="../id419075/index.html">Pada pembentukan urutan dalam hipotesis Collatz (3n + 1)</a></li>
<li><a href="../id419077/index.html">Pelokalan aplikasi di iOS. Bagian 1. Apa yang kita miliki?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>