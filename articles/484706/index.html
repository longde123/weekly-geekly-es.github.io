<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìß üõ¢Ô∏è üëäüèº Practica trabajando con neum√°ticos personalizados del complejo Redd üåî ü§æüèΩ üì∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En el √∫ltimo art√≠culo, examinamos la teor√≠a de manejar mil peque√±as cosas en el complejo Redd, pero para no inflar el volumen, posponemos la pr√°ctica ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Practica trabajando con neum√°ticos personalizados del complejo Redd</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484706/"> En el <a href="https://habr.com/ru/post/483724/">√∫ltimo art√≠culo,</a> examinamos la teor√≠a de manejar mil peque√±as cosas en el complejo Redd, pero para no inflar el volumen, posponemos la pr√°ctica la pr√≥xima vez.  Ha llegado el momento de realizar experimentos pr√°cticos.  Aquellos que no usan el complejo Redd tambi√©n podr√°n encontrar conocimientos √∫tiles en este art√≠culo, a saber, la metodolog√≠a para enviar comandos de proveedor a unidades USB desde Linux, porque, como ya se mencion√≥, el controlador STM32 en el complejo realiza la funci√≥n de un lector SD, es decir, conducir <br><br><img src="https://habrastorage.org/webt/_e/hh/5n/_ehh5nw2j8tiw7myjovthvvc_va.png"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Art√≠culos anteriores del ciclo</b> <div class="spoiler_text"><ol><li>  <a href="https://habr.com/ru/post/452656/">Desarrollo del "firmware" m√°s simple para FPGAs instalados en Redd, y depuraci√≥n utilizando la prueba de memoria como ejemplo.</a> </li><li>  <a href="https://habr.com/ru/post/453682/">Desarrollo del "firmware" m√°s simple para FPGAs instalados en Redd.</a>  <a href="https://habr.com/ru/post/453682/">Parte 2. C√≥digo del programa.</a> </li><li>  <a href="https://habr.com/ru/post/454938/">Desarrollo de su propio n√∫cleo para incrustar en un sistema de procesador basado en FPGA.</a> </li><li>  <a href="https://habr.com/ru/post/456008/">Desarrollo de programas para el procesador central Redd sobre el ejemplo de acceso a la FPGA.</a> </li><li>  <a href="https://habr.com/ru/post/462253/">Los primeros experimentos utilizando el protocolo de transmisi√≥n en el ejemplo de la conexi√≥n de la CPU y el procesador en el FPGA del complejo Redd.</a> </li><li>  <a href="https://habr.com/ru/post/464795/">Merry Quartusel, o c√≥mo el procesador ha llegado a tal vida.</a> </li><li>  <a href="https://habr.com/ru/post/467353/">M√©todos de optimizaci√≥n de c√≥digo para Redd.</a>  <a href="https://habr.com/ru/post/467353/">Parte 1: efecto cach√©.</a> </li><li>  <a href="https://habr.com/ru/post/468027/">M√©todos de optimizaci√≥n de c√≥digo para Redd.</a>  <a href="https://habr.com/ru/post/468027/">Parte 2: memoria no almacenada en cach√© y operaci√≥n de bus paralelo.</a> </li><li>  <a href="https://habr.com/ru/post/469985/">Amplia optimizaci√≥n de c√≥digo: reemplazar un generador de reloj para mejorar el rendimiento del sistema.</a> </li><li>  <a href="https://habr.com/ru/post/477662/">Acceso a autobuses Redd implementados en controladores FTDI</a> </li><li>  <a href="https://habr.com/ru/post/483724/">Trabaja con neum√°ticos personalizados complejos Redd</a> </li></ol><br></div></div><br><h2>  Clasificaci√≥n de unidades por sistemas de comando </h2><br>  Al trabajar con unidades, debe distinguir entre una interfaz f√≠sica y un sistema de comando.  En particular, unidades de CD / DVD / BD y otras √≥pticas.  Tradicionalmente, se conectan a un cable SATA (anteriormente IDE).  Pero espec√≠ficamente en este cable, solo los comandos PACKET se ejecutan durante la operaci√≥n, en el bloque de datos de los cuales se colocan los comandos codificados de acuerdo con un principio completamente diferente (pronto descubriremos por cu√°l).  Por lo tanto, ahora hablaremos no tanto de cables, sino de los equipos que corren en ellos.  S√© de tres sistemas de comando comunes para trabajar con unidades. <br><br><ul><li>  MMC  Se entiende por tarjetas SD.  Honestamente, para m√≠ este es el sistema de comando m√°s misterioso.  Al parecer, c√≥mo enviarlos es claro, pero c√≥mo administrar la unidad sin leer cuidadosamente el documento que contiene muchos gr√°ficos de transici√≥n, siempre estoy confundido.  Afortunadamente, esto no nos molesta hoy, ya que aunque trabajamos con una tarjeta SD, el controlador STM32 en el modo de "caja negra" funciona con ella. </li><li>  ATA  Inicialmente, estos comandos se ejecutaron en el bus IDE, luego en SATA.  Un maravilloso sistema de comando, pero hoy tambi√©n mencionamos que existe. </li><li>  SCSI  Este sistema de comando se utiliza en una amplia gama de dispositivos.  Considere su uso en unidades.  Hoy en d√≠a, los equipos SCSI se ejecutan, en primer lugar, a lo largo de los cables del bus SAS (por cierto, incluso los SSD con interfaz SAS ahora est√°n de moda).  Curiosamente, las unidades √≥pticas f√≠sicamente conectadas al bus SATA tambi√©n funcionan a trav√©s de comandos SCSI.  En el bus USB cuando se trabaja de acuerdo con el est√°ndar del dispositivo de almacenamiento masivo, los comandos tambi√©n van en formato SCSI.  El microcontrolador STM32 est√° conectado al complejo Redd a trav√©s del bus USB, es decir, en nuestro caso, los comandos siguen la siguiente ruta: <br><br><img src="https://habrastorage.org/webt/hy/iy/f4/hyiyf4m9sjgr8etz8ily8joxsrc.png"><br></li></ul><br>  Desde la PC al controlador, a trav√©s de USB, los comandos est√°n en formato SCSI.  El controlador transcodifica los comandos de acuerdo con la regla MMC y los env√≠a a trav√©s del bus SDIO.  Pero tenemos que escribir un programa para la PC, por lo que los equipos nos dejan en formato SCSI.  Los prepara el controlador de dispositivo del dispositivo de almacenamiento masivo, con el que nos comunicamos a trav√©s del controlador del sistema de archivos.  ¬øEs posible mezclar solicitudes con otros dispositivos para estas solicitudes?  Vamos a hacerlo bien. <br><br><h2>  Detalles del sistema de comando SCSI </h2><br>  Si aborda el asunto formalmente, la descripci√≥n del est√°ndar SCSI est√° disponible en t10.org, pero seremos realistas.  Nadie lo leer√° voluntariamente.  M√°s precisamente, no el suyo, sino el de ellos: hay un mont√≥n de documentos abiertos y una monta√±a de documentos cerrados. Solo una necesidad extrema har√° que te sumerjas en el lenguaje complejo en el que est√° escrito el est√°ndar (esto, por cierto, se aplica al est√°ndar ATA en t13.org).  Es mucho m√°s f√°cil leer la documentaci√≥n de las unidades reales.  Est√° escrito en un lenguaje m√°s animado, y partes hipot√©ticas pero no realmente usadas est√°n recortadas.  Mientras preparaba el art√≠culo, me encontr√© con un documento bastante nuevo (2016) del <b>Manual de referencia de comandos SCSI</b> de Seagate (enlace directo <a href="https://www.seagate.com/files/staticfiles/support/docs/manual/Interface%2520manuals/100293068j.pdf">www.seagate.com/files/staticfiles/support/docs/manual/Interface%20manuals/100293068j.pdf</a> pero, como siempre, No s√© cu√°nto tiempo vivir√°).  Creo que si alguien quiere dominar este sistema de comandos, deber√≠a comenzar con este documento.  Solo recordamos que los lectores SD implementan un subconjunto a√∫n m√°s peque√±o de los comandos de esa descripci√≥n. <br><br>  Hablando muy brevemente, una unidad de comando con una longitud de 6 a 16 bytes se env√≠a a la unidad.  Se puede conectar un bloque de datos al bloque de comando desde la PC al disco, o desde el disco a la PC (el est√°ndar SCSI tambi√©n permite el intercambio bidireccional, pero para el dispositivo de almacenamiento masivo a trav√©s de USB solo se permite un bloque, lo que significa que la direcci√≥n es solo uno).  En el bloque de instrucciones, el primer byte es siempre el c√≥digo de comando.  Los bytes restantes son sus argumentos.  Las reglas para completar los argumentos se describen exclusivamente por los detalles de la implementaci√≥n del comando. <br><br><img src="https://habrastorage.org/webt/xt/1l/eb/xt1lebwoznye5dag98pwbtiuxfm.png"><br><br>  Al principio insert√© muchos ejemplos en el art√≠culo, pero luego me di cuenta de que dificultan la lectura.  Por lo tanto, sugiero a todos que comparen los campos del comando READ CAPACITY (10) de la tabla 119 del documento Seigate y los campos del comando READ (10) de la tabla 97 del mismo documento (vea el enlace de arriba).  ¬øQui√©n no encontr√≥ ninguna conexi√≥n? No se alarme.  Eso es lo que quer√≠a mostrar.  Adem√°s del campo "comando" en el byte cero, el prop√≥sito de todos los campos depende √∫nicamente de los detalles de un comando en particular.  Siempre necesita abrir el documento y estudiar el prop√≥sito de los campos restantes en √©l. <br><br>  Entonces <br><br><ul><li>  Para comunicarse con la unidad, debe formar un bloque de comandos con una longitud de 6 a 16 bytes (dependiendo del formato del comando, el n√∫mero exacto se indica en la documentaci√≥n correspondiente). </li><li>  El m√°s importante es el byte cero del bloque: es √©l quien establece el c√≥digo de comando. </li><li>  Los bytes de bloque restantes no tienen un prop√≥sito claro.  Para comprender c√≥mo completarlos, debe abrir la documentaci√≥n para un equipo espec√≠fico. </li><li>  Un bloque de datos que se puede transferir hacia o desde una unidad se puede adjuntar a un comando. </li></ul><br>  En realidad, eso es todo.  Aprendimos las reglas para emitir comandos SCSI.  Ahora podemos enviarlos, habr√≠a documentaci√≥n sobre ellos.  Pero, ¬øc√≥mo hacerlo a nivel del sistema operativo? <br><br><h2>  Comandos SCSI de Linux </h2><br><h3>  Buscar dispositivo de destino </h3><br>  Para emitir comandos, abra el dispositivo de disco.  Encontremos su nombre.  Para hacer esto, iremos exactamente de la misma manera que en el <a href="https://habr.com/ru/post/477662/">art√≠culo sobre puertos seriales</a> .  Veamos la lista de "archivos" en el <b>directorio / dev</b> (recuerde que en los dispositivos Linux tambi√©n se muestran como archivos y su lista se muestra con el mismo <b>comando ls</b> ). <br><br>  Hoy prestamos atenci√≥n al <b>disco del</b> directorio virtual: <br><br><img src="https://habrastorage.org/webt/t_/py/kj/t_pykjsq2_2gdno-u0oc9wdpltm.png"><br><br>  Nos fijamos en su contenido: <br><br><img src="https://habrastorage.org/webt/cp/yp/n_/cpypn_cslhfibis7ixhbez64q4y.png"><br><br>  ¬°Un conjunto familiar de directorios anidados!  Estamos tratando de considerar el directorio <b>by-id</b> , utilizando el <b>modificador ‚Äìl</b> del <b>comando ls</b> , que ya nos resulta familiar en el art√≠culo sobre puertos seriales: <br><br><img src="https://habrastorage.org/webt/jq/8s/zn/jq8sznkl6pimg5oxevbdp8m7l4w.png"><br><br>  Las palabras resaltadas hablan por s√≠ mismas.  Esta es una unidad que contiene la tarjeta SD interna del complejo Redd.  Genial  Ahora sabemos que el dispositivo <b>MIR_Redd_Internal_SD</b> corresponde al dispositivo <b>/ dev / sdb y / dev / sdb1</b> .  El que no tiene el n√∫mero es la unidad en s√≠, trabajaremos con √©l, y con el n√∫mero es el sistema de archivos ubicado en el medio insertado en √©l.  En t√©rminos de trabajar con una tarjeta SD, <b>/ dev / sdb</b> es el lector, y <b>/ dev / sdb1</b> es el sistema de archivos en la tarjeta insertada en √©l. <br><br><h3>  Funci√≥n del sistema operativo para emitir comandos </h3><br>  Por lo general, en cualquier sistema operativo, todas las cosas no est√°ndar con dispositivos se realizan a trav√©s de solicitudes directas al controlador.  En Linux, la funci√≥n <b>ioctl ()</b> est√° disponible para enviar tales solicitudes.  Nuestro caso no es la excepci√≥n.  Como argumento, pasamos la solicitud SG_IO descrita en el archivo de encabezado <b>sg.h.</b>  La estructura <b>sg_io_hdr_t</b> que contiene los par√°metros de solicitud tambi√©n se describe all√≠.  No dar√© la estructura completa, ya que no todos los campos deben completarse.  Dar√© solo el m√°s importante de ellos: <br><br><pre><code class="plaintext hljs">typedef struct sg_io_hdr { int interface_id; /* [i] 'S' for SCSI generic (required) */ int dxfer_direction; /* [i] data transfer direction */ unsigned char cmd_len; /* [i] SCSI command length ( &lt;= 16 bytes) */ unsigned char mx_sb_len; /* [i] max length to write to sbp */ unsigned short int iovec_count; /* [i] 0 implies no scatter gather */ unsigned int dxfer_len; /* [i] byte count of data transfer */ void * dxferp; /* [i], [*io] points to data transfer memory or scatter gather list */ unsigned char * cmdp; /* [i], [*i] points to command to perform */ unsigned char * sbp; /* [i], [*o] points to sense_buffer memory */ unsigned int timeout; /* [i] MAX_UINT-&gt;no timeout (unit: millisec) */</code> </pre> <br>  No tiene sentido describir aquellos campos que est√°n bien documentados en los comentarios ( <b>interface_id, dxfer_direction, timeout</b> ).  El art√≠culo ya est√° creciendo. <br><br>  El campo <b>cmd_len</b> contiene el n√∫mero de bytes en el bloque de comando y <b>cmdp contiene</b> un puntero a este bloque.  No puede prescindir de un comando, por lo que el n√∫mero de bytes debe ser distinto de cero (de 6 a 16). <br><br>  Los datos son opcionales.  Si lo son, la longitud del b√∫fer seleccionado se especifica en el campo <b>dxfer_len</b> , y se especifica un puntero en el campo <b>dxferp</b> .  Una unidad puede transferir f√≠sicamente menos datos que el tama√±o de b√∫fer especificado.  La direcci√≥n de transmisi√≥n se especifica en el campo <b>dxfer_direction</b> .  Los valores v√°lidos del dispositivo de almacenamiento masivo USB son: <b>SG_DXFER_NONE, SG_DXFER_TO_DEV, SG_DXFER_FROM_DEV</b> .  Hay una cosa m√°s en el archivo de encabezado, pero el est√°ndar del Dispositivo de almacenamiento masivo no permite implementarlo f√≠sicamente. <br><br>  Tambi√©n puede solicitar la devoluci√≥n de un c√≥digo de error extendido ( <b>SENSE</b> ).  Lo que se puede encontrar en el documento de Segate, secci√≥n 2.4.  La longitud del b√∫fer asignado se indica en el campo <b>mx_sb_len</b> , y el puntero al b√∫fer en s√≠ se indica en el campo <b>sbp</b> . <br><br>  Como puede ver, todo lo que mencion√© anteriormente se completa en esta estructura (adem√°s, puede obtener informaci√≥n extendida sobre el error).  Lea m√°s sobre c√≥mo trabajar con la solicitud <b>SG_IO</b> aqu√≠: <a href="http://sg.danny.cz/sg/sg_io.html">sg.danny.cz/sg/sg_io.html</a> <br><br><h3>  Enviamos un comando est√°ndar a la unidad </h3><br>  Bueno, descubrimos el formato del comando, descubrimos a qu√© dispositivo enviarlo, descubrimos a qu√© funci√≥n llamar.  Intentemos enviar alg√∫n comando est√°ndar a nuestro dispositivo.  Deje que este sea el comando para obtener el nombre de la unidad.  As√≠ es como se describe en el documento de Sigeyt: <br><br><img src="https://habrastorage.org/webt/nj/qk/ca/njqkcamj1tnhjznoczjnrdfni60.png"><br><br>  Tenga en cuenta que de acuerdo con la ideolog√≠a SCSI, todos los campos en los comandos est√°ndar se completan en notaci√≥n Big Endian, es decir, el byte m√°s alto hacia adelante.  Por lo tanto, completamos el campo con la longitud del b√∫fer no en el formato "0x80, 0x00", sino por el contrario - "0x00, 0x80".  Pero esto est√° en los comandos est√°ndar.  En no est√°ndar todo es posible, siempre debe consultar la descripci√≥n.  En realidad, solo el c√≥digo de comando ( <b>12h</b> ) y la longitud que tenemos que completar.  Solicitaremos una p√°gina cero, y los campos restantes est√°n reservados, desactualizados o predeterminados a cero.  As√≠ que ll√©nalos todos con ceros. <br><br><div class="spoiler">  <b class="spoiler_title">Hacemos un programa que da este comando:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdio&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; // open #include &lt;unistd.h&gt; // close #include &lt;sys/ioctl.h&gt; #include &lt;scsi/scsi.h&gt; #include &lt;scsi/sg.h&gt; int main() { printf("hello from SdAccessTest!\n"); int s_fd = open("/dev/sdb", O_NONBLOCK | O_RDWR); if (s_fd &lt; 0) { printf("Cannot open file\n"); return -1; } sg_io_hdr_t header; memset(&amp;header;, 0, sizeof(header)); uint8_t cmd12h[] = { 0x12,0x00,0x00,0x00,0x80,0x00}; uint8_t data[0x80]; uint8_t sense[0x80]; header.interface_id = 'S'; //  'S' //  header.cmd_len = sizeof(cmd12h); header.cmdp = cmd12h; //  header.dxfer_len = sizeof(data); header.dxferp = data; header.dxfer_direction = SG_DXFER_TO_FROM_DEV; //     header.mx_sb_len = sizeof(sense); header.sbp = sense; // header.timeout = 100; // 100  int res = ioctl(s_fd, SG_IO, &amp;header;); close(s_fd); return 0; }</code> </pre><br></div></div><br><br>  C√≥mo ejecutar dichos programas en un dispositivo Redd remoto, ya lo hemos discutido en uno de los <a href="https://habr.com/ru/post/456008/">art√≠culos anteriores</a> .  Es cierto, al iniciarlo por primera vez, inmediatamente recib√≠ un error al llamar a la funci√≥n <b>open ()</b> .  Result√≥ que el usuario por defecto no tiene suficientes derechos para abrir dispositivos de disco.  Cu√°l de m√≠ es un especialista en Linux, escrib√≠ muchas veces, pero en la red logr√© encontrar que para resolver este problema, puede cambiar los derechos de acceso al dispositivo emitiendo el comando: <br><br>  <b>sudo chmod 666 / dev / sdb</b> <br><br>  Sin embargo, mi jefe (y √©l es un gran especialista en este sistema operativo) m√°s tarde not√≥ que la soluci√≥n es v√°lida hasta que se reinicie el sistema operativo.  Para obtener los derechos con seguridad, debe agregar el usuario al grupo de <b>discos</b> . <br><br>  Cualquiera de estos dos caminos vamos, pero despu√©s de que todo haya funcionado, coloque un punto de interrupci√≥n en la l√≠nea <b>close (s_fd);</b>  e inspeccione los resultados cuando se logre en el entorno de desarrollo (dado que el programa no es de un solo d√≠a, lo que significa que no tenemos tiempo para invertir tiempo y esfuerzo en insertar mapeadores, si el entorno de desarrollo puede mostrarnos todo).  El valor de <b>res</b> es cero.  Entonces el equipo trabaj√≥ sin errores. <br><br><img src="https://habrastorage.org/webt/ih/2o/40/ih2o40ujbpv2p0qk9m_qiwdw9do.png"><br><br>  ¬øQu√© vino al b√∫fer?  Cuando ingres√© la palabra <b>datos</b> en la direcci√≥n del vertedero, me dijeron que no pod√≠an calcular el valor, ten√≠a que ingresar <b>&amp; data;</b>  .  Es extra√±o, porque los <b>datos</b> son un puntero, cuando la depuraci√≥n en Windows todo funciona, pero solo noto este hecho, funciona as√≠: mira el resultado obtenido de esta manera: <br><br><img src="https://habrastorage.org/webt/bj/tk/ae/bjtkaehd8ucyzdufbdsn1392tgm.png"><br><br>  As√≠ es, nos devolvieron el nombre y la revisi√≥n de la unidad.  Puede encontrar m√°s informaci√≥n sobre el formato de la estructura resultante en el documento de Segate (secci√≥n 3.6.2, tabla 59).  El b√∫fer de detecci√≥n no se llen√≥, pero la descripci√≥n IOCTL de la solicitud dice que se llena solo cuando se produce un error que devuelve algo en este b√∫fer.  Literalmente: los <b>datos de detecci√≥n (solo se usan cuando el "estado" es CHECK CONDITION o (driver_status &amp; DRIVER_SENSE) es verdadero)</b> . <br><br><h2>  Formato de comando personalizado para la unidad SD interna de Redd </h2><br>  Ahora que no solo hemos estudiado la descripci√≥n seca del est√°ndar, sino que tambi√©n hemos intentado todo en la pr√°ctica, despu√©s de experimentar lo que es un bloque de comandos, ya podemos mostrar el formato de comando con el que puede llamar a funciones no est√°ndar que se "flashean" al controlador STM32 en la placa compleja.  Seleccion√© el c√≥digo de comando desde el principio del rango de comandos <b>espec√≠ficos</b> del <b>proveedor</b> .  Es igual a 0xC0.  Tradicionalmente, en las descripciones de los comandos SCSI, escriba <b>C0h</b> .  La longitud del comando siempre es de 10 bytes.  El formato del equipo est√° unificado y se presenta en la tabla a continuaci√≥n. <br><br><div class="scrollable-table"><table><tbody><tr><td>  <b>Byte</b> </td><td>  <b>Cita</b> </td></tr><tr><td>  0 0 </td><td>  C√≥digo de comando C0h </td></tr><tr><td>  1 </td><td>  C√≥digo de subcomando </td></tr><tr><td>  2 </td><td rowspan="4">  Argumento arg1.  Establecer en notaci√≥n Little Endian (byte bajo hacia adelante) </td></tr><tr><td>  3 </td></tr><tr><td>  4 4 </td></tr><tr><td>  5 5 </td></tr><tr><td>  6 6 </td><td rowspan="4">  Argumento arg2.  Establecer en notaci√≥n Little Endian (byte bajo hacia adelante) </td></tr><tr><td>  7 7 </td></tr><tr><td>  8 </td></tr><tr><td>  9 9 </td></tr></tbody></table></div><br>  Como puede ver, los argumentos se dan en la notaci√≥n Little Endian.  Esto le permitir√° describir el comando en forma de estructura y acceder a sus campos directamente, sin recurrir a la funci√≥n de permutaci√≥n de bytes.  Los problemas de alineaci√≥n (las palabras dobles en la estructura tienen desplazamientos que no son m√∫ltiplos de cuatro) en arquitecturas x86 y x64 no valen la pena. <br><br>  Los c√≥digos de subcomando se describen mediante la siguiente enumeraci√≥n: <br><pre> <code class="plaintext hljs">enum vendorSubCommands { subCmdSdEnable = 0, // 00 Switch SD card to PC or Outside subCmdSdPower, // 01 Switch Power of SD card On/Off subCmdSdReinit, // 02 Reinitialize SD card (for example, after Power Cycle) subCmdSpiFlashEnable, // 03 Switch SPI Flash to PC or Outside subCmdSpiFlashWritePage, // 04 Write Page to SPI Flash subCmdSpiFlashReadPage, // 05 Read Page from SPI Flash subCmdSpiFlashErasePage,// 06 Erase Pages on SPI Flash (4K block) subCmdRelaysOn, // 07 Switch relays On by mask subCmdRelaysOff, // 08 Switch relays off by mask subCmdRelaysSet, // 09 Set state of all relays by data subCmdFT4222_1_Reset, // 0A Activate Reset State or switch chip to normal mode subCmdFT4222_2_Reset, // 0B Activate Reset State or switch chip to normal mode subCmdFT4222_3_Reset, // 0C Activate Reset State or switch chip to normal mode subCmdFT4232_Reset, // 0D Activate Reset State or switch chip to normal mode subCmdFT2232_Reset, // 0E Activate Reset State or switch chip to normal mode subCmdMAX3421_Reset, // 0F Activate Reset State or switch chip to normal mode subCmdFT4222_1_Cfg, // 10 Write to CFG pins of FT4222_1 subCmdFT4222_2_Cfg, // 11 Write to CFG pins of FT4222_2 subCmdFT4222_3_Cfg, // 12 Write to CFG pins of FT4222_3 };</code> </pre><br>  Se pueden dividir en grupos. <br><br><h3>  Cambiar dispositivos a modos internos y externos </h3><br>  Los <b>comandos</b> <b>subCmdSdEnable</b> y <b>subCmdSpiFlashEnable</b> cambian la tarjeta SD y el flash SPI, respectivamente.  El par√°metro <b>arg1</b> pasa uno de los siguientes valores: <br><br><pre> <code class="plaintext hljs">enum enableMode { enableModeToPC = 0, enableModeOutside };</code> </pre> <br>  Por defecto, ambos dispositivos est√°n conectados a una PC. <br><br><h3>  Cambio de potencia </h3><br>  El protocolo SDIO requiere mucha manipulaci√≥n durante la inicializaci√≥n.  A veces es √∫til restablecer la tarjeta SD a su estado inicial (por ejemplo, al cambiar sus l√≠neas a un conector externo).  Para hacer esto, apague, luego encienda su energ√≠a.  Esto se puede hacer usando el <b>comando subCmdSdPower</b> .  En el argumento <b>arg1,</b> se pasa uno de los siguientes valores: 0 - apagado, 1 - encendido.  Recuerde dar tiempo para descargar los condensadores en la l√≠nea de alimentaci√≥n. <br><br>  Despu√©s de encender la alimentaci√≥n, la tarjeta, si est√° conectada a la PC, debe reiniciarse.  Para hacer esto, use el comando <b>subCmdSdReinit</b> (no tiene argumentos). <br><br><h3>  Trabajar con unidad flash SPI </h3><br>  Si la tarjeta SD est√° conectada al sistema como una unidad completa, el chip de acceso en la versi√≥n actual es bastante limitado.  Puede acceder solo a sus p√°ginas individuales (256 bytes) y solo una a la vez.  La cantidad de memoria en el microcircuito es tal que incluso cuando se trabaja en la p√°gina, el proceso no tomar√° mucho tiempo de todos modos, pero este enfoque simplifica enormemente el "firmware" del microcontrolador. <br><br>  El comando <b>subCmdSpiFlashReadPage</b> lee la p√°gina.  La direcci√≥n se especifica en el par√°metro arg1, el n√∫mero de p√°ginas a transmitir en el par√°metro arg2.  Pero en la versi√≥n actual, el n√∫mero de p√°ginas debe ser igual a uno.  El comando devolver√° 256 bytes de datos. <br><br>  Reflejado para ella est√° el comando <b>subCmdSpiFlashWritePage</b> .  Los argumentos a favor de ella se completan con el mismo principio.  La direcci√≥n de la transferencia de datos es al dispositivo. <br><br>  La peculiaridad de la memoria flash es que solo los bits individuales se pueden reemplazar con bits cero durante la grabaci√≥n.  Para devolverlos a un solo valor, las p√°ginas deben borrarse.  Hay un comando <b>subCmdSpiFlashErasePage</b> para <b>esto</b> .  Es cierto que, debido a las caracter√≠sticas del microcircuito utilizado, no se establece una sola p√°gina en el par√°metro <b>arg1</b> que se borra, sino un bloque de 4 kilobytes que lo contiene. <br><br><h3>  Gesti√≥n de rel√©s de estado s√≥lido </h3><br>  El complejo tiene seis rel√©s de estado s√≥lido.  Hay tres equipos para gestionarlos. <br><br>  <b>subCmdRelaysSet</b> : establece el valor de los seis rel√©s simult√°neamente.  En el par√°metro <b>arg1,</b> se pasa <b>un</b> valor, cada bit del cual corresponde a su propio rel√© (bit cero - rel√© con √≠ndice 0, primer bit con √≠ndice 1, etc.).  Un solo valor de bit cierra el rel√©, un valor cero hace que se abra. <br><br>  Este m√©todo de operaci√≥n es bueno cuando todos los rel√©s funcionan como un solo grupo.  Si funcionan independientemente el uno del otro, con este enfoque debe iniciar una variable de b√∫fer que almacena el valor de estado de todos los rel√©s.  Si diferentes programas son controlados por diferentes programas, el problema de almacenar el valor agregado se vuelve extremadamente agudo.  En este caso, puede usar otros dos comandos: <br><br>  <b>subCmdRelaysOn</b> : habilita los rel√©s seleccionados por m√°scara.  Se habilitar√°n los rel√©s que corresponden a los bits unitarios en el argumento <b>arg1</b> .  Los rel√©s que corresponden a ceros en la m√°scara conservar√°n su estado actual. <br><br>  El comando <b>subCmdRelaysOff que lo refleja</b> apagar√° los rel√©s seleccionados por m√°scara.  Los rel√©s que corresponden a los bits individuales en el argumento <b>arg1</b> se <b>apagar√°n</b> .  Los rel√©s que corresponden a ceros en la m√°scara conservar√°n su estado actual. <br><br><h3>  Restablecer controladores FTDI y Maxim </h3><br>  Para enviar se√±ales de reinicio a los microcircuitos FTDI y Maxim, se <b>usa</b> el grupo de comandos <b>subCmdFT4222_1_Reset</b> , <b>subCmdFT4222_2_Reset</b> , <b>subCmdFT4222_3_Reset</b> , <b>subCmdFT4232_Reset</b> , <b>subCmdFT2232_Reset</b> y <b>subCmdMAX3421_</b> .  A partir de sus nombres, puede ver qu√© chips controlan mediante se√±ales de reinicio.  Los puentes FT4222, como consideramos anteriormente, son dos en el circuito (sus √≠ndices son 1 y 2), otro puente FT4222 transfiere datos al chip MAX3421, que consideraremos en el pr√≥ximo art√≠culo. <br><br>  El par√°metro <b>arg1</b> pasa uno de los siguientes valores: <br><br><pre> <code class="plaintext hljs">enum ResetState { resetStateActive =0, resetStateNormalOperation };</code> </pre> <br>  Por defecto, todos los puentes est√°n en condiciones normales de trabajo.  Como ya se se√±al√≥ en un <a href="https://habr.com/ru/post/483724/">art√≠culo anterior</a> , nosotros mismos no estamos seguros de si se necesita esta funcionalidad, pero cuando no hay acceso directo al dispositivo, es mejor poder restablecer de forma remota todo y todo. <br><br><h3>  Cambio de l√≠neas de configuraci√≥n de chips FT4222 </h3><br>  Los chips FT4222 tienen cuatro modos.  Es poco probable que alguien necesite un modo que no sea "00", pero si de repente lo necesita, puede usar los <b>comandos subCmdFT4222_1_Cfg</b> , <b>subCmdFT4222_2_Cfg</b> y <b>subCmdFT4222_3_Cfg</b> para <b>cambiar</b> el primer, segundo y tercer chip.  El valor de las l√≠neas CFG0 y CFG1 se establece en los dos bits inferiores del par√°metro <b>arg1</b> . <br><br><h2>  Experiencia pr√°ctica en la emisi√≥n de comandos al controlador STM32 </h2><br>  Para probar el material te√≥rico obtenido en la pr√°ctica, intentaremos cambiar la tarjeta SD.  Para hacer esto, emita el comando <b>subCmdSdEnable</b> con el c√≥digo 0x00 con el argumento <b>enableModeOutside</b> con el c√≥digo 0x01.  Genial  Reescribimos el programa de la experiencia pasada de la siguiente manera. <br><br><div class="spoiler">  <b class="spoiler_title">Programa reescrito:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdio&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; // open #include &lt;unistd.h&gt; // close #include &lt;sys/ioctl.h&gt; #include &lt;scsi/scsi.h&gt; #include &lt;scsi/sg.h&gt; int main() { printf("hello from SdAccessTest!\n"); int s_fd = open("/dev/sdb", O_NONBLOCK | O_RDWR); if (s_fd &lt; 0) { printf("Cannot open file\n"); return -1; } sg_io_hdr_t header; memset(&amp;header;, 0, sizeof(header)); uint8_t cmdSdToOutside[] = { 0xC0,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00 }; uint8_t cmdSdToPC[] = { 0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 }; uint8_t sense[32]; memset(sense, 0, sizeof(sense)); header.interface_id = 'S'; //  'S' //  header.cmd_len = sizeof(cmdSdToOutside); header.cmdp = cmdSdToOutside; //  ( ) header.dxfer_len = 0; header.dxferp = 0; header.dxfer_direction = SG_DXFER_NONE; //     header.mx_sb_len = sizeof(sense); header.sbp = sense; // header.timeout = 100; // 100  int res = ioctl(s_fd, SG_IO, &amp;header;); //   header.cmdp = cmdSdToPC; res = ioctl(s_fd, SG_IO, &amp;header;); close(s_fd); return 0; }</code> </pre><br></div></div><br>  Cambiamos la longitud del comando a diez bytes y eliminamos el bloque de datos.  Bueno, escribieron el c√≥digo de comando con argumentos, seg√∫n sea necesario.  De lo contrario, todo sigue igual.  Comenzamos ... Y ... Nada funciona.  La funci√≥n <b>ioctl ()</b> devuelve un error.  El motivo se describe en el <b>documento de</b> comando <b>SG_IO</b> .  El hecho es que le damos al comando espec√≠fico del proveedor <b>C0h</b> , y lo siguiente se dice sobre ellos literalmente: <br><blockquote>  Cualquier otro comando SCSI (c√≥digo de operaci√≥n) no mencionado para el controlador sg necesita O_RDWR.  Cualquier otro comando SCSI (c√≥digo de operaci√≥n) no mencionado para la capa de bloques SG_IO ioctl necesita un usuario con capacidad CAP_SYS_RAWIO. </blockquote><br>  Como me explic√≥ el jefe (solo estoy volviendo a contar sus palabras), los valores de <b>capacidades</b> se asignan a un archivo ejecutable.  Por esta raz√≥n, tuve que rastrear desde el entorno de desarrollo iniciando sesi√≥n como <b>root</b> .  No es la mejor soluci√≥n, pero al menos algo.  De hecho, en Windows, la solicitud <b>IOCTL_SCSI_PASS_THROUGH_DIRECT</b> tambi√©n requiere derechos de administrador.  Quiz√°s en los comentarios alguien le dar√° consejos sobre c√≥mo resolver el problema de rastreo sin pasos tan dr√°sticos, pero puede ejecutar el programa ya escrito sin <b>root</b> , si registra las <b>capacidades</b> correctas <b>para ello</b> .  Mientras tanto, cambie el nombre de usuario en el entorno de desarrollo y establezca un punto de interrupci√≥n en la l√≠nea: <br><br><pre> <code class="plaintext hljs">int res = ioctl(s_fd, SG_IO, &amp;header;);</code> </pre> <br>  y antes de llamar a la funci√≥n <b>ioctl ()</b> , miramos la lista de dispositivos de almacenamiento: <br><br><img src="https://habrastorage.org/webt/ys/ef/ls/yseflsambpnn83pbywoqfuazoqi.png"><br><br>  Llame a <b>ioctl ()</b> y mire la lista nuevamente: <br><br><img src="https://habrastorage.org/webt/ro/2g/33/ro2g331krziu9uslxuzo28hylxa.png"><br><br>  El dispositivo <b>/ dev / sdb</b> permaneci√≥ (en t√©rminos generales, este es el lector de tarjetas SD), y <b>/ dev / sdb1</b> desapareci√≥.  Este dispositivo corresponde al sistema de archivos en los medios.  El operador se desconect√≥ de la computadora; ya no era visible.  Seguimos rastreando.  Despu√©s de llamar a la segunda funci√≥n <b>ioctl ()</b> , nuevamente miramos la lista de dispositivos: <br><br><img src="https://habrastorage.org/webt/rd/wi/zx/rdwizxqu4amrqeuhzghnrptvkly.png"><br><br>  La tarjeta SD se vuelve a conectar al sistema, por lo que <b>/ dev / sdb1</b> vuelve a estar en su lugar.  En realidad, aprendimos c√≥mo emitir comandos espec√≠ficos del proveedor y administrar un dispositivo basado en el microcontrolador STM32 en el complejo Redd.  Otros comandos se dejar√°n a los lectores para su estudio independiente.  Puede controlar el funcionamiento de algunos de ellos de manera similar.  Si alg√∫n chip <b>ftdi entra</b> en un estado de reinicio, el dispositivo correspondiente desaparecer√° del sistema.  El funcionamiento del rel√© y el control de las patas de la configuraci√≥n deber√°n controlarse mediante instrumentos de medici√≥n.  Bueno, puede verificar el trabajo con una unidad flash escribiendo p√°ginas con su control de lectura posterior. <br><br><h2>  Conclusi√≥n </h2><br>  Examinamos dos grandes temas que no est√°n relacionados con los FPGA en el complejo Redd.  El tercero permaneci√≥: trabajar con el chip MAX3421, que permite implementar dispositivos USB 2.0 FS.  De hecho, tambi√©n hay hosts, pero hay muchos hosts y la placa base.  La funcionalidad del dispositivo permitir√° que el complejo pretenda ser una unidad flash USB (para enviar actualizaciones de "firmware"), un teclado USB (para controlar unidades externas), etc.  Consideraremos este tema en el pr√≥ximo art√≠culo. </div></div><p>Source: <a href="https://habr.com/ru/post/484706/">https://habr.com/ru/post/484706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../484688/index.html">Nos estamos acercando al l√≠mite de la potencia inform√°tica: necesitamos nuevos programadores</a></li>
<li><a href="../484690/index.html">Seminario, conferencia, mitap: estudio de las estad√≠sticas de 18,000 eventos.</a></li>
<li><a href="../484692/index.html">Vitamina C: ¬ønecesito tomar suplementos o es una medida comercial?</a></li>
<li><a href="../484700/index.html">Java 14: vista previa de registros</a></li>
<li><a href="../484702/index.html">Alternativas de Prestashop en 2020: principales plataformas de comercio electr√≥nico</a></li>
<li><a href="../484708/index.html">Richard Hamming "Cap√≠tulo inexistente": ¬øC√≥mo sabemos lo que sabemos (versi√≥n completa)</a></li>
<li><a href="../484710/index.html">Romper las reglas de la recolecci√≥n de basura de Unity</a></li>
<li><a href="../484712/index.html">Compatibilidad binaria reactiva: c√≥mo la proporcionamos</a></li>
<li><a href="../484716/index.html">Deja de llamar a todo AI</a></li>
<li><a href="../484718/index.html">Las impresoras modernas HP se niegan a trabajar sin suscripci√≥n de tinta</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>