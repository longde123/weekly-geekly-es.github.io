<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👏🏽 👨‍👨‍👦‍👦 👨🏾‍🍳 Shaders de juegos en 3D para principiantes 🦋 🎚️ 🤷🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¿Quieres aprender a agregar texturas, iluminación, sombras, mapas normales, objetos brillantes, oclusión ambiental y otros efectos a tu juego 3D? Geni...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Shaders de juegos en 3D para principiantes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453300/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba2/494/983/ba2494983fe869e14d259f717aa8fc19.gif" alt="imagen"></div><br>  ¿Quieres aprender a agregar texturas, iluminación, sombras, mapas normales, objetos brillantes, oclusión ambiental y otros efectos a tu juego 3D?  Genial  Este artículo presenta un conjunto de técnicas de sombreado que pueden elevar el nivel de los gráficos de su juego a nuevas alturas.  Explico cada técnica de tal manera que puede aplicar / transferir esta información en cualquier pila de herramientas, ya sea Godot, Unity u otra cosa. <br><br>  Como "pegamento" entre los sombreadores, decidí usar el magnífico motor de juegos Panda3D y OpenGL Shading Language (GLSL).  Si usa la misma pila, obtendrá una ventaja adicional: aprenderá a usar técnicas de sombreado específicamente en Panda3D y OpenGL. <br><a name="habracut"></a><br><h2>  Preparación </h2><br>  A continuación se muestra el sistema que utilicé para desarrollar y probar el código de muestra. <br><br><h3>  Miercoles </h3><br>  El código de muestra se desarrolló y probó en el siguiente entorno: <br><br><ul><li>  Linux manjaro 4.9.135-1-MANJARO </li><li>  Cadena de renderizador OpenGL: GeForce GTX 970 / PCIe / SSE2 </li><li>  Cadena de versión OpenGL: 4.6.0 NVIDIA 410.73 </li><li>  g ++ (GCC) 8.2.1 20180831 </li><li>  Panda3D 1.10.1-1 </li></ul><br><h3>  Materiales </h3><br>  Cada uno de los materiales de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Blender</a> utilizados para crear <code>mill-scene.egg</code> tiene dos texturas. <br><br>  La primera textura es un mapa normal, la segunda es un mapa difuso.  Si un objeto usa las normales de sus vértices, entonces se usa un mapa normal "azul claro".  Debido al hecho de que todos los modelos tienen las mismas tarjetas en las mismas posiciones, los sombreadores se pueden generalizar y aplicar al nodo raíz del gráfico de escena. <br><br>  Tenga en cuenta que el gráfico de escena es una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">característica de</a> la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">implementación del</a> motor Panda3D. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19f/9c0/14f/19f9c014f06aee0e2204aa95f87c6306.png"></div><br>  Aquí hay un mapa normal de un color que contiene solo el color <code>[red = 128, green = 128, blue = 255]</code> . <br><br>  Este color indica la unidad normal, indicando en la dirección positiva del eje z <code>[0, 0, 1]</code> . <br><br><pre> <code class="cpp hljs">[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] = [ round((<span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span>) , round((<span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span>) , round((<span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span>) ] = [<span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>] = [ round(<span class="hljs-number"><span class="hljs-number">128</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) , round(<span class="hljs-number"><span class="hljs-number">128</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) , round(<span class="hljs-number"><span class="hljs-number">255</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) ] = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br>  Aquí vemos la unidad normal <code>[0, 0, 1]</code> convertida a un color azul claro <code>[128, 128, 255]</code> , y el azul sólido convertido a una unidad normal. <br><br>  Esto se describe con más detalle en la sección sobre técnicas de superposición de mapas normales. <br><br><h3>  Panda3d </h3><br>  En este ejemplo de código, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Panda3D se</a> usa como el "pegamento" entre los sombreadores.  Esto no afecta las técnicas que se describen a continuación, es decir, puede usar la información estudiada aquí en cualquier pila o motor de juego seleccionado.  Panda3D ofrece ciertas comodidades.  En el artículo hablé sobre ellos, para que pueda encontrar su contraparte en su pila o recrearlos usted mismo si no están en la pila. <br><br>  Vale la pena considerar que los valores <code>gl-coordinate-system default</code> , <code>textures-power-2 down</code> y <code>textures-auto-power-2 1</code> se agregaron a <code>config.prc</code> .  No están contenidos en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">configuración</a> estándar de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Panda3D</a> . <br><br>  Por defecto, Panda3D usa un sistema de coordenadas diestro con un eje z hacia arriba, mientras que OpenGL usa un sistema de coordenadas diestro con un eje y hacia arriba. <br><br>  <code>gl-coordinate-system default</code> le permite deshacerse de las transformaciones entre dos sistemas de coordenadas dentro de los sombreadores. <br><br>  <code>textures-auto-power-2 1</code> nos permite usar tamaños de textura que no son potencias de dos, si el sistema los admite. <br><br>  Esto es conveniente al realizar SSAO o implementar otras técnicas dentro de una pantalla / ventana, ya que el tamaño de la pantalla / ventana generalmente no es una potencia de dos. <br><br>  <code>textures-power-2 down</code> reduce el tamaño de las texturas a una potencia de dos si el sistema solo admite texturas con tamaños iguales a potencias de dos. <br><br><h2>  Código de ejemplo de compilación </h2><br>  Si desea ejecutar el código de muestra, primero debe compilarlo. <br><br>  Panda3D se ejecuta en Linux, Mac y Windows. <br><br><h3>  Linux </h3><br>  Comience <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">instalando el</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">SDK Panda3D</a> para su distribución. <br><br>  Encuentra dónde están los encabezados y bibliotecas de Panda3D.  Lo más probable es que se encuentren en <code>/usr/include/panda3d/</code> y en <code>/usr/lib/panda3d/</code> . <br><br>  Luego clone este repositorio y navegue a su directorio. <br><br> <code>git clone https://github.com/lettier/3d-game-shaders-for-beginners.git <br> cd 3d-game-shaders-for-beginners</code> <br> <br>  Ahora compile el código fuente en un archivo de salida. <br><br> <code>g++ \ <br> -c main.cxx \ <br> -o 3d-game-shaders-for-beginners.o \ <br> -std=gnu++11 \ <br> -O2 \ <br> -I/usr/include/python2.7/ \ <br> -I/usr/include/panda3d/</code> <br> <br>  Después de crear el archivo de salida, cree un archivo ejecutable asociando el archivo de salida con sus dependencias. <br><br> <code>g++ \ <br> 3d-game-shaders-for-beginners.o \ <br> -o 3d-game-shaders-for-beginners \ <br> -L/usr/lib/panda3d \ <br> -lp3framework \ <br> -lpanda \ <br> -lpandafx \ <br> -lpandaexpress \ <br> -lp3dtoolconfig \ <br> -lp3dtool \ <br> -lp3pystub \ <br> -lp3direct \ <br> -lpthread</code> <br> <br>  Consulte el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">manual de Panda3D para</a> más información. <br><br><h3>  Mac </h3><br>  Comience instalando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Panda3D SDK</a> para Mac. <br><br>  Encuentra dónde están los encabezados y las bibliotecas de Panda3D. <br><br>  Luego clone el repositorio y navegue a su directorio. <br><br> <code>git clone https://github.com/lettier/3d-game-shaders-for-beginners.git <br> cd 3d-game-shaders-for-beginners</code> <br> <br>  Ahora compile el código fuente en un archivo de salida.  Debe encontrar dónde están los directorios de inclusión en Python 2.7 y Panda3D. <br><br> <code>clang++ \ <br> -c main.cxx \ <br> -o 3d-game-shaders-for-beginners.o \ <br> -std=gnu++11 \ <br> -g \ <br> -O2 \ <br> -I/usr/include/python2.7/ \ <br> -I/Developer/Panda3D/include/</code> <br> <br>  Después de crear el archivo de salida, cree un archivo ejecutable asociando el archivo de salida con sus dependencias. <br><br>  Necesita encontrar dónde se encuentran las bibliotecas Panda3D. <br><br> <code>clang++ \ <br> 3d-game-shaders-for-beginners.o \ <br> -o 3d-game-shaders-for-beginners \ <br> -L/Developer/Panda3D/lib \ <br> -lp3framework \ <br> -lpanda \ <br> -lpandafx \ <br> -lpandaexpress \ <br> -lp3dtoolconfig \ <br> -lp3dtool \ <br> -lp3pystub \ <br> -lp3direct \ <br> -lpthread</code> <br> <br>  Consulte el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">manual de Panda3D para</a> más información. <br><br><h3>  Ventanas </h3><br>  Comience <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">instalando</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Panda3D SDK</a> para Windows. <br><br>  Encuentra dónde están los encabezados y bibliotecas de Panda3D. <br><br>  Clone este repositorio y navegue a su directorio. <br><br> <code>git clone https://github.com/lettier/3d-game-shaders-for-beginners.git <br> cd 3d-game-shaders-for-beginners</code> <br> <br>  Consulte el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">manual de Panda3D para</a> más información. <br><br><h2>  Lanzar demo </h2><br>  Después de compilar el código de muestra, puede ejecutar el ejecutable o la demostración.  Así es como se ejecutan en Linux o Mac. <br><br> <code>./3d-game-shaders-for-beginners</code> <br> <br>  Y entonces se ejecutan en Windows: <br><br> <code>3d-game-shaders-for-beginners.exe</code> <br> <br><h3>  Control del teclado </h3><br>  La demostración tiene un control de teclado que le permite mover la cámara y cambiar el estado de varios efectos. <br><br><h3>  Movimiento </h3><br><ul><li>  <code>w</code> - muévete profundamente en la escena. </li><li>  <code>a</code> - gira la escena en el sentido de las agujas del reloj. </li><li>  <code>s</code> : aléjate de la escena. </li><li>  <code>d</code> - gira la escena en sentido antihorario. </li></ul><br><h3>  Efectos conmutables </h3><br><ul><li>  <code>y</code> - habilitar SSAO. </li><li>  <code>Shift</code> + <code>y</code> - deshabilita SSAO. </li><li>  <code>u</code> - inclusión de circuitos. </li><li>  <code>Shift</code> + <code>u</code> : deshabilita los contornos. </li><li>  <code>i</code> - habilita la floración. </li><li>  <code>Shift</code> + <code>i</code> : deshabilita la floración. </li><li>  <code>o</code> - habilitar mapas normales. </li><li>  <code>Shift</code> + <code>o</code> : deshabilita los mapas normales. </li><li>  <code>p</code> - inclusión de niebla. </li><li>  <code>Shift</code> + <code>p</code> - apaga la niebla. </li><li>  <code>h</code> - la inclusión de la profundidad de campo. </li><li>  <code>Shift</code> + <code>h</code> - deshabilita la profundidad de campo. </li><li>  <code>j</code> : habilitar la posterización. </li><li>  <code>Shift</code> + <code>j</code> - deshabilita la posterización </li><li>  <code>k</code> : habilita la pixelación. </li><li>  <code>Shift</code> + <code>k</code> : deshabilita la pixelización. </li><li>  <code>l</code> - afilado. </li><li>  <code>Shift</code> + <code>l</code> : deshabilita la nitidez. </li><li>  <code>n</code> inclusión de grano de película. </li><li>  <code>Shift</code> + <code>n</code> - deshabilita el grano de la película. </li></ul><br><h2>  Sistema de referencia </h2><br>  Antes de comenzar a escribir sombreadores, debe familiarizarse con los siguientes sistemas de referencia o sistemas de coordenadas.  Todos ellos se reducen de donde se toman las coordenadas actuales del origen de la referencia <code>(0, 0, 0)</code> .  Tan pronto como lo descubramos, podemos transformarlos usando algún tipo de matriz u otro espacio vectorial.  Por lo general, si la salida de un sombreador no se ve bien, entonces la causa son los sistemas de coordenadas confusos. <br><br><h3>  Modelo </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e06/9ce/863/e069ce863ffc7bd3b94394dc20b25687.gif"></div><br>  El sistema de coordenadas del modelo u objeto es relativo al origen del modelo.  En los programas de modelado tridimensional, por ejemplo, en Blender, generalmente se coloca en el centro del modelo. <br><br><h3>  El mundo </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/9de/1f7/d0a9de1f741bb90174efd93d174ef1f9.gif"></div><br>  El espacio mundial es relativo al origen de la escena / nivel / universo que creaste. <br><br><h3>  Revisar </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd2/15b/b6e/bd215bb6ee79a6904eba3f6ad4ff56d3.gif"></div><br>  El espacio de coordenadas de la vista es relativo a la posición activa de la cámara. <br><br><h3>  Recorte </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d77/505/a34/d77505a349f37a695f77625400857d58.png"></div><br>  Espacio de recorte relativo al centro del marco de la cámara.  Todas las coordenadas en él son homogéneas y están en el intervalo <code>(-1, 1)</code> .  X e y son paralelos a la película de la cámara, y la coordenada z es la profundidad. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc7/0be/d7c/dc70bed7ca78c39cc9f538b127d7176e.gif"></div><br>  Todos los vértices que no están dentro de los límites de la pirámide de visibilidad o el volumen de visibilidad de la cámara se cortan o descartan.  Vemos cómo sucede esto con un cubo truncado detrás por el plano lejano de la cámara, y con un cubo ubicado a un lado. <br><br><h3>  Pantalla </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5b/47d/336/e5b47d33660b9c1744faa12fec8ef256.png"></div><br>  El espacio de la pantalla es (generalmente) relativo a la esquina inferior izquierda de la pantalla.  X cambia de cero al ancho de la pantalla.  Y cambia de cero a la altura de la pantalla. <br><br><h2>  GLSL </h2><br>  En lugar de trabajar con una canalización de funciones fijas, utilizaremos una canalización de representación de GPU programable.  Como es programable, nosotros mismos debemos pasarle el código del programa en forma de sombreadores.  Un sombreador es un programa (generalmente pequeño) creado con una sintaxis similar al lenguaje C. Una canalización de representación de GPU programable consta de varios pasos que se pueden programar utilizando sombreadores.  Los diferentes tipos de sombreadores incluyen sombreadores de vértices, sombreadores de teselación, sombreadores geométricos, de fragmentos y computacionales.  Para usar las técnicas descritas en el artículo, es suficiente para nosotros usar vértices y fragmentos <br>  etapas <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 void main() {}</span></span></code> </pre> <br>  Aquí está el sombreador GLSL mínimo, que consta del número de versión GLSL y la función principal. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform mat4 p3d_ModelViewProjectionMatrix; in vec4 p3d_Vertex; void main() { gl_Position = p3d_ModelViewProjectionMatrix * p3d_Vertex; }</span></span></code> </pre> <br>  Aquí está el sombreador de vértices truncados GLSL, que transforma el vértice de entrada en espacio de recorte y muestra esta nueva posición como una posición de vértice uniforme. <br><br>  El procedimiento <code>main</code> no devuelve nada, porque es <code>void</code> , y la variable <code>gl_Position</code> es la salida en línea. <br><br>  Dos palabras clave que vale la pena mencionar son: <code>uniform</code> y <code>in</code> . <br><br>  La palabra clave <code>uniform</code> significa que esta variable global es la misma para todos los vértices.  Panda3D establece <code>p3d_ModelViewProjectionMatrix</code> y para cada vértice es la misma matriz. <br><br>  La palabra clave <code>in</code> significa que esta variable global se pasa al sombreador.  Un sombreador de vértices obtiene cada vértice en el que se compone la geometría, al que se adjunta un sombreador de vértices. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 out vec4 fragColor; void main() { fragColor = vec4(0, 1, 0, 1); }</span></span></code> </pre> <br>  Aquí está el sombreador de fragmentos GLSL recortado, que muestra el verde opaco como el color del fragmento. <br><br>  No olvide que un fragmento afecta solo a un píxel de la pantalla, pero varios fragmentos pueden afectar a un píxel. <br><br>  Presta atención a la palabra clave out. <br><br>  La palabra clave <code>out</code> significa que el sombreador establece esta variable global. <br><br>  El nombre <code>fragColor</code> opcional, por lo que puede elegir cualquier otro. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b4/276/b2d/8b4276b2d7e735cc05484e80e0c046e8.gif"></div><br>  Aquí está la salida de los dos sombreadores que se muestran arriba. <br><br><h2>  Representación de textura </h2><br>  En lugar de representar / dibujar directamente en la pantalla, el código de muestra utiliza una técnica para <br>  el nombre "renderizar a textura" (renderizar a textura).  Para renderizar a una textura, necesita configurar el búfer de marco y vincular la textura a él.  Puede vincular múltiples texturas a un solo búfer de cuadro. <br><br>  Las texturas ligadas al buffer de cuadro almacenan los vectores devueltos por el sombreador de fragmentos.  Por lo general, estos vectores son vectores de color <code>(r, g, b, a)</code> , pero pueden ser vectores de posición o normales <code>(x, y, z, w)</code> .  Para cada textura encuadernada, un sombreador de fragmentos puede generar un vector separado.  Por ejemplo, podemos deducir de una pasada la posición y la normalidad del vértice. <br><br>  La mayor parte del código de ejemplo que funciona con Panda3D está relacionado con la configuración de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">las texturas del búfer de cuadros</a> .  Para simplificar las cosas, cada sombreador de fragmentos en el código de ejemplo tiene solo una salida.  Sin embargo, para garantizar una alta velocidad de fotogramas (FPS), necesitamos generar la mayor cantidad de información posible en cada paso de representación. <br><br>  Aquí hay dos estructuras de textura para el buffer de cuadro del código de muestra. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ac9/d2b/d50/ac9d2bd50cd1c0bc991ffe7569bf5432.gif"></div><br>  La primera estructura convierte una escena de molino de agua en una textura de búfer de cuadro utilizando una variedad de sombreadores de vértices y fragmentos.  Esta estructura atraviesa cada uno de los vértices de la etapa con el molino y a lo largo de los fragmentos correspondientes. <br><br>  En esta estructura, el código de ejemplo funciona de la siguiente manera. <br><br><ul><li>  Guarda datos de geometría (por ejemplo, posición o vértice normal) para uso futuro. </li><li>  Guarda datos de material (por ejemplo, color difuso) para uso futuro. </li><li>  Crea un enlace UV de diferentes texturas (mapas difusos, normales, mapas de sombras, etc.). </li><li>  Calcula la iluminación ambiental, difusa, reflejada y emitida. </li><li>  Renderiza la niebla. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e5/554/0c2/7e55540c20fe190246f3180b3f06a731.png"></div><br>  La segunda estructura es una cámara ortogonal dirigida a un rectángulo en forma de pantalla. <br>  Esta estructura atraviesa solo cuatro picos y sus fragmentos correspondientes. <br><br>  En la segunda estructura, el código de muestra realiza las siguientes acciones: <br><br><ul><li>  Procesa la salida de otra textura de búfer de cuadro. </li><li>  Combina diferentes texturas de frame buffer en una. </li></ul><br>  En el ejemplo de código, podemos ver la salida de una textura de búfer de cuadro, configurando el cuadro correspondiente en verdadero y falso para todos los demás. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... bool showPositionBuffer = false; bool showNormalBuffer = false; bool showSsaoBuffer = false; bool showSsaoBlurBuffer = false; bool showMaterialDiffuseBuffer = false; bool showOutlineBuffer = false; bool showBaseBuffer = false; bool showSharpenBuffer = false; bool showBloomBuffer = false; bool showCombineBuffer = false; bool showCombineBlurBuffer = false; bool showDepthOfFieldBuffer = false; bool showPosterizeBuffer = false; bool showPixelizeBuffer = false; bool showFilmGrainBuffer = true; // ...</span></span></code> </pre> <br><h2>  Texturizado </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1c/0eb/1c6/d1c0eb1c650b9b05e2372b33259ed8a6.gif"></div><br>  La textura es la unión de un color o algún otro vector a un fragmento utilizando coordenadas UV.  Los valores de U y V varían de cero a uno.  Cada vértice recibe una coordenada UV y se muestra en el sombreador de vértices. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/519/487/fee/519487fee2bb16357b225ce32649fb91.png"></div><br>  El sombreador de fragmentos obtiene la coordenada UV interpolada.  La interpolación significa que la coordenada UV para el fragmento está en algún lugar entre las coordenadas UV de los vértices que forman la cara del triángulo. <br><br><h3>  Sombreador de vértices </h3><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform mat4 p3d_ModelViewProjectionMatrix; in vec2 p3d_MultiTexCoord0; in vec4 p3d_Vertex; out vec2 texCoord; void main() { texCoord = p3d_MultiTexCoord0; gl_Position = p3d_ModelViewProjectionMatrix * p3d_Vertex; }</span></span></code> </pre> <br>  Aquí vemos que el sombreador de vértices genera la coordenada de la textura en el sombreador de fragmentos.  Tenga en cuenta que este es un vector bidimensional: un valor para U y otro para V. <br><br><h3>  Sombreador de fragmentos </h3><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform sampler2D p3d_Texture0; in vec2 texCoord; out vec2 fragColor; void main() { texColor = texture(p3d_Texture0, texCoord); fragColor = texColor; }</span></span></code> </pre> <br>  Aquí vemos que el sombreador de fragmentos busca el color en su coordenada UV y lo muestra como el color del fragmento. <br><br><h4>  Textura de relleno de pantalla </h4><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform sampler2D screenSizedTexture; out vec2 fragColor; void main() { vec2 texSize = textureSize(texture, 0).xy; vec2 texCoord = gl_FragCoord.xy / texSize; texColor = texture(screenSizedTexture, texCoord); fragColor = texColor; }</span></span></code> </pre> <br>  Al renderizar a una textura, la malla es un rectángulo plano con la misma relación de aspecto que la pantalla.  Por lo tanto, podemos calcular las coordenadas UV, sabiendo solo <br><br>  A) el ancho y la altura de la textura con el tamaño de la pantalla superpuesta en el rectángulo usando coordenadas UV, y <br>  B) las coordenadas x e y del fragmento. <br><br>  Para unir x a U, debe dividir x por el ancho de la textura entrante.  Del mismo modo, para unir y a V, debe dividir y por la altura de la textura entrante.  Verá que esta técnica se utiliza en el código de muestra. <br><br><h2>  Iluminación </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f98/05e/0ca/f9805e0ca9717c961dd9618f49475381.gif"></div><br>  Para determinar la iluminación, es necesario calcular y combinar aspectos de la iluminación ambiental, difusa, reflejada y emitida.  El código de muestra utiliza iluminación Phong. <br><br><h3>  Sombreador de vértices </h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform struct p3d_LightSourceParameters { vec4 color ; vec4 ambient ; vec4 diffuse ; vec4 specular ; vec4 position ; vec3 spotDirection ; float spotExponent ; float spotCutoff ; float spotCosCutoff ; float constantAttenuation ; float linearAttenuation ; float quadraticAttenuation ; vec3 attenuation ; sampler2DShadow shadowMap ; mat4 shadowViewMatrix ; } p3d_LightSource[NUMBER_OF_LIGHTS]; // ...</span></span></code> </pre><br>  Para cada fuente de luz, con la excepción de la luz ambiental, Panda3D nos proporciona una estructura conveniente que está disponible para sombreadores de vértices y fragmentos.  Lo más conveniente es un mapa de sombras y una matriz para ver sombras para convertir los vértices en un espacio de sombras o iluminación. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vertexPosition = p3d_ModelViewMatrix * p3d_Vertex; // ... for (int i = 0; i &lt; p3d_LightSource.length(); ++i) { vertexInShadowSpaces[i] = p3d_LightSource[i].shadowViewMatrix * vertexPosition; } // ...</span></span></code> </pre> <br>  Comenzando con el sombreador de vértices, debemos transformar y eliminar el vértice del espacio de visualización en el espacio de sombra o iluminación para cada fuente de luz en la escena.  Esto será útil en el futuro para que el sombreador de fragmentos genere sombras.  Un espacio de sombra o iluminación es un espacio en el que cada coordenada es relativa a la posición de la fuente de luz (el origen es la fuente de luz). <br><br><h3>  Sombreador de fragmentos </h3><br>  El sombreador de fragmentos realiza la mayor parte del cálculo de la iluminación. <br><br><h4>  Material </h4><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform struct { vec4 ambient ; vec4 diffuse ; vec4 emission ; vec3 specular ; float shininess ; } p3d_Material; // ...</span></span></code> </pre> <br>  Panda3D nos proporciona material (en forma de estructura) para la malla o modelo que estamos renderizando actualmente. <br><br><h4>  Múltiples fuentes de iluminación </h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 diffuseSpecular = vec4(0.0, 0.0, 0.0, 0.0); // ...</span></span></code> </pre> <br>  Antes de dar una vuelta por las fuentes de iluminación de la escena, crearemos una unidad que contendrá colores difusos y reflejados. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; p3d_LightSource.length(); ++i) { // ... } // ...</span></span></code> </pre> <br>  Ahora podemos recorrer las fuentes de luz en un ciclo, calculando los colores difusos y reflejados para cada uno. <br><br><h4>  Vectores relacionados con la iluminación </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/307/035/ce7/307035ce7bf5a52b8f25c7aeb862b9d4.gif"></div><br>  Aquí hay cuatro vectores básicos necesarios para calcular los colores difusos y reflejados introducidos por cada fuente de luz.  El vector de dirección de iluminación es una flecha azul que apunta a la fuente de luz.  El vector normal es una flecha verde que apunta verticalmente hacia arriba.  El vector de reflexión es una flecha azul que refleja el vector de dirección de la luz.  El vector de ojo o vista es la flecha naranja que apunta hacia la cámara. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 lightDirection = p3d_LightSource[i].position.xyz - vertexPosition.xyz * p3d_LightSource[i].position.w; // ...</span></span></code> </pre> <br>  La dirección de la iluminación es el vector desde la posición del vértice hasta la posición de la fuente de luz. <br><br>  Si se trata de iluminación direccional, Panda3D establece <code>p3d_LightSource[i].position.w</code> cero.  La iluminación direccional no tiene posición, solo dirección.  Por lo tanto, si se trata de iluminación direccional, entonces la dirección de la iluminación será una dirección negativa u opuesta a la fuente, porque para la iluminación direccional Panda3D establece <code>p3d_LightSource[i].position.xyz</code> en <code>p3d_LightSource[i].position.xyz</code> . <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... normal = normalize(vertexNormal); // ...</span></span></code> </pre> <br>  Lo normal al vértice debe ser un vector unitario.  Los vectores unitarios tienen un valor igual a uno. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 unitLightDirection = normalize(lightDirection); vec3 eyeDirection = normalize(-vertexPosition.xyz); vec3 reflectedDirection = normalize(-reflect(unitLightDirection, normal)); // ...</span></span></code> </pre> <br>  A continuación, necesitamos tres vectores más. <br><br>  Necesitamos un producto escalar con la participación de la dirección de iluminación, por lo que es mejor normalizarlo.  Esto nos da una distancia o magnitud igual a la unidad (vector unitario). <br><br>  La dirección de la vista es opuesta a la posición del vértice / fragmento, porque la posición del vértice / fragmento es relativa a la posición de la cámara.  No olvide que la posición del vértice / fragmento está en el espacio de visualización.  Por lo tanto, en lugar de pasar de la cámara (ojo) al vértice / fragmento, pasamos del vértice / fragmento a la cámara (ojo). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">El vector de reflexión</a> es un reflejo de la dirección de iluminación normal a la superficie.  Cuando el "rayo" de luz toca la superficie, se refleja en el mismo ángulo en el que cayó.  El ángulo entre el vector de dirección de la iluminación y el normal se llama "ángulo de incidencia".  El ángulo entre el vector de reflexión y el normal se llama "ángulo de reflexión". <br><br>  Debe cambiar el signo del vector de luz reflejada, ya que debe apuntar en la misma dirección que el vector del ojo.  No olvide que la dirección del ojo va desde la parte superior / fragmento a la posición de la cámara.  Usaremos el vector de reflexión para calcular el brillo de la luz reflejada. <br><br><h4>  Iluminación difusa </h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float diffuseIntensity = max(dot(normal, unitLightDirection), 0.0); if (diffuseIntensity &gt; 0) { // ... } // ...</span></span></code> </pre> <br>  El brillo de la iluminación difusa es el producto escalar de lo normal a la superficie y la dirección de iluminación de un solo vector.  El producto escalar puede variar de menos uno a uno.  Si ambos vectores apuntan en la misma dirección, entonces el brillo es la unidad.  En todos los demás casos, será menos que la unidad. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/168/5bc/5e7/1685bc5e759e638b5c2bcc4a6c56bbd3.gif"></div><br>  Si el vector de iluminación se aproxima a la misma dirección que lo normal, entonces el brillo de la iluminación difusa tiende a la unidad. <br><br>  Si el brillo de la iluminación difusa es menor o igual a cero, entonces debe pasar a la siguiente fuente de luz. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 diffuse = vec4 ( clamp ( diffuseTex.rgb * p3d_LightSource[i].diffuse.rgb * diffuseIntensity , 0 , 1 ) , 1 ); diffuse.r = clamp(diffuse.r, 0, diffuseTex.r); diffuse.g = clamp(diffuse.g, 0, diffuseTex.g); diffuse.b = clamp(diffuse.b, 0, diffuseTex.b); // ...</span></span></code> </pre> <br>  Ahora podemos calcular el color difuso introducido por esta fuente.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si el brillo de la iluminación difusa es igual a la unidad, entonces el color difuso será una mezcla del color de la textura difusa y el color de la iluminación. </font><font style="vertical-align: inherit;">En cualquier otro brillo, el color difuso será más oscuro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que limito el color difuso para que no sea más brillante que el color de la textura difusa. </font><font style="vertical-align: inherit;">Esto evitará la sobreexposición de la escena.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Luz reflejada </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Después de una iluminación difusa, se calcula lo reflejado. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/989/ade/77c/989ade77c01b7137f437f97fe83ccd17.gif"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 specular = clamp ( vec4(p3d_Material.specular, 1) * p3d_LightSource[i].specular * pow ( max(dot(reflectedDirection, eyeDirection), 0) , p3d_Material.shininess ) , 0 , 1 ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El brillo de la luz reflejada es el producto escalar entre el vector del ojo y el vector de reflexión. </font><font style="vertical-align: inherit;">Como en el caso del brillo de la iluminación difusa, si dos vectores apuntan en la misma dirección, entonces el brillo de la iluminación reflejada es igual a la unidad. </font><font style="vertical-align: inherit;">Cualquier otro brillo reducirá la cantidad de color reflejado introducido por esta fuente de luz.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/046/570/c2e046570e770e1804544d6ae67ae2f8.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El brillo del material determina cuánto se dispersará la iluminación de la luz reflejada. </font><font style="vertical-align: inherit;">Por lo general, se configura en un programa de simulación, por ejemplo, en Blender. </font><font style="vertical-align: inherit;">En Blender, se llama dureza especular.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Focos </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float unitLightDirectionDelta = dot ( normalize(p3d_LightSource[i].spotDirection) , -unitLightDirection ); if (unitLightDirectionDelta &gt;= p3d_LightSource[i].spotCosCutoff) { // ... } // ... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este código no permite que la iluminación afecte fragmentos fuera del cono de foco o la pirámide. </font><font style="vertical-align: inherit;">Afortunadamente, Panda3D puede </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definir</font></font></a> <code>spotDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><code>spotCosCutoff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trabajar con las luces direccionales y spot. </font><font style="vertical-align: inherit;">Los focos tienen una posición y una dirección. </font><font style="vertical-align: inherit;">Sin embargo, la iluminación direccional solo tiene dirección, y las fuentes puntuales solo tienen posición. </font><font style="vertical-align: inherit;">Sin embargo, este código funciona para los tres tipos de iluminación sin la necesidad de declaraciones if confusas.</font></font><br><br><pre> <code class="cpp hljs">spotCosCutoff = cosine(<span class="hljs-number"><span class="hljs-number">0.5</span></span> * spotlightLensFovAngle);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si en el caso de la iluminación de proyección, el producto escalar del vector "fragmento-fuente de iluminación" y el vector de dirección del reflector es menor que el coseno de la mitad del ángulo del campo de visión del </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reflector, entonces el sombreador no tiene en cuenta la influencia de esta fuente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que debe cambiar el signo </font></font><code>unitLightDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>unitLightDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">va del fragmento al reflector, y necesitamos pasar del reflector al fragmento, porque </font></font><code>spotDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">va directamente al centro de la pirámide del reflector a cierta distancia de la posición del reflector. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el caso de la iluminación direccional y puntual, Panda3D establece el </font></font><code>spotCosCutoff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor en -1. Recuerde que el producto escalar varía en el rango de -1 a 1. Por lo tanto, no importa cuál será </font></font><code>unitLightDirectionDelta</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque siempre es mayor o igual que -1.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... diffuse *= pow(unitLightDirectionDelta, p3d_LightSource[i].spotExponent); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al igual que el código </font></font><code>unitLightDirectionDelta</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, este código también funciona para los tres tipos de fuentes de luz. </font><font style="vertical-align: inherit;">En el caso de los focos, hará que los fragmentos sean más brillantes a medida que se acerque al centro de la pirámide de focos. </font><font style="vertical-align: inherit;">Para fuentes direccionales y puntuales de luz </font></font><code>spotExponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es cero. </font><font style="vertical-align: inherit;">Recuerde que cualquier valor de la potencia de cero es igual a la unidad, por lo que el color difuso es igual a sí mismo, multiplicado por uno, es decir, no cambia.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sombras </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float shadow = textureProj ( p3d_LightSource[i].shadowMap , vertexInShadowSpaces[i] ); diffuse.rgb *= shadow; specular.rgb *= shadow; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panda3D simplifica el uso de las sombras porque crea un mapa de sombras y una matriz de transformación de sombras para cada fuente de luz en la escena. Para crear una matriz de transformación usted mismo, debe recopilar una matriz que convierta las coordenadas del espacio de visualización en el espacio de iluminación (las coordenadas son relativas a la posición de la fuente de luz). Para crear un mapa de sombras usted mismo, debe renderizar la escena desde el punto de vista de la fuente de luz en la textura del marco del búfer. La textura de la memoria intermedia del cuadro debe contener la distancia desde la fuente de luz hasta los fragmentos. Esto se llama un "mapa de profundidad". Finalmente, debe transferir manualmente al sombreador su mapa de profundidad casero como </font></font><code>uniform sampler2DShadow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y la matriz de transformación de sombras como </font></font><code>uniform mat4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Así que recrearemos lo que Panda3D hace automáticamente por nosotros.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se utiliza el fragmento de código que se muestra </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que es diferente de la función que se muestra arriba </font></font><code>texture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primero se divide </font></font><code>vertexInShadowSpaces[i].xyz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por </font></font><code>vertexInShadowSpaces[i].w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Luego lo usa </font></font><code>vertexInShadowSpaces[i].xy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para encontrar la profundidad almacenada en el mapa de sombras. Luego, ella </font></font><code>vertexInShadowSpaces[i].z</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compara la profundidad de la parte superior con la profundidad del mapa de sombras </font></font><code>vertexInShadowSpaces[i].xy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si la comparación tiene éxito, </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devuelve uno. De lo contrario, devuelve cero. Cero significa que este vértice / fragmento está en la sombra, y uno significa que el vértice / fragmento no está en la sombra. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">también puede devolver un valor de cero a uno, dependiendo de cómo esté configurado el mapa de sombras. En este ejemplo</font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Realiza múltiples pruebas de profundidad basadas en profundidades adyacentes y devuelve un promedio ponderado. </font><font style="vertical-align: inherit;">Este promedio ponderado puede dar suavidad a las sombras.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atenuación </font></font></h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/381/e8d/bfb/381e8dbfb118dac85b139d0c1ec41bad.png"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float lightDistance = length(lightDirection); float attenuation = 1 / ( p3d_LightSource[i].constantAttenuation + p3d_LightSource[i].linearAttenuation * lightDistance + p3d_LightSource[i].quadraticAttenuation * (lightDistance * lightDistance) ); diffuse.rgb *= attenuation; specular.rgb *= attenuation; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La distancia a la fuente de luz es simplemente la magnitud o la longitud del vector de dirección de la iluminación. </font><font style="vertical-align: inherit;">Tenga en cuenta que no utilizamos la dirección normalizada de iluminación, porque esa distancia sería igual a la unidad. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La distancia a la fuente de luz es necesaria para calcular la atenuación. </font><font style="vertical-align: inherit;">Atenuación significa que disminuye el efecto de la luz lejos de la fuente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parámetros </font></font><code>constantAttenuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>linearAttenuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>quadraticAttenuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede establecer cualquier valor. </font><font style="vertical-align: inherit;">Vale la pena comenzar con </font></font><code>constantAttenuation = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>linearAttenuation = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>quadraticAttenuation = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Con estos parámetros, en la posición de la fuente de luz es igual a la unidad y tiende a cero cuando se aleja de ella.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Iluminación de color final </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... diffuseSpecular += (diffuse + specular); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para calcular el color final de la iluminación, debe agregar el color difuso y reflejado. </font><font style="vertical-align: inherit;">Es necesario agregar esto a la unidad en un ciclo de derivación de las fuentes de luz en la escena.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ambiente </font></font></h4><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D p3d_Texture1; // ... uniform struct { vec4 ambient ; } p3d_LightModel; // ... in vec2 diffuseCoord; // ... vec4 diffuseTex = texture(p3d_Texture1, diffuseCoord); // ... vec4 ambient = p3d_Material.ambient * p3d_LightModel.ambient * diffuseTex; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El componente de iluminación ambiental en el modelo de iluminación se basa en el color ambiental del material, el color de la iluminación ambiental y el color de la textura difusa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nunca debe haber más de una fuente de luz ambiental, por lo tanto, este cálculo debe realizarse solo una vez, en contraste con los cálculos de colores difusos y reflejados acumulados para cada fuente de luz. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que el color de la luz ambiental es útil cuando se realiza SSAO.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Poniendo todo junto </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 outputColor = ambient + diffuseSpecular + p3d_Material.emission; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El color final es la suma del color ambiental, el color difuso, el color reflejado y el color emitido. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Código fuente </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mapas normales </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d1/6bb/9de/6d16bb9deae1520429083896b7492a3f.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El uso de mapas normales le permite agregar nuevas partes a la superficie sin geometría adicional. </font><font style="vertical-align: inherit;">Normalmente, cuando se trabaja en un programa de modelado 3D, se crean versiones de malla alta y baja. </font><font style="vertical-align: inherit;">Luego, se toman las normales de los vértices de la alta malla de polietileno y se hornean en la textura. </font><font style="vertical-align: inherit;">Esta textura es un mapa normal. </font><font style="vertical-align: inherit;">Luego, dentro del sombreador de fragmentos, reemplazamos las normales de los vértices de la malla de polietileno baja con las normales de la malla de polietileno alta cocidas en el mapa normal. </font><font style="vertical-align: inherit;">Debido a esto, al encender una malla, parecerá que tiene más polígonos de los que realmente tiene. </font><font style="vertical-align: inherit;">Esto le permite mantener un FPS alto, mientras transmite la mayoría de los detalles de la versión de alta poli.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e1/92b/4ae/8e192b4ae48d96a65b92456ba640c7d0.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aquí vemos la transición de un modelo de alta poli a un modelo de baja poli, y luego a un modelo de baja poli con un mapa normal superpuesto. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/987/20d/ee1/98720dee1f77246721e1905abf2ebea4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, no olvide que superponer un mapa normal es solo una ilusión. </font><font style="vertical-align: inherit;">En cierto ángulo, la superficie comienza a verse plana nuevamente.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sombreador de vértices </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform mat3 p3d_NormalMatrix; // ... in vec3 p3d_Normal; // ... in vec3 p3d_Binormal; in vec3 p3d_Tangent; // ... vertexNormal = normalize(p3d_NormalMatrix * p3d_Normal); binormal = normalize(p3d_NormalMatrix * p3d_Binormal); tangent = normalize(p3d_NormalMatrix * p3d_Tangent); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comenzando con el sombreador de vértices, necesitamos generar el vector normal, el vector binormal y el vector tangente al sombreador de fragmentos. </font><font style="vertical-align: inherit;">Estos vectores se utilizan en el sombreador de fragmentos para transformar la normalidad del mapa normal del espacio tangente al espacio de visualización. </font></font><br><br> <code>p3d_NormalMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Convierte los vectores normales del vector de vértice, binormal y tangente en el espacio de visualización. </font><font style="vertical-align: inherit;">No olvide que en el espacio de visualización todas las coordenadas son relativas a la posición de la cámara.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[p3d_NormalMatrix] son ​​los principales elementos de transposición inversa 3x3 de ModelViewMatrix. </font><font style="vertical-align: inherit;">Esta estructura se utiliza para convertir el vector normal a las coordenadas del espacio de visualización.</font></font><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Fuente</a> </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... in vec2 p3d_MultiTexCoord0; // ... out vec2 normalCoord; // ... normalCoord = p3d_MultiTexCoord0; // ...</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b40/f21/575/b40f21575482aa633de61643a1c497aa.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> También necesitamos enviar las coordenadas UV del mapa normal al sombreador de fragmentos. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sombreador de fragmentos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recuerde que el vértice normal se usó para calcular la iluminación. </font><font style="vertical-align: inherit;">Sin embargo, para calcular la iluminación, el mapa normal nos da otras normales. </font><font style="vertical-align: inherit;">En el sombreador de fragmentos, necesitamos reemplazar las normales de los vértices con las normales ubicadas en el mapa normal.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D p3d_Texture0; // ... in vec2 normalCoord; // ... /* Find */ vec4 normalTex = texture(p3d_Texture0, normalCoord); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usando las coordenadas del mapa normal transferido por el sombreador de vértices, extraemos la normal correspondiente del mapa. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 normal; // ... /* Unpack */ normal = normalize ( normalTex.rgb * 2.0 - 1.0 ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arriba, mostré cómo las normales se convierten en colores para crear mapas normales. </font><font style="vertical-align: inherit;">Ahora necesitamos revertir este proceso para que podamos obtener las normales originales horneadas en el mapa.</font></font><br><br><pre> <code class="cpp hljs">[ r, g, b] = [ r * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>, g * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>, b * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>] = [ x, y, z]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Así es como se ve el proceso de desempaquetar normales del mapa normal. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... /* Transform */ normal = normalize ( mat3 ( tangent , binormal , vertexNormal ) * normal ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las normales obtenidas del mapa normal suelen estar en el espacio tangente. </font><font style="vertical-align: inherit;">Sin embargo, pueden estar en otro espacio. </font><font style="vertical-align: inherit;">Por ejemplo, Blender le permite hornear normales en espacio tangente, espacio de objetos, espacio mundial y espacio de cámara.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/009/cfc/62c/009cfc62c03b455a1e22b68e8636e735.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para transferir la normalidad del mapa normal desde el espacio tangente al espacio de visualización, cree una matriz de 3x3 basada en el vector tangente, los vectores binormales y el vértice normal. </font><font style="vertical-align: inherit;">Multiplique lo normal por esta matriz y normalícela. </font><font style="vertical-align: inherit;">Aquí es donde terminamos con las normales. </font><font style="vertical-align: inherit;">Todos los demás cálculos de iluminación aún se realizan.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Código fuente </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.frag</font></font></a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/453300/">https://habr.com/ru/post/453300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453290/index.html">Data Science Digest (mayo de 2019)</a></li>
<li><a href="../453292/index.html">"Un pequeño libro sobre agujeros negros"</a></li>
<li><a href="../453294/index.html">Reaccionar Carga perezosa</a></li>
<li><a href="../453296/index.html">Gestionar la asincronía en PHP: de las promesas a las rutinas</a></li>
<li><a href="../453298/index.html">Verano: tiempo de actualización ... usted mismo</a></li>
<li><a href="../453302/index.html">La primera hora de vida con Yandex.Module</a></li>
<li><a href="../453304/index.html">Beneficios clave de Zextras PowerStore</a></li>
<li><a href="../453306/index.html">Kubernetes se hará cargo del mundo. Cuando y como</a></li>
<li><a href="../453310/index.html">Intercambie datos entre componentes React utilizando la biblioteca RxJS</a></li>
<li><a href="../453312/index.html">Generador de correo electrónico empresarial PDF basado en datos XML</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>