<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëèüèΩ üë®‚Äçüë®‚Äçüë¶‚Äçüë¶ üë®üèæ‚Äçüç≥ Shaders de juegos en 3D para principiantes ü¶ã üéöÔ∏è ü§∑üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬øQuieres aprender a agregar texturas, iluminaci√≥n, sombras, mapas normales, objetos brillantes, oclusi√≥n ambiental y otros efectos a tu juego 3D? Geni...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Shaders de juegos en 3D para principiantes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453300/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba2/494/983/ba2494983fe869e14d259f717aa8fc19.gif" alt="imagen"></div><br>  ¬øQuieres aprender a agregar texturas, iluminaci√≥n, sombras, mapas normales, objetos brillantes, oclusi√≥n ambiental y otros efectos a tu juego 3D?  Genial  Este art√≠culo presenta un conjunto de t√©cnicas de sombreado que pueden elevar el nivel de los gr√°ficos de su juego a nuevas alturas.  Explico cada t√©cnica de tal manera que puede aplicar / transferir esta informaci√≥n en cualquier pila de herramientas, ya sea Godot, Unity u otra cosa. <br><br>  Como "pegamento" entre los sombreadores, decid√≠ usar el magn√≠fico motor de juegos Panda3D y OpenGL Shading Language (GLSL).  Si usa la misma pila, obtendr√° una ventaja adicional: aprender√° a usar t√©cnicas de sombreado espec√≠ficamente en Panda3D y OpenGL. <br><a name="habracut"></a><br><h2>  Preparaci√≥n </h2><br>  A continuaci√≥n se muestra el sistema que utilic√© para desarrollar y probar el c√≥digo de muestra. <br><br><h3>  Miercoles </h3><br>  El c√≥digo de muestra se desarroll√≥ y prob√≥ en el siguiente entorno: <br><br><ul><li>  Linux manjaro 4.9.135-1-MANJARO </li><li>  Cadena de renderizador OpenGL: GeForce GTX 970 / PCIe / SSE2 </li><li>  Cadena de versi√≥n OpenGL: 4.6.0 NVIDIA 410.73 </li><li>  g ++ (GCC) 8.2.1 20180831 </li><li>  Panda3D 1.10.1-1 </li></ul><br><h3>  Materiales </h3><br>  Cada uno de los materiales de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Blender</a> utilizados para crear <code>mill-scene.egg</code> tiene dos texturas. <br><br>  La primera textura es un mapa normal, la segunda es un mapa difuso.  Si un objeto usa las normales de sus v√©rtices, entonces se usa un mapa normal "azul claro".  Debido al hecho de que todos los modelos tienen las mismas tarjetas en las mismas posiciones, los sombreadores se pueden generalizar y aplicar al nodo ra√≠z del gr√°fico de escena. <br><br>  Tenga en cuenta que el gr√°fico de escena es una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">caracter√≠stica de</a> la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">implementaci√≥n del</a> motor Panda3D. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19f/9c0/14f/19f9c014f06aee0e2204aa95f87c6306.png"></div><br>  Aqu√≠ hay un mapa normal de un color que contiene solo el color <code>[red = 128, green = 128, blue = 255]</code> . <br><br>  Este color indica la unidad normal, indicando en la direcci√≥n positiva del eje z <code>[0, 0, 1]</code> . <br><br><pre> <code class="cpp hljs">[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] = [ round((<span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span>) , round((<span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span>) , round((<span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span>) ] = [<span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>] = [ round(<span class="hljs-number"><span class="hljs-number">128</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) , round(<span class="hljs-number"><span class="hljs-number">128</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) , round(<span class="hljs-number"><span class="hljs-number">255</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) ] = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br>  Aqu√≠ vemos la unidad normal <code>[0, 0, 1]</code> convertida a un color azul claro <code>[128, 128, 255]</code> , y el azul s√≥lido convertido a una unidad normal. <br><br>  Esto se describe con m√°s detalle en la secci√≥n sobre t√©cnicas de superposici√≥n de mapas normales. <br><br><h3>  Panda3d </h3><br>  En este ejemplo de c√≥digo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Panda3D se</a> usa como el "pegamento" entre los sombreadores.  Esto no afecta las t√©cnicas que se describen a continuaci√≥n, es decir, puede usar la informaci√≥n estudiada aqu√≠ en cualquier pila o motor de juego seleccionado.  Panda3D ofrece ciertas comodidades.  En el art√≠culo habl√© sobre ellos, para que pueda encontrar su contraparte en su pila o recrearlos usted mismo si no est√°n en la pila. <br><br>  Vale la pena considerar que los valores <code>gl-coordinate-system default</code> , <code>textures-power-2 down</code> y <code>textures-auto-power-2 1</code> se agregaron a <code>config.prc</code> .  No est√°n contenidos en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">configuraci√≥n</a> est√°ndar de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Panda3D</a> . <br><br>  Por defecto, Panda3D usa un sistema de coordenadas diestro con un eje z hacia arriba, mientras que OpenGL usa un sistema de coordenadas diestro con un eje y hacia arriba. <br><br>  <code>gl-coordinate-system default</code> le permite deshacerse de las transformaciones entre dos sistemas de coordenadas dentro de los sombreadores. <br><br>  <code>textures-auto-power-2 1</code> nos permite usar tama√±os de textura que no son potencias de dos, si el sistema los admite. <br><br>  Esto es conveniente al realizar SSAO o implementar otras t√©cnicas dentro de una pantalla / ventana, ya que el tama√±o de la pantalla / ventana generalmente no es una potencia de dos. <br><br>  <code>textures-power-2 down</code> reduce el tama√±o de las texturas a una potencia de dos si el sistema solo admite texturas con tama√±os iguales a potencias de dos. <br><br><h2>  C√≥digo de ejemplo de compilaci√≥n </h2><br>  Si desea ejecutar el c√≥digo de muestra, primero debe compilarlo. <br><br>  Panda3D se ejecuta en Linux, Mac y Windows. <br><br><h3>  Linux </h3><br>  Comience <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">instalando el</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">SDK Panda3D</a> para su distribuci√≥n. <br><br>  Encuentra d√≥nde est√°n los encabezados y bibliotecas de Panda3D.  Lo m√°s probable es que se encuentren en <code>/usr/include/panda3d/</code> y en <code>/usr/lib/panda3d/</code> . <br><br>  Luego clone este repositorio y navegue a su directorio. <br><br> <code>git clone https://github.com/lettier/3d-game-shaders-for-beginners.git <br> cd 3d-game-shaders-for-beginners</code> <br> <br>  Ahora compile el c√≥digo fuente en un archivo de salida. <br><br> <code>g++ \ <br> -c main.cxx \ <br> -o 3d-game-shaders-for-beginners.o \ <br> -std=gnu++11 \ <br> -O2 \ <br> -I/usr/include/python2.7/ \ <br> -I/usr/include/panda3d/</code> <br> <br>  Despu√©s de crear el archivo de salida, cree un archivo ejecutable asociando el archivo de salida con sus dependencias. <br><br> <code>g++ \ <br> 3d-game-shaders-for-beginners.o \ <br> -o 3d-game-shaders-for-beginners \ <br> -L/usr/lib/panda3d \ <br> -lp3framework \ <br> -lpanda \ <br> -lpandafx \ <br> -lpandaexpress \ <br> -lp3dtoolconfig \ <br> -lp3dtool \ <br> -lp3pystub \ <br> -lp3direct \ <br> -lpthread</code> <br> <br>  Consulte el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">manual de Panda3D para</a> m√°s informaci√≥n. <br><br><h3>  Mac </h3><br>  Comience instalando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Panda3D SDK</a> para Mac. <br><br>  Encuentra d√≥nde est√°n los encabezados y las bibliotecas de Panda3D. <br><br>  Luego clone el repositorio y navegue a su directorio. <br><br> <code>git clone https://github.com/lettier/3d-game-shaders-for-beginners.git <br> cd 3d-game-shaders-for-beginners</code> <br> <br>  Ahora compile el c√≥digo fuente en un archivo de salida.  Debe encontrar d√≥nde est√°n los directorios de inclusi√≥n en Python 2.7 y Panda3D. <br><br> <code>clang++ \ <br> -c main.cxx \ <br> -o 3d-game-shaders-for-beginners.o \ <br> -std=gnu++11 \ <br> -g \ <br> -O2 \ <br> -I/usr/include/python2.7/ \ <br> -I/Developer/Panda3D/include/</code> <br> <br>  Despu√©s de crear el archivo de salida, cree un archivo ejecutable asociando el archivo de salida con sus dependencias. <br><br>  Necesita encontrar d√≥nde se encuentran las bibliotecas Panda3D. <br><br> <code>clang++ \ <br> 3d-game-shaders-for-beginners.o \ <br> -o 3d-game-shaders-for-beginners \ <br> -L/Developer/Panda3D/lib \ <br> -lp3framework \ <br> -lpanda \ <br> -lpandafx \ <br> -lpandaexpress \ <br> -lp3dtoolconfig \ <br> -lp3dtool \ <br> -lp3pystub \ <br> -lp3direct \ <br> -lpthread</code> <br> <br>  Consulte el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">manual de Panda3D para</a> m√°s informaci√≥n. <br><br><h3>  Ventanas </h3><br>  Comience <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">instalando</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Panda3D SDK</a> para Windows. <br><br>  Encuentra d√≥nde est√°n los encabezados y bibliotecas de Panda3D. <br><br>  Clone este repositorio y navegue a su directorio. <br><br> <code>git clone https://github.com/lettier/3d-game-shaders-for-beginners.git <br> cd 3d-game-shaders-for-beginners</code> <br> <br>  Consulte el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">manual de Panda3D para</a> m√°s informaci√≥n. <br><br><h2>  Lanzar demo </h2><br>  Despu√©s de compilar el c√≥digo de muestra, puede ejecutar el ejecutable o la demostraci√≥n.  As√≠ es como se ejecutan en Linux o Mac. <br><br> <code>./3d-game-shaders-for-beginners</code> <br> <br>  Y entonces se ejecutan en Windows: <br><br> <code>3d-game-shaders-for-beginners.exe</code> <br> <br><h3>  Control del teclado </h3><br>  La demostraci√≥n tiene un control de teclado que le permite mover la c√°mara y cambiar el estado de varios efectos. <br><br><h3>  Movimiento </h3><br><ul><li>  <code>w</code> - mu√©vete profundamente en la escena. </li><li>  <code>a</code> - gira la escena en el sentido de las agujas del reloj. </li><li>  <code>s</code> : al√©jate de la escena. </li><li>  <code>d</code> - gira la escena en sentido antihorario. </li></ul><br><h3>  Efectos conmutables </h3><br><ul><li>  <code>y</code> - habilitar SSAO. </li><li>  <code>Shift</code> + <code>y</code> - deshabilita SSAO. </li><li>  <code>u</code> - inclusi√≥n de circuitos. </li><li>  <code>Shift</code> + <code>u</code> : deshabilita los contornos. </li><li>  <code>i</code> - habilita la floraci√≥n. </li><li>  <code>Shift</code> + <code>i</code> : deshabilita la floraci√≥n. </li><li>  <code>o</code> - habilitar mapas normales. </li><li>  <code>Shift</code> + <code>o</code> : deshabilita los mapas normales. </li><li>  <code>p</code> - inclusi√≥n de niebla. </li><li>  <code>Shift</code> + <code>p</code> - apaga la niebla. </li><li>  <code>h</code> - la inclusi√≥n de la profundidad de campo. </li><li>  <code>Shift</code> + <code>h</code> - deshabilita la profundidad de campo. </li><li>  <code>j</code> : habilitar la posterizaci√≥n. </li><li>  <code>Shift</code> + <code>j</code> - deshabilita la posterizaci√≥n </li><li>  <code>k</code> : habilita la pixelaci√≥n. </li><li>  <code>Shift</code> + <code>k</code> : deshabilita la pixelizaci√≥n. </li><li>  <code>l</code> - afilado. </li><li>  <code>Shift</code> + <code>l</code> : deshabilita la nitidez. </li><li>  <code>n</code> inclusi√≥n de grano de pel√≠cula. </li><li>  <code>Shift</code> + <code>n</code> - deshabilita el grano de la pel√≠cula. </li></ul><br><h2>  Sistema de referencia </h2><br>  Antes de comenzar a escribir sombreadores, debe familiarizarse con los siguientes sistemas de referencia o sistemas de coordenadas.  Todos ellos se reducen de donde se toman las coordenadas actuales del origen de la referencia <code>(0, 0, 0)</code> .  Tan pronto como lo descubramos, podemos transformarlos usando alg√∫n tipo de matriz u otro espacio vectorial.  Por lo general, si la salida de un sombreador no se ve bien, entonces la causa son los sistemas de coordenadas confusos. <br><br><h3>  Modelo </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e06/9ce/863/e069ce863ffc7bd3b94394dc20b25687.gif"></div><br>  El sistema de coordenadas del modelo u objeto es relativo al origen del modelo.  En los programas de modelado tridimensional, por ejemplo, en Blender, generalmente se coloca en el centro del modelo. <br><br><h3>  El mundo </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/9de/1f7/d0a9de1f741bb90174efd93d174ef1f9.gif"></div><br>  El espacio mundial es relativo al origen de la escena / nivel / universo que creaste. <br><br><h3>  Revisar </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd2/15b/b6e/bd215bb6ee79a6904eba3f6ad4ff56d3.gif"></div><br>  El espacio de coordenadas de la vista es relativo a la posici√≥n activa de la c√°mara. <br><br><h3>  Recorte </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d77/505/a34/d77505a349f37a695f77625400857d58.png"></div><br>  Espacio de recorte relativo al centro del marco de la c√°mara.  Todas las coordenadas en √©l son homog√©neas y est√°n en el intervalo <code>(-1, 1)</code> .  X e y son paralelos a la pel√≠cula de la c√°mara, y la coordenada z es la profundidad. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc7/0be/d7c/dc70bed7ca78c39cc9f538b127d7176e.gif"></div><br>  Todos los v√©rtices que no est√°n dentro de los l√≠mites de la pir√°mide de visibilidad o el volumen de visibilidad de la c√°mara se cortan o descartan.  Vemos c√≥mo sucede esto con un cubo truncado detr√°s por el plano lejano de la c√°mara, y con un cubo ubicado a un lado. <br><br><h3>  Pantalla </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5b/47d/336/e5b47d33660b9c1744faa12fec8ef256.png"></div><br>  El espacio de la pantalla es (generalmente) relativo a la esquina inferior izquierda de la pantalla.  X cambia de cero al ancho de la pantalla.  Y cambia de cero a la altura de la pantalla. <br><br><h2>  GLSL </h2><br>  En lugar de trabajar con una canalizaci√≥n de funciones fijas, utilizaremos una canalizaci√≥n de representaci√≥n de GPU programable.  Como es programable, nosotros mismos debemos pasarle el c√≥digo del programa en forma de sombreadores.  Un sombreador es un programa (generalmente peque√±o) creado con una sintaxis similar al lenguaje C. Una canalizaci√≥n de representaci√≥n de GPU programable consta de varios pasos que se pueden programar utilizando sombreadores.  Los diferentes tipos de sombreadores incluyen sombreadores de v√©rtices, sombreadores de teselaci√≥n, sombreadores geom√©tricos, de fragmentos y computacionales.  Para usar las t√©cnicas descritas en el art√≠culo, es suficiente para nosotros usar v√©rtices y fragmentos <br>  etapas <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 void main() {}</span></span></code> </pre> <br>  Aqu√≠ est√° el sombreador GLSL m√≠nimo, que consta del n√∫mero de versi√≥n GLSL y la funci√≥n principal. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform mat4 p3d_ModelViewProjectionMatrix; in vec4 p3d_Vertex; void main() { gl_Position = p3d_ModelViewProjectionMatrix * p3d_Vertex; }</span></span></code> </pre> <br>  Aqu√≠ est√° el sombreador de v√©rtices truncados GLSL, que transforma el v√©rtice de entrada en espacio de recorte y muestra esta nueva posici√≥n como una posici√≥n de v√©rtice uniforme. <br><br>  El procedimiento <code>main</code> no devuelve nada, porque es <code>void</code> , y la variable <code>gl_Position</code> es la salida en l√≠nea. <br><br>  Dos palabras clave que vale la pena mencionar son: <code>uniform</code> y <code>in</code> . <br><br>  La palabra clave <code>uniform</code> significa que esta variable global es la misma para todos los v√©rtices.  Panda3D establece <code>p3d_ModelViewProjectionMatrix</code> y para cada v√©rtice es la misma matriz. <br><br>  La palabra clave <code>in</code> significa que esta variable global se pasa al sombreador.  Un sombreador de v√©rtices obtiene cada v√©rtice en el que se compone la geometr√≠a, al que se adjunta un sombreador de v√©rtices. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 out vec4 fragColor; void main() { fragColor = vec4(0, 1, 0, 1); }</span></span></code> </pre> <br>  Aqu√≠ est√° el sombreador de fragmentos GLSL recortado, que muestra el verde opaco como el color del fragmento. <br><br>  No olvide que un fragmento afecta solo a un p√≠xel de la pantalla, pero varios fragmentos pueden afectar a un p√≠xel. <br><br>  Presta atenci√≥n a la palabra clave out. <br><br>  La palabra clave <code>out</code> significa que el sombreador establece esta variable global. <br><br>  El nombre <code>fragColor</code> opcional, por lo que puede elegir cualquier otro. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b4/276/b2d/8b4276b2d7e735cc05484e80e0c046e8.gif"></div><br>  Aqu√≠ est√° la salida de los dos sombreadores que se muestran arriba. <br><br><h2>  Representaci√≥n de textura </h2><br>  En lugar de representar / dibujar directamente en la pantalla, el c√≥digo de muestra utiliza una t√©cnica para <br>  el nombre "renderizar a textura" (renderizar a textura).  Para renderizar a una textura, necesita configurar el b√∫fer de marco y vincular la textura a √©l.  Puede vincular m√∫ltiples texturas a un solo b√∫fer de cuadro. <br><br>  Las texturas ligadas al buffer de cuadro almacenan los vectores devueltos por el sombreador de fragmentos.  Por lo general, estos vectores son vectores de color <code>(r, g, b, a)</code> , pero pueden ser vectores de posici√≥n o normales <code>(x, y, z, w)</code> .  Para cada textura encuadernada, un sombreador de fragmentos puede generar un vector separado.  Por ejemplo, podemos deducir de una pasada la posici√≥n y la normalidad del v√©rtice. <br><br>  La mayor parte del c√≥digo de ejemplo que funciona con Panda3D est√° relacionado con la configuraci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">las texturas del b√∫fer de cuadros</a> .  Para simplificar las cosas, cada sombreador de fragmentos en el c√≥digo de ejemplo tiene solo una salida.  Sin embargo, para garantizar una alta velocidad de fotogramas (FPS), necesitamos generar la mayor cantidad de informaci√≥n posible en cada paso de representaci√≥n. <br><br>  Aqu√≠ hay dos estructuras de textura para el buffer de cuadro del c√≥digo de muestra. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ac9/d2b/d50/ac9d2bd50cd1c0bc991ffe7569bf5432.gif"></div><br>  La primera estructura convierte una escena de molino de agua en una textura de b√∫fer de cuadro utilizando una variedad de sombreadores de v√©rtices y fragmentos.  Esta estructura atraviesa cada uno de los v√©rtices de la etapa con el molino y a lo largo de los fragmentos correspondientes. <br><br>  En esta estructura, el c√≥digo de ejemplo funciona de la siguiente manera. <br><br><ul><li>  Guarda datos de geometr√≠a (por ejemplo, posici√≥n o v√©rtice normal) para uso futuro. </li><li>  Guarda datos de material (por ejemplo, color difuso) para uso futuro. </li><li>  Crea un enlace UV de diferentes texturas (mapas difusos, normales, mapas de sombras, etc.). </li><li>  Calcula la iluminaci√≥n ambiental, difusa, reflejada y emitida. </li><li>  Renderiza la niebla. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e5/554/0c2/7e55540c20fe190246f3180b3f06a731.png"></div><br>  La segunda estructura es una c√°mara ortogonal dirigida a un rect√°ngulo en forma de pantalla. <br>  Esta estructura atraviesa solo cuatro picos y sus fragmentos correspondientes. <br><br>  En la segunda estructura, el c√≥digo de muestra realiza las siguientes acciones: <br><br><ul><li>  Procesa la salida de otra textura de b√∫fer de cuadro. </li><li>  Combina diferentes texturas de frame buffer en una. </li></ul><br>  En el ejemplo de c√≥digo, podemos ver la salida de una textura de b√∫fer de cuadro, configurando el cuadro correspondiente en verdadero y falso para todos los dem√°s. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... bool showPositionBuffer = false; bool showNormalBuffer = false; bool showSsaoBuffer = false; bool showSsaoBlurBuffer = false; bool showMaterialDiffuseBuffer = false; bool showOutlineBuffer = false; bool showBaseBuffer = false; bool showSharpenBuffer = false; bool showBloomBuffer = false; bool showCombineBuffer = false; bool showCombineBlurBuffer = false; bool showDepthOfFieldBuffer = false; bool showPosterizeBuffer = false; bool showPixelizeBuffer = false; bool showFilmGrainBuffer = true; // ...</span></span></code> </pre> <br><h2>  Texturizado </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1c/0eb/1c6/d1c0eb1c650b9b05e2372b33259ed8a6.gif"></div><br>  La textura es la uni√≥n de un color o alg√∫n otro vector a un fragmento utilizando coordenadas UV.  Los valores de U y V var√≠an de cero a uno.  Cada v√©rtice recibe una coordenada UV y se muestra en el sombreador de v√©rtices. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/519/487/fee/519487fee2bb16357b225ce32649fb91.png"></div><br>  El sombreador de fragmentos obtiene la coordenada UV interpolada.  La interpolaci√≥n significa que la coordenada UV para el fragmento est√° en alg√∫n lugar entre las coordenadas UV de los v√©rtices que forman la cara del tri√°ngulo. <br><br><h3>  Sombreador de v√©rtices </h3><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform mat4 p3d_ModelViewProjectionMatrix; in vec2 p3d_MultiTexCoord0; in vec4 p3d_Vertex; out vec2 texCoord; void main() { texCoord = p3d_MultiTexCoord0; gl_Position = p3d_ModelViewProjectionMatrix * p3d_Vertex; }</span></span></code> </pre> <br>  Aqu√≠ vemos que el sombreador de v√©rtices genera la coordenada de la textura en el sombreador de fragmentos.  Tenga en cuenta que este es un vector bidimensional: un valor para U y otro para V. <br><br><h3>  Sombreador de fragmentos </h3><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform sampler2D p3d_Texture0; in vec2 texCoord; out vec2 fragColor; void main() { texColor = texture(p3d_Texture0, texCoord); fragColor = texColor; }</span></span></code> </pre> <br>  Aqu√≠ vemos que el sombreador de fragmentos busca el color en su coordenada UV y lo muestra como el color del fragmento. <br><br><h4>  Textura de relleno de pantalla </h4><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform sampler2D screenSizedTexture; out vec2 fragColor; void main() { vec2 texSize = textureSize(texture, 0).xy; vec2 texCoord = gl_FragCoord.xy / texSize; texColor = texture(screenSizedTexture, texCoord); fragColor = texColor; }</span></span></code> </pre> <br>  Al renderizar a una textura, la malla es un rect√°ngulo plano con la misma relaci√≥n de aspecto que la pantalla.  Por lo tanto, podemos calcular las coordenadas UV, sabiendo solo <br><br>  A) el ancho y la altura de la textura con el tama√±o de la pantalla superpuesta en el rect√°ngulo usando coordenadas UV, y <br>  B) las coordenadas x e y del fragmento. <br><br>  Para unir x a U, debe dividir x por el ancho de la textura entrante.  Del mismo modo, para unir y a V, debe dividir y por la altura de la textura entrante.  Ver√° que esta t√©cnica se utiliza en el c√≥digo de muestra. <br><br><h2>  Iluminaci√≥n </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f98/05e/0ca/f9805e0ca9717c961dd9618f49475381.gif"></div><br>  Para determinar la iluminaci√≥n, es necesario calcular y combinar aspectos de la iluminaci√≥n ambiental, difusa, reflejada y emitida.  El c√≥digo de muestra utiliza iluminaci√≥n Phong. <br><br><h3>  Sombreador de v√©rtices </h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform struct p3d_LightSourceParameters { vec4 color ; vec4 ambient ; vec4 diffuse ; vec4 specular ; vec4 position ; vec3 spotDirection ; float spotExponent ; float spotCutoff ; float spotCosCutoff ; float constantAttenuation ; float linearAttenuation ; float quadraticAttenuation ; vec3 attenuation ; sampler2DShadow shadowMap ; mat4 shadowViewMatrix ; } p3d_LightSource[NUMBER_OF_LIGHTS]; // ...</span></span></code> </pre><br>  Para cada fuente de luz, con la excepci√≥n de la luz ambiental, Panda3D nos proporciona una estructura conveniente que est√° disponible para sombreadores de v√©rtices y fragmentos.  Lo m√°s conveniente es un mapa de sombras y una matriz para ver sombras para convertir los v√©rtices en un espacio de sombras o iluminaci√≥n. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vertexPosition = p3d_ModelViewMatrix * p3d_Vertex; // ... for (int i = 0; i &lt; p3d_LightSource.length(); ++i) { vertexInShadowSpaces[i] = p3d_LightSource[i].shadowViewMatrix * vertexPosition; } // ...</span></span></code> </pre> <br>  Comenzando con el sombreador de v√©rtices, debemos transformar y eliminar el v√©rtice del espacio de visualizaci√≥n en el espacio de sombra o iluminaci√≥n para cada fuente de luz en la escena.  Esto ser√° √∫til en el futuro para que el sombreador de fragmentos genere sombras.  Un espacio de sombra o iluminaci√≥n es un espacio en el que cada coordenada es relativa a la posici√≥n de la fuente de luz (el origen es la fuente de luz). <br><br><h3>  Sombreador de fragmentos </h3><br>  El sombreador de fragmentos realiza la mayor parte del c√°lculo de la iluminaci√≥n. <br><br><h4>  Material </h4><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform struct { vec4 ambient ; vec4 diffuse ; vec4 emission ; vec3 specular ; float shininess ; } p3d_Material; // ...</span></span></code> </pre> <br>  Panda3D nos proporciona material (en forma de estructura) para la malla o modelo que estamos renderizando actualmente. <br><br><h4>  M√∫ltiples fuentes de iluminaci√≥n </h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 diffuseSpecular = vec4(0.0, 0.0, 0.0, 0.0); // ...</span></span></code> </pre> <br>  Antes de dar una vuelta por las fuentes de iluminaci√≥n de la escena, crearemos una unidad que contendr√° colores difusos y reflejados. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; p3d_LightSource.length(); ++i) { // ... } // ...</span></span></code> </pre> <br>  Ahora podemos recorrer las fuentes de luz en un ciclo, calculando los colores difusos y reflejados para cada uno. <br><br><h4>  Vectores relacionados con la iluminaci√≥n </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/307/035/ce7/307035ce7bf5a52b8f25c7aeb862b9d4.gif"></div><br>  Aqu√≠ hay cuatro vectores b√°sicos necesarios para calcular los colores difusos y reflejados introducidos por cada fuente de luz.  El vector de direcci√≥n de iluminaci√≥n es una flecha azul que apunta a la fuente de luz.  El vector normal es una flecha verde que apunta verticalmente hacia arriba.  El vector de reflexi√≥n es una flecha azul que refleja el vector de direcci√≥n de la luz.  El vector de ojo o vista es la flecha naranja que apunta hacia la c√°mara. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 lightDirection = p3d_LightSource[i].position.xyz - vertexPosition.xyz * p3d_LightSource[i].position.w; // ...</span></span></code> </pre> <br>  La direcci√≥n de la iluminaci√≥n es el vector desde la posici√≥n del v√©rtice hasta la posici√≥n de la fuente de luz. <br><br>  Si se trata de iluminaci√≥n direccional, Panda3D establece <code>p3d_LightSource[i].position.w</code> cero.  La iluminaci√≥n direccional no tiene posici√≥n, solo direcci√≥n.  Por lo tanto, si se trata de iluminaci√≥n direccional, entonces la direcci√≥n de la iluminaci√≥n ser√° una direcci√≥n negativa u opuesta a la fuente, porque para la iluminaci√≥n direccional Panda3D establece <code>p3d_LightSource[i].position.xyz</code> en <code>p3d_LightSource[i].position.xyz</code> . <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... normal = normalize(vertexNormal); // ...</span></span></code> </pre> <br>  Lo normal al v√©rtice debe ser un vector unitario.  Los vectores unitarios tienen un valor igual a uno. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 unitLightDirection = normalize(lightDirection); vec3 eyeDirection = normalize(-vertexPosition.xyz); vec3 reflectedDirection = normalize(-reflect(unitLightDirection, normal)); // ...</span></span></code> </pre> <br>  A continuaci√≥n, necesitamos tres vectores m√°s. <br><br>  Necesitamos un producto escalar con la participaci√≥n de la direcci√≥n de iluminaci√≥n, por lo que es mejor normalizarlo.  Esto nos da una distancia o magnitud igual a la unidad (vector unitario). <br><br>  La direcci√≥n de la vista es opuesta a la posici√≥n del v√©rtice / fragmento, porque la posici√≥n del v√©rtice / fragmento es relativa a la posici√≥n de la c√°mara.  No olvide que la posici√≥n del v√©rtice / fragmento est√° en el espacio de visualizaci√≥n.  Por lo tanto, en lugar de pasar de la c√°mara (ojo) al v√©rtice / fragmento, pasamos del v√©rtice / fragmento a la c√°mara (ojo). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">El vector de reflexi√≥n</a> es un reflejo de la direcci√≥n de iluminaci√≥n normal a la superficie.  Cuando el "rayo" de luz toca la superficie, se refleja en el mismo √°ngulo en el que cay√≥.  El √°ngulo entre el vector de direcci√≥n de la iluminaci√≥n y el normal se llama "√°ngulo de incidencia".  El √°ngulo entre el vector de reflexi√≥n y el normal se llama "√°ngulo de reflexi√≥n". <br><br>  Debe cambiar el signo del vector de luz reflejada, ya que debe apuntar en la misma direcci√≥n que el vector del ojo.  No olvide que la direcci√≥n del ojo va desde la parte superior / fragmento a la posici√≥n de la c√°mara.  Usaremos el vector de reflexi√≥n para calcular el brillo de la luz reflejada. <br><br><h4>  Iluminaci√≥n difusa </h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float diffuseIntensity = max(dot(normal, unitLightDirection), 0.0); if (diffuseIntensity &gt; 0) { // ... } // ...</span></span></code> </pre> <br>  El brillo de la iluminaci√≥n difusa es el producto escalar de lo normal a la superficie y la direcci√≥n de iluminaci√≥n de un solo vector.  El producto escalar puede variar de menos uno a uno.  Si ambos vectores apuntan en la misma direcci√≥n, entonces el brillo es la unidad.  En todos los dem√°s casos, ser√° menos que la unidad. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/168/5bc/5e7/1685bc5e759e638b5c2bcc4a6c56bbd3.gif"></div><br>  Si el vector de iluminaci√≥n se aproxima a la misma direcci√≥n que lo normal, entonces el brillo de la iluminaci√≥n difusa tiende a la unidad. <br><br>  Si el brillo de la iluminaci√≥n difusa es menor o igual a cero, entonces debe pasar a la siguiente fuente de luz. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 diffuse = vec4 ( clamp ( diffuseTex.rgb * p3d_LightSource[i].diffuse.rgb * diffuseIntensity , 0 , 1 ) , 1 ); diffuse.r = clamp(diffuse.r, 0, diffuseTex.r); diffuse.g = clamp(diffuse.g, 0, diffuseTex.g); diffuse.b = clamp(diffuse.b, 0, diffuseTex.b); // ...</span></span></code> </pre> <br>  Ahora podemos calcular el color difuso introducido por esta fuente.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si el brillo de la iluminaci√≥n difusa es igual a la unidad, entonces el color difuso ser√° una mezcla del color de la textura difusa y el color de la iluminaci√≥n. </font><font style="vertical-align: inherit;">En cualquier otro brillo, el color difuso ser√° m√°s oscuro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que limito el color difuso para que no sea m√°s brillante que el color de la textura difusa. </font><font style="vertical-align: inherit;">Esto evitar√° la sobreexposici√≥n de la escena.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Luz reflejada </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Despu√©s de una iluminaci√≥n difusa, se calcula lo reflejado. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/989/ade/77c/989ade77c01b7137f437f97fe83ccd17.gif"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 specular = clamp ( vec4(p3d_Material.specular, 1) * p3d_LightSource[i].specular * pow ( max(dot(reflectedDirection, eyeDirection), 0) , p3d_Material.shininess ) , 0 , 1 ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El brillo de la luz reflejada es el producto escalar entre el vector del ojo y el vector de reflexi√≥n. </font><font style="vertical-align: inherit;">Como en el caso del brillo de la iluminaci√≥n difusa, si dos vectores apuntan en la misma direcci√≥n, entonces el brillo de la iluminaci√≥n reflejada es igual a la unidad. </font><font style="vertical-align: inherit;">Cualquier otro brillo reducir√° la cantidad de color reflejado introducido por esta fuente de luz.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/046/570/c2e046570e770e1804544d6ae67ae2f8.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El brillo del material determina cu√°nto se dispersar√° la iluminaci√≥n de la luz reflejada. </font><font style="vertical-align: inherit;">Por lo general, se configura en un programa de simulaci√≥n, por ejemplo, en Blender. </font><font style="vertical-align: inherit;">En Blender, se llama dureza especular.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Focos </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float unitLightDirectionDelta = dot ( normalize(p3d_LightSource[i].spotDirection) , -unitLightDirection ); if (unitLightDirectionDelta &gt;= p3d_LightSource[i].spotCosCutoff) { // ... } // ... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este c√≥digo no permite que la iluminaci√≥n afecte fragmentos fuera del cono de foco o la pir√°mide. </font><font style="vertical-align: inherit;">Afortunadamente, Panda3D puede </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definir</font></font></a> <code>spotDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><code>spotCosCutoff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trabajar con las luces direccionales y spot. </font><font style="vertical-align: inherit;">Los focos tienen una posici√≥n y una direcci√≥n. </font><font style="vertical-align: inherit;">Sin embargo, la iluminaci√≥n direccional solo tiene direcci√≥n, y las fuentes puntuales solo tienen posici√≥n. </font><font style="vertical-align: inherit;">Sin embargo, este c√≥digo funciona para los tres tipos de iluminaci√≥n sin la necesidad de declaraciones if confusas.</font></font><br><br><pre> <code class="cpp hljs">spotCosCutoff = cosine(<span class="hljs-number"><span class="hljs-number">0.5</span></span> * spotlightLensFovAngle);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si en el caso de la iluminaci√≥n de proyecci√≥n, el producto escalar del vector "fragmento-fuente de iluminaci√≥n" y el vector de direcci√≥n del reflector es menor que el coseno de la mitad del √°ngulo del campo de visi√≥n del </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reflector, entonces el sombreador no tiene en cuenta la influencia de esta fuente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que debe cambiar el signo </font></font><code>unitLightDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>unitLightDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">va del fragmento al reflector, y necesitamos pasar del reflector al fragmento, porque </font></font><code>spotDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">va directamente al centro de la pir√°mide del reflector a cierta distancia de la posici√≥n del reflector. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el caso de la iluminaci√≥n direccional y puntual, Panda3D establece el </font></font><code>spotCosCutoff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor en -1. Recuerde que el producto escalar var√≠a en el rango de -1 a 1. Por lo tanto, no importa cu√°l ser√° </font></font><code>unitLightDirectionDelta</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque siempre es mayor o igual que -1.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... diffuse *= pow(unitLightDirectionDelta, p3d_LightSource[i].spotExponent); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al igual que el c√≥digo </font></font><code>unitLightDirectionDelta</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, este c√≥digo tambi√©n funciona para los tres tipos de fuentes de luz. </font><font style="vertical-align: inherit;">En el caso de los focos, har√° que los fragmentos sean m√°s brillantes a medida que se acerque al centro de la pir√°mide de focos. </font><font style="vertical-align: inherit;">Para fuentes direccionales y puntuales de luz </font></font><code>spotExponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es cero. </font><font style="vertical-align: inherit;">Recuerde que cualquier valor de la potencia de cero es igual a la unidad, por lo que el color difuso es igual a s√≠ mismo, multiplicado por uno, es decir, no cambia.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sombras </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float shadow = textureProj ( p3d_LightSource[i].shadowMap , vertexInShadowSpaces[i] ); diffuse.rgb *= shadow; specular.rgb *= shadow; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panda3D simplifica el uso de las sombras porque crea un mapa de sombras y una matriz de transformaci√≥n de sombras para cada fuente de luz en la escena. Para crear una matriz de transformaci√≥n usted mismo, debe recopilar una matriz que convierta las coordenadas del espacio de visualizaci√≥n en el espacio de iluminaci√≥n (las coordenadas son relativas a la posici√≥n de la fuente de luz). Para crear un mapa de sombras usted mismo, debe renderizar la escena desde el punto de vista de la fuente de luz en la textura del marco del b√∫fer. La textura de la memoria intermedia del cuadro debe contener la distancia desde la fuente de luz hasta los fragmentos. Esto se llama un "mapa de profundidad". Finalmente, debe transferir manualmente al sombreador su mapa de profundidad casero como </font></font><code>uniform sampler2DShadow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y la matriz de transformaci√≥n de sombras como </font></font><code>uniform mat4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. As√≠ que recrearemos lo que Panda3D hace autom√°ticamente por nosotros.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se utiliza el fragmento de c√≥digo que se muestra </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que es diferente de la funci√≥n que se muestra arriba </font></font><code>texture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primero se divide </font></font><code>vertexInShadowSpaces[i].xyz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por </font></font><code>vertexInShadowSpaces[i].w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Luego lo usa </font></font><code>vertexInShadowSpaces[i].xy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para encontrar la profundidad almacenada en el mapa de sombras. Luego, ella </font></font><code>vertexInShadowSpaces[i].z</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compara la profundidad de la parte superior con la profundidad del mapa de sombras </font></font><code>vertexInShadowSpaces[i].xy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si la comparaci√≥n tiene √©xito, </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devuelve uno. De lo contrario, devuelve cero. Cero significa que este v√©rtice / fragmento est√° en la sombra, y uno significa que el v√©rtice / fragmento no est√° en la sombra. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tambi√©n puede devolver un valor de cero a uno, dependiendo de c√≥mo est√© configurado el mapa de sombras. En este ejemplo</font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Realiza m√∫ltiples pruebas de profundidad basadas en profundidades adyacentes y devuelve un promedio ponderado. </font><font style="vertical-align: inherit;">Este promedio ponderado puede dar suavidad a las sombras.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atenuaci√≥n </font></font></h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/381/e8d/bfb/381e8dbfb118dac85b139d0c1ec41bad.png"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float lightDistance = length(lightDirection); float attenuation = 1 / ( p3d_LightSource[i].constantAttenuation + p3d_LightSource[i].linearAttenuation * lightDistance + p3d_LightSource[i].quadraticAttenuation * (lightDistance * lightDistance) ); diffuse.rgb *= attenuation; specular.rgb *= attenuation; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La distancia a la fuente de luz es simplemente la magnitud o la longitud del vector de direcci√≥n de la iluminaci√≥n. </font><font style="vertical-align: inherit;">Tenga en cuenta que no utilizamos la direcci√≥n normalizada de iluminaci√≥n, porque esa distancia ser√≠a igual a la unidad. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La distancia a la fuente de luz es necesaria para calcular la atenuaci√≥n. </font><font style="vertical-align: inherit;">Atenuaci√≥n significa que disminuye el efecto de la luz lejos de la fuente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par√°metros </font></font><code>constantAttenuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>linearAttenuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>quadraticAttenuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede establecer cualquier valor. </font><font style="vertical-align: inherit;">Vale la pena comenzar con </font></font><code>constantAttenuation = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>linearAttenuation = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>quadraticAttenuation = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Con estos par√°metros, en la posici√≥n de la fuente de luz es igual a la unidad y tiende a cero cuando se aleja de ella.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Iluminaci√≥n de color final </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... diffuseSpecular += (diffuse + specular); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para calcular el color final de la iluminaci√≥n, debe agregar el color difuso y reflejado. </font><font style="vertical-align: inherit;">Es necesario agregar esto a la unidad en un ciclo de derivaci√≥n de las fuentes de luz en la escena.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ambiente </font></font></h4><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D p3d_Texture1; // ... uniform struct { vec4 ambient ; } p3d_LightModel; // ... in vec2 diffuseCoord; // ... vec4 diffuseTex = texture(p3d_Texture1, diffuseCoord); // ... vec4 ambient = p3d_Material.ambient * p3d_LightModel.ambient * diffuseTex; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El componente de iluminaci√≥n ambiental en el modelo de iluminaci√≥n se basa en el color ambiental del material, el color de la iluminaci√≥n ambiental y el color de la textura difusa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nunca debe haber m√°s de una fuente de luz ambiental, por lo tanto, este c√°lculo debe realizarse solo una vez, en contraste con los c√°lculos de colores difusos y reflejados acumulados para cada fuente de luz. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que el color de la luz ambiental es √∫til cuando se realiza SSAO.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Poniendo todo junto </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 outputColor = ambient + diffuseSpecular + p3d_Material.emission; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El color final es la suma del color ambiental, el color difuso, el color reflejado y el color emitido. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√≥digo fuente </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mapas normales </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d1/6bb/9de/6d16bb9deae1520429083896b7492a3f.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El uso de mapas normales le permite agregar nuevas partes a la superficie sin geometr√≠a adicional. </font><font style="vertical-align: inherit;">Normalmente, cuando se trabaja en un programa de modelado 3D, se crean versiones de malla alta y baja. </font><font style="vertical-align: inherit;">Luego, se toman las normales de los v√©rtices de la alta malla de polietileno y se hornean en la textura. </font><font style="vertical-align: inherit;">Esta textura es un mapa normal. </font><font style="vertical-align: inherit;">Luego, dentro del sombreador de fragmentos, reemplazamos las normales de los v√©rtices de la malla de polietileno baja con las normales de la malla de polietileno alta cocidas en el mapa normal. </font><font style="vertical-align: inherit;">Debido a esto, al encender una malla, parecer√° que tiene m√°s pol√≠gonos de los que realmente tiene. </font><font style="vertical-align: inherit;">Esto le permite mantener un FPS alto, mientras transmite la mayor√≠a de los detalles de la versi√≥n de alta poli.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e1/92b/4ae/8e192b4ae48d96a65b92456ba640c7d0.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aqu√≠ vemos la transici√≥n de un modelo de alta poli a un modelo de baja poli, y luego a un modelo de baja poli con un mapa normal superpuesto. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/987/20d/ee1/98720dee1f77246721e1905abf2ebea4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, no olvide que superponer un mapa normal es solo una ilusi√≥n. </font><font style="vertical-align: inherit;">En cierto √°ngulo, la superficie comienza a verse plana nuevamente.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sombreador de v√©rtices </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform mat3 p3d_NormalMatrix; // ... in vec3 p3d_Normal; // ... in vec3 p3d_Binormal; in vec3 p3d_Tangent; // ... vertexNormal = normalize(p3d_NormalMatrix * p3d_Normal); binormal = normalize(p3d_NormalMatrix * p3d_Binormal); tangent = normalize(p3d_NormalMatrix * p3d_Tangent); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comenzando con el sombreador de v√©rtices, necesitamos generar el vector normal, el vector binormal y el vector tangente al sombreador de fragmentos. </font><font style="vertical-align: inherit;">Estos vectores se utilizan en el sombreador de fragmentos para transformar la normalidad del mapa normal del espacio tangente al espacio de visualizaci√≥n. </font></font><br><br> <code>p3d_NormalMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Convierte los vectores normales del vector de v√©rtice, binormal y tangente en el espacio de visualizaci√≥n. </font><font style="vertical-align: inherit;">No olvide que en el espacio de visualizaci√≥n todas las coordenadas son relativas a la posici√≥n de la c√°mara.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[p3d_NormalMatrix] son ‚Äã‚Äãlos principales elementos de transposici√≥n inversa 3x3 de ModelViewMatrix. </font><font style="vertical-align: inherit;">Esta estructura se utiliza para convertir el vector normal a las coordenadas del espacio de visualizaci√≥n.</font></font><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Fuente</a> </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... in vec2 p3d_MultiTexCoord0; // ... out vec2 normalCoord; // ... normalCoord = p3d_MultiTexCoord0; // ...</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b40/f21/575/b40f21575482aa633de61643a1c497aa.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tambi√©n necesitamos enviar las coordenadas UV del mapa normal al sombreador de fragmentos. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sombreador de fragmentos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recuerde que el v√©rtice normal se us√≥ para calcular la iluminaci√≥n. </font><font style="vertical-align: inherit;">Sin embargo, para calcular la iluminaci√≥n, el mapa normal nos da otras normales. </font><font style="vertical-align: inherit;">En el sombreador de fragmentos, necesitamos reemplazar las normales de los v√©rtices con las normales ubicadas en el mapa normal.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D p3d_Texture0; // ... in vec2 normalCoord; // ... /* Find */ vec4 normalTex = texture(p3d_Texture0, normalCoord); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usando las coordenadas del mapa normal transferido por el sombreador de v√©rtices, extraemos la normal correspondiente del mapa. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 normal; // ... /* Unpack */ normal = normalize ( normalTex.rgb * 2.0 - 1.0 ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arriba, mostr√© c√≥mo las normales se convierten en colores para crear mapas normales. </font><font style="vertical-align: inherit;">Ahora necesitamos revertir este proceso para que podamos obtener las normales originales horneadas en el mapa.</font></font><br><br><pre> <code class="cpp hljs">[ r, g, b] = [ r * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>, g * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>, b * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>] = [ x, y, z]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As√≠ es como se ve el proceso de desempaquetar normales del mapa normal. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... /* Transform */ normal = normalize ( mat3 ( tangent , binormal , vertexNormal ) * normal ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las normales obtenidas del mapa normal suelen estar en el espacio tangente. </font><font style="vertical-align: inherit;">Sin embargo, pueden estar en otro espacio. </font><font style="vertical-align: inherit;">Por ejemplo, Blender le permite hornear normales en espacio tangente, espacio de objetos, espacio mundial y espacio de c√°mara.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/009/cfc/62c/009cfc62c03b455a1e22b68e8636e735.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para transferir la normalidad del mapa normal desde el espacio tangente al espacio de visualizaci√≥n, cree una matriz de 3x3 basada en el vector tangente, los vectores binormales y el v√©rtice normal. </font><font style="vertical-align: inherit;">Multiplique lo normal por esta matriz y normal√≠cela. </font><font style="vertical-align: inherit;">Aqu√≠ es donde terminamos con las normales. </font><font style="vertical-align: inherit;">Todos los dem√°s c√°lculos de iluminaci√≥n a√∫n se realizan.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√≥digo fuente </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.frag</font></font></a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/453300/">https://habr.com/ru/post/453300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453290/index.html">Data Science Digest (mayo de 2019)</a></li>
<li><a href="../453292/index.html">"Un peque√±o libro sobre agujeros negros"</a></li>
<li><a href="../453294/index.html">Reaccionar Carga perezosa</a></li>
<li><a href="../453296/index.html">Gestionar la asincron√≠a en PHP: de las promesas a las rutinas</a></li>
<li><a href="../453298/index.html">Verano: tiempo de actualizaci√≥n ... usted mismo</a></li>
<li><a href="../453302/index.html">La primera hora de vida con Yandex.Module</a></li>
<li><a href="../453304/index.html">Beneficios clave de Zextras PowerStore</a></li>
<li><a href="../453306/index.html">Kubernetes se har√° cargo del mundo. Cuando y como</a></li>
<li><a href="../453310/index.html">Intercambie datos entre componentes React utilizando la biblioteca RxJS</a></li>
<li><a href="../453312/index.html">Generador de correo electr√≥nico empresarial PDF basado en datos XML</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>