<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïâÔ∏è üå≠ üôãüèø Se pr√©parer pour C ++ 20. √âtude de cas r√©elle Coroutines TS üë©üèΩ‚Äçüé® üë©üèª‚Äçüî¨ üñï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En C ++ 20, l'opportunit√© de travailler avec des coroutines pr√™tes √† l'emploi est sur le point d'appara√Ætre. Ce sujet est proche et int√©ressant pour n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Se pr√©parer pour C ++ 20. √âtude de cas r√©elle Coroutines TS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/420861/">  En C ++ 20, l'opportunit√© de travailler avec des coroutines pr√™tes √† l'emploi est sur le point d'appara√Ætre.  Ce sujet est proche et int√©ressant pour nous chez Yandex.Taxi (pour nos propres besoins, nous d√©veloppons un framework asynchrone).  Par cons√©quent, aujourd'hui, nous allons montrer aux lecteurs de Habr en utilisant un exemple r√©el comment travailler avec des coroutines sans pile C ++. <br><br>  √Ä titre d'exemple, prenons quelque chose de simple: sans travailler avec des interfaces r√©seau asynchrones, des minuteries asynchrones, constitu√©es d'une seule fonction.  Par exemple, essayons de r√©aliser et de r√©√©crire cette "nouille" √† partir des rappels: <br><br><img align="right" src="https://habrastorage.org/webt/za/0m/kp/za0mkphg8qyitvudyvv-dhunfae.jpeg"><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FuncToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); writerQueue.PushTask([=]() { InWriterThread1(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> finally = [=]() { InWriterThread2(); ShutdownAll(); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedNetwork()) { networkQueue.PushTask([=](){ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = InNetworkThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v) { UIQueue.PushTask([=](){ InUIThread(); writerQueue.PushTask(finally); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { writerQueue.PushTask(finally); } }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { finally(); } }); }</code> </pre> <br><a name="habracut"></a><br><h2>  Pr√©sentation </h2><br>  Les coroutines ou coroutines sont la capacit√© d'emp√™cher une fonction de s'ex√©cuter dans un emplacement pr√©d√©termin√©;  passer quelque part l'√©tat entier de la fonction arr√™t√©e avec les variables locales;  ex√©cutez la fonction du m√™me endroit o√π nous l'avons arr√™t√©e. <br>  Il existe plusieurs saveurs de coroutines: empilables et empilables.  Nous en reparlerons plus tard. <br><br><h2>  √ânonc√© du probl√®me </h2><br>  Nous avons plusieurs files d'attente de t√¢ches.  Chaque t√¢che contient certaines t√¢ches: il y a une file d'attente pour dessiner des graphiques, il y a une file d'attente pour les interactions r√©seau et il y a une file d'attente pour travailler avec un disque.  Toutes les files d'attente sont des instances de la classe WorkQueue qui ont la m√©thode void PushTask (t√¢che std :: function &lt;void ()&gt;);.  Les files d'attente vivent plus longtemps que toutes les t√¢ches qui y sont plac√©es (la situation selon laquelle nous avons d√©truit une file d'attente lorsqu'elle contient des t√¢ches en suspens ne devrait pas se produire). <br><br>  La fonction FuncToDealWith () de l'exemple ex√©cute une logique dans diff√©rentes files d'attente et, selon les r√©sultats de l'ex√©cution, place une nouvelle t√¢che dans la file d'attente. <br><br>  Nous r√©√©crivons les ¬´nouilles¬ª des rappels sous la forme d'un pseudo-code lin√©aire, marquant dans quelle file d'attente le code sous-jacent doit √™tre ex√©cut√©: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CoroToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); <span class="hljs-comment"><span class="hljs-comment">// =&gt;   writerQueue InWriterThread1(); if (NeedNetwork()) { // =&gt;   networkQueue auto v = InNetworkThread(); if (v) { // =&gt;   UIQueue InUIThread(); } } // =&gt;   writerQueue InWriterThread2(); ShutdownAll(); }</span></span></code> </pre> <br>  Environ ce r√©sultat que je veux atteindre. <br><br>  Il y a des limitations: <br><br><ul><li>  Les interfaces de file d'attente ne peuvent pas √™tre modifi√©es - elles sont utilis√©es dans d'autres parties de l'application par des d√©veloppeurs tiers.  Vous ne pouvez pas casser le code d√©veloppeur ou ajouter de nouvelles instances de file d'attente. </li><li>  Vous ne pouvez pas modifier la fa√ßon dont vous utilisez la fonction FuncToDealWith.  Vous pouvez seulement changer son nom, mais vous ne pouvez pas lui faire retourner des objets que l'utilisateur doit garder √† la maison. </li><li>  Le code r√©sultant doit √™tre aussi productif que l'original (ou m√™me plus productif). </li></ul><br><h2>  Solution </h2><br><h3>  R√©√©crire la fonction FuncToDealWith </h3><br>  Dans Coroutines TS, le r√©glage de la coroutine se fait en d√©finissant le type de la valeur de retour de la fonction.  Si le type satisfait certaines exigences, vous pouvez utiliser les nouveaux mots cl√©s co_await / co_return / co_yield dans le corps de la fonction.  Dans cet exemple, pour basculer entre les files d'attente, nous utiliserons co_yield: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">CoroTask </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CoroToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); co_yield writerQueue; InWriterThread1(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedNetwork()) { co_yield networkQueue; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = InNetworkThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v) { co_yield UIQueue; InUIThread(); } } co_yield writerQueue; InWriterThread2(); ShutdownAll(); }</code> </pre> <br>  Il s'est av√©r√© tr√®s similaire au pseudocode de la derni√®re section.  Toute la ¬´magie¬ª pour travailler avec des coroutines est cach√©e dans la classe CoroTask. <br><br><h3>  CoroTask </h3><br>  Dans le cas le plus simple (dans notre) cas, le contenu de la classe "tuner" de la coroutine est constitu√© d'un seul alias: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;experimental/coroutine&gt; struct CoroTask { using promise_type = PromiseType; };</span></span></span></span></code> </pre> <br><br>  promise_type est un type de donn√©es que nous devons √©crire nous-m√™mes.  Il contient une logique qui d√©crit: <br><br><ul><li>  que faire √† la sortie de coroutine </li><li>  que faire lorsque vous entrez pour la premi√®re fois dans la corutine </li><li>  qui lib√®re des ressources </li><li>  que faire avec les exceptions sortant de la coroutine </li><li>  Comment cr√©er un objet CoroTask </li><li>  que faire si √† l'int√©rieur des corutines appel√©es co_yield </li></ul><br>  L'alias promise_type doit √™tre appel√© de cette fa√ßon.  Si vous changez le nom d'alias en quelque chose d'autre, le compilateur jurera et dira que vous avez mal orthographi√© CoroTask.  Le nom CoroTask peut √™tre modifi√© comme vous le souhaitez. <br><br><div class="spoiler">  <b class="spoiler_title">Mais pourquoi cette CoroTask est-elle n√©cessaire si tout est d√©crit dans promise_type?</b> <div class="spoiler_text">  Dans les cas plus complexes, vous pouvez cr√©er une CoroTask qui vous permettra de communiquer avec une coroutine arr√™t√©e, d'envoyer et de recevoir des donn√©es de celle-ci, de la r√©veiller et de la d√©truire. <br></div></div><br><h3>  PromiseType </h3><br>  Arriver √† la partie amusante.  Nous d√©crivons le comportement de la corutine: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkQueue</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">// forward declaration class PromiseType { public: //      `co_return;`     , ... void return_void() const { /* ...    :) */ } //        ,  CoroTask, ... auto initial_suspend() const { // ...       . return std::experimental::suspend_never{}; } //      - , ... auto final_suspend() const { // ...        //      . return std::experimental::suspend_never{}; } //     , ... void unhandled_exception() const { // ...   (  ). std::terminate(); } //    CoroTask,    , ... auto get_return_object() const { // ...  CoroTask. return CoroTask{}; } //     co_yield, ... auto yield_value(WorkQueue&amp; wq) const; // ... &lt;  &gt; };</span></span></code> </pre> <br>  Dans le code ci-dessus, vous pouvez remarquer le type de donn√©es std :: experimental :: suspend_never.  Il s'agit d'un type de donn√©es sp√©cial qui indique que la corutine n'a pas besoin d'√™tre arr√™t√©e.  Il y a aussi son contraire - le type std :: experimental :: suspend_always, qui vous dit d'arr√™ter la corutine.  Ces types sont les soi-disant attendables.  Si vous √™tes int√©ress√© par leur structure interne, ne vous inqui√©tez pas, nous √©crirons bient√¥t nos Awaitables. <br><br>  L'endroit le plus simple dans le code ci-dessus est final_suspend ().  La fonction a des effets inattendus.  Donc, si nous <b>n'arr√™tons</b> pas l'ex√©cution dans cette fonction, les ressources allou√©es √† la coroutine par le compilateur nettoieront le compilateur pour nous.  Mais si dans cette fonction nous arr√™tons l'ex√©cution de coroutine (par exemple, en retournant std :: experimental :: suspend_always {}), alors vous devrez lib√©rer manuellement des ressources de quelque part √† l'ext√©rieur: vous devrez enregistrer un pointeur intelligent pour coroutiner quelque part et l'appeler explicitement d√©truire ().  Heureusement, cela n'est pas n√©cessaire pour notre exemple. <br><br><h3>  <b>INCORRECT</b> PromiseType :: yield_value </h3><br>  Il semble que l'√©criture de PromiseType :: yield_value soit assez simple.  Nous avons une ligne;  coroutine, qui doit √™tre suspendu et √† ce tour mettre: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PromiseType::yield_value(WorkQueue&amp; wq) { <span class="hljs-comment"><span class="hljs-comment">//        std::experimental::coroutine_handle&lt;&gt; this_coro = std::experimental::coroutine_handle&lt;&gt;::from_promise(*this); //    .  this_coro  operator(),    // wq      .   , //     ,  operator(),  //   . wq.PushTask(this_coro); //     . return std::experimental::suspend_always{}; }</span></span></code> </pre> <br>  Et ici, nous sommes confront√©s √† un probl√®me tr√®s important et difficile √† d√©tecter.  Le fait est que nous mettons d'abord la coroutine dans la file d'attente et que nous la suspendons ensuite.  Il peut arriver que la coroutine soit supprim√©e de la file d'attente et commence √† √™tre ex√©cut√©e avant m√™me de la suspendre dans le thread actuel.  Cela entra√Ænera une condition de concurrence, un comportement ind√©fini et des erreurs d'ex√©cution compl√®tement folles. <br><br><h3>  <b>Correct</b> PromiseType :: yield_value </h3><br>  Donc, nous devons d'abord arr√™ter la corutine et ensuite l'ajouter √† la file d'attente.  Pour ce faire, nous allons √©crire notre Awaitable et l'appeler schedule_for_execution: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PromiseType::yield_value(WorkQueue&amp; wq) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">schedule_for_execution</span></span></span><span class="hljs-class"> {</span></span> WorkQueue&amp; wq; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_ready</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_suspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::experimental::coroutine_handle&lt;&gt; this_coro)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ wq.PushTask(this_coro); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_resume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> schedule_for_execution{wq}; }</code> </pre> <br>  Les classes std :: experimental :: suspend_always, std :: experimental :: suspend_never, schedule_for_execution et autres Awaitables devraient contenir 3 fonctions.  wait_ready est appel√© pour v√©rifier si la coroutine doit √™tre arr√™t√©e.  wait_suspend est appel√© apr√®s l'arr√™t du programme, le handle de la coroutine arr√™t√©e lui est transmis.  wait_resume est appel√© lorsque l'ex√©cution de la coroutine reprend. <br><div class="spoiler">  <b class="spoiler_title">Et que peut-on √©crire dans des skrabs triangulaires std :: experimental :: coroutine_handle &lt;&gt;?</b> <div class="spoiler_text">  Vous pouvez sp√©cifier le type PromiseType ici, et l'exemple fonctionnera exactement de la m√™me mani√®re :) <br><br>  std :: experimental :: coroutine_handle &lt;&gt; (alias std :: experimental :: coroutine_handle &lt;void&gt;) est le type de base pour tous std :: experimental :: coroutine_handle &lt;DataType&gt;, o√π le DataType doit √™tre le type_de_promesse de la coroutine actuelle.  Si vous n'avez pas besoin d'acc√©der au contenu interne de DataType, vous pouvez √©crire std :: experimental :: coroutine_handle &lt;&gt;.  Cela peut √™tre utile dans les endroits o√π vous souhaitez faire abstraction d'un type particulier de promise_type et utiliser l'effacement de type. <br></div></div><br><h3>  Termin√© </h3><br>  Vous pouvez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">compiler, ex√©cuter l'exemple en ligne et exp√©rimenter de toutes les mani√®res</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Et si je n'aime pas co_yield, puis-je le remplacer par quelque chose?</b> <div class="spoiler_text">  Peut √™tre remplac√© par co_await.  Pour ce faire, ajoutez la fonction suivante √† PromiseType: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WorkQueue&amp; wq)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> yield_value(wq); }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Mais que faire si je n'aime pas co_await?</b> <div class="spoiler_text">  La chose est mauvaise.  Rien √† changer. <br></div></div><br></div></div><br><h3>  Feuille de triche </h3><br>  CoroTask est une classe qui ajuste le comportement d'une coroutine.  Dans les cas plus complexes, il vous permet de communiquer avec une coroutine arr√™t√©e et de prendre toutes les donn√©es de celle-ci. <br><br>  CoroTask :: promise_type d√©crit comment et quand les coroutines s'arr√™tent, comment lib√©rer des ressources et comment construire CoroTask. <br><br>  Les fichiers attendus (std :: experimental :: suspend_always, std :: experimental :: suspend_never, schedule_for_execution et autres) indiquent au compilateur quoi faire avec la coroutine √† un point sp√©cifique (si arr√™ter la corutine, quoi faire avec la corutine arr√™t√©e et quoi faire lorsque la corutine se r√©veille) . <br><br><h3>  Optimisations </h3><br>  Il y a une faille dans notre PromiseType.  M√™me si nous sommes actuellement en cours d'ex√©cution dans la file d'attente de t√¢ches correcte, appeler co_yield suspendra toujours la coroutine et la replacera dans la m√™me file d'attente de t√¢ches.  Il serait beaucoup plus optimal de ne pas arr√™ter l'ex√©cution de la coroutine, mais de poursuivre imm√©diatement l'ex√©cution. <br><br>  Corrigeons cette faille.  Pour ce faire, ajoutez un champ priv√© √† PromiseType: <br><br><pre> <code class="cpp hljs">WorkQueue* current_queue_ = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>;</code> </pre> <br>  Dans celui-ci, nous tiendrons un pointeur sur la file d'attente dans laquelle nous sommes actuellement en cours d'ex√©cution. <br><br>  Ensuite, ajustez PromiseType :: yield_value: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PromiseType::yield_value(WorkQueue&amp; wq) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">schedule_for_execution</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> do_resume; WorkQueue&amp; wq; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_ready</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_resume; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_suspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::experimental::coroutine_handle&lt;&gt; this_coro)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ wq.PushTask(this_coro); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_resume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> do_not_suspend = (current_queue_ == &amp;wq); current_queue_ = &amp;wq; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> schedule_for_execution{do_not_suspend, wq}; }</code> </pre> <br>  Ici, nous avons modifi√© Schedule_for_execution :: Wait_ready ().  Maintenant, cette fonction indique au compilateur que la coroutine n'a pas besoin d'√™tre suspendue si la file d'attente de t√¢ches actuelle correspond √† celle sur laquelle nous essayons de d√©marrer. <br><br>  C'est fait.  Vous pouvez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exp√©rimenter de toutes les mani√®res</a> . <br><br><h2>  √Ä propos des performances </h2><br>  Dans l'exemple d'origine, √† chaque appel √† WorkQueue :: PushTask (std :: function &lt;void ()&gt; f), nous avons cr√©√© une instance de la classe std :: function &lt;void ()&gt; √† partir du lambda.  Dans le code r√©el, ces lambdas sont souvent de taille assez importante, c'est pourquoi std :: function &lt;void ()&gt; est oblig√© d'allouer dynamiquement de la m√©moire pour stocker les lambdas. <br><br>  Dans l'exemple coroutine, nous cr√©ons des instances de std :: function &lt;void ()&gt; √† partir de std :: experimental :: coroutine_handle &lt;&gt;.  La taille de std :: experimental :: coroutine_handle &lt;&gt; d√©pend de l'impl√©mentation, mais la plupart des impl√©mentations essaient de garder sa taille au minimum.  Donc, sur clang, sa taille est √©gale √† sizeof (void *).  Lors de la construction de std :: function &lt;void ()&gt;, l'allocation dynamique ne se produit pas √† partir de petits objets. <br>  Total - avec Coroutines, nous nous sommes d√©barrass√©s de plusieurs allocations dynamiques inutiles. <br><br>  Mais!  Souvent, le compilateur ne peut pas simplement enregistrer toute la coroutine sur la pile.  De ce fait, une allocation dynamique suppl√©mentaire est possible lors de la saisie de CoroToDealWith. <br><br><h2>  Stackless vs stackful </h2><br>  Nous venons de travailler avec les coroutines Stackless, qui n√©cessitent le support du compilateur pour fonctionner.  Il existe √©galement des Coroutines empilables qui peuvent √™tre impl√©ment√©es enti√®rement au niveau de la biblioth√®que. <br><br>  Les premiers permettent une allocation de m√©moire plus √©conomique, potentiellement ils sont mieux optimis√©s par le compilateur.  Les seconds sont plus faciles √† impl√©menter dans les projets existants, car ils n√©cessitent moins de modifications de code.  Cependant, dans cet exemple, vous ne pouvez pas sentir la diff√©rence, des exemples plus compliqu√©s sont n√©cessaires. <br><br><h2>  R√©sum√© </h2><br>  Nous avons examin√© l'exemple de base et obtenu une classe universelle CoroTask, qui peut √™tre utilis√©e pour cr√©er d'autres coroutines. <br><br>  Le code avec lui devient plus lisible et l√©g√®rement plus productif qu'avec l'approche na√Øve: <br><table><tbody><tr><th>  √âtait </th><th>  Avec des coroutines </th></tr><tr><td><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FuncToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); writerQueue.PushTask([=]() { InWriterThread1(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> fin = [=]() { InWriterThread2(); ShutdownAll(); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedNetwork()) { networkQueue.PushTask([=](){ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = InNetThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v) { UIQueue.PushTask([=](){ InUIThread(); writerQueue.PushTask(fin); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { writerQueue.PushTask(fin); } }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fin(); } }); }</code> </pre></td><td><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">CoroTask </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CoroToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); co_yield writerQueue; InWriterThread1(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedNetwork()) { co_yield networkQueue; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = InNetThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v) { co_yield UIQueue; InUIThread(); } } co_yield writerQueue; InWriterThread2(); ShutdownAll(); }</code> </pre> </td></tr></tbody></table><br>  Par dessus bord, il y a eu des moments: <br><br><ul><li>  comment appeler une autre coroutine de la corutine et attendre sa fin </li><li>  quels trucs utiles vous pouvez entasser dans CoroTask </li><li>  un exemple qui fait la diff√©rence entre Stackless et Stackful </li></ul><br><h2>  Autre </h2><br>  Si vous souhaitez en savoir plus sur les autres nouveaut√©s du langage C ++ ou communiquer personnellement avec vos coll√®gues sur les avantages, consultez la conf√©rence C ++ Russia.  La prochaine se tiendra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le 6 octobre √† Nijni Novgorod</a> . <br><br>  Si vous avez des probl√®mes li√©s au C ++ et que vous souhaitez am√©liorer quelque chose dans le langage ou si vous souhaitez simplement discuter des innovations possibles, alors bienvenue sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://stdcpp.ru/</a> . <br><br>  Eh bien, si cela vous surprend que Yandex.Taxi a un grand nombre de t√¢ches qui ne sont pas li√©es aux graphiques, alors j'esp√®re que cela s'est av√©r√© √™tre une agr√©able surprise pour vous :) Venez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nous rendre visite le 11 octobre</a> , nous parlerons de C ++ et plus encore. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420861/">https://habr.com/ru/post/fr420861/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420845/index.html">Apprivoiser l'obstin√© √† l'aide d'une b√©quille: le trou de l'adaptateur Wi-Fi WF2190 (Realtek8812AU Wireless LAN 802.11ac USB)</a></li>
<li><a href="../fr420847/index.html">Introduction √† la programmation des shaders pour les mises en page</a></li>
<li><a href="../fr420853/index.html">D√©couvrez la pseudo console Windows (ConPTY)</a></li>
<li><a href="../fr420857/index.html">Itin√©rance Wi-Fi transparente: la th√©orie en pratique</a></li>
<li><a href="../fr420859/index.html">√Ä la question de Wirth et des cha√Ænes</a></li>
<li><a href="../fr420863/index.html">Comme nous l'avons fait le premier smartphone russe, a continu√©</a></li>
<li><a href="../fr420865/index.html">Le principe de moindre action. Partie 1</a></li>
<li><a href="../fr420867/index.html">Calcul d'int√©grales d√©finies: algorithmes de base</a></li>
<li><a href="../fr420869/index.html">√âvacuation, HAMR et MAMR - trois fa√ßons de maximiser la capacit√© des disques durs modernes</a></li>
<li><a href="../fr420871/index.html">Comment nous avons d√©m√©nag√© notre studio web √† Bali</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>