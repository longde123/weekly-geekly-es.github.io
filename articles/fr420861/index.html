<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕉️ 🌭 🙋🏿 Se préparer pour C ++ 20. Étude de cas réelle Coroutines TS 👩🏽‍🎨 👩🏻‍🔬 🖕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En C ++ 20, l'opportunité de travailler avec des coroutines prêtes à l'emploi est sur le point d'apparaître. Ce sujet est proche et intéressant pour n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Se préparer pour C ++ 20. Étude de cas réelle Coroutines TS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/420861/">  En C ++ 20, l'opportunité de travailler avec des coroutines prêtes à l'emploi est sur le point d'apparaître.  Ce sujet est proche et intéressant pour nous chez Yandex.Taxi (pour nos propres besoins, nous développons un framework asynchrone).  Par conséquent, aujourd'hui, nous allons montrer aux lecteurs de Habr en utilisant un exemple réel comment travailler avec des coroutines sans pile C ++. <br><br>  À titre d'exemple, prenons quelque chose de simple: sans travailler avec des interfaces réseau asynchrones, des minuteries asynchrones, constituées d'une seule fonction.  Par exemple, essayons de réaliser et de réécrire cette "nouille" à partir des rappels: <br><br><img align="right" src="https://habrastorage.org/webt/za/0m/kp/za0mkphg8qyitvudyvv-dhunfae.jpeg"><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FuncToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); writerQueue.PushTask([=]() { InWriterThread1(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> finally = [=]() { InWriterThread2(); ShutdownAll(); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedNetwork()) { networkQueue.PushTask([=](){ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = InNetworkThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v) { UIQueue.PushTask([=](){ InUIThread(); writerQueue.PushTask(finally); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { writerQueue.PushTask(finally); } }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { finally(); } }); }</code> </pre> <br><a name="habracut"></a><br><h2>  Présentation </h2><br>  Les coroutines ou coroutines sont la capacité d'empêcher une fonction de s'exécuter dans un emplacement prédéterminé;  passer quelque part l'état entier de la fonction arrêtée avec les variables locales;  exécutez la fonction du même endroit où nous l'avons arrêtée. <br>  Il existe plusieurs saveurs de coroutines: empilables et empilables.  Nous en reparlerons plus tard. <br><br><h2>  Énoncé du problème </h2><br>  Nous avons plusieurs files d'attente de tâches.  Chaque tâche contient certaines tâches: il y a une file d'attente pour dessiner des graphiques, il y a une file d'attente pour les interactions réseau et il y a une file d'attente pour travailler avec un disque.  Toutes les files d'attente sont des instances de la classe WorkQueue qui ont la méthode void PushTask (tâche std :: function &lt;void ()&gt;);.  Les files d'attente vivent plus longtemps que toutes les tâches qui y sont placées (la situation selon laquelle nous avons détruit une file d'attente lorsqu'elle contient des tâches en suspens ne devrait pas se produire). <br><br>  La fonction FuncToDealWith () de l'exemple exécute une logique dans différentes files d'attente et, selon les résultats de l'exécution, place une nouvelle tâche dans la file d'attente. <br><br>  Nous réécrivons les «nouilles» des rappels sous la forme d'un pseudo-code linéaire, marquant dans quelle file d'attente le code sous-jacent doit être exécuté: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CoroToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); <span class="hljs-comment"><span class="hljs-comment">// =&gt;   writerQueue InWriterThread1(); if (NeedNetwork()) { // =&gt;   networkQueue auto v = InNetworkThread(); if (v) { // =&gt;   UIQueue InUIThread(); } } // =&gt;   writerQueue InWriterThread2(); ShutdownAll(); }</span></span></code> </pre> <br>  Environ ce résultat que je veux atteindre. <br><br>  Il y a des limitations: <br><br><ul><li>  Les interfaces de file d'attente ne peuvent pas être modifiées - elles sont utilisées dans d'autres parties de l'application par des développeurs tiers.  Vous ne pouvez pas casser le code développeur ou ajouter de nouvelles instances de file d'attente. </li><li>  Vous ne pouvez pas modifier la façon dont vous utilisez la fonction FuncToDealWith.  Vous pouvez seulement changer son nom, mais vous ne pouvez pas lui faire retourner des objets que l'utilisateur doit garder à la maison. </li><li>  Le code résultant doit être aussi productif que l'original (ou même plus productif). </li></ul><br><h2>  Solution </h2><br><h3>  Réécrire la fonction FuncToDealWith </h3><br>  Dans Coroutines TS, le réglage de la coroutine se fait en définissant le type de la valeur de retour de la fonction.  Si le type satisfait certaines exigences, vous pouvez utiliser les nouveaux mots clés co_await / co_return / co_yield dans le corps de la fonction.  Dans cet exemple, pour basculer entre les files d'attente, nous utiliserons co_yield: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">CoroTask </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CoroToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); co_yield writerQueue; InWriterThread1(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedNetwork()) { co_yield networkQueue; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = InNetworkThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v) { co_yield UIQueue; InUIThread(); } } co_yield writerQueue; InWriterThread2(); ShutdownAll(); }</code> </pre> <br>  Il s'est avéré très similaire au pseudocode de la dernière section.  Toute la «magie» pour travailler avec des coroutines est cachée dans la classe CoroTask. <br><br><h3>  CoroTask </h3><br>  Dans le cas le plus simple (dans notre) cas, le contenu de la classe "tuner" de la coroutine est constitué d'un seul alias: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;experimental/coroutine&gt; struct CoroTask { using promise_type = PromiseType; };</span></span></span></span></code> </pre> <br><br>  promise_type est un type de données que nous devons écrire nous-mêmes.  Il contient une logique qui décrit: <br><br><ul><li>  que faire à la sortie de coroutine </li><li>  que faire lorsque vous entrez pour la première fois dans la corutine </li><li>  qui libère des ressources </li><li>  que faire avec les exceptions sortant de la coroutine </li><li>  Comment créer un objet CoroTask </li><li>  que faire si à l'intérieur des corutines appelées co_yield </li></ul><br>  L'alias promise_type doit être appelé de cette façon.  Si vous changez le nom d'alias en quelque chose d'autre, le compilateur jurera et dira que vous avez mal orthographié CoroTask.  Le nom CoroTask peut être modifié comme vous le souhaitez. <br><br><div class="spoiler">  <b class="spoiler_title">Mais pourquoi cette CoroTask est-elle nécessaire si tout est décrit dans promise_type?</b> <div class="spoiler_text">  Dans les cas plus complexes, vous pouvez créer une CoroTask qui vous permettra de communiquer avec une coroutine arrêtée, d'envoyer et de recevoir des données de celle-ci, de la réveiller et de la détruire. <br></div></div><br><h3>  PromiseType </h3><br>  Arriver à la partie amusante.  Nous décrivons le comportement de la corutine: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkQueue</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">// forward declaration class PromiseType { public: //      `co_return;`     , ... void return_void() const { /* ...    :) */ } //        ,  CoroTask, ... auto initial_suspend() const { // ...       . return std::experimental::suspend_never{}; } //      - , ... auto final_suspend() const { // ...        //      . return std::experimental::suspend_never{}; } //     , ... void unhandled_exception() const { // ...   (  ). std::terminate(); } //    CoroTask,    , ... auto get_return_object() const { // ...  CoroTask. return CoroTask{}; } //     co_yield, ... auto yield_value(WorkQueue&amp; wq) const; // ... &lt;  &gt; };</span></span></code> </pre> <br>  Dans le code ci-dessus, vous pouvez remarquer le type de données std :: experimental :: suspend_never.  Il s'agit d'un type de données spécial qui indique que la corutine n'a pas besoin d'être arrêtée.  Il y a aussi son contraire - le type std :: experimental :: suspend_always, qui vous dit d'arrêter la corutine.  Ces types sont les soi-disant attendables.  Si vous êtes intéressé par leur structure interne, ne vous inquiétez pas, nous écrirons bientôt nos Awaitables. <br><br>  L'endroit le plus simple dans le code ci-dessus est final_suspend ().  La fonction a des effets inattendus.  Donc, si nous <b>n'arrêtons</b> pas l'exécution dans cette fonction, les ressources allouées à la coroutine par le compilateur nettoieront le compilateur pour nous.  Mais si dans cette fonction nous arrêtons l'exécution de coroutine (par exemple, en retournant std :: experimental :: suspend_always {}), alors vous devrez libérer manuellement des ressources de quelque part à l'extérieur: vous devrez enregistrer un pointeur intelligent pour coroutiner quelque part et l'appeler explicitement détruire ().  Heureusement, cela n'est pas nécessaire pour notre exemple. <br><br><h3>  <b>INCORRECT</b> PromiseType :: yield_value </h3><br>  Il semble que l'écriture de PromiseType :: yield_value soit assez simple.  Nous avons une ligne;  coroutine, qui doit être suspendu et à ce tour mettre: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PromiseType::yield_value(WorkQueue&amp; wq) { <span class="hljs-comment"><span class="hljs-comment">//        std::experimental::coroutine_handle&lt;&gt; this_coro = std::experimental::coroutine_handle&lt;&gt;::from_promise(*this); //    .  this_coro  operator(),    // wq      .   , //     ,  operator(),  //   . wq.PushTask(this_coro); //     . return std::experimental::suspend_always{}; }</span></span></code> </pre> <br>  Et ici, nous sommes confrontés à un problème très important et difficile à détecter.  Le fait est que nous mettons d'abord la coroutine dans la file d'attente et que nous la suspendons ensuite.  Il peut arriver que la coroutine soit supprimée de la file d'attente et commence à être exécutée avant même de la suspendre dans le thread actuel.  Cela entraînera une condition de concurrence, un comportement indéfini et des erreurs d'exécution complètement folles. <br><br><h3>  <b>Correct</b> PromiseType :: yield_value </h3><br>  Donc, nous devons d'abord arrêter la corutine et ensuite l'ajouter à la file d'attente.  Pour ce faire, nous allons écrire notre Awaitable et l'appeler schedule_for_execution: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PromiseType::yield_value(WorkQueue&amp; wq) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">schedule_for_execution</span></span></span><span class="hljs-class"> {</span></span> WorkQueue&amp; wq; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_ready</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_suspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::experimental::coroutine_handle&lt;&gt; this_coro)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ wq.PushTask(this_coro); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_resume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> schedule_for_execution{wq}; }</code> </pre> <br>  Les classes std :: experimental :: suspend_always, std :: experimental :: suspend_never, schedule_for_execution et autres Awaitables devraient contenir 3 fonctions.  wait_ready est appelé pour vérifier si la coroutine doit être arrêtée.  wait_suspend est appelé après l'arrêt du programme, le handle de la coroutine arrêtée lui est transmis.  wait_resume est appelé lorsque l'exécution de la coroutine reprend. <br><div class="spoiler">  <b class="spoiler_title">Et que peut-on écrire dans des skrabs triangulaires std :: experimental :: coroutine_handle &lt;&gt;?</b> <div class="spoiler_text">  Vous pouvez spécifier le type PromiseType ici, et l'exemple fonctionnera exactement de la même manière :) <br><br>  std :: experimental :: coroutine_handle &lt;&gt; (alias std :: experimental :: coroutine_handle &lt;void&gt;) est le type de base pour tous std :: experimental :: coroutine_handle &lt;DataType&gt;, où le DataType doit être le type_de_promesse de la coroutine actuelle.  Si vous n'avez pas besoin d'accéder au contenu interne de DataType, vous pouvez écrire std :: experimental :: coroutine_handle &lt;&gt;.  Cela peut être utile dans les endroits où vous souhaitez faire abstraction d'un type particulier de promise_type et utiliser l'effacement de type. <br></div></div><br><h3>  Terminé </h3><br>  Vous pouvez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">compiler, exécuter l'exemple en ligne et expérimenter de toutes les manières</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Et si je n'aime pas co_yield, puis-je le remplacer par quelque chose?</b> <div class="spoiler_text">  Peut être remplacé par co_await.  Pour ce faire, ajoutez la fonction suivante à PromiseType: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WorkQueue&amp; wq)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> yield_value(wq); }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Mais que faire si je n'aime pas co_await?</b> <div class="spoiler_text">  La chose est mauvaise.  Rien à changer. <br></div></div><br></div></div><br><h3>  Feuille de triche </h3><br>  CoroTask est une classe qui ajuste le comportement d'une coroutine.  Dans les cas plus complexes, il vous permet de communiquer avec une coroutine arrêtée et de prendre toutes les données de celle-ci. <br><br>  CoroTask :: promise_type décrit comment et quand les coroutines s'arrêtent, comment libérer des ressources et comment construire CoroTask. <br><br>  Les fichiers attendus (std :: experimental :: suspend_always, std :: experimental :: suspend_never, schedule_for_execution et autres) indiquent au compilateur quoi faire avec la coroutine à un point spécifique (si arrêter la corutine, quoi faire avec la corutine arrêtée et quoi faire lorsque la corutine se réveille) . <br><br><h3>  Optimisations </h3><br>  Il y a une faille dans notre PromiseType.  Même si nous sommes actuellement en cours d'exécution dans la file d'attente de tâches correcte, appeler co_yield suspendra toujours la coroutine et la replacera dans la même file d'attente de tâches.  Il serait beaucoup plus optimal de ne pas arrêter l'exécution de la coroutine, mais de poursuivre immédiatement l'exécution. <br><br>  Corrigeons cette faille.  Pour ce faire, ajoutez un champ privé à PromiseType: <br><br><pre> <code class="cpp hljs">WorkQueue* current_queue_ = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>;</code> </pre> <br>  Dans celui-ci, nous tiendrons un pointeur sur la file d'attente dans laquelle nous sommes actuellement en cours d'exécution. <br><br>  Ensuite, ajustez PromiseType :: yield_value: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PromiseType::yield_value(WorkQueue&amp; wq) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">schedule_for_execution</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> do_resume; WorkQueue&amp; wq; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_ready</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_resume; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_suspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::experimental::coroutine_handle&lt;&gt; this_coro)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ wq.PushTask(this_coro); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">await_resume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> do_not_suspend = (current_queue_ == &amp;wq); current_queue_ = &amp;wq; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> schedule_for_execution{do_not_suspend, wq}; }</code> </pre> <br>  Ici, nous avons modifié Schedule_for_execution :: Wait_ready ().  Maintenant, cette fonction indique au compilateur que la coroutine n'a pas besoin d'être suspendue si la file d'attente de tâches actuelle correspond à celle sur laquelle nous essayons de démarrer. <br><br>  C'est fait.  Vous pouvez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">expérimenter de toutes les manières</a> . <br><br><h2>  À propos des performances </h2><br>  Dans l'exemple d'origine, à chaque appel à WorkQueue :: PushTask (std :: function &lt;void ()&gt; f), nous avons créé une instance de la classe std :: function &lt;void ()&gt; à partir du lambda.  Dans le code réel, ces lambdas sont souvent de taille assez importante, c'est pourquoi std :: function &lt;void ()&gt; est obligé d'allouer dynamiquement de la mémoire pour stocker les lambdas. <br><br>  Dans l'exemple coroutine, nous créons des instances de std :: function &lt;void ()&gt; à partir de std :: experimental :: coroutine_handle &lt;&gt;.  La taille de std :: experimental :: coroutine_handle &lt;&gt; dépend de l'implémentation, mais la plupart des implémentations essaient de garder sa taille au minimum.  Donc, sur clang, sa taille est égale à sizeof (void *).  Lors de la construction de std :: function &lt;void ()&gt;, l'allocation dynamique ne se produit pas à partir de petits objets. <br>  Total - avec Coroutines, nous nous sommes débarrassés de plusieurs allocations dynamiques inutiles. <br><br>  Mais!  Souvent, le compilateur ne peut pas simplement enregistrer toute la coroutine sur la pile.  De ce fait, une allocation dynamique supplémentaire est possible lors de la saisie de CoroToDealWith. <br><br><h2>  Stackless vs stackful </h2><br>  Nous venons de travailler avec les coroutines Stackless, qui nécessitent le support du compilateur pour fonctionner.  Il existe également des Coroutines empilables qui peuvent être implémentées entièrement au niveau de la bibliothèque. <br><br>  Les premiers permettent une allocation de mémoire plus économique, potentiellement ils sont mieux optimisés par le compilateur.  Les seconds sont plus faciles à implémenter dans les projets existants, car ils nécessitent moins de modifications de code.  Cependant, dans cet exemple, vous ne pouvez pas sentir la différence, des exemples plus compliqués sont nécessaires. <br><br><h2>  Résumé </h2><br>  Nous avons examiné l'exemple de base et obtenu une classe universelle CoroTask, qui peut être utilisée pour créer d'autres coroutines. <br><br>  Le code avec lui devient plus lisible et légèrement plus productif qu'avec l'approche naïve: <br><table><tbody><tr><th>  Était </th><th>  Avec des coroutines </th></tr><tr><td><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FuncToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); writerQueue.PushTask([=]() { InWriterThread1(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> fin = [=]() { InWriterThread2(); ShutdownAll(); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedNetwork()) { networkQueue.PushTask([=](){ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = InNetThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v) { UIQueue.PushTask([=](){ InUIThread(); writerQueue.PushTask(fin); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { writerQueue.PushTask(fin); } }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fin(); } }); }</code> </pre></td><td><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">CoroTask </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CoroToDealWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ InCurrentThread(); co_yield writerQueue; InWriterThread1(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NeedNetwork()) { co_yield networkQueue; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = InNetThread(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v) { co_yield UIQueue; InUIThread(); } } co_yield writerQueue; InWriterThread2(); ShutdownAll(); }</code> </pre> </td></tr></tbody></table><br>  Par dessus bord, il y a eu des moments: <br><br><ul><li>  comment appeler une autre coroutine de la corutine et attendre sa fin </li><li>  quels trucs utiles vous pouvez entasser dans CoroTask </li><li>  un exemple qui fait la différence entre Stackless et Stackful </li></ul><br><h2>  Autre </h2><br>  Si vous souhaitez en savoir plus sur les autres nouveautés du langage C ++ ou communiquer personnellement avec vos collègues sur les avantages, consultez la conférence C ++ Russia.  La prochaine se tiendra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le 6 octobre à Nijni Novgorod</a> . <br><br>  Si vous avez des problèmes liés au C ++ et que vous souhaitez améliorer quelque chose dans le langage ou si vous souhaitez simplement discuter des innovations possibles, alors bienvenue sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://stdcpp.ru/</a> . <br><br>  Eh bien, si cela vous surprend que Yandex.Taxi a un grand nombre de tâches qui ne sont pas liées aux graphiques, alors j'espère que cela s'est avéré être une agréable surprise pour vous :) Venez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nous rendre visite le 11 octobre</a> , nous parlerons de C ++ et plus encore. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420861/">https://habr.com/ru/post/fr420861/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420845/index.html">Apprivoiser l'obstiné à l'aide d'une béquille: le trou de l'adaptateur Wi-Fi WF2190 (Realtek8812AU Wireless LAN 802.11ac USB)</a></li>
<li><a href="../fr420847/index.html">Introduction à la programmation des shaders pour les mises en page</a></li>
<li><a href="../fr420853/index.html">Découvrez la pseudo console Windows (ConPTY)</a></li>
<li><a href="../fr420857/index.html">Itinérance Wi-Fi transparente: la théorie en pratique</a></li>
<li><a href="../fr420859/index.html">À la question de Wirth et des chaînes</a></li>
<li><a href="../fr420863/index.html">Comme nous l'avons fait le premier smartphone russe, a continué</a></li>
<li><a href="../fr420865/index.html">Le principe de moindre action. Partie 1</a></li>
<li><a href="../fr420867/index.html">Calcul d'intégrales définies: algorithmes de base</a></li>
<li><a href="../fr420869/index.html">Évacuation, HAMR et MAMR - trois façons de maximiser la capacité des disques durs modernes</a></li>
<li><a href="../fr420871/index.html">Comment nous avons déménagé notre studio web à Bali</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>