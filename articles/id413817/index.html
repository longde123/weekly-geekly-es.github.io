<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👷🏻 ⏯️ 🚙 Pemrosesan data kompetitif heterogen real-time secara ketat satu kali ⛹🏾 😱 🚥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anotasi 


 Memproses data secara real time tepat sekali ( tepat sekali ) adalah tugas yang sangat tidak sepele dan membutuhkan pendekatan yang serius...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemrosesan data kompetitif heterogen real-time secara ketat satu kali</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413817/"><p><img src="https://habrastorage.org/webt/uf/mh/m-/ufmhm-q0wjfbdgbv4jn4ece8duw.jpeg" alt="Sosis kompetitif"></p><br><h2 id="annotaciya">  Anotasi </h2><br><p>  Memproses data secara real time tepat sekali ( <em>tepat sekali</em> ) adalah tugas yang sangat tidak sepele dan membutuhkan pendekatan yang serius dan bijaksana di seluruh rantai perhitungan.  Beberapa bahkan percaya bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tugas seperti itu tidak mungkin</a> .  Pada kenyataannya, saya ingin memiliki pendekatan yang menyediakan pemrosesan yang toleran terhadap kesalahan tanpa penundaan sama sekali dan penggunaan berbagai penyimpanan data, yang mengedepankan persyaratan baru yang bahkan lebih ketat untuk sistem: <em>bersamaan tepat sekali</em> dan heterogenitas lapisan persisten.  Sampai saat ini, persyaratan seperti itu tidak mendukung sistem yang ada. </p><br><p>  Pendekatan yang diusulkan akan secara konsisten mengungkapkan bahan-bahan rahasia dan konsep-konsep yang diperlukan yang membuatnya relatif mudah untuk mengimplementasikan proses heterogen <em>secara bersamaan tepat satu kali</em> secara harfiah dari dua komponen. </p><br><h2 id="vvedenie">  Pendahuluan </h2><br><p>  Pengembang sistem terdistribusi melalui beberapa tahap: </p><br><p>  <em>Tahap 1: Algoritma</em> .  Berikut adalah studi tentang algoritma dasar, struktur data, pendekatan pemrograman seperti OOP, dll.  Kode secara eksklusif single-threaded.  Tahap awal memasuki profesi.  Namun, ini cukup rumit dan bisa bertahan bertahun-tahun. </p><br><p>  <em>Tahap 2: Multithreading</em> .  Selanjutnya, muncul pertanyaan tentang mengekstraksi efisiensi maksimum dari besi, ada multithreading, asynchrony, balap, debugging, strace, malam tanpa tidur ... Banyak yang terjebak pada tahap ini dan bahkan mulai merasakan sensasi yang tidak dapat dijelaskan di beberapa titik.  Tetapi hanya sedikit yang memahami arsitektur memori virtual dan model memori, algoritma bebas kunci / tunggu-bebas, dan berbagai model asinkron.  Dan hampir tidak ada yang pernah - verifikasi kode multi-threaded. </p><br><p>  <em>Tahap 3: Distribusi</em> .  Di sini sampah seperti itu terjadi yang tidak ada dalam dongeng atau pena untuk menggambarkan. </p><a name="habracut"></a><br><p>  Tampaknya sesuatu yang rumit.  Kami melakukan transformasi: banyak utas -&gt; banyak proses -&gt; banyak server.  Tetapi setiap langkah transformasi membawa perubahan kualitatif, dan semuanya jatuh pada sistem, menghancurkannya dan mengubahnya menjadi debu. </p><br><p>  Dan intinya di sini adalah untuk mengubah domain penanganan kesalahan dan ketersediaan memori bersama.  Jika sebelumnya selalu ada sepotong memori yang tersedia di setiap utas, dan jika diinginkan, dalam setiap proses, sekarang tidak ada bagian seperti itu dan tidak bisa.  Masing-masing untuk dirinya sendiri, mandiri dan bangga. </p><br><p>  Jika sebelumnya kegagalan dalam aliran mengubur aliran dan proses pada saat yang sama, dan ini bagus, karena  tidak menyebabkan kegagalan parsial, sekarang kegagalan parsial menjadi norma dan setiap kali sebelum setiap tindakan Anda berpikir: "bagaimana jika?".  Ini sangat menjengkelkan dan mengalihkan perhatian dari menulis, pada kenyataannya, tindakan itu sendiri bahwa kode karena ini tumbuh tidak pada waktu, tetapi dengan perintah besarnya.  Semuanya berubah menjadi mie penanganan kesalahan, pergantian status dan pelestarian konteks, pemulihan karena kegagalan satu komponen, komponen lain, tidak dapat diaksesnya beberapa layanan, dll.  dll.  Setelah mengacaukan pemantauan untuk semua hal ini, Anda dapat tidur nyenyak di laptop favorit Anda. </p><br><p>  Apakah itu masalah multithreading: Saya mengambil mutex dan pergi untuk menghancurkan memori bersama untuk kesenangan.  Cantik! </p><br><p>  Sebagai hasilnya, kami memiliki bahwa kunci dan pola yang diuji pertempuran diambil, dan yang baru, untuk menggantikannya, untuk beberapa alasan tidak disampaikan, dan ternyata seperti dalam lelucon tentang bagaimana peri melambaikan tongkatnya dan menara jatuh dari tangki. </p><br><p>  Namun, sistem terdistribusi memiliki serangkaian praktik yang terbukti dan algoritma yang terbukti.  Namun, setiap programmer yang menghargai diri sendiri menganggap tugasnya untuk menolak prestasi terkenal dan mengayuh kebaikannya sendiri, terlepas dari pengalaman yang didapat, sejumlah besar artikel ilmiah dan penelitian akademis.  Lagi pula, jika Anda bisa ke dalam algoritma dan multithreading, bagaimana Anda bisa menjadi berantakan dengan distribusi?  Tidak ada dua pendapat di sini! </p><br><p>  Akibatnya, sistem buggy, data menyimpang dan memburuk, layanan secara berkala menjadi tidak tersedia untuk ditulis, atau bahkan sama sekali tidak tersedia, karena tiba-tiba sebuah node crash, jaringan turun, Java mengkonsumsi banyak memori dan GC membosankan, dan ada banyak alasan lain yang dapat menunda akhirnya kepada pihak berwenang. </p><br><p>  Namun, bahkan dengan pendekatan yang terkenal dan terbukti, hidup tidak menjadi lebih mudah, karena  primitif andalan terdistribusi adalah kelas berat dengan persyaratan serius untuk logika kode yang dapat dieksekusi.  Oleh karena itu, sudutnya terputus sedapat mungkin.  Dan, seperti yang sering terjadi, dengan sudut yang tergesa-gesa, kesederhanaan dan skalabilitas relatif muncul, tetapi keandalan, ketersediaan, dan konsistensi sistem terdistribusi menghilang. </p><br><p>  Idealnya, saya ingin tidak berpikir sama sekali bahwa sistem kami didistribusikan dan multithreaded, yaitu  bekerja pada tahap 1 (algoritma), tanpa memikirkan ke-2 (multithreading + asynchrony) dan ke-3 (distribusi).  Cara isolasi abstraksi ini akan secara signifikan meningkatkan kesederhanaan, keandalan, dan kecepatan penulisan kode.  Sayangnya, saat ini hanya mungkin dalam mimpi. </p><br><p>  Namun, abstraksi individual memungkinkan isolasi relatif.  Salah satu contoh khasnya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penggunaan coroutine</a> , di mana alih-alih kode asinkron kita menjadi sinkron, mis.  kami beralih dari tahap 2 ke tahap 1, yang memungkinkan kami menyederhanakan penulisan dan pemeliharaan kode secara signifikan. </p><br><p>  Artikel ini secara berturut-turut mengungkapkan penggunaan algoritma bebas-kunci untuk membangun sistem waktu-nyata yang dapat didistribusikan secara konsisten dan konsisten, mis.  bagaimana pencapaian bebas-kunci dari tahap 2 membantu dalam penerapan tahap ke-3, mengurangi tugas menjadi algoritma single-threaded dari tahap 1. </p><br><h2 id="postanovka-zadachi">  Pernyataan masalah </h2><br><p>  Tugas ini hanya menggambarkan beberapa pendekatan penting dan disajikan sebagai contoh untuk memasukkan masalah ke dalam konteks.  Ini dapat dengan mudah digeneralisasikan ke kasus yang lebih kompleks, yang akan dilakukan di masa depan. </p><br><p>  <strong>Tugas: pemrosesan data streaming real-time</strong> . </p><br><p>  Ada dua aliran angka.  Pawang membaca data dari aliran input ini dan memilih angka terakhir untuk periode tertentu.  Angka-angka ini dirata-rata selama interval waktu ini, yaitu  di jendela data geser untuk waktu tertentu.  Nilai rata-rata yang diperoleh harus ditulis ke antrian output untuk diproses selanjutnya.  Selain itu, jika jumlah angka di jendela melebihi ambang tertentu, kemudian naikkan satu penghitung di basis data transaksional eksternal. </p><br><p><img src="https://habrastorage.org/webt/nf/9d/jh/nf9djhbhsjmrumrg5eckb1h6u_c.png" alt="Awal"></p><br><p>  Kami mencatat beberapa fitur dari masalah ini. </p><br><ol><li>  <em>Non-determinisme</em> .  Ada dua sumber perilaku non-deterministik: ini adalah bacaan dari dua aliran, serta jendela waktu.  Jelas bahwa membaca dapat dilakukan dengan cara yang berbeda, dan hasil akhir akan tergantung pada urutan data yang akan diekstraksi.  Jendela waktu juga mengubah hasil dari awal ke awal, sebagai  jumlah data di jendela akan tergantung pada kecepatan pekerjaan. </li><li>  <em>Keadaan pawang</em> .  Ada keadaan pawang dalam bentuk serangkaian angka di jendela, di mana hasil saat ini dan selanjutnya dari pekerjaan tergantung.  Yaitu  kami memiliki penangan yang tegas. </li><li>  <em>Interaksi dengan penyimpanan eksternal</em> .  Penting untuk memperbarui nilai penghitung di database eksternal.  Poin penting adalah bahwa jenis penyimpanan eksternal berbeda dari penyimpanan keadaan prosesor dan utas. </li></ol><br><p>  Semua ini, seperti yang akan ditunjukkan di bawah ini, secara serius mempengaruhi alat yang digunakan dan metode implementasi yang mungkin. </p><br><p>  Tetap menambahkan sentuhan kecil pada tugas, yang segera mentransfer tugas dari area yang sangat rumit ke yang tidak mungkin: jaminan <em>secara bersamaan-sekali</em> diperlukan. </p><br><h2 id="exactly-once">  Tepat sekali </h2><br><p>  <em>Tepat-sekali</em> sering ditafsirkan secara luas, yang mengebiri istilah itu sendiri, dan tidak lagi memenuhi persyaratan asli dari tugas tersebut.  Jika kita berbicara tentang sistem yang berjalan secara lokal di satu komputer - maka semuanya sederhana: ambil lebih banyak, lanjutkan.  Tetapi dalam kasus ini kita berbicara tentang sistem terdistribusi di mana: </p><br><ol><li>  Jumlah penangan bisa besar: setiap penangan bekerja dengan bagian datanya sendiri.  Selain itu, hasilnya dapat ditambahkan ke berbagai tempat, misalnya, database eksternal, bahkan mungkin diacak. </li><li>  Setiap pawang tiba-tiba dapat berhenti memproses.  Sistem toleran kesalahan menyiratkan operasi yang berkelanjutan bahkan dalam hal kegagalan bagian-bagian individu dari sistem. </li></ol><br><p>  Dengan demikian, kita harus siap dengan kenyataan bahwa pawang bisa jatuh, dan pawang lain harus mengambil pekerjaan yang sudah dilakukan dan melanjutkan pemrosesan. </p><br><p>  Pertanyaan segera muncul: apa yang akan berarti <em>sekali</em> jika pawang non-deterministik bekerja?  Lagi pula, setiap kali kita memulai ulang, kita akan menerima, secara umum, keadaan yang berbeda.  Jawabannya di sini sederhana: dengan <em>tepat-sekali,</em> ada eksekusi sistem di mana setiap nilai input diproses tepat sekali, memberikan hasil keluaran yang sesuai.  Selain itu, eksekusi ini tidak harus secara fisik berada pada simpul yang sama.  Tetapi hasilnya harus seolah-olah semuanya diproses pada satu node logis <em>tanpa crash</em> . </p><br><h2 id="concurrent-exactly-once">  Bersamaan tepat-sekali </h2><br><p>  Untuk memperparah persyaratan, kami memperkenalkan konsep baru: <em>bersamaan tepat sekali</em> .  Perbedaan mendasar dari sederhana <em>persis-sekali</em> adalah tidak adanya jeda selama pemrosesan, seolah-olah semuanya diproses pada node yang sama <strong>tanpa tetes</strong> dan <strong>tanpa jeda</strong> .  Dalam tugas kami, kami akan membutuhkan tepat <em>bersamaan satu kali</em> , untuk kesederhanaan presentasi, agar tidak mempertimbangkan perbandingan dengan sistem yang ada yang tidak tersedia saat ini. </p><br><p>  Konsekuensi dari memiliki persyaratan seperti itu akan dibahas di bawah ini. </p><br><h2 id="tranzakcionnost">  Transaksional </h2><br><p>  Agar pembaca semakin diilhami oleh kompleksitas yang telah muncul, mari kita lihat berbagai skenario buruk yang harus dipertimbangkan ketika mengembangkan sistem seperti itu.  Kami juga akan mencoba menggunakan pendekatan umum yang akan memungkinkan kami untuk menyelesaikan masalah di atas dengan mempertimbangkan persyaratan kami. </p><br><p>  Hal pertama yang terlintas dalam pikiran adalah kebutuhan untuk mencatat keadaan pawang dan aliran input dan output.  Keadaan aliran keluaran dijelaskan oleh antrian angka yang sederhana, dan keadaan aliran input oleh posisi di dalamnya.  Intinya, stream adalah antrian tanpa batas, dan posisi dalam antrian secara unik menentukan lokasi. </p><br><p><img src="https://habrastorage.org/webt/iu/h0/pf/iuh0pfzcezje80kdbsv3idyeu9a.jpeg" alt="Ide"></p><br><p>  Implementasi penangan naif berikut muncul dengan menggunakan semacam gudang data.  Pada tahap ini, sifat penyimpanan khusus tidak akan penting bagi kami.  Kami akan menggunakan bahasa Pseco untuk menggambarkan ide (Pseco: = kode semu): </p><br><pre><code class="hljs pgsql">handle(input_queues, output_queues, state): #    input_indexes = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.get_input_indexes() #      <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #         items, new_input_indexes = input_queues.get_from(input_indexes) #    state.queue.push(items) #     duration state.queue.trim_time_window(duration) avg = state.queue.avg() need_update_counter = state.queue.size() &gt; size_boundary # (A)      output_queues[<span class="hljs-number"><span class="hljs-number">0</span></span>].push(avg) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> need_update_counter: # (B)      db.increment_counter() # (C)     <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.save_state(state) # (D)    <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.save_queue_indexes(new_input_indexes) # (E)    input_indexes = new_input_indexes</code> </pre> <br><p>  Berikut adalah algoritma single-threaded sederhana yang membaca data dari input stream dan menulis nilai yang diinginkan sesuai dengan tugas yang dijelaskan di atas. </p><br><p>  Mari kita lihat apa yang terjadi jika sebuah node jatuh pada titik yang berubah-ubah dalam waktu, dan juga setelah melanjutkan pekerjaan.  Jelas bahwa jika terjadi penurunan pada titik <code>(A)</code> dan <code>(E)</code> semuanya akan baik-baik saja: baik data belum direkam di mana pun dan kami hanya mengembalikan keadaan dan melanjutkan pada simpul lain, atau semua data yang diperlukan telah direkam dan lanjutkan langkah berikutnya. </p><br><p>  Namun, jika terjadi kejatuhan di semua titik lain, masalah tak terduga menunggu kita.  Jika penurunan terjadi pada titik <code>(B)</code> , maka ketika pawang restart, kami akan mengembalikan keadaan dan merekam ulang nilai rata-rata dalam kisaran kisaran yang sama.  Dalam kasus jatuh pada titik <code>(C)</code> selain duplikat rata-rata, duplikat akan terjadi dalam kenaikan nilai.  Dan jika terjadi penurunan <code>(D)</code> kita akan mendapatkan status handler yang tidak konsisten: state berhubungan dengan momen baru dalam waktu, dan kita akan membaca nilai dari input yang lama. </p><br><p><img src="https://habrastorage.org/webt/fn/8z/6f/fn8z6f9t3y-fe2hzlepgnie7qps.jpeg" alt="Kejutan"></p><br><p>  Pada saat yang sama, tidak ada yang akan berubah secara fundamental ketika menata ulang operasi perekaman: inkonsistensi dan duplikat akan tetap demikian.  Dengan demikian, kita sampai pada kesimpulan bahwa semua tindakan untuk mengubah keadaan penangan dalam repositori, antrian output dan basis data harus dilakukan secara transaksi, yaitu.  semuanya atom pada saat bersamaan. </p><br><p>  Oleh karena itu, perlu untuk mengembangkan suatu mekanisme sehingga penyimpanan yang berbeda dapat mengubah keadaannya secara transaksi, dan tidak di dalam masing-masing secara independen, tetapi secara transaksial antara semua penyimpanan secara bersamaan.  Tentu saja, Anda dapat menempatkan penyimpanan kami di dalam basis data eksternal, namun, tugas tersebut mengasumsikan bahwa mesin basis data dan mesin untuk kerangka kerja pemrosesan data streaming terpisah dan bekerja secara independen satu sama lain.  Di sini saya ingin mempertimbangkan kasus yang paling sulit, karena  kasus-kasus sederhana tidak menarik untuk dipertimbangkan. </p><br><h2 id="konkurentnaya-otzyvchivost">  Daya Respons Kompetitif </h2><br><p>  Pertimbangkan eksekusi kompetitif tepat sekali dengan lebih detail.  Dalam kasus sistem toleransi kesalahan, kami membutuhkan kelanjutan pekerjaan dari beberapa titik.  Jelas bahwa poin ini akan menjadi poin di masa lalu, karena  Untuk mempertahankan kinerja, tidak mungkin untuk menyimpan semua momen perubahan kondisi di masa sekarang dan di masa depan: baik hasil terakhir dari operasi atau sekelompok nilai untuk meningkatkan throughput disimpan.  Perilaku ini segera membawa kita pada fakta bahwa setelah pemulihan keadaan prosesor, akan ada beberapa keterlambatan dalam hasil, itu akan meningkat dengan meningkatnya ukuran kelompok nilai dan ukuran negara. </p><br><p>  Selain keterlambatan ini, ada juga keterlambatan dalam sistem yang terkait dengan memuat negara ke node lain.  Selain itu, pendeteksian simpul masalah juga membutuhkan waktu, dan seringkali banyak.  Hal ini disebabkan, pertama-tama, oleh kenyataan bahwa jika kita menetapkan waktu deteksi yang pendek, maka kemungkinan positif palsu adalah mungkin, yang akan mengarah pada semua jenis efek khusus yang tidak menyenangkan. </p><br><p>  Selain itu, dengan bertambahnya jumlah prosesor paralel, tiba-tiba ternyata tidak semuanya bekerja dengan baik meskipun tidak ada kegagalan.  Terkadang tumpul terjadi, yang juga menyebabkan keterlambatan dalam pemrosesan.  Alasan tumpul tersebut dapat bervariasi: </p><br><ol><li>  <em>Perangkat lunak</em> : Jeda GC, fragmentasi memori, jeda pengalokasi, gangguan kernel dan penjadwalan tugas, masalah dengan driver perangkat yang menyebabkan perlambatan. </li><li>  <em>Perangkat keras</em> : disk tinggi atau beban jaringan, pelambatan CPU karena masalah pendinginan, kelebihan beban, dll., Perlambatan disk karena masalah teknis. </li></ol><br><p>  Dan ini sama sekali bukan daftar masalah yang bisa memperlambat penangan. </p><br><p>  Karenanya, melambat adalah pemberian yang dengannya seseorang harus hidup.  Terkadang ini bukan masalah serius, dan kadang-kadang sangat penting untuk mempertahankan kecepatan pemrosesan yang tinggi meskipun mengalami kegagalan atau perlambatan. </p><br><p>  Segera muncul ide duplikasi sistem: mari kita jalankan untuk satu dan aliran data yang sama bukan hanya satu tapi dua prosesor sekaligus, atau bahkan tiga.  Masalahnya di sini adalah bahwa dalam kasus ini, duplikat dan perilaku sistem yang tidak konsisten dapat dengan mudah terjadi.  Biasanya, kerangka kerja tidak dirancang untuk perilaku ini dan menyarankan bahwa jumlah penangan pada waktu tertentu tidak melebihi satu.  Sistem yang memungkinkan duplikasi eksekusi dijelaskan disebut <em>bersamaan tepat sekali</em> . </p><br><p>  Arsitektur ini memungkinkan Anda untuk memecahkan beberapa masalah sekaligus: </p><br><ol><li>  Perilaku gagal: jika salah satu node jatuh, yang lain terus bekerja seolah-olah tidak ada yang terjadi.  Tidak perlu koordinasi tambahan, karena  pawang kedua dieksekusi terlepas dari kondisi yang pertama. </li><li>  Menghapus tumpul: siapa pun yang pertama kali memberikan hasil itu baik untuknya.  Yang lain hanya perlu mengambil negara baru dan melanjutkan dari saat ini. </li></ol><br><p>  Pendekatan ini, khususnya, memungkinkan Anda untuk menyelesaikan perhitungan panjang yang sulit, sulit untuk waktu yang lebih mudah diprediksi, karena  kemungkinan keduanya akan bodoh dan jatuh jauh lebih sedikit. </p><br><h3 id="veroyatnostnaya-ocenka">  Penilaian probabilitas </h3><br><p>  Mari kita coba mengevaluasi manfaat dari duplikasi kinerja.  Misalkan sesuatu terjadi rata-rata setiap hari dengan pawang: baik GC telah tumpul, atau simpul berbohong, atau wadah telah menjadi kanker.  Misalkan kita menyiapkan paket data dalam 10 detik. </p><br><p>  Maka probabilitas bahwa sesuatu akan terjadi selama pembuatan paket adalah <code>10 / (24 · 3600) ≃ 1e-4</code> . </p><br><p>  Jika Anda menjalankan dua penangan secara paralel, maka kemungkinan keduanya terbang adalah <code>≃ 1e-8</code> .  Jadi acara ini akan datang dalam 23 tahun!  Ya, sistem tidak hidup banyak, yang berarti ini tidak akan pernah terjadi! </p><br><p>  Selain itu, jika waktu persiapan paket akan lebih pendek dan / atau tumpul akan terjadi lebih jarang, maka angka ini hanya akan meningkat. </p><br><p>  Dengan demikian, kami menyimpulkan bahwa pendekatan yang dipertimbangkan secara signifikan meningkatkan keandalan seluruh sistem kami.  Tetap hanya untuk memecahkan pertanyaan kecil seperti ini: di mana membaca tentang bagaimana membuat sistem <em>konkuren sekali saja</em> .  Dan jawabannya sederhana: Anda harus membaca di sini. </p><br><h2 id="polutranzakcii">  Setengah transaksi </h2><br><p>  Untuk diskusi lebih lanjut, kita perlu konsep <em>setengah transaksi</em> .  Cara termudah untuk menjelaskannya adalah dengan sebuah contoh. </p><br><p>  Pertimbangkan untuk mentransfer dana dari satu rekening bank ke rekening bank lain.  Pendekatan tradisional menggunakan transaksi dalam bahasa Pseco dapat digambarkan sebagai berikut: </p><br><pre> <code class="hljs pgsql">transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): tx = db.begin_transaction() amount_from = tx.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.insufficient_funds tx.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount_from - amount) tx.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, tx.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) + amount) tx.<span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok</code> </pre> <br><p>  Namun, bagaimana jika transaksi ini tidak tersedia untuk kita?  Menggunakan kunci, ini bisa dilakukan sebagai berikut: </p><br><pre> <code class="hljs pgsql">transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): #         lock_from = db.<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) lock_to = db.<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) amount_from = db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.insufficient_funds db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount_from - amount) db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) + amount) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok</code> </pre> <br><p>  Pendekatan ini dapat menyebabkan kebuntuan, seperti  kunci dapat diambil dalam urutan berbeda secara paralel.  Untuk memperbaiki perilaku ini, cukup dengan memperkenalkan fungsi yang secara bersamaan mengambil beberapa kunci dalam urutan deterministik (misalnya, mengurutkan berdasarkan kunci), yang sepenuhnya menghilangkan kemungkinan deadlock. </p><br><p>  Namun, implementasinya dapat disederhanakan: </p><br><pre> <code class="hljs vbscript">transfer(from, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): lock_from = db.lock(from) amount_from = db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(from) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: return <span class="hljs-keyword"><span class="hljs-keyword">error</span></span>.insufficient_funds db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(from, amount_from - amount) lock_from.release() #   , # .. db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>...)     lock_to = db.lock(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) + amount) return ok</code> </pre> <br><p>  Pendekatan ini juga membuat keadaan akhir konsisten, melestarikan invarian dengan jenis mencegah pengeluaran dana yang berlebihan.  Perbedaan utama dari pendekatan sebelumnya adalah bahwa dalam implementasi seperti itu kami memiliki periode waktu tertentu di mana akun berada dalam keadaan tidak konsisten.  Yaitu, operasi seperti itu menyiratkan bahwa keadaan total dana dalam akun tidak berubah.  Dalam kasus ini, ada kesenjangan waktu antara <code>lock_from.release()</code> dan <code>db.lock(to)</code> , di mana database dapat mengembalikan nilai yang tidak konsisten: jumlah total mungkin berbeda dari yang benar ke bawah. </p><br><p>  Bahkan, kami membagi satu transaksi untuk mentransfer uang menjadi dua setengah transaksi: </p><br><ol><li>  Setengah transaksi pertama membuat cek dan mengurangi jumlah yang diperlukan dari akun. </li><li>  Transaksi paruh kedua menulis jumlah yang ditarik ke akun lain. </li></ol><br><p>  Jelas bahwa membagi transaksi menjadi yang lebih kecil, secara umum, melanggar perilaku transaksional.  Dan contoh di atas tidak terkecuali.  Namun, jika semua setengah transaksi dalam rantai terpenuhi sepenuhnya, maka hasilnya akan konsisten dengan semua invarian dipertahankan.  Inilah tepatnya yang merupakan properti penting dari rantai setengah transaksi. </p><br><p>  Untuk sementara kehilangan beberapa konsistensi, namun demikian kami memperoleh fitur bermanfaat lainnya: kemandirian operasi, dan, sebagai hasilnya, skalabilitas yang lebih baik.  Kemandirian dimanifestasikan dalam kenyataan bahwa setengah transaksi setiap kali bekerja hanya dengan satu baris, membaca, memeriksa dan mengubah datanya, tanpa berkomunikasi dengan data lain.  Dengan demikian, Anda dapat mengocok basis data yang transaksinya bekerja hanya dengan satu pecahan.  Selain itu, pendekatan ini dapat digunakan dalam kasus repositori heterogen, yaitu  setengah transaksi dapat dimulai pada satu jenis penyimpanan, dan berakhir pada yang lain.  Ini adalah properti yang sangat berguna yang akan digunakan di masa depan. </p><br><p>  Muncul pertanyaan yang sah: bagaimana menerapkan setengah trans dalam sistem terdistribusi dan tidak menyapu?  Untuk mengatasi masalah ini, Anda perlu mempertimbangkan pendekatan bebas kunci. </p><br><h2 id="lock-free">  Bebas kunci </h2><br><p>  Seperti yang Anda ketahui, pendekatan bebas-kunci terkadang meningkatkan kinerja sistem multi-utas, khususnya dalam hal akses kompetitif ke sumber daya.  Namun, sama sekali tidak jelas bahwa pendekatan semacam itu dapat digunakan dalam sistem terdistribusi.  Mari kita menggali lebih dalam dan mempertimbangkan apa yang bebas kunci dan mengapa properti ini akan berguna dalam menyelesaikan masalah kita. </p><br><p>  Beberapa pengembang terkadang tidak begitu mengerti apa itu bebas kunci.  Pandangan picik menunjukkan bahwa ini adalah sesuatu yang terkait dengan instruksi prosesor atom.  Penting untuk dipahami di sini bahwa penguncian bebas berarti penggunaan "atom", sebaliknya tidak benar, yaitu,  tidak semua "atom" memberikan perilaku bebas kunci. </p><br><p>  Properti penting dari algoritma bebas kunci adalah setidaknya satu utas membuat kemajuan dalam sistem.  Tetapi karena beberapa alasan, banyak atribut properti ini sebagai definisi (itu adalah definisi yang tumpul yang dapat ditemukan, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di Wikipedia</a> ).  Di sini perlu menambahkan satu nuansa penting: kemajuan dibuat bahkan dalam kasus tumpul satu atau lebih utas.  Ini adalah poin yang sangat kritis yang sering diabaikan dan memiliki implikasi serius bagi sistem terdistribusi. </p><br><p>  Mengapa tidak adanya kondisi kemajuan setidaknya satu utas meniadakan konsep algoritma bebas kunci?  Faktanya adalah bahwa dalam kasus ini spinlock biasa juga akan bebas kunci.  Memang, orang yang mengambil kunci akan membuat kemajuan.  Apakah ada utas dengan progres =&gt; bebas kunci? </p><br><p>  Jelas, tanpa kunci berarti tanpa kunci, sementara spinlock dengan namanya menunjukkan bahwa ini adalah kunci yang sebenarnya.  Itulah sebabnya penting untuk menambahkan kondisi pada kemajuan, bahkan dalam kasus tumpul.  Lagi pula, penundaan ini bisa bertahan tanpa batas waktu, karena  definisi tidak mengatakan apa-apa tentang garis waktu atas.  Dan jika demikian, maka penundaan tersebut akan setara dalam arti dengan mematikan arus.  Dalam hal ini, algoritma bebas kunci akan menghasilkan kemajuan dalam kasus ini. </p><br><p>  Tetapi siapa yang mengatakan pendekatan bebas kunci berlaku secara eksklusif untuk sistem multi-utas?  Mengganti thread dalam proses yang sama pada node yang sama dengan proses pada node yang berbeda, dan memori bersama dari thread dengan penyimpanan terdistribusi bersama, kami mendapatkan algoritma terdistribusi bebas kunci. </p><br><p>  Penurunan node dalam sistem seperti itu sama dengan penundaan dalam pelaksanaan utas untuk beberapa waktu, karena  saatnya memulihkan pekerjaan.  Pada saat yang sama, pendekatan bebas-kunci memungkinkan peserta lain dalam sistem terdistribusi untuk terus bekerja.  Selain itu, algoritma bebas kunci khusus dapat dijalankan secara paralel satu sama lain, mendeteksi perubahan kompetitif, dan memotong duplikat. </p><br><p>  <em>Pendekatan Tepat sekali</em> menyiratkan adanya penyimpanan terdistribusi yang konsisten.  Penyimpanan seperti itu sebagai aturan mewakili tabel nilai kunci yang persisten besar.  Kemungkinan operasi: <code>set</code> , <code>get</code> , <code>del</code> .  Namun, operasi yang lebih rumit diperlukan untuk pendekatan bebas kunci: CAS atau compare-and-swap.  Mari kita pertimbangkan lebih rinci operasi ini, kemungkinan penggunaannya, serta hasil apa yang diberikannya. </p><br><h3 id="cas">  Cas </h3><br><p>  CAS atau compare-and-swap adalah primitif sinkronisasi utama dan penting untuk algoritma bebas kunci dan tunggu.  Esensinya dapat diilustrasikan oleh Pseco berikut: </p><br><pre> <code class="hljs kotlin">CAS(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected, new): # ,   atomic,   atomic: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() != expected: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(new) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  Kadang-kadang, untuk optimasi, mereka mengembalikan tidak <code>true</code> atau <code>false</code> , tetapi nilai sebelumnya, karena  sangat sering operasi seperti itu dilakukan dalam satu lingkaran, dan untuk mendapatkan nilai yang <code>expected</code> , Anda harus terlebih dahulu membacanya: </p><br><pre> <code class="hljs vala">CAS_optimized(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>): # ,   atomic,   atomic: current = <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current == expected: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current #  CAS   CAS_optimized CAS(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.CAS_optimized(expected, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>) == expected</code> </pre> <br><p>  Pendekatan ini dapat menghemat satu bacaan.  Sebagai bagian dari tinjauan kami, kami akan menggunakan bentuk <code>CAS</code> sederhana, karena  jika diinginkan, optimasi tersebut dapat dilakukan secara independen. </p><br><p>  Dalam hal sistem terdistribusi, setiap perubahan diversi.  Yaitu  pertama-tama kita membaca nilai dari toko, mendapatkan versi data saat ini.  Dan kemudian kami mencoba menulis, berharap bahwa versi data tidak berubah.  Dalam hal ini, versi bertambah setiap kali data diperbarui: </p><br><pre> <code class="hljs cs">CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected_version, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>): atomic: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.get_version() != expected_version: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>, expected_version + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  Pendekatan ini memungkinkan Anda untuk lebih akurat mengontrol pembaruan nilai, menghindari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah ABA</a> .  Khususnya, versi didukung oleh Etcd dan Zookeeper. </p><br><p>  Perhatikan properti penting yang <code>CAS_versioned</code> operasi <code>CAS_versioned</code> .  Faktanya adalah bahwa operasi seperti itu dapat diulang tanpa mengurangi logika superior.  Dalam pemrograman multi-utas, properti ini tidak memiliki nilai khusus, karena  di sana, jika operasi gagal, maka kita tahu pasti bahwa itu tidak berlaku.  Dalam kasus sistem terdistribusi, invarian ini dilanggar, karena  permintaan dapat mencapai penerima, tetapi respons yang berhasil tidak ada lagi.  Oleh karena itu, penting untuk dapat mengirim ulang permintaan tanpa takut melanggar invarian logika tingkat tinggi. </p><br><p>  Properti inilah yang <code>CAS_versioned</code> operasi <code>CAS_versioned</code> .  Bahkan, operasi ini dapat diulang tanpa henti hingga respons nyata dari penerima dikembalikan.  Yang, pada gilirannya, melempar seluruh kelas kesalahan yang terkait dengan interaksi jaringan. </p><br><h3 id="primer">  Contoh </h3><br><p>  Mari kita lihat bagaimana, berdasarkan <code>CAS_versioned</code> dan setengah transaksi, untuk mentransfer dari satu akun ke akun lain, yang termasuk, misalnya, ke salinan Etcd yang berbeda.  Di sini, saya berasumsi bahwa fungsi <code>CAS_versioned</code> sudah diterapkan berdasarkan pada API yang disediakan. </p><br><pre> <code class="hljs pgsql">withdraw(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount): # CAS- <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #     version_from, amount_from = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.insufficient_funds <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.CAS_versioned(version_from, amount_from - amount): break <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok deposit(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): # CAS- <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: version_to, amount_to = <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.CAS_versioned(version_to, amount_to + amount): break <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): #   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> withdraw(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ok: #     , #    deposit(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount)</code> </pre> <br><p>  Di sini kami membagi operasi kami menjadi setengah transaksi, dan kami melakukan setiap setengah transaksi melalui operasi <code>CAS_versioned</code> .  Pendekatan ini memungkinkan Anda untuk bekerja secara independen dengan masing-masing akun, memungkinkan penggunaan penyimpanan heterogen yang tidak terhubung satu sama lain.  Satu-satunya masalah yang menunggu kita di sini adalah hilangnya uang jika terjadi penurunan proses saat ini dalam interval antara setengah transaksi. </p><br><h2 id="ochered">  Antrian </h2><br><p>  Untuk melanjutkan, Anda perlu mengimplementasikan antrian acara.  Idenya adalah agar penangan berkomunikasi satu sama lain, Anda harus memiliki antrian pesan yang dipesan di mana data tidak hilang atau digandakan.  Dengan demikian, semua interaksi dalam rantai penangan akan dibangun di atas primitif ini.  Ini juga merupakan alat yang berguna untuk menganalisis dan mengaudit aliran data yang masuk dan keluar.  Selain itu, mutasi dari keadaan penangan juga dapat dilakukan melalui antrian. </p><br><p>  Antrean akan terdiri dari sepasang operasi: </p><br><ol><li>  Tambahkan pesan ke akhir antrian. </li><li>  Menerima pesan dari antrian di indeks yang ditentukan. </li></ol><br><p>  Dalam konteks ini, saya tidak mempertimbangkan menghapus pesan dari antrian karena beberapa alasan: </p><br><ol><li>  Beberapa prosesor dapat membaca dari antrian yang sama.  Menghapus sinkronisasi akan menjadi tugas yang tidak sepele, meskipun bukan tidak mungkin. </li><li>  Berguna untuk menjaga antrian untuk interval yang relatif panjang (hari atau minggu) untuk debugging dan audit.  Kegunaan properti ini sulit ditaksir terlalu tinggi. </li><li>  Anda dapat menghapus item lama baik sesuai jadwal atau dengan mengatur TTL pada item antrian.  Penting untuk memastikan bahwa prosesor mengelola untuk memproses data sebelum sapu tiba dan membersihkan semuanya.  Jika waktu pemrosesan adalah urutan detik, dan TTL urutan hari, maka tidak ada yang terjadi. </li></ol><br><p>  Untuk menyimpan elemen dan mengimplementasikan penambahan secara efektif, kita perlu: </p><br><ol><li>  Nilai dengan indeks saat ini.  Indeks ini menunjuk ke akhir antrian untuk menambahkan item. </li><li>  ,    . </li></ol><br><h3 id="kak-by-lock-free-ochered">   lock-free  </h3><br><p>          :        .        : </p><br><ol><li>    CAS     . </li><li>       . </li></ol><br><p>    ,    ,     . </p><br><ol><li> <strong>    lock-free</strong> .  ,      ,          . Lock-free? !   ,    2 :   .         lock-free,     — !    ,  ,        ,   .              .         , ..            ,     . </li><li> <strong>    </strong> .         ,               .    . </li></ol><br><p>  ,    lock-free         . </p><br><h3 id="lock-free-realizaciya-dobavleniya"> Lock-free   </h3><br><p> ,  ,     :   , ..      ,    : </p><br><pre> <code class="hljs pgsql">push(queue, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): #      <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = queue.get_current_index() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #  ,    #    var = queue.at(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) #  = <span class="hljs-number"><span class="hljs-number">0</span></span>   , ..   # ,         <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> var.CAS_versioned(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): #   ,    queue.update_index(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) break #   , .   <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = max(queue.get_current_index(), <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) update_index(queue, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #     cur_index, version = queue.get_current_index_versioned() #      , #  , .   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cur_index &gt;= <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>: # -     , #        break <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> queue.current_index_var().CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): #      ,   break # -  . # ,      ,  </code> </pre> <br><p>      .   ,            (     — ,  ,     ).       lock-free   .    ? </p><br><p>   ,   <code>push</code>     ,      ! ,             ,      . </p><br><p>        .       :         .   ,      -   ,  -               .  ,      , ..      .          .        ?       , ..     ,    ,        . </p><br><p>  ,       ,          . ..    .        ,    ,     .          ,       . </p><br><p>  ,       .               ,   .    ,   ,     .       ,    . </p><br><h2 id="vzaimodeystvie-ocheredey">   </h2><br><p>  ,  ,   ,      . </p><br><p> <em></em> .       . </p><br><p>    ,      : </p><br><ol><li>  , ..  stateless. </li><li>  ,     — . </li></ol><br><p> ,    ,        <em>concurrent exactly-once</em> . </p><br><p>        : </p><br><pre> <code class="hljs pgsql">handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output): <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) output.push(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>   .        : </p><br><pre> <code class="hljs pgsql">handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output, state): #   <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = state.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) output.push(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span> #   state.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>)</code> </pre> <br><p>     <em>exactly-once</em> .   ,           ,    ,    . </p><br><p>    <em>exactly-once</em> ,     ,    . ..,  ,       ,       ,   ,    —      : </p><br><pre> <code class="hljs pgsql">#       get_next_index(queue): <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = queue.get_index() #     <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> queue.has(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): #    queue.push <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = max(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>, queue.get_index()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> #      . #  <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>    push_at(queue, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): var = queue.at(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> var.CAS_versioned(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): #   queue.update_index(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output, state): #   #    {PREPARING, <span class="hljs-number"><span class="hljs-number">0</span></span>} fsm_state = state.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: switch fsm_state: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {PREPARING, input_index}: #   :   , #        output_index = output.get_next_index() fsm_state = {WRITING, input_index, output_index} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {WRITING, input_index, output_index}: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(input_index) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output.push_at(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, output_index): #  ,     input_index += <span class="hljs-number"><span class="hljs-number">1</span></span> #    ,  push_at  <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, #        fsm_state = {PREPARING, input_index} state.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(fsm_state)</code> </pre> <br><p>        <code>push_at</code> ?      ,   .   ,    ,  ,    .   ,               .             .          -  ,     lock-free . </p><br><p>  ,      : </p><br><ol><li>   :       . </li><li> ,  :      . </li></ol><br><p>   :   <em>concurrent</em>  <em>exactly-once</em> . </p><br><p>      ?   : </p><br><ol><li>       ,         ,   <code>push_at</code>     false.            . </li><li>       ,      . ,   ,       . </li></ol><br><p>     <em>concurrent exactly-once</em>   ?   ,     ,            .    ,           .            . </p><br><p>          : </p><br><pre> <code class="hljs pgsql">#     ,  ,     # ..       <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, #      <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>. #       <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> push_at_idempotent(queue, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> queue.push_at(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> queue.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output, state): <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: switch fsm_state: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {PREPARING, input_index}: #   ,   , #        output_index = output.get_next_index() fsm_state = {WRITING, input_index, output_index} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {WRITING, input_index, output_index}: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(input_index) #   , #       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output.push_at_idempotent(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, output_index): input_index += <span class="hljs-number"><span class="hljs-number">1</span></span> fsm_state = {PREPARING, input_index} #     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state.CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state): <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: #   ,    <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned()</code> </pre> <br><p>  : </p><br><p><img src="https://habrastorage.org/webt/rx/qi/ub/rxqiubplbrrdlokp_sniqhktmvu.png" alt="Sederhana"></p><br><p>     ,     .     ,           . </p><br><p>             kernel panic,   ,    ..              .              .       :      ,    .  ,        . </p><br><p>  ,    <strong> </strong>    ,    . </p><br><h2 id="reshenie-nachalnoy-zadachi">    </h2><br><p>        :    . </p><br><p>       :  ,     ,    ,      ,      : </p><br><pre> <code class="hljs pgsql">#  : # - input_queues -   # - output_queues -   # - state -    # - <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span> -    : state, inputs -&gt; state, outputs handle(input_queues, output_queues, state, <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>): #        <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: switch fsm_state: # input_indexes       <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {HANDLING, user_state, input_indexes}: #       inputs = [queue.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> queue, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> zip(input_queues, input_indexes)] #   ,    next_indexes = next(inputs, input_indexes) #    #     user_state, outputs = <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>(user_state, inputs) #      , #     fsm_state = {PREPARING, user_state, next_indexes, outputs, <span class="hljs-number"><span class="hljs-number">0</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {PREPARING, user_state, input_indexes, outputs, output_pos}: #  ,      #    output_index = output_queues[output_pos].get_next_index() #     fsm_state = { WRITING, user_state, input_indexes, outputs, output_pos, output_index } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> { WRITING, user_state, input_indexes, outputs, output_pos, output_index }: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = outputs[output_pos] #       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output_queues[output_pos].push_at_idempotent( <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, output_index ): #  ,      output_pos += <span class="hljs-number"><span class="hljs-number">1</span></span> #    ,      PREPARING. #     #     fsm_state = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output_pos == len(outputs): #   , #       {HANDLING, user_state, input_indexes} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: #       #   , #         {PREPARING, user_state, input_indexes, outputs, output_pos} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state.CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state): <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: #   ,    <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned()</code> </pre> <br><p>     : </p><br><p><img src="https://habrastorage.org/webt/fe/mk/bg/femkbgvjaxyy2gi9ye5wkaufqf4.png" alt="terakhir"></p><br><p>      : <code>HANDLING</code> .        , ..,  ,     .  ,      .    ,   <code>PREPARING</code>  <code>WRITING</code>   ,         .     ,      <code>HANDLING</code> . </p><br><p>  ,      ,       ,          .   ,           .  ,            . </p><br><p>      .         .               . </p><br><p><img src="https://habrastorage.org/webt/or/qk/tg/orqktgqgrdw-9tv0_wkl2wt_rye.png" alt="terakhir"></p><br><p>   : </p><br><pre> <code class="hljs cpp">my_handler(state, inputs): #      state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.push(inputs) #    duration state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.trim_time_window(duration) #   avg = state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.avg() need_update_counter = state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.size() &gt; size_boundary <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state, [ avg, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> need_update_counter: <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: # none      none ]</code> </pre> <br><p>  ,      ,           <em>concurrent exactly-once</em>     <code>handle</code> . </p><br><p>        : </p><br><pre> <code class="hljs pgsql">handle_db(input_queue, db): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #      tx = db.begin_transaction() #     . #      , #      <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = tx.get_current_index() #    tx.write_current_index(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) #      <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = intput_queue.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: #    tx.increment_counter() tx.<span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>() #   ,      , #          </code> </pre> <br><p>    .  Karena       ,         , , ,    <em>concurrent exactly-once</em> .       . </p><br><h2 id="za-bortom">   </h2><br><p>   —            .        ,      ,     . </p><br><h3 id="optimizacii-dlya-konkretnogo-hranilischa">     </h3><br><p>      ,      ,       .           ,  ,          . </p><br><h3 id="asinhronnaya-publikaciya">   </h3><br><p>           .    ,     .  Karena        ,      .              .        . </p><br><h3 id="gruppirovka-znacheniy">   </h3><br><p>        —   . ,       ,     .    ,     -  ,   ,    .        , .. ,    ,        . </p><br><h3 id="dvoynoe-shardirovanie">   </h3><br><p>       .   ,     ,           .            ,    ,    . </p><br><h2 id="fundamentalnost-podhoda">   </h2><br><p>     . ,         .  :          ,      .     ,       . </p><br><p>      ,   ,      : </p><br><ol><li>    ,   .          . </li><li>     .      ,        . </li><li>          .    ,       .      ,   ,        . ..          .     :    . </li></ol><br><p>     , , -,     ,  -,     . </p><br><p>     ,     .     : </p><br><pre> <code class="hljs pgsql">transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): #   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> withdraw(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ok: #     , #    deposit(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount)</code> </pre> <br><p>  <code>withdraw</code>     ,   ,  <code>deposit</code>    :      ?    <code>deposit</code>  -     (,   ,       ),    .  ,    ,    ,   ,        ?    ,   ,      - ,     . </p><br><p>     ,   ,   ,     . ,     ,   ,   .   ,     .   ,       ,       .  Karena     ,       ,        .      ,        :     ,     —  . </p><br><h3 id="dvuhfaznost-bez-blokirovok">    </h3><br><p>      ,       . </p><br><p>      :        ,  ,     ,   ,   .   ,        -  : </p><br><ul><li> <em></em> .            ,   , ,     ,     . </li><li> <em></em> .        . </li></ul><br><p>     , , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . </p><br><p> ,        , ..       ,      ,  .        ,       . </p><br><p>          :     lock-free   ,           .            , ..      ,  . </p><br><p>      CAS       . ,      : </p><br><pre> <code class="hljs swift">#     ,    handle(input, output, state): # ... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> fsm_state: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {<span class="hljs-type"><span class="hljs-type">HANDLING</span></span>, ...}: #      fsm_state = {<span class="hljs-type"><span class="hljs-type">PREPARING</span></span>, ...} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {<span class="hljs-type"><span class="hljs-type">PREPARING</span></span>, input_index}: #   ... output_index = ...get_next_index() fsm_state = {<span class="hljs-type"><span class="hljs-type">WRITING</span></span>, output_index, ...} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {<span class="hljs-type"><span class="hljs-type">WRITING</span></span>, output_index, ...}: #  ,  output_index</code> </pre> <br><p>  ,     .          .      : </p><br><ol><li> <strong>PREPARING</strong> .     ,        . </li><li> <strong>WRITING</strong> .     .       ,       <strong>PREPARING</strong> . </li></ol><br><p>     ,      . ,          ,     —    .     : </p><br><ol><li>         .  ,    , ..     ,      . </li><li>            , ..       .         ,     . </li></ol><br><p>  ,  lock-free        ,        ,     . </p><br><h2 id="trebovaniya-k-konsistentnosti">    </h2><br><p>  ,     .     ,      <em>Stale Read</em> ,       .   —       CAS:              .       : </p><br><ul><li> <em>Distributed single register</em> —       (, etcd  Zookeeper): <br><ol><li> Linearizability </li><li> Sequential consistency </li></ol></li><li> <em>Transactional</em> —     (, MySQL, PostgreSQL  ..): <br><ol><li> Serializability </li><li> Snapshot Isolation </li><li> Repeatable Read </li><li> Read Committed </li></ol></li><li> <em>Distributed Transactional</em> — NewSQL : <br><ol><li> Strict Consistency </li><li>    </li></ol></li></ul><br><p>   :             ?   ,  ,   .         ,    ,     CAS                .        , ,   <em>Read My Writes</em> . </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>        <em>exactly-once</em> .     , ..  ,  ,    ,    .       ,      ,  , , ..        ,     . </p><br><p>       lock-free       . </p><br><p>    : </p><br><ol><li> <strong></strong> :      . </li><li> <strong></strong> :       . </li><li> <strong></strong> :        : <em>exactly-once</em> . </li><li> <strong>Concurrent</strong> :       . </li><li> <strong>Real-time</strong> :     . </li><li> <strong>Lock-free</strong> :      ,     . </li><li> <strong>Deadlock free</strong> :      ,      . </li><li> <strong>Race condition free</strong> :     . </li><li> <strong>Hot-hot</strong> :        . </li><li> <strong>Hard stop</strong> :       . </li><li> <strong>No failover</strong> :                  . </li><li> <strong>No downtime</strong> :    . </li><li> <strong> </strong> :   ,    . </li><li> <strong></strong> :         . </li><li> <strong></strong> :         . </li><li> <strong></strong> :        . </li></ol><br><p>  ,        .  Tapi itu cerita lain. </p><br><p><img src="https://habrastorage.org/webt/ku/4j/nf/ku4jnf9-1pkdjfh_peshj0xd73w.jpeg" alt="Ringan"></p><br><h2 id="novye-terminy">   </h2><br><p>       : </p><br><ol><li> Concurrent exactly-once. </li><li> Semi-transactions  . </li><li> Lock-free two-phase commit,       . </li></ol><br><h2 id="zadachi-dlya-samoistyazaniya">    </h2><br><ol><li>     . </li><li>  lock-free       . </li><li>    . </li></ol><br><h2 id="literatura">  Sastra </h2><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia: Masalah ABA. </font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blog: Anda Tidak Bisa Memiliki Pengiriman Tepat-Sekali</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [3] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habr: Keterjangkauan dari batas bawah pada waktu pelaksanaan komit dari transaksi gagal-aman terdistribusi. </font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[4] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habr: Asynchrony 3: model subjektif. </font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[5] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia: Sinkronisasi non-pemblokiran.</font></font></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id413817/">https://habr.com/ru/post/id413817/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id413807/index.html">Penentuan karakteristik balistik-temporal dari gerakan pusat massa penerjun payung dari pesawat terbang</a></li>
<li><a href="../id413809/index.html">Set-Top-Box dan percobaan dengan Android di wadah LXC</a></li>
<li><a href="../id413811/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 318 (4 - 10 Juni, 2018)</a></li>
<li><a href="../id413813/index.html">PHP Digest No. 132 (27 Mei - 10 Juni 2018)</a></li>
<li><a href="../id413815/index.html">Lokakarya kontribusi Go di Rusia</a></li>
<li><a href="../id413819/index.html">Jujur tentang pasar TI di Rusia</a></li>
<li><a href="../id413823/index.html">Booming pekerjaan yang tidak berarti</a></li>
<li><a href="../id413827/index.html">Proyek Kubernetes berusia 4 tahun</a></li>
<li><a href="../id413831/index.html">Versi baru Tesla Autopilot akan dirilis pada bulan Agustus, untuk pertama kalinya dengan "fitur mengemudi yang sepenuhnya otonom"</a></li>
<li><a href="../id413837/index.html">Menjadikan Tower Defense sebagai Game Persatuan - Bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>