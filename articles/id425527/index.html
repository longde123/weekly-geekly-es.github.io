<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘‚ğŸ½ ğŸ‘† ğŸ‘´ğŸ» Daftar di Kotlin. Pendekatan Haskell ğŸ¤½ğŸ¾ ğŸ›€ğŸ» ğŸ™†ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Haskell adalah bahasa yang berfungsi penuh dan sangat ringkas. Siapa pun yang pernah mencoba menulis kode di Haskell memperhatikan betapa ringkas dan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Daftar di Kotlin. Pendekatan Haskell</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425527/">  Haskell adalah bahasa yang berfungsi penuh dan sangat ringkas.  Siapa pun yang pernah mencoba menulis kode di Haskell memperhatikan betapa ringkas dan anggunnya daripada menulis hal yang sama dalam bahasa imperatif.  Untuk mencapai hal yang sama di Jawa, menurut saya, tidak mungkin, tetapi Kotlin memungkinkan Anda untuk bergerak ke arah ini dan mencoba gaya yang berfungsi penuh.  Kita dapat memperoleh semua fungsi kompleks yang mungkin kita butuhkan dari basis awal dari 3 fungsi paling terkenal: peta, filter, kurangi.  Selain itu, saya membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori</a> yang dapat Anda pelajari dan lihat tesnya. <br><a name="habracut"></a><br>  Sebelum memulai, saya ingin menarik perhatian pada fakta bahwa tidak layak menerapkan pendekatan fungsional dengan cara ini, karena kode akan sangat lambat dan tidak boleh digunakan dalam aplikasi produksi.  Tentu ada opsi untuk memperbaikinya, tetapi tujuan artikel ini bukan untuk mengungkapkan opsi-opsi ini, tetapi untuk mempertimbangkan pendekatan alternatif untuk menulis kode.  Bagaimanapun, pemahaman tentang pendekatan ini akan membantu Anda dengan struktur data rekursif, dan Anda dapat menghargai keindahan dan keanggunan dari bagaimana kode dibaca dan betapa lebih mudah untuk memahami. <br><br><h3>  Fungsi dasar </h3><br>  Daftar memainkan peran yang sangat penting dalam bahasa, dan banyak fungsi yang bermanfaat diterapkan untuk mereka.  Mari kita lihat beberapa dari mereka dan bagaimana mereka dapat diimplementasikan di Kotlin. <br><br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">head</span></span> (x:_) = x head [] = badHead</code> </pre> <br>  Jika ada elemen dalam daftar, kami akan mengembalikan yang pertama, jika tidak kami akan mengembalikan kesalahan. <br>  Kami tidak memiliki kesempatan untuk menulis kode seperti itu, tetapi, secara umum, jika Anda melihat lebih dekat, sangat mirip dengan ketika template.  Kami juga akan menggunakan fungsi ekstensi untuk nantinya dapat menggunakan metode ini pada daftar dan memiliki cara yang sedikit lebih ringkas untuk mendapatkan nilai, tanpa tanda kurung pada akhirnya, seperti pemanggilan metode. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> &lt;T&gt; List&lt;T&gt;.head: T <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isEmpty()) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> NoSuchElementException(<span class="hljs-string"><span class="hljs-string">"List is empty."</span></span>) <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] }</code> </pre><br>  Agar mudah menggunakan rekursi, kami juga ingin membagi daftar menjadi elemen pertama + yang lainnya.  Mari kita coba menerapkan fungsi ekor untuk ini. <br><br>  Begini tampilannya di haskell: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">tail</span></span> (_:xs) = xs tail [] = errorEmptyList <span class="hljs-string"><span class="hljs-string">"tail"</span></span></code> </pre><br>  Sayangnya, Kotlin tidak menyediakan tingkat kecocokan pola yang dapat dijelaskan oleh pengembang dengan gaya yang sama, jadi di sini kita harus menulis sedikit kapan. <br><br><pre> <code class="hljs xml">val <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>.tail: List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> get() = drop(1)</code> </pre><br>  Agak tidak jujur â€‹â€‹untuk menggunakan fungsi dari perpustakaan bahasa, tetapi di sisi lain, kita harus menulis kode untuk metode ini, jadi akan lebih baik menggunakan metode yang sudah bekerja. <br><br>  Sekarang kita dapat membagi daftar menjadi elemen pertama + sisa daftar.  Kita juga memerlukan fungsi menggabungkan daftar dan satu elemen, yang nantinya akan digunakan secara aktif untuk konversi dan operasi lainnya dalam daftar. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: List&lt;T&gt; = ArrayList(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).also { it.add(x) }</code> </pre><br>  Sekarang kita dapat menambahkan daftar ke elemen di akhir, dan implementasi kita dari fungsi peta menjadi bekerja dan siap digunakan.  Sayangnya, sekali lagi tidak ada cara untuk menambahkan objek ke daftar dengan cara yang lebih nyaman, jadi kami menggunakan metode <b>add</b> . <br><br>  Saat ini kami memiliki hampir semua yang kami butuhkan.  Satu-satunya hal yang kita butuhkan sekarang adalah untuk dapat menggambarkan kondisi batas untuk keluar dari rekursi.  Untuk melakukan ini, kita akan menggunakan metode <b>isEmpty ()</b> standar.  Mari kita berhenti dan melihat apa yang kita miliki saat ini: <br><br><ul><li>  isEmpty () - apakah ada elemen dalam daftar </li><li>  head - elemen pertama dari daftar </li><li>  tail - daftar tanpa elemen pertama </li><li>  daftar + elemen - kita dapat menggabungkan daftar dengan objek </li></ul><br>  Faktanya, hanya itu yang kita butuhkan untuk mendapatkan semua metode yang kita butuhkan. <br>  Untuk selera saya, akan lebih mudah untuk menggunakan perbandingan panjang daftar di <b>saat</b> pernyataan.  Kotlin sudah memberi kami <b>ukuran</b> untuk mendapatkan panjang daftar ini.  Namun, misalkan kita ingin mengimplementasikannya sendiri.  Dengan fungsionalitas kami, itu akan sangat sederhana: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> &lt;T&gt; List&lt;T&gt;.size: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isEmpty()) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tail.size }</code> </pre><br><h3>  Penerapan fungsi dasar </h3><br>  Pertimbangkan contoh paling umum.  Misalkan kita memiliki daftar bilangan bulat, dan kami ingin menjumlahkannya, melupakan keberadaan siklus.  Semua yang kita miliki adalah metode yang kita peroleh di atas, dan rekursi.  Untuk melakukan ini, kami akan menggunakan pendekatan yang sama seperti ketika menghitung ukuran daftar: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; xs.head + sum(xs.tail) }</code> </pre><br>  Idenya sangat sederhana: jika tidak ada elemen dalam daftar, maka jumlahnya adalah 0;  jika tidak, itu adalah jumlah dari elemen pertama dan panggilan rekursif dari jumlah untuk ekor. <br><br>  Terlepas dari kenyataan bahwa kami tidak peduli dengan kecepatan dan optimisasi dalam kode ini, kami tidak bisa tidak mengingat kemampuan bahasa untuk menggunakan rekursi ekor.  Rekursi ekor adalah kasus rekursi khusus di mana panggilan rekursif adalah operasi terakhir sebelum kembali dari suatu fungsi.  Rekursi semacam ini patut diperhatikan karena dijamin memungkinkan Anda membangun kembali kode untuk iterasi.  Seperti yang Anda tahu, masalah utama rekursi adalah bahwa selama pelaksanaan fungsi itu perlu untuk menyimpan tumpukan panggilan sehingga ketika kondisi batas tercapai, Anda dapat kembali dan menceritakan hasil akhir. <br><br>  Mungkin tampak bahwa fungsi jumlah yang kami jelaskan persis seperti itu, karena panggilan terakhir adalah <b>jumlah (xs.tail)</b> .  Namun, ini tidak benar.  Jika Anda menjelaskan kode sedikit berbeda, itu akan menjadi jelas: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> head = xs.head <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tailSum = sum(xs.tail) head + tailSum } }</code> </pre><br>  Sekarang kita melihat bahwa sebenarnya panggilan terakhir adalah jumlah dari elemen pertama dan bagian ekor yang tersisa. <br><br>  Berita baiknya adalah jika Anda menambahkan pengubah <b>tailrec</b> ke suatu fungsi, IDE akan memberi tahu Anda bahwa fungsinya tidak.  Namun, memperbaiki ini cukup mudah.  Trik umum yang mengoreksi suatu fungsi adalah dengan menggunakan variabel bantu untuk menyimpan hasilnya.  Ini terlihat seperti ini: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">tailrec</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, acum: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; acum <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; sum(xs.tail, xs.head + acum) }</code> </pre><br>  Untuk menghitung jumlah elemen, cukup untuk lulus 0 sebagai parameter kedua. Dan, untuk membuatnya benar-benar idiomatis, kita akan mengulang fungsinya sedikit lagi, menyembunyikan perhitungan utama dalam fungsi internal tanpa dunia luar memiliki akses ke parameter yang tidak dibutuhkan. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>:<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">tailrec</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumInner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, acum: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; acum <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; sumInner(xs.tail, xs.head + acum) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sumInner(xs, <span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre><br>  Memiliki pengetahuan ini, Anda dapat melihat bahwa fungsi ukuran yang kami terapkan di atas tidak memenuhi kondisi yang diperlukan untuk rekursi ekor. <br><br>  Sekarang kita siap mengimplementasikan peta, filter, kurangi menggunakan Kotlin.  Nanti kita akan melihat bahwa itu cukup untuk menyadari hanya yang terakhir, dan sisanya, secara umum, adalah turunan dari itu.  Tetapi hal pertama yang pertama. <br><br><h3>  Fungsi utama </h3><br><h4>  PETA </h4><br>  Implementasi berulang fungsi ini melibatkan gerakan berurutan melalui daftar, menggunakan fungsi konversi dan menambahkan semua elemen yang diterima ke koleksi baru.  Kami akan menggunakan panggilan rekursif di mana kondisi batas adalah daftar kosong.  Maka implementasinya akan terlihat seperti ini: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; R): List&lt;R&gt; = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; listOf() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; f(head) + tail.map(f) }</code> </pre><br>  Jika tidak ada elemen dalam daftar asli, maka kami mengembalikan daftar kosong, jika tidak, kami menerapkan transformasi ke elemen pertama dan menambahkan panggilan rekursif ke ujung untuk sisa daftar. <br><br>  Namun, kami masih belum memiliki fungsi untuk menggabungkan elemen dan daftar.  Tapi kita sudah bisa menyadarinya.  Untuk memulainya, kita mendapatkan kasus yang lebih umum dari menggabungkan daftar dan setelah itu kita menggunakannya untuk menambahkan daftar lain ke elemen. <br><br><pre> <code class="hljs xml">operator fun <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>.plus(xs: List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>): List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> = when (xs.size) { 0 -&gt; ArrayList(this) else -&gt; (this + xs.head) + xs.tail } operator fun <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> T.plus(xs: List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>): List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> = listOf(this) + xs</code> </pre><br><h4>  Saring </h4><br>  Implementasinya akan sangat mirip dengan peta.  Satu-satunya perbedaan adalah bahwa Anda perlu memahami apakah Anda perlu menambahkan elemen saat ini ke hasilnya.  Untuk melakukan ini, kita akan memanggil lambda yang kita terima sebagai parameter.  Implementasinya akan terlihat seperti ini: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>): List&lt;T&gt; = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; listOf() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f(head)) head + tail.filter(f) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> tail.filter(f) }</code> </pre><br>  Jika elemen saat ini memenuhi kondisi filter, tambahkan secara rekursif ke ekor daftar, jika tidak, kami terus bekerja hanya dengan ekor daftar. <br><br><h4>  KURANGI </h4><br>  Yang paling sulit untuk dipahami dan, pada saat yang sama, fungsi yang paling kuat (dalam dunia fungsional itu disebut <b>lipatan</b> ).  Paling sering, ini digunakan untuk menciutkan daftar menjadi satu item.  Anda memiliki nilai awal tertentu <b>s0</b> , dan juga ada daftar elemen <b>a []</b> dan fungsi <b>f</b> , yang mengembalikan yang baru untuk nilai awal dan elemen berikutnya dari daftar.  <b>f (s0, a [0]) = s1</b> .  Dan dengan demikian, kita secara berurutan menelusuri seluruh daftar elemen, mendapatkan semacam nilai tunggal pada output.  Contoh yang cukup umum adalah penjumlahan elemen array.  Dalam kasus ini, nilai awal adalah 0, dan fungsinya mengembalikan jumlah dari dua elemen: <b>f (s, a [i]) = s + a [i]</b> .  Pertimbangkan bagaimana kita dapat mengimplementasikan fungsi ini secara rekursif. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, R)</span></span></span></span> -&gt; T): T = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; s <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; reduce(f(s, xs.head), xs.tail, f) }</code> </pre><br>  Pada prinsipnya, implementasinya persis sama dengan yang kami ulas di atas.  Jika tidak ada elemen dalam daftar, kami mengembalikan nilai saat ini, jika tidak, kami menghitung elemen pertama yang baru, dan sekali lagi memanggil fungsi pengurangan untuk itu dan bagian belakang daftar. <br><br>  Perhatikan bahwa kami juga dapat membuat modifikasi pada fungsi ini.  Misalnya, jangan melewati nilai awal, tetapi gunakan elemen pertama dari daftar untuk ini.  Untuk memahami bahwa pengurangan tidak berakhir di sana, bayangkan kita menggunakan daftar yang berbeda sebagai nilai awal.  Dalam hal ini, setiap kali pada iterasi kami akan menyimpan tidak hanya satu nilai, tetapi sebuah daftar, berkat kemampuan kami yang sangat meningkat.  Sebagai contoh, mari kita coba menerapkan fungsi pengurangan sedemikian rupa sehingga hasilnya adalah daftar asli: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduceSame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> = reduce(listOf&lt;T&gt;(), xs) { ys, s -&gt; ys + s }</code> </pre><br>  Sekarang, saya pikir, Anda menebak bahwa kita bisa menggunakan pengurangan, untuk implementasi peta alternatif, filter.  Karena kami belajar mengembalikan daftar yang sama persis dengan pengurangan, kami perlu melakukan sedikit perubahan untuk dapat mengonversi setiap elemen.  Untuk filter, semuanya sangat mirip. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; R): List&lt;R&gt; = reduce(mutableListOf(), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { xs, s -&gt; (xs + f(s)).toMutableList() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>): List&lt;T&gt; = reduce(mutableListOf(), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { ys, s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f(s)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span><span class="hljs-symbol"><span class="hljs-symbol">@reduce</span></span> (ys + s).toMutableList() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ys }</code> </pre><br>  Selain itu, mereka sering lupa bahwa kita juga dapat menggunakan pengurangan bukan dari awal daftar, tetapi dari akhir.  Tentu, kita bisa memperluas daftar, dan setelah itu berlaku kurangi, tetapi ini tidak menarik.  Mari kita coba menulis dan memahami bagaimana mengurangi karya untuk menciutkan daftar dalam urutan terbalik. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduceRight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, R)</span></span></span></span> -&gt; T): T = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; s <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; f(reduceRight(s, xs.tail, f), xs.head) }</code> </pre><br>  Jika daftar tidak kosong, maka kita menerapkan fungsi f ke hasil melipat ekor daftar dan kepala daftar.  Dengan demikian, elemen pertama akan diproses terakhir;  kedua dari belakang - ke-2 dan seterusnya.  Untuk opsi ini, Anda juga dapat menambahkan modifikasi yang akan menggunakan elemen terakhir dari daftar sebagai nilai awal, dll. <br><br>  Hampir selalu, ketika bekerja dengan daftar, Anda dapat menggunakan beberapa kombinasi dari 3 fungsi ini untuk mendapatkan hasil yang Anda minati. <br><br>  Mari kita juga mengimplementasikan fungsi <b>zip</b> , yang akan memungkinkan kita untuk menggabungkan 2 daftar. <br>  Di pintu masuk kami mendapatkan 2 daftar.  Dan kami ingin mengembalikan daftar pasangan yang panjangnya sama dengan minimum daftar asli. <br><br>  Seperti biasa, Anda perlu memikirkan untuk keluar dari rekursi dan menulis suatu fungsi. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zip</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, ys: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: List&lt;Pair&lt;T, R&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.isEmpty() || ys.isEmpty()) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; listOf() <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; Pair(xs.head, ys.head) + zip(xs.tail, ys.tail) } }</code> </pre><br>  Anda dapat menambahkan modifikasi Anda sendiri, yang akan memungkinkan Anda, alih-alih mengembalikan sepasang elemen, menerapkan fungsi tertentu ke dua elemen.  Di Haskell, fungsi ini disebut <b>zipWith</b> .  Dan itu diimplementasikan dengan fungsi yang kami berhasil menulis dengan sangat sederhana: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R, C&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zipWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, ys: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, R)</span></span></span></span> -&gt; C): List&lt;C&gt; = zip(xs, ys).map { f(it.first, it.second) }</code> </pre><br>  Sangat sering, ketika menggunakan pendekatan fungsional, masalah muncul ketika Anda perlu melakukan manipulasi berdasarkan bukan pada objek dalam daftar, tetapi berdasarkan indeks.  Sebagai contoh, kita perlu menjumlahkan semua elemen genap dari daftar.  Anda dapat mencoba untuk mencapai ini dengan mengurangi, mempertahankan Pair &lt;Int, Boolean&gt; sebagai nilai saat ini dan menambahkan nilai jika flag == true, dan ambil negasi bendera setiap kali untuk langkah berikutnya.  Namun, ini tidak terlihat terlalu cantik, dan pembaca harus mencari tahu apa yang ingin Anda ungkapkan dengan kode ini.  Kotlin memiliki urutan yang tak terbatas, dan mereka bagus untuk menyelesaikan masalah ini.  Jika kita menganalisis apa yang ingin kita lakukan, ternyata kita ingin menyaring semua elemen dengan indeks ganjil, dan menjumlahkan yang tersisa.  Dan untuk dapat memperoleh indeks, cukup memanggil <b>zip</b> untuk daftar dan <b>urutan</b> [0,1,2 ..] <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumWithEvenIndexes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> = zip(xs, generateSequence(<span class="hljs-number"><span class="hljs-number">0</span></span>) { it + <span class="hljs-number"><span class="hljs-number">1</span></span> }.take(xs.size).toList()) .filter { it.second % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> } .map { it.first } .sum()</code> </pre><br>  Di perpustakaan standar Kotlin, Anda dapat menemukan fungsi zip untuk pasangan urutan. <br><br>  Sekarang mari kita lihat sebuah teka-teki sederhana yang mengilhami saya untuk menulis panduan ini, dan bagaimana implementasinya terlihat dalam bahasa imperatif di Kotlin dan di bagian paling akhir di Haskell. <br><br>  Penting untuk menghitung jumlah maksimum di antara pasangan angka yang berdekatan dalam array bilangan bulat.  Panjang array lebih besar dari 1, dan Anda tidak perlu khawatir meluap saat menambahkan elemen. <br><br>  Pendekatan Java imperatif: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Integer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maxSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Integer&gt; array)</span></span></span><span class="hljs-function"> </span></span>{ Integer max = array.get(<span class="hljs-number"><span class="hljs-number">0</span></span>) + array.get(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; array.size(); i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array.get(i) + array.get(i-<span class="hljs-number"><span class="hljs-number">1</span></span>) &gt; max) max = array.get(i) + array.get(i-<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> max; }</code> </pre><br>  Pendekatan fungsional pada Kotlin menggunakan fungsi tertulis (saya mengusulkan untuk mengimplementasikan sendiri fungsi max sebagai pelatihan sendiri): <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maxSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> = zipWith(xs, xs.tail, {a, b -&gt; a + b}).max()</code> </pre><br>  Implementasi Haskell: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">maxSum</span></span> xs = maximum $ zipWith (+) xs (tail xs)</code> </pre><br>  Seperti yang bisa kita lihat, apa yang kita implementasikan di Kotlin (omong-omong, kita bisa menggunakan mengurangi untuk menyelesaikan masalah ini) sangat mirip dengan apa yang dapat ditulis dalam Haskell. <br><br><h3>  Kesimpulan </h3><br>  Tidak diragukan lagi, ini tidak boleh digunakan dalam pengembangan, karena semuanya dilaksanakan secara tidak optimal hanya untuk menunjukkan pendekatan fungsional.  Juga, hampir semua yang ditulis ada di perpustakaan standar Kotlin, jadi mungkin di masa depan, alih-alih menulis yang lain untuk loop, Anda akan menggunakan gaya fungsional yang disediakan oleh Kotlin. <br><br>  Mungkin yang paling sulit dalam gaya fungsional adalah bahwa masalahnya dapat diselesaikan dengan berbagai cara.  Yang paling jelas mungkin rumit dan sulit untuk dipahami di masa depan, dan menulis yang paling dimengerti mungkin membutuhkan waktu dan pemikiran yang serius.  Satu-satunya hal yang dapat membantu dalam penguasaan adalah latihan dan pelatihan yang konstan. <br><br>  PS: Seperti yang disebutkan di atas, Anda dapat melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori</a> dengan semua contoh yang ada di artikel.  Jalankan tes dan lihat cara kerjanya! <br><br>  PPS: Anda juga dapat melihat pendekatan alternatif yang mengimplementasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi</a> serupa. <br><br>  Dan pastikan untuk melihat nanti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://arrow-kt.io/</a> .  Menurut pendapat saya, Anda tidak harus melihat ke sana segera, karena semuanya terlihat cukup menakutkan, tetapi kemudian, ketika functors dan monad tidak akan membuat Anda takut, pastikan untuk mempelajarinya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425527/">https://habr.com/ru/post/id425527/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425511/index.html">Fitur-fitur aplikasi Rotativa yang tidak jelas untuk menghasilkan PDF dalam aplikasi ASP.NET MVC</a></li>
<li><a href="../id425515/index.html">Apple memblokir perbaikan independen model MacBook baru</a></li>
<li><a href="../id425517/index.html">Bagaimana Yandex membuat perkiraan curah hujan global menggunakan radar dan satelit</a></li>
<li><a href="../id425521/index.html">Metode yang Dilindungi dalam JavaScript ES5</a></li>
<li><a href="../id425525/index.html">Tim Berners-Lee melanjutkan perang: "Satu langkah kecil untuk web ..."</a></li>
<li><a href="../id425529/index.html">Sans Forgetica: font yang memungkinkan Anda sedikit lebih baik menghafal apa yang Anda baca</a></li>
<li><a href="../id425531/index.html">Pendinginan rem cair. Opsi Pengembangan Sistem</a></li>
<li><a href="../id425533/index.html">Cara bekerja di cloud: dari memeriksa keandalan pusat data hingga mengelola infrastruktur virtual</a></li>
<li><a href="../id425537/index.html">Bagaimana menggabungkan Java, Js dan grafik dengan seni, atau kisah tentang bagaimana teater interaktif dibuat</a></li>
<li><a href="../id425541/index.html">Cara cepat dan tanpa chip yang tidak perlu menghindari kekekalan alamat HTU21</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>