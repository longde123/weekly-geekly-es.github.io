<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õπüèΩ üíÖüèª üë©üèª‚ÄçüöÄ Escrevemos em FPGA sem HDL. Compara√ß√£o de ferramentas de desenvolvimento de alto n√≠vel üë®üèø‚Äç‚úàÔ∏è üë©üèæ‚Äçüî¨ üíÖüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recentemente, fabricantes de FPGA e empresas terceirizadas t√™m desenvolvido ativamente m√©todos de desenvolvimento para FPGAs que diferem das abordagen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escrevemos em FPGA sem HDL. Compara√ß√£o de ferramentas de desenvolvimento de alto n√≠vel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455668/">  Recentemente, fabricantes de FPGA e empresas terceirizadas t√™m desenvolvido ativamente m√©todos de desenvolvimento para FPGAs que diferem das abordagens convencionais usando ferramentas de desenvolvimento de alto n√≠vel. <br><br>  Como desenvolvedor de FPGA, utilizo a linguagem de descri√ß√£o de hardware ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HDL</a> ) da Verilog como ferramenta principal, mas a crescente popularidade de novos m√©todos despertou meu grande interesse. Portanto, neste artigo, decidi entender o que estava acontecendo. <br><br>  Este artigo n√£o √© um guia ou instru√ß√£o de uso, esta √© minha revis√£o e conclus√µes sobre o que v√°rias ferramentas de desenvolvimento de alto n√≠vel podem oferecer a um desenvolvedor ou programador de FPGA que deseja mergulhar no mundo do FPGA.  Para comparar as ferramentas de desenvolvimento mais interessantes na minha opini√£o, escrevi v√°rios testes e analisei os resultados.  Sob o corte - o que veio disso. <br><a name="habracut"></a><br><h2>  Por que voc√™ precisa de ferramentas de desenvolvimento de alto n√≠vel para FPGA? </h2><br><ul><li>  Acelerar o desenvolvimento do projeto <br>  - devido √† reutiliza√ß√£o de c√≥digo j√° escrito em linguagens de alto n√≠vel; <br>  - atrav√©s do uso de todas as vantagens de linguagens de alto n√≠vel, ao escrever c√≥digo do zero; <br>  - reduzindo o tempo de compila√ß√£o e a verifica√ß√£o do c√≥digo. <br></li><li>  Capacidade de criar c√≥digo universal que funcione em qualquer fam√≠lia FPGA. </li><li>  Reduza o limite de desenvolvimento para FPGAs, por exemplo, evitando os conceitos de "velocidade do rel√≥gio" e outras entidades de baixo n√≠vel.  Capacidade de escrever c√≥digo para FPGA para um desenvolvedor que n√£o esteja familiarizado com HDL. </li></ul><br><h2>  De onde v√™m as ferramentas de desenvolvimento de alto n√≠vel? </h2><br>  Agora muitos s√£o atra√≠dos pela id√©ia de desenvolvimento de alto n√≠vel.  Tanto entusiastas como, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Quokka</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o gerador de c√≥digo Python</a> , quanto empresas como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mathworks</a> e fabricantes de FPGA <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Intel</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Xilinx</a> est√£o envolvidos nisso. <br><br>  Todo mundo usa seus m√©todos e ferramentas para alcan√ßar seu objetivo.  Os entusiastas na luta por um mundo perfeito e bonito usam suas linguagens de desenvolvimento favoritas, como Python ou C #.  As empresas, tentando agradar o cliente, oferecem suas pr√≥prias ou adaptam as ferramentas existentes.  O Mathworks oferece sua pr√≥pria ferramenta de codificador HDL para gerar c√≥digo HDL a partir de m-scripts e modelos Simulink, enquanto a Intel e o Xilinx oferecem compiladores para o C / C ++ comum. <br><br>  No momento, empresas com recursos financeiros e humanos significativos obtiveram maior sucesso, enquanto os entusiastas est√£o um pouco atrasados.  Este artigo ser√° dedicado √† considera√ß√£o do codificador HDL do produto da Mathworks e HLS Compiler da Intel. <br><br><div class="spoiler">  <b class="spoiler_title">E o Xilinx</b> <div class="spoiler_text">  Neste artigo, n√£o considero o HIL do Xilinx, devido √†s diferentes arquiteturas e sistemas CAD da Intel e do Xilinx, o que torna imposs√≠vel fazer uma compara√ß√£o inequ√≠voca dos resultados.  Mas quero observar que o Xilinx HLS, como o Intel HLS, fornece um compilador C / C ++ e eles s√£o conceitualmente semelhantes. <br></div></div><br>  Vamos come√ßar a comparar o codificador HDL do Mathworks e do Intel HLS Compiler, tendo resolvido v√°rios problemas usando abordagens diferentes. <br><br><h2>  Compara√ß√£o de ferramentas de desenvolvimento de alto n√≠vel </h2><br><h3>  Teste um.  "Dois multiplicadores e um somador" </h3><br>  A solu√ß√£o para esse problema n√£o tem valor pr√°tico, mas √© adequada como primeiro teste.  A fun√ß√£o pega 4 par√¢metros, multiplica o primeiro pelo segundo, o terceiro pelo quarto e adiciona os resultados da multiplica√ß√£o.  Nada complicado, mas vamos ver como nossos assuntos lidam com isso. <br><br><h4>  Codificador HDL da Mathworks </h4><br>  Para resolver esse problema, o script m √© o seguinte: <br><br><pre><code class="matlab hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[out]</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TwoMultAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a,b,c,d)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a*b)</span></span></span><span class="hljs-function">+</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c*d)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre> <br>  Vamos ver o que o Mathworks nos oferece para converter o c√≥digo em HDL. <br><br>  N√£o considerarei o trabalho com o codificador HDL em detalhes, vou me concentrar apenas nas configura√ß√µes que alterarei no futuro para obter resultados diferentes no FPGA, e cujas altera√ß√µes dever√£o ser consideradas pelo programador do MATLAB que precisa executar seu c√≥digo no FPGA. <br><br>  Portanto, a primeira coisa a fazer √© definir o tipo e o intervalo dos valores de entrada.  N√£o h√° char familiar, int, float, duplo no FPGA.  A profundidade de bits do n√∫mero pode ser qualquer uma, √© l√≥gico escolh√™-lo, com base no intervalo de valores de entrada que voc√™ planeja usar. <br><br><img src="https://habrastorage.org/webt/yi/vt/rm/yivtrmsrseix9d6-r5ktf7q4i98.png" alt="imagem"><br>  <i>Figura 1</i> <br><br>  O MATLAB verifica os tipos de vari√°veis, seus valores e seleciona os tamanhos de bits corretos para barramentos e registradores, o que √© realmente conveniente.  Se n√£o houver problemas com a profundidade de bits e a digita√ß√£o, prossiga para os seguintes pontos. <br><br> <a href=""><img src="https://habrastorage.org/webt/hy/bw/zv/hybwzvt-w0xzsta5gkf-0oapcrq.png" alt="imagem"></a> <br>  <i>Figura 2</i> <br><br>  Existem v√°rias guias na gera√ß√£o de c√≥digo HDL, nas quais voc√™ pode escolher o idioma para o qual converter (Verilog ou VHDL);  estilo de c√≥digo  nomes de sinais.  A guia mais interessante, na minha opini√£o, √© a Otimiza√ß√£o, e eu vou experimentar, mas mais tarde, por enquanto, vamos deixar todos os padr√µes e ver o que acontece com o codificador HDL "fora da caixa". <br><br>  Pressione o bot√£o Executar e obtenha o seguinte c√≥digo: <br><br><pre> <code class="plaintext hljs">`timescale 1 ns / 1 ns module TwoMultAdd_fixpt (a, b, c, d, out); input [7:0] a; // ufix8 input [7:0] b; // ufix8 input [7:0] c; // ufix8 input [7:0] d; // ufix8 output [16:0] out; // ufix17 wire [15:0] TwoMultAdd_fixpt_mul_temp; // ufix16 wire [16:0] TwoMultAdd_fixpt_2; // ufix17 wire [15:0] TwoMultAdd_fixpt_mul_temp_1; // ufix16 wire [16:0] TwoMultAdd_fixpt_3; // ufix17 //HDL code generation from MATLAB function: TwoMultAdd_fixpt //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% // % // Generated by MATLAB 9.2 and Fixed-Point Designer 5.4 % // % //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% assign TwoMultAdd_fixpt_mul_temp = a * b; assign TwoMultAdd_fixpt_2 = {1'b0, TwoMultAdd_fixpt_mul_temp}; assign TwoMultAdd_fixpt_mul_temp_1 = c * d; assign TwoMultAdd_fixpt_3 = {1'b0, TwoMultAdd_fixpt_mul_temp_1}; assign out = TwoMultAdd_fixpt_2 + TwoMultAdd_fixpt_3; endmodule // TwoMultAdd_fixpt</code> </pre><br>  O c√≥digo parece bom.  O MATLAB entende que escrever a express√£o inteira em uma √∫nica linha no Verilog √© uma pr√°tica ruim.  Cria <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fios</a> separados para o multiplicador e o somador, n√£o h√° do que reclamar. <br><br>  √â alarmante que a descri√ß√£o dos registros esteja ausente.  Isso aconteceu porque n√£o perguntamos sobre o HDL-coder e deixamos todos os campos nas configura√ß√µes com seus valores padr√£o. <br><br>  Aqui est√° o que Quartus sintetiza a partir desse c√≥digo. <br><br><img src="https://habrastorage.org/webt/zf/af/ja/zfafjaezynolikraaha86gadp-e.png"><br>  <i>Figura 3</i> <br><br>  Sem problemas, tudo foi como planejado. <br><br>  No FPGA, implementamos circuitos s√≠ncronos, e ainda gostaria de ver os registros.  O codificador HDL oferece um mecanismo para a coloca√ß√£o de registros, mas a localiza√ß√£o dos mesmos depende do desenvolvedor.  Podemos colocar os registradores na entrada dos multiplicadores, na sa√≠da dos multiplicadores na frente do somador ou na sa√≠da do somador. <br><br>  Para sintetizar os exemplos, escolhi a fam√≠lia FPGA Cyclone V, onde blocos DSP especiais com somadores e multiplicadores embutidos s√£o usados ‚Äã‚Äãpara implementar opera√ß√µes aritm√©ticas.  O bloco DSP fica assim: <br><br> <a href=""><img src="https://habrastorage.org/webt/zf/5s/bt/zf5sbts5ke1t_pw3dsmrc4uhtrc.png"></a> <br>  <i>Figura 4</i> <br><br>  O bloco DSP possui registros de entrada e sa√≠da.  N√£o h√° necessidade de tentar tirar os resultados da multiplica√ß√£o no registro antes da adi√ß√£o, isso violar√° apenas a arquitetura (em certos casos, essa op√ß√£o √© poss√≠vel e at√© necess√°ria).  Cabe ao desenvolvedor decidir como lidar com o registro de entrada e sa√≠da com base nos requisitos de lat√™ncia e na frequ√™ncia m√°xima necess√°ria.  Eu decidi usar apenas o registro de sa√≠da.  Para que esse registro seja descrito no c√≥digo gerado pelo codificador HDL, na guia Op√ß√µes do codificador HDL, marque a caixa de sele√ß√£o Registrar sa√≠da e reinicie a convers√£o. <br><br>  Acontece o seguinte c√≥digo: <br><br><pre> <code class="plaintext hljs">`timescale 1 ns / 1 ns module TwoMultAdd_fixpt (clk, reset, clke_ena_i, a, b, c, d, clke_ena_o, out); input clk; input reset; input clke_ena_i; input [7:0] a; // ufix8 input [7:0] b; // ufix8 input [7:0] c; // ufix8 input [7:0] d; // ufix8 output clke_ena_o; output [16:0] out; // ufix17 wire enb; wire [16:0] out_1; // ufix17 wire [15:0] TwoMultAdd_fixpt_mul_temp; // ufix16 wire [16:0] TwoMultAdd_fixpt_2; // ufix17 wire [15:0] TwoMultAdd_fixpt_mul_temp_1; // ufix16 wire [16:0] TwoMultAdd_fixpt_3; // ufix17 reg [16:0] out_2; // ufix17 //HDL code generation from MATLAB function: TwoMultAdd_fixpt //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% // % // Generated by MATLAB 9.2 and Fixed-Point Designer 5.4 % // % //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% assign TwoMultAdd_fixpt_mul_temp = a * b; assign TwoMultAdd_fixpt_2 = {1'b0, TwoMultAdd_fixpt_mul_temp}; assign TwoMultAdd_fixpt_mul_temp_1 = c * d; assign TwoMultAdd_fixpt_3 = {1'b0, TwoMultAdd_fixpt_mul_temp_1}; assign out_1 = TwoMultAdd_fixpt_2 + TwoMultAdd_fixpt_3; assign enb = clke_ena_i; always @(posedge clk or posedge reset) begin : out_reg_process if (reset == 1'b1) begin out_2 &lt;= 17'b00000000000000000; end else begin if (enb) begin out_2 &lt;= out_1; end end end assign clke_ena_o = clke_ena_i; assign out = out_2; endmodule // TwoMultAdd_fixpt</code> </pre><br>  Como voc√™ pode ver, o c√≥digo tem diferen√ßas fundamentais em compara√ß√£o com a vers√£o anterior.  Um bloco sempre apareceu, que √© uma descri√ß√£o do registro (exatamente o que quer√≠amos).  Para a opera√ß√£o sempre em bloco, tamb√©m apareceram as entradas do m√≥dulo clk (frequ√™ncia do rel√≥gio) e reset (reset).  Pode-se ver que a sa√≠da do somador est√° travada no gatilho descrito em sempre.  H√° tamb√©m alguns sinais de permiss√£o ena, mas eles n√£o s√£o muito interessantes para n√≥s. <br><br>  Vejamos o diagrama que o Quartus agora sintetiza. <br><br><img src="https://habrastorage.org/webt/ro/we/px/rowepxxw-fun6ey4x2tpw4cfjyg.png"><br>  <i>Figura 5</i> <br><br>  E, novamente, os resultados s√£o bons e esperados. <br><br>  A tabela abaixo mostra a tabela de recursos usados ‚Äã‚Äã- n√≥s mantemos isso em mente. <br><br><img src="https://habrastorage.org/webt/_z/wy/lk/_zwylksweoc_mhrps-rqhwankbe.png"><br>  <i>Figura 6</i> <br><br>  Para esta primeira miss√£o, o Mathworks recebe um cr√©dito.  Tudo n√£o √© complicado, previs√≠vel e com o resultado desejado. <br><br>  Descrevi em detalhes um exemplo simples, forneci um diagrama de um bloco DSP e descrevi as possibilidades de usar as configura√ß√µes de uso de registro no codificador HDL, que s√£o diferentes das configura√ß√µes "padr√£o".  Isso √© feito por uma raz√£o.  Com isso, gostaria de enfatizar que, mesmo em um exemplo t√£o simples, ao usar o codificador HDL, √© necess√°rio o conhecimento da arquitetura FPGA e dos fundamentos dos circuitos digitais, e as configura√ß√µes devem ser alteradas conscientemente. <br><br><h4>  Compilador Intel HLS </h4><br>  Vamos tentar compilar c√≥digo com a mesma funcionalidade escrita em C ++ e ver o que √© finalmente sintetizado no FPGA usando o compilador HLS. <br><br>  C√≥digo C ++ <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">component </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TwoMultAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> d)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a*b)+(c*d); }</code> </pre><br>  Eu escolhi tipos de dados para evitar o transbordamento de vari√°veis. <br><br>  Existem m√©todos avan√ßados para definir a profundidade de bits, mas nosso objetivo √© testar a capacidade de montar fun√ß√µes escritas no estilo C / C ++ no FPGA sem fazer nenhuma altera√ß√£o, tudo pronto para uso. <br><br>  Como o compilador HLS √© uma ferramenta nativa da Intel, coletamos o c√≥digo com um compilador especial e verificamos o resultado imediatamente no Quartus. <br><br>  Vejamos o circuito que Quartus sintetiza. <br><br><img src="https://habrastorage.org/webt/ra/wy/bg/rawybgvk1yirtlaxi5yfmqjk6mi.png"><br>  <i>Figura 7</i> <br><br>  O compilador criado registra na entrada e na sa√≠da, mas a ess√™ncia est√° oculta no m√≥dulo wrapper.  Come√ßamos a implantar o wrapper e ... ver mais, mais e mais m√≥dulos aninhados. <br><br>  A estrutura do projeto √© assim. <br><br> <a href=""><img src="https://habrastorage.org/webt/x6/3x/pi/x63xpin-73wlqtuear-rhyhcpcy.png"></a> <br>  <i>Figura 8</i> <br><br>  Uma dica √≥bvia da Intel √© "n√£o coloque as m√£os nela!".  Mas vamos tentar, especialmente a funcionalidade n√£o √© complicada. <br><br>  Nas entranhas da √°rvore do projeto | quartus_compile | TwoMultAdd: TwoMultAdd_inst | TwoMultAdd_internal: twomultadd_internal_inst | TwoMultAdd_fu <br>  nction_wrapper: TwoMultAdd_internal | TwoMultAdd_function: theTwoMultAdd_function | bb_TwoMultAdd_B1_start: <br>  thebb_TwoMultAdd_B1_start | bb_TwoMultAdd_B1_start_stall_region: thebb_TwoMultAdd_B1_start_stall_region | i <br>  _sfc_c1_wt_entry_twomultadd_c1_enter_twomultadd: thei_sfc_c1_wt_entry_twomultadd_c1_enter_twomultad <br>  d_aunroll_x | i_sfc_logic_c1_wt_entry_twomultadd_c1_enter_twomultadd13: thei_sfc_logic_c1_wt_entry_twom <br>  ultadd_c1_enter_twomultadd13_aunroll_x | Mult1 √© o m√≥dulo que voc√™ est√° procurando. <br><br>  Podemos observar o diagrama do m√≥dulo desejado sintetizado pelo Quartus. <br><br> <a href=""><img src="https://habrastorage.org/webt/4m/e8/_c/4me8_cxojdb6zyvo0mkvc-i7a60.png"></a> <br>  <i>Figura 9</i> <br><br>  Que conclus√µes podem ser tiradas desse esquema. <br><br>  √â evidente que algo aconteceu que tentamos evitar ao trabalhar no MATLAB: o caso na sa√≠da do multiplicador foi sintetizado - isso n√£o √© muito bom.  Pode ser visto no diagrama de blocos DSP (Figura 4) que existe apenas um registro em sua sa√≠da, o que significa que cada multiplica√ß√£o dever√° ser feita em um bloco separado. <br><br>  A tabela de recursos usados ‚Äã‚Äãmostra o que isso leva. <br><br><img src="https://habrastorage.org/webt/es/eu/tj/eseutjlsyur_gibiank94suhhca.png"><br>  <i>Figura 10</i> <br><br>  Compare os resultados com a tabela do codificador HDL (Figura 6). <br><br>  Se voc√™ usar um n√∫mero maior de registros, pode gastar muito preciosos blocos DSP em uma funcionalidade t√£o simples. <br><br>  Mas h√° uma enorme vantagem no Intel HLS em compara√ß√£o com o codificador HDL.  Com as configura√ß√µes padr√£o, o compilador HLS desenvolveu um design s√≠ncrono no FPGA, embora gastasse mais recursos.  Essa arquitetura √© poss√≠vel, √© claro que o Intel HLS est√° configurado para atingir o desempenho m√°ximo e n√£o para economizar recursos. <br><br>  Vamos ver como nossos assuntos se comportam em projetos mais complexos. <br><br><h3>  O segundo teste.  ‚ÄúMultiplica√ß√£o de matrizes por elementos com soma dos resultados‚Äù </h3><br>  Esta fun√ß√£o √© amplamente utilizada no processamento de imagens: o chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"filtro de matriz"</a> .  N√≥s o vendemos usando ferramentas de alto n√≠vel. <br><br><h4>  Codificador HDL da Mathwork </h4><br>  O trabalho come√ßa imediatamente com uma limita√ß√£o.  O codificador HDL n√£o pode aceitar fun√ß√µes da matriz 2-D como entradas.  Dado que o MATLAB √© uma ferramenta para trabalhar com matrizes, esse √© um duro golpe para todo o c√≥digo herdado, que pode se tornar um problema s√©rio.  Se o c√≥digo foi escrito do zero, esse √© um recurso desagrad√°vel que deve ser considerado.  Portanto, voc√™ deve implantar todas as matrizes em um vetor e implementar as fun√ß√µes levando em considera√ß√£o os vetores de entrada. <br><br>  O c√≥digo para a fun√ß√£o no MATLAB √© o seguinte <br><br><pre> <code class="matlab hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[out]</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mhls_conv2_manually</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target,kernel)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(kernel)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mult</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">target</span></span></span><span class="hljs-function">.*</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kernel</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mult)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  O c√≥digo HDL gerado acabou por estar muito inchado e cont√©m centenas de linhas, portanto n√£o o darei aqui.  Vamos ver qual esquema o Quartus sintetiza a partir desse c√≥digo. <br><br> <a href=""><img src="https://habrastorage.org/webt/6d/3z/cd/6d3zcdcx0yzcqp-ht6fhz_mtx2i.png"></a> <br>  <i>Figura 11</i> <br><br>  Esse esquema parece malsucedido.  Formalmente, est√° funcionando, mas presumo que funcione com uma frequ√™ncia muito baixa e dificilmente pode ser usado em hardware real.  Mas qualquer suposi√ß√£o deve ser verificada.  Para fazer isso, colocaremos os registros na entrada e sa√≠da deste circuito e, com a ajuda do Timing Analyzer, avaliaremos a situa√ß√£o real.  Para conduzir a an√°lise, voc√™ deve especificar a frequ√™ncia operacional desejada do circuito para que o Quartus saiba o que buscar ao fazer a fia√ß√£o e, em caso de falha, fornecer relat√≥rios de viola√ß√µes. <br><br>  Definimos a frequ√™ncia para 100 MHz, vamos ver o que o Quartus pode extrair do circuito proposto. <br><br><img src="https://habrastorage.org/webt/r7/zv/xy/r7zvxygef12ws12mmyfwgxc0plk.png"><br>  <i>Figura 12</i> <br><br>  Pode-se ver que ficou um pouco: 33 MHz parecem fr√≠volos.  O atraso na cadeia de multiplicadores e somadores √© de cerca de 30 ns.  Para se livrar desse ‚Äúgargalo‚Äù, √© necess√°rio usar o transportador: insira registradores ap√≥s opera√ß√µes aritm√©ticas, reduzindo assim o caminho cr√≠tico. <br><br>  O codificador HDL nos d√° essa oportunidade.  Na guia Op√ß√µes, voc√™ pode definir vari√°veis ‚Äã‚Äãde Pipeline.  Como o c√≥digo em quest√£o √© escrito no estilo MATLAB, n√£o h√° como pipeline vari√°veis ‚Äã‚Äã(exceto vari√°veis ‚Äã‚Äãmult e summ), o que n√£o nos conv√©m.  √â necess√°rio inserir os registradores nos circuitos intermedi√°rios ocultos em nosso c√≥digo HDL. <br><br>  Al√©m disso, a situa√ß√£o com otimiza√ß√£o poderia ser pior.  Por exemplo, nada nos impede de escrever c√≥digo <br><br><pre> <code class="matlab hljs">out = (sum(target.*kernel))/len;</code> </pre> <br>  √© bastante adequado para o MATLAB, mas nos priva completamente da possibilidade de otimizar o HDL. <br><br>  A pr√≥xima sa√≠da √© editar o c√≥digo manualmente.  Este √© um ponto muito importante, pois nos recusamos a herdar e come√ßar a reescrever o script m, e N√ÉO no estilo MATLAB. <br><br>  O novo c√≥digo √© o seguinte <br><br><pre> <code class="matlab hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[out]</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mhls_conv2_manually</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target,kernel)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(kernel)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mult</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">target</span></span></span><span class="hljs-function">.*</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kernel</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_1</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zeros</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([1,(len/2)</span></span></span><span class="hljs-function">]); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_2</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zeros</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([1,(len/4)</span></span></span><span class="hljs-function">]); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_3</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zeros</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([1,(len/8)</span></span></span><span class="hljs-function">]); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function">=0:1:</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(len/2)</span></span></span><span class="hljs-function">-1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i+1)</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mult(i*2+1)</span></span></span><span class="hljs-function">+</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i*2+2)</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function">=0:1:</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(len/4)</span></span></span><span class="hljs-function">-1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i+1)</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(summ_1(i*2+1)</span></span></span><span class="hljs-function">+</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i*2+2)</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function">=0:1:</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(len/8)</span></span></span><span class="hljs-function">-1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i+1)</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(summ_2(i*2+1)</span></span></span><span class="hljs-function">+</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i*2+2)</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ_3</span></span></span><span class="hljs-function">/</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  No Quartus, coletamos o c√≥digo gerado pelo codificador HDL.  Pode-se observar que o n√∫mero de camadas com primitivas diminuiu e o esquema parece muito melhor. <br><br> <a href=""><img src="https://habrastorage.org/webt/nd/7j/sr/nd7jsrm1hiursvzgredphpuvr7k.png"></a> <br>  <i>Figura 12</i> <br><br>  Com o layout correto das primitivas, a frequ√™ncia cresce quase 3 vezes, at√© 88 MHz. <br><br><img src="https://habrastorage.org/webt/3z/4s/o3/3z4so3o-whcbn8jct8y-wtfsja4.png"><br>  <i>Figura 13</i> <br><br>  Agora, o toque final: nas configura√ß√µes de otimiza√ß√£o, especifique summ_1, summ_2 e summ_3 como elementos do pipeline.  Coletamos o c√≥digo resultante no Quartus.  O esquema muda da seguinte maneira: <br><br> <a href=""><img src="https://habrastorage.org/webt/cu/kr/ua/cukruasropyfoifoib6er-fhck4.png"></a> <br>  <i>Figura 14</i> <br><br>  A frequ√™ncia m√°xima aumenta novamente e agora seu valor √© de cerca de 195 MHz. <br><br><img src="https://habrastorage.org/webt/tl/gg/dd/tlggddvndao-cm0bavadgbuxx30.png"><br>  <i>Figura 15</i> <br><br>  Quantos recursos no chip ser√£o necess√°rios para esse projeto?  A Figura 16 mostra a tabela de recursos usados ‚Äã‚Äãpara o caso descrito. <br><br><img src="https://habrastorage.org/webt/vl/ju/io/vljuioe1zmgnc-zr-nxvyv0lawu.png"><br>  <i>Figura 16</i> <br><br>  Que conclus√µes podem ser tiradas depois de considerar este exemplo? <br><br>  A principal desvantagem do codificador HDL √© que √© improv√°vel que voc√™ use o c√≥digo MATLAB em sua forma pura. <br>  N√£o h√° suporte para matrizes como entradas de fun√ß√£o, o layout do c√≥digo no estilo MATLAB √© med√≠ocre. <br><br>  O principal perigo √© a falta de registros no c√≥digo gerado sem configura√ß√µes adicionais.  Sem esses registros, mesmo tendo recebido c√≥digo HDL formalmente funcionando sem erros de sintaxe, o uso desse c√≥digo em realidades e desenvolvimentos modernos √© indesej√°vel. <br><br>  √â aconselh√°vel escrever imediatamente um c√≥digo afiado para convers√£o em HDL.  Nesse caso, voc√™ pode obter resultados bastante aceit√°veis ‚Äã‚Äãem termos de velocidade e intensidade de recursos. <br><br>  Se voc√™ √© um desenvolvedor do MATLAB, n√£o se apresse em clicar no bot√£o Executar e compilar seu c√≥digo em FPGA, lembre-se de que seu c√≥digo ser√° sintetizado em um circuito real.  =) <br><br><h4>  Compilador Intel HLS </h4><br>  Para a mesma funcionalidade, escrevi o seguinte c√≥digo C / C ++ <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">component </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">conv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *kernel)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mult_res[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> summl; summl = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; i++) { mult_res[i] = data[i] * kernel[i]; summl = summl+mult_res[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> summl/<span class="hljs-number"><span class="hljs-number">16</span></span>; }</code> </pre><br>  A primeira coisa que chama sua aten√ß√£o √© a quantidade de recursos utilizados. <br><br><img src="https://habrastorage.org/webt/yg/t1/zq/ygt1zq3p67hkkly29pneur9x6bu.png"><br>  <i>Figura 17</i> <br><br>  Pode ser visto na tabela que apenas 1 bloco DSP foi usado; portanto, algo deu errado e as multiplica√ß√µes n√£o s√£o realizadas em paralelo.  O n√∫mero de registradores usados ‚Äã‚Äãtamb√©m √© surpreendente, e at√© a mem√≥ria est√° envolvida, mas deixaremos isso para a consci√™ncia do compilador HLS. <br><br>  Vale a pena notar que o compilador HLS desenvolveu um sub√≥timo, usando uma enorme quantidade de recursos extras, mas ainda um circuito de trabalho que, de acordo com os relat√≥rios da Quartus, funcionar√° em uma frequ√™ncia aceit√°vel e uma falha que o codificador HDL n√£o far√°. <br><br><img src="https://habrastorage.org/webt/y-/wg/fa/y-wgfaigf6zgbaljoez__xzxuqm.png"><br>  <i>Figura 18</i> <br><br>  Vamos tentar melhorar a situa√ß√£o.  O que √© necess√°rio para isso?  √â isso mesmo, feche os olhos para a heran√ßa e entre no c√≥digo, mas at√© agora n√£o √© muito. <br><br>  O HLS possui diretrizes especiais para otimizar o c√≥digo do FPGA.  N√≥s inserimos a diretiva unroll, que deve expandir nosso loop em paralelo: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> unroll for (int i = 0; i &lt; 16; i++) { mult_res[i] = data[i] * kernel[i]; }</span></span></code> </pre><br><br>  Vamos ver como o Quartus reagiu a ele <br><br><img src="https://habrastorage.org/webt/fi/7j/nk/fi7jnkhaoeals29m0pfk38shv70.png"><br>  <i>Figura 19</i> <br><br>  Antes de tudo, preste aten√ß√£o ao n√∫mero de blocos DSP - existem 16 deles, o que significa que as multiplica√ß√µes s√£o realizadas em paralelo. <br><br>  Viva!  desenrolar funciona!  Mas j√° √© dif√≠cil suportar o quanto a utiliza√ß√£o de outros recursos aumentou.  O circuito tornou-se completamente ileg√≠vel. <br><br> <a href=""><img src="https://habrastorage.org/webt/vj/gs/tu/vjgstugdk5a661jnk281gys8-qo.png"></a> <br>  <i>Figura 20</i> <br><br>  Acredito que isso se deve ao fato de ningu√©m apontar para o compilador que os c√°lculos em n√∫meros de ponto fixo s√£o bastante adequados para n√≥s, e ele honestamente implementou toda a matem√°tica de ponto flutuante na l√≥gica e nos registros.  Precisamos explicar ao compilador o que √© necess√°rio e, para isso, mergulhamos novamente no c√≥digo. <br><br>  Com o objetivo de usar ponto fixo, as classes de modelo s√£o implementadas. <br><br><img src="https://habrastorage.org/webt/0a/a8/dj/0aa8djn0cwvyf8tplhtay6lymdg.png"><br>  <i>Figura 21</i> <br><br>  Falando com nossas pr√≥prias palavras, podemos usar vari√°veis ‚Äã‚Äãcuja profundidade de bits √© configurada manualmente at√© um pouco.  Para aqueles que escrevem em HDL, voc√™ n√£o pode se acostumar, mas os programadores de C / C ++ provavelmente ir√£o se agarrar.  Profundidades de bits, como no MATLAB, neste caso, ningu√©m dir√°, e o pr√≥prio desenvolvedor deve contar o n√∫mero de bits. <br><br>  Vamos ver como fica na pr√°tica. <br><br>  Editamos o c√≥digo da seguinte maneira: <br><br><pre> <code class="cpp hljs">component ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt; conv(ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt; *data, ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt; *kernel) { ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt;mult_res[<span class="hljs-number"><span class="hljs-number">16</span></span>]; ac_fixed&lt;<span class="hljs-number"><span class="hljs-number">32</span></span>,<span class="hljs-number"><span class="hljs-number">32</span></span>,<span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt;summl; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> unroll for (int i = 0; i &lt; 16; i++) { mult_res[i] = data[i] * kernel[i]; } for (int i = 0; i &lt; 16; i++) { summl = summl+mult_res[i]; } return summl/16; }</span></span></code> </pre><br>  E, em vez da massa assustadora da Figura 20, temos essa beleza: <br><br> <a href=""><img src="https://habrastorage.org/webt/kg/v0/ot/kgv0ot9el2l5a3u4wawqsbw4hli.png"></a> <br>  <i>Figura 22</i> <br><br>  Infelizmente, algo estranho continua a acontecer com os recursos utilizados. <br><br><img src="https://habrastorage.org/webt/my/dk/bk/mydkbkemq-dzzzhk53gky-zix00.png"><br>  <i>Figura 23</i> <br><br>  Mas uma an√°lise detalhada dos relat√≥rios mostra que o m√≥dulo que nos interessa diretamente parece mais do que adequado: <br><br> <a href=""><img src="https://habrastorage.org/webt/tn/t0/da/tnt0daffouamtkyozxnrnu_zoku.png"></a> <br>  <i>Figura 24</i> <br><br>  O enorme consumo de registros e mem√≥ria de bloco est√° associado a um grande n√∫mero de m√≥dulos perif√©ricos.  Ainda n√£o compreendo completamente o profundo significado de sua exist√™ncia, e isso precisar√° ser resolvido, mas o problema est√° resolvido.  Em um caso extremo, voc√™ pode cortar cuidadosamente um m√≥dulo de interesse da estrutura geral do projeto, o que nos salvar√° dos m√≥dulos perif√©ricos que consomem recursos. <br><br><h3>  O terceiro teste.  "Transi√ß√£o de RGB para HSV" </h3><br>  Come√ßando a escrever este artigo, n√£o esperava que fosse t√£o volumoso.  Mas n√£o posso recusar o terceiro e o √∫ltimo na estrutura deste artigo, um exemplo. <br><br>  Primeiro, este √© um exemplo real da minha pr√°tica e foi por isso que comecei a procurar ferramentas de desenvolvimento de alto n√≠vel. <br><br>  Em segundo lugar, a partir dos dois primeiros exemplos, poder√≠amos assumir que, quanto mais complexo o design, piores as ferramentas de alto n√≠vel lidam com a tarefa. <br><br>  Quero demonstrar que esse julgamento √© err√¥neo e, de fato, quanto mais complexa a tarefa, mais as vantagens das ferramentas de desenvolvimento de alto n√≠vel s√£o manifestadas. <br><br>  No ano passado, ao trabalhar em um dos projetos, n√£o gostei da c√¢mera comprada no Aliexpress, ou seja, as cores n√£o estavam suficientemente saturadas.  Uma das maneiras populares de variar a satura√ß√£o da cor √© alternar do espa√ßo de cores RGB para o espa√ßo HSV, onde um dos par√¢metros √© a satura√ß√£o.  Lembro-me de como abri a f√≥rmula de transi√ß√£o e respirei fundo ... Implementar esses c√°lculos no FPGA n√£o √© algo extraordin√°rio, mas √© claro que levar√° tempo para escrever o c√≥digo.  Portanto, a f√≥rmula para alternar de RGB para HSV √© a seguinte: <br><br><img src="https://habrastorage.org/webt/z_/6u/_t/z_6u_tufgvs_wkbknmisu_gtn1e.png"><br>  <i>Figura 25</i> <br><br>  A implementa√ß√£o de um algoritmo desse tipo no FPGA n√£o levar√° dias, mas horas, e tudo isso deve ser feito com muito cuidado devido √†s especificidades do HDL, e a implementa√ß√£o em C ++ ou no MATLAB levar√°, eu acho, minutos. <br><br>  No C ++, voc√™ pode escrever c√≥digo diretamente na testa e ainda obter um resultado funcional. <br>  Eu escrevi a seguinte op√ß√£o em C ++ <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">color_space</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> rh; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> gs; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> bv; }; <span class="hljs-function"><span class="hljs-function">component color_space </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rgb2hsv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(color_space rgb_0)</span></span></span><span class="hljs-function"> </span></span>{ color_space hsv; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> h,s,v,r,g,b; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> max_col, min_col; r = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(rgb_0.rh)/<span class="hljs-number"><span class="hljs-number">255</span></span>; g = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(rgb_0.gs)/<span class="hljs-number"><span class="hljs-number">255</span></span>; b = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;(rgb_0.bv)/<span class="hljs-number"><span class="hljs-number">255</span></span>; max_col = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(r,g),b); min_col = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(r,g),b); <span class="hljs-comment"><span class="hljs-comment">// H if (max_col == min_col) h = 0; else if (max_col==r &amp;&amp; g&gt;=b) h = 60*((gb)/(max_col-min_col)); else if (max_col==r &amp;&amp; g&lt;b) h = 60*((gb)/(max_col-min_col))+360; else if (max_col==g) h = 60*((br)/(max_col-min_col))+120; else if (max_col==b) h = 60*((rg)/(max_col-min_col))+240; // S if (max_col == 0) s = 0; else { s = (1-(min_col/max_col))*100; } // V v = max_col*100; hsv.rh = static_cast&lt;char&gt;(h); hsv.gs = static_cast&lt;char&gt;(s); hsv.bv = static_cast&lt;char&gt;(v); return hsv; }</span></span></code> </pre><br>  E a Quartus implementou o resultado com sucesso, como pode ser visto na tabela de recursos usados. <br><br><img src="https://habrastorage.org/webt/us/bs/qx/usbsqx6dg4ncv_kkefii6ul8msq.png"><br>  <i>Figura 26</i> <br><br>  A frequ√™ncia √© muito boa. <br><br><img src="https://habrastorage.org/webt/t-/tk/hd/t-tkhdxq-d1yr7uo28m5_k7sfaa.png"><br>  <i>Figura 27</i> <br><br>  Com o codificador HDL, as coisas s√£o um pouco mais complicadas. <br><br>  Para n√£o inflar o artigo, n√£o fornecerei um script m para esta tarefa, n√£o deve causar dificuldades.  Um script m escrito na testa dificilmente pode ser usado com √™xito, mas se voc√™ editar o c√≥digo e especificar corretamente os locais para o pipelining, obteremos um resultado √∫til.  Isso, √© claro, levar√° v√°rias dezenas de minutos, mas n√£o horas. <br><br>  C++          ,       . <br><br>  ,    ,   ,    ,     ‚Äî   ,         FPGA      ,     HDL. <br><br><h2>  Conclus√£o </h2><br>     . <br><br> ,     ,    ,      . <br><br>    ,   ,   .     ,    ,      HDL,  . <br><br>   ,    FPGA        FPGA       .           . <br><br>    ,    ‚Äî          FPGA. <br><br>  HLS compiler     : ,     ,  ,      ‚Äúbest practices‚Äù  ..  MATLAB,    ,     GUI , , ,      ,    ,     . <br><br>     ?   ‚Äî  Intel HLS compiler.         . HDL coder          .   ,  HDL coder   ,    ,       .   HLS,   ,  ,   FPGA     ,         . <br><br>   Xilinx ,       ‚Äî              FPGA.        ,  , Verilog/VHDL   ,    .          (    ),       . <br><br>          ?  ,      ,      ,      HDL   . <br><br>      ,              ,        ,      ,    . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt455668/">https://habr.com/ru/post/pt455668/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt455650/index.html">Como treinamos uma rede neural para classificar parafusos</a></li>
<li><a href="../pt455652/index.html">Deep Learning vs senso comum: desenvolvendo um bot de bate-papo</a></li>
<li><a href="../pt455658/index.html">Lend√°rio Intel Core i7-2600K: testando Sandy Bridge em 2019 (parte 3)</a></li>
<li><a href="../pt455662/index.html">Grande display mec√¢nico com mecanismo de came como decodificador</a></li>
<li><a href="../pt455666/index.html">Construindo vendas de sa√≠da em uma empresa de servi√ßos de TI</a></li>
<li><a href="../pt455670/index.html">Como as impressoras 3D imprimem ossos, vasos sangu√≠neos e √≥rg√£os</a></li>
<li><a href="../pt455676/index.html">A bolha do aprendizado de m√°quina estourou ou o in√≠cio de um novo amanhecer</a></li>
<li><a href="../pt455678/index.html">No caminho de Sergey Pavlovich Korolev. Projeto tripulado russo moderno. Parte 1. "Federa√ß√£o"</a></li>
<li><a href="../pt455682/index.html">Quanto voc√™ gasta em infraestrutura? E como economizar nisso?</a></li>
<li><a href="../pt455684/index.html">Por que realizamos um hackathon para testadores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>