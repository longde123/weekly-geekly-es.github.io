<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéöÔ∏è üí™üèº üéüÔ∏è El tiempo est√° fragmentado; un poco sobre la similitud de los sistemas distribuidos y un modelo de memoria d√©bil üìØ üôÉ üë©üèø‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! 

 Hoy nos gustar√≠a volver a tocar el tema de la ejecuci√≥n simult√°nea y secuencial en varios programas, especialmente en sistemas distri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>El tiempo est√° fragmentado; un poco sobre la similitud de los sistemas distribuidos y un modelo de memoria d√©bil</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/430926/">  Hola a todos! <br><br>  Hoy nos gustar√≠a volver a tocar el tema de la ejecuci√≥n simult√°nea y secuencial en varios programas, especialmente en sistemas distribuidos.  En septiembre, publicamos el art√≠culo "La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sincronicidad es un mito</a> " sobre este tema, y ‚Äã‚Äãahora estamos publicando una traducci√≥n de un estudio m√°s serio, que, esperamos, lo ayudar√° a navegar mejor con sistemas distribuidos. <br><a name="habracut"></a><br><blockquote>  Solo hay un problema real en inform√°tica: admitir que los errores de invalidaci√≥n de cach√© se nombran incorrectamente.  Estos son solo errores unitarios relacionados con el uso del tiempo. </blockquote> - Autor desconocido <br><br>  El tiempo es una cosa extra√±a. <br><br>  Esta vez es muy extra√±a, porque realmente queremos creer que est√° completamente optimizada.  Nos parece que cualquier evento a las 15.00 ocurre (como dir√≠amos) antes de cualquier evento a las 16.00, sin excepciones, argumentos o compromisos. <br><br>  Sin embargo, la inform√°tica conoce muchos ejemplos cuando es necesario abordar este requisito de manera no tan estricta.  Se manifiesta a nivel de procesadores, compiladores, nodos de red.  Una y otra vez en los c√°lculos, en diferentes niveles de la pila, nos encontramos en situaciones en las que nos enfrentamos a dos eventos, y no sabemos en qu√© orden ocurrieron.  El tiempo obviamente no es total;  Ella est√° fragmentada. <br><br>  Por qu√©  El hecho es que no lo sabemos, ya que el nivel de abstracci√≥n sobre el que existimos no proporciona una respuesta a esta pregunta.  Ya sea accidental o no, nuestras abstracciones computacionales no dan garant√≠as con respecto al procedimiento.  La libertad de reordenar eventos a menudo le permite crear sistemas mucho m√°s productivos y asequibles. <br><br>  El procesador puede tener un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">modelo de pedido de memoria</a> ;  refleja lo que garantiza que el procesador no quiere brindarle ninguna garant√≠a en la etapa de ensamblaje, por ejemplo, qu√© instrucci√≥n se ejecut√≥ antes y cu√°l despu√©s.  El procesador decide exactamente c√≥mo transmitir las instrucciones y las ejecuta fuera de servicio, es decir, utiliza sus chips de manera m√°s eficiente de lo que hubiera pensado. <br><br>  Un idioma puede tener un <i>modelo de coincidencia de memoria</i> ("modelo de memoria" para abreviar);  refleja lo que garantiza que el lenguaje no le brinda al generar un ensamblado, por ejemplo, al distribuir instrucciones en varios subprocesos.  Tal reordenamiento es, por definici√≥n, inherente al modelo de hardware de la memoria y explica en gran medida por qu√© se proporciona un concepto de tiempo tan "d√©bil" en los compiladores.  Est√° dentro del marco de dicho modelo de memoria implementado en el lenguaje que usted programa cuando escribe c√≥digo sin bloqueo. <br><br>  Un ejemplo famoso de un modelo de memoria implementado a nivel de lenguaje es el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">modelo de memoria fuerte y d√©bil</a> en el est√°ndar C ++ 11.  Por defecto, C ++ proporciona operaciones at√≥micas con sincronizaci√≥n, pero tambi√©n puede debilitar el modelo de acceso a la memoria para mejorar el rendimiento.  El comportamiento proporcionado de esta manera est√° destinado a servir como una abstracci√≥n sobre las arquitecturas del procesador principal utilizadas hoy (x86, POWER y ARM). <br><br>  Finalmente, un sistema distribuido puede tener su propio modelo de consistencia;  refleja lo que garantiza que el sistema no le dar√° con respecto al orden de los eventos en los clientes y las r√©plicas en la red inform√°tica mundial.  Los pedidos que est√°n directamente relacionados con la latencia de comunicaci√≥n o la falta de sincronizaci√≥n explican principalmente por qu√© en un sistema distribuido no puede prescindir del mencionado modelo de tiempo d√©bil.  Es este modelo de consistencia lo que usted programa cuando escribe una aplicaci√≥n distribuida. <br><br>  En la pr√°ctica, hay un gran <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">zool√≥gico</a> de modelos de consistencia que puede usar al programar un sistema distribuido.  En todas esas situaciones, estos modelos describen el comportamiento (deseado) del sistema observado desde fuera de ese sistema.  Si yo, un cliente espec√≠fico o una secuencia espec√≠fica, escribo un valor, luego lo leo de inmediato, ¬øest√° garantizado que definitivamente ver√© un registro no m√°s antiguo que el m√≠o?  Si el tiempo no estuviera fragmentado, si siempre tuvi√©ramos una idea clara en qu√© orden se desarrollan las operaciones en nuestro sistema, naturalmente, la respuesta a esta pregunta ser√≠a afirmativa.  Ser√≠a extra√±o hacer tal pregunta en absoluto. <br><br>  Pero el tiempo es fragmentario, por lo tanto, es necesario plantear esa pregunta. <br><br><h4>  Modelos de consistencia: quiero decir, modelos de memoria </h4><br>  Hablar de un orden tan fragmentado es a menudo dif√≠cil y siempre desagradable.  Nos gustar√≠a comenzar por el hecho de que en todos los niveles de la pila, el tiempo siempre es absolutamente absoluto, ya sea con transacciones ACID u operaciones / bloqueos at√≥micos.  ¬°Cuanto m√°s estrictas sean las garant√≠as, m√°s f√°cil ser√° programar con ellas! <br><br>  Pero todos luchamos por la velocidad.  Ya sea que se trate de sistemas distribuidos en los que se deba sacrificar la consistencia estricta en aras de la accesibilidad, o sobre la programaci√≥n sin bloqueo, donde se usa un modelo de memoria d√©bil para evitar los costos de sincronizaci√≥n, generalmente es recomendable que un programador que trabaje con cualquier nivel de la pila entre en estos argumentos complejos . <br><br>  La consistencia de los modelos de memoria compartida y la consistencia de los modelos de memoria distribuida son ambas <i>abstractas</i> .  Describen el programador que trabaja con el sistema, la interfaz de este sistema.  Permiten comprender qu√© tipos de comportamiento corresponden a un modelo de memoria d√©bil, dado que las propiedades generales del ordenamiento de eventos en el sistema, que damos por sentado, ya no act√∫an en √©l.  Puede parecer que estos dos modelos de memoria son similares, sin embargo, ambas comunidades han desarrollado sus propios discursos para la discusi√≥n.  Los valores utilizados en ellos difieren, aunque se superponen. <br><br>  Ya imaginamos cu√°n confundido puede ser esto.  Que hacer <br><br><h4>  Descripci√≥n del tiempo como entidad, lo que implica entre dos y ocho tipos de orden parcial. </h4><br>  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">su libro de 2014,</a> Sebastian Burkhardt busca proporcionar una descripci√≥n exhaustiva de las muchas opciones para modelos de consistencia.  Con esta caracter√≠stica, junto con otras estructuras matem√°ticas, se utilizan dos variantes del ordenamiento l√≥gico de los eventos: "visibilidad" y "arbitraje", mencionados anteriormente tambi√©n en otros trabajos de Burkhardt et al, ver, por ejemplo, el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> sobre se√±alar y verificar tipos de datos replicados (2014). <br><br>  La "visibilidad" es un orden parcial inherente al condicionamiento potencial.  Le permite rastrear qu√© eventos (posiblemente en otras r√©plicas) son visibles para qu√© otros eventos.  No hay requisitos de visibilidad aparte de acyclicity;  los eventos en un objeto pueden ser visibles para los eventos en otro objeto, y la operaci√≥n de leer o escribir un evento no afecta su visibilidad para otros eventos. <br><br>  La "arbitrariedad" es un orden general que le permite rastrear c√≥mo un sistema distribuido en el que surge una situaci√≥n de elecci√≥n juzgar√° qu√© evento ocurre antes y cu√°l despu√©s. <br><br>  Dado que los modelos de consistencia distribuida son similares a los modelos de memoria, resulta que tales fen√≥menos de visibilidad y aleatoriedad tambi√©n pueden ser √∫tiles cuando se discuten modelos de memoria.  En particular, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el ap√©ndice de su art√≠culo de 2014,</a> Burkhardt demuestra "cu√°n cerca" est√° el modelo de memoria d√©bil de C ++ 11 a la coherencia objeto por causalidad, pero con algunas desviaciones interesantes.  Esto se discutir√° en el resto de la publicaci√≥n. <br><br>  Para empezar, desarrollemos la visibilidad y la aleatoriedad, teniendo en cuenta la "lectura" y el "orden de los cambios".  Al "leer", la visibilidad entre dos objetos se tendr√° en cuenta solo en situaciones en las que tanto la lectura como la escritura tocan el mismo objeto, y cuando se lee solo un registro (o m√°s de uno) puede ser visible. <br>  Esto corresponde a una situaci√≥n en la que un procesador con memoria compartida en un momento dado puede registrar informaci√≥n en una sola celda de memoria para cualquier objeto en particular, incluso si diferentes subprocesos pueden acceder a ella en diferentes momentos de causa y efecto (por otro lado, en un sistema distribuido, la l√≥gica un objeto puede grabarse inmediatamente en muchas r√©plicas separadas). <br><br>  El ‚Äúorden de modificaci√≥n‚Äù corresponde a la misma etapa cuando se concreta la arbitrariedad, es objetivo y solo permite grabaciones.  Nuevamente, esta especializaci√≥n se basa en el hecho de que, con una especificaci√≥n de memoria d√©bil, las garant√≠as categ√≥ricas se otorgan solo a nivel de un objeto. <br><br>  A continuaci√≥n, analicemos los axiomas de consistencia formulados por Burkhardt et al. Y veamos c√≥mo se aplican a un modelo de memoria d√©bil.  Tenga en cuenta: incluso a pesar de la palabra "axiomas", estas son simplemente propiedades que pueden proporcionarse o no en varios modelos de memoria.  El art√≠culo de Burkhardt se centra en las propiedades que determinan la causalidad entre objetos. <br><br><h4>  Coherencia en √∫ltima instancia </h4><br>  Para cualquier evento en particular, no puede haber un n√∫mero indefinido de eventos que no lo vean.  Es decir, cualquier evento <i>es en √∫ltima instancia</i> visible para el sistema. <br><br>  Construir l√≥gicamente tales condiciones en un sistema con un modelo de memoria d√©bil deber√≠a ser algo m√°s dif√≠cil: debe argumentarse que para cualquier <i>registro en</i> particular no puede haber un n√∫mero infinito de operaciones de lectura que no leer√≠an este registro o registros anteriores (en el orden de modificaci√≥n). <br><br>  En la especificaci√≥n C ++ 11, no se garantiza el cumplimiento de este axioma, aunque en la pr√°ctica es dif√≠cil encontrar un contraejemplo. <br><br><h4>  Consistencia Et√©rea </h4><br>  Al rastrear la "condicionalidad potencial" a nivel de flujos / operaciones del cliente y con respecto a la visibilidad / legibilidad, debe comprender que no hay tiempo de retorno.  Es por eso que se requiere que los cierres al ordenar los flujos que implican lectura sean ac√≠clicos.  Como regla, no hay duda de que esta propiedad se observar√° en sistemas distribuidos, sin embargo, es esta propiedad la que no permite la visibilidad del usuario en algunas versiones especulativas si el sistema tiene un modelo de memoria d√©bil. <br><br>  Burkhardt et al. Se√±alan que este axioma "no est√° confirmado" en la especificaci√≥n C ++ 11, y no est√° claro "no valida" si se pueden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">observar</a> "ciclos satisfactorios" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en la pr√°ctica</a> . <br><br><h4>  Axiomas de condicionalidad </h4><br>  Para especificar con qu√© se relaciona exactamente el fen√≥meno de la condicionalidad bajo un modelo de memoria d√©bil, debemos determinar con precisi√≥n qu√© eventos pueden influir en los resultados de qu√© otros eventos.  Para comenzar, considere nuestros axiomas est√°ndar de causa y efecto: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">garant√≠as de sesi√≥n</a> .  Estas son cuatro cualidades interrelacionadas que reflejan las propiedades de coherencia de las operaciones de lectura y escritura que ocurren en diferentes flujos, adem√°s, deben especificarse al nivel de cada objeto (ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Burkhardt et al</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fig. 23</a> ). <br><br><ul><li>  RYW (Lea sus registros): la operaci√≥n de lectura despu√©s de la operaci√≥n de escritura se realiza en la misma celda, dentro de la misma secuencia / r√©plica / sesi√≥n, debe leer datos no menos relevantes que el registro.  La variante de esta propiedad para sistemas distribuidos se especifica exclusivamente en t√©rminos de visibilidad, mientras que la variante para un modelo de memoria d√©bil debe basarse tanto en el orden de lectura como en el orden de cambio. </li><li>  MR (lecturas monol√≠ticas): las lecturas posteriores (dentro de la misma secuencia, en la misma celda) tambi√©n deber√≠an ver datos no menos relevantes en el futuro. </li><li>  WFR (primera lectura, luego escritura): si la escritura sigue a la lectura dentro de la secuencia, en la misma celda, entonces, en el orden de los cambios, debe ir m√°s tarde que la operaci√≥n de lectura. </li><li>  MW (registros monol√≠ticos): los registros posteriores (dentro de la secuencia, en la misma celda) deben ir m√°s tarde en el orden de modificaci√≥n. </li></ul><br>  Las versiones originales de WFR y MW existen en dos versiones, para aleatoriedad y visibilidad;  pero esto es importante solo cuando se trabaja con celdas de datos m√°s complejas que con registros para enteros. <br><br>  Estas propiedades reflejan las nociones de condicionalidad, consistentes con nuestro sentido com√∫n;  sin embargo, extra√±an lo m√°s interesante.  En particular, al analizar en un modelo de memoria d√©bil, tales fen√≥menos de condicionalidad est√°n limitados por los l√≠mites del flujo / r√©plica / sesi√≥n y la celda / objeto espec√≠fico donde se realiza la entrada: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en un art√≠culo de Burkhardt et al</a> .  en este caso se dice sobre "visibilidad condicional por objeto por condicional" y "arbitrariedad arbitraria por objeto por condicional", v√©ase tambi√©n la fig.  23. Estos fen√≥menos no limitan completamente el comportamiento del sistema cuando diferentes flujos escriben informaci√≥n en diferentes celdas. <br><br>  Luego, los axiomas del condicionamiento de objetos cruzados describen el efecto de las relaciones causa-efecto a nivel de varios objetos / celdas de memoria. <br><br><ul><li>  COCV (Visibilidad condicional de objetos cruzados): el mismo caso que RYW, pero sin la condici√≥n de que la lectura final debe realizarse en el mismo hilo / r√©plica / sesi√≥n.  Las lecturas de un objeto que son objetivamente posteriores a los registros en este objeto deben tomar datos no menos relevantes que los ingresados ‚Äã‚Äãdurante la grabaci√≥n. </li></ul><br>  La especificaci√≥n C ++ 11 refleja estas propiedades.  Tenga en cuenta que est√°n definidos de tal manera que las restricciones en la visibilidad de grabaci√≥n y la arbitrariedad del orden de modificaci√≥n no afectan demasiado estas definiciones. <br><br>  Pero esto no se aplica a la √∫ltima propiedad. <br><br><ul><li>  COCA (arbitrario condicional de objetos cruzados): similar a los registros monol√≠ticos, pero se aplica a diferentes flujos, similar a COCV: es RYW para diferentes flujos.  Sin embargo, dado que el orden de modificaci√≥n solo afecta a los registros en un objeto, la formulaci√≥n de un modelo de memoria d√©bil permite que el sistema tenga una distribuci√≥n inconsistente de los eventos de grabaci√≥n en diferentes objetos, y los registros pueden no corresponder ni a las lecturas ni al orden dentro de la secuencia. </li></ul><br>  Espec√≠ficamente, COCA en un modelo de memoria d√©bil es una propiedad mucho m√°s d√©bil.  Es por eso que con un modelo de memoria d√©bil, el siguiente c√≥digo puede devolver <code>{x ‚â° 0, y ‚â° 0}</code> . <br><br> <code>Thread A: y := 0; x := 1; return x <br> Thread B: x := 0; y := 1; return y</code> <br> <br>  El orden dentro de cada flujo puede ser inconsistente con el orden objeto por orden y el orden de modificaci√≥n.  Tenga en cuenta: con RYW no hay <code>x := 0 ‚Üí x := 1</code> en el orden de modificaci√≥n y para <code>y</code> es lo mismo;  por lo tanto, el orden de modificaci√≥n debe contener <code>x := 1 ‚Üí x := 0</code> e <code>y := 1 ‚Üí y := 0</code> .  Por lo tanto, el orden de modificaci√≥n obviamente forma un ciclo en el orden de los flujos. <br>  Tal bucle est√° permitido en COCA con un modelo de memoria d√©bil.  No es que el orden de las secuencias / lecturas sea contrario al orden de modificaci√≥n, sino que cada secuencia ve un historial de registros consistente.  Estas historias son consistentes con las historias de otros flujos solo si limitamos objetivamente el alcance de su aplicaci√≥n. <br><br><h4>  ¬øQu√© significa todo esto? </h4><br>  El tiempo est√° fragmentado. <br><br>  Aunque nos parece que el tiempo fluye de manera ordenada, estudiar sistemas distribuidos y un modelo de memoria d√©bil muestra claramente que esto no es as√≠.  Es por eso que en ambas situaciones, nuestra sobre-aproximaci√≥n est√°ndar, seg√∫n la cual el tiempo es total, limita el rendimiento, lo que no podemos permitirnos. <br>  Luego, reconociendo que el tiempo est√° realmente fragmentado, encontramos muchas diferencias peque√±as pero importantes entre las variedades de tal parcialidad.  Incluso los dos campos mencionados anteriormente, que parecen tan similares a primera vista, en muchos matices sutiles permiten distinguir qu√© tipos particulares de eventos se consideran mutuamente afectados. <br><br>  Es necesario comprender con m√°s detalle los detalles t√©cnicos de varias propiedades ya despu√©s de que alguien pueda expresar las propiedades de un campo en el lenguaje de otro. <br><br>  El tiempo est√° fragmentado.  Quiz√°s solo necesitemos acostumbrarnos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430926/">https://habr.com/ru/post/es430926/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430914/index.html">An√°lisis de los precios del mercado negro para datos personales y penetraci√≥n</a></li>
<li><a href="../es430916/index.html">Detector de di√≥xido de carbono MT8057S. No revisi√≥n con la participaci√≥n de un no emulador</a></li>
<li><a href="../es430918/index.html">Sobre Flutter, en resumen: conceptos b√°sicos</a></li>
<li><a href="../es430922/index.html">Ejemplo de c√°lculo para centralita</a></li>
<li><a href="../es430924/index.html">Programaci√≥n Ada</a></li>
<li><a href="../es430928/index.html">Sobre la "casa inteligente": c√≥mo hacer una luz de fondo "inteligente"</a></li>
<li><a href="../es430930/index.html">Acerca de los gr√°ficos 3D en palabras simples</a></li>
<li><a href="../es430932/index.html">Los hackers robaron m√°s de 21 millones de rublos de un banco ruso</a></li>
<li><a href="../es430934/index.html">Asterisk dialplan extension generador de m√°scara</a></li>
<li><a href="../es430936/index.html">DEFCON 21. La conferencia DNS puede ser peligrosa para su salud. Parte 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>