<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø üï¢ üßí Segredo do firmware üõ´ üéØ üëÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Autores: Ph.D. Chernov A.V. ( monsieur_cher ) e Ph.D. Troshina K.N. 

 Como, usando as suposi√ß√µes mais gerais baseadas no conhecimento das arquitetura...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Segredo do firmware</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/solarsecurity/blog/442262/">  <b>Autores: Ph.D.</b>  <b>Chernov A.V.</b>  <b>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">monsieur_cher</a> ) e Ph.D.</b>  <b>Troshina K.N.</b> <br><br>  <b>Como, usando as suposi√ß√µes mais gerais baseadas no conhecimento das arquiteturas modernas de processador, voc√™ pode restaurar a estrutura do programa a partir de uma imagem bin√°ria de uma arquitetura desconhecida e, em seguida, restaurar algoritmos e muito mais?</b> <br><br>  Neste artigo, falaremos sobre uma tarefa interessante que nos foi apresentada v√°rios anos atr√°s.  O cliente pediu para lidar com o firmware bin√°rio do dispositivo que estava gerenciando um determinado processo f√≠sico.  Ele precisava de um algoritmo de controle na forma de um programa C compilado, al√©m de f√≥rmulas com uma explica√ß√£o de como eles funcionam e por qu√™.  Segundo o Cliente, isso era necess√°rio para garantir a compatibilidade com o equipamento "antigo" no novo sistema.  O modo como lidamos com a f√≠sica, no √¢mbito desta s√©rie de artigos, omitimos, mas consideraremos o processo de restaura√ß√£o do algoritmo em detalhes. <br><br>  O uso quase onipresente de microcontroladores program√°veis ‚Äã‚Äãem dispositivos de massa (IOT ou SmartHome Internet of Things) requer aten√ß√£o √† an√°lise bin√°ria do c√≥digo incorporado ou, em outras palavras, an√°lise bin√°ria do firmware do dispositivo. <br><br>  Uma an√°lise bin√°ria do firmware do dispositivo pode ter os seguintes objetivos: <br><br><ul><li>  An√°lise do c√≥digo de vulnerabilidades que permite obter acesso n√£o autorizado ao dispositivo ou aos dados transmitidos ou processados ‚Äã‚Äãpor este dispositivo. </li><li>  An√°lise de c√≥digo para recursos n√£o documentados, levando, por exemplo, a vazamento de informa√ß√µes. </li><li>  An√°lise de c√≥digo para restaurar protocolos e interfaces de intera√ß√£o com dispositivos para garantir a compatibilidade deste dispositivo com outros. </li></ul><br>  A tarefa de an√°lise de c√≥digo bin√°rio colocada acima pode ser considerada como um caso especial da tarefa de an√°lise bin√°ria para garantir a compatibilidade do dispositivo. <br><a name="habracut"></a><br><h4>  An√°lise do formato de arquivo bin√°rio </h4><br>  Se no mundo dos sistemas operacionais "reais", os formatos de arquivo execut√°veis ‚Äã‚Äãs√£o padronizados, no mundo dos programas incorporados, cada fornecedor pode usar sua solu√ß√£o propriet√°ria.  Portanto, a an√°lise do arquivo de firmware bin√°rio deve come√ßar com a an√°lise do formato do arquivo bin√°rio. <br><br>  No in√≠cio do trabalho, a situa√ß√£o para n√≥s era a seguinte: recebemos um determinado arquivo com o firmware sem nenhuma documenta√ß√£o anexa.  N√£o havia informa√ß√µes sobre o formato do arquivo de firmware nem sobre a arquitetura do microcontrolador. <br><br>  O arquivo do firmware acabou sendo um arquivo de texto.  Continha linhas do seguinte formato: <br><br><pre><code class="tex hljs">:04013000260F970CF8 :10020000004D000B043F000B34AD010C002FFE4D30 :02023000FD0BC1 :1004000018001A0000001E0008005E000200190052</code> </pre> <br>  Depois de analisar cuidadosamente o conjunto dessas linhas, percebemos que este √© um formato Intel HEX completamente padr√£o para microcontroladores.  O arquivo consiste em registros, cada um dos quais indica seu tipo, localiza√ß√£o da mem√≥ria, dados e soma de verifica√ß√£o.  Por si s√≥, o uso do formato Intel Hex implica que o arquivo provavelmente n√£o est√° criptografado e √© uma imagem de um programa que reside na mem√≥ria. <br><br>  Embora o formato Intel Hex suporte para endere√ßamento de mem√≥ria de at√© 32 bits, havia apenas endere√ßos de mem√≥ria de 16 bits em nosso arquivo.  Portanto, √© f√°cil criar um arquivo bin√°rio de uma imagem de mem√≥ria a partir de um arquivo de texto no qual os registros do arquivo de teste original j√° ser√£o colocados nos endere√ßos especificados.  √â mais conveniente inspecionar um arquivo bin√°rio usando os utilit√°rios de an√°lise de arquivo bin√°rio, e √© mais f√°cil escrever seus pr√≥prios utilit√°rios para ele do que para o Intel HEX.  O arquivo de mem√≥ria de imagem bin√°ria confirmou que o arquivo n√£o foi criptografado, pois v√°rias linhas significativas foram encontradas espalhadas em diferentes locais do c√≥digo. <br>  No entanto, isso n√£o respondeu √† pergunta para qual arquitetura esse arquivo √©. <br><br><img src="https://habrastorage.org/webt/25/6a/cq/256acqp6bgydpoj5ju-vwvc97gq.jpeg"><br><br>  Temos um arquivo com a imagem de mem√≥ria de um microcontrolador de 16 ou 8 bits.  E que tipo de microcontrolador √© n√£o est√° claro.  Pegamos o IDA Pro e tentamos desmontar o arquivo com todas as variantes poss√≠veis dos processadores suportados.  E nada.  Nenhum dos processadores suportados do IDA Pro surgiu: a listagem n√£o foi gerada ou continha um absurdo √≥bvio.  Pode ter sido um programa para um dos processadores IDA Pro suportados, mas fizemos algo errado.  Por exemplo, voc√™ s√≥ precisava de processamento adicional do arquivo de imagem.  De qualquer forma, aqui foi poss√≠vel suspender o trabalho e solicitar informa√ß√µes adicionais sobre o arquivo bin√°rio. <br><br><h4>  Todos os processadores s√£o praticamente os mesmos. </h4><br>  Mas tornou-se interessante para n√≥s, e o que podemos entender do programa bin√°rio, mesmo que o processador para o qual √© compilado seja desconhecido.  A resposta √© "nada" - desinteressante, mesmo que possamos entender um pouco, √© melhor que nada.  Obviamente, as strings de texto podem fornecer informa√ß√µes sobre o programa, mas pretendemos obter mais informa√ß√µes - para entender algo da estrutura do programa. <br>  V√°rias arquiteturas de processador - um grande n√∫mero.  A evolu√ß√£o da computa√ß√£o gerou at√© as arquiteturas mais incomuns, como computadores tern√°rios.  No entanto, os microprocessadores e microcontroladores que existem atualmente, pelo menos os de massa, s√£o notavelmente semelhantes entre si. <br><br>  Abaixo listamos os princ√≠pios b√°sicos comuns aos microprocessadores modernos. <br><br>  Execu√ß√£o consistente de instru√ß√µes.  O processador executa instru√ß√µes em sequ√™ncia na mem√≥ria.  Existem instru√ß√µes especiais para salto condicional e incondicional, chamada e retorno da sub-rotina, que permitem interromper a sele√ß√£o seq√ºencial de instru√ß√µes da mem√≥ria e prosseguir para outra instru√ß√£o.  No entanto, o restante das instru√ß√µes assume a execu√ß√£o sequencial e, portanto, n√£o cont√©m o endere√ßo da pr√≥xima instru√ß√£o. <br><br>  <i>Codifica√ß√£o bin√°ria.</i>  Al√©m do fato de o processador processar os dados em formato bin√°rio, as instru√ß√µes do processador que comp√µem o programa execut√°vel s√£o codificadas em formato bin√°rio, ou seja, os campos nos quais os par√¢metros de instru√ß√£o s√£o armazenados, por exemplo, deslocamentos ou n√∫meros de registro, ocupam um n√∫mero inteiro de bits.  Teoricamente, pode-se imaginar que, apesar da codifica√ß√£o bin√°ria de dados e programas, eles ser√£o processados ‚Äã‚Äãno processador em algum outro sistema num√©rico, mas n√£o temos conhecimento de tais informa√ß√µes ex√≥ticas. <br><br>  Os princ√≠pios a seguir, de um modo geral, n√£o s√£o princ√≠pios arquiteturais b√°sicos, mas s√£o praticamente universalmente implementados, especialmente para c√≥digo de m√°quina que n√£o √© escrito manualmente na linguagem assembly, mas √© gerado por um compilador de linguagem de alto n√≠vel. <br><br>  <i>Programa√ß√£o processual.</i>  O programa √© dividido em unidades estruturais, que podem ser chamadas de maneira diferente: procedimentos, fun√ß√µes, subprogramas, etc. Os subprogramas podem chamar outros subprogramas, passando par√¢metros para eles e recuperando o resultado da execu√ß√£o.  √â importante que o subprograma tenha um ponto de entrada, ou seja, todos os subprogramas que invocam o determinado v√£o para o mesmo endere√ßo do ponto de entrada. <br><br>  Normalmente, as rotinas t√™m um ponto de sa√≠da que retorna o controle ao ponto de chamada, mas isso √© menos significativo do que exigir um ponto de entrada para cada rotina.  Esse c√≥digo geralmente √© obtido atrav√©s da compila√ß√£o de um programa.  O otimizador de tempo de link pode destruir parcialmente essa estrutura para reduzir o tamanho do programa, e o tamanho do programa √© cr√≠tico para sistemas incorporados.  Al√©m disso, essa estrutura pode ser destru√≠da pelo ofuscador de c√≥digo. <br><br>  O aninhamento de chamadas de sub-rotina pode ser organizado usando a pilha, que ainda pode ser usada para passar argumentos para a sub-rotina e armazenar vari√°veis ‚Äã‚Äãlocais, mas, no n√≠vel atual de desenvolvimento da arquitetura, essas informa√ß√µes s√£o prematuras. <br><br>  Como esses princ√≠pios podem ser aplicados √† an√°lise inicial do c√≥digo bin√°rio? <br><br>  Assumimos que existe uma instru√ß√£o RET (retorno de uma sub-rotina) no sistema de comando do processador.  Esta instru√ß√£o possui algum tipo de representa√ß√£o bin√°ria fixa, a qual procuraremos.  Se o RET n√£o for o √∫nico, como em x86, onde o RET tem um argumento - o tamanho da √°rea de par√¢metro da sub-rotina ou se o RET √© um efeito colateral de uma opera√ß√£o mais complicada, como no ARMv7, onde o valor do PC pode ser buscado da pilha simultaneamente com os valores de outros registradores (ldmfd sp! , {fp, pc}), provavelmente, nossa pesquisa heur√≠stica n√£o produzir√° resultados. <br><br>  Tamb√©m precisamos fazer suposi√ß√µes razo√°veis ‚Äã‚Äãsobre o princ√≠pio das instru√ß√µes de codifica√ß√£o do processador em estudo.  Os processadores existentes usam v√°rios princ√≠pios para instru√ß√µes de codifica√ß√£o: <br><br><ul><li>  Um fluxo de bytes a partir do qual as instru√ß√µes s√£o geradas e instru√ß√µes diferentes s√£o codificadas com um n√∫mero diferente de bytes.  Nesta categoria, o representante mais famoso √© a fam√≠lia x86, dos primeiros processadores 8080 aos mais modernos processadores de 64 bits.  Uma instru√ß√£o do processador x86_64 pode ser codificada em uma sequ√™ncia de 1 a 16 bytes.  A mesma fam√≠lia de processadores com comprimentos de instru√ß√£o vari√°veis ‚Äã‚Äãinclui o 8051, que √© usado em microcontroladores. </li><li>  Um fluxo de valores de 16 bits.  Al√©m disso, cada instru√ß√£o tem um tamanho fixo - 16 bits. </li><li>  Um fluxo de valores de 16 bits, enquanto as instru√ß√µes s√£o de tamanho vari√°vel.  Um dos representantes dessa fam√≠lia √© a arquitetura PDP-11, na qual o pr√≥prio comando ocupa os primeiros 16 bits e pode ser seguido por valores diretos ou endere√ßos de mem√≥ria para endere√ßamento direto.  Isso inclui a codifica√ß√£o THUMB na arquitetura ARM. </li><li>  Um fluxo de valores de 32 bits, cada instru√ß√£o tem um tamanho fixo de 32 bits.  Estes s√£o a maioria dos processadores RISC de 32 e 64 bits: ARMv7, ARMv8, MIPS. </li></ul><br>  A escolha entre um fluxo de bytes de comprimento vari√°vel e um fluxo de palavras de 16 bits ajudar√° a visualizar a imagem da mem√≥ria "a olho nu".  N√£o importa como as instru√ß√µes do processador sejam codificadas, em um programa de dura√ß√£o suficiente elas ser√£o inevitavelmente repetidas.  Por exemplo, na instru√ß√£o x86 <br><br><pre> <code class="tex hljs">add <span class="hljs-comment"><span class="hljs-comment">%ebx,%eax</span></span></code> </pre> <br>  que adiciona os valores dos registros eax e ebx e coloca o resultado em eax, √© codificado em dois bytes: <br><br><pre> <code class="tex hljs">01 d8.</code> </pre> <br>  Na instru√ß√£o ARMv7 <br><br><pre> <code class="tex hljs">add r0, r0, r1</code> </pre> <br>  que adiciona os valores dos registradores r0 e r1 e coloca o resultado em r0, √© codificado pelo valor de 32 bits e0800001. <br><br>  Em um programa suficientemente grande, essas instru√ß√µes ser√£o repetidas mais de uma vez.  Se uma sequ√™ncia de bytes de seu interesse (por exemplo, 01 d8) ocorrer em um endere√ßo arbitr√°rio e desalinhado, podemos assumir que as instru√ß√µes do processador s√£o codificadas por um fluxo de bytes de tamanho vari√°vel.  Se o valor, por exemplo, e0800001 for encontrado apenas em endere√ßos com m√∫ltiplos de 4, podemos assumir um tamanho fixo das instru√ß√µes do processador.  Obviamente, h√° um erro aqui: pegamos bytes de dados para uma instru√ß√£o, ou aconteceu por acaso que alguma instru√ß√£o sempre se mostrou alinhada.  No entanto, o impacto desse "ru√≠do" em um programa de tamanho suficiente ser√° pequeno. <br><br>  Quando analisamos o firmware analisado desse √¢ngulo, ficou claro que muito provavelmente as instru√ß√µes para o processador em quest√£o est√£o codificadas com valores de 16 bits. <br><br>  Portanto, com base no pressuposto de que a codifica√ß√£o da instru√ß√£o RET √© um valor fixo de 16 bits, vamos tentar encontr√°-lo.  Encontramos na imagem do programa os valores mais comuns de 16 bits.  No nosso caso, aconteceu o seguinte: <br><br><pre> <code class="tex hljs"> (hex)   0b01 854 5.1<span class="hljs-comment"><span class="hljs-comment">% 0800 473 2.8% 8c0d 432 2.6% 2b00 401 2.4% 4e1c 365 2.2% 0801 277 1.6%</span></span></code> </pre><br>  Procuraremos a instru√ß√£o RET entre esses valores de 16 bits mais frequentemente encontrados no c√≥digo.  Imediatamente, procuraremos a instru√ß√£o CALL - emparelhada com a instru√ß√£o RET.  A instru√ß√£o CALL possui pelo menos um par√¢metro - o endere√ßo de salto, portanto, valores fixos s√£o indispens√°veis. <br><br>  Assumimos que, em muitos casos, imediatamente ap√≥s o final de um subprograma, ou seja, ap√≥s a instru√ß√£o RET, outro subprograma √© iniciado e esse subprograma √© chamado pela instru√ß√£o CALL de outro ponto do programa.  Um grande n√∫mero de saltos para o endere√ßo imediatamente ap√≥s RET ser√° uma das marcas registradas da instru√ß√£o CALL.  Obviamente, essa regra n√£o √© universal, pois em algumas plataformas, em particular no ARMv7, imediatamente ap√≥s a conclus√£o da sub-rotina, geralmente √© localizado um pool constante.  Nesse caso, podemos considerar um intervalo razo√°vel de endere√ßos imediatamente ap√≥s o RET como pontos de transi√ß√£o da instru√ß√£o RET. <br><br>  No caso da instru√ß√£o CALL, pode haver muitas op√ß√µes para codific√°-la na sub-rotina.  Em primeiro lugar, o processador pode usar uma ordem de bytes diferente na palavra: little-endian, como na maioria dos processadores modernos, quando um n√∫mero inteiro multibyte √© gravado na mem√≥ria, come√ßando com o byte baixo, e big-endian, quando um n√∫mero inteiro multibyte √© gravado na mem√≥ria, iniciando de byte alto.  Quase todos os processadores modernos operam no modo little-endian, mas voc√™ n√£o deve descartar outros poss√≠veis pedidos de bytes em uma palavra. <br>  Em segundo lugar, a instru√ß√£o CALL pode usar o endere√ßo absoluto do ponto de salto ou o endere√ßo relativo ao endere√ßo atual.  No caso de endere√ßamento absoluto, a instru√ß√£o codificada cont√©m o endere√ßo para o qual voc√™ deseja ir em alguns bits da instru√ß√£o codificada.  Para garantir que a sub-rotina seja chamada de qualquer ponto no espa√ßo de endere√ßo de 16 bits para qualquer outro ponto no endere√ßo absoluto da palavra de 16 bits, a instru√ß√£o codificada n√£o √© suficiente, pois, al√©m do endere√ßo de transi√ß√£o, os bits do c√≥digo de opera√ß√£o precisam ser armazenados em outro lugar.  Portanto, faz sentido considerar duas palavras de 16 bits seguidas e tentar op√ß√µes diferentes para dividir o endere√ßo de transi√ß√£o entre essas palavras. <br><br>  Uma alternativa √† codifica√ß√£o absoluta de um endere√ßo de rotina √© a codifica√ß√£o relativa.  Na instru√ß√£o codificada, registramos a diferen√ßa entre o endere√ßo do subprograma e o ponto atual.  A codifica√ß√£o relativa √© geralmente prefer√≠vel √† absoluta, porque, em primeiro lugar, um programa com transi√ß√µes relativas √© posicionalmente independente, ou seja, pode ser localizado na mem√≥ria a partir de qualquer endere√ßo sem altera√ß√µes no c√≥digo bin√°rio.  Em segundo lugar, para codificar o deslocamento, menos bits podem ser reservados que a dimens√£o do espa√ßo de endere√ßo, com base no fato de que, em muitos casos, a rotina chamada n√£o est√° t√£o distante da chamada.  No entanto, se o deslocamento da chamada estiver fora do intervalo de valores represent√°veis, voc√™ precisar√° inserir instru√ß√µes especiais - "saltos". <br><br>  A codifica√ß√£o relativa de um endere√ßo de subprograma pode ser realizada com algumas varia√ß√µes: primeiro, o endere√ßo do ponto atual do programa pode ser usado como o endere√ßo da instru√ß√£o atual ou como o endere√ßo da pr√≥xima instru√ß√£o, como nos processadores x86, ou o endere√ßo de alguma outra instru√ß√£o pr√≥xima ao ponto atual.  Por exemplo, nos processadores ARM, o ponto de refer√™ncia √© o endere√ßo da instru√ß√£o atual +8 (ou seja, n√£o o endere√ßo da instru√ß√£o ap√≥s a CHAMADA, mas o endere√ßo da instru√ß√£o ap√≥s a pr√≥xima).  Al√©m disso, como no nosso caso o programa √© escrito como um fluxo de palavras de 16 bits, √© l√≥gico esperar que o deslocamento seja expresso em palavras.  Ou seja, para obter o endere√ßo da rotina chamada, o deslocamento precisar√° ser multiplicado por 2. <br><br>  Levando em conta tudo acima, obtemos o seguinte espa√ßo de enumera√ß√£o para procurar um par CALL / RET no c√≥digo bin√°rio. <br><br>  Primeiro, usamos palavras de 16 bits da lista dos valores mais comuns no c√≥digo como candidatos √† instru√ß√£o RET.  Em seguida, pesquisamos a instru√ß√£o CALL: <br><br><ul><li>  Ordem de bytes de palavra big endian e little endian </li><li>  Codifica√ß√£o absoluta e relativa do endere√ßo de rotina na instru√ß√£o. </li></ul><br>  Para codifica√ß√£o absoluta, consideramos dois valores de 16 bits em uma linha, ou seja, classificamos v√°rias op√ß√µes para colocar um campo de bits que armazena um endere√ßo absoluto em uma palavra de 32 bits e, para codifica√ß√£o relativa, consideramos valores de 16 bits e duas palavras de 16 bits em uma linha .  Em seguida, classificamos as v√°rias op√ß√µes para colocar um campo de bits que armazena compensa√ß√µes.  Verificamos se o deslocamento √© expresso em bytes ou em palavras de 16 bits, ou seja, se √© necess√°rio multiplicar o deslocamento por 2, verificamos diferentes op√ß√µes para o ponto de refer√™ncia: o endere√ßo da instru√ß√£o atual, o endere√ßo da pr√≥xima instru√ß√£o. <br><br>  Para cada uma das op√ß√µes no espa√ßo de pesquisa descrito acima, calculamos as estat√≠sticas: <br><br><ul><li>  Quantos endere√ßos supostos do in√≠cio dos subprogramas n√£o est√£o obviamente corretos, ou seja, eles est√£o localizados onde n√£o h√° nada ou onde os dados (cadeias expl√≠citas ou tabelas de valores expl√≠citos) est√£o localizados.  Mesmo para o valor correspondente √† codifica√ß√£o correta da instru√ß√£o CALL, √© bem poss√≠vel que um pequeno n√∫mero de endere√ßos incorretos do in√≠cio do subprograma seja poss√≠vel se o valor correspondente √† instru√ß√£o CALL ocorrer acidentalmente nos dados. </li><li>  Quantos endere√ßos iniciais de rotina putativos est√£o imediatamente ap√≥s a instru√ß√£o RET putativa. </li><li>  Quantos endere√ßos hipot√©ticos de in√≠cio de rotinas s√£o usados ‚Äã‚Äãmais de uma vez. </li></ul><br>  Se nossas suposi√ß√µes sobre um par de instru√ß√µes CALL / RET estiverem corretas, dever√° estar no espa√ßo de enumera√ß√£o descrito.  Mas tamb√©m pode haver falsos positivos.  Bem, come√ßamos a busca. <br><br>  E encontramos apenas uma op√ß√£o poss√≠vel! <br><br><pre> <code class="tex hljs">Trying 8c0d as RET After-ret-addr-set-size: 430 Matching call opcodes for 1, ff00ff00, 1: 000b003d: total: 1275, hits: 843 (66<span class="hljs-comment"><span class="hljs-comment">%), misses: 432 (33%), coverage: 76%</span></span></code> </pre> <br>  Portanto, a palavra 8c0d de 16 bits √© adequada como candidata √† instru√ß√£o RET.  No total, o firmware cont√©m 430 posi√ß√µes de endere√ßos de programas imediatamente ap√≥s esta instru√ß√£o.  Foram considerados valores de 32 bits (duas palavras de 16 bits seguidas), com um valor de m√°scara de endere√ßo de ff 00 ff 00, uma instru√ß√£o com o c√≥digo 00 0b 00 3d foi encontrada.  Existem 1275 dessas instru√ß√µes, das quais 843 (ou seja, 66%) transferem o controle para o ponto imediatamente ap√≥s o candidato ao RET.  Assim, duas instru√ß√µes foram identificadas: <br><br><ul><li>  RET: 8c0d (Little-Endian de 16 bits) </li><li>  CHAMADA HHLL: 0bHH 3dLL (2 Little-Endian de 16 bits) </li></ul><br>  A instru√ß√£o CALL usa endere√ßamento absoluto e, ao escrever o endere√ßo de salto, o byte alto √© gravado primeiro e o byte baixo √© gravado.  √â poss√≠vel que, na realidade, estas sejam duas instru√ß√µes do processador, cada uma carregando metade do endere√ßo de transi√ß√£o, mas do ponto de vista da an√°lise do programa, isso n√£o √© importante.  Conhecendo as instru√ß√µes CALL e RET, podemos marcar com mais precis√£o √°reas de c√≥digo e dados do programa, o que ser√° importante para an√°lises posteriores. <br><br>  Para continuar ... <br><br>  Al√©m disso, mostraremos como as transi√ß√µes condicionais e incondicionais e algumas opera√ß√µes aritm√©ticas e l√≥gicas foram restauradas. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt442262/">https://habr.com/ru/post/pt442262/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt442250/index.html">Reagir e Vue: Pontos fortes</a></li>
<li><a href="../pt442252/index.html">Ciclo de vida do c√≥digo Python - CPython Runtime Model</a></li>
<li><a href="../pt442256/index.html">Defesa digital do mundo pl√°stico dos reguladores dom√©sticos da Internet</a></li>
<li><a href="../pt442258/index.html">Raspagem da Web para desenvolvedores da Web: um breve resumo</a></li>
<li><a href="../pt442260/index.html">10 comandos Git que um desenvolvedor deve saber</a></li>
<li><a href="../pt442264/index.html">Eliminando oportunidades de seq√ºestro de tr√°fego</a></li>
<li><a href="../pt442266/index.html">Delta Chat - mensageiro descentralizado sobre o email</a></li>
<li><a href="../pt442268/index.html">AsyncIO Micropython: m√©todos de sincroniza√ß√£o em programa√ß√£o ass√≠ncrona</a></li>
<li><a href="../pt442270/index.html">5 erros a serem evitados ao criar modelos 3D para impress√£o 3D</a></li>
<li><a href="../pt442272/index.html">Ir + = controle de vers√£o do pacote</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>