<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧟 🥂 👖 Desarrollo de su propio núcleo para incrustar en un sistema de procesador basado en FPGA ✈️ 🍍 🔺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Entonces, en el primer artículo del ciclo , se dijo que es mejor usar un sistema de procesador para controlar nuestro equipo implementado usando FPGAs...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desarrollo de su propio núcleo para incrustar en un sistema de procesador basado en FPGA</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454938/"><img src="https://habrastorage.org/webt/ze/eo/9f/zeeo9fw5rmqp8pk7lsmr0cytbve.jpeg"><br><br>  Entonces, en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primer artículo del ciclo</a> , se dijo que es mejor usar un sistema de procesador para controlar nuestro equipo implementado usando FPGAs para el complejo Redd, después de lo cual durante el primer y segundo artículo se mostró cómo hacer este sistema.  Bueno, está hecho, incluso podemos elegir algunos núcleos listos de la lista para incluirlos en él, pero el objetivo final es administrar nuestros propios núcleos personalizados.  Ha llegado el momento de considerar cómo incluir un núcleo arbitrario en el sistema del procesador. <br><a name="habracut"></a><br>  Todos los artículos del ciclo: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desarrollo del "firmware" más simple para FPGAs instalados en Redd, y depuración utilizando la prueba de memoria como ejemplo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desarrollo del "firmware" más simple para FPGAs instalados en Redd.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2. Código del programa</a> <br><br>  Para comprender la teoría de hoy, debe encontrar y descargar el documento de <b>especificaciones de la interfaz de Avalon</b> , ya que el bus <b>Avalon</b> es el bus base para el sistema NIOS II.  Me referiré a secciones, tablas y figuras para la revisión del documento del 26 de septiembre de 2018. <br><br>  Abrimos la sección 3 dedicada a las interfaces mapeadas de memoria, o más bien - 3.2.  La Tabla 9 enumera las señales del bus.  Tenga en cuenta que todas estas señales son opcionales.  No encontré una sola señal que tuviera "Sí" en la columna Requerido.  Es posible que no enviemos esta o aquella señal a nuestro dispositivo.  Por lo tanto, en el caso más simple, el bus es extremadamente simple de implementar.  El comienzo de la tabla se ve así: <br><br><img src="https://habrastorage.org/webt/qj/et/kn/qjetkngv8gubiwwtqtx8atvab7c.png"><br><br>  Como puede ver, todas las señales están muy bien descritas (excepto que esto se hace en inglés).  A continuación se muestran los cuadros de tiempo para varios casos.  El caso más simple no plantea ninguna pregunta.  Ahora tomaré el diagrama de tiempo del documento y cubriré algunas de las líneas con un relleno translúcido (todas son opcionales, tenemos el derecho de excluir cualquiera de las consideraciones). <br><br><img src="https://habrastorage.org/webt/q4/oz/w_/q4ozw_efgf6v6adbdhnkdeacply.png"><br><br>  Miedo  Pero todo es simple: se nos da la dirección y la luz estroboscópica de <b>lectura</b> , debemos configurar los datos en el bus readdata.  Y viceversa: se nos da la dirección, los datos en el bus de escritura de datos y la luz estroboscópica de escritura, y tenemos que ajustar los datos.  No es para nada aterrador, un bus sincrónico típico. <br><br>  <b>Se</b> necesitan líneas ocultas byteenable para el caso cuando el acceso a la memoria no es palabras de 32 bits.  Esto es extremadamente importante cuando diseñamos núcleos universales.  Pero cuando diseñamos un núcleo de un día, simplemente escribimos en el documento sobre este núcleo (soy un oponente de la marca en mi cabeza, pero alguien puede limitarlo a esto) que necesitamos usar palabras de 32 bits y eso es todo.  Bueno, y la señal de <b>respuesta</b> , es muy especial, y no nos interesa en principio. <br><br>  Algunas veces es importante que cuando el equipo no esté listo, sea posible retrasar la operación del bus por varios ciclos de reloj.  En este caso, se debe agregar la señal <b>WaitRequest</b> .  La tabla de tiempos cambiará de la siguiente manera: <br><br><img src="https://habrastorage.org/webt/sy/hr/lf/syhrlf64dvm-zrr262xvveicea4.png"><br><br>  Mientras <b>WaitRequest está activado</b> , el asistente sabe que nuestro dispositivo está ocupado.  Tenga cuidado si esta señal no se restablece, todo el sistema se "congelará" al manipularlo, por lo que solo un reinicio del FPGA puede restablecerlo.  JTAG se cuelga con el sistema.  La última vez que observé este fenómeno fue en la preparación de este artículo, por lo que los recuerdos aún son vívidos. <br><br>  Además, en el documento de la compañía se consideran casos más productivos de canalización de datos y transacciones por lotes, pero la tarea del artículo no es considerar todas las opciones posibles, sino mostrarle al lector la forma de trabajar, enfatizando que todo esto no da miedo, por lo que nos limitaremos a estas dos opciones simples. <br><br>  Diseñemos un dispositivo simple que periódicamente no estará disponible en el bus.  Lo primero que viene a la mente es la interfaz en serie.  Mientras la transmisión esté en progreso, haremos que el sistema espere.  Y en la vida, aconsejo encarecidamente que no haga esto: el procesador se detendrá hasta el final de una transacción ocupada, pero este es un caso ideal para un artículo, ya que el código de implementación será comprensible y no muy engorroso.  En general, haremos un transmisor en serie que pueda enviar datos y señales de selección de chips a dos dispositivos. <br><br><img src="https://habrastorage.org/webt/fr/uj/_u/fruj_ufw0phhzgbovupezinxo6c.png"><br><br>  Comencemos con la opción de llanta más simple.  Hagamos un puerto de salida paralelo, que forma las señales de la elección de los cristales. <br><br><img src="https://habrastorage.org/webt/rc/z6/yg/rcz6ygig6s3yz-bxsjwsbonygp4.png"><br><br>  Para esto, tomaré el proyecto obtenido en el artículo anterior, pero para evitar confusiones, lo pondré en el directorio AVALON_DEMO.  No cambiaré los nombres de otros archivos.  En este directorio, cree el directorio <b>my_cores</b> .  El nombre del directorio puede ser cualquier cosa.  Almacenaremos nuestros núcleos en él.  Es cierto, hoy será uno.  Cree un archivo <b>CrazySerial.sv</b> con el siguiente contenido: <br><pre><code class="plaintext hljs">module CrazySerial ( input clk, input reset, input [1:0] address, input write, input [31:0] writedata, output reg [1:0] cs ); always @(posedge clk, posedge reset) begin if (reset == 1) begin cs &lt;= 0; end else begin if (write) case (address) 2'h00: cs &lt;= writedata [1:0]; default:; endcase end end endmodule</code> </pre> <br>  Vamos a hacerlo bien.  En primer lugar, las líneas de interfaz.  <b>clk</b> y <b>reset</b> son las líneas de reloj y reset.  Los nombres de las <b>direcciones</b> , <b>escribir</b> y <b>escribir</b> <b>líneas de datos</b> se toman de la tabla con la lista de señales del documento de <b>Interfaces Mapeadas de Memoria</b> . <br><br><img src="https://habrastorage.org/webt/lz/q9/rv/lzq9rvmj8mekwwiqqene5mvbu7i.png"><br><br><img src="https://habrastorage.org/webt/pe/xz/a-/pexza-dsswt01-shzs4sy0pkjay.png"><br><br>  De hecho, podría dar cualquier nombre.  Vincular las líneas lógicas con las físicas se realizará más adelante.  Pero si da los nombres, como en la tabla, el entorno de desarrollo los conectará por sí mismo.  Por lo tanto, es mejor tomar los nombres de la tabla. <br><br>  Bueno, <b>cs</b> son las líneas de selección de cristal que saldrán del chip. <br><br>  La implementación en sí es trivial.  Cuando se reinicia, las salidas se ponen a cero.  Y así, en cada medida verificamos si hay una señal de <b>escritura</b> .  Si hay una dirección igual a cero, haga clic en los datos.  Por supuesto, sería posible agregar un decodificador aquí, lo que evitará la elección de dos dispositivos a la vez, pero lo que es bueno en la vida sobrecargará el artículo.  El artículo proporciona solo los pasos más necesarios, sin embargo, se observa que en la vida todo se puede hacer más complicado. <br><br>  Genial  Estamos listos para introducir este código en el sistema del procesador.  Vamos a <b>Platform Designer</b> , seleccionamos como archivo de entrada el sistema que creamos en experimentos anteriores: <br><br><img src="https://habrastorage.org/webt/vd/a3/mp/vda3mpnhkbmfl9gj037h7kyefs8.png"><br><br>  Llamamos la atención sobre el elemento <b>Nuevo componente</b> en la esquina superior izquierda: <br><br><img src="https://habrastorage.org/webt/iz/xq/hw/izxqhw8wg6jshahucg0ardu7ukg.png"><br><br>  Para agregar su componente, haga clic en este elemento.  En el cuadro de diálogo que se abre, complete los campos.  Y para el artículo, complete solo el nombre del componente: <br><br><img src="https://habrastorage.org/webt/nn/l8/mt/nnl8mtcsdxmqyp6cjnkrcr-qlc0.png"><br><br>  Ahora vaya a la pestaña <b>Archivos</b> y haga clic en <b>Agregar archivo</b> : <br><br><img src="https://habrastorage.org/webt/fo/rw/jx/forwjxin05orcsaaw7uuuiw1mra.png"><br><br>  Agregue el archivo creado anteriormente, selecciónelo en la lista y haga clic en <b>Analizar archivo de síntesis</b> : <br><br><img src="https://habrastorage.org/webt/a_/-i/g0/a_-ig0-b-v--safmwwco-gcblvi.png"><br><br>  No hay errores al analizar <b>SystemVerilog</b> , pero hay varios errores conceptuales.  Son causados ​​por el hecho de que algunas líneas estaban conectadas incorrectamente por el entorno de desarrollo.  Vamos a la pestaña <b>Señales e interfaces</b> y prestamos atención aquí: <br><br><img src="https://habrastorage.org/webt/be/7s/nb/be7snb0yjnqj8qn-ku_dboeirjs.png"><br><br>  Las líneas <b>cs</b> se asignaron incorrectamente a la interfaz <b>avalon_slave0</b> , la señal <b>readdata</b> .  Pero luego todas las otras líneas se reconocieron correctamente, gracias al hecho de que les dimos nombres de la tabla de documentos.  ¿Pero qué hacer con las líneas problemáticas?  Deben asignarse a una interfaz como <b>conducto</b> .  Para hacer esto, haga clic en el elemento "agregar interfaz" <br><br><img src="https://habrastorage.org/webt/ur/ce/je/urcejebzbrayxcoyvs16vorleik.png"><br><br>  En el menú desplegable, seleccione <b>conducto</b> : <br><br><img src="https://habrastorage.org/webt/2-/l-/45/2-l-45h1b_8jnat3uazcscgcpt0.png"><br><br>  Obtenemos una nueva interfaz: <br><br><img src="https://habrastorage.org/webt/g_/r4/j0/g_r4j0acbfvawp7plewjmsolw1e.png"><br><br>  Si lo desea, puede cambiarle el nombre.  Es cierto que esto sin duda será necesario si queremos hacer varias interfaces externas.  Como parte del artículo, le dejaremos el nombre <b>conduit_end</b> .  Ahora conectamos la línea <b>cs</b> con el mouse y la arrastramos a esta interfaz.  Debemos lograr lanzar una señal debajo de la línea <b>conduit_end</b> , luego se nos permitirá hacer esto.  En otros lugares, el cursor aparecerá como un círculo tachado.  Al final, deberíamos tener esto: <br><br><img src="https://habrastorage.org/webt/gb/2e/lw/gb2elw6dvx2iw11y28uq0qlye5q.png"><br><br>  Reemplace el tipo de señal con <b>readdata</b> con, digamos, <b>chipselect</b> .  Imagen final: <br><br><img src="https://habrastorage.org/webt/6o/ur/gq/6ourgq054tn85rth2nixk33_pvs.png"><br><br>  Pero los errores permanecieron.  El <b>bus avalon</b> no tiene asignada una señal de reinicio.  Seleccionamos <b>avalon_slave_0</b> de la lista y miramos sus propiedades. <br><br><img src="https://habrastorage.org/webt/s6/0i/--/s60i--4ijigk6exutkovd5zlwi0.png"><br><br>  Reemplace <b>ninguno</b> con <b>reinicio</b> .  Al mismo tiempo, examinaremos las otras propiedades de la interfaz. <br><br><img src="https://habrastorage.org/webt/xn/4d/kf/xn4dkf5jpxsi-6ujubxeuptddo4.png"><br><br>  Se puede ver que el direccionamiento es en palabras.  Bueno, aquí se configuran otras cosas de la documentación.  Los diagramas de tiempo que se obtienen en este caso se dibujarán en la parte inferior de las propiedades: <br><br><img src="https://habrastorage.org/webt/xc/nw/xq/xcnwxqjxkz7y4qgxtcmn6ulb5eu.png"><br><br>  En realidad, no hay más errores.  Puedes hacer clic en <b>Finalizar</b> .  Nuestro módulo creado apareció en el árbol de dispositivos: <br><br><img src="https://habrastorage.org/webt/rt/qe/bz/rtqebza22wictmnw0cpgvw_uu3g.png"><br><br>  Agréguelo al sistema del procesador, conecte las señales del reloj y reinicie.  Conectamos el bus de <b>datos al</b> procesador <b>Data Master</b> .  Haga doble clic en <b>Conduit_end</b> y <b>asigne</b> a la señal externa un nombre, por ejemplo, <b>líneas</b> .  Resulta de alguna manera así: <br><br><img src="https://habrastorage.org/webt/ob/mm/al/obmmalo6x1jytho2mzkvy4emdbu.png"><br><br>  Es importante no olvidar que, dado que agregamos un bloque al sistema, debemos asegurarnos de que no entre en conflicto con nadie en el espacio de direcciones.  En este caso particular, no hay conflictos en la figura, pero de todos modos, seleccionaré el elemento del menú <b>Sistema-&gt; Asignar direcciones base</b> . <br><br>  Eso es todo.  El bloque se crea, configura y agrega al sistema.  Haga clic en el botón <b>Generar HDL</b> , luego en <b>Finalizar</b> . <br><br>  Hacemos un borrador del proyecto, luego de lo cual vamos al <b>Pin Planner</b> y asignamos las piernas.  Resultó así: <br><br><img src="https://habrastorage.org/webt/mn/fs/39/mnfs39ezihwpwese2tsdto4ialc.png"><br><br>  Que corresponde a los contactos B22 y C22 del conector de interfaz. <br><br>  Hacemos el ensamblaje final, cargamos el sistema del procesador en el FPGA.  Ahora necesitamos refinar el código del programa.  Lanzamiento de Eclipse. <br><br>  Permítame recordarle que actualmente estoy trabajando con un proyecto que se encuentra en un directorio diferente en relación con mi último trabajo con Redd.  Para no confundirme, eliminaré proyectos antiguos del árbol (pero solo del árbol, sin borrar los archivos mismos). <br><br><img src="https://habrastorage.org/webt/xm/jv/ch/xmjvchikm8_ukin_evoqdw28op8.png"><br><br>  A continuación, hago clic con el botón derecho del mouse en un árbol vacío y selecciono <b>Importar</b> en el menú: <br><br><img src="https://habrastorage.org/webt/yp/kt/sf/ypktsfboxaxgfhqcubjnlwogoxq.png"><br><br>  Siguiente - <b>General-&gt; Proyecto existente en el espacio de trabajo</b> : <br><br><img src="https://habrastorage.org/webt/rb/dw/me/rbdwmebel6yu6hjmvyxn7hik0q8.png"><br><br>  Y simplemente seleccione el directorio en el que se almacenan los archivos del proyecto: <br><br><img src="https://habrastorage.org/webt/nd/3t/6h/nd3t6hwmddm9pfrwr4cjd4iw4hy.png"><br><br><img src="https://habrastorage.org/webt/ei/qg/de/eiqgdehf_klzhkyyleod_opnlgq.png"><br><br>  Ambos proyectos heredados de experimentos anteriores se conectarán al entorno de desarrollo. <br><br><img src="https://habrastorage.org/webt/qq/vw/jk/qqvwjkfgoli7vu3wedt3qhbnsf0.png"><br><br>  Destacaré el siguiente elemento en un marco: <br><blockquote>  Cada vez que cambie la configuración del hardware, seleccione el elemento <b>Nios II -&gt; Generar</b> menú <b>BSP</b> para el proyecto BSP nuevamente. </blockquote><br><br><img src="https://habrastorage.org/webt/ks/jn/mt/ksjnmtcdfbf2p0vej4qeeltlkxk.png"><br><br>  En realidad, después de esta operación, apareció un nuevo bloque en el <b>archivo \ AVALON_DEMO \ software \ SDRAMtest_bsp \ system.h</b> : <br><pre> <code class="plaintext hljs">/* * CrazySerial_0 configuration * */ #define ALT_MODULE_CLASS_CrazySerial_0 CrazySerial #define CRAZYSERIAL_0_BASE 0x4011020 #define CRAZYSERIAL_0_IRQ -1 #define CRAZYSERIAL_0_IRQ_INTERRUPT_CONTROLLER_ID -1 #define CRAZYSERIAL_0_NAME "/dev/CrazySerial_0" #define CRAZYSERIAL_0_SPAN 16 #define CRAZYSERIAL_0_TYPE "CrazySerial"</code> </pre><br>  En primer lugar, estamos interesados ​​en la constante <b>CRAZYSERIAL_0_BASE</b> . <br><br>  Agregue el siguiente código a la función <b>main ()</b> : <br><pre> <code class="plaintext hljs"> while (true) { IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE,0x00); IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE,0x01); IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE,0x02); IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE,0x03); }</code> </pre><br>  Comenzamos a depurar y miramos el contenido de las líneas con un osciloscopio.  Debe haber un código binario incremental.  El esta ahi. <br><br><img src="https://habrastorage.org/webt/fm/xp/0z/fmxp0z5mactvzv-vdv2cahbvj1i.png"><br><br>  Además, la frecuencia de acceso a los puertos es simplemente maravillosa: <br><br><img src="https://habrastorage.org/webt/cm/rd/of/cmrdofrh6yzmo2xwdkjynz6gwwm.png"><br><br>  Aproximadamente 25 MHz es la mitad de la frecuencia del bus (2 ciclos de reloj).  A veces el tiempo de acceso no es de 2 ciclos, sino más largo.  Esto se debe a la ejecución de operaciones de ramificación en el programa.  En general, el acceso más simple al autobús funciona. <br><br>  Es hora de agregar, por ejemplo, la funcionalidad del puerto serie.  Para hacer esto, agregue la señal de interfaz de <b>solicitud de espera</b> relacionada con el bus y un par de señales de puerto serie: <b>sck</b> y <b>sdo</b> .  Total, obtenemos el siguiente fragmento de código en <b>systemverilog</b> : <br><br><img src="https://habrastorage.org/webt/dy/wc/vt/dywcvtwz6_h4ccubotauamcnnju.png"><br><br><div class="spoiler">  <b class="spoiler_title">Mismo texto:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module CrazySerial ( input clk, input reset, input [1:0] address, input write, input [31:0] writedata, output waitrequest, output reg [1:0] cs, output reg sck, output sdo );</code> </pre><br></div></div><br>  De acuerdo con las reglas de buena forma, debe hacer una máquina simple que transmita datos.  Desafortunadamente, la máquina más sencilla en el artículo se verá muy difícil.  Pero, de hecho, si no aumento la funcionalidad de la máquina (y no voy a hacerlo dentro del marco del artículo), entonces solo tendrá dos estados: la transmisión está en progreso y la transmisión no está en progreso.  Por lo tanto, puedo codificar el estado con una sola señal: <br>  envío de registros = 0; <br><br>  Durante la transmisión, necesito un contador de bits, un divisor de reloj (estoy haciendo un dispositivo deliberadamente lento) y un registro de desplazamiento para los datos transmitidos.  Agregue los registros apropiados: <br><pre> <code class="plaintext hljs"> reg [2:0] bit_cnt = 0; reg [3:0] clk_div = 0; reg [7:0] shifter = 0;</code> </pre><br>  Dividiré la frecuencia por 10 (guiado por el principio de "¿por qué no?").  En consecuencia, en el quinto paso, llamaré a SCK, y en el décimo, dejar esta línea, después de lo cual, pasaré al siguiente bit de datos.  En todas las demás medidas, simplemente aumente el contador divisor.  Es importante no olvidar que en la cuarta medida también necesita aumentar el contador, y en la novena - cero.  Si omitimos la transición al siguiente bit, la lógica especificada se ve así: <br><pre> <code class="plaintext hljs"> if (sending) begin case (clk_div) 4: begin sck &lt;= 1; clk_div &lt;= clk_div + 1; end 9: begin sck &lt;= 0; clk_div &lt;= 0; // &lt;   &gt; end default: clk_div &lt;= clk_div + 1; endcase end else</code> </pre><br>  Ir al siguiente bit es fácil.  Cambiaron el registro de desplazamiento, luego, si el bit actual es el séptimo, dejaron de funcionar cambiando el estado de la máquina, de lo contrario aumentaron el contador de bits. <br><pre> <code class="plaintext hljs"> shifter &lt;= {shifter[6:0],1'b0}; if (bit_cnt == 7) begin sending &lt;= 0; end else begin bit_cnt &lt;= bit_cnt + 1; end</code> </pre><br>  En realidad, eso es todo.  El bit de salida siempre se toma del bit alto del registro de desplazamiento: <br><pre> <code class="plaintext hljs"> assign sdo = shifter [7];</code> </pre><br>  Y la línea más importante para la revisión actual.  La señal de <b>solicitud de espera se activa</b> hasta la unidad siempre que se transmiten datos en serie.  Es decir, es una copia de la señal de <b>envío</b> que establece el estado de la máquina: <br><pre> <code class="plaintext hljs"> assign waitrequest = sending;</code> </pre><br>  Bueno, y al escribir en la dirección 1 (recuerde, aquí tenemos el direccionamiento en palabras de 32 bits), ajustamos los datos en el registro de desplazamiento, ponemos a cero los contadores e iniciamos el proceso de transferencia: <br><pre> <code class="plaintext hljs"> if (write) //... 2'h01: begin bit_cnt &lt;= 0; clk_div &lt;= 0; sending &lt;= 1; shifter &lt;= writedata [7:0]; end default:; endcase end</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Ahora daré todos los fragmentos descritos como un solo texto:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module CrazySerial ( input clk, input reset, input [1:0] address, input write, input [31:0] writedata, output waitrequest, output reg [1:0] cs, output reg sck, output sdo ); reg sending = 0; reg [2:0] bit_cnt = 0; reg [3:0] clk_div = 0; reg [7:0] shifter = 0; always @(posedge clk, posedge reset) begin if (reset == 1) begin cs &lt;= 0; sck &lt;= 0; sending &lt;= 0; end else begin if (sending) begin case (clk_div) 4: begin sck &lt;= 1; clk_div &lt;= clk_div + 1; end 9: begin clk_div &lt;= 0; shifter &lt;= {shifter[6:0],1'b0}; sck &lt;= 0; if (bit_cnt == 7) begin sending &lt;= 0; end else begin bit_cnt &lt;= bit_cnt + 1; end end default: clk_div &lt;= clk_div + 1; endcase end else if (write) case (address) 2'h00: cs &lt;= writedata [1:0]; 2'h01: begin bit_cnt &lt;= 0; clk_div &lt;= 0; sending &lt;= 1; shifter &lt;= writedata [7:0]; end default:; endcase end end assign sdo = shifter [7]; assign waitrequest = sending; endmodule</code> </pre><br></div></div><br>  Comenzamos a introducir nuevo código en el sistema.  En realidad, la ruta es la misma que cuando se crea el componente, pero algunos de los pasos ya pueden omitirse.  Ahora nos familiarizaremos con el proceso de refinamiento.  Vaya a <b>Diseñador de plataforma</b> .  Si solo cambiamos el código verilog, sería bastante simple realizar la operación <b>Generar HDL</b> para el sistema terminado.  Pero dado que el módulo tiene nuevas líneas (es decir, la interfaz ha cambiado), necesita ser rehecho.  Para hacer esto, selecciónelo en el árbol, presione el botón derecho del mouse y seleccione <b>Editar</b> . <br><br><img src="https://habrastorage.org/webt/sg/el/hx/sgelhxlzgzwjz81z6q7xhkhbxzs.png"><br><br>  Estamos editando un sistema existente.  Tan solo vaya a la pestaña <b>Archivos</b> y haga clic en <b>Analizar archivos de síntesis</b> : <br><br><img src="https://habrastorage.org/webt/qy/nw/0q/qynw0q5tul7k26yaygdyzsigouu.png"><br><br>  Predeciblemente se produjeron errores.  Pero ya sabemos que las líneas equivocadas tienen la culpa.  Por lo tanto, vamos a la pestaña <b>Señales e interfaces</b> , arrastramos <b>sck</b> y <b>sdo a lo</b> largo de la misma línea desde la interfaz <b>avalon_slave_0</b> a la interfaz <b>conduit_end</b> : <br><br><img src="https://habrastorage.org/webt/z_/rz/jj/z_rzjjaaiaqzey6gczf6ptt0vfa.png"><br><br>  También cambie el nombre de los campos de <b>Tipo de señal</b> para ellos.  El resultado debe ser el siguiente: <br><br><img src="https://habrastorage.org/webt/ng/3_/t_/ng3_t_kiebqf_jw3wwljh0aqsig.png"><br><br>  En realidad, eso es todo.  Haga clic en <b>Finalizar</b> , llame a <b>Generar archivo HDL</b> para el sistema del procesador, redacte el proyecto en Quartus, asigne nuevos tramos: <br><br><img src="https://habrastorage.org/webt/ul/hg/rh/ulhgrhytzp1y9149j8x11apyvcy.png"><br><br>  Estos son los contactos A21 y A22 del conector de interfaz, hacemos el ensamblaje final, completamos el "firmware" en el FPGA. <br><br>  Plancha actualizada.  Ahora el programa.  Vamos a Eclipse.  ¿Qué recordamos hacer allí?  Así es, no te olvides de elegir <b>Generate BSP</b> . <br><br>  En realidad, eso es todo.  Queda por agregar funcionalidad al programa.  Transfieramos un par de bytes al puerto serie, pero enviaremos el primer byte al dispositivo seleccionado por la línea <b>cs [0]</b> y el segundo - <b>cs [1]</b> . <br><pre> <code class="plaintext hljs"> IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE,0x01); IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE+4,0x12); IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE,0x02); IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE+4,0x34); IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE,0x00);</code> </pre><br>  Tenga en cuenta que no hay controles de disponibilidad allí.  Las parcelas van una tras otra.  Sin embargo, en el osciloscopio todo resultó bastante consistente <br><br><img src="https://habrastorage.org/webt/vh/qm/ig/vhqmigcblrnmmcizbs11jwdgsig.png"><br><br>  El rayo amarillo es <b>cs [0]</b> , el <b>rayo</b> verde es <b>sdo</b> , el <b>rayo</b> violeta es <b>sck</b> y el <b>rayo</b> azul es <b>cs [1]</b> .  Se puede ver que el código 0x12 fue al primer dispositivo, 0x34 al segundo. <br><br>  La lectura se realiza de manera similar, pero no puedo encontrar ningún ejemplo hermoso, excepto la lectura banal del contenido del pie del conector.  Pero ese ejemplo es tan degenerado que ni siquiera es interesante hacerlo.  Pero aquí vale la pena señalar que al leer esta configuración de bus puede ser extremadamente importante: <br><br><img src="https://habrastorage.org/webt/m4/7g/i6/m47gi6xbkat-jct5iuuffqmyya8.png"><br><br>  Si hay una línea de <b>Lectura</b> , aparecerá un cuadro de tiempo de lectura en el cuadro de diálogo de configuración.  Y mostrará la influencia de este parámetro.  Al leer las patas del conector, aún no se notará, pero al leer desde el mismo FIFO o RAM, completamente.  La RAM se puede configurar para emitir datos inmediatamente después de que se envíe la dirección, o se puede emitir sincrónicamente.  En el segundo caso, se agrega latencia.  Después de todo, el bus estableció la dirección, configuró la luz estroboscópica ... Pero no hay datos en el borde más cercano de la señal del reloj.  Aparecerán después de este frente ... Es decir, el sistema tiene una latencia de latencia única.  Y solo debe tenerse en cuenta al configurar este parámetro.  En resumen, si no está leyendo lo que se esperaba, primero verifique si necesita configurar la latencia.  El resto: leer no es diferente de escribir. <br><br>  Bien, permítame recordarle una vez más que es mejor no eliminar la preparación del bus para operaciones a largo plazo, de lo contrario es muy posible reducir drásticamente el rendimiento del sistema.  La señal de listo es buena para mantener la transacción durante un par de ciclos de reloj, y no hasta 80 ciclos de reloj, como en mi ejemplo.  Pero, en primer lugar, cualquier otro ejemplo sería inconveniente para el artículo y, en segundo lugar, para los núcleos de un día, esto es bastante aceptable.  Estará completamente consciente de sus acciones y evitará situaciones en las que el autobús esté bloqueado.  Es cierto que si el núcleo sobrevive el tiempo que se le asigna, tal suposición puede arruinar la vida en el futuro, cuando todos se olviden de ello, y ralentizará todo.  Pero será más tarde. <br><br>  Sin embargo, hemos aprendido a hacer que el núcleo del procesador controle nuestros núcleos.  Todo está claro con el mundo direccionable, ahora es el momento de lidiar con el mundo de la transmisión.  Pero haremos esto en el próximo artículo, y posiblemente incluso en varios artículos. <br><br><h3>  Conclusión </h3><br>  El artículo muestra cómo se puede conectar un kernel arbitrario de Verilog para controlar el sistema de procesador Nios II.  Se muestran las opciones para la conexión más simple al bus Avalon, así como la conexión en la que el bus puede estar ocupado.  Se proporcionan enlaces a la literatura, desde la cual puede encontrar otros modos de funcionamiento del bus Avalon en el modo Asignación de memoria. <br><br>  El proyecto resultante se puede descargar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/454938/">https://habr.com/ru/post/454938/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454924/index.html">Configuración de autenticación en Veeam Backup para Microsoft Office 365 v3</a></li>
<li><a href="../454926/index.html">Todo lo que sabías sobre word2vec no es cierto</a></li>
<li><a href="../454930/index.html">Recolección de basura en V8: como funciona el nuevo Orinoco GC</a></li>
<li><a href="../454932/index.html">Inversiones y software: 5 terminales comerciales para operar en bolsa</a></li>
<li><a href="../454936/index.html">Vivaldi: el bloqueo de anuncios debe ser la elección del usuario</a></li>
<li><a href="../454940/index.html">Seguro médico de viaje: instrucciones detalladas</a></li>
<li><a href="../454944/index.html">Cómo funciona el formato JPEG</a></li>
<li><a href="../454946/index.html">Estados globales: por qué y cómo evitarlos</a></li>
<li><a href="../454958/index.html">Una mirada al interior: escuela de posgrado en EPFL. Parte 4.1: vida cotidiana</a></li>
<li><a href="../454960/index.html">Microbiota Cómo las drogas afectan las bacterias intestinales</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>