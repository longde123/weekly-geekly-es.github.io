<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧦 ⛹🏽 🤘🏾 Modul memuat otomatis menggunakan impor dinamis 🛴 👧🏼 🎒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini , dukungan untuk modul ECMAScript diumumkan di Node.js, dan dukungan untuk impor dinamis muncul di ES2020. Dalam kerangka artikel ini sa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Modul memuat otomatis menggunakan impor dinamis</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478974/"><p>  Baru-baru ini <a href="https://medium.com/%40nodejs/announcing-core-node-js-support-for-ecmascript-modules-c5d6dc29b663" rel="nofollow">,</a> dukungan untuk modul ECMAScript <a href="https://medium.com/%40nodejs/announcing-core-node-js-support-for-ecmascript-modules-c5d6dc29b663" rel="nofollow">diumumkan</a> di Node.js, dan dukungan untuk <a href="https://v8.dev/features/dynamic-import" rel="nofollow">impor dinamis</a> muncul di ES2020.  Dalam kerangka artikel ini saya akan berbicara tentang implementasi kasus nyata menggunakan impor dinamis - dengan nama direktori yang tidak diketahui sebelumnya. </p><br><p><img src="https://habrastorage.org/webt/xf/tq/5x/xftq5xiu8t_um1cnsinetckoqee.png" alt="penutup"></p><a name="habracut"></a><br><h1 id="problematika">  Masalah </h1><br><p>  Seringkali saya mengamati sekitar struktur direktori berikut dalam proyek: </p><br><pre><code class="plaintext hljs">$ tree . ├── modules │ ├── a │ │ └── index.ts │ ├── b │ │ └── index.ts │ └── c │ └── bobule.ts ├── index.ts └── package.json</code> </pre> <br><p>  dan isi dari <code>index.ts</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./modules/a'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./modules/b'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./modules/c/bobule.ts'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { <span class="hljs-attr"><span class="hljs-attr">module</span></span>: a, <span class="hljs-attr"><span class="hljs-attr">dopule</span></span>: b, <span class="hljs-attr"><span class="hljs-attr">bobule</span></span>: c };</code> </pre> <br><p>  Dan kemudian di suatu tempat di tingkat atas ada index.ts lain yang mengimpor index.ts ini yang mengimpor ... </p><br><p>  Saya ingin menulis sesuatu seperti <code>index.ts</code> tingkat <code>index.ts</code> </p><br><pre> <code class="plaintext hljs">import modules from './modules/*/*'</code> </pre> <br><p>  tetapi di luar kotak, ini tidak didukung, yang membangkitkan dalam diri saya keinginan tak tertahankan untuk mengacaukan saya <del>  kruk, sepeda, rangka </del>  Tidak diragukan lagi solusi yang berguna, asli dan sangat diperlukan untuk masalah ini. </p><br><h1 id="dinamicheskie-importy">  Impor dinamis </h1><br><p>  Keuntungan utama mengimpor dinamis daripada statis adalah bentuk fungsional, yang memungkinkan memuat modul berdasarkan kondisi.  Cara kerjanya seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// module.ts export const a = 'i love hexlet' const b = { referral: 'hexlet.io/?ref=162475' } export default b // index.ts const module = await import('./module.ts') module.default // { referral: 'hexlet.io/?ref=162475' } module.a // 'i love hexlet'</span></span></code> </pre> <br><p>  Dengan demikian, menambahkan sedikit <code>fs</code> ke desain ini, impor dinamis akan memungkinkan Anda untuk mendapatkan semua file dari subdirektori dari tingkat mana pun. </p><br><h1 id="vdohnovlyonnyy-php">  Terinspirasi PHP </h1><br><p>  Gagasan autoload bukanlah hal baru dan aktif digunakan dalam PHP, karena alasan arsitektur dan historis, tetapi tidak ada yang menghalangi saya untuk membuat kesulitan saya sendiri dan mengatasinya dengan heroik.  Oleh karena itu, saya mencoba membuat bagian autoload di package.json dan membuat alat yang membaca nama modul dengan kunci, dan path file dari nilai: </p><br><pre> <code class="json hljs">//  package.json { <span class="hljs-attr"><span class="hljs-attr">"autoload"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"modules"</span></span>: [<span class="hljs-string"><span class="hljs-string">"modules"</span></span>, <span class="hljs-string"><span class="hljs-string">"*"</span></span>, <span class="hljs-string"><span class="hljs-string">"index.ts"</span></span>] <span class="hljs-string"><span class="hljs-string">"bobules"</span></span>: [<span class="hljs-string"><span class="hljs-string">"*"</span></span>, <span class="hljs-string"><span class="hljs-string">"*"</span></span>, <span class="hljs-string"><span class="hljs-string">"bobule.ts"</span></span>], } }</code> </pre> <br><p>  Dalam hal menggunakan typescipt, ada momen yang mengganggu dengan fakta bahwa ekstensi berubah setelah aplikasi dibangun dan ada lebih dari dua di antaranya: <code>ts|js|mjs|tsx</code> sehingga Anda dapat segera mempertimbangkannya dengan mendaftar semua opsi yang tersedia, dan unduh hanya yang Anda perlukan: </p><br><pre> <code class="json hljs">//  package.json { <span class="hljs-attr"><span class="hljs-attr">"autoload"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"modules"</span></span>: [<span class="hljs-string"><span class="hljs-string">"modules"</span></span>, <span class="hljs-string"><span class="hljs-string">"*"</span></span>, <span class="hljs-string"><span class="hljs-string">"index.ts|js"</span></span>] <span class="hljs-string"><span class="hljs-string">"bobules"</span></span>: [<span class="hljs-string"><span class="hljs-string">"*"</span></span>, <span class="hljs-string"><span class="hljs-string">"*"</span></span>, <span class="hljs-string"><span class="hljs-string">"bobule.ts|js"</span></span>], } }</code> </pre> <br><h1 id="realizaciya">  Implementasi </h1><br><p>  Kasus-kasus berikut diperoleh: </p><br><ol><li>  <code>f(projectRoot, ['modules', '*', 'index.js|ts'], moduleName = 'default')</code> // muat modul di jalur yang ditentukan oleh pengguna </li><li>  <code>f(projectRoot)</code> // memuat modul dari package.json, nama modul (kunci di bagian autoload) dalam hal ini diteruskan oleh argumen ketiga yang sudah "di bawah tenda". </li></ol><br><p>  Membangun jalur adalah tugas yang sepele, kita hanya pergi melalui array dan memilih semua subdirektori untuk bintang-bintang ketika array berakhir, mengembalikannya dan memuat modul ke dalam array.  Akibatnya, untuk beberapa malam, saya membuat sketsa untuk diri saya sendiri solusi ini dengan cara ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   package.json /   const modulesRawPathsParts = await getModulesRawPaths( projectRoot, modulePath, moduleGroupName ); //         const modulesFilesPathsParts = entries(modulesRawPathsParts).reduce( (acc, [moduleName, moduleRawPath]) =&gt; { const rawFilename = moduleRawPath.pop(); const processedFilenames = processFileExtensions(rawFilename); const pathsWithFilenames = processedFilenames.map( filename =&gt; moduleRawPath.concat(filename) ); return { ...acc, [moduleName]: pathsWithFilenames }; }, {} ); //       const modulesFilesPaths = await Promise.all( entries(modulesFilesPathsParts).map(([moduleName, modulePathParts]) =&gt; Promise.all( modulePathParts.map(modulePathPart =&gt; buildPaths(projectRoot, modulePathPart)) ) .then(paths =&gt; paths.flat().filter(processedPath =&gt; processedPath)) .then(existingPaths =&gt; ({ [moduleName]: existingPaths })), ), ); const processedModulesFilesPaths = arrayToObject(modulesFilesPaths); //    ,       const availableModules = entries(processedModulesFilesPaths).reduce( (acc, [moduleName, modulePaths]) =&gt; (modulePaths.length === 0 ? acc : { ...acc, [moduleName]: modulePaths }), {}, ); //   return Promise.all( entries(availableModules).map(([moduleName, modulePaths]) =&gt; Promise.all(modulePaths.map(moduleLoadPath =&gt; //     : import(moduleLoadPath) )).then(loadedModule =&gt; ({ [moduleName]: loadedModule, })), ), ).then(arrayToObject);</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/u9/9o/or/u99ooru0jkdcq9bclelznor0n9s.png" alt="hanya naskah yang tersisa untuk menipu"></p><br><h1 id="zachem-eto-vsyo">  Kenapa ini semua? </h1><br><p>  Tampak bagi saya bahwa masalah impor dinamis tidak tercakup dengan sangat buruk dan semua perpustakaan seperti itu di npm tidak sedikit diperbarui (atau apakah saya terlihat buruk?), Dan teknologi ini memungkinkan Anda melakukannya dengan baik tanpa registrasi dan SMS.  Saya harap kode sumber proyek dan kasus penggunaannya akan menarik minat Anda untuk digunakan dalam proyek Anda, sedikit mengurangi duplikasi kode dengan mengacaukan yang baru <del>  kruk, sepeda, rangka </del>  niscaya pembantu yang berguna. </p><br><hr><br><p>  Tautan, bukti, terjemahan: </p><br><ul><li>  Modul ECMAScript <br><ul><li>  asli: <a href="https://medium.com/%40nodejs/announcing-core-node-js-support-for-ecmascript-modules-c5d6dc29b663" rel="nofollow">https://medium.com/@nodejs/announcing-core-node-js-support-for-ecmascript-modules-c5d6dc29b663</a> </li><li>  terjemahan: <a href="https://habr.com/ru/post/477168/">https://habr.com/en/post/477168/</a> </li></ul></li><li>  Impor Dinamis: <br><ul><li>  asli: <a href="https://v8.dev/features/dynamic-import" rel="nofollow">https://v8.dev/features/dynamic-import</a> </li><li>  terjemahan gratis: <a href="https://habr.com/ru/post/455200/">https://habr.com/en/post/455200/</a> </li></ul></li></ul><br><p>  Kode sumber untuk kode tanpa cacat ini ada di sini: <br>  <a href="" rel="nofollow">https://github.com/Melodyn/npm-dynamicimport/blob/master/lib/index.js#L93-L120</a> <br>  Dapatkan pengalaman pengguna yang tak ternilai di sini: <br>  <a href="https://www.npmjs.com/package/%40melodyn/dynamicimport" rel="nofollow">https://www.npmjs.com/package/@melodyn/dynamicimport</a> <br>  Kucing ada di sini: <br>  (^ ≗ω≗ ^) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id478974/">https://habr.com/ru/post/id478974/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id478960/index.html">Lampu mini dan sensor kejut | nRF52840</a></li>
<li><a href="../id478962/index.html">Ilya Yakyamsev: Efisiensi tidak bekerja</a></li>
<li><a href="../id478966/index.html">Bagaimana cara bertahan dan menjadi pengembang frontend di dunia modern?</a></li>
<li><a href="../id478968/index.html">Nanoracks dengan SpaceX akan meluncurkan demonstran untuk membuat stasiun orbit puing ruang</a></li>
<li><a href="../id478972/index.html">Pemenang Kontes Platform Miro</a></li>
<li><a href="../id478978/index.html">Azure SDK untuk .NET: Kisah tentang Pencarian Kesalahan yang Sulit</a></li>
<li><a href="../id478980/index.html">Azure SDK untuk .NET: Kisah Pencari Bug yang Sulit</a></li>
<li><a href="../id478982/index.html">Seperti yang saya yakini Topeng Ilona. Dan ketika kita akan berada di bulan lagi</a></li>
<li><a href="../id478984/index.html">TimTam - pijat perkusi generasi baru dengan fungsi pemanasan tip yang unik</a></li>
<li><a href="../id478986/index.html">Yandex meluncurkan suara populer untuk game retro. Finalis Pertempuran Game Retro 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>