<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏩ 🏖️ 👍 Waktu terfragmentasi; sedikit tentang kesamaan sistem terdistribusi dan model memori yang lemah 🌇 👩🏿‍🤝‍👩🏾 👩‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 

 Hari ini kami ingin sekali lagi menyinggung topik eksekusi simultan dan berurutan dalam berbagai program, terutama dalam sistem terd...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Waktu terfragmentasi; sedikit tentang kesamaan sistem terdistribusi dan model memori yang lemah</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/430926/">  Halo semuanya! <br><br>  Hari ini kami ingin sekali lagi menyinggung topik eksekusi simultan dan berurutan dalam berbagai program, terutama dalam sistem terdistribusi.  Kembali pada bulan September, kami menerbitkan artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sinkronisasi adalah mitos</a> " pada topik ini, dan sekarang kami menerbitkan terjemahan studi yang lebih serius, yang, kami harap, akan membantu Anda menavigasi lebih baik dengan sistem terdistribusi. <br><a name="habracut"></a><br><blockquote>  Hanya ada satu masalah nyata dalam ilmu komputer: untuk mengakui bahwa kesalahan validasi cache tidak disebutkan dengan benar.  Ini hanya kesalahan unit yang terkait dengan penggunaan waktu. </blockquote> - Penulis tidak dikenal <br><br>  Waktu adalah hal yang aneh. <br><br>  Waktu ini sangat aneh, karena kami benar-benar ingin percaya bahwa itu sepenuhnya efisien.  Tampaknya bagi kita bahwa peristiwa apa pun pada pukul 15.00 terjadi (seperti yang akan kita katakan) sebelum peristiwa apa pun pada pukul 16.00 - tanpa pengecualian, argumen, atau kompromi. <br><br>  Namun, ilmu komputer tahu banyak contoh ketika perlu untuk mendekati persyaratan ini tidak begitu ketat.  Ini memanifestasikan dirinya di tingkat prosesor, kompiler, node jaringan.  Berkali-kali dalam perhitungan, pada tingkat tumpukan yang berbeda, kita menemukan diri kita dalam situasi di mana kita dihadapkan dengan dua peristiwa, dan kita tidak tahu dalam urutan apa mereka terjadi.  Waktu jelas tidak total;  dia terfragmentasi. <br><br>  Mengapa  Faktanya adalah bahwa kita tidak mengetahui hal ini, karena tingkat abstraksi yang kita miliki tidak memberikan jawaban untuk pertanyaan ini.  Apakah itu kebetulan atau tidak, abstraksi komputasi kami tidak memberikan jaminan mengenai prosedur ini.  Kebebasan untuk menyusun ulang acara sering kali memungkinkan Anda membuat sistem yang jauh lebih produktif dan terjangkau. <br><br>  Prosesor mungkin memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">model pemesanan memori</a> ;  itu mencerminkan jaminan apa yang prosesor tidak ingin memberi Anda jaminan pada tahap perakitan - misalnya, instruksi mana yang dieksekusi sebelumnya dan yang kemudian.  Prosesor memutuskan dengan tepat bagaimana menyampaikan instruksi dan mengeksekusi mereka keluar dari urutan - yaitu, menggunakan chip lebih efisien daripada yang saya kira. <br><br>  Suatu bahasa mungkin memiliki <i>model pencocokan memori</i> ("model memori" singkatnya);  itu mencerminkan jaminan apa yang tidak diberikan oleh bahasa itu saat membuat perakitan, misalnya, ketika mendistribusikan instruksi di banyak utas.  Penataan ulang seperti itu secara inheren melekat dalam model perangkat keras memori dan untuk sebagian besar menjelaskan mengapa konsep waktu "lemah" disediakan dalam kompiler.  Hal ini dalam kerangka model memori yang diterapkan dalam bahasa yang Anda program ketika Anda menulis kode non-blocking. <br><br>  Contoh terkenal dari model memori yang diimplementasikan pada tingkat bahasa adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">model memori yang kuat dan lemah</a> dalam standar C ++ 11.  Secara default, C ++ menyediakan operasi atom dengan sinkronisasi, tetapi juga dapat melemahkan model akses memori untuk meningkatkan kinerja.  Perilaku yang disediakan dengan cara ini dimaksudkan untuk berfungsi sebagai abstraksi atas arsitektur prosesor utama yang digunakan saat ini (x86, POWER, dan ARM). <br><br>  Akhirnya, sistem terdistribusi mungkin memiliki model konsistensi sendiri;  itu mencerminkan jaminan apa yang sistem tidak akan berikan kepada Anda mengenai urutan kejadian pada klien dan replika di jaringan komputer global.  Perekam ulang yang berhubungan langsung dengan latensi komunikasi atau kurangnya sinkronisasi terutama menjelaskan mengapa dalam sistem terdistribusi Anda tidak dapat melakukannya tanpa model waktu yang lemah tersebut.  Model konsistensi inilah yang Anda program ketika Anda menulis aplikasi terdistribusi. <br><br>  Dalam praktiknya, ada banyak sekali model konsistensi yang dapat Anda gunakan saat memprogram sistem terdistribusi.  Dalam semua situasi seperti itu, model-model ini menggambarkan perilaku (yang diinginkan) dari sistem yang diamati dari luar sistem itu.  Jika saya - klien tertentu atau aliran tertentu - menulis nilai, kemudian segera membacanya, apakah dijamin bahwa saya pasti akan melihat catatan yang tidak lebih lama dari milik saya?  Jika waktu tidak terfragmentasi, jika kita selalu memiliki ide yang jelas dalam urutan apa operasi dalam sistem kita berlangsung - tentu saja, jawaban untuk pertanyaan ini adalah di afirmatif.  Akan aneh untuk bertanya seperti itu sama sekali. <br><br>  Tetapi waktu itu terpisah-pisah - karena itu, perlu untuk mengajukan pertanyaan seperti itu. <br><br><h4>  Model Konsistensi - Maksud saya, model memori </h4><br>  Berbicara tentang keteraturan yang terfragmentasi seperti ini seringkali sulit dan selalu tidak menyenangkan.  Kami ingin memulai dari fakta bahwa di semua tingkat tumpukan, waktu selalu mutlak absolut - baik dengan transaksi ACID atau operasi / kunci atom.  Semakin ketat jaminan, semakin mudah diprogram dengan mereka! <br><br>  Tapi kita semua berusaha untuk kecepatan.  Apakah itu tentang sistem terdistribusi di mana pengorbanan konsistensi yang ketat demi aksesibilitas harus dikorbankan, atau tentang pemrograman non-blocking, di mana model memori yang lemah digunakan untuk menghindari biaya sinkronisasi, biasanya disarankan bagi seorang programmer yang bekerja dengan tingkat tumpukan apa saja untuk masuk ke argumen kompleks ini. . <br><br>  Konsistensi model memori bersama dan konsistensi model memori terdistribusi keduanya <i>abstrak</i> .  Mereka menggambarkan pemrogram bekerja dengan sistem, antarmuka sistem ini.  Mereka memungkinkan untuk memahami tipe perilaku mana yang sesuai dengan model memori yang lemah, mengingat sekarang bahwa sifat umum dari urutan peristiwa dalam sistem, yang kita terima begitu saja, tidak lagi bertindak di dalamnya.  Tampaknya kedua model memori ini serupa, namun kedua komunitas telah mengembangkan wacana mereka sendiri untuk diskusi.  Nilai yang digunakan di dalamnya berbeda, meskipun tumpang tindih. <br><br>  Kita sudah membayangkan betapa bingungnya hal ini.  Apa yang harus dilakukan <br><br><h4>  Deskripsi waktu sebagai entitas, menyiratkan suatu tempat dari dua hingga delapan jenis urutan parsial </h4><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bukunya 2014,</a> Sebastian Burkhardt berusaha untuk memberikan deskripsi lengkap tentang banyak pilihan untuk model konsistensi.  Dengan karakteristik ini, bersama dengan struktur matematika lainnya, dua varian dari urutan logis peristiwa digunakan: "visibilitas" dan "arbitrasi", yang sebelumnya juga disebutkan dalam karya-karya lain Burkhardt et al, lihat, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> tentang menunjuk dan memeriksa tipe data yang direplikasi (2014). <br><br>  "Visibilitas" adalah urutan parsial yang melekat dalam pengondisian potensial.  Hal ini memungkinkan Anda untuk melacak peristiwa mana (mungkin dalam replika lain) yang terlihat dengan peristiwa lainnya.  Tidak ada persyaratan untuk visibilitas selain asiklisitas;  peristiwa dalam suatu objek dapat terlihat oleh peristiwa di objek lain, dan operasi membaca atau menulis suatu peristiwa tidak mempengaruhi visibilitasnya untuk peristiwa lain. <br><br>  "Arbitrase" adalah urutan umum yang memungkinkan Anda melacak bagaimana sistem terdistribusi di mana situasi pilihan muncul akan menilai peristiwa mana yang terjadi lebih awal dan yang kemudian. <br><br>  Karena model konsistensi terdistribusi mirip dengan model memori, ternyata fenomena visibilitas dan keacakan seperti itu juga dapat berguna ketika membahas model memori.  Secara khusus, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam lampiran artikelnya 2014,</a> Burkhardt menunjukkan "seberapa dekat" model memori lemah dari C ++ 11 dengan konsistensi kausal berbasis objek, tetapi dengan beberapa penyimpangan yang menarik.  Ini akan dibahas di sisa posting. <br><br>  Untuk mulai dengan, mari kita menyempurnakan visibilitas dan keacakan, dengan mempertimbangkan "membaca" dan "urutan perubahan".  Ketika "membaca", visibilitas antara dua objek akan diperhitungkan hanya dalam situasi di mana membaca dan menulis menyentuh objek yang sama, dan ketika membaca hanya satu catatan (atau lebih dari satu) dapat terlihat. <br>  Ini sesuai dengan situasi di mana prosesor dengan memori bersama pada waktu tertentu dapat merekam informasi hanya dalam satu sel memori untuk objek tertentu, bahkan jika utas yang berbeda dapat mengaksesnya pada momen sebab dan akibat yang berbeda (di sisi lain, dalam sistem terdistribusi, logis suatu objek dapat direkam segera dalam banyak replika terpisah). <br><br>  "Modifikasi pesanan" sesuai dengan tahap yang sama ketika mengkonkretkan kesewenang-wenangan, itu objektif dan hanya memungkinkan rekaman.  Sekali lagi, spesialisasi ini didasarkan pada kenyataan bahwa, dengan spesifikasi memori yang lemah, jaminan kategoris hanya diberikan pada tingkat satu objek. <br><br>  Selanjutnya, mari kita bahas aksioma konsistensi yang dirumuskan oleh Burkhardt et al. Dan lihat bagaimana mereka berlaku untuk model memori yang lemah.  Harap dicatat: meskipun ada kata "aksioma", ini hanyalah properti yang mungkin atau mungkin tidak disediakan dalam berbagai model memori.  Artikel Burkhardt berfokus pada sifat-sifat yang menentukan kausalitas objek-silang. <br><br><h4>  Koherensi akhirnya </h4><br>  Untuk peristiwa tertentu, tidak mungkin ada banyak peristiwa tanpa batas yang tidak dapat melihatnya.  Artinya, setiap peristiwa <i>pada akhirnya</i> dapat dilihat oleh sistem. <br><br>  Secara logis membangun kondisi seperti itu dalam sistem dengan model memori yang lemah harus agak lebih sulit: harus diperdebatkan bahwa untuk <i>catatan</i> tertentu tidak boleh ada jumlah tak terbatas operasi baca yang tidak akan membaca catatan ini atau catatan sebelumnya (dalam urutan modifikasi). <br><br>  Dalam spesifikasi C ++ 11, kepatuhan terhadap aksioma ini tidak dijamin, meskipun dalam praktiknya sulit untuk menemukan contoh tandingan. <br><br><h4>  Konsistensi Ethereal </h4><br>  Saat melacak "kondisionalitas potensial" pada tingkat arus / operasi klien dan terkait dengan visibilitas / keterbacaan, Anda perlu memahami bahwa tidak ada waktu pengembalian.  Itu sebabnya diperlukan bahwa penutupan ketika memesan aliran menyiratkan membaca asiklik.  Sebagai aturan, tidak ada keraguan bahwa properti ini akan diamati dalam sistem terdistribusi, namun properti inilah yang tidak memungkinkan visibilitas pengguna dalam beberapa versi spekulatif jika sistem memiliki model memori yang lemah. <br><br>  Burkhardt et al. Menunjukkan bahwa aksioma ini "tidak dikonfirmasi" dalam spesifikasi C ++ 11, dan tidak jelas "tidak memvalidasi" apakah "siklus yang memuaskan" dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diamati dalam praktek</a> . <br><br><h4>  Aksioma Kondisionalitas </h4><br>  Untuk menentukan secara pasti apa yang terkait dengan fenomena kondisionalitas di bawah model memori yang lemah, kita harus secara tepat menentukan peristiwa mana yang dapat mempengaruhi hasil peristiwa lainnya.  Untuk memulai, pertimbangkan aksioma sebab-akibat standar kami: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jaminan sesi</a> .  Ini adalah empat kualitas yang saling terkait yang mencerminkan sifat koherensi operasi baca dan tulis yang terjadi dalam aliran yang berbeda, apalagi, mereka harus ditentukan pada tingkat setiap objek (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Burkhardt et al</a> ., <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gbr. 23</a> ). <br><br><ul><li>  RYW (Baca catatan Anda): operasi baca setelah operasi tulis dilakukan dalam sel yang sama, dalam aliran / replika / sesi yang sama, itu harus membaca data yang tidak kalah relevan dari catatan.  Varian dari properti ini untuk sistem terdistribusi ditentukan secara khusus dalam hal visibilitas, sedangkan varian untuk model memori yang lemah harus didasarkan pada urutan membaca dan urutan perubahan. </li><li>  MR (bacaan monolitik): bacaan selanjutnya (dalam aliran yang sama, dalam sel yang sama) juga harus melihat data yang tidak kurang relevan di masa depan. </li><li>  WFR (baca pertama, lalu tulis): jika menulis mengikuti pembacaan di dalam aliran, dalam sel yang sama, maka dalam urutan perubahan harus lebih lambat dari operasi baca. </li><li>  MW (Catatan Monolitik): catatan yang lebih baru (di dalam aliran, dalam sel yang sama) harus masuk kemudian dalam urutan modifikasi. </li></ul><br>  Versi asli WFR dan MW ada dalam dua versi, untuk keacakan dan visibilitas;  tetapi ini hanya penting ketika bekerja dengan sel data yang lebih kompleks daripada dengan register untuk integer. <br><br>  Sifat-sifat ini mencerminkan pengertian kondisionalitas, konsisten dengan akal sehat kita;  Namun, mereka melewatkan yang paling menarik.  Khususnya, ketika menganalisis dalam model memori yang lemah, fenomena kondisionalitas seperti itu dibatasi oleh batas-batas aliran / replika / sesi dan sel / objek spesifik tempat entri dibuat: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam sebuah artikel oleh Burkhardt et al</a> .  dalam hal ini dikatakan tentang "visibilitas kondisional objek-oleh-kondisional" dan "kesewenang-wenangan objek-demi-kondisional", juga lihat gambar.  23. Fenomena ini tidak sepenuhnya membatasi perilaku sistem ketika aliran yang berbeda menulis informasi ke sel yang berbeda. <br><br>  Kemudian aksioma pengkondisian objek-silang menggambarkan efek hubungan sebab-akibat pada level berbagai objek / sel memori. <br><br><ul><li>  COCV (Cross-Object Conditional Visibility): kasus yang sama dengan RYW, tetapi tanpa syarat pembacaan akhir harus dilakukan semua dalam utas / replika / sesi yang sama.  Pembacaan dari suatu objek yang secara obyektif lebih lambat dari catatan dalam objek ini harus mengambil data yang tidak kurang relevan dari yang dimasukkan selama perekaman. </li></ul><br>  Spesifikasi C ++ 11 mencerminkan properti ini.  Harap dicatat: mereka didefinisikan sedemikian rupa sehingga pembatasan pencatatan visibilitas dan kesewenang-wenangan dari urutan modifikasi tidak terlalu mencerminkan definisi ini. <br><br>  Tetapi ini tidak berlaku untuk properti yang terakhir. <br><br><ul><li>  COCA (Cross-Object Conditional Arbitrary): mirip dengan catatan monolitik, tetapi berlaku untuk aliran yang berbeda, mirip dengan COCV - itu adalah RYW untuk aliran yang berbeda.  Namun, karena urutan modifikasi hanya mempengaruhi rekaman dalam satu objek, formulasi untuk model memori yang lemah memungkinkan sistem untuk memiliki distribusi yang tidak konsisten dari peristiwa perekaman di objek yang berbeda, dan catatan mungkin tidak sesuai dengan bacaan atau urutan dalam aliran. </li></ul><br>  Secara khusus, COCA dalam model memori yang lemah adalah properti yang jauh lebih lemah.  Itulah sebabnya dengan model memori yang lemah, kode berikut dapat mengembalikan <code>{x ≡ 0, y ≡ 0}</code> . <br><br> <code>Thread A: y := 0; x := 1; return x <br> Thread B: x := 0; y := 1; return y</code> <br> <br>  Urutan dalam setiap aliran mungkin tidak konsisten dengan urutan objek-oleh-pesanan dan urutan modifikasi.  Harap dicatat: dengan RYW tidak ada <code>x := 0 → x := 1</code> dalam urutan modifikasi dan untuk <code>y</code> sama;  dengan demikian, urutan modifikasi harus mengandung <code>x := 1 → x := 0</code> dan <code>y := 1 → y := 0</code> .  Jadi, urutan modifikasi jelas membentuk siklus dalam urutan arus. <br>  Perulangan semacam itu diizinkan dalam COCA dengan model memori yang lemah.  Bukan berarti urutan aliran / membaca bertentangan dengan urutan modifikasi, tetapi bahwa setiap aliran melihat riwayat catatan yang konsisten.  Kisah-kisah ini konsisten dengan kisah-kisah aliran lain hanya jika kita secara objektif membatasi ruang lingkup penerapannya. <br><br><h4>  Apa artinya semua ini? </h4><br>  Waktu terfragmentasi. <br><br>  Meskipun bagi kami tampaknya waktu mengalir dengan tertib, mempelajari sistem terdistribusi dan model memori yang lemah jelas menunjukkan kepada Anda bahwa ini tidak benar.  Itulah sebabnya dalam kedua situasi ini, perkiraan standar kami yang berlebihan, yang sesuai dengan waktu total, membatasi kinerja - yang tidak dapat kami mampu. <br>  Kemudian, mengakui bahwa waktu benar-benar terfragmentasi, kami menemukan banyak perbedaan kecil namun penting antara varietas keberpihakan seperti itu.  Bahkan dua bidang yang disebutkan di atas, yang tampak sangat mirip pada pandangan pertama, dalam banyak nuansa halus memungkinkan untuk membedakan jenis peristiwa tertentu yang dianggap saling mempengaruhi. <br><br>  Hal ini diperlukan untuk memahami secara lebih rinci rincian teknis dari berbagai properti yang sudah ada setelah seseorang dapat mengekspresikan properti dari satu bidang dalam bahasa yang lain. <br><br>  Waktu terfragmentasi.  Mungkin kita hanya perlu membiasakan diri dengannya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430926/">https://habr.com/ru/post/id430926/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430914/index.html">Analisis harga pasar gelap untuk data pribadi dan menerobos</a></li>
<li><a href="../id430916/index.html">Detektor Karbon Dioksida MT8057S. TINJAUAN DENGAN PARTISIPASI</a></li>
<li><a href="../id430918/index.html">Tentang Flutter, secara singkat: Dasar-dasar</a></li>
<li><a href="../id430922/index.html">Contoh perhitungan untuk switchboard</a></li>
<li><a href="../id430924/index.html">Ada pemrograman</a></li>
<li><a href="../id430928/index.html">Hanya tentang "rumah pintar": cara membuat lampu latar "pintar"</a></li>
<li><a href="../id430930/index.html">Tentang grafik 3D dengan kata-kata sederhana</a></li>
<li><a href="../id430932/index.html">Peretas mencuri lebih dari 21 juta rubel dari bank Rusia</a></li>
<li><a href="../id430934/index.html">Asterisk dialplan extension mask generator</a></li>
<li><a href="../id430936/index.html">DEFCON 21. Konferensi DNS dapat berbahaya bagi kesehatan Anda. Bagian 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>