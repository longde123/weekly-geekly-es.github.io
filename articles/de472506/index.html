<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✳️ 👩🏾‍🍳 🧗🏼 Wo ist der Fehler, Billy? Wir brauchen einen Fehler ... 🎅🏻 🚒 😵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einiger Zeit veröffentlichte mein Kollege einen Artikel über die Fehlerbehandlung in Java / Kotlin. Und es wurde für mich interessant, welche Meth...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wo ist der Fehler, Billy? Wir brauchen einen Fehler ...</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/472506/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/hk/ek/aa/hkekaakde8vvcz8i9sulw6rakww.png"></div><br>  Vor einiger Zeit veröffentlichte mein Kollege <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Artikel</a> über die Fehlerbehandlung in Java / Kotlin.  Und es wurde für mich interessant, welche Methoden der Fehlerübertragung in der Programmierung im Allgemeinen existieren.  Wenn Sie auch interessiert sind, dann ist unter dem Schnitt das Ergebnis der Forschung.  Höchstwahrscheinlich wurden einige exotische Methoden weggelassen, aber es gibt nur eine Hoffnung auf Kommentare, die manchmal interessanter und nützlicher für den Habré-Artikel sind.  :) <br><a name="habracut"></a><br>  In der Geschichte der Programmiersprachen wurden nicht viele Wege erfunden, um einen Fehler zu vermitteln.  Wenn wir uns vollständig lösen, gibt es nur drei davon: eine direkte Rückkehr von einer Funktion, eine Übertragung der Kontrolle und das Festlegen des Zustands.  Alles andere ist bis zu dem einen oder anderen Grad eine Mischung dieser Ansätze.  Im Folgenden habe ich versucht, die Hauptvertreter dieser drei Arten zu sammeln und zu beschreiben. <br><br>  Haftungsausschluss: Zur Vereinfachung und Vereinfachung der Wahrnehmung für jeden isolierten ausführbaren Code, der einen Fehler erzeugt, verwende ich das Wort "Funktion" und für alle nicht primitiven (Ganzzahl-, Zeichenfolgen-, Booleschen usw.) Entitäten - "Struktur". <br><br><h3>  Direkte Rückgabe </h3><br>  Die direkte Rückgabe ist einfach.  Dies ist zwar wahrscheinlich die am häufigsten verwendete Methode, aber es gibt viele Möglichkeiten.  Die Verarbeitungsmethode vereint sie alle und vergleicht den Rückgabewert mit vordefinierten Werten. <br><br><ol><li>  Laufstatus zurückgeben.  Die banalste Option ist TRUE (wenn sie normal ausgeführt wurde) oder FALSE (wenn ein Fehler aufgetreten ist). </li><li>  Geben Sie im Erfolgsfall den richtigen und im Fehlerfall den falschen Wert zurück. <br><blockquote>  C / c ++ <br>  Die Funktion strchr () gibt einen Zeiger auf das erste Vorkommen des Zeichens ch in der Zeichenfolge zurück, auf die str zeigt.  Wenn ch nicht gefunden wird, wird NULL zurückgegeben. </blockquote><br>  Sehr oft werden die Ansätze 1 und 2 in Verbindung mit der Einstellung des Zustands verwendet. <br></li><li>  Fehlercode zurückgeben.  Wenn wir nicht nur wissen wollen, dass die Ausführung falsch beendet wurde, sondern auch verstehen möchten, wo der Fehler in der Funktion aufgetreten ist.  Wenn die Funktion fehlerfrei abgeschlossen wurde, wird normalerweise der Code 0 zurückgegeben. Im Fehlerfall wird der Code verwendet, um eine bestimmte Stelle im Hauptteil der Funktion zu bestimmen, an der ein Fehler aufgetreten ist.  Dies ist jedoch keine eiserne Regel. Schauen Sie sich beispielsweise HTTP mit seinen 200 an. </li><li>  Rückgabe des Fehlercodes in einem ungültigen Wertebereich.  Normalerweise sollte eine Funktion normalerweise eine positive Ganzzahl und im Fehlerfall ihren Code mit einem Minuszeichen zurückgeben. <br><br><pre><code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countElements</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(param)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isArray(param)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-10</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!isInitialized(param)){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-20</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>); } }</code> </pre> <br></li><li>  Geben Sie verschiedene Typen für positive und negative Ergebnisse zurück.  Zum Beispiel nominell - eine Zeichenfolge, aber nicht nominell - eine Zahl oder Klasse <b>Erfolg</b> und Klasse <b>Fehler</b> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserProfileResult</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Success</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> userProfile: UserProfileDTO) : UserProfileResult() <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Error</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> message: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cause: Exception? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>) : UserProfileResult() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> avatarUrl = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = client.requestUserProfile(userId)) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> UserProfileResult.Success -&gt; result.userProfile.avatarUrl <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> UserProfileResult.Error -&gt; <span class="hljs-string"><span class="hljs-string">"http://domain.com/defaultAvatar.png"</span></span> }</code> </pre> <br>  Sie können sich auch an <b>Entweder</b> aus der Welt der funktionalen Programmierung erinnern.  Obwohl hier kann man streiten. <br></li><li>  Rückgabe einer Struktur, die sowohl das Ergebnis selbst als auch den Fehler enthält. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($somethingWrong === <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">"result"</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-string"><span class="hljs-string">"error"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"Alarm!!!"</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">"result"</span></span> =&gt; $result, <span class="hljs-string"><span class="hljs-string">"error"</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>]; } ... }</code> </pre> <br></li><li>  Mehrere Werte zurückgeben.  Anfangs war ich geneigt, diese Methode nicht von der vorherigen zu trennen, aber am Ende habe ich beschlossen, sie in einen separaten Absatz aufzunehmen.  Diese Option ist ziemlich selten, da sie ausschließlich in Sprachen verwendet werden kann, in denen Sie mehrere Werte von einer Funktion zurückgeben können, und es gibt nicht viele davon.  Das auffälligste, aber nicht das einzige Beispiel ist die <b>Go-</b> Sprache. <br><br><pre> <code class="go hljs">f, err := Sqrt(<span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(err) }</code> </pre> </li></ol><br><h3>  Statuseinstellung </h3><br>  Die älteste und hardcore Version, die bis heute nicht an Relevanz verloren hat.  Es besteht darin, dass die Funktion nichts zurückgibt und im Falle eines Fehlers ihren Wert (in irgendeiner Form) in eine separate Entität schreibt, unabhängig davon, ob es sich um ein Prozessorregister, eine globale Variable oder ein privates Klassenfeld handelt.  Um diese Art von Fehler zu behandeln, müssen Sie den Wert unabhängig von der richtigen Stelle extrahieren und überprüfen. <br><br><ol><li>  Festlegen des "globalen" Status.  Ich habe es in Anführungszeichen gesetzt, weil wir meistens über Globalität in einem bestimmten Umfang sprechen. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ls /unknown/path 2&gt;/dev/null # echo $? 1</span></span></code> </pre> <br></li><li>  Festlegen Ihres eigenen Status.  Wenn wir eine Struktur haben, die eine Funktion bereitstellt.  Die Funktion legt den Status für diese Struktur fest, und der Fehler wird bereits entweder direkt oder mithilfe einer anderen speziellen Funktion aus der Struktur extrahiert. <br><br><pre> <code class="php hljs">$mysqli = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> mysqli(<span class="hljs-string"><span class="hljs-string">"localhost"</span></span>, <span class="hljs-string"><span class="hljs-string">"my_user"</span></span>, <span class="hljs-string"><span class="hljs-string">"my_password"</span></span>, <span class="hljs-string"><span class="hljs-string">"world"</span></span>); $result = $mysqli-&gt;query(<span class="hljs-string"><span class="hljs-string">"SET a=1"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($mysqli-&gt;errno) { printf(<span class="hljs-string"><span class="hljs-string">" : %d\n"</span></span>, $mysqli-&gt;errno); }</code> </pre> <br></li><li>  Festlegen des Status des zurückgegebenen Objekts.  Stimmt stark mit Absatz 6 überein.  aus dem vorherigen Abschnitt.  Im Gegensatz zum vorherigen Absatz wird eine Statusprüfung für die zurückgegebene Struktur durchgeführt und nicht für die Struktur, die die Funktion bereitstellt.  Als offensichtliches Beispiel arbeiten das HTTP-Protokoll und unzählige Bibliotheken in einer Vielzahl von Sprachen damit. <br><br><pre> <code class="java hljs">Response response = client.newCall(<span class="hljs-string"><span class="hljs-string">"https://www.google.com"</span></span>).execute(); Integer errorCode = response.getCode();</code> </pre> <br></li></ol><br><h3>  Kontrolle übertragen </h3><br>  Und jetzt kommen wir zum modischsten Paradigma.  Ausnahmen, Rückrufe, globale Fehlerbehandlungsroutinen - all dies.  Was sie alle verbindet, ist, dass im Fehlerfall die Steuerung an einen vorgegebenen Handler übertragen wird und nicht an den Code, der die Funktion aufgerufen hat. <br><br><ol><li>  Ausnahmen  Jeder weiß werfen / versuchen / fangen.  Wenn eine Ausnahme ausgelöst wird, bildet die Funktion eine Struktur, die den Fehler beschreibt und meistens verschiedene nützliche Metadaten enthält, die die Diagnose des Problems erleichtern (z. B. den Aufrufstapel).  Danach wird diese Struktur an einen speziellen Mechanismus übergeben, der entlang des Aufrufstapels zum ersten try-Block "zurückrollt", der mit catch verknüpft ist und Ausnahmen dieses Typs verarbeiten kann.  Diese Methode ist insofern gut, als die gesamte Logik zum Auslösen einer Ausnahme von der Laufzeit selbst implementiert wird.  Das gleiche ist schlecht, da Gemeinkosten (lasst uns nur ohne holivarov :)). </li><li>  Globale Fehlerbehandlungsroutinen.  Nicht der üblichste Weg, aber es tut.  Ich weiß nicht einmal, was ich hier sagen soll.  Vielleicht ist es erwähnenswert, dass hier auch die Mechanismen von Browsern zugeschrieben werden können: Wenn der Code, der vom Hauptstrom abweicht, die darin eintreffenden Ereignisse überwacht. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myErrorHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($errno, $errstr, $errfile, $errline)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;b&gt;Custom error:&lt;/b&gt; [$errno] $errstr&lt;br&gt;"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">" Error on line $errline in $errfile&lt;br&gt;"</span></span>; } set_error_handler(<span class="hljs-string"><span class="hljs-string">"myErrorHandler"</span></span>);</code> </pre> <br></li><li>  Rückrufe.  Sie werden von Entwicklern für Android, JavaScript und Entschuldigern für reaktive Programmierung sehr geliebt.  Das Wesentliche ist einfach: Zusätzlich zu den verarbeiteten Daten werden Handlerfunktionen auf die Funktion übertragen.  Im Fehlerfall ruft die Hauptfunktion den entsprechenden Handler auf und leitet den Fehler an ihn weiter. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> observer = Rx.Observer.create( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`onNext: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${x}</span></span></span><span class="hljs-string">`</span></span>), e =&gt; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`onError: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${e}</span></span></span><span class="hljs-string">`</span></span>), () =&gt; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'onCompleted'</span></span>));</code> </pre> <br></li></ol><br>  Es scheint nichts vergessen zu haben. <br><br>  Und eine lustige Tatsache.  Der wahrscheinlich originellste Weg, einen Fehler zurückzugeben, Ausnahmen gleichzeitig zu kombinieren, den Status festzulegen und mehrere Werte zurückzugeben, traf ich in Informix SPL (ich schreibe aus dem Speicher): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> some_proc(...) <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>; … ON EXCEPTION <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> SQLERR, ISAMERR <span class="hljs-keyword"><span class="hljs-keyword">RETURN</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, SQLERR, ISAMERR, USRERR; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXCEPTION</span></span>; LET USRERR = 1; <span class="hljs-comment"><span class="hljs-comment">-- do Something That May Raise Exception LET USRERR = 2; -- do Something Other That May Raise Exception … RETURN result, 0, 0, 0; END PROCEDURE</span></span></code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472506/">https://habr.com/ru/post/de472506/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472490/index.html">Wie ich mithilfe der Verarbeitung natürlicher Sprache nach einem Schönheitsstandard gesucht habe (und ihn nicht gefunden habe)</a></li>
<li><a href="../de472492/index.html">Analyse des ROOT-Codes, Scientific Data Analysis Framework</a></li>
<li><a href="../de472496/index.html">Erstellen eines Sammelalbum-Layouts in CSS Grid</a></li>
<li><a href="../de472502/index.html">SOC ist Menschen: der harte Alltag des Service Managers des Zentrums zur Überwachung und Reaktion auf Cyber-Angriffe</a></li>
<li><a href="../de472504/index.html">PHP Microservice Framework Swoft: Verwenden Sie die Datenbank Teil 1</a></li>
<li><a href="../de472508/index.html">Flash-Zuverlässigkeit: erwartet und unerwartet. Teil 3. XIV. Konferenz der USENIX Association. Dateispeichertechnologien</a></li>
<li><a href="../de472514/index.html">Von der Suche nach einer Idee bis zur fertigen Bewerbung</a></li>
<li><a href="../de472516/index.html">Yandex.Translator für Linux unter Python + GTK3</a></li>
<li><a href="../de472520/index.html">Trainingskits aus dem Video - schnell und effizient</a></li>
<li><a href="../de472522/index.html">Das Buch "Kontinuierliche Weiterentwicklung der API. Die richtigen Entscheidungen in einer sich verändernden technologischen Landschaft “</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>