<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚚 🚿 👨🏻‍🏫 .NET multithreading: ketika kinerja kurang 👇🏿 💂🏼 🚤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Platform .NET menyediakan banyak primitif sinkronisasi pre-built dan koleksi thread-safe. Jika Anda perlu menerapkan, misalnya, cache thread-safe atau...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET multithreading: ketika kinerja kurang</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/468611/"><img src="https://habrastorage.org/webt/rn/su/tj/rnsutjjvg7sllluahknu8brlnbc.jpeg"><br><br>  Platform .NET menyediakan banyak primitif sinkronisasi pre-built dan koleksi thread-safe.  Jika Anda perlu menerapkan, misalnya, cache thread-safe atau antrian permintaan ketika mengembangkan aplikasi, solusi siap pakai ini biasanya digunakan, kadang-kadang beberapa sekaligus.  Dalam beberapa kasus, ini menyebabkan masalah kinerja: menunggu lama pada kunci, konsumsi memori yang berlebihan dan pengumpulan sampah yang lama. <br><br>  Masalah-masalah ini dapat diselesaikan jika kita mempertimbangkan bahwa solusi standar dibuat cukup umum - mereka dapat memiliki overhead dalam skenario kita yang berlebihan.  Karenanya, Anda dapat menulis, misalnya, koleksi aman-aman Anda sendiri untuk kasus tertentu. <br><br>  Di bawah cutscene adalah video dan transkrip laporan saya dari konferensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DotNext</a> , di mana saya menganalisis beberapa contoh ketika menggunakan alat dari perpustakaan .NET standar (Task.Delay, SemaphoreSlim, ConcurrentDictionary) menyebabkan penurunan kinerja, dan saya mengusulkan solusi yang dirancang untuk tugas-tugas tertentu dan tanpa kekurangan ini. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-tNeYjRNJtY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Pada saat laporan itu dia bekerja di sirkuit.  Kontur mengembangkan berbagai aplikasi untuk bisnis, dan tim saya bekerja dalam berurusan dengan infrastruktur dan mengembangkan berbagai layanan dukungan dan perpustakaan yang membantu pengembang di tim lain menciptakan layanan produk. <br><br>  Tim Infrastruktur membangun gudang data, sistem hosting aplikasi untuk Windows dan berbagai perpustakaan untuk pengembangan layanan-layanan microser.  Aplikasi kami didasarkan pada arsitektur layanan mikro - semua layanan berinteraksi satu sama lain melalui jaringan, dan, tentu saja, mereka menggunakan cukup banyak kode asinkron dan multi-berulir.  Beberapa aplikasi ini cukup kritis kinerja, mereka harus dapat menangani banyak permintaan. <br><br>  Apa yang akan kita bicarakan hari ini? <br><br><ul><li>  Multithreading dan asynchrony di .NET; </li><li>  Mengisi primitif dan koleksi sinkronisasi; </li><li>  Apa yang harus dilakukan jika pendekatan standar tidak dapat mengatasi beban? </li></ul><br>  Mari kita menganalisis beberapa fitur bekerja dengan kode multithreaded dan asynchronous di .NET.  Mari kita lihat beberapa sinkronisasi primitif dan koleksi bersamaan, lihat bagaimana mereka diatur di dalamnya.  Kami akan membahas apa yang harus dilakukan jika tidak ada kinerja yang cukup, jika kelas standar tidak dapat mengatasi beban, dan apakah sesuatu dapat dilakukan dalam situasi ini. <br><br>  Saya akan menceritakan empat kisah yang terjadi di lokasi produksi kami. <br><br><h2>  Riwayat 1: Tugas.Hapus &amp; TimerQueue </h2><br>  Kisah ini sudah cukup terkenal, termasuk tentang hal itu di DotNext sebelumnya.  Namun, ada sekuel yang cukup menarik, jadi saya menambahkannya.  Jadi apa gunanya? <br><br><h3>  1.1 Polling dan polling panjang </h3><br>  Server melakukan operasi lama, klien menunggu untuk mereka. <br>  <b>Polling:</b> klien secara berkala bertanya kepada server tentang hasilnya. <br>  <b>Polling panjang:</b> klien mengirimkan permintaan dengan batas waktu yang lama, dan server merespons ketika operasi selesai. <br><br>  Keuntungan: <br><br><ul><li>  Lebih sedikit lalu lintas </li><li>  Klien belajar tentang hasilnya lebih cepat </li></ul><br>  Bayangkan bahwa kita memiliki server yang dapat menangani beberapa permintaan panjang, misalnya, aplikasi yang mengubah file XML ke PDF, dan ada klien yang menjalankan tugas ini untuk diproses dan ingin menunggu hasilnya secara sinkron.  Bagaimana harapan seperti itu dapat terwujud? <br><br>  Cara pertama adalah <b>polling</b> .  Klien memulai tugas di server, kemudian secara berkala memeriksa status tugas ini, sementara server mengembalikan status tugas ("selesai" / "tidak selesai" / "selesai dengan kesalahan").  Klien secara berkala mengirimkan permintaan sampai hasilnya muncul. <br><br>  Cara kedua adalah <b>polling panjang</b> .  Perbedaannya di sini adalah bahwa klien mengirim permintaan dengan waktu tunggu yang lama.  Server, menerima permintaan seperti itu, tidak akan segera melaporkan bahwa tugas tersebut belum selesai, tetapi akan mencoba menunggu beberapa saat hingga hasilnya muncul. <br>  Jadi apa keuntungan dari pemungutan suara yang lama dibandingkan pemungutan suara biasa?  Pertama, lebih sedikit lalu lintas yang dihasilkan.  Kami membuat lebih sedikit permintaan jaringan - lebih sedikit lalu lintas yang dikejar di seluruh jaringan.  Selain itu, klien akan dapat mengetahui tentang hasil lebih cepat daripada dengan polling biasa, karena ia tidak perlu menunggu interval antara beberapa permintaan polling.  Apa yang ingin kita dapatkan bisa dimengerti.  Bagaimana kita menerapkan ini dalam kode? <br><blockquote>  Tugas: batas waktu <br>  Kami ingin menunggu Tugas dengan batas waktu <br>  menunggu SendAsync (); </blockquote>  Misalnya, kami memiliki Tugas yang mengirimkan permintaan ke server, dan kami ingin menunggu hasilnya dengan batas waktu, yaitu, kami akan mengembalikan hasil Tugas ini atau mengirim beberapa jenis kesalahan.  Kode C # akan terlihat seperti ini: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sendTask = SendAsync(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> delayTask = Task.Delay(timeout); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> task = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAny(sendTask, delayTask); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (task == delayTask) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Timeout;</code> </pre> <br>  Kode ini meluncurkan Tugas kami, hasil yang ingin kami tunggu, dan Task.Delay.  Selanjutnya, menggunakan Task.WhenAny, kami menunggu Task atau Task.Delay kami.  Jika ternyata Task.Delay dijalankan terlebih dahulu, maka waktunya habis dan kami memiliki batas waktu, kami harus mengembalikan kesalahan. <br><br>  Kode ini, tentu saja, tidak sempurna dan dapat ditingkatkan.  Sebagai contoh, tidak ada salahnya untuk membatalkan Task.Delay jika SendAsync kembali lebih awal, tetapi ini tidak terlalu menarik bagi kami sekarang.  Intinya adalah bahwa jika kita menulis kode seperti itu dan menerapkannya untuk pemungutan suara lama dengan batas waktu yang lama, kita akan mendapatkan beberapa masalah kinerja. <br><br><h3>  1.2 Masalah dengan polling panjang </h3><br><ul><li>  Batas waktu besar </li><li>  Banyak permintaan bersamaan </li><li>  =&gt; Penggunaan CPU tinggi </li></ul><br>  Dalam hal ini, masalahnya adalah konsumsi sumber daya prosesor yang tinggi.  Mungkin terjadi bahwa prosesor terisi penuh pada 100%, dan aplikasi umumnya berhenti bekerja.  Tampaknya kita sama sekali tidak mengonsumsi sumber daya prosesor: kami melakukan beberapa operasi tidak sinkron, menunggu respons dari server, dan prosesor tersebut masih dimuat bersama kami. <br><br>  Ketika kami menghadapi situasi ini, kami menghapus dump memori dari aplikasi kami: <br><br><pre> <code class="cs hljs"> ~*e!clrstack System.Threading.Monitor.Enter(System.Object) System.Threading.TimerQueueTimer.Change(…) System.Threading.Timer.TimerSetup(…) System.Threading.Timer..ctor(…) System.Threading.Tasks.Task.Delay(…)</code> </pre> <br>  Untuk menganalisis dump, kami menggunakan alat WinDbg.  Kami memasukkan perintah yang menampilkan tumpukan jejak dari semua utas yang dikelola, dan melihat hasil seperti itu.  Kami memiliki banyak utas dalam proses yang menunggu beberapa kunci.  Metode Monitor.Enter adalah apa yang dikunci oleh konstruksi di C #.  Kunci ini ditangkap di dalam kelas yang disebut Timer dan TimerQueueTimer.  Di Timer, kami berasal dari Task.Delay ketika kami mencoba membuatnya.  Apa itu  Ketika Task.Delay dimulai, kunci di dalam TimerQueue ditangkap. <br><br><h3>  1.3 Konvoi kunci </h3><br><ul><li>  Banyak utas yang mencoba mengunci satu kunci </li><li>  Di bawah kunci, kode kecil dijalankan </li><li>  Waktu dihabiskan untuk sinkronisasi utas, bukan eksekusi kode. </li><li>  Blokir diblokir - tidak terbatas </li></ul><br>  Kami memiliki konvoi kunci dalam aplikasi.  Banyak utas yang mencoba menangkap kunci yang sama.  Di bawah kunci ini, beberapa kode dijalankan.  Sumber daya prosesor di sini tidak dihabiskan untuk kode aplikasi itu sendiri, tetapi pada operasi untuk menyinkronkan utas di antara mereka sendiri di kunci ini.  Perlu juga diperhatikan fitur yang terkait dengan .NET: utas yang berpartisipasi dalam konvoi kunci adalah utas dari kumpulan utas. <br><br>  Oleh karena itu, jika utas dari kumpulan utas diblokir, mereka mungkin berakhir - jumlah utas di kumpulan utas terbatas.  Ini dapat dikonfigurasi, tetapi masih ada batas atas.  Setelah tercapai, semua utas threadpool akan berpartisipasi dalam konvoi kunci, dan kode apa pun yang melibatkan threadpool akan berhenti dieksekusi dalam aplikasi.  Ini sangat memperburuk situasi. <br><br><h3>  1.4 TimerQueue </h3><br><ul><li>  Mengelola penghitung waktu dalam aplikasi .NET. </li><li>  Pengatur waktu digunakan di: <br>  - Tugas. Terlambat <br>  - PembatalanTocken.Batal Setelah <br>  - HttpClient </li></ul><br>  TimerQueue adalah kelas yang mengatur semua penghitung waktu dalam aplikasi .NET.  Jika Anda pernah memprogram di WinForms, Anda mungkin telah membuat penghitung waktu secara manual.  Bagi mereka yang tidak tahu apa itu timer: mereka digunakan di Task.Delay (ini hanya kasus kami), mereka juga digunakan di dalam CancellingToken, dalam metode CancelAfter.  Artinya, mengganti Task.Delay dengan PembatalanToken.CancelAfter tidak akan membantu kami dengan cara apa pun.  Selain itu, timer digunakan di banyak kelas .NET internal, misalnya, di HttpClient. <br><br>  Sejauh yang saya tahu, beberapa implementasi dari handler HttpClient memiliki timer.  Bahkan jika Anda tidak menggunakannya secara eksplisit, jangan memulai Task.Delay, kemungkinan besar, Anda tetap menggunakannya. <br><br>  Sekarang mari kita lihat bagaimana TimerQueue diatur di dalamnya. <br><br><ul><li>  Status global (per-appdomain): <br>  - Daftar tautan ganda TimerQueueTimer <br>  - Mengunci objek </li><li>  Callback Pengatur Waktu Rutin </li><li>  Pengatur waktu tidak dipesan oleh waktu tanggapan </li><li>  Menambahkan penghitung waktu: O (1) + kunci </li><li>  Penghapusan Timer: O (1) + kunci </li><li>  Mulai timer: O (N) + kunci </li></ul><br>  Di dalam TimerQueue ada keadaan global, itu adalah daftar objek yang terhubung dua kali lipat dari tipe TimerQueueTimer.  TimerQueueTimer berisi tautan ke TimerQueueTimer lainnya, yang bersebelahan dengan daftar tertaut, juga berisi waktu penghitung waktu dan panggilan balik, yang akan dipanggil saat penghitung waktu menyala.  Daftar tertaut dua kali ini dilindungi oleh objek kunci, hanya satu di mana konvoi kunci terjadi dalam aplikasi kita.  Juga di dalam TimerQueue ada Rutin yang meluncurkan panggilan balik yang terkait dengan timer kami. <br><br>  Pengatur waktu sama sekali tidak dipesan oleh waktu tanggapan, seluruh struktur dioptimalkan untuk menambah / menghapus pengatur waktu baru.  Ketika Rutin dimulai, itu berjalan melalui seluruh daftar yang ditautkan ganda, memilih pengatur waktu yang akan berfungsi, dan memanggil mereka kembali. <br><br>  Kompleksitas operasi di sini sedemikian rupa.  Menambah dan menghapus timer terjadi O per unit, dan dimulainya timer terjadi per baris.  Selain itu, jika semuanya dapat diterima dengan kompleksitas algoritmik, ada satu masalah: semua operasi ini menangkap kunci, yang tidak terlalu baik. <br><br>  Situasi apa yang bisa terjadi?  Kami memiliki terlalu banyak timer yang terakumulasi di TimerQueue, jadi ketika Routine dimulai, ia mengunci operasi linearnya yang panjang, pada saat itu mereka yang mencoba memulai atau menghapus timer dari TimerQueue tidak dapat berbuat apa-apa.  Karena itu, konvoi kunci terjadi.  Masalah ini telah diperbaiki di .NET Core. <br><blockquote>  Kurangi pertentangan kunci Timer (coreclr # 14527) <br><ul><li>  Kunci pecahan <br>  - Lingkungan.Prosesor Timer TimerQueue TimerQueueTimer </li><li>  Antrian terpisah untuk penghitung waktu pendek / umur panjang </li><li>  Timer pendek: waktu &lt;= 1/3 detik </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/dotnet/coreclr/issues/14462</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/dotnet/coreclr/pull/14527</a> <br></blockquote>  Bagaimana cara memperbaikinya?  Mereka menggerebek TimerQueue: alih-alih satu TimerQueue, yang statis untuk seluruh AppDomain, untuk seluruh aplikasi, beberapa TimerQueue dibuat.  Ketika utas tiba di sana dan mencoba memulai penghitung waktu mereka, penghitung waktu ini akan jatuh ke TimerQueue acak, dan utas akan memiliki lebih sedikit peluang bertabrakan pada satu kunci. <br><br>  NET Core juga menerapkan beberapa optimasi.  Pengatur waktu dibagi menjadi jangka panjang dan pendek, TimerQueue terpisah sekarang digunakan untuk mereka.  Pengatur waktu singkat dipilih kurang dari 1/3 detik.  Saya tidak tahu mengapa konstanta seperti itu dipilih.  Di .NET Core, kami gagal menangkap masalah dengan penghitung waktu. <br><br><img src="https://habrastorage.org/webt/f_/am/cv/f_amcv6bohiq54ciyuunvtrr0ei.jpeg"><br><br>  <a href="">https://github.com/Microsoft/dotnet-framework-early-access/blob/master/release-notes/NET48/dotnet-48-changes.md</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/dotnet/coreclr/labels/netfx-port-consider</a> <br><br>  Perbaikan ini di-backport ke .NET Framework, versi 4.8.  Tag netfx-port-pertimbangkan ditunjukkan dalam tautan di atas, jika Anda pergi ke repositori .NET Core, CoreCLR, CoreFX, Anda dapat mencari masalah ini yang akan di-backport ke .NET Framework, sekarang ada sekitar lima puluh di antaranya.  Artinya, open source .NET banyak membantu, beberapa bug diperbaiki.  Anda dapat membaca changelog .NET Framework 4.8: banyak bug telah diperbaiki, lebih banyak daripada rilis NET lainnya.  Menariknya, perbaikan ini dimatikan secara default di .NET Framework 4.8.  Itu termasuk dalam seluruh file yang Anda kenal disebut App.config <br><br>  Pengaturan di App.config yang memungkinkan perbaikan ini disebut UseNetCoreTimer.  Sebelum .NET Framework 4.8 keluar, agar aplikasi kami berfungsi dan tidak masuk ke konvoi kunci, Anda harus menggunakan implementasi Task.Delay Anda.  Di dalamnya, kami mencoba menggunakan tumpukan biner untuk lebih efisien memahami timer mana yang harus dipanggil sekarang. <br><br><h3>  1.5 Task.Delay: implementasi asli </h3><br><ul><li>  Biner </li><li>  Sharding </li><li>  Itu membantu, tetapi tidak dalam semua kasus </li></ul><br>  Menggunakan tumpukan biner memungkinkan Anda untuk mengoptimalkan Rutin, yang memanggil panggilan balik, tetapi memperburuk waktu yang diperlukan untuk menghapus timer sewenang-wenang dari antrian - untuk ini Anda perlu membangun kembali tumpukan.  Ini kemungkinan besar mengapa .NET menggunakan daftar tertaut ganda.  Tentu saja, hanya menggunakan tumpukan biner tidak akan membantu kami di sini, kami juga harus mengerjakan TimerQueue.  Solusi ini berfungsi untuk sementara waktu, tetapi tetap saja semuanya jatuh ke konvoi kunci lagi karena fakta bahwa timer digunakan tidak hanya di mana mereka berjalan secara eksplisit dalam kode, tetapi juga di perpustakaan pihak ketiga dan kode .NET.  Untuk sepenuhnya memperbaiki masalah ini, Anda harus memutakhirkan ke .NET Framework versi 4.8 dan mengaktifkan perbaikan dari .NET developer. <br><br><h3>  1.6. Tugas.Delay: kesimpulan </h3><br><ul><li>  Perangkap di mana-mana - bahkan dalam hal-hal yang paling sering digunakan </li><li>  Lakukan stress testing </li><li>  Beralih ke Core, dapatkan perbaikan bug (dan bug baru) terlebih dahulu :) </li></ul><br>  Apa kesimpulan dari keseluruhan cerita ini?  Pertama, jebakan dapat ditemukan benar-benar di mana-mana, bahkan di kelas yang Anda gunakan setiap hari tanpa berpikir, misalnya, Tugas yang sama, Tugas. <br><br>  Saya sarankan melakukan pengujian stres terhadap proposal Anda.  Masalah ini baru saja kami identifikasi pada tahap pengujian beban.  Kami kemudian memotretnya beberapa kali pada produksi di aplikasi lain, tetapi, bagaimanapun, stress testing membantu kami untuk menunda waktu sebelum kami menghadapi masalah ini dalam kenyataan. <br><br>  Beralih ke .NET Core - Anda akan menjadi yang pertama menerima perbaikan bug (dan bug baru).  Di mana tanpa bug baru? <br><br>  Cerita tentang penghitung waktu telah berakhir, dan kami beralih ke yang berikutnya. <br><br><h2>  Kisah 2: SemaphoreSlim </h2><br>  Kisah berikut adalah tentang SemaphoreSlim yang terkenal. <br><br><h3>  2.1 Pelambatan server </h3><br><ul><li>  Diperlukan untuk membatasi jumlah permintaan yang diproses secara bersamaan di server </li></ul><br>  Kami ingin menerapkan pembatasan pada server.  Apa ini  Anda mungkin semua tahu pembatasan pada CPU: ketika prosesor terlalu panas, ia menurunkan frekuensi untuk menjadi dingin, dan ini membatasi kinerjanya.  Jadi di sini.  Kami tahu bahwa server kami dapat memproses permintaan N secara paralel dan tidak jatuh.  Apa yang ingin kita lakukan?  Batasi jumlah permintaan yang diproses secara bersamaan untuk konstanta ini dan buatlah sehingga jika lebih banyak permintaan datang, mereka mengantri dan menunggu sampai permintaan yang datang lebih awal dieksekusi.  Bagaimana mengatasi masalah ini?  Perlu untuk menggunakan semacam sinkronisasi primitif. <br><br>  Semaphore adalah primitif sinkronisasi tempat Anda dapat menunggu N kali, setelah itu orang yang tiba N + pertama dan seterusnya akan menunggu sampai mereka yang memasukkannya lebih dulu melepaskan Semaphore.  Ternyata seperti ini: dua utas eksekusi, dua pekerja di bawah Semaphore, sisanya berdiri dalam barisan. <br><br><img src="https://habrastorage.org/webt/6s/bu/h7/6sbuh77p4temzi5yiofjlh-rxoi.png"><br><br>  Tentu saja, hanya saja Semaphore tidak terlalu cocok untuk kita, itu ada di .NET sinkron, jadi kami mengambil SemaphoreSlim dan menulis kode ini: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> semaphore = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SemaphoreSlim(N); … <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> semaphore.WaitAsync(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> HandleRequestAsync(request); semaphore.Release();</code> </pre> <br>  Kami membuat SemaphoreSlim, tunggu, di bawah Semaphore kami memproses permintaan Anda, setelah itu kami merilis Semaphore.  Tampaknya ini adalah implementasi ideal pelambatan server, dan tidak bisa lebih baik lagi.  Tapi semuanya jauh lebih rumit. <br><br><h3>  2.2 Pelambatan server: komplikasi </h3><br><ul><li>  Memproses permintaan dalam urutan LIFO </li><li>  SemaphoreSlim </li><li>  Concurrentstack </li><li>  TaskCompletionSource </li></ul><br>  Kami lupa sedikit tentang logika bisnis.  Permintaan yang datang ke pembatasan adalah permintaan http asli.  Sebagai aturan, mereka memiliki batas waktu, yang ditetapkan oleh mereka yang mengirim permintaan ini secara otomatis, atau batas waktu pengguna yang menekan F5 setelah beberapa waktu.  Dengan demikian, jika Anda memproses permintaan dalam urutan antrian, seperti Semaphore biasa, maka pertama-tama permintaan dari antrian yang telah habis waktu mungkin sudah diproses.  Jika Anda bekerja dalam urutan tumpukan - proses pertama dari semua permintaan yang datang terakhir, masalah seperti itu tidak akan muncul. <br><br>  Selain SemaphoreSlim, kami harus menggunakan ConcurrentStack, TaskCompletionSource, untuk membungkus banyak kode di sekitar semua ini, sehingga semuanya bekerja sesuai urutan yang kami butuhkan.  TaskCompletionSource adalah hal semacam itu, yang mirip dengan CancertokenSource, tetapi tidak untuk Cancertoken, tetapi untuk Task.  Anda dapat membuat TaskCompletionSource, menarik Tugas dari itu, memberikannya dan kemudian memberi tahu TaskCompletionSource bahwa Anda perlu mengatur hasil untuk Tugas ini, dan mereka yang menunggu Tugas ini akan mencari tahu tentang hasil ini. <br><br>  Kita semua sudah menerapkannya.  Kode ini mengerikan.  dan yang terburuk, ternyata tidak bisa beroperasi. <br><br>  Beberapa bulan setelah dimulainya penggunaannya dalam aplikasi yang agak sarat muatan, kami menemui masalah.  Dengan cara yang sama seperti pada kasus sebelumnya, konsumsi CPU telah meningkat menjadi 100%.  Kami melakukan hal yang sama, menghapus tempat sampah, melihatnya di WinDbg, dan kembali menemukan konvoi kunci. <br><br><img src="https://habrastorage.org/webt/h_/ef/as/h_efasuul34r0fm7vwopo2hm1bc.jpeg"><br><br>  Kali ini kunci konvoi terjadi di dalam SemaphoreSlim.WaitAsync dan SemaphoreSlim.Release.  Ternyata ada kunci di dalam SemaphoreSlim, itu tidak bebas kunci.  Ini menjadi kekurangan yang cukup serius bagi kami. <br><br><img src="https://habrastorage.org/webt/0h/-k/qq/0h-kqqxojlujm3dglokmacabvwq.jpeg"><br><br>  Di dalam SemaphoreSlim ada keadaan internal (sebuah counter dari berapa banyak pekerja masih bisa masuk di bawahnya), dan daftar yang saling terkait dari mereka yang menunggu di Semaphore ini.  Gagasannya hampir sama: Anda bisa menunggu di Semaphore ini, Anda dapat membatalkan harapan Anda - untuk meninggalkan antrian ini.  Ada kunci yang menghancurkan hidup kita. <br><br>  Kami memutuskan: turun dengan semua kode mengerikan yang harus kami tulis. <br><br><img src="https://habrastorage.org/webt/ax/ls/3i/axls3iseuxmgjt-vqkeiqs7hvtq.jpeg"><br><br>  Mari kita menulis Semaphore kita, yang akan segera bebas kunci dan yang akan segera bekerja dalam susunan tumpukan.  Membatalkan penantian tidak penting bagi kami. <br><br><img src="https://habrastorage.org/webt/rv/rg/wv/rvrgwv8apebibtiymhxpvm5giti.jpeg"><br><br>  Tentukan kondisi ini.  Ini akan menjadi jumlah currentCount - ini adalah berapa banyak lagi ruang yang tersisa di Semaphore.  Jika tidak ada kursi yang tersisa di Semaphore, angka ini akan negatif dan akan menunjukkan berapa banyak pekerja dalam antrian.  Juga akan ada ConcurrentStack, yang terdiri dari TaskCompletionSource'ov - ini hanya setumpuk wait'ov dari mana mereka akan ditarik jika perlu.  Mari kita menulis metode WaitAsync. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> decrementedCount = Interlocked.Decrement(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> currentCount); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (decrementedCount &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.CompletedTask; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> waiter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(); waiters.Push(waiter); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> waiter.Task;</code> </pre> <br>  Pertama, kita mengurangi meja, mengambil satu tempat di Semaphore untuk diri kita sendiri, jika kita memiliki tempat bebas, dan kemudian kita berkata: "Itu saja, kamu pergi di bawah Semaphore". <br><br>  Jika tidak ada tempat di Semaphore, kami membuat TaskCompletionSource, membuangnya di tumpukan waiter'ov dan mengembalikan Task ke dunia luar.  Ketika saatnya tiba, Tugas ini akan bekerja, dan pekerja akan dapat melanjutkan pekerjaannya dan akan pergi di bawah Semaphore. <br><br>  Sekarang mari kita menulis metode Rilis. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> countBefore = Interlocked.Increment(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> currentCount) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (countBefore &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (waiters.TryPop(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> waiter)) waiter.TrySetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br>  Metode rilis adalah sebagai berikut: <br><br><ul><li>  Gratis Satu Kursi di Semaphore </li><li>  Jumlah saat ini bertambah </li></ul><br>  Jika kita dapat mengetahui dengan currentCount apakah ada pelayan di dalam tumpukan yang perlu kita beri sinyal, kita menarik pelayan seperti itu keluar dari tumpukan dan memberi sinyal.  Di sini pelayan adalah TaskCompletionSource.  Pertanyaan untuk kode ini: sepertinya masuk akal, tetapi apakah ini bekerja?  Ada masalah apa?  Ada nuansa yang terkait dengan tempat kelanjutan dan TugasCompletionSource'y diluncurkan. <br><br><img src="https://habrastorage.org/webt/_1/zo/hu/_1zohu07rqeiemrkwrcubv7gwhe.png"><br><br>  Pertimbangkan kode ini.  Kami menciptakan TaskCompletionSource dan meluncurkan dua Task.  Tugas pertama menampilkan unit, mengatur hasilnya menjadi TaskCompletionSource, dan kemudian menampilkan deuce pada konsol.  Tugas kedua menunggu pada TaskCompletionSource ini, pada tugasnya, dan kemudian selamanya memblokir utasnya dari kumpulan utas. <br><br>  Apa yang akan terjadi di sini?  Tugas 2 pada kompilasi akan dibagi menjadi dua metode, yang kedua adalah kelanjutan yang berisi Thread.Sleep.  Setelah mengatur hasil dari TaskCompletionSource, kelanjutan ini akan dieksekusi di utas yang sama di mana Tugas pertama dieksekusi.  Dengan demikian, aliran Tugas pertama akan diblokir selamanya, dan deuce ke konsol tidak akan lagi dicetak. <br><br>  Menariknya, saya mencoba mengubah kode ini, dan jika saya menghapus output ke unit konsol, kelanjutan diluncurkan pada utas lainnya dari kumpulan utas dan deuce dicetak.  Dalam hal ini kelanjutan akan dieksekusi di utas yang sama, dan di mana - akan sampai ke kumpulan utas - sebuah pertanyaan bagi pembaca. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tcs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;( TaskCreationOptions.RunContinuationsAsynchronously); <span class="hljs-comment"><span class="hljs-comment">/* OR */</span></span> Task.Run(() =&gt; tcs.TrySetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>));</code> </pre> <br>  Untuk mengatasi masalah ini, kita bisa membuat TaskCompletionSource dengan RunContinuations yang sesuai menandai secara tidak sinkron, atau memanggil metode TrySetResult di dalam Task.Run/ThreadPool.QueueUserWorkItem agar tidak berjalan di utas kami.  Jika dijalankan di utas kami, kami mungkin memiliki efek samping yang tidak diinginkan.  Selain itu, ada masalah kedua, kami akan membahasnya lebih detail. <br><br><img src="https://habrastorage.org/webt/m9/x8/gx/m9x8gxz7x5tw3mjcps7nygdmkjs.jpeg"><br><br>  Lihatlah metode WaitAsync dan Release dan cobalah untuk menemukan masalah lain dalam metode Release. <br><br>  Kemungkinan besar, untuk menemukannya sangat mustahil.  Ada perlombaan di sini. <br><br><img src="https://habrastorage.org/webt/cs/1e/4q/cs1e4q3yaz4d3084_24z2ucsd6y.jpeg"><br><br>  Hal ini disebabkan oleh fakta bahwa dalam metode WaitAsync perubahan negara bukan atom.  Pertama kita mengurangi meja dan kemudian mendorong pelayan ke tumpukan.  Jika Kebetulan bahwa Rilis dieksekusi antara penurunan dan dorongan, itu bisa keluar sehingga tidak menarik apa pun dari tumpukan.  Ini harus diperhitungkan, dan dalam metode Pelepasan, tunggu sampai pelayan muncul di tumpukan. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> countBefore = Interlocked.Increment(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> currentCount) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (countBefore &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Waiter waiter; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spinner = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpinWait(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!waiter.TryPop(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> waiter)) spinner.SpinOnce(); waiter.TrySetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br>  Di sini kita melakukannya dalam satu lingkaran sampai kita berhasil menariknya keluar.  Agar tidak membuang siklus prosesor sekali lagi, kami menggunakan SpinWait. <br><br>  Dalam beberapa iterasi pertama, itu akan berputar dalam satu lingkaran.  Jika ada banyak iterasi, pelayan tidak akan muncul untuk waktu yang lama, maka utas kami akan menuju Thread. Tidur, agar tidak membuang sumber daya CPU sekali lagi. <br><br>  Bahkan, Semaphore-order LIFO bukan hanya ide kami. <br><blockquote>  <b>LowLevelLifoSemaphore</b> <br><ul><li>  Sinkron </li><li>  Pada Windows menggunakan port IO Completion sebagai tumpukan Windows </li></ul><br>  <a href="">https://github.com/dotnet/corert/blob/master/src/System.Private.CoreLib/src/System/Threading/LowLevelLifoSemaphore.cs</a> </blockquote>  Ada Semaphore di NET itu sendiri, tetapi tidak di CoreCLR, tidak di CoreFX, tetapi di CoreRT.  Terkadang cukup berguna untuk mengintip ke dalam repositori .NET.  Ada Semaphore yang disebut LowLevelLifoSemaphore.  Semaphore ini tidak cocok untuk kita: itu sinkron. <br><br>  Hebatnya, pada Windows ini berfungsi melalui port IO Completion.  Mereka memiliki properti yang dapat ditunggu oleh utas, dan utas ini akan dirilis hanya dalam urutan LIFO.  Fitur ini digunakan di sana, itu benar-benar LowLevel. <br><br><h3>  2.3 Kesimpulan: </h3><br><ul><li>  Jangan harap pengisian kerangka akan bertahan di bawah beban Anda </li><li>  Lebih mudah untuk menyelesaikan masalah tertentu daripada kasus umum. </li><li>  Tes stres tidak selalu membantu </li><li>  Waspadalah terhadap pemblokiran </li></ul><br>  Apa kesimpulan dari keseluruhan cerita ini?  Pertama-tama, jangan berharap bahwa beberapa kelas dari kerangka kerja yang Anda gunakan dari pustaka standar akan mengatasi beban Anda.  Saya tidak ingin mengatakan bahwa SemaphoreSlim buruk, hanya saja ternyata tidak cocok secara khusus dalam skenario ini. <br><br>  Ternyata jauh lebih mudah bagi kita untuk menulis Semaphore kita untuk tugas tertentu.  Misalnya, itu tidak mendukung pembatalan menunggu.  Fitur ini tersedia di SemaphoreSlim biasa, kami tidak memilikinya, tetapi ini memungkinkan kami untuk menyederhanakan kode. <br><br>  Pengujian beban, meskipun membantu, mungkin tidak selalu membantu. <br><br> .NET  ,           —   .        lock,  : «    ?»     CPU 100%,     lock', , ,   -  .NET.      . <br><br>    . <br><br><h2>  3: (A)sync IO </h2><br>    /,      . <br><br><img src="https://habrastorage.org/webt/84/qh/sz/84qhsz9je7twmgbswt5so0dfx2q.jpeg"><br><br>    lock convoy,    stack trace     Overlapped  PinnableBufferCache.   lock.     : Overlapped  PinnableBufferCache? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OVERLAPPED</a> —    Windows,      /.      ,        .        ,  .       ,     lock convoy.   ,      lock convoy,    ,   . <br><br><img src="https://habrastorage.org/webt/if/j_/fc/ifj_fclqmvkfgfff7zedxpj63mo.jpeg"><br><br>  ,       ,   .NET 4.5.1  4.5.2.     .NET 4.5.2,     ,    .NET 4.5.2.  .NET 4.5.1     OverlappedDataCache,      Overlapped — ,       ,   .    ,  lock-free,   ConcurrentStack,       .  .NET 4.5.2     :  OverlappedDataCache   PinnableBufferCache. <br><br>   ? PinnableBufferCache     ,   Overlapped     ,    ,       —      . ,     ,      . PinnableBufferCache     .   , lock-free,   ConcurrentStack.     ,      .        ,        ,  -    lock-free    list  lock'. <br><br><h3> 3.1 PinnableBufferCache </h3><br> LockConvoy: <br><br><ul><li>    </li><li>      </li></ul><br>  lock convoy  ,   -     .        list      ,     lock   ,  ,                . <br><br>     PinnableBufferCache  ,         .    : <br><br><pre> <code class="plaintext hljs">PinnableBufferCache_System.ThreadingOverlappedData_MinCount</code> </pre> <br>      ,      .  : « !         -  ».         -: <br><br><pre> <code class="cs hljs">Environment.SetEnvironmentVariable( <span class="hljs-string"><span class="hljs-string">"PinnableBufferCache_System.Threading.OverlappedData_MinCount"</span></span>, <span class="hljs-string"><span class="hljs-string">"10000"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Overlapped().GetHashCode(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) GC.Collect(GC.MaxGeneration, GCCollectionMode.Forced);</code> </pre> <br>    ?     ,    Overlapped  ,   ,        .     ,   ,     ,     ,  PinnableBufferCache      lock convoy'.    ,           . <br><br>  .NET Core  PinnableBufferCache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ,   OverlappedData   . ,        , Garbage collector     ,      .     .NET Core  .  .NET Framework,   ,     . <br><br><h3> 3.2 : </h3><br><ul><li>      </li><li>      </li><li>   .NET Core </li></ul><br>      ,     .   ,   .NET            ,       . ,  ,  .NET Core. ,     ,         -. <br><br>    key-value . <br><br><h2>  4: Concurrent key-value collections </h2><br>  .NET   concurrent-.  lock-free  ConcurrentStack  ConcurrentQueu,       .   ConcurrentDictionary,    .   lock-free  ,   ,      .    ConcurrentDictionary? <br><br><h3> 4.1 ConcurrentDictionary </h3><br> : <br><br><ul><li>  </li><li>  </li></ul><br>  Pro: <br><br><ul><li>     </li><li>   (TryAdd/TryUpdate/AddOrUpdate) </li><li> Lock-free  </li><li> Lock-free enumeration </li></ul><br>      , memory-,  ,        .    ,    ,    .NET Framework.            . ,  ,      (enumeration) lock-free. ,   . <br><br>  ,   ,   -  .NET.  key-value    -    : <br><br><img src="https://habrastorage.org/webt/ff/9f/g_/ff9fg_qzzuzvafep8c-p3seyigm.jpeg"><br><br>  -,     bucket'.      bucket',    .   ,    bucket   ,       . <br><br>    —   ,  ConcurrentDictionary.  ConcurrentDictionary    «-»   .    ,      ,   ,       memory traffic.     ConcurrentDictionary,   lock'.   —   . <br><br>    ,    Dictionary. <br><br><img src="https://habrastorage.org/webt/-_/dw/jo/-_dwjoxswmd1kecoi3aln8m7bow.jpeg"><br><br>  Dictionary  ,  Concurrent,      .     :  buckets,  entries.   buckets       bucket'   entries.   «-»    entries.          .      «-»   int,     bucket'. <br><br>   memory overhead,     ConcurrentDictionary   Dictionary. <br><br><img src="https://habrastorage.org/webt/em/aa/ch/emaachor-z_xxt7m_1wc7ntqupm.jpeg"><br><br>    Dictionary. Memory overhea'    ,       .    Dictionary  overhead  -    ,  int'.  8 . <br><br>    ConcurrentDictionary.  ConcurrentDictionary     ConcurrentDictionary.Node.   , .     int hashCode        .       ,    table (  16 ),  int hashCode     .      ,   64-    28  overhead'.       Dictionary. <br><br>  memory overhead', ConcurrentDictionary     GC   ,       .     Benchmark.   ConcurrentDictionary  ,       GC.Collect.    ? <br><br><img src="https://habrastorage.org/webt/on/yj/uq/onyjuq1rqgfkv8iav5x4z8nrnq8.jpeg"><br><br>     .       ConcurrentDictionary  10  ,        ,             ,      .   Dictionary   .      ,   ,  ,    .       . <br><br>     ,     ConcurrentDictionary? <br><br><h3> 4.2   </h3><br><ul><li>    </li><li> TTL </li><li> Dictionary+lock </li><li> Sharding </li></ul><br>     .      ConcurrentDictionary.        10  .   ,     .   TTL  ,    .        Dictionary  lock'. ,  ,  lock    .       Dictionary  lock'      ,   -     ,           lock.      ,     . <br><br><h3> 4.3  </h3><br><ul><li>   in-memory  &lt;Guid,Guid&gt; </li><li>   &gt;10 <sup>6</sup>  </li><li>       </li><li>   </li><li>        </li></ul><br>     .      —      ,       in-memory   Guid'  Guid,     .       .     - - ,     .  ,            15    .   .     Semaphore     ConcurrentDictionary. <br><br><img src="https://habrastorage.org/webt/u4/kw/kt/u4kwkttmxwpyelqlqoqp9zxahaa.jpeg"><br><br> ,    lock-free    ,    overhead      GC.   ,          .      ,    ,       ,   .   ,     -  ,       ,    .  ,  ,      Large Object Heap.    ? <br><br>       ,     ,     Dictionary   . <br><br><img src="https://habrastorage.org/webt/kx/yn/oi/kxynoiatsy8zcyrc5dei-xohlk4.jpeg"><br><br>   Dictionary   bucket',  Entry.  Entry  , ,   ,   . <br><br><img src="https://habrastorage.org/webt/n8/7a/5r/n87a5rlkgdk62nw82qysi3fmi18.png"><br><br>  Dictionary   ,   ,      . ,     - . <br><br>      ,  -     ? -,  ,       ,     ,      .     .    Dictionary,     , buckets, entries,              Interlocked. ,         . <br><blockquote> <b>Dictionary</b> <br><ul><li>   ,    </li><li>     ,   ? <br> —  Resize  buckets  entries   <br> —      - <br> —    Dictionary.Entry <br> —   -   </li></ul><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://blogs.msdn.microsoft.com/tess/2009/12/21/high-cpu-in-net-app-using-a-static-generic-dictionary/</a> </blockquote>     ,       Dictionary       -  bucket'.       ,      .    ,     ,        .       ,       ,    . <br><br>      Entry  Dictionary.     - -    .  ,     . <br><br><img src="https://habrastorage.org/webt/4p/xb/aq/4pxbaqil2cd4jaxnayxjqz-5yae.jpeg"><br><br>    .NET Framework  1.1.     Hashtable,   Dictionary,    object'.     MSDN ,      .  ,             -.   .  ,  Hashtable  .  ,      . <br><br><h3> 4.4    Dictionary.Entry </h3><br><img src="https://habrastorage.org/webt/y2/ww/rs/y2wwrslyuqpioqcalmpnt8dh6cw.jpeg"><br>    ? Dictionary.Entry ,  ,  8 , ,  ,   ,     .   ? <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> writing; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.writing = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; buckets[index] = …; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.version++; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.writing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>   :  (    ,    )  int-.   ,  .   ,     , ,  ,  . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> writing; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.version; bucket = bickets[index]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.writing || version != <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.version) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>    ,     ,         .       ,   .       ,  8 . <br><br><h3> 4.5   -   </h3><br>  ,   . <br><br><img src="https://habrastorage.org/webt/hh/bp/0l/hhbp0leb95qndz4bmg-2gtvmeue.jpeg"><br><br>  Dictionary     bucket    ,     . <br><br>  Dictionary,    .      : 0  2.   bucket, 1       2.   ?     0.   ,       ,    2.     .   ,  2,       , , 1. 1       2 —     bucket.   ,      ,   .    1 — ,     bucket.  Hashtable     ,     bucket'  -.        — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">double hashing</a> . <br><br><h3> 4.6   </h3><br><ul><li>     </li><li>      </li></ul><br> <b></b> <br><br><ul><li>        </li><li>    ,  resize </li></ul><br> <b></b> <br><br><ul><li>     ,      </li></ul><br>        .         ,       Buckets,     Entries (   Buckets,     Entries).   -  ,       ,   ,          ,    . <br><br>             .    ,    . <br><br>  :     ,      ,    ,     ,     . ,       ,   . <br><br><img src="https://habrastorage.org/webt/pm/lo/ah/pmloah0wlfbq7ilvlnrvbh3pyuu.png"><br><br>     ,   , —  . <br><br>   ?   ,  -    2.   -   Capacity  ,            .    — 2.       ,   .      2.    ?  ,  ,     ,   .    -  ,        ,       3. ,    ,  ,    ,  ,  . <br><br>  ,    Hashtable,  .   ,     double hashing.     ,       ,   ,     . <br><br>   ,      ,     —   ,            .     Hashtable.   ,    —     —       .                 .  ,     bucket',       -  ,       .  . <br><br>     ,  ,   lock-free      LOH. <br><br><img src="https://habrastorage.org/webt/pg/2b/6b/pg2b6bbfkm_3nnkds27g2krziz8.jpeg"><br><br>   lock-free ?  MSDN    Hashtable ,      .    ,            ,            . <br><br><img src="https://habrastorage.org/webt/yu/sg/he/yusghe0crfu9ywaic0aozpr7wri.jpeg"><br><br>      ,     ,        ,   bucket'.         Dictionary  bucket',  -,   bucket'      .    -    bucket,  bucket  .      ,     . <br><br>  ,       Large Object Heap. <br><br><img src="https://habrastorage.org/webt/wf/po/8o/wfpo8ou1_fpzhdkgcdbjzw-7u9q.jpeg"><br><br>      .  CustomDictionary  CustomDictionarySegment    .   Dictionary,    ,      .   —   Dictionary,      .       ,      Large Object Heap.        ,   bucket'   . ,      ,    ,   bucket,     - - . <br><br>           .       ConcurrentDictionary,     .NET,        ,      . <br><br><h3> 4.7  </h3><br><ul><li> .NET   </li><li>    </li><li>   </li><li> ,     </li><li>   </li><li>   </li></ul><br>     ? .NET  .   .   ,     ,       .    -   —   - .   ,  , ,     . <br><br>  -   , ,   ,     ,   .   ,   ,   ,        , ,          .   —   , ,   . <br><br><h3>   </h3><br><ul><li>   ConcurrentDictionary: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://habr.com/ru/company/skbkontur/blog/348508/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/vostok/commons.threading</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/epeshk/dotnext-2019-threading</a> </li></ul><br>   —          ConcurrentDictionary. ,      ,   ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Diafilm</a> ),       . <br><br>      GitHub.   —     ,    ,    LIFO-Semaphore,    .       ,    . <br><blockquote> 6-7     <b>DotNext 2019 Moscow</b>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">«.NET:  »</a>    ,        .NET Framework  .NET Core,  ,        . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468611/">https://habr.com/ru/post/id468611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468597/index.html">Segi enam Saturnus atau bagaimana di rumah mereproduksi eksperimen para ilmuwan dari Universitas Oxford</a></li>
<li><a href="../id468601/index.html">Perkiraan jangka waktu proyek. Mengapa hampir selalu sangat bersahaja dan apa yang harus dilakukan</a></li>
<li><a href="../id468603/index.html">Rutracker sudah memasukkan eSNI. Akhir era DPI dan akhir kunci</a></li>
<li><a href="../id468605/index.html">Pointer konstan ke pointer ke pointer ...</a></li>
<li><a href="../id468609/index.html">Performa penjadwalan berganda yang sulit dipahami</a></li>
<li><a href="../id468615/index.html">10 Bahasa Teratas untuk Pelokalan Aplikasi</a></li>
<li><a href="../id468621/index.html">Kami menerjemahkan jaringan rumah ke DoH, atau klik lain pada hidung pemfilteran</a></li>
<li><a href="../id468623/index.html">Saya ingin ulasan tentang Habr</a></li>
<li><a href="../id468625/index.html">Tanpa server: 15% lebih lambat dan delapan kali lebih mahal</a></li>
<li><a href="../id468627/index.html">ADAM-6200 I / O Modul</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>