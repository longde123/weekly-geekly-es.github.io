<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏚️ 👎 💍 Wie Clang eine Funktion kompiliert ☘️ 🔃 ☎️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich wollte einen Artikel darüber schreiben, wie LLVM eine Funktion optimiert, aber zuerst müssen Sie schreiben, wie Clang C oder C ++ in LLVM übersetz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie Clang eine Funktion kompiliert</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431688/">  Ich wollte einen Artikel darüber schreiben, wie LLVM eine Funktion optimiert, aber zuerst müssen Sie schreiben, wie Clang C oder C ++ in LLVM übersetzt. <br><br><img src="https://habrastorage.org/webt/df/9y/a9/df9ya9didizcjaetap9tjvfymzo.jpeg" alt="Bild"><br><a name="habracut"></a><br><br>  Betrachten Sie die Aspekte auf hoher Ebene, ohne in die Tiefen von Clang einzutauchen.  Ich möchte darauf achten, wie die Clang-Ausgabe mit der Eingabe zusammenhängt, während wir die nicht trivialen Funktionen von C ++ nicht berücksichtigen.  Wir verwenden diese kleine Funktion, die ich aus hervorragenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorlesungen über zyklische Optimierungen</a> entlehnt habe: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_sorted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[i] &gt; a[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Da Clang keine Optimierungen vornimmt und LLVM IR ursprünglich für C und C ++ entwickelt wurde, ist die Konvertierung relativ einfach.  Ich werde Clang 6.0.1 (oder eine nahe Version, da diese noch nicht veröffentlicht wurde) auf x86-64 verwenden. <br><br>  Die Befehlszeile lautet wie folgt: <br><br><pre> <code class="bash hljs">clang++ is_sorted.cpp -O0 -S -emit-llvm</code> </pre> <br>  Mit anderen Worten: Wir kompilieren die Datei is_sorted.cpp als C ++ und teilen der LLVM-Toolchain Folgendes mit: Nicht optimieren, den Assembler als Textdarstellung von LLVM-IR ausgeben.  LLVM IR ist umfangreich und kann nicht schnell angezeigt oder analysiert werden. Ein binäres Bitcode-Format ist immer vorzuziehen, wenn eine Person diesen Code nicht betrachten muss.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> ist die vollständige LLVM-IR, wir werden sie in Teilen überprüfen. <br><br>  Beginnen wir oben in der Datei: <br><br><pre> <code class="cpp hljs">; ModuleID = <span class="hljs-string"><span class="hljs-string">'is_sorted.cpp'</span></span> source_filename = <span class="hljs-string"><span class="hljs-string">"is_sorted.cpp"</span></span> target datalayout = <span class="hljs-string"><span class="hljs-string">"em:e-i64:64-f80:128-n8:16:32:64-S128"</span></span> target triple = <span class="hljs-string"><span class="hljs-string">"x86_64-unknown-linux-gnu"</span></span></code> </pre> <br>  Der gesamte Text zwischen dem Semikolon und dem Ende der Zeile ist ein Kommentar, was bedeutet, dass die erste Zeile nichts bewirkt. Wenn Sie jedoch an LLVM interessiert sind, ist ein „Modul“ eine Kompilierungseinheit, ein Container für Code und Daten.  Die zweite Zeile sollte uns auch nicht stören.  In der dritten Zeile werden einige vom Compiler getroffene Annahmen beschrieben. Sie spielen in diesem Artikel keine Rolle. Weitere Informationen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Ziel drei</a> ist das Erbe von gcc und braucht uns nicht mehr. <br><br>  Die LLVM-Funktion verfügt über optionale Attribute: <br><br><pre> <code class="cpp hljs">; Function Attrs: noinline nounwind optnone uwtable</code> </pre> <br>  Einige von ihnen (wie diese) werden vom Front-End unterstützt, andere werden später durch Optimierungsdurchläufe hinzugefügt.  Diese Attribute haben nichts mit der Bedeutung des Codes zu tun. Ich werde sie hier nicht diskutieren, aber Sie können sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> lesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> wenn Sie interessiert sind. <br><br>  Und schließlich unsere Funktion: <br><br><pre> <code class="bash hljs">define zeroext i1 @_Z9is_sortedPii(i32* %a, i32 %n) <span class="hljs-comment"><span class="hljs-comment">#0 {</span></span></code> </pre> <br>  "Zeroext" bedeutet, dass der Rückgabewert der Funktion (i1, eine Einzelbit-Ganzzahl) im Backend mit Nullen auf die vom ABI benötigte Breite erweitert werden muss.  Dann kommt der "verstümmelte" Funktionsname, dann ist die Liste der Parameter im Grunde die gleiche wie im C ++ - Code, außer dass i32 eine 32-Bit-Variable definiert.  # 0 verbindet die Funktion mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Attributgruppe</a> am Ende der Datei. <br><br>  Hier ist die erste Basiseinheit: <br><br><pre> <code class="cpp hljs">entry: %retval = alloca i1, align <span class="hljs-number"><span class="hljs-number">1</span></span> %a.addr = alloca i32*, align <span class="hljs-number"><span class="hljs-number">8</span></span> %n.addr = alloca i32, align <span class="hljs-number"><span class="hljs-number">4</span></span> %i = alloca i32, align <span class="hljs-number"><span class="hljs-number">4</span></span> store i32* %a, i32** %a.addr, align <span class="hljs-number"><span class="hljs-number">8</span></span> store i32 %n, i32* %n.addr, align <span class="hljs-number"><span class="hljs-number">4</span></span> store i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> br label %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.cond</code> </pre> <br>  Jeder LLVM-Befehl muss sich innerhalb der Basiseinheit befinden: ein Befehlssatz mit einem Eingang am Anfang und einem Ausgang am Ende.  Die letzte Anweisung der Basiseinheit muss eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beendigungsanweisung sein</a> : "Fehler" in der nächsten Basiseinheit ist nicht zulässig.  Jede Funktion muss einen Eingabeblock haben, der keine Vorgänger hat, die den Übergang zu diesem Block ausführen.  Diese und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">andere Eigenschaften</a> werden beim Parsen von IR überprüft. Diese Überprüfungen können auch während des Kompilierungsprozesses vom „Modulprüfer“ mehrmals aufgerufen werden.  Der Verifizierer ist nützlich zum Debuggen, wenn ein Durchlauf eine ungültige IR generiert. <br><br>  Die ersten vier Anweisungen in diesem Basisblock lauten "alloca": Zuweisen des Stapelspeichers.  Die ersten drei erstellen Variablen, die implizit während der Kompilierung erstellt werden, die vierte - eine Schleifenvariable.  Auf diese Weise zugewiesene Variablen können nur über Lade- und Speicheranweisungen aufgerufen werden.  Die folgenden drei Anweisungen initialisieren die drei Stapelschlitze a.addr und n.addr werden unter Verwendung der an die Funktion als Parameter übergebenen Werte initialisiert, und i wird auf Null initialisiert.  Der Rückgabewert muss nicht initialisiert werden, jeder Code, der in C und C ++ nicht undefiniert ist, muss sich darum kümmern.  Die letzte Anweisung ist ein bedingungsloser Übergang zur nächsten Basiseinheit (darüber sind wir noch nicht besorgt, die meisten unnötigen Übergänge werden vom LLVM-Backend gelöscht). <br><br>  Sie fragen sich vielleicht: Warum weist Clang Stapelschlitze für a und n zu?  Warum verwendet er diese Werte nicht direkt?  Da sich a und n in dieser Funktion nicht ändern, funktioniert eine solche Strategie. Dieser Fall wird jedoch vom Optimierer berücksichtigt und liegt außerhalb der Zuständigkeit von Calng.  Wenn a und n geändert werden können, sollten sie sich im Speicher befinden und keine SSA-Werte sein, die per Definition nur an einer Stelle im Programm einen Wert annehmen können.  Speicherzellen befinden sich außerhalb der SSA-Welt und können jederzeit geändert werden.  Dies mag seltsam erscheinen, aber mit einer solchen Lösung können Sie die Arbeit aller Teile des Compilers auf natürliche und effiziente Weise organisieren. <br><br>  Ich stelle mir Clang als einen Generator für entarteten SSA-Code vor, der alle Anforderungen von SSA erfüllt, aber nur, weil der Informationsaustausch zwischen den Basiseinheiten über den Speicher erfolgt.  Das Generieren von nicht entartetem Code erfordert einige Aufmerksamkeit und einige Analysen, und Clang-Entwickler lehnten dies ab, um die Verantwortlichkeiten für das Generieren und Optimieren des Codes zu trennen.  Ich habe die Messergebnisse nicht gesehen, aber nach meinem Verständnis werden viele Speicheroperationen generiert, und dann werden die meisten fast sofort vom Optimierer gelöscht, ohne dass dies zu einem hohen Aufwand an Kompilierungszeit führt. <br><br>  Überlegen Sie, wie die for-Schleife übersetzt wird.  Im Allgemeinen sieht es so aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (initializer; condition; modifier) { body }</code> </pre> <br>  Dies bedeutet ungefähr so: <br><br><pre> <code class="cpp hljs"> initializer <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> COND COND: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> BODY <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> EXIT BODY: body modifier <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> COND EXIT:</code> </pre> <br>  Natürlich ist eine solche Übersetzung nicht spezifisch für Clang, jeder C- und C ++ - Compiler macht dasselbe. <br><br>  In unserem Beispiel wird der Schleifeninitialisierer in den Eingabebasisblock eingeblendet.  Die folgende Basiseinheit ist eine Schleifenzustandsprüfung: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.cond: ; preds = %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.inc, %entry %<span class="hljs-number"><span class="hljs-number">0</span></span> = load i32, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">1</span></span> = load i32, i32* %n.addr, align <span class="hljs-number"><span class="hljs-number">4</span></span> %sub = sub nsw i32 %<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> %cmp = icmp slt i32 %<span class="hljs-number"><span class="hljs-number">0</span></span>, %sub br i1 %cmp, label %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.body, label %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.end</code> </pre> <br>  Clang macht auch einen nützlichen Kommentar, dass dieser Basisblock entweder von for.inc oder vom Eingabebasisblock aus erreichbar ist.  Dieser Block lädt i und n aus dem Speicher, reduziert n (das nsw-Flag spiegelt die C-Spracheigenschaft wider, dass der Vorzeichenüberlauf nicht definiert ist; ohne dieses Flag verwendet LLVM die Semantik des zusätzlichen Codes) und vergleicht den reduzierten Wert mit i unter Verwendung des slt (signiert kleiner als, signiere weniger als) und verzweige dann schließlich in die Basis für.body oder for.end Block. <br><br>  Der Zugang zum Schleifenkörper ist nur über den for.cond-Block möglich: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.body: %<span class="hljs-number"><span class="hljs-number">2</span></span> = load i32*, i32** %a.addr, align <span class="hljs-number"><span class="hljs-number">8</span></span> %<span class="hljs-number"><span class="hljs-number">3</span></span> = load i32, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> %idxprom = sext i32 %<span class="hljs-number"><span class="hljs-number">3</span></span> to i64 %arrayidx = getelementptr inbounds i32, i32* %<span class="hljs-number"><span class="hljs-number">2</span></span>, i64 %idxprom %<span class="hljs-number"><span class="hljs-number">4</span></span> = load i32, i32* %arrayidx, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">5</span></span> = load i32*, i32** %a.addr, align <span class="hljs-number"><span class="hljs-number">8</span></span> %<span class="hljs-number"><span class="hljs-number">6</span></span> = load i32, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> %add = add nsw i32 %<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> %idxprom1 = sext i32 %add to i64 %arrayidx2 = getelementptr inbounds i32, i32* %<span class="hljs-number"><span class="hljs-number">5</span></span>, i64 %idxprom1 %<span class="hljs-number"><span class="hljs-number">7</span></span> = load i32, i32* %arrayidx2, align <span class="hljs-number"><span class="hljs-number">4</span></span> %cmp3 = icmp sgt i32 %<span class="hljs-number"><span class="hljs-number">4</span></span>, %<span class="hljs-number"><span class="hljs-number">7</span></span> br i1 %cmp3, label %<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>.then, label %<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>.end</code> </pre> <br>  Die ersten beiden Zeilen laden a und i in die SSA-Register;  Ich expandiere dann auf 64 Bit und kann an der Berechnung der Adresse teilnehmen.  Der Befehl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">getelementptr</a> (oder kurz gep) ist der LLVM-Befehl, der für seine Anmaßung bekannt ist, und verfügt sogar über einen eigenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hilfeabschnitt</a> .  Im Gegensatz zur Maschinensprache behandelt LLVM Zeiger nicht als Ganzzahlen.  Dies erleichtert die Alias-Analyse und andere Speicheroptimierungen.  Dieser Code lädt ein [i] und ein [i + 1], vergleicht sie und führt je nach Ergebnis eine Verzweigung durch. <br><br>  Der if.then-Block speichert 0 für den Rückgabewert der Funktion im Stapelsteckplatz und springt bedingungslos zum Ausgabeblock der Funktion: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>.then: store i1 <span class="hljs-literal"><span class="hljs-literal">false</span></span>, i1* %retval, align <span class="hljs-number"><span class="hljs-number">1</span></span> br label %<span class="hljs-keyword"><span class="hljs-keyword">return</span></span></code> </pre> <br>  Der else-Block ist trivial: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>.end: br label %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.inc</code> </pre> <br>  Und der Block zum Hinzufügen einer zur Schleifenvariablen ist ebenfalls sehr einfach: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.inc: %<span class="hljs-number"><span class="hljs-number">8</span></span> = load i32, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> %inc = add nsw i32 %<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> store i32 %inc, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> br label %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.cond</code> </pre> <br>  Dieser Code springt zurück, um nach Schleifenbedingungen zu suchen. <br><br>  Wenn die Schleife normal abgeschlossen ist, geben wir true zurück: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.end: store i1 <span class="hljs-literal"><span class="hljs-literal">true</span></span>, i1* %retval, align <span class="hljs-number"><span class="hljs-number">1</span></span> br label %<span class="hljs-keyword"><span class="hljs-keyword">return</span></span></code> </pre> <br>  Und schließlich wird das, was wir in den Stapelschlitz des Rückgabewerts geladen haben, geladen und zurückgegeben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span>: %<span class="hljs-number"><span class="hljs-number">9</span></span> = load i1, i1* %retval, align <span class="hljs-number"><span class="hljs-number">1</span></span> ret i1 %<span class="hljs-number"><span class="hljs-number">9</span></span></code> </pre> <br>  Am Ende der Funktion gibt es nichts Besonderes.  Der Beitrag war länger als ich dachte. Im nächsten Beitrag werden wir überlegen, den IR-Pegel für diese Funktion zu optimieren. <br><br>  (Danke an Xi Wang und Alex Rosenberg für die Korrekturen) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431688/">https://habr.com/ru/post/de431688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431674/index.html">Nanoleaf Canvas: Bald an allen Wänden</a></li>
<li><a href="../de431676/index.html">Taktvoller Roboter: Kann zuhören und unterbricht nicht</a></li>
<li><a href="../de431678/index.html">Es gibt einen mobilen Entwickler im Wald, sieht - Kotlin brennt. Er saß in Kotlin und brannte nieder</a></li>
<li><a href="../de431682/index.html">Marriott hat personenbezogene Daten von 500 Millionen Kunden veröffentlicht</a></li>
<li><a href="../de431686/index.html">Außer IoT: Das Mirai-Botnetz hat einen Angriff auf Linux-Computer gestartet</a></li>
<li><a href="../de431690/index.html">Crackme von Kaspersky Lab lösen</a></li>
<li><a href="../de431692/index.html">Fortschritte in der Immuntherapie bei der Behandlung von Multipler Sklerose</a></li>
<li><a href="../de431694/index.html">Sortieren Sie "Turm von Hanoi"</a></li>
<li><a href="../de431696/index.html">Kodein. Die Grundlagen</a></li>
<li><a href="../de431698/index.html">Analyse der Fragen am Stand hh.ru auf # HolyJS18</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>