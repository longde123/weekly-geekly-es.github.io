<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèöÔ∏è üëé üíç Wie Clang eine Funktion kompiliert ‚òòÔ∏è üîÉ ‚òéÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich wollte einen Artikel dar√ºber schreiben, wie LLVM eine Funktion optimiert, aber zuerst m√ºssen Sie schreiben, wie Clang C oder C ++ in LLVM √ºbersetz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie Clang eine Funktion kompiliert</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431688/">  Ich wollte einen Artikel dar√ºber schreiben, wie LLVM eine Funktion optimiert, aber zuerst m√ºssen Sie schreiben, wie Clang C oder C ++ in LLVM √ºbersetzt. <br><br><img src="https://habrastorage.org/webt/df/9y/a9/df9ya9didizcjaetap9tjvfymzo.jpeg" alt="Bild"><br><a name="habracut"></a><br><br>  Betrachten Sie die Aspekte auf hoher Ebene, ohne in die Tiefen von Clang einzutauchen.  Ich m√∂chte darauf achten, wie die Clang-Ausgabe mit der Eingabe zusammenh√§ngt, w√§hrend wir die nicht trivialen Funktionen von C ++ nicht ber√ºcksichtigen.  Wir verwenden diese kleine Funktion, die ich aus hervorragenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorlesungen √ºber zyklische Optimierungen</a> entlehnt habe: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_sorted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[i] &gt; a[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Da Clang keine Optimierungen vornimmt und LLVM IR urspr√ºnglich f√ºr C und C ++ entwickelt wurde, ist die Konvertierung relativ einfach.  Ich werde Clang 6.0.1 (oder eine nahe Version, da diese noch nicht ver√∂ffentlicht wurde) auf x86-64 verwenden. <br><br>  Die Befehlszeile lautet wie folgt: <br><br><pre> <code class="bash hljs">clang++ is_sorted.cpp -O0 -S -emit-llvm</code> </pre> <br>  Mit anderen Worten: Wir kompilieren die Datei is_sorted.cpp als C ++ und teilen der LLVM-Toolchain Folgendes mit: Nicht optimieren, den Assembler als Textdarstellung von LLVM-IR ausgeben.  LLVM IR ist umfangreich und kann nicht schnell angezeigt oder analysiert werden. Ein bin√§res Bitcode-Format ist immer vorzuziehen, wenn eine Person diesen Code nicht betrachten muss.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> ist die vollst√§ndige LLVM-IR, wir werden sie in Teilen √ºberpr√ºfen. <br><br>  Beginnen wir oben in der Datei: <br><br><pre> <code class="cpp hljs">; ModuleID = <span class="hljs-string"><span class="hljs-string">'is_sorted.cpp'</span></span> source_filename = <span class="hljs-string"><span class="hljs-string">"is_sorted.cpp"</span></span> target datalayout = <span class="hljs-string"><span class="hljs-string">"em:e-i64:64-f80:128-n8:16:32:64-S128"</span></span> target triple = <span class="hljs-string"><span class="hljs-string">"x86_64-unknown-linux-gnu"</span></span></code> </pre> <br>  Der gesamte Text zwischen dem Semikolon und dem Ende der Zeile ist ein Kommentar, was bedeutet, dass die erste Zeile nichts bewirkt. Wenn Sie jedoch an LLVM interessiert sind, ist ein ‚ÄûModul‚Äú eine Kompilierungseinheit, ein Container f√ºr Code und Daten.  Die zweite Zeile sollte uns auch nicht st√∂ren.  In der dritten Zeile werden einige vom Compiler getroffene Annahmen beschrieben. Sie spielen in diesem Artikel keine Rolle. Weitere Informationen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Ziel drei</a> ist das Erbe von gcc und braucht uns nicht mehr. <br><br>  Die LLVM-Funktion verf√ºgt √ºber optionale Attribute: <br><br><pre> <code class="cpp hljs">; Function Attrs: noinline nounwind optnone uwtable</code> </pre> <br>  Einige von ihnen (wie diese) werden vom Front-End unterst√ºtzt, andere werden sp√§ter durch Optimierungsdurchl√§ufe hinzugef√ºgt.  Diese Attribute haben nichts mit der Bedeutung des Codes zu tun. Ich werde sie hier nicht diskutieren, aber Sie k√∂nnen sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> lesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> wenn Sie interessiert sind. <br><br>  Und schlie√ülich unsere Funktion: <br><br><pre> <code class="bash hljs">define zeroext i1 @_Z9is_sortedPii(i32* %a, i32 %n) <span class="hljs-comment"><span class="hljs-comment">#0 {</span></span></code> </pre> <br>  "Zeroext" bedeutet, dass der R√ºckgabewert der Funktion (i1, eine Einzelbit-Ganzzahl) im Backend mit Nullen auf die vom ABI ben√∂tigte Breite erweitert werden muss.  Dann kommt der "verst√ºmmelte" Funktionsname, dann ist die Liste der Parameter im Grunde die gleiche wie im C ++ - Code, au√üer dass i32 eine 32-Bit-Variable definiert.  # 0 verbindet die Funktion mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Attributgruppe</a> am Ende der Datei. <br><br>  Hier ist die erste Basiseinheit: <br><br><pre> <code class="cpp hljs">entry: %retval = alloca i1, align <span class="hljs-number"><span class="hljs-number">1</span></span> %a.addr = alloca i32*, align <span class="hljs-number"><span class="hljs-number">8</span></span> %n.addr = alloca i32, align <span class="hljs-number"><span class="hljs-number">4</span></span> %i = alloca i32, align <span class="hljs-number"><span class="hljs-number">4</span></span> store i32* %a, i32** %a.addr, align <span class="hljs-number"><span class="hljs-number">8</span></span> store i32 %n, i32* %n.addr, align <span class="hljs-number"><span class="hljs-number">4</span></span> store i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> br label %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.cond</code> </pre> <br>  Jeder LLVM-Befehl muss sich innerhalb der Basiseinheit befinden: ein Befehlssatz mit einem Eingang am Anfang und einem Ausgang am Ende.  Die letzte Anweisung der Basiseinheit muss eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beendigungsanweisung sein</a> : "Fehler" in der n√§chsten Basiseinheit ist nicht zul√§ssig.  Jede Funktion muss einen Eingabeblock haben, der keine Vorg√§nger hat, die den √úbergang zu diesem Block ausf√ºhren.  Diese und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">andere Eigenschaften</a> werden beim Parsen von IR √ºberpr√ºft. Diese √úberpr√ºfungen k√∂nnen auch w√§hrend des Kompilierungsprozesses vom ‚ÄûModulpr√ºfer‚Äú mehrmals aufgerufen werden.  Der Verifizierer ist n√ºtzlich zum Debuggen, wenn ein Durchlauf eine ung√ºltige IR generiert. <br><br>  Die ersten vier Anweisungen in diesem Basisblock lauten "alloca": Zuweisen des Stapelspeichers.  Die ersten drei erstellen Variablen, die implizit w√§hrend der Kompilierung erstellt werden, die vierte - eine Schleifenvariable.  Auf diese Weise zugewiesene Variablen k√∂nnen nur √ºber Lade- und Speicheranweisungen aufgerufen werden.  Die folgenden drei Anweisungen initialisieren die drei Stapelschlitze a.addr und n.addr werden unter Verwendung der an die Funktion als Parameter √ºbergebenen Werte initialisiert, und i wird auf Null initialisiert.  Der R√ºckgabewert muss nicht initialisiert werden, jeder Code, der in C und C ++ nicht undefiniert ist, muss sich darum k√ºmmern.  Die letzte Anweisung ist ein bedingungsloser √úbergang zur n√§chsten Basiseinheit (dar√ºber sind wir noch nicht besorgt, die meisten unn√∂tigen √úberg√§nge werden vom LLVM-Backend gel√∂scht). <br><br>  Sie fragen sich vielleicht: Warum weist Clang Stapelschlitze f√ºr a und n zu?  Warum verwendet er diese Werte nicht direkt?  Da sich a und n in dieser Funktion nicht √§ndern, funktioniert eine solche Strategie. Dieser Fall wird jedoch vom Optimierer ber√ºcksichtigt und liegt au√üerhalb der Zust√§ndigkeit von Calng.  Wenn a und n ge√§ndert werden k√∂nnen, sollten sie sich im Speicher befinden und keine SSA-Werte sein, die per Definition nur an einer Stelle im Programm einen Wert annehmen k√∂nnen.  Speicherzellen befinden sich au√üerhalb der SSA-Welt und k√∂nnen jederzeit ge√§ndert werden.  Dies mag seltsam erscheinen, aber mit einer solchen L√∂sung k√∂nnen Sie die Arbeit aller Teile des Compilers auf nat√ºrliche und effiziente Weise organisieren. <br><br>  Ich stelle mir Clang als einen Generator f√ºr entarteten SSA-Code vor, der alle Anforderungen von SSA erf√ºllt, aber nur, weil der Informationsaustausch zwischen den Basiseinheiten √ºber den Speicher erfolgt.  Das Generieren von nicht entartetem Code erfordert einige Aufmerksamkeit und einige Analysen, und Clang-Entwickler lehnten dies ab, um die Verantwortlichkeiten f√ºr das Generieren und Optimieren des Codes zu trennen.  Ich habe die Messergebnisse nicht gesehen, aber nach meinem Verst√§ndnis werden viele Speicheroperationen generiert, und dann werden die meisten fast sofort vom Optimierer gel√∂scht, ohne dass dies zu einem hohen Aufwand an Kompilierungszeit f√ºhrt. <br><br>  √úberlegen Sie, wie die for-Schleife √ºbersetzt wird.  Im Allgemeinen sieht es so aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (initializer; condition; modifier) { body }</code> </pre> <br>  Dies bedeutet ungef√§hr so: <br><br><pre> <code class="cpp hljs"> initializer <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> COND COND: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> BODY <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> EXIT BODY: body modifier <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> COND EXIT:</code> </pre> <br>  Nat√ºrlich ist eine solche √úbersetzung nicht spezifisch f√ºr Clang, jeder C- und C ++ - Compiler macht dasselbe. <br><br>  In unserem Beispiel wird der Schleifeninitialisierer in den Eingabebasisblock eingeblendet.  Die folgende Basiseinheit ist eine Schleifenzustandspr√ºfung: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.cond: ; preds = %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.inc, %entry %<span class="hljs-number"><span class="hljs-number">0</span></span> = load i32, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">1</span></span> = load i32, i32* %n.addr, align <span class="hljs-number"><span class="hljs-number">4</span></span> %sub = sub nsw i32 %<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> %cmp = icmp slt i32 %<span class="hljs-number"><span class="hljs-number">0</span></span>, %sub br i1 %cmp, label %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.body, label %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.end</code> </pre> <br>  Clang macht auch einen n√ºtzlichen Kommentar, dass dieser Basisblock entweder von for.inc oder vom Eingabebasisblock aus erreichbar ist.  Dieser Block l√§dt i und n aus dem Speicher, reduziert n (das nsw-Flag spiegelt die C-Spracheigenschaft wider, dass der Vorzeichen√ºberlauf nicht definiert ist; ohne dieses Flag verwendet LLVM die Semantik des zus√§tzlichen Codes) und vergleicht den reduzierten Wert mit i unter Verwendung des slt (signiert kleiner als, signiere weniger als) und verzweige dann schlie√ülich in die Basis f√ºr.body oder for.end Block. <br><br>  Der Zugang zum Schleifenk√∂rper ist nur √ºber den for.cond-Block m√∂glich: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.body: %<span class="hljs-number"><span class="hljs-number">2</span></span> = load i32*, i32** %a.addr, align <span class="hljs-number"><span class="hljs-number">8</span></span> %<span class="hljs-number"><span class="hljs-number">3</span></span> = load i32, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> %idxprom = sext i32 %<span class="hljs-number"><span class="hljs-number">3</span></span> to i64 %arrayidx = getelementptr inbounds i32, i32* %<span class="hljs-number"><span class="hljs-number">2</span></span>, i64 %idxprom %<span class="hljs-number"><span class="hljs-number">4</span></span> = load i32, i32* %arrayidx, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">5</span></span> = load i32*, i32** %a.addr, align <span class="hljs-number"><span class="hljs-number">8</span></span> %<span class="hljs-number"><span class="hljs-number">6</span></span> = load i32, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> %add = add nsw i32 %<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> %idxprom1 = sext i32 %add to i64 %arrayidx2 = getelementptr inbounds i32, i32* %<span class="hljs-number"><span class="hljs-number">5</span></span>, i64 %idxprom1 %<span class="hljs-number"><span class="hljs-number">7</span></span> = load i32, i32* %arrayidx2, align <span class="hljs-number"><span class="hljs-number">4</span></span> %cmp3 = icmp sgt i32 %<span class="hljs-number"><span class="hljs-number">4</span></span>, %<span class="hljs-number"><span class="hljs-number">7</span></span> br i1 %cmp3, label %<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>.then, label %<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>.end</code> </pre> <br>  Die ersten beiden Zeilen laden a und i in die SSA-Register;  Ich expandiere dann auf 64 Bit und kann an der Berechnung der Adresse teilnehmen.  Der Befehl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">getelementptr</a> (oder kurz gep) ist der LLVM-Befehl, der f√ºr seine Anma√üung bekannt ist, und verf√ºgt sogar √ºber einen eigenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hilfeabschnitt</a> .  Im Gegensatz zur Maschinensprache behandelt LLVM Zeiger nicht als Ganzzahlen.  Dies erleichtert die Alias-Analyse und andere Speicheroptimierungen.  Dieser Code l√§dt ein [i] und ein [i + 1], vergleicht sie und f√ºhrt je nach Ergebnis eine Verzweigung durch. <br><br>  Der if.then-Block speichert 0 f√ºr den R√ºckgabewert der Funktion im Stapelsteckplatz und springt bedingungslos zum Ausgabeblock der Funktion: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>.then: store i1 <span class="hljs-literal"><span class="hljs-literal">false</span></span>, i1* %retval, align <span class="hljs-number"><span class="hljs-number">1</span></span> br label %<span class="hljs-keyword"><span class="hljs-keyword">return</span></span></code> </pre> <br>  Der else-Block ist trivial: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>.end: br label %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.inc</code> </pre> <br>  Und der Block zum Hinzuf√ºgen einer zur Schleifenvariablen ist ebenfalls sehr einfach: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.inc: %<span class="hljs-number"><span class="hljs-number">8</span></span> = load i32, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> %inc = add nsw i32 %<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> store i32 %inc, i32* %i, align <span class="hljs-number"><span class="hljs-number">4</span></span> br label %<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.cond</code> </pre> <br>  Dieser Code springt zur√ºck, um nach Schleifenbedingungen zu suchen. <br><br>  Wenn die Schleife normal abgeschlossen ist, geben wir true zur√ºck: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>.end: store i1 <span class="hljs-literal"><span class="hljs-literal">true</span></span>, i1* %retval, align <span class="hljs-number"><span class="hljs-number">1</span></span> br label %<span class="hljs-keyword"><span class="hljs-keyword">return</span></span></code> </pre> <br>  Und schlie√ülich wird das, was wir in den Stapelschlitz des R√ºckgabewerts geladen haben, geladen und zur√ºckgegeben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span>: %<span class="hljs-number"><span class="hljs-number">9</span></span> = load i1, i1* %retval, align <span class="hljs-number"><span class="hljs-number">1</span></span> ret i1 %<span class="hljs-number"><span class="hljs-number">9</span></span></code> </pre> <br>  Am Ende der Funktion gibt es nichts Besonderes.  Der Beitrag war l√§nger als ich dachte. Im n√§chsten Beitrag werden wir √ºberlegen, den IR-Pegel f√ºr diese Funktion zu optimieren. <br><br>  (Danke an Xi Wang und Alex Rosenberg f√ºr die Korrekturen) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431688/">https://habr.com/ru/post/de431688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431674/index.html">Nanoleaf Canvas: Bald an allen W√§nden</a></li>
<li><a href="../de431676/index.html">Taktvoller Roboter: Kann zuh√∂ren und unterbricht nicht</a></li>
<li><a href="../de431678/index.html">Es gibt einen mobilen Entwickler im Wald, sieht - Kotlin brennt. Er sa√ü in Kotlin und brannte nieder</a></li>
<li><a href="../de431682/index.html">Marriott hat personenbezogene Daten von 500 Millionen Kunden ver√∂ffentlicht</a></li>
<li><a href="../de431686/index.html">Au√üer IoT: Das Mirai-Botnetz hat einen Angriff auf Linux-Computer gestartet</a></li>
<li><a href="../de431690/index.html">Crackme von Kaspersky Lab l√∂sen</a></li>
<li><a href="../de431692/index.html">Fortschritte in der Immuntherapie bei der Behandlung von Multipler Sklerose</a></li>
<li><a href="../de431694/index.html">Sortieren Sie "Turm von Hanoi"</a></li>
<li><a href="../de431696/index.html">Kodein. Die Grundlagen</a></li>
<li><a href="../de431698/index.html">Analyse der Fragen am Stand hh.ru auf # HolyJS18</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>