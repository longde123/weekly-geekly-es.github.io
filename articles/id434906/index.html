<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖱️ 🧚 👩🏻‍✈️ Tes dalam C ++ tanpa makro dan memori dinamis ⛹🏻 🦑 🈴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Banyak perpustakaan populer untuk pengujian, misalnya Google Test, Catch2, Boost.Test, sangat terkait dengan penggunaan makro, jadi sebagai contoh pen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tes dalam C ++ tanpa makro dan memori dinamis</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434906/"><p> Banyak perpustakaan populer untuk pengujian, misalnya Google Test, Catch2, Boost.Test, sangat terkait dengan penggunaan makro, jadi sebagai contoh pengujian di perpustakaan ini, Anda biasanya melihat gambar seperti ini: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Tests the default c'tor. TEST(MyString, DefaultConstructor) { const MyString s; EXPECT_STREQ(nullptr, s.c_string()); EXPECT_EQ(0u, s.Length()); } const char kHelloString[] = "Hello, world!"; // Tests the c'tor that accepts a C string. TEST(MyString, ConstructorFromCString) { const MyString s(kHelloString); EXPECT_EQ(0, strcmp(s.c_string(), kHelloString)); EXPECT_EQ(sizeof(kHelloString)/sizeof(kHelloString[0]) - 1, s.Length()); } // Tests the copy c'tor. TEST(MyString, CopyConstructor) { const MyString s1(kHelloString); const MyString s2 = s1; EXPECT_EQ(0, strcmp(s2.c_string(), kHelloString)); } } // namespace</span></span></code> </pre> <br><p>  Macro di C ++ waspada, mengapa mereka begitu berkembang di perpustakaan untuk membuat tes? </p><a name="habracut"></a><br><p>  Pustaka tes unit harus memberi para penggunanya cara untuk menulis tes sehingga runtime tes dapat menemukan dan menjalankannya dengan cara apa pun.  Ketika Anda berpikir tentang cara melakukan ini, menggunakan makro tampaknya paling mudah.  Makro TEST () biasanya mendefinisikan fungsi (dalam kasus Google Test, makro juga membuat kelas) dan memastikan bahwa alamat fungsi ini masuk ke beberapa wadah global. </p><br><p>  Pustaka yang terkenal di mana pendekatan tanpa makro tunggal dilaksanakan adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kerangka kerja tut</a> .  Mari kita lihat contohnya dari tutorial: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;tut/tut.hpp&gt; namespace tut { struct basic{}; typedef test_group&lt;basic&gt; factory; typedef factory::object object; } namespace { tut::factory tf("basic test"); } namespace tut { template&lt;&gt; template&lt;&gt; void object::test&lt;1&gt;() { ensure_equals("2+2=?", 2+2, 4); } }</span></span></span></span></code> </pre> <br><p>  Gagasan yang mendasari cukup menarik dan berhasil, itu tidak terlalu sulit.  Singkatnya, Anda memiliki kelas dasar yang mengimplementasikan fungsi template yang melibatkan parameterisasi dengan integer: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test_object</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Data { <span class="hljs-comment"><span class="hljs-comment">/** * Default do-nothing test. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ called_method_was_a_dummy_test_ = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Sekarang ketika Anda menulis tes seperti itu: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> object::test&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;() { ensure_equals(<span class="hljs-string"><span class="hljs-string">"2+2=?"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); }</code> </pre> <br><p>  Anda benar-benar membuat spesialisasi metode pengujian untuk angka tertentu N = 1 (inilah persisnya <code>template&lt;&gt;template&lt;&gt;</code> singkatan).  Dengan memanggil <code>test&lt;N&gt;()</code> runtime tes dapat memahami apakah itu tes yang sebenarnya atau itu adalah rintisan melihat nilai yang <code>called_method_was_a_dummy_test_</code> setelah tes dieksekusi. </p><br><p>  Berikutnya, ketika Anda mendeklarasikan grup uji: </p><br><pre> <code class="cpp hljs">tut::<span class="hljs-function"><span class="hljs-function">factory </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"basic test"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br><p>  Pertama, Anda menghitung semua <code>test&lt;N&gt;</code> ke konstanta tertentu yang ditransfer ke perpustakaan, dan kedua, dengan efek samping, Anda menambahkan informasi tentang grup ke wadah global (nama grup dan alamat semua fungsi tes). </p><br><p>  Pengecualian digunakan sebagai kondisi pengujian dalam tut, jadi fungsi <code>tut::ensure_equals()</code> akan dengan mudah melempar pengecualian jika dua nilai yang diteruskan ke sana tidak sama, dan lingkungan uji coba akan menangkap pengecualian dan menganggap pengujian gagal.  Saya suka pendekatan ini, segera menjadi jelas bagi pengembang C ++ mana pun pernyataan seperti itu dapat digunakan.  Misalnya, jika pengujian saya membuat utas bantu, maka tidak ada gunanya menempatkan pernyataan di sana, tidak ada yang akan menangkapnya.  Selain itu, jelas bagi saya bahwa pengujian saya harus dapat membebaskan sumber daya jika terjadi pengecualian, seolah-olah itu adalah kode aman-pengecualian biasa. </p><br><p>  Pada prinsipnya, perpustakaan tut-framework terlihat cukup bagus, tetapi ada beberapa kelemahan dalam implementasinya.  Sebagai contoh, untuk kasus saya, saya ingin tes tidak hanya memiliki angka, tetapi juga atribut lainnya, khususnya nama, serta "ukuran" tes (misalnya, apakah itu tes integrasi atau tes unit).  Ini dapat dipecahkan dalam kerangka tut API, dan bahkan sesuatu sudah ada, dan sesuatu dapat diterapkan jika Anda menambahkan metode ke pustaka API dan memanggilnya ke badan tes untuk mengatur salah satu parameternya: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> object::test&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;() { set_name(<span class="hljs-string"><span class="hljs-string">"2+2"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Set test name to be shown in test report ensure_equals("2+2=?", 2+2, 4); }</span></span></code> </pre> <br><p>  Masalah lain adalah bahwa lingkungan uji coba tut tidak tahu apa-apa tentang peristiwa seperti awal tes.  Lingkungan mengeksekusi <code>object::test&lt;N&gt;()</code> dan tidak tahu sebelumnya apakah tes diimplementasikan untuk N yang diberikan, atau itu hanya sebuah rintisan.  Dia hanya <code>called_method_was_a_dummy_test_</code> kapan tes selesai dengan menganalisis nilai yang <code>called_method_was_a_dummy_test_</code> .  Fitur ini tidak menunjukkan dirinya dengan sangat baik dalam sistem CI, yang dapat mengelompokkan output yang dibuat oleh program antara awal dan akhir pengujian. </p><br><p>  Namun, menurut pendapat saya, hal utama yang dapat ditingkatkan ("kesalahan fatal") adalah adanya kode tambahan yang diperlukan untuk menulis tes.  Ada cukup banyak hal dalam tutorial tut-framework: diusulkan untuk terlebih dahulu membuat kelas <code>struct basic{}</code> , dan menggambarkan tes sebagai metode objek yang terkait dengan ini.  Di kelas ini, Anda dapat menentukan metode dan data yang ingin Anda gunakan dalam kelompok uji, dan konstruktor dan destruktor membingkai pelaksanaan tes, menciptakan hal seperti fixture dari jUnit.  Dalam latihan saya dengan tut, objek ini hampir selalu kosong, tetapi ia menyeret sejumlah baris kode tertentu. </p><br><p>  Jadi, kami pergi ke bengkel sepeda dan mencoba mengatur idenya dalam bentuk perpustakaan kecil. </p><br><p>  Seperti inilah tampilan file tes minimal di perpustakaan yang diuji: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Test group for std::vector (illustrative purposes) #include "tested.h" #include &lt;vector&gt; template&lt;&gt; void tested::Case&lt;CASE_COUNTER&gt;(tested::IRuntime* runtime) { runtime-&gt;StartCase("emptiness"); std::vector&lt;int&gt; vec; tested::Is(vec.empty(), "Vector must be empty by default"); } template&lt;&gt; void tested::Case&lt;CASE_COUNTER&gt;(tested::IRuntime* runtime) { runtime-&gt;StartCase("AddElement"); std::vector&lt;int&gt; vec; vec.push_back(1); tested::Is(vec.size() == 1); tested::Is(vec[0] == 1); tested::FailIf(vec.empty()); } void LinkVectorTests() { static tested::Group&lt;CASE_COUNTER&gt; x("std.vector", __FILE__); }</span></span></code> </pre> <br><p>  Selain kekurangan makro, bonusnya adalah kurangnya memori dinamis di dalam perpustakaan. </p><br><h3 id="opredelenie-test-keysov">  Definisi kasus uji </h3><br><p>  Untuk pendaftaran tes, sihir tingkat dasar entri digunakan pada prinsip yang sama dengan tut.  Di suatu tempat di diuji. Ada fungsi boilerplate semacam ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Case</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IRuntime* runtime)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> TheCaseIsAStub(); }</code> </pre> <br><p>  Kasus uji yang ditulis oleh pengguna perpustakaan hanyalah spesialisasi dari metode ini.  Fungsi ini dinyatakan statis, mis.  di setiap unit terjemahan, kami membuat spesialisasi yang tidak bersinggungan dengan nama satu sama lain selama penautan. </p><br><p>  Ada aturan seperti itu yang pertama kali Anda perlu panggil <code>StartCase()</code> , di mana Anda bisa lulus hal-hal seperti nama tes dan mungkin beberapa hal lain yang masih dalam pengembangan. </p><br><p>  Ketika tes memanggil <code>runtime-&gt;StartTest()</code> , hal-hal menarik dapat terjadi.  Pertama, jika tes sekarang dalam mode jalankan, maka Anda dapat memberi tahu suatu tempat bahwa tes telah mulai dieksekusi.  Kedua, jika ada mode pengumpulan informasi tentang tes yang tersedia, <code>StartTest()</code> melempar jenis pengecualian khusus yang akan berarti bahwa tes itu nyata, dan bukan rintisan. </p><br><h3 id="registraciya">  Pendaftaran </h3><br><p>  Pada titik tertentu, Anda perlu mengumpulkan alamat semua kotak uji dan menyimpannya di suatu tempat.  Dalam menguji, ini dilakukan dengan menggunakan kelompok.  Konstruktor kelas Grup :: teruji melakukan ini sebagai efek samping: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> tested::Group&lt;CASE_COUNTER&gt; x(<span class="hljs-string"><span class="hljs-string">"std.vector"</span></span>, __FILE__);</code> </pre> <br><p>  Konstruktor membuat grup dengan nama yang ditentukan dan menambahkannya semua <code>Case&lt;N&gt;</code> yang ditemukan di unit terjemahan saat ini.  Ternyata dalam satu unit terjemahan Anda tidak dapat memiliki dua grup.  Ini juga berarti bahwa Anda tidak dapat membagi satu grup menjadi beberapa unit terjemahan. </p><br><p>  Parameter template adalah berapa banyak kasus uji yang harus dicari dalam unit terjemahan saat ini untuk grup yang dibuat. </p><br><h3 id="linkovka">  Tautan </h3><br><p>  Dalam contoh di atas, penciptaan objek yang diuji :: Group () terjadi di dalam fungsi yang harus kita panggil dari aplikasi kita untuk mendaftarkan tes: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LinkStdVectorTests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> tested::Group&lt;CASE_COUNTER&gt; x(<span class="hljs-string"><span class="hljs-string">"std.vector"</span></span>, __FILE__); }</code> </pre> <br><p>  Fungsi tidak selalu diperlukan, kadang-kadang Anda bisa mendeklarasikan objek dari kelas <code>tested::Group</code> di dalam file.  Namun, pengalaman saya adalah bahwa tautan kadang-kadang "mengoptimalkan" seluruh file jika dirakit di dalam perpustakaan, dan tidak ada aplikasi utama yang menggunakan karakter apa pun dari file cpp ini: </p><br><pre> <code class="plaintext hljs">calc.lib &lt;- calc_test.lib(calc_test.cpp) ^ ^ | | app.exe run_test.exe</code> </pre> <br><p>  Ketika calc_test.cpp tidak ditautkan dari sumber run_test.exe, penghubung hanya menghapus file ini dari pertimbangan seluruhnya, bersama dengan penciptaan objek statis, meskipun faktanya ia memiliki efek samping yang kita butuhkan. </p><br><p>  Jika rantai mana yang dihasilkan dari run_test.exe, maka objek statis akan muncul di file yang dapat dieksekusi.  Dan tidak masalah bagaimana ini dilakukan, seperti dalam contoh: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LinkStdVectorTests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> tested::Group&lt;CASE_COUNTER&gt; x(<span class="hljs-string"><span class="hljs-string">"std.vector"</span></span>, __FILE__); }</code> </pre> <br><p>  atau lebih: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> tested::Group&lt;CASE_COUNTER&gt; x(<span class="hljs-string"><span class="hljs-string">"std.vector"</span></span>, __FILE__); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LinkStdVectorTests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br><p>  Opsi pertama, menurut saya, lebih baik karena konstruktor dipanggil setelah dimulainya main (), dan aplikasi memiliki kontrol atas proses ini. </p><br><p>  Saya pikir pengaturan kruk ini diperlukan untuk setiap perpustakaan pengujian unit yang menggunakan variabel global dan efek samping dari konstruktor untuk membuat database pengujian.  Namun, itu mungkin dapat dihindari dengan menghubungkan pustaka uji dengan kunci - seluruh arsip (analog di MSVC hanya muncul di Visual Studio 2015.3). </p><br><h3 id="makrosy">  Makro </h3><br><p>  Saya berjanji bahwa tidak akan ada makro, tapi itu - <code>CASE_COUNTER</code> .  Opsi kerjanya adalah bahwa ia digunakan oleh <code>__COUNTER__</code> , makro yang ditambahkan oleh kompiler setiap kali digunakan di dalam unit terjemahan. <br>  Didukung oleh GCC, CLANG, MSVC, tetapi tidak standar.  Jika ini membuat frustrasi, berikut adalah beberapa alternatif: </p><br><ul><li>  gunakan angka 0, 1, 2 </li><li>  gunakan <code>__LINE__</code> standar. </li><li>  gunakan sihir constexpr level 80.  Anda dapat mencari "penghitung constexpr" dan mencoba menemukan kompiler yang akan berfungsi. </li></ul><br><p>  Masalah dengan <code>__LINE__</code> adalah bahwa menggunakan angka besar dalam opsi templat membuat ukuran file besar yang dapat dieksekusi.  Itu sebabnya saya membatasi jenis pola char yang ditandatangani menjadi 128 sebagai jumlah tes maksimum dalam grup. </p><br><h3 id="otkaz-ot-dinamicheskoy-pamyati">  Kegagalan memori dinamis </h3><br><p>  Ternyata saat mendaftar tes, Anda tidak dapat menggunakan memori dinamis, yang saya gunakan.  Ada kemungkinan bahwa lingkungan Anda tidak memiliki memori dinamis atau Anda menggunakan pencarian untuk kebocoran memori dalam kasus uji, sehingga intervensi dari lingkungan pelaksanaan tes bukan yang Anda butuhkan.  Google Test sedang bergumul dengan ini, berikut ini cuplikan dari sana: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Use the RAII idiom to flag mem allocs that are intentionally never // deallocated. The motivation is to silence the false positive mem leaks // that are reported by the debug version of MS's CRT which can only detect // if an alloc is missing a matching deallocation. // Example: // MemoryIsNotDeallocated memory_is_not_deallocated; // critical_section_ = new CRITICAL_SECTION; class MemoryIsNotDeallocated</span></span></code> </pre> <br><p>  Dan kita tidak bisa membuat kesulitan. </p><br><p>  Lalu bagaimana kita mendapatkan daftar tes?  Ini lebih internal teknis, yang lebih mudah dilihat dalam kode sumber, tetapi saya akan memberitahu Anda. </p><br><p>  Saat membuat grup, kelasnya akan menerima pointer ke fungsi <code>tested::CaseCollector&lt;CASE_COUNTER&gt;::collect</code> , yang akan mengumpulkan semua tes unit terjemahan ke dalam daftar.  Begini cara kerjanya: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Make the anonymouse namespace to have instances be hidden to specific translation unit namespace { template &lt;Ordinal_t N&gt; struct CaseCollector { // Test runtime that collects the test case struct CollectorRuntime final : IRuntime { void StartCase(const char* caseName, const char* description = nullptr) final { // the trick is exit from test case function into the collector via throw throw CaseIsReal(); } }; // Finds the Case&lt;N&gt; function in current translation unit and adds into the static list. It uses the // reverse order, so the case executed in order of appearance in C++ file. static CaseListEntry* collect(CaseListEntry* tail) { CaseListEntry* current = nullptr; CollectorRuntime collector; try { Case&lt;N&gt;(&amp;collector); } catch (CaseIsStub) { current = tail; } catch (CaseIsReal) { s_caseListEntry.CaseProc = Case&lt;N&gt;; s_caseListEntry.Next = tail; s_caseListEntry.Ordinal = N; current = &amp;s_caseListEntry; } return CaseCollector&lt;N - 1&gt;::collect(current); } private: static CaseListEntry s_caseListEntry; }; // This static storage will be instantiated in any cpp file template &lt;Ordinal_t N&gt; CaseListEntry CaseCollector&lt;N&gt;::s_caseListEntry; }</span></span></code> </pre> <br><p>  Ternyata di setiap unit terjemahan banyak variabel statis tipe CaseListEntry CaseCollector \ :: s_caseListEntry dibuat, yang merupakan elemen dari daftar tes, dan metode collect () mengumpulkan elemen-elemen ini dalam daftar yang terhubung secara tunggal.  Dengan cara yang kira-kira sama, daftar ini membentuk kelompok-kelompok tes, tetapi tanpa pola dan rekursi. <br></p><br><h3 id="struktura">  Struktur </h3><br><p>  Tes memerlukan pengikatan yang berbeda, seperti output ke konsol dalam huruf merah Gagal, membuat laporan pengujian dalam format yang dapat dimengerti untuk CI atau GUI di mana Anda dapat melihat daftar tes dan menjalankan yang dipilih - secara umum, banyak hal.  Saya memiliki visi tentang bagaimana hal ini dapat dilakukan, yang berbeda dari apa yang saya lihat sebelumnya di perpustakaan pengujian.  Klaim ini terutama untuk perpustakaan yang menyebut diri mereka "hanya header", sementara termasuk sejumlah besar kode, yang pada dasarnya bukan untuk file header. </p><br><p>  Pendekatan yang saya asumsikan adalah bahwa kita membagi perpustakaan menjadi front-end - ini diuji.h dan back-end perpustakaan sendiri.  Untuk menulis tes, Anda hanya perlu diuji.h, yang sekarang C ++ 17 (karena std :: std :: string_view) tetapi diasumsikan bahwa akan ada C ++ 98.  Tested.h benar-benar melakukan registrasi dan mencari tes, opsi peluncuran yang minimal nyaman, serta kemampuan untuk mengekspor tes (grup, alamat fungsi kasus uji).  Pustaka back-end yang belum ada dapat melakukan apa pun yang mereka butuhkan dalam hal menghasilkan hasil dan meluncurkan menggunakan fungsi ekspor.  Dengan cara yang sama, Anda dapat menyesuaikan peluncuran dengan kebutuhan proyek Anda. </p><br><h3 id="itog">  Ringkasan </h3><br><p>  Pustaka yang diuji ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode github</a> ) masih membutuhkan beberapa stabilisasi.  Dalam waktu dekat, tambahkan kemampuan untuk menjalankan tes asinkron (diperlukan untuk tes integrasi di WebAssembly) dan tunjukkan ukuran tes.  Menurut pendapat saya, perpustakaan masih belum cukup siap untuk penggunaan produksi, tetapi tiba-tiba saya menghabiskan banyak waktu dan panggung telah berhenti, mengambil napas dan meminta umpan balik dari masyarakat.  Apakah Anda tertarik untuk menggunakan perpustakaan semacam ini?  Mungkin ada ide lain di gudang C ++ karena mungkin untuk membuat perpustakaan tanpa makro?  Apakah pernyataan masalah seperti itu menarik sama sekali? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id434906/">https://habr.com/ru/post/id434906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id434892/index.html">Menggambar kode dalam Swift, PaintCode</a></li>
<li><a href="../id434894/index.html">Seni perdukunan atau firmware khusus untuk Olinuxino. Bagian 1</a></li>
<li><a href="../id434896/index.html">Hall of Fame Elektronik Konsumen: Kisah Gadget Terbaik 50 Tahun Terakhir, Bagian 1</a></li>
<li><a href="../id434898/index.html">Grasp2Vec: Belajar Mewakili Objek melalui Capture Belajar Mandiri</a></li>
<li><a href="../id434902/index.html">Membuat Generator Permintaan Kustom di Data Musim Semi Neo4j (Bagian 1)</a></li>
<li><a href="../id434908/index.html">Pendidikan Programmer - Apa? Dimana? Kapan?</a></li>
<li><a href="../id434912/index.html">Stok tahunan Porsche Taycan sudah dipesan, terutama oleh pemilik Tesla</a></li>
<li><a href="../id434924/index.html">Apa yang harus dibaca tentang organisasi tempat kerja, rekan kerja, dan desain ruang untuk pekerjaan jarak jauh</a></li>
<li><a href="../id434928/index.html">Metode aplikasi dan distorsi akurasi dalam game. Grafik visual untuk perbandingan</a></li>
<li><a href="../id434930/index.html">Iklan video hari ini: harus memiliki bisnis yang sukses</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>