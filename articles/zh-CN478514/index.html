<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📆 👐🏻 🐈 使用加密的数据进行机器学习而不解密 🌳 🗞️ 📘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="使用加密的数据进行机器学习而不解密 
 本文讨论了高级加密技术。 这只是Julia Computing进行的研究的概述。 不要在商业应用中使用此处给出的示例。 在应用加密之前，请务必咨询加密专家。 

 在这里，您可以下载实现所有魔术的程序包，这是本文中讨论的代码。 

 引言 
 假设您刚刚开发了...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用加密的数据进行机器学习而不解密</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/478514/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/_p/ns/yf/_pnsyfz49v6t61j8whitl-q4qw0.jpeg"></div><br> 使用加密的数据进行机器学习而不解密 <br> 本文讨论了高级加密技术。 这只是Julia Computing进行的研究的概述。 不要在商业应用中使用此处给出的示例。 在应用加密之前，请务必咨询加密专家。 <br><br>  <a href="">在这里，</a>您可以下载实现所有魔术的程序包，这是本文中讨论的代码。 <br><a name="habracut"></a><br><h2> 引言 </h2><br> 假设您刚刚开发了一个很酷的新机器学习模型（当然，使用<a href="">Flux.jl</a> ）。 现在，您想开始为您的用户部署它。 您将如何做？ 可能最简单的方法是将模型提供给用户，并使其在其数据上本地运行。 但是这种方法有缺点： <br><br><ol><li> 机器学习模型很大，并且用户计算机可能没有足够的计算或磁盘资源。 </li><li> 机器学习模型通常会更新，因此可能无法方便地通过网络定期发送大量数据。 <br></li><li> 模型开发非常耗时，并且需要大量的计算资源。 您可能希望以使用模型的费用的形式对此进行补偿。 </li></ol><br> 然后他们通常会回忆起可以通过API在云中提供该模型。 在过去的几年中，出现了许多此类服务；每个大型云平台都为企业开发人员提供了类似的服务。 但是潜在的用户面临一个明显的难题：现在，他们的数据在远程服务器上处理，这可能是不可信的。 这具有明显的道德和法律影响，限制了此类服务的使用。 在受监管的行业中，尤其是医疗保健和金融服务，通常无法将患者和客户数据发送给第三方进行处理。 <br><br> 还有其他选择吗？ <br><br> 原来有！ 密码学的最新发现允许对数据进行计算而<i>无需对其进行解码</i> 。 例如，用户将加密的数据（例如，图像）发送到云API，该API启动机器学习模型，然后发送加密的响应。 在任何阶段都不会解密数据，云提供商不会访问源图像，也无法解密计算出的预测。 这怎么可能？ 让我们通过创建用于在MNIST数据集中的加密图像上进行手写识别的服务来找到答案。 <br><br><h2> 关于同态加密 </h2><br> 使用加密数据执行计算的能力通常称为“安全计算”。 这是一个很大的研究领域，根据各种应用场景，可以使用多种加密方法。 我们将专注于一种称为“同态加密”的技术。 在这样的系统中，通常可以进行以下操作： <br><br><ul><li><code>pub_key, eval_key, priv_key = keygen()</code> <br> </li><li> <code>encrypted = encrypt(pub_key, plaintext)</code> <br> </li><li> <code>decrypted = decrypt(priv_key, encrypted)</code> <br> </li><li> <code>encrypted′ = eval(eval_key, f, encrypted)</code> <br> </li></ul><br> 对于已经使用任何非对称加密算法的每个人（例如，如果您通过TLS进行连接），前三个操作都很简单且熟悉。 所有的魔术都发生在最后的操作中。 在加密过程中，它评估函数<code>f</code>并返回根据对加密值评估<code>f</code>的结果计算出的另一个加密值。 此功能为其方法命名。 评估与加密操作有关： <br><br><pre> <code class="julia hljs">f(decrypt(priv_key, encrypted)) == decrypt(priv_key, eval(eval_key, f, encrypted))</code> </pre> <br> 类似地，使用加密的值，我们可以评估任意同构性<code>f</code> 。 <br><br> 支持哪些功能<code>f</code>取决于加密方案和支持的操作。 如果仅支持一个<code>f</code> （例如<code>f = +</code> ），则该电路称为“部分同态”。 如果<code>f</code>可以是网关的任何完整集合，可以在该网关的基础上创建任意方案，则对于方案的有限大小，这称为另一种部分同态计算-“有些同态”，而对于无限制大小，则称为“完全同构”计算。 您可以使用自举技术将“以某种方式”转换为完全同态加密，但这超出了本文的范围。 全同态加密是一个相对较新的发现，第一个工作方案（尽管不切实际）是由<a href="https://www.cs.cmu.edu/~odonnell/hits09/gentry-homomorphic-encryption.pdf">Craig Gentry在2009年发布的</a> 。 有许多后来的（和实际的）完全同构方案。 还有一些软件包可以定性地实现这些方案。 大多数情况下，他们使用<a href="https://github.com/microsoft/SEAL">Microsoft SEAL</a>和<a href="https://palisade-crypto.org/">PALISADE</a> 。 另外，我最近打开了这些<a href="">Pure Julia</a>算法的实现代码。 对于本文，我们将使用其中实现的CKKS加密。 <br><br><h2>  CKS概述 </h2><br>  CKKS（以2016年提出该算法的<a href="https://eprint.iacr.org/2016/421.pdf">科学著作</a> Cheon-Kim-Kim-Song的作者的名字命名）是一种同态加密方案，可以对以下原始操作进行同态评估： <br><br><ul><li>  <code>n</code>个复数向量的长度的元素加法。 <br></li><li>  <code>n</code>复数向量的长度的逐元素乘法。 <br></li><li> 旋转（在<code>circshift</code>的情况下）向量中的元素。 <br></li><li> 向量元素的集成配对。 <br></li></ul><br> 参数<code>n</code>取决于所需的安全性和准确性，通常很高。 在我们的示例中，它将等于4096（较高的值可提高安全性，但在计算中也较困难，它的缩放比例近似为<code>n log n</code> ）。 <br><br> 此外，使用CKKS进行的计算比较<i>嘈杂</i> 。 因此，结果是近似值，必须注意以足够的准确性评估结果，以免影响结果的正确性。 <br><br> 另一方面，这样的限制对于机器学习包的开发人员来说并不罕见。 像GPU这样的特殊加速器通常也可以使用数字矢量运行。 另外，对于许多开发人员来说，由于选择算法，多线程等的影响，浮点数有时看起来很嘈杂。 我想强调一点，这里的主要区别在于，尽管CKKS原语确实很嘈杂，但由于实现的复杂性，尽管浮点数的算术计算最初是确定性的，即使这并不明显。 但这也许可以使用户理解噪音并不像看起来那样可怕。 <br><br> 现在，让我们看看如何在Julia中执行这些操作（注意：选择了非常不安全的参数，在这些操作中，我们仅说明了REPL中库的使用）。 <br><br><pre> <code class="julia hljs">julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ToyFHE <span class="hljs-comment"><span class="hljs-comment"># Let's play with 8 element vectors julia&gt; N = 8; # Choose some parameters - we'll talk about it later julia&gt; ℛ = NegacyclicRing(2N, (40, 40, 40)) ℤ₁₃₂₉₂₂₇₉₉₇₅₆₈₀₈₁₄₅₇₄₀₂₇₀₁₂₀₇₁₀₄₂₄₈₂₅₇/(x¹⁶ + 1) # We'll use CKKS julia&gt; params = CKKSParams(ℛ) CKKS parameters # We need to pick a scaling factor for a numbers - again we'll talk about that later julia&gt; Tscale = FixedRational{2^40} FixedRational{1099511627776,T} where T # Let's start with a plain Vector of zeros julia&gt; plain = CKKSEncoding{Tscale}(zero(ℛ)) 8-element CKKSEncoding{FixedRational{1099511627776,T} where T} with indices 0:7: 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im # Ok, we're ready to get started, but first we'll need some keys julia&gt; kp = keygen(params) CKKS key pair julia&gt; kp.priv CKKS private key julia&gt; kp.pub CKKS public key # Alright, let's encrypt some things: julia&gt; foreach(i-&gt;plain[i] = i+1, 0:7); plain 8-element CKKSEncoding{FixedRational{1099511627776,T} where T} with indices 0:7: 1.0 + 0.0im 2.0 + 0.0im 3.0 + 0.0im 4.0 + 0.0im 5.0 + 0.0im 6.0 + 0.0im 7.0 + 0.0im 8.0 + 0.0im julia&gt; c = encrypt(kp.pub, plain) CKKS ciphertext (length 2, encoding CKKSEncoding{FixedRational{1099511627776,T} where T}) # And decrypt it again julia&gt; decrypt(kp.priv, c) 8-element CKKSEncoding{FixedRational{1099511627776,T} where T} with indices 0:7: 0.9999999999995506 - 2.7335193113350057e-16im 1.9999999999989408 - 3.885780586188048e-16im 3.000000000000205 + 1.6772825551165524e-16im 4.000000000000538 - 3.885780586188048e-16im 4.999999999998865 + 8.382500573679615e-17im 6.000000000000185 + 4.996003610813204e-16im 7.000000000001043 - 2.0024593503998215e-16im 8.000000000000673 + 4.996003610813204e-16im # Note that we had some noise. Let's go through all the primitive operations we'll need: julia&gt; decrypt(kp.priv, c+c) 8-element CKKSEncoding{FixedRational{1099511627776,T} where T} with indices 0:7: 1.9999999999991012 - 5.467038622670011e-16im 3.9999999999978817 - 7.771561172376096e-16im 6.00000000000041 + 3.354565110233105e-16im 8.000000000001076 - 7.771561172376096e-16im 9.99999999999773 + 1.676500114735923e-16im 12.00000000000037 + 9.992007221626409e-16im 14.000000000002085 - 4.004918700799643e-16im 16.000000000001346 + 9.992007221626409e-16im julia&gt; csq = c*c CKKS ciphertext (length 3, encoding CKKSEncoding{FixedRational{1208925819614629174706176,T} where T}) julia&gt; decrypt(kp.priv, csq) 8-element CKKSEncoding{FixedRational{1208925819614629174706176,T} where T} with indices 0:7: 0.9999999999991012 - 2.350516767363621e-15im 3.9999999999957616 - 5.773159728050814e-15im 9.000000000001226 - 2.534464540987068e-15im 16.000000000004306 - 2.220446049250313e-15im 24.99999999998865 + 2.0903753311370056e-15im 36.00000000000222 + 4.884981308350689e-15im 49.000000000014595 + 1.0182491378134327e-15im 64.00000000001077 + 4.884981308350689e-15im</span></span></code> </pre> <br> 好简单！ 细心的读者可能会注意到CSQ与以前的密文略有不同。 特别地，密文具有“长度3”并且规模更大。 关于什么是什么以及需要什么的解释超出了本文的范围。 足以说明我们需要在继续计算之前降低这些值，否则“位置”将以密文结尾。 幸运的是，我们可以减少两个增加的值中的每一个： <br><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># To get back down to length 2, we need to `keyswitch` (aka # relinerarize), which requires an evaluation key. Generating # this requires the private key. In a real application we would # have generated this up front and sent it along with the encrypted # data, but since we have the private key, we can just do it now. julia&gt; ek = keygen(EvalMultKey, kp.priv) CKKS multiplication key julia&gt; csq_length2 = keyswitch(ek, csq) CKKS ciphertext (length 2, encoding CKKSEncoding{FixedRational{1208925819614629174706176,T} where T}) # Getting the scale back down is done using modswitching. julia&gt; csq_smaller = modswitch(csq_length2) CKKS ciphertext (length 2, encoding CKKSEncoding{FixedRational{1.099511626783e12,T} where T}) # And it still decrypts correctly (though note we've lost some precision) julia&gt; decrypt(kp.priv, csq_smaller) 8-element CKKSEncoding{FixedRational{1.099511626783e12,T} where T} with indices 0:7: 0.9999999999802469 - 5.005163520332181e-11im 3.9999999999957723 - 1.0468514951188039e-11im 8.999999999998249 - 4.7588542623100616e-12im 16.000000000023014 - 1.0413447889166631e-11im 24.999999999955193 - 6.187833723406491e-12im 36.000000000002345 + 1.860733715346631e-13im 49.00000000001647 - 1.442396043149794e-12im 63.999999999988695 - 1.0722489563648028e-10im</span></span></code> </pre> <br> 另外，modswitching（模数转换，模块转换的缩写）减小了密文模块的大小，因此我们不能无限期地继续这样做（我们使用了某种同态加密方案）： <br><br><pre> <code class="julia hljs">julia&gt; ℛ <span class="hljs-comment"><span class="hljs-comment"># Remember the ring we initially created ℤ₁₃₂₉₂₂₇₉₉₇₅₆₈₀₈₁₄₅₇₄₀₂₇₀₁₂₀₇₁₀₄₂₄₈₂₅₇/(x¹⁶ + 1) julia&gt; ToyFHE.ring(csq_smaller) # It shrunk! ℤ₁₂₀₈₉₂₅₈₂₀₁₄₄₅₉₃₇₇₉₃₃₁₅₅₃/(x¹⁶ + 1)&lt;/code&gt;     —  (rotations).      keyswitch,       (evaluation key,     ): &lt;source lang="julia"&gt;julia&gt; gk = keygen(GaloisKey, kp.priv; steps=2) CKKS galois key (element 25) julia&gt; decrypt(circshift(c, gk)) decrypt(kp, circshift(c, gk)) 8-element CKKSEncoding{FixedRational{1099511627776,T} where T} with indices 0:7: 7.000000000001042 + 5.68459112632516e-16im 8.000000000000673 + 5.551115123125783e-17im 0.999999999999551 - 2.308655353580721e-16im 1.9999999999989408 + 2.7755575615628914e-16im 3.000000000000205 - 6.009767921608429e-16im 4.000000000000538 + 5.551115123125783e-17im 4.999999999998865 + 4.133860996136768e-17im 6.000000000000185 - 1.6653345369377348e-16im # And let's compare to doing the same on the plaintext julia&gt; circshift(plain, 2) 8-element OffsetArray(::Array{Complex{Float64},1}, 0:7) with eltype Complex{Float64} with indices 0:7: 7.0 + 0.0im 8.0 + 0.0im 1.0 + 0.0im 2.0 + 0.0im 3.0 + 0.0im 4.0 + 0.0im 5.0 + 0.0im 6.0 + 0.0im</span></span></code> </pre> <br> 我们介绍了使用HE库的基础知识。 但是在继续使用这些原语来计算神经网络预测之前，让我们看一下学习它的过程。 <br><br><h2> 机器学习模型 </h2><br> 如果您不熟悉机器学习或Flux.jl库，那么建议您简要浏览一下<a href="https://fluxml.ai/Flux.jl/stable/">Flux.jl文档，</a>或者免费阅读<a href="https://juliaacademy.com/p/introduction-to-machine-learning">机器学习简介</a> ，因为我们将仅讨论将模型应用于加密数据的更改。 <br><br> 让我们<a href="">从使用Flux动物园</a>的卷积神经网络开始。 我们将执行相同的训练周期，并进行数据准备等，只需稍微建立一下模型即可。 这是： <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> reshape_and_vcat(x) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y=reshape(x, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, size(x, <span class="hljs-number"><span class="hljs-number">4</span></span>)) vcat((y[:,i,:] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i=axes(y,<span class="hljs-number"><span class="hljs-number">2</span></span>))...) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> model = Chain( <span class="hljs-comment"><span class="hljs-comment"># First convolution, operating upon a 28x28 image Conv((7, 7), 1=&gt;4, stride=(3,3), x-&gt;x.^2), reshape_and_vcat, Dense(256, 64, x-&gt;x.^2), Dense(64, 10), )</span></span></code> </pre><br> 这与<a href="https://eprint.iacr.org/2018/1041.pdf">“安全外包矩阵计算和应用于神经网络”</a>工作中的模型相同，后者使用相同的密码方案，但有两个区别：1）为简单起见，我们未对模型本身进行加密； 2）在每一层之后使用贝叶斯向量（在Flux中默认完成），我不确定在提到的工作中是什么。 也许是由于第二点，我们模型的测试集的准确性原来更高（98.6％对98.1％），但是高参数差异也可能是原因。 <br><br>  <code>x.^2</code>函数激活是不寻常的（对于那些拥有机器学习经验的人而言）。 在大多数情况下，他们使用<code>tanh</code> ， <code>relu</code>或其他更古怪的东西。 但是，尽管这些函数（尤其是<code>relu</code> ）很容易针对普通文本值进行计算，但是它们可能需要大量的计算资源才能以加密形式对其进行评估（我们通常估算多项式近似值）。 幸运的是，在这种情况下， <code>x.^2</code>非常有效。 <br><br> 学习周期的其余部分保持不变。 我们从损失函数对数<code>logitcrossentropy</code>模型中删除了<code>softmax</code> （您可以将其保留，并在客户端解密后评估softmax）。 训练模型的完整代码位于<a href="">GitHub上</a> ，可在几分钟内在任何新的视频卡上运行。 <br><br><h2> 有效运作 </h2><br> 现在我们知道我们需要执行哪些操作： <br><br><ul><li> 凝血。 <br></li><li> 元素平方。 <br></li><li> 矩阵乘法。 <br></li></ul><br> 通过平方，一切都很简单，我们已经在上面进行了检查，因此我们将考虑另外两个操作。 我们假设数据包的长度为64（您可能会注意到选择模型参数和数据包大小是为了利用由于实际选择参数而获得的4096元素矢量）。 <br><br><h3> 凝结 </h3><br> 回想一下凝血是如何工作的。 取原始输入数组的一个窗口（在我们的例子中为7x7），每个窗口元素乘以卷积掩码元素。 然后，将窗口移至某个步骤（在本例中，该步骤为3，即，移动3个元素）并重复该过程（使用相同的卷积蒙版）。 下图显示了3x3卷积与步骤<code>(2, 2)</code> ）的过程（ <a href="https://github.com/vdumoulin/conv_arithmetic">source</a> ）的动画（蓝色数组-输入，绿色-输出）： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h5/a3/q3/h5a3q3ea0pljgdagz1wd-k2igdy.gif"></div><br> 另外，我们在四个不同的“通道”中执行卷积（也就是说，我们使用不同的蒙版重复卷积3次以上）。 <br><br> 现在我们知道该怎么做了，仍然需要了解如何做。 幸运的是，卷积是模型中的第一个操作。 因此，为了节省资源，我们可以在客户端上预处理数据，然后对它们进行加密（不使用权重）。 让我们这样做： <br><br><ul><li> 首先，我们计算每个卷积窗口（即来自源图像的7x7样本），从而为每个输入图像提供64个7x7矩阵。 请注意，对于以2为增量的7x7窗口，将有8x8卷积窗口用于评估28x28输入图像。 <br></li><li> 让我们在一个向量中收集每个窗口中相同的位置。 也就是说，对于每个图像，对于大小为64的数据包（总共49个64x64矩阵），我们将具有64个元素的向量或64x64个元素的向量。 <br></li><li> 我们将加密。 <br></li></ul><br> 然后，凝结简单地变成整个矩阵与相应的蒙版元素的标量乘法。 然后汇总所有49个元素，我们得到折叠的结果。 这是该策略的实现形式（以纯文本形式）： <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> public_preprocess(batch) ka = OffsetArray(<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Create feature extracted matrix I = [[batch[i′*3 .+ (1:7), j′*3 .+ (1:7), 1, k] for i′=ka, j′=ka] for k = 1:64] # Reshape into the ciphertext Iᵢⱼ = [[I[k][l...][i,j] for k=1:64, l=product(ka, ka)] for i=1:7, j=1:7] end Iᵢⱼ = public_preprocess(batch) # Evaluate the convolution weights = model.layers[1].weight conv_weights = reverse(reverse(weights, dims=1), dims=2) conved = [sum(Iᵢⱼ[i,j]*conv_weights[i,j,1,channel] for i=1:7, j=1:7) for channel = 1:4] conved = map(((x,b),)-&gt;x .+ b, zip(conved, model.layers[1].bias))</span></span></code> </pre> <br> 这个（用于更改尺寸的模块）（以模数形式更改尺寸的顺序）给出的答案与操作<code>model.layers[1](batch)</code> 。 <br><br> 添加加密操作： <br><br><pre> <code class="julia hljs">Iᵢⱼ = public_preprocess(batch) C_Iᵢⱼ = map(Iᵢⱼ) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Iij plain = CKKSEncoding{Tscale}(zero(plaintext_space(ckks_params))) plain .= OffsetArray(vec(Iij), <span class="hljs-number"><span class="hljs-number">0</span></span>:(N÷<span class="hljs-number"><span class="hljs-number">2</span></span>-<span class="hljs-number"><span class="hljs-number">1</span></span>)) encrypt(kp, plain) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> weights = model.layers[<span class="hljs-number"><span class="hljs-number">1</span></span>].weight conv_weights = reverse(reverse(weights, dims=<span class="hljs-number"><span class="hljs-number">1</span></span>), dims=<span class="hljs-number"><span class="hljs-number">2</span></span>) conved3 = [sum(C_Iᵢⱼ[i,j]*conv_weights[i,j,<span class="hljs-number"><span class="hljs-number">1</span></span>,channel] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>, j=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> channel = <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>] conved2 = map(((x,b),)-&gt;x .+ b, zip(conved3, model.layers[<span class="hljs-number"><span class="hljs-number">1</span></span>].bias)) conved1 = map(ToyFHE.modswitch, conved2)</code> </pre> <br> 请注意，由于砝码是公共的，因此此处不需要按键开关。 因此，我们不会增加密文的长度。 <br><br><h3> 矩阵乘法 </h3><br> 继续矩阵乘法，我们可以使用向量中元素的旋转来更改乘法索引的顺序。 考虑向量中矩阵元素的逐行放置。 如果将向量移位行大小的倍数，则会得到列旋转的效果，这足以实现矩阵乘法（至少是平方矩阵）。 让我们尝试： <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> matmul_square_reordered(weights, x) sum(<span class="hljs-number"><span class="hljs-number">1</span></span>:size(weights, <span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> k <span class="hljs-comment"><span class="hljs-comment"># We rotate the columns of the LHS and take the diagonal weight_diag = diag(circshift(weights, (0,(k-1)))) # We rotate the rows of the RHS x_rotated = circshift(x, (k-1,0)) # We do an elementwise, broadcast multiply weight_diag .* x_rotated end end function matmul_reorderd(weights, x) sum(partition(1:256, 64)) do range matmul_square_reordered(weights[:, range], x[range, :]) end end fc1_weights = model.layers[3].W x = rand(Float64, 256, 64) @assert (fc1_weights*x) ≈ matmul_reorderd(fc1_weights, x)</span></span></code> </pre> <br> 当然，对于一般的矩阵乘法，需要做一些更复杂的事情，但是到目前为止，这已经足够了。 <br><br><h2> 改进技术 </h2><br> 现在，我们技术的所有组件都可以工作了。 这是完整的代码（设置选择选项和类似内容除外）： <br><br><pre> <code class="julia hljs">ek = keygen(EvalMultKey, kp.priv) gk = keygen(GaloisKey, kp.priv; steps=<span class="hljs-number"><span class="hljs-number">64</span></span>) Iᵢⱼ = public_preprocess(batch) C_Iᵢⱼ = map(Iᵢⱼ) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Iij plain = CKKSEncoding{Tscale}(zero(plaintext_space(ckks_params))) plain .= OffsetArray(vec(Iij), <span class="hljs-number"><span class="hljs-number">0</span></span>:(N÷<span class="hljs-number"><span class="hljs-number">2</span></span>-<span class="hljs-number"><span class="hljs-number">1</span></span>)) encrypt(kp, plain) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> weights = model.layers[<span class="hljs-number"><span class="hljs-number">1</span></span>].weight conv_weights = reverse(reverse(weights, dims=<span class="hljs-number"><span class="hljs-number">1</span></span>), dims=<span class="hljs-number"><span class="hljs-number">2</span></span>) conved3 = [sum(C_Iᵢⱼ[i,j]*conv_weights[i,j,<span class="hljs-number"><span class="hljs-number">1</span></span>,channel] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>, j=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> channel = <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>] conved2 = map(((x,b),)-&gt;x .+ b, zip(conved3, model.layers[<span class="hljs-number"><span class="hljs-number">1</span></span>].bias)) conved1 = map(ToyFHE.modswitch, conved2) Csqed1 = map(x-&gt;x*x, conved1) Csqed1 = map(x-&gt;keyswitch(ek, x), Csqed1) Csqed1 = map(ToyFHE.modswitch, Csqed1) <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> encrypted_matmul(gk, weights, x::ToyFHE.CipherText) result = repeat(diag(weights), inner=<span class="hljs-number"><span class="hljs-number">64</span></span>).*x rotated = x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k = <span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">64</span></span> rotated = ToyFHE.rotate(gk, rotated) result += repeat(diag(circshift(weights, (<span class="hljs-number"><span class="hljs-number">0</span></span>,(k-<span class="hljs-number"><span class="hljs-number">1</span></span>)))), inner=<span class="hljs-number"><span class="hljs-number">64</span></span>) .* rotated <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> fq1_weights = model.layers[<span class="hljs-number"><span class="hljs-number">3</span></span>].W Cfq1 = sum(enumerate(partition(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">256</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> (i,range) encrypted_matmul(gk, fq1_weights[:, range], Csqed1[i]) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> Cfq1 = Cfq1 .+ OffsetArray(repeat(model.layers[<span class="hljs-number"><span class="hljs-number">3</span></span>].b, inner=<span class="hljs-number"><span class="hljs-number">64</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">4095</span></span>) Cfq1 = modswitch(Cfq1) Csqed2 = Cfq1*Cfq1 Csqed2 = keyswitch(ek, Csqed2) Csqed2 = modswitch(Csqed2) <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> naive_rectangular_matmul(gk, weights, x) <span class="hljs-meta"><span class="hljs-meta">@assert</span></span> size(weights, <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt; size(weights, <span class="hljs-number"><span class="hljs-number">2</span></span>) weights = vcat(weights, zeros(eltype(weights), size(weights, <span class="hljs-number"><span class="hljs-number">2</span></span>)-size(weights, <span class="hljs-number"><span class="hljs-number">1</span></span>), size(weights, <span class="hljs-number"><span class="hljs-number">2</span></span>))) encrypted_matmul(gk, weights, x) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> fq2_weights = model.layers[<span class="hljs-number"><span class="hljs-number">4</span></span>].W Cresult = naive_rectangular_matmul(gk, fq2_weights, Csqed2) Cresult = Cresult .+ OffsetArray(repeat(vcat(model.layers[<span class="hljs-number"><span class="hljs-number">4</span></span>].b, zeros(<span class="hljs-number"><span class="hljs-number">54</span></span>)), inner=<span class="hljs-number"><span class="hljs-number">64</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">4095</span></span>)</code> </pre> <br> 看起来不太整洁，但是如果您完成了所有这些步骤，则应该了解每个步骤。 <br> 现在，让我们考虑一下抽象可以简化我们的生活。 我们将离开制图学和机器学习领域，而转向编程语言的体系结构，因此让我们利用Julia允许您使用和创建强大的抽象这一事实。 例如，您可以将提取卷积的整个过程封装为数组类型： <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BlockArrays <span class="hljs-string"><span class="hljs-string">""" ExplodedConvArray{T, Dims, Storage} &lt;: AbstractArray{T, 4} Represents a an `nxmx1xb` array of images, but rearranged into a series of convolution windows. Evaluating a convolution compatible with `Dims` on this array is achievable through a sequence of scalar multiplications and sums on the underling storage. """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ExplodedConvArray{T, <span class="hljs-built_in"><span class="hljs-built_in">Dims</span></span>, Storage} &lt;: <span class="hljs-built_in"><span class="hljs-built_in">AbstractArray</span></span>{T, <span class="hljs-number"><span class="hljs-number">4</span></span>} <span class="hljs-comment"><span class="hljs-comment"># sx*sy matrix of b*(dx*dy) matrices of extracted elements # where (sx, sy) = kernel_size(Dims) # (dx, dy) = output_size(DenseConvDims(...)) cdims::Dims x::Matrix{Storage} function ExplodedConvArray{T, Dims, Storage}(cdims::Dims, storage::Matrix{Storage}) where {T, Dims, Storage} @assert all(==(size(storage[1])), size.(storage)) new{T, Dims, Storage}(cdims, storage) end end Base.size(ex::ExplodedConvArray) = (NNlib.input_size(ex.cdims)..., 1, size(ex.x[1], 1)) function ExplodedConvArray{T}(cdims, batch::AbstractArray{T, 4}) where {T} x, y = NNlib.output_size(cdims) kx, ky = NNlib.kernel_size(cdims) stridex, stridey = NNlib.stride(cdims) kax = OffsetArray(0:x-1, 0:x-1) kay = OffsetArray(0:x-1, 0:x-1) I = [[batch[i′*stridex .+ (1:kx), j′*stridey .+ (1:ky), 1, k] for i′=kax, j′=kay] for k = 1:size(batch, 4)] Iᵢⱼ = [[I[k][l...][i,j] for k=1:size(batch, 4), l=product(kax, kay)] for (i,j) in product(1:kx, 1:ky)] ExplodedConvArray{T, typeof(cdims), eltype(Iᵢⱼ)}(cdims, Iᵢⱼ) end function NNlib.conv(x::ExplodedConvArray{&lt;:Any, Dims}, weights::AbstractArray{&lt;:Any, 4}, cdims::Dims) where {Dims&lt;:ConvDims} blocks = reshape([ Base.ReshapedArray(sum(xx[i,j]*weights[i,j,1,channel] for i=1:7, j=1:7), (NNlib.output_size(cdims)...,1,size(x, 4)), ()) for channel = 1:4 ],(1,1,4,1)) BlockArrays._BlockArray(blocks, BlockArrays.BlockSizes([8], [8], [1,1,1,1], [64])) end</span></span></code> </pre><br> 在这里，我们再次使用<code>BlockArrays</code>将<code>8x8x4x64</code>数组表示为四个<code>8x8x1x64</code>数组，如源代码中所示。 现在，至少使用未加密的数组，第一阶段的演示变得更加美观： <br><br><pre> <code class="julia hljs">julia&gt; cdims = DenseConvDims(batch, model.layers[<span class="hljs-number"><span class="hljs-number">1</span></span>].weight; stride=(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>), padding=(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>), dilation=(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) DenseConvDims: (<span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>) -&gt; (<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), stride: (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) pad: (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), dil: (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), flip: <span class="hljs-literal"><span class="hljs-literal">false</span></span> julia&gt; a = ExplodedConvArray{eltype(batch)}(cdims, batch); julia&gt; model(a) <span class="hljs-number"><span class="hljs-number">10</span></span>×<span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Float32</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>}: [snip]</code> </pre><br> 现在我们如何将其与加密连接起来？ 为此，您需要： <br><br><ol><li> 加密结构（ <code>ExplodedConvArray</code> ），以便我们获取每个字段的密文。 具有这种加密结构的操作将验证函数将对原始结构执行的操作，并且同态地执行相同的操作。 <br></li><li> 拦截某些操作，以便在加密的上下文中不同地执行它们。 </li></ol><br> 幸运的是，Julia为此提供了一个抽象：一个使用<a href="">Cassette.jl</a>机制的编译器插件。 我不会告诉您它是什么以及它是如何工作的，我会简单地说一说它可以确定上下文（例如<code>Encrypted</code> ，然后定义规则在该上下文中应如何工作。 例如，您可以为第二个要求编写此代码： <br><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># Define Matrix multiplication between an array and an encrypted block array function (*::Encrypted{typeof(*)})(a::Array{T, 2}, b::Encrypted{&lt;:BlockArray{T, 2}}) where {T} sum(a*b for (i,range) in enumerate(partition(1:size(a, 2), size(b.blocks[1], 1)))) end # Define Matrix multiplication between an array and an encrypted array function (*::Encrypted{typeof(*)})(a::Array{T, 2}, b::Encrypted{Array{T, 2}}) where {T} result = repeat(diag(a), inner=size(a, 1)).*x rotated = b for k = 2:size(a, 2) rotated = ToyFHE.rotate(GaloisKey(*), rotated) result += repeat(diag(circshift(a, (0,(k-1)))), inner=size(a, 1)) .* rotated end result end</span></span></code> </pre><br> 结果，用户将能够用最少的手工编写以上所有内容： <br><br><pre> <code class="julia hljs">kp = keygen(ckks_params) ek = keygen(EvalMultKey, kp.priv) gk = keygen(GaloisKey, kp.priv; steps=<span class="hljs-number"><span class="hljs-number">64</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Create evaluation context ctx = Encrypted(ek, gk) # Do public preprocessing batch = ExplodedConvArray{eltype(batch)}(cdims, batch); # Run on encrypted data under the encryption context Cresult = ctx(model)(encrypt(kp.pub, batch)) # Decrypt the answer decrypt(kp, Cresult)</span></span></code> </pre> <br> ,     .   (   ℛ,   modswitch, keyswitch  ..)       ,      .  ,    ,    ,         ,        . <br><br><h2> 结论 </h2><br>          —      .     Julia          .  RAMPARTS ( <a href="https://eprint.iacr.org/2019/988.pdf">paper</a> , <a href="https://www.youtube.com/watch%3Fv%3D_KLlMg6jKQg">JuliaCon talk</a> )       :  Julia-   -  PALISADE. Julia Computing    RAMPARTS    Verona, <a href="https://galois.com/news/15m-iarpa-hector-contract-privacy-preserving-technology/"> </a>     .             ,     .  .     ,   ,          . <br><br>        ,   <a href=""> ToyFHE</a> .   <a href="https://juliacomputing.github.io/ToyFHE.jl/dev/man/background/"></a> , ,   ,         . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN478514/">https://habr.com/ru/post/zh-CN478514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN478500/index.html">为什么夏天的会议这么少？</a></li>
<li><a href="../zh-CN478502/index.html">所有人的智能技术</a></li>
<li><a href="../zh-CN478504/index.html">工作场所如何随着笔记本电脑的发展而改变</a></li>
<li><a href="../zh-CN478508/index.html">电报即服务</a></li>
<li><a href="../zh-CN478510/index.html">我们邀请您参加DINS QA EVENING 12/12/19：创建Jenkins管道，并了解如何在他们的帮助下并行启动测试</a></li>
<li><a href="../zh-CN478516/index.html">Houdini和Unity中的程序性道路</a></li>
<li><a href="../zh-CN478518/index.html">体验在Zextras / Zimbra OSE上部署办公基础架构的经验</a></li>
<li><a href="../zh-CN478522/index.html">承认吧，沃森，你完全困惑了吗？</a></li>
<li><a href="../zh-CN478526/index.html">Windows Server和Mikrotik上的一堆OpenVPN，并将这些东西迁移到Linux</a></li>
<li><a href="../zh-CN478528/index.html">宠物（一个梦幻般的故事）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>