<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ—ï¸ ğŸ–±ï¸ ğŸ‘·ğŸ» Ikhtisar metode penautan teks ğŸ‡ğŸ¾ ğŸ® ğŸŒ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 


 Beberapa waktu yang lalu, saya menjadi anggota proyek untuk mengembangkan produk perangkat lunak yang dirancang untuk menganalisis cat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ikhtisar metode penautan teks</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417465/"><h2 id="vvedenie">  Pendahuluan </h2><br><p>  Beberapa waktu yang lalu, saya menjadi anggota proyek untuk mengembangkan produk perangkat lunak yang dirancang untuk menganalisis catatan pasien dan data tentang keadaan kesehatan mereka yang berasal dari organisasi medis untuk membuat rekam medis terpadu.  Untuk waktu yang lama, tim tidak dapat mengembangkan pendekatan untuk menggabungkan data pasien.  Titik awalnya adalah studi tentang kode sumber solusi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Open EMPI</a> (Open Enterprise Master Patient Index), yang mendorong kami untuk merangkai algoritma analisis kesamaan.  Sejak saat itu, studi yang lebih mendalam tentang bahan dimulai, yang memungkinkan untuk membuat tata letak terlebih dahulu, dan kemudian solusi yang berfungsi. </p><br><p>  Sampai sekarang, di berbagai jenis presentasi, kita harus mendengar banyak pertanyaan tentang logika karya produk tersebut, dari mana saya menyimpulkan bahwa tinjauan metode untuk menghubungkan catatan teks akan menarik bagi banyak pembaca. </p><br><p>  Bahannya adalah terjemahan dari artikel wikipedia " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rekam tautan</a> " dengan hak cipta dan tambahan. </p><a name="habracut"></a><br><h2 id="chto-takoe-svyazyvanie-tekstovyh-zapisey">  Apa itu penautan teks? </h2><br><p>  Istilah <em>"</em> hubungan rekaman" menggambarkan proses melampirkan catatan teks dari satu sumber data ke catatan dari yang lain, asalkan mereka menggambarkan objek yang sama.  Dalam ilmu komputer, ini disebut <em>"pemetaan data"</em> atau <em>"masalah identitas objek"</em> .  Definisi alternatif kadang-kadang digunakan, seperti <em>"identifikasi"</em> , <em>"mengikat</em> , <em>" deteksi duplikat "</em> , <em>" deduplikasi "</em> , <em>" catatan yang cocok "</em> , <em>" identifikasi objek "</em> , yang menggambarkan konsep yang sama.  Kelimpahan terminologis ini telah menyebabkan pemisahan pendekatan pemrosesan informasi dan penataan - <em>pengikatan</em> <em>catatan</em> dan <em>pengikatan data</em> .  Meskipun keduanya menentukan identifikasi objek yang cocok dengan set parameter yang berbeda, istilah "menghubungkan catatan teks" biasanya digunakan ketika merujuk pada <em>"esensi"</em> seseorang, sedangkan "data menghubungkan" berarti kemungkinan menghubungkan sumber daya web apa pun antara set data, menggunakan, masing-masing, konsep yang lebih luas dari pengidentifikasi, yaitu URI. </p><br><h2 id="zachem-eto-nuzhno">  Mengapa ini dibutuhkan? </h2><br><p>  Ketika mengembangkan produk perangkat lunak untuk membangun sistem otomatis yang digunakan dalam berbagai bidang yang terkait dengan pemrosesan data pribadi seseorang (layanan kesehatan, sejarah, statistik, pendidikan, dll.), Tugas muncul untuk mengidentifikasi data tentang mata pelajaran akuntansi yang berasal dari berbagai sumber. </p><br><p>  Namun, ketika mengumpulkan deskripsi dari sejumlah besar sumber, muncul masalah yang membuat identifikasi mereka tidak sulit.  Masalah-masalah ini meliputi: </p><br><ul><li>  kesalahan ketik; </li><li>  permutasi bidang (misalnya, dengan nama depan); </li><li>  penggunaan singkatan dan singkatan; </li><li>  penggunaan format pengidentifikasi yang berbeda (tanggal, nomor dokumen, dll.). </li><li>  distorsi fonetik; </li><li>  dll. </li></ul><br><p>  Kualitas data mentah secara langsung mempengaruhi hasil dari proses pengikatan.  Karena masalah ini, kumpulan data sering ditransfer ke pemrosesan, yang, meskipun mereka menggambarkan objek yang sama, terlihat seperti catatan ini terlihat berbeda.  Oleh karena itu, di satu sisi, semua pengidentifikasi catatan yang ditransmisikan dievaluasi untuk penerapan untuk digunakan dalam proses identifikasi, dan di sisi lain, catatan itu sendiri dinormalisasi atau distandarisasi untuk membawanya ke format tunggal. </p><br><h2 id="ekskurs-v-istoriyu">  Tur sejarah </h2><br><p>  Ide asli menghubungkan catatan dikemukakan oleh Halbert L. Dunn, yang menerbitkan sebuah artikel berjudul "Catatan Tautan" dalam American Journal of Public Health pada tahun 1946. </p><br><p>  Kemudian, pada tahun 1959, dalam sebuah artikel tentang Hubungan Otomatis dari Vital Records di majalah Science, Howard B. Newcombe meletakkan dasar probabilistik dari teori pengikatan tali modern, yang dikembangkan dan diperkuat pada tahun 1969 oleh Ivan Fellegi dan Alan Santer (Alan Sunter).  Karya mereka "A Theory For Record Linkage" masih merupakan dasar matematika untuk banyak algoritma penghubung. </p><br><p>  Perkembangan utama dari algoritma adalah di tahun 90-an abad terakhir.  Kemudian, dari berbagai bidang (statistik, pengarsipan, epidemiologi, sejarah dan lain-lain), algoritma yang sering digunakan sekarang dalam produk perangkat lunak mendatangi kami, seperti <em>kesamaan (jarak) jarak</em> Jaro-Winkler dan jarak <em>Levenshtein</em> , namun, beberapa solusi, misalnya, algoritma Soundex fonetis, muncul jauh lebih awal - pada 20-an abad terakhir. </p><br><h2 id="algoritmy-sravneniya-tekstovyh-zapisey">  Algoritma Perbandingan Entri Teks </h2><br><p>  Bedakan antara algoritma <em>deterministik</em> dan <em>probabilistik</em> untuk membandingkan catatan teks.  Algoritme deterministik didasarkan pada kebetulan lengkap atribut rekaman.  Algoritma probabilistik memungkinkan untuk menghitung tingkat korespondensi atribut rekaman dan, berdasarkan ini, memutuskan kemungkinan hubungan mereka. </p><br><h3 id="determinirovannye-algoritmy">  Algoritma Deterministik </h3><br><p>  Cara termudah untuk membandingkan string didasarkan pada aturan yang jelas ketika tautan antara objek dihasilkan berdasarkan jumlah kecocokan atribut dari kumpulan data.  Yaitu, dua catatan saling berhubungan satu sama lain melalui algoritma deterministik jika semua atau beberapa atributnya identik.  Algoritme deterministik cocok untuk membandingkan subjek yang dideskripsikan dengan serangkaian data yang diidentifikasi oleh pengidentifikasi umum (misalnya, nomor Asuransi dari akun pribadi perorangan di Dana Pensiun - SNILS) atau memiliki beberapa pengidentifikasi representatif (tanggal lahir, jenis kelamin, dll.) Yang dapat dipercaya. </p><br><p>  Algoritme deterministik dapat diterapkan ketika set data terstruktur (terstandarisasi) ditransfer ke pemrosesan. </p><br><p>  Misalnya, ia memiliki serangkaian entri teks berikut: </p><br><table><thead><tr><th>  Tidak. </th><th>  GAGAL </th><th>  Nama depan </th><th>  Tanggal lahir </th><th>  Gender </th></tr></thead><tbody><tr><td>  A1 </td><td>  163-648-564 96 </td><td>  Zhvanetsky Mikhail </td><td>  03/06/1934 </td><td>  M. </td></tr><tr><td>  A2 </td><td>  163-648-564 96 </td><td>  Zhvanetsky Mikhail </td><td>  03/06/1934 </td><td>  M. </td></tr><tr><td>  A3 </td><td>  126-029-036 24 </td><td>  Ilchenko Victor </td><td>  01/02/1937 </td><td>  M. </td></tr><tr><td>  A4 </td><td></td><td>  Novikova Klara </td><td>  12.26.1946 </td><td>  F </td></tr></tbody></table><br><table><thead><tr><th>  Tidak. </th><th>  GAGAL </th><th>  Nama depan </th><th>  Tanggal lahir </th><th>  Gender </th></tr></thead><tbody><tr><td>  B1 </td><td>  126-029-036 24 </td><td>  Ilyichenko Victor </td><td>  01/02/1937 </td><td>  M. </td></tr><tr><td>  B2 </td><td></td><td>  Zhivanetsky Mikhail </td><td>  03/06/1934 </td><td>  M. </td></tr><tr><td>  B3 </td><td></td><td>  Zerchaninova Klara </td><td>  12.26.1946 </td><td>  2 </td></tr></tbody></table><br><p>  Sebelumnya dikatakan bahwa algoritma deterministik yang paling sederhana adalah penggunaan pengidentifikasi unik, yang seharusnya mengidentifikasi seseorang secara unik.  Sebagai contoh, kami mengasumsikan bahwa semua catatan yang memiliki nilai pengidentifikasi yang sama (SNILS) menggambarkan subjek yang sama, jika tidak mereka adalah subyek yang berbeda.  Koneksi deterministik dalam hal ini akan menghasilkan pasangan berikut: A1 dan A2, A3 dan B1.  B2 tidak akan dikaitkan dengan A1 dan A2, karena pengidentifikasi tidak masalah, meskipun bertepatan konten dengan catatan yang ditentukan. </p><br><p>  Pengecualian ini mengarah pada kebutuhan untuk melengkapi algoritma deterministik dengan aturan baru.  Misalnya, jika tidak ada pengidentifikasi unik, Anda dapat menggunakan atribut lain seperti nama, tanggal lahir, dan jenis kelamin.  Dalam contoh yang diberikan, aturan tambahan ini lagi tidak akan memberikan korespondensi B2 dan A1 / A2, karena sekarang namanya berbeda - ada distorsi fonetik dari nama keluarga. </p><br><p>  Masalah ini dapat diselesaikan dengan menggunakan metode analisis fonetik, tetapi jika Anda mengubah nama keluarga (misalnya, dalam kasus pernikahan), Anda harus menggunakan aplikasi aturan baru, misalnya, membandingkan tanggal lahir atau untuk memungkinkan perbedaan dalam atribut yang tersedia dari catatan (misalnya, jenis kelamin). </p><br><p>  Contoh dengan jelas menggambarkan bahwa algoritma deterministik sangat sensitif terhadap kualitas data, dan peningkatan jumlah atribut rekaman dapat menyebabkan peningkatan substansial dalam jumlah aturan yang diterapkan, yang sangat menyulitkan penggunaan algoritma deterministik. </p><br><p>  Selain itu, penggunaan algoritma deterministik dimungkinkan jika ada kumpulan data yang diverifikasi (referensi utama) yang digunakan untuk membandingkan informasi yang masuk.  Namun, dalam kasus pengisian ulang direktori master itu sendiri secara konstan, diperlukan perbaikan menyeluruh dari hubungan yang ada, yang membuat penggunaan algoritma deterministik memakan waktu atau tidak mungkin. </p><br><h3 id="veroyatnostnye-algoritmy">  Algoritma Probabilistik </h3><br><p>  Algoritma probabilistik untuk menghubungkan catatan string menggunakan serangkaian atribut yang lebih luas daripada yang deterministik, dan untuk setiap atribut dihitung koefisien bobot yang menentukan kemampuan untuk mempengaruhi koneksi dalam penilaian akhir tentang kemungkinan kesesuaian catatan yang diperkirakan.  Catatan yang memiliki akumulasi berat total di atas ambang tertentu dianggap terkait, catatan yang telah mengumpulkan berat total di bawah ambang batas dianggap tidak terkait.  Pasangan yang telah mendapatkan nilai bobot total dari tengah kisaran dianggap sebagai kandidat untuk dihubungkan dan dapat dipertimbangkan kemudian (misalnya, oleh operator), yang akan memutuskan serikat mereka (tautan) atau membiarkannya tidak terikat.  Dengan demikian, tidak seperti algoritma deterministik, yang merupakan seperangkat sejumlah besar aturan yang jelas (terprogram), algoritma probabilistik dapat disesuaikan dengan kualitas data dengan memilih nilai ambang dan tidak memerlukan pemrograman ulang. </p><br><p>  Jadi, algoritma probabilistik menetapkan koefisien bobot ( <em>u</em> dan <em>m</em> ) untuk atribut catatan, dengan bantuan yang korespondensi atau ketidakkonsistenan satu sama lain akan ditentukan. </p><br><p>  Koefisien u menentukan probabilitas bahwa pengidentifikasi dari dua catatan independen bertepatan secara acak.  Misalnya, probabilitas u bulan kelahiran (ketika ada dua belas nilai yang terdistribusi seragam) adalah 1 \ 12 = 0,083.  Pengidentifikasi dengan nilai yang tidak terdistribusi secara merata akan memiliki probabilitas berbeda untuk nilai yang berbeda (kadang-kadang, termasuk nilai yang hilang). </p><br><p>  Koefisien m adalah probabilitas bahwa pengidentifikasi dalam pasangan yang dibandingkan saling bersesuaian atau sangat mirip - misalnya, dalam kasus probabilitas tinggi oleh algoritma Jaro-Winkler atau rendah oleh algoritma Levenshtein.  Jika atribut catatan sepenuhnya konsisten, nilai ini harus memiliki nilai 1,0, tetapi mengingat probabilitasnya yang rendah, koefisien harus dievaluasi secara berbeda.  Penilaian ini dapat dilakukan atas dasar analisis awal dari kumpulan data, misalnya, dengan secara manual <em>â€œmempelajariâ€</em> algoritma probabilistik untuk mengidentifikasi sejumlah besar pasangan yang cocok dan tidak cocok atau dengan meluncurkan algoritma secara iteratif untuk memilih nilai koefisien-m yang paling cocok. </p><br><p>  Jika probabilitas-m didefinisikan sebagai 0,95, maka koefisien kepatuhan / tidak-kepatuhan untuk bulan kelahiran akan terlihat seperti ini: </p><br><table><thead><tr><th>  Metrik </th><th>  Bagikan tautan </th><th>  Bagikan nilai, bukan referensi </th><th>  Frekuensi </th><th>  Berat </th></tr></thead><tbody><tr><td>  Kepatuhan </td><td>  m = 0,95 </td><td>  u = 0,083 </td><td>  m \ u = 11.4 </td><td>  Dalam (m / u) / ln (2) â‰ˆ 3.51 </td></tr><tr><td>  Ketidakcocokan </td><td>  1-m = 0,05 </td><td>  1-u = 0,917 </td><td>  (1-m) / (1-u) â‰ˆ 0,0545 </td><td>  ln ((1-m) / (1-u)) / ln (2) â‰ˆ -4.20 </td></tr></tbody></table><br><p>  Perhitungan serupa harus dibuat untuk pengidentifikasi rekaman lain untuk menentukan koefisien kepatuhan dan ketidakpatuhan mereka.  Kemudian, masing-masing pengidentifikasi dari satu rekaman dibandingkan dengan pengidentifikasi yang sesuai dari catatan lain untuk menentukan berat total pasangan: berat pasangan yang sesuai ditambahkan ke hasil total dengan total kumulatif, sedangkan berat pasangan yang tidak tepat dikurangkan dari total hasil.  Jumlah yang dihasilkan dibandingkan dengan nilai ambang batas yang diidentifikasi untuk menentukan apakah akan memasangkan pasangan yang dianalisis secara otomatis atau mentransfernya ke operator untuk dipertimbangkan. </p><br><h4 id="blokirovanie">  Memblokir </h4><br><p>  Penentuan ambang kepatuhan / ketidakpatuhan adalah keseimbangan antara memperoleh sensitivitas yang dapat diterima (bagian catatan terkait yang terdeteksi oleh algoritma) dan nilai prediksi hasil (mis. Akurasi, sebagai ukuran catatan yang benar-benar cocok yang dihubungkan oleh algoritma).  Karena mendefinisikan ambang batas bisa menjadi tugas yang sangat sulit, terutama untuk set data besar, metode yang dikenal sebagai <em>pemblokiran</em> sering digunakan untuk meningkatkan efisiensi komputasi.  Upaya dilakukan untuk melakukan perbandingan antara catatan yang perbedaannya signifikan ( <em>diskriminasi</em> ) dalam nilai atribut dasar diungkapkan.  Ini mengarah pada peningkatan akurasi karena penurunan sensitivitas. </p><br><p>  Misalnya, penguncian berdasarkan pengkodean fonetik dari nama keluarga mengurangi jumlah total perbandingan yang diperlukan dan meningkatkan kemungkinan bahwa hubungan antara catatan akan benar, karena dua atribut sudah konsisten, tetapi berpotensi melewatkan catatan yang terkait dengan orang yang sama dengan nama keluarga berubah (misalnya, sebagai hasil dari pernikahan).  Pemblokiran berdasarkan bulan kelahiran adalah indikator yang lebih stabil yang hanya dapat disesuaikan jika ada kesalahan dalam data sumber, tetapi memberikan manfaat yang lebih sederhana dalam nilai prediksi positif dan hilangnya sensitivitas, karena hal itu menciptakan dua belas kelompok kumpulan data yang sangat besar dan tidak mengarah pada peningkatan kecepatan. komputasi. </p><br><p>  Dengan demikian, sistem penghubung entri teks yang paling efisien sering menggunakan beberapa lintasan pemblokiran untuk mengelompokkan data dengan berbagai cara untuk mempersiapkan kelompok catatan yang nantinya harus diserahkan untuk dianalisis. </p><br><h4 id="mashinnoe-obuchenie">  Pembelajaran mesin </h4><br><p>  Baru-baru ini, berbagai metode pembelajaran mesin telah digunakan untuk menghubungkan catatan teks.  Dalam makalah 2011, Randall Wilson menunjukkan bahwa algoritma klasik menghubungkan probabilistik untuk catatan teks setara dengan algoritma Bayes naif dan menderita masalah yang sama dari asumsi bahwa fitur klasifikasi independen.  Untuk meningkatkan akurasi analisis, penulis mengusulkan untuk menggunakan model dasar jaringan saraf yang disebut perceptron lapisan tunggal, yang penggunaannya memungkinkan seseorang untuk secara signifikan melebihi hasil yang diperoleh dengan menggunakan algoritma probabilistik tradisional. </p><br><h2 id="foneticheskoe-kodirovanie">  Pengkodean Fonetik </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Algoritma fonetik</a> cocok dengan dua kata yang diucapkan sama dengan kode yang sama, yang memungkinkan Anda untuk membandingkan kata-kata tersebut berdasarkan kesamaan fonetisnya. </p><br><p>  Sebagian besar algoritma fonetik dirancang untuk menganalisis kata-kata bahasa Inggris, meskipun baru-baru ini beberapa algoritma telah dimodifikasi untuk digunakan dengan bahasa lain, atau pada awalnya dibuat sebagai solusi nasional (misalnya, Caverphone). </p><br><h3 id="soundex">  Soundex </h3><br><p>  Algoritma klasik untuk membandingkan dua string oleh suara mereka adalah Soundex (kependekan dari Sound index).  Ini menetapkan kode yang sama untuk string yang memiliki suara serupa dalam bahasa Inggris.  Soundex pada awalnya digunakan oleh Administrasi Arsip Nasional AS pada 1930-an untuk secara retrospektif menganalisis sensus dari tahun 1890 hingga 1920. </p><br><p>  Para penulis algoritma adalah Robert C. Russel dan Margaret King Odell, yang mematenkannya di tahun 20-an abad terakhir.  Algoritme itu sendiri mendapatkan popularitas pada paruh kedua abad terakhir ketika menjadi subjek dari beberapa artikel di jurnal sains populer di Amerika Serikat dan diterbitkan dalam monograf D. Knut "The Art of Programming". </p><br><h3 id="daitch-mokotoff-soundex">  Daitch-Mokotoff Soundex </h3><br><p>  Karena Soundex hanya cocok untuk bahasa Inggris, beberapa peneliti telah berusaha untuk memodifikasinya.  Pada tahun 1985, Gary Mokotoff dan Randy Daitch mengusulkan varian dari algoritma Soundex, yang dirancang untuk membandingkan nama keluarga Eropa Timur (termasuk Rusia) dengan kualitas yang cukup tinggi. </p><br><h3 id="metaphone">  Metafon </h3><br><p>  Pada tahun 90-an, Lawrence Philips (Lawrence Philips) mengusulkan versi alternatif dari algoritma Soundex, yang disebut Metaphone.  Algoritma baru menggunakan seperangkat aturan yang lebih besar untuk pengucapan bahasa Inggris karena lebih akurat.  Kemudian, algoritma tersebut dimodifikasi untuk digunakan dalam bahasa lain berdasarkan transkripsi menggunakan huruf-huruf alfabet Latin. </p><br><h3 id="russkiy-metaphone">  Metafon Rusia </h3><br><p>  Pada tahun 2002, edisi ke-8 majalah Programmer menerbitkan sebuah artikel oleh Peter Kankowski yang menceritakan tentang adaptasinya terhadap versi bahasa Inggris dari algoritma Metaphone.  Versi algoritma ini mengubah kata-kata sumber sesuai dengan aturan dan norma-norma bahasa Rusia, dengan mempertimbangkan suara fonetik dari huruf-huruf vokal yang tidak ditekan dan kemungkinan "penggabungan" konsonan dalam pengucapan. </p><br><h2 id="vmesto-zaklyucheniya">  Alih-alih sebuah kesimpulan </h2><br><p>  Sebagai hasil dari beberapa iterasi, tim proyek dari proyek pengembangan produk perangkat lunak, yang disebutkan dalam pendahuluan, mengembangkan solusi arsitektur, skema yang ditunjukkan pada gambar. <br><img src="https://habrastorage.org/webt/fr/yx/dg/fryxdgd4sf1lcf1iachctg_rvqc.png"></p><br><p>  Deskripsi tekstual pasien diterima melalui layanan REST dan disimpan dalam repositori (basis data kartu) tanpa perubahan apa pun.  Karena sistem kami bekerja dengan data medis, standar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FHIR</a> (Fast Healthcare Interoperability Resources) dipilih untuk pertukaran informasi.  Informasi tentang kartu pasien yang diterima ditransfer ke antrian pesan untuk analisis lebih lanjut dan pengambilan keputusan dalam menjalin komunikasi. </p><br><p>  Kartu pertama yang diproses adalah <em>"Penganalisis Cepat" yang</em> beroperasi pada algoritma deterministik.  Jika semua aturan algoritma deterministik berhasil, maka ia akan membuat catatan dengan tautan ke kartu yang diproses dalam penyimpanan terpisah (tautan basis data).  Catatan tersebut berisi tambahan untuk pengidentifikasi kartu yang dianalisis, tanggal pendirian komunikasi dan pengidentifikasi bersyarat yang mengidentifikasi pasien yang diidentifikasi secara global.  Kartu lebih lanjut selanjutnya disebut pengenal global yang ditentukan, sehingga membentuk sebuah array yang menggambarkan individu tertentu. </p><br><p>  Jika algoritma deterministik tidak menemukan kecocokan, maka informasi kartu ditransmisikan melalui antrian pesan ke "Full Analyzer". </p><br><p>       (  ).       .       : </p><br><p><img src="https://habrastorage.org/webt/i8/_7/-k/i8_7-km0ifcsu6llsqhmsruperg.png"></p><br><p> <strong> 1.  -</strong> <br>            ,       .          2. </p><br><p> <strong> 2.  </strong> <br>    -       ,         (). </p><br><p> <strong> 3.  </strong> <br>        ,    ,   (  )  ,      . </p><br><p> <strong> 4.   </strong> <br>     ,        .         .       ,      ,     .       ,   ,    ,         . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417465/">https://habr.com/ru/post/id417465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417453/index.html">Organisasi magang untuk siswa: menyapu dan trik</a></li>
<li><a href="../id417457/index.html">Frontend Conf Moscow - sisi klien masuk dan keluar</a></li>
<li><a href="../id417459/index.html">Ketahui JIT Anda: lebih dekat ke mobil</a></li>
<li><a href="../id417461/index.html">Ivan Tulup: asinkron di JS di bawah tenda</a></li>
<li><a href="../id417463/index.html">Pertemuan yang tidak terduga. Bab 17</a></li>
<li><a href="../id417469/index.html">Lima alasan egois untuk bekerja secara berulang</a></li>
<li><a href="../id417471/index.html">Solder Sederhana MK936 SMD. Stasiun solder DIY untuk komponen SMD</a></li>
<li><a href="../id417473/index.html">Penyimpanan Tepercaya dengan DRBD9 dan Proxmox (Bagian 1: NFS)</a></li>
<li><a href="../id417475/index.html">Glusterfs + erasure coding: saat Anda membutuhkan banyak, murah dan dapat diandalkan</a></li>
<li><a href="../id417477/index.html">Meja panas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>