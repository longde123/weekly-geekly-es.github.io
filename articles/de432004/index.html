<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🤝‍👨🏼 👩🏾‍🤝‍👨🏻 🦀 Einführung in die reaktive Programmierung 👃 💀 🥑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag. In diesem Artikel werde ich durch Europa galoppieren, nämlich Ihnen sagen, was sie unter reaktiver Programmierung verstehen, Schauspieler u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einführung in die reaktive Programmierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/arcadia/blog/432004/">  Guten Tag.  In diesem Artikel werde ich durch Europa galoppieren, nämlich Ihnen sagen, was sie unter reaktiver Programmierung verstehen, Schauspieler und reaktive Flüsse vorstellen und schließlich mithilfe reaktiver Flüsse Mausgesten erkennen, wie in der alten Oper und ihrem spirituellen Nachfolger - Vivaldi . <br><br>  Ziel ist es, die Grundkonzepte der reaktiven Programmierung vorzustellen und zu zeigen, dass nicht alles so kompliziert und beängstigend ist, wie es auf den ersten Blick erscheinen mag. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0c6/858/157/0c68581574002383d90367c3e6b996c9.jpg" alt="Bild"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a></i> <br><a name="habracut"></a><br><h2>  Was ist reaktive Programmierung? </h2><br>  Um diese Frage zu beantworten, wenden wir uns an die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Website</a> .  Es hat ein schönes Bild, das 4 Hauptkriterien zeigt, die reaktive Anwendungen erfüllen müssen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6e5/092/390/6e5092390fa27e7843b59d57da94b8b3.svg" alt="Bild"><br><br>  Die Anwendung sollte schnell, fehlertolerant und gut skalierbar sein. <br>  Es sieht so aus, als ob "wir für alle gut gegen alle schlecht sind", oder? <br><br>  Was ist mit diesen Worten gemeint: <br><br><ol><li> <b>Reaktionsfähigkeit</b> <br><br>  Die Anwendung sollte dem Benutzer das Ergebnis in einer halben Sekunde liefern.  Dies schließt auch das Prinzip des schnellen Ausfalls ein. Wenn also etwas schief geht, ist es besser, eine Fehlermeldung wie „Entschuldigung, es ist ein Problem aufgetreten.  Versuchen Sie es später noch einmal, damit das Wetter am Meer wartet.  Wenn der Vorgang lang ist, zeigen wir dem Benutzer einen Fortschrittsbalken.  Wenn es sehr lang ist - „Ihre Anfrage wird vorläufig am 18. März 2042 erfüllt.  Wir senden Ihnen eine Benachrichtigung per Post. " </li><li>  <b>Skalierbarkeit</b> ist eine Möglichkeit, unter Last <b>reaktionsschnell</b> zu sein.  Stellen Sie sich den Lebenszyklus eines relativ erfolgreichen Dienstes vor: <br><ol><li>  Start - Der Anforderungsfluss ist klein, der Dienst wird auf einer virtuellen Maschine mit einem Kern ausgeführt. </li><li>  Der Anforderungsfluss nimmt zu - Kernel werden der virtuellen Maschine hinzugefügt und Anforderungen werden in mehreren Threads verarbeitet. </li><li>  Noch mehr Last - wir verbinden Batching - Anfragen an die Datenbank und die Festplatte werden gruppiert. </li><li>  Noch mehr Last - Sie müssen mehr Server anheben und Arbeit im Cluster bereitstellen. <br>  Idealerweise sollte das System selbst je nach Belastung vergrößert oder verkleinert werden. </li></ol></li><li>  <b>Fehlertoleranz</b> <br><br>  Wir akzeptieren, dass wir in einer unvollkommenen Welt leben und alles passiert.  Für den Fall, dass in unserem System etwas schief geht, müssen wir Methoden zur Fehlerbehandlung und Wiederherstellung bereitstellen </li><li>  Und schließlich sind wir eingeladen, all dies mit einem System zu erreichen, dessen Architektur auf <b>nachrichtengesteuertem</b> Messaging basiert </li></ol><br>  Bevor ich fortfahre, möchte ich näher darauf eingehen, wie sich ereignisgesteuerte Systeme von nachrichtengesteuerten Systemen unterscheiden. <br><br>  <b>Ereignisgesteuert:</b> <br><br><ul><li>  Ereignis - Das System meldet, dass es einen bestimmten Status erreicht hat. </li><li>  Es können viele Abonnenten der Veranstaltung sein. </li><li>  Die Ereigniskette ist normalerweise kurz und die Ereignishandler befinden sich (sowohl physisch als auch im Code) in der Nähe der Quelle. </li><li>  Die Ereignisquelle und ihre Handler haben normalerweise einen gemeinsamen Status (physisch - sie verwenden denselben RAM-Teil für den Informationsaustausch). </li></ul><br>  <b>Im Gegensatz zu ereignisgesteuert in einem nachrichtengesteuerten System:</b> <br><br><ul><li>  Jede Nachricht hat nur einen Empfänger. </li><li>  Nachrichten sind unveränderlich: Sie können nichts an der empfangenen Nachricht ändern, damit der Absender davon erfährt und die Informationen lesen kann. </li><li>  Elemente des Systems reagieren auf empfangene Nachrichten (oder nicht) und können Nachrichten an andere Elemente des Systems senden. </li></ul><br>  Das alles bietet uns <br><br><h1>  Schauspieler Modell </h1><br>  Meilensteine ​​der Entwicklung: <br><br><ul><li>  Die erste Erwähnung von Schauspielern findet sich in einem wissenschaftlichen Artikel von 1973 - Carl Hewitt, Peter Bishop und Richard Steiger, "Ein universeller modularer ACTOR-Formalismus für künstliche Intelligenz". </li><li>  1986 - Erlang erscheint.  Ericson benötigte eine Sprache für Telekommunikationsgeräte, die Fehlertoleranz und fehlerfreie Ausbreitung bietet.  Im Kontext dieses Artikels sind seine Hauptmerkmale: <br><br><ul><li>  Alles ist ein Prozess </li><li>  Nachrichten sind die einzige Art der Kommunikation (Erlang ist eine funktionale Sprache und Nachrichten darin sind unveränderlich). </li></ul></li><li>  .. </li><li>  2004 - die erste Version der Scala-Sprache.  Seine Eigenschaften: <ul><li>  Powered by JVM, </li><li>  Funktionell </li><li>  Für Multithreading wurde ein Akteurmodell ausgewählt. </li></ul><br></li><li>  2009 - Die Umsetzung der Akteure wurde in einer separaten Bibliothek - Akka - zugewiesen </li><li>  2014 - Akka.net - es wurde auf .Net portiert. </li></ul><br><h1>  Was können Schauspieler tun? </h1><br>  Schauspieler sind die gleichen Objekte, aber: <br><br><ul><li>  Im Gegensatz zu gewöhnlichen Objekten können sich die Akteure nicht gegenseitig aufrufen. </li><li>  Akteure können Informationen <b>nur über unveränderliche Nachrichten übertragen</b> . </li><li>  Nach Erhalt der Nachricht kann der Schauspieler <br><ul><li>  Erstellen Sie neue Akteure (sie werden in der Hierarchie niedriger sein), </li><li>  Senden Sie Nachrichten an andere Akteure, </li><li>  Stoppen Sie die Akteure unten in der Hierarchie und sich selbst. </li></ul></li></ul><br>  Schauen wir uns ein Beispiel an. <br><br><img src="https://habrastorage.org/webt/ql/wj/cj/qlwjcjyygaw5s7iub_mshc1rbry.jpeg" alt="Bild"><br><br>  Schauspieler A möchte eine Nachricht an Schauspieler B senden. Er hat nur ActorRef (eine Adresse).  Schauspieler B kann überall sein. <br>  Akteur A sendet einen Buchstaben B über das System (ActorSystem).  Das System legt den Brief in die Mailbox von Schauspieler B und „weckt“ Schauspieler B. Schauspieler B nimmt den Brief aus der Mailbox und tut etwas. <br><br>  Im Vergleich zum Aufrufen von Methoden für ein anderes Objekt sieht es unnötig kompliziert aus, aber das Modell der Schauspieler passt perfekt in die reale Welt, wenn Sie sich vorstellen, dass Schauspieler Menschen sind, die darauf trainiert sind, auf bestimmte Reize zu reagieren. <br><br>  Stellen Sie sich einen Vater und einen Sohn vor: <br><br><img src="https://habrastorage.org/webt/gk/o9/s5/gko9s5syabkkpdkg0_v_aimwwis.jpeg"><br><br>  Der Vater schickt seinem Sohn SMSku „Clean in the room“ und macht weiterhin sein eigenes Ding.  Der Sohn liest SMSku und beginnt zu putzen.  Vater spielt mittlerweile Poker.  Der Sohn beendet die Reinigung und sendet eine SMS „Fertig stellen“.  Es sieht einfach aus, oder? <br><br>  Stellen Sie sich nun vor, Vater und Sohn sind keine Schauspieler, sondern gewöhnliche Objekte, die sich gegenseitig in die Quere kommen lassen.  Der Vater zieht seinen Sohn für die Methode „Zimmer reinigen“ und folgt ihm auf den Fersen. Er wartet, bis der Sohn mit der Reinigung fertig ist und die Kontrolle an seinen Vater zurückgibt.  Vater kann derzeit nicht Poker spielen.  In diesem Zusammenhang wird das Akteurmodell attraktiver. <br><br>  Nun gehen wir weiter zu <br><br><h1>  Akka.NET </h1><br>  Alles, was unten geschrieben steht, gilt für das ursprüngliche Akka für die JVM, aber für mich ist C # näher als Java, daher werde ich Akka.NET als Beispiel verwenden. <br><br><h3>  Was sind die Vorteile von Akka? </h3><br><ul><li>  Multithreading durch Messaging.  Sie müssen nicht mehr mit allen Arten von Sperren, Semaphoren, Mutexen und anderen Reizen leiden, die für klassisches Multithreading mit gemeinsamem Speicher charakteristisch sind. </li><li>  Transparente Kommunikation zwischen dem System und seinen Komponenten.  Sie müssen sich keine Gedanken über komplexen Netzwerkcode machen - das System selbst findet das Nachrichtenziel und garantiert die Nachrichtenübermittlung (hier können Sie einen Witz über UDP und TCP einfügen). </li><li>  Flexible Architektur, die automatisch vergrößert oder verkleinert werden kann.  Unter Last kann das System beispielsweise zusätzliche Clusterknoten anheben und die Last gleichmäßig verteilen. </li></ul><br>  Das Thema Skalierung ist jedoch sehr umfangreich und verdient eine gesonderte Veröffentlichung.  Daher werde ich nur auf die Funktion näher eingehen, die in allen Projekten nützlich sein wird: <br><br><h2>  Fehlerbehandlung </h2><br>  Akteure haben eine Hierarchie - sie kann als Baum dargestellt werden.  Jeder Schauspieler hat einen Elternteil und kann „Kinder“ haben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/99e/57e/919/99e57e919cbea8e6761b75537c3f507a.png" alt="Bild"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Akka.NET-Dokumentation</a> Copyright 2013-2018 Akka.NET-Projekt</i> <br><br>  Für jeden Schauspieler können Sie eine Überwachungsstrategie festlegen - was zu tun ist, wenn für die „Kinder“ etwas schief geht.  Schlagen Sie beispielsweise einen Schauspieler, der Probleme hat, und erstellen Sie dann einen neuen Schauspieler des gleichen Typs und vertrauen Sie ihm die gleiche Arbeit an. <br><br>  Zum Beispiel habe ich eine Anwendung auf Akka.net CRUD erstellt, in der die Ebene der "Geschäftslogik" auf den Akteuren implementiert ist.  Das Ziel dieses Projekts war es herauszufinden, ob Akteure in nicht skalierbaren Systemen eingesetzt werden sollten - werden sie das Leben verbessern oder mehr Schmerzen verursachen. <br><br>  Wie die integrierte Fehlerbehandlung von Akka helfen kann: <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/1f/oz/ou/1fozoulh0ufwzuyufofz4n8pvbi.gif"><br></div></div><br><ol><li>  alles ist in Ordnung, die Anwendung funktioniert, </li><li>  Es ist etwas mit dem Repository passiert, und jetzt gibt es nur noch 1 von 5 Ergebnissen. </li><li>  Ich habe die Überwachungsstrategie auf "10 Mal pro Sekunde versuchen" eingestellt. </li><li>  Die Anwendung funktioniert wieder (wenn auch langsamer), und ich habe Zeit, um herauszufinden, was los ist. </li></ol><br>  Es besteht die Versuchung zu sagen: "Komm schon, ich schreibe solche Fehler selbst. Warum müssen einige Schauspieler einen Fehler machen?"  Faire Bemerkung, aber nur, wenn es nur wenige Fehler gibt. <br><br>  Und etwas Code.  So sieht die Initialisierung des Akteursystems im IoC-Container aus: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Container</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { system = ActorSystem.Create(<span class="hljs-string"><span class="hljs-string">"MySystem"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> echo = system.ActorOf&lt;EchoActor&gt;(<span class="hljs-string"><span class="hljs-string">"Echo"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//stop initialization if something is wrong with actor system var alive = echo.Ask&lt;bool&gt;(true, TimeSpan.FromMilliseconds(100)).Result; container = new WindsorContainer(); //search for dependencies //register controllers //register ActorSystem propsResolver = new WindsorDependencyResolver(container, (ActorSystem)system); system.AddDependencyResolver(propsResolver); actorSystemWrapper = new ActorSystemWrapper(system, propsResolver); container.Register(Component.For&lt;IActorRefFactory&gt;().Instance(actorSystemWrapper)); container.Register(Component.For&lt;IDependencyResolver&gt;().Instance(propsResolver)); }</span></span></code> </pre> <br>  EchoActor ist der einfachste Akteur, der dem Absender einen Wert zurückgibt: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EchoActor</span></span> : <span class="hljs-title"><span class="hljs-title">ReceiveActor</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EchoActor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Receive&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(flag =&gt; { Sender.Tell(flag); }); } }</code> </pre><br>  Um die Akteure mit dem „normalen“ Code zu verbinden, wird der Befehl Ask verwendet: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;ActionResult&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Index</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ViewBag.Type = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Model); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> CrudActorRef.Ask&lt;IEnumerable&lt;Model&gt;&gt;(DataMessage.GetAll&lt;Model&gt;(), maxDelay); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> View(res); }</code> </pre> <br><h3>  Insgesamt </h3><br>  Mit den Schauspielern kichern kann ich sagen: <br><br><ul><li>  Schauen Sie sich diese an, wenn Sie Skalierbarkeit benötigen. </li><li>  Für komplexe Geschäftslogik ist es besser, sie wegen nicht zu verwenden <ul><li>  seltsame Abhängigkeitsinjektion.  Um einen Akteur mit den erforderlichen Abhängigkeiten zu initialisieren, müssen Sie zuerst ein Requisitenobjekt erstellen und es dann dem ActorSystem übergeben, um einen Akteur des gewünschten Typs zu erstellen.  Zum Erstellen von Requisiten mit IoC-Containern (z. B. Castle Windsor oder Autofac) gibt es vorgefertigte Wrapper - DependencyResolvers.  Ich war jedoch mit der Tatsache konfrontiert, dass der IoC-Container versuchte, die Abhängigkeitslebensdauer zu kontrollieren, und nach einer Weile fiel das System leise ab. <br><br>  * Vielleicht sollten Sie diese Abhängigkeit als untergeordneten Akteur platzieren, anstatt eine Abhängigkeit in ein Objekt einzufügen. </li><li>  Tippprobleme.  ActorRef weiß nichts über die Art des Schauspielers, auf den es sich bezieht.  Das heißt, zur Kompilierungszeit ist nicht bekannt, ob ein Akteur eine Nachricht dieses Typs verarbeiten kann oder nicht. </li></ul></li></ul><br><h1>  Teil 2: Jetstreams </h1><br>  Kommen wir nun zu einem populäreren und nützlicheren Thema - Jet Flows.  Wenn Sie sich während der Arbeit nie mit Schauspielern treffen können, sind Rx-Streams sowohl im Frontend als auch im Backend sicherlich nützlich.  Ihre Implementierung erfolgt in fast allen modernen Programmiersprachen.  Ich werde Beispiele für RxJs geben, da heutzutage sogar Backend-Programmierer manchmal etwas in JavaScript tun müssen. <br><br><img src="https://habrastorage.org/webt/ru/yn/g9/ruyng9clvfa1gh8bd5ai3lpnc5m.jpeg"><br>  <i>Rx-Streams sind für alle gängigen Programmiersprachen verfügbar.</i> <br><br>  <i>" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einführung in die reaktive Programmierung, die Sie vermisst haben</a> " von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andre Staltz</a> , lizenziert unter CC BY-NC 4.0</i> <br><br>  Um zu erklären, was Jetstream ist, beginne ich mit den Pull- und Push-Sammlungen. <br><table><tbody><tr><th></th><th>  Einzelner Rückgabewert </th><th>  Mehrere Rückgabewerte </th></tr><tr><td>  Ziehen <br>  Synchron <br>  Interaktiv </td><td>  T. </td><td>  IEnumerable &lt;T&gt; </td></tr><tr><td>  Drücken Sie <br>  Asynchron <br>  Reaktiv </td><td>  Aufgabe &lt;T&gt; </td><td>  IObservable &lt;T&gt; </td></tr></tbody></table><br>  Pull-Sammlungen sind das, was wir alle in der Programmierung gewohnt sind.  Das auffälligste Beispiel ist ein Array. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>];</code> </pre> <br>  Es hat bereits Daten, er selbst wird diese Daten nicht ändern, aber er kann sie auf Anfrage geben. <br><br><pre> <code class="javascript hljs">arr.forEach(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log);</code> </pre> <br>  Bevor Sie etwas mit den Daten tun, können Sie sie auch irgendwie verarbeiten. <br><br><pre> <code class="javascript hljs">arr.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> i+<span class="hljs-number"><span class="hljs-number">1</span></span>).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">I</span></span></span><span class="hljs-function"> =&gt;</span></span> “my number is ”+i).forEach(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log);</code> </pre> <br>  Stellen wir uns nun vor, dass sich anfangs keine Daten in der Sammlung befinden, aber es wird Sie definitiv darüber informieren, dass sie erschienen sind (Push).  Gleichzeitig können wir die notwendigen Transformationen auf diese Sammlung anwenden. <br><br>  Zum Beispiel: <br><br><pre> <code class="javascript hljs">source.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> i+<span class="hljs-number"><span class="hljs-number">1</span></span>).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">I</span></span></span><span class="hljs-function"> =&gt;</span></span> “my number is ”+i).forEach(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log);</code> </pre> <br>  Wenn in der Quelle ein Wert wie 1 angezeigt wird, gibt console.log "Meine Nummer ist 1" aus. <br><br>  Wie es funktioniert: <br><br>  Eine neue Entität wird angezeigt - Betreff (oder Beobachtbar): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = Rx.Observable.create(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) </span></span>{ observer.next(<span class="hljs-number"><span class="hljs-number">1</span></span>); observer.next(<span class="hljs-number"><span class="hljs-number">2</span></span>); observer.next(<span class="hljs-number"><span class="hljs-number">3</span></span>); setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { observer.next(<span class="hljs-number"><span class="hljs-number">4</span></span>); observer.complete(); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); });</code> </pre> <br>  Dies ist eine Push-Sammlung, die Benachrichtigungen über Änderungen in ihrem Status sendet. <br><br>  In diesem Fall erscheinen die Nummern 1, 2 und 3 sofort darin, in einer zweiten 4, und dann wird die Sammlung "beendet".  Dies ist eine besondere Art von Veranstaltung. <br><br>  Die zweite Entität ist Observer.  Er kann Betreffereignisse abonnieren und mit den empfangenen Daten etwas unternehmen.  Zum Beispiel: <br><br><pre> <code class="javascript hljs">observable.subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x)); observable.subscribe({ <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'got value '</span></span> + x), <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(<span class="hljs-string"><span class="hljs-string">'something wrong occurred: '</span></span> + err), <span class="hljs-attr"><span class="hljs-attr">complete</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'done'</span></span>), }); observable .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'This is '</span></span> + x) .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x));</code> </pre> <br>  Es ist ersichtlich, dass ein Betreff viele Abonnenten haben kann. <br><br>  Es sieht einfach aus, aber es ist noch nicht klar, warum dies notwendig ist.  Ich werde zwei weitere Definitionen geben, die Sie kennen müssen, wenn Sie mit reaktiven Flüssen arbeiten, und dann werde ich in der Praxis zeigen, wie sie funktionieren und in welchen Situationen ihr volles Potenzial offenbart wird. <br><br><h4>  Kalte Observablen </h4><br><ul><li>  Benachrichtigen Sie über Ereignisse, wenn jemand sie abonniert. </li><li>  Der gesamte Datenstrom wird unabhängig vom Zeitpunkt des Abonnements erneut an jeden Teilnehmer gesendet. </li><li>  Daten werden für jeden Teilnehmer kopiert. </li></ul><br>  Was bedeutet das? Nehmen wir an, das Unternehmen (Betreff) hat beschlossen, die Verteilung der Geschenke zu arrangieren.  Jeder Mitarbeiter (Beobachter) kommt zur Arbeit und erhält seine Kopie des Geschenks.  Niemand bleibt beraubt. <br><br><h4>  Heiße Observable </h4><br><ul><li>  Sie versuchen, das Ereignis unabhängig von der Anwesenheit von Abonnenten zu benachrichtigen.  Wenn zum Zeitpunkt der Veranstaltung keine Abonnenten vorhanden waren, gehen die Daten verloren. </li></ul><br>  Beispiel: Am Morgen werden heiße Kuchen für Mitarbeiter ins Unternehmen gebracht.  Wenn sie hereingebracht werden, fliegen alle Lerchen zum Geruch und machen die Kuchen zum Frühstück aus.  Aber die Eulen, die später kamen, bekommen keine Kuchen mehr. <br><br><h4>  In welchen Situationen werden Jetstreams eingesetzt? </h4><br>  Wenn ein Datenstrom über die Zeit verteilt ist.  Zum Beispiel Benutzereingaben.  Oder protokolliert von jedem Dienst.  In einem der Projekte sah ich einen selbst erstellten Logger, der Ereignisse in N Sekunden sammelte und dann gleichzeitig das gesamte Paket aufzeichnete.  Der Batteriecode belegte die Seite.  Wenn Rx-Streams verwendet würden, wäre dies viel einfacher: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b6e/b1a/396/b6eb1a3960bd8b422c01b6c0a5dd97f0.png" alt="Bild"><br>  <i>“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RxJs Reference / Observable</a> , Dokumentation lizenziert unter CC BY 4.0</i> . <br>  <i>(Es gibt viele Beispiele und Bilder, die erklären, was verschiedene Operationen mit reaktiven Strömungen bewirken.)</i> <br><br><pre> <code class="javascript hljs">source.bufferTime(<span class="hljs-number"><span class="hljs-number">2000</span></span>).subsribe(doThings);</code> </pre> <br>  Und schließlich ein Anwendungsbeispiel. <br><br><h2>  Erkennen von Mausgesten mit Rx-Streams </h2><br>  In der alten Oper oder ihrem spirituellen Nachfolger - Vivaldi - gab es eine Browsersteuerung mit Mausgesten. <br><br><div class="spoiler">  <b class="spoiler_title">Gif - Mausgesten in Vivaldi</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/xs/ok/eq/xsokeqelkjbtvgrcurbv-wffmog.gif"><br></div></div><br>  Das heißt, Sie müssen Mausbewegungen nach oben / unten, rechts / links und Kombinationen davon erkennen.  Es kann ohne Rx-Streams geschrieben werden, aber der Code ist komplex und schwer zu pflegen. <br><br><h4>  Und so sieht es mit Rx-Streams aus: </h4><br>  Ich beginne am Ende - Ich lege fest, welche Daten und in welchem ​​Format ich in der ursprünglichen Reihenfolge suchen werde: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//gestures to look for const gestures = Rx.Observable.from([ { name: "Left", sequence: Rx.Observable.from([{ x: -1, y: 0 }]) }, { name: "Right", sequence: Rx.Observable.from([{ x: 1, y: 0 }]) }, { name: "Up", sequence: Rx.Observable.from([{ x: 0, y: -1 }]) }, { name: "Down", sequence: Rx.Observable.from([{ x: 0, y: 1 }]) }, { name: "Down+Up", sequence: Rx.Observable.from([{ x: 0, y: 1 }, { x: 0, y: -1 }]) }, { name: "Up+Right", sequence: Rx.Observable.from([{ x: 0, y: -1 }, { x: 1, y: 0 }]) } ]);</span></span></code> </pre> <br>  Dies sind Einheitsvektoren und ihre Kombinationen. <br><br>  Als Nächstes müssen Sie die Mausereignisse in Rx-Streams konvertieren.  Alle Rx-Bibliotheken verfügen über integrierte Tools, mit denen Standardereignisse in Observables umgewandelt werden können. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mouseMoves = Rx.Observable.fromEvent(canvas, <span class="hljs-string"><span class="hljs-string">'mousemove'</span></span>), mouseDowns = Rx.Observable.fromEvent(canvas, <span class="hljs-string"><span class="hljs-string">'mousedown'</span></span>), mouseUps = Rx.Observable.fromEvent(canvas, <span class="hljs-string"><span class="hljs-string">'mouseup'</span></span>);</code> </pre> <br>  Als nächstes gruppiere ich die Koordinaten der Maus nach 2 und finde ihren Unterschied, wobei ich den Mausversatz erhalte. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mouseDiffs = mouseMoves .map(getOffset) .pairwise() .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pair</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: pair[<span class="hljs-number"><span class="hljs-number">1</span></span>].x-pair[<span class="hljs-number"><span class="hljs-number">0</span></span>].x, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: pair[<span class="hljs-number"><span class="hljs-number">1</span></span>].y-pair[<span class="hljs-number"><span class="hljs-number">0</span></span>].y } });</code> </pre> <br>  Und gruppieren Sie diese Bewegungen mit den Ereignissen 'Mousedown' und 'Mouseup'. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mouseGestures = mouseDiffs .bufferToggle(mouseDowns, x =&gt; mouseUps) .map(concat);</code> </pre> <br>  Die Concat-Funktion schneidet zu kurze Bewegungen aus und gruppiert Bewegungen, die grob in Richtung ausgerichtet sind. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{<span class="hljs-comment"><span class="hljs-comment">//summarize move in same direction return values.reduce((a, v) =&gt; { if (!a.length) { a.push(v); } else { const last = a[a.length - 1]; const lastAngle = Math.atan2(last.x, last.y); const angle = Math.atan2(vx, vy); const angleDiff = normalizeAngle(angle - lastAngle); const dist = Math.hypot(vx, vy); if (dist &lt; 1) return a;//move is too short – ignore //moving in same direction =&gt; adding vectors if (Math.abs(angleDiff) &lt;= maxAngleDiff) { last.x += vx; last.y += vy; } else { a.push(v); } } return a; }, []); }</span></span></code> </pre> <br>  Wenn die Bewegung auf der X- oder Y-Achse zu kurz ist, wird sie auf Null zurückgesetzt.  Und dann bleibt nur das Vorzeichen von den erhaltenen Verschiebungskoordinaten übrig.  Somit werden die Einheitsvektoren erhalten, nach denen wir gesucht haben. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> normalizedMouseGestures = mouseGestures.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr</span></span></span><span class="hljs-function"> =&gt;</span></span> arr.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dist = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.hypot(vx, vy);<span class="hljs-comment"><span class="hljs-comment">//length of vector vx = Math.abs(vx) &gt; minMove &amp;&amp; Math.abs(vx) * treshold &gt; dist ? vx : 0; vy = Math.abs(vy) &gt; minMove &amp;&amp; Math.abs(vy) * treshold &gt; dist ? vy : 0; return v; }) ).map(arr =&gt; arr .map(v =&gt; { return { x: Math.sign(vx), y: Math.sign(vy) }; }) .filter(v =&gt; Math.hypot(vx, vy) &gt; 0) );</span></span></code> </pre> <br>  Ergebnis: <br><br><pre> <code class="javascript hljs">gestures.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">gesture</span></span></span><span class="hljs-function"> =&gt;</span></span> normalizedMouseGestures.mergeMap( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">moves</span></span></span><span class="hljs-function"> =&gt;</span></span> Rx.Observable.from(moves) .sequenceEqual(gesture.sequence, comparer) ).filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x).mapTo(gesture.name) ).mergeAll().subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">gestureName</span></span></span><span class="hljs-function"> =&gt;</span></span> actions[gestureName]());</code> </pre> <br>  Mit sequenceEqual können Sie die empfangenen Bewegungen mit den ursprünglichen Bewegungen vergleichen und bei Übereinstimmung eine bestimmte Aktion ausführen. <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/lp/bx/fe/lpbxfeq_bq-mdfybskn0v7wwen8.gif"><br></div></div><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier können Sie mit Gesten spielen</a> <br><br>  Bitte beachten Sie, dass neben der Gestenerkennung auch eine Zeichnung der anfänglichen und normalisierten Mausbewegungen auf der HTML-Zeichenfläche angezeigt wird.  Die Lesbarkeit des Codes leidet nicht darunter. <br><br>  Daraus ergibt sich ein weiterer Vorteil: Die mit Hilfe von Rx-Streams geschriebene Funktionalität kann einfach ergänzt und erweitert werden. <br><br><h2>  Zusammenfassung </h2><br><ul><li>  Bibliotheken mit Rx-Streams sind für fast alle Programmiersprachen verfügbar. </li><li>  Rx-Streams sollten verwendet werden, wenn ein Stream von Ereignissen über die Zeit verteilt ist (z. B. Benutzereingaben). </li><li>  Mit Rx-Streams geschriebene Funktionen können einfach ergänzt und erweitert werden. </li><li>  Ich habe keine wesentlichen Mängel festgestellt. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Nützliche Links</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.introtorx.com</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">getakka.net/articles/intro/what-is-akka.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">reactivex.io/rxjs/class/es6/Observable.js~Observable.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">reactivex.io/languages.html</a> </div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432004/">https://habr.com/ru/post/de432004/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431992/index.html">Biometrie: Wie geht es uns und ihnen?</a></li>
<li><a href="../de431994/index.html">Diskussion der kostenlosen PVS-Studio-Lizenz für auf GitHub gehostete Projekte</a></li>
<li><a href="../de431996/index.html">Smart Engines Science Corporate (oder wie wir zum ICMV 2018 gefahren sind)</a></li>
<li><a href="../de431998/index.html">Treffen Sie Yandex.Phone - jetzt offiziell</a></li>
<li><a href="../de432002/index.html">Microsoft entwickelt einen auf Chromium basierenden Browser, der standardmäßig anstelle von Edge ausgeliefert wird</a></li>
<li><a href="../de432006/index.html">Die Geschichte, wie ich zum Thema Frauengesundheit gekommen bin</a></li>
<li><a href="../de432008/index.html">Jagd nach Webstandards</a></li>
<li><a href="../de432012/index.html">So testen Sie intelligente Verträge</a></li>
<li><a href="../de432014/index.html">Kali Linux für Anfänger</a></li>
<li><a href="../de432016/index.html">Wie Musik und Zeichnen mir das Programmieren beigebracht haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>