<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌰 🧚🏿 👩‍👩‍👧‍👦 Tarantool Cartridge: Sharding Lua Backend in drei Zeilen 📙 🏵️ 📳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In der Mail.ru-Gruppe haben wir Tarantool, einen Lua-basierten Anwendungsserver und eine Datenbank vereint. Es ist schnell und elegant, aber die Resso...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tarantool Cartridge: Sharding Lua Backend in drei Zeilen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/470812/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/tg/6f/71/tg6f71dbjoo5m5qm5ebndfjxjdu.jpeg"></div><br>  In der Mail.ru-Gruppe haben wir Tarantool, einen Lua-basierten Anwendungsserver und eine Datenbank vereint.  Es ist schnell und elegant, aber die Ressourcen eines einzelnen Servers sind immer begrenzt.  Vertikale Skalierung ist auch kein Allheilmittel.  Aus diesem Grund verfügt Tarantool über einige Tools für die horizontale Skalierung oder das vshard-Modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[1]</a> .  Sie können Daten auf mehrere Server verteilen, müssen jedoch eine Weile daran basteln, um sie zu konfigurieren und die Geschäftslogik zu verbessern. <br><br>  Gute Nachricht: Wir haben unseren Anteil an Unebenheiten (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[2]</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[3]</a> ) und ein weiteres Framework erstellt, das die Lösung dieses Problems erheblich vereinfacht. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tarantool Cartridge</a> ist das neue Framework für die Entwicklung komplexer verteilter Systeme.  Sie können sich darauf konzentrieren, Geschäftslogik zu schreiben, anstatt Infrastrukturprobleme zu lösen.  Im Folgenden werde ich Ihnen erläutern, wie dieses Framework funktioniert und wie es beim Schreiben verteilter Dienste hilfreich sein kann. <br><a name="habracut"></a><br><h2>  Was genau ist das Problem? </h2><br>  Wir haben Tarantool und vshard - was wollen wir mehr? <br><br>  Erstens ist es eine Frage der Bequemlichkeit.  Vshard ist in Lua-Tabellen konfiguriert.  Damit ein verteiltes System mit mehreren Tarantool-Prozessen ordnungsgemäß funktioniert, muss die Konfiguration jedoch überall gleich sein.  Niemand möchte dies manuell tun, daher werden alle Arten von Skripten, Ansible und Bereitstellungssystemen verwendet. <br><br>  Cartridge selbst verwaltet die vshard-Konfiguration basierend auf <i>seiner eigenen verteilten Konfiguration</i> .  Tatsächlich handelt es sich um eine einfache YAML-Datei, deren Kopie auf jeder Tarantool-Instanz gespeichert ist.  Mit anderen Worten, das Framework überwacht seine Konfiguration so, dass sie überall gleich ist. <br><br>  Zweitens ist es wieder eine Frage der Bequemlichkeit.  Die Vshard-Konfiguration bezieht sich nicht auf die Entwicklung der Geschäftslogik und lenkt einen Entwickler nur von seiner Arbeit ab.  Wenn wir die Architektur eines Projekts diskutieren, handelt es sich höchstwahrscheinlich um separate Komponenten und deren Interaktion.  Es ist noch zu früh, um überhaupt über die Bereitstellung eines Clusters für drei Rechenzentren nachzudenken. <br><br>  Wir haben diese Probleme immer wieder gelöst und irgendwann einen Ansatz entwickelt, um die Arbeit mit der Anwendung über den gesamten Lebenszyklus hinweg zu vereinfachen: Erstellung, Entwicklung, Test, CI / CD, Wartung. <br><br>  Cartridge führt das Konzept der Rollen für jeden Tarantool-Prozess ein.  Mithilfe von Rollen kann sich der Entwickler auf das Schreiben von Code konzentrieren.  Alle im Projekt verfügbaren Rollen können auf der einzelnen Instanz von Tarantool ausgeführt werden. Dies würde zum Testen ausreichen. <br><br>  Hauptmerkmale der Tarantool-Patrone: <br><br><ul><li>  automatisierte Cluster-Orchestrierung; <br></li><li>  erweiterte Anwendungsfunktionalität mit neuen Rollen; <br></li><li>  Anwendungsvorlage für Entwicklung und Bereitstellung; <br></li><li>  eingebautes automatisches Sharding; <br></li><li>  Integration in das Luatest-Framework; <br></li><li>  Clusterverwaltung über WebUI und API; <br></li><li>  Verpackungs- und Bereitstellungstools. <br></li></ul><br><h2>  Hallo Welt! </h2><br>  Ich kann es kaum erwarten, Ihnen das Framework selbst zu zeigen. Speichern wir also die Geschichte über Architektur für später und beginnen Sie mit einer einfachen Aufgabe.  Vorausgesetzt, Tarantool ist bereits installiert, müssen wir nur noch etwas tun <br><br><pre><code class="plaintext hljs">$ tarantoolctl rocks install cartridge-cli $ export PATH=$PWD/.rocks/bin/:$PATH</code> </pre> <br>  Als Ergebnis werden die Befehlszeilenprogramme installiert, mit denen Sie Ihre erste Anwendung aus der Vorlage erstellen können: <br><br><pre> <code class="plaintext hljs">$ cartridge create --name myapp</code> </pre> <br>  Und hier ist was wir bekommen: <br><br><pre> <code class="plaintext hljs">myapp/ ├── .git/ ├── .gitignore ├── app/roles/custom.lua ├── deps.sh ├── init.lua ├── myapp-scm-1.rockspec ├── test │ ├── helper │ │ ├── integration.lua │ │ └── unit.lua │ ├── helper.lua │ ├── integration/api_test.lua │ └── unit/sample_test.lua └── tmp/</code> </pre> <br>  Dies ist ein Git-Repository mit einem gebrauchsfertigen "Hallo Welt!"  Anwendung.  Versuchen wir, es nach der Installation der Abhängigkeiten (einschließlich des Frameworks selbst) auszuführen: <br><br><pre> <code class="plaintext hljs">$ tarantoolctl rocks make $ ./init.lua --http-port 8080</code> </pre> <br>  Wir haben einen Knoten unserer zukünftigen Sharded-Anwendung gestartet.  Wenn Sie neugierig sind, können Sie sofort die Weboberfläche öffnen, die auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">localhost</a> : 8080 ausgeführt wird. Verwenden Sie eine Maus, um einen Cluster mit einem Knoten zu konfigurieren und das Ergebnis zu genießen, aber freuen Sie sich nicht zu früh.  Die Anwendung weiß noch nicht, wie sie etwas Nützliches tun soll, daher werde ich Sie später über die Bereitstellung informieren, und jetzt ist es Zeit, Code zu schreiben. <br><br><h2>  Anwendungen entwickeln </h2><br>  Stellen Sie sich vor, wir entwerfen ein System, das Daten empfangen, speichern und einmal täglich einen Bericht erstellen soll. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc6/dba/8a2/dc6dba8a2a2ff31693cff9a825c44b7f.png"></div><br>  Wir zeichnen also ein Diagramm mit drei Komponenten: Gateway, Speicher und Scheduler.  Lassen Sie uns weiter an der Architektur arbeiten.  Da wir vshard als Speicher verwenden, fügen wir dem Diagramm vshard-router und vshard-storage hinzu.  Weder das Gateway noch der Scheduler greifen direkt auf den Speicher zu - für diese Aufgabe wird explizit ein Router erstellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/151/eb0/ac5/151eb0ac5b9d8a1a6217e0992b502089.png"></div><br>  Dieses Diagramm sieht abstrakt aus, da die Komponenten immer noch nicht das widerspiegeln, was wir im Projekt erstellen werden.  Wir müssen sehen, wie dieses Projekt echtem Tarantool entspricht, also gruppieren wir unsere Komponenten nach dem Prozess. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fdc/781/a46/fdc781a46e819a67232bfcd308605b5d.png"></div><br>  Es macht wenig Sinn, vshard-router und gateway auf getrennten Instanzen zu halten.  Warum sollten wir noch einmal über das Netzwerk gehen, wenn dies bereits in der Verantwortung des Routers liegt?  Sie sollten innerhalb desselben Prozesses ausgeführt werden, dh sowohl das Gateway als auch vshard.router.cfg sollten im selben Prozess initialisiert werden und lokal interagieren. <br><br>  Während der Entwurfsphase war es praktisch, mit drei Komponenten zu arbeiten, aber als Entwickler möchte ich nicht daran denken, drei Instanzen von Tarantool beim Schreiben von Code zu starten.  Ich muss die Tests ausführen und überprüfen, ob ich den Gateway-Code korrekt geschrieben habe.  Oder ich möchte meinen Mitarbeitern eine neue Funktion zeigen.  Warum sollte ich Probleme mit der Bereitstellung von drei Instanzen haben?  So wurde das Konzept der Rollen geboren.  Eine Rolle ist ein reguläres Lua-Modul, und Cartridge verwaltet seinen Lebenszyklus.  In diesem Beispiel gibt es vier davon: Gateway, Router, Speicher und Scheduler.  Ein anderes Projekt hat möglicherweise mehr Rollen.  Alle Rollen können in einem Prozess gestartet werden, und es würde ausreichen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e1/49c/95a/1e149c95aed1d5dc7cf73e298198c719.png"></div><br>  Wenn es um die Bereitstellung für Staging oder Produktion geht, weisen wir jedem Tarantool-Prozess abhängig von den zugrunde liegenden Hardwarefunktionen einen separaten Rollensatz zu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f9/b59/1d7/1f9b591d794e4b459b863f0da01f042b.png"></div><br><h2>  Topologieverwaltung </h2><br>  Wir sollten auch irgendwo Informationen über die laufenden Rollen speichern.  Und "irgendwo" bedeutet die oben erwähnte verteilte Konfiguration.  Das Wichtigste dabei ist die Clustertopologie.  Hier sehen Sie 3 Replikationsgruppen von 5 Tarantool-Prozessen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb6/118/a0f/eb6118a0f7c2381ce82491bd65272ec5.png"></div><br>  Wir möchten die Daten nicht verlieren, deshalb behandeln wir die Informationen über die laufenden Prozesse mit Sorgfalt.  Cartridge überwacht die Konfiguration mithilfe eines zweiphasigen Commits.  Sobald wir die Konfiguration aktualisieren möchten, wird zunächst geprüft, ob die Instanzen verfügbar und bereit sind, die neue Konfiguration zu akzeptieren.  Danach wird die Konfiguration in der zweiten Phase angewendet.  Selbst wenn eine Instanz vorübergehend nicht verfügbar ist, kann nichts schief gehen.  Die Konfiguration wird einfach nicht angewendet und Sie werden im Voraus einen Fehler sehen. <br><br>  Der Topologieabschnitt enthält auch einen so wichtigen Parameter wie den Leiter jeder Replikationsgruppe.  Normalerweise ist dies die Instanz, die die Schreibvorgänge akzeptiert.  Der Rest ist meistens schreibgeschützt, obwohl es Ausnahmen geben kann.  Manchmal haben mutige Entwickler keine Angst vor Konflikten und können Daten gleichzeitig auf mehrere Replikate schreiben.  Einige Operationen sollten jedoch nicht zweimal ausgeführt werden.  Deshalb haben wir einen Führer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f96/b85/7f3/f96b857f346a756f27c05651b85a9886.png"></div><br><h2>  Rollenlebenszyklus </h2><br>  Damit eine Projektarchitektur abstrakte Rollen enthält, muss das Framework diese irgendwie verwalten können.  Natürlich werden die Rollen verwaltet, ohne den Tarantool-Prozess neu zu starten.  Es gibt vier Rückrufe für das Rollenmanagement.  Cartridge selbst ruft sie abhängig von den Informationen aus der verteilten Konfiguration auf und wendet dabei die Konfiguration auf die spezifischen Rollen an. <br><br><pre> <code class="plaintext hljs">function init() function validate_config() function apply_config() function stop()</code> </pre> <br>  Jede Rolle hat eine <code>init</code> Funktion.  Es wird einmal aufgerufen: entweder wenn die Rolle aktiviert ist oder wenn Tarantool neu gestartet wird.  Hier ist es beispielsweise praktisch, box.space.create zu initialisieren, oder der Scheduler kann eine Hintergrundfaser ausführen, die die Aufgabe in regelmäßigen Abständen erledigt. <br><br>  Die <code>init</code> Funktion allein reicht möglicherweise nicht aus.  Mit Cartridge können die Rollen auf die verteilte Konfiguration zugreifen, die zum Speichern der Topologie verwendet wird.  In derselben Konfiguration können wir einen neuen Abschnitt deklarieren und dort einen Teil der Geschäftskonfiguration speichern.  In meinem Beispiel kann dies ein Datenschema oder Zeitplaneinstellungen für die Scheduler-Rolle sein. <br><br>  Der Cluster ruft jedes Mal <code>validate_config</code> und <code>apply_config</code> auf, wenn sich die verteilte Konfiguration ändert.  Wenn eine Konfiguration in einem zweiphasigen Commit angewendet wird, überprüft der Cluster, ob jede Rolle auf jedem Server bereit ist, diese neue Konfiguration zu akzeptieren, und meldet dem Benutzer gegebenenfalls einen Fehler.  Wenn alle mit der Konfiguration einverstanden sind, wird <code>apply_config</code> aufgerufen. <br><br>  Rollen unterstützen auch eine <code>stop</code> zum Reinigen des Mülls.  Wenn wir sagen, dass der Scheduler auf diesem Server nicht benötigt wird, kann er die Fasern stoppen, die er mit <code>init</code> gestartet hat. <br><br>  Rollen können miteinander interagieren.  Wir sind es gewohnt, Lua-Funktionsaufrufe zu schreiben, aber der Prozess hat möglicherweise nicht die erforderliche Rolle.  Um den Netzwerkzugriff zu erleichtern, verwenden wir ein Hilfsmodul namens rpc (Remote Procedure Call), das auf dem Standardmodul Tarantool net.box basiert.  Dies kann beispielsweise nützlich sein, wenn Ihr Gateway den Scheduler direkt anfordern möchte, die Aufgabe jetzt und nicht an einem Tag auszuführen. <br><br>  Ein weiterer wichtiger Punkt ist die Gewährleistung der Fehlertoleranz.  Cartridge verwendet das SWIM-Protokoll <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[4]</a> , um den Zustand zu überwachen.  Kurz gesagt, die Prozesse tauschen über UDP "Gerüchte" miteinander aus, dh jeder Prozess teilt seinen Nachbarn die neuesten Nachrichten mit und sie antworten.  Wenn es plötzlich keine Antwort mehr gibt, vermutet Tarantool, dass etwas nicht stimmt, und nach einer Weile erklärt es den Tod und sendet diese Nachricht an alle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/748/1ff/6f2/7481ff6f235c9833ac93d4aa310e2911.png"></div><br>  Basierend auf diesem Protokoll organisiert Cartridge ein automatisches Failover.  Jeder Prozess überwacht seine Umgebung. Wenn der Leiter plötzlich nicht mehr reagiert, kann das Replikat seine Rolle beanspruchen, und Cartridge konfiguriert die ausgeführten Rollen entsprechend. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49a/925/53b/49a92553be1edd2834c373b14cf17431.png"></div><br>  Hier müssen Sie vorsichtig sein, da häufiges Hin- und Herwechseln zu Datenkonflikten während der Replikation führen kann.  Das automatische Failover sollte auf keinen Fall zufällig aktiviert werden.  Sie sollten eine klare Vorstellung davon haben, was vor sich geht, und sicherstellen, dass die Replikation nicht abstürzt, wenn der Anführer sich erholt und seine Krone wiedererlangt. <br><br>  Nach allem, was gesagt wurde, scheinen die Rollen den Mikrodiensten ähnlich zu sein.  In gewissem Sinne sind sie nur Module in Tarantool-Prozessen, und es gibt mehrere grundlegende Unterschiede.  Erstens müssen alle Projektrollen in derselben Codebasis leben.  Alle Tarantool-Prozesse sollten auf derselben Codebasis ausgeführt werden, damit es keine Überraschungen gibt, beispielsweise wenn wir versuchen, den Scheduler zu initialisieren, aber es gibt einfach keinen Scheduler.  Außerdem sollten wir keine Unterschiede in den Codeversionen zulassen, da das Systemverhalten in einer solchen Situation kompliziert vorherzusagen und zu debuggen ist. <br><br>  Im Gegensatz zu Docker können wir nicht einfach ein "Image" einer Rolle erstellen, es auf einen anderen Computer übertragen und dort ausführen.  Unsere Rollen sind nicht so isoliert wie Docker-Container.  Darüber hinaus können wir nicht zwei identische Rollen auf derselben Instanz ausführen.  Die Rolle ist entweder da oder nicht;  In gewissem Sinne ist es ein Singleton.  Und drittens sollten die Rollen innerhalb der gesamten Replikationsgruppe gleich sein, da dies sonst lächerlich aussehen würde: Die Daten sind gleich, aber das Verhalten ist unterschiedlich. <br><br><h2>  Bereitstellungstools </h2><br>  Ich habe versprochen, Ihnen zu zeigen, wie Cartridge bei der Bereitstellung von Anwendungen helfen kann.  Um das Leben einfacher zu machen, erstellt das Framework RPM-Pakete: <br><br><pre> <code class="plaintext hljs">$ cartridge pack rpm myapp # will create ./myapp-0.1.0-1.rpm $ sudo yum install ./myapp-0.1.0-1.rpm</code> </pre> <br>  Das installierte Paket enthält fast alles, was Sie benötigen: sowohl die Anwendung als auch die installierten Lua-Abhängigkeiten.  Tarantool kommt auch als RPM-Paketabhängigkeit auf den Server, und unser Service ist startbereit.  Dies geschieht alles mit systemd, aber zuerst sollten wir eine Konfiguration vornehmen, zumindest den URI jedes Prozesses angeben.  Drei wären genug für unser Beispiel. <br><br><pre> <code class="plaintext hljs">$ sudo tee /etc/tarantool/conf.d/demo.yml &lt;&lt;CONFIG myapp.router: {"advertise_uri": "localhost:3301", "http_port": 8080} myapp.storage_A: {"advertise_uri": "localhost:3302", "http_enabled": False} myapp.storage_B: {"advertise_uri": "localhost:3303", "http_enabled": False} CONFIG</code> </pre> <br>  Es gibt einen interessanten Aspekt, der berücksichtigt werden sollte: Anstatt nur den binären Protokollport anzugeben, geben wir die öffentliche Adresse des gesamten Prozesses an, einschließlich des Hostnamens.  Wir tun dies, weil die Clusterknoten wissen sollten, wie sie sich miteinander verbinden.  Es wäre eine schlechte Idee, die 0.0.0.0-Adresse als Advertise_uri zu verwenden, da es sich um eine externe IP-Adresse und nicht um eine Socket-Bindung handeln sollte.  Ohne funktioniert nichts, sodass Cartridge den Knoten mit der falschen Advertise_uri einfach nicht starten lässt. <br><br>  Nachdem die Konfiguration fertig ist, können wir die Prozesse starten.  Da eine normale systemd-Einheit nicht das Starten mehrerer Prozesse erlaubt, installieren die sogenannten instanziierten Einheiten die Anwendungen auf Cartridge: <br><br><pre> <code class="plaintext hljs">$ sudo systemctl start myapp@router $ sudo systemctl start myapp@storage_A $ sudo systemctl start myapp@storage_B</code> </pre> <br>  Wir haben den HTTP-Port für die Cartridge-Weboberfläche in der Konfiguration angegeben: 8080. Gehen wir dort hin und schauen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4d/c41/8fc/c4dc418fca8a18c3f3dd2c4430bd1eaa.png"></div><br>  Wir können sehen, dass die Prozesse noch nicht konfiguriert sind, obwohl sie bereits ausgeführt werden.  Cartridge weiß noch nicht, wie die Replikation durchgeführt werden soll, und kann nicht selbst entscheiden. Daher wartet es auf unsere Aktionen.  Wir haben keine große Auswahl: Die Lebensdauer eines neuen Clusters beginnt mit der Konfiguration des ersten Knotens.  Anschließend fügen wir dem Cluster weitere Knoten hinzu, weisen ihnen Rollen zu, und die Bereitstellung kann als erfolgreich abgeschlossen betrachtet werden. <br><br>  Gießen wir uns einen Drink ein und entspannen uns nach einer langen Arbeitswoche.  Die Anwendung ist einsatzbereit. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95e/78c/fc5/95e78cfc50600fc8b3acf86d3f553242.png"></div><br><h2>  Ergebnisse </h2><br>  Was ist mit den Ergebnissen?  Bitte testen, verwenden, Feedback geben und Tickets auf Github erstellen. <br><br><h2>  Referenzen </h2><br>  [1] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tarantool »2.2» Referenz »Rocks Referenz» Modul vshard</a> <br>  [2] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie wir den Kern des auf Tarantool basierenden Investmentgeschäfts der Alfa-Bank implementiert haben</a> <br>  [3] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abrechnungsarchitektur der nächsten Generation: Übergang zu Tarantool</a> <br>  [4] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SWIM - Cluster Building Protocol</a> <br>  [5] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub - tarantool / cartridge-cli</a> <br>  [6] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub - Tarantool / Cartridge</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470812/">https://habr.com/ru/post/de470812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470800/index.html">P - Antizipation sowie das vorläufige DUMP Kazan Programm. Siehe die Berichte, die die Fleischwolfauswahl bestanden haben</a></li>
<li><a href="../de470802/index.html">Backup, Teil 6: Vergleichen der Backup-Tools</a></li>
<li><a href="../de470804/index.html">Alice Award: 5 Einblicke vom Gewinner</a></li>
<li><a href="../de470806/index.html">Grundlegendes Testproblem</a></li>
<li><a href="../de470808/index.html">Astra Linux "Eagle" Common Edition: Gibt es ein Leben nach Windows?</a></li>
<li><a href="../de470814/index.html">Materialien von android-mitap: Tools für Autotests | Yandex Mapkit 3 | Anwendungsdesign | Servergesteuerte Benutzeroberfläche</a></li>
<li><a href="../de470816/index.html">Russland - TPA - Weißrussland: Hier ist der dritte überhaupt nicht überflüssig</a></li>
<li><a href="../de470818/index.html">Bug Hunt, Blind-XSS und Fox Tricks</a></li>
<li><a href="../de470820/index.html">Ein kurzer Test von Dutzenden von Hypothesen: Wie wir aus der Routine ausbrechen und in einer anderen Stadt diskutieren</a></li>
<li><a href="../de470822/index.html">Temperaturüberwachung im Unternehmen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>