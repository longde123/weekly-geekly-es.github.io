<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸŒ° ğŸ§šğŸ¿ ğŸ‘©â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ Tarantool Cartridge: Sharding Lua Backend in drei Zeilen ğŸ“™ ğŸµï¸ ğŸ“³</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In der Mail.ru-Gruppe haben wir Tarantool, einen Lua-basierten Anwendungsserver und eine Datenbank vereint. Es ist schnell und elegant, aber die Resso...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tarantool Cartridge: Sharding Lua Backend in drei Zeilen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/470812/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/tg/6f/71/tg6f71dbjoo5m5qm5ebndfjxjdu.jpeg"></div><br>  In der Mail.ru-Gruppe haben wir Tarantool, einen Lua-basierten Anwendungsserver und eine Datenbank vereint.  Es ist schnell und elegant, aber die Ressourcen eines einzelnen Servers sind immer begrenzt.  Vertikale Skalierung ist auch kein Allheilmittel.  Aus diesem Grund verfÃ¼gt Tarantool Ã¼ber einige Tools fÃ¼r die horizontale Skalierung oder das vshard-Modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[1]</a> .  Sie kÃ¶nnen Daten auf mehrere Server verteilen, mÃ¼ssen jedoch eine Weile daran basteln, um sie zu konfigurieren und die GeschÃ¤ftslogik zu verbessern. <br><br>  Gute Nachricht: Wir haben unseren Anteil an Unebenheiten (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[2]</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[3]</a> ) und ein weiteres Framework erstellt, das die LÃ¶sung dieses Problems erheblich vereinfacht. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tarantool Cartridge</a> ist das neue Framework fÃ¼r die Entwicklung komplexer verteilter Systeme.  Sie kÃ¶nnen sich darauf konzentrieren, GeschÃ¤ftslogik zu schreiben, anstatt Infrastrukturprobleme zu lÃ¶sen.  Im Folgenden werde ich Ihnen erlÃ¤utern, wie dieses Framework funktioniert und wie es beim Schreiben verteilter Dienste hilfreich sein kann. <br><a name="habracut"></a><br><h2>  Was genau ist das Problem? </h2><br>  Wir haben Tarantool und vshard - was wollen wir mehr? <br><br>  Erstens ist es eine Frage der Bequemlichkeit.  Vshard ist in Lua-Tabellen konfiguriert.  Damit ein verteiltes System mit mehreren Tarantool-Prozessen ordnungsgemÃ¤ÃŸ funktioniert, muss die Konfiguration jedoch Ã¼berall gleich sein.  Niemand mÃ¶chte dies manuell tun, daher werden alle Arten von Skripten, Ansible und Bereitstellungssystemen verwendet. <br><br>  Cartridge selbst verwaltet die vshard-Konfiguration basierend auf <i>seiner eigenen verteilten Konfiguration</i> .  TatsÃ¤chlich handelt es sich um eine einfache YAML-Datei, deren Kopie auf jeder Tarantool-Instanz gespeichert ist.  Mit anderen Worten, das Framework Ã¼berwacht seine Konfiguration so, dass sie Ã¼berall gleich ist. <br><br>  Zweitens ist es wieder eine Frage der Bequemlichkeit.  Die Vshard-Konfiguration bezieht sich nicht auf die Entwicklung der GeschÃ¤ftslogik und lenkt einen Entwickler nur von seiner Arbeit ab.  Wenn wir die Architektur eines Projekts diskutieren, handelt es sich hÃ¶chstwahrscheinlich um separate Komponenten und deren Interaktion.  Es ist noch zu frÃ¼h, um Ã¼berhaupt Ã¼ber die Bereitstellung eines Clusters fÃ¼r drei Rechenzentren nachzudenken. <br><br>  Wir haben diese Probleme immer wieder gelÃ¶st und irgendwann einen Ansatz entwickelt, um die Arbeit mit der Anwendung Ã¼ber den gesamten Lebenszyklus hinweg zu vereinfachen: Erstellung, Entwicklung, Test, CI / CD, Wartung. <br><br>  Cartridge fÃ¼hrt das Konzept der Rollen fÃ¼r jeden Tarantool-Prozess ein.  Mithilfe von Rollen kann sich der Entwickler auf das Schreiben von Code konzentrieren.  Alle im Projekt verfÃ¼gbaren Rollen kÃ¶nnen auf der einzelnen Instanz von Tarantool ausgefÃ¼hrt werden. Dies wÃ¼rde zum Testen ausreichen. <br><br>  Hauptmerkmale der Tarantool-Patrone: <br><br><ul><li>  automatisierte Cluster-Orchestrierung; <br></li><li>  erweiterte AnwendungsfunktionalitÃ¤t mit neuen Rollen; <br></li><li>  Anwendungsvorlage fÃ¼r Entwicklung und Bereitstellung; <br></li><li>  eingebautes automatisches Sharding; <br></li><li>  Integration in das Luatest-Framework; <br></li><li>  Clusterverwaltung Ã¼ber WebUI und API; <br></li><li>  Verpackungs- und Bereitstellungstools. <br></li></ul><br><h2>  Hallo Welt! </h2><br>  Ich kann es kaum erwarten, Ihnen das Framework selbst zu zeigen. Speichern wir also die Geschichte Ã¼ber Architektur fÃ¼r spÃ¤ter und beginnen Sie mit einer einfachen Aufgabe.  Vorausgesetzt, Tarantool ist bereits installiert, mÃ¼ssen wir nur noch etwas tun <br><br><pre><code class="plaintext hljs">$ tarantoolctl rocks install cartridge-cli $ export PATH=$PWD/.rocks/bin/:$PATH</code> </pre> <br>  Als Ergebnis werden die Befehlszeilenprogramme installiert, mit denen Sie Ihre erste Anwendung aus der Vorlage erstellen kÃ¶nnen: <br><br><pre> <code class="plaintext hljs">$ cartridge create --name myapp</code> </pre> <br>  Und hier ist was wir bekommen: <br><br><pre> <code class="plaintext hljs">myapp/ â”œâ”€â”€ .git/ â”œâ”€â”€ .gitignore â”œâ”€â”€ app/roles/custom.lua â”œâ”€â”€ deps.sh â”œâ”€â”€ init.lua â”œâ”€â”€ myapp-scm-1.rockspec â”œâ”€â”€ test â”‚ â”œâ”€â”€ helper â”‚ â”‚ â”œâ”€â”€ integration.lua â”‚ â”‚ â””â”€â”€ unit.lua â”‚ â”œâ”€â”€ helper.lua â”‚ â”œâ”€â”€ integration/api_test.lua â”‚ â””â”€â”€ unit/sample_test.lua â””â”€â”€ tmp/</code> </pre> <br>  Dies ist ein Git-Repository mit einem gebrauchsfertigen "Hallo Welt!"  Anwendung.  Versuchen wir, es nach der Installation der AbhÃ¤ngigkeiten (einschlieÃŸlich des Frameworks selbst) auszufÃ¼hren: <br><br><pre> <code class="plaintext hljs">$ tarantoolctl rocks make $ ./init.lua --http-port 8080</code> </pre> <br>  Wir haben einen Knoten unserer zukÃ¼nftigen Sharded-Anwendung gestartet.  Wenn Sie neugierig sind, kÃ¶nnen Sie sofort die WeboberflÃ¤che Ã¶ffnen, die auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">localhost</a> : 8080 ausgefÃ¼hrt wird. Verwenden Sie eine Maus, um einen Cluster mit einem Knoten zu konfigurieren und das Ergebnis zu genieÃŸen, aber freuen Sie sich nicht zu frÃ¼h.  Die Anwendung weiÃŸ noch nicht, wie sie etwas NÃ¼tzliches tun soll, daher werde ich Sie spÃ¤ter Ã¼ber die Bereitstellung informieren, und jetzt ist es Zeit, Code zu schreiben. <br><br><h2>  Anwendungen entwickeln </h2><br>  Stellen Sie sich vor, wir entwerfen ein System, das Daten empfangen, speichern und einmal tÃ¤glich einen Bericht erstellen soll. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc6/dba/8a2/dc6dba8a2a2ff31693cff9a825c44b7f.png"></div><br>  Wir zeichnen also ein Diagramm mit drei Komponenten: Gateway, Speicher und Scheduler.  Lassen Sie uns weiter an der Architektur arbeiten.  Da wir vshard als Speicher verwenden, fÃ¼gen wir dem Diagramm vshard-router und vshard-storage hinzu.  Weder das Gateway noch der Scheduler greifen direkt auf den Speicher zu - fÃ¼r diese Aufgabe wird explizit ein Router erstellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/151/eb0/ac5/151eb0ac5b9d8a1a6217e0992b502089.png"></div><br>  Dieses Diagramm sieht abstrakt aus, da die Komponenten immer noch nicht das widerspiegeln, was wir im Projekt erstellen werden.  Wir mÃ¼ssen sehen, wie dieses Projekt echtem Tarantool entspricht, also gruppieren wir unsere Komponenten nach dem Prozess. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fdc/781/a46/fdc781a46e819a67232bfcd308605b5d.png"></div><br>  Es macht wenig Sinn, vshard-router und gateway auf getrennten Instanzen zu halten.  Warum sollten wir noch einmal Ã¼ber das Netzwerk gehen, wenn dies bereits in der Verantwortung des Routers liegt?  Sie sollten innerhalb desselben Prozesses ausgefÃ¼hrt werden, dh sowohl das Gateway als auch vshard.router.cfg sollten im selben Prozess initialisiert werden und lokal interagieren. <br><br>  WÃ¤hrend der Entwurfsphase war es praktisch, mit drei Komponenten zu arbeiten, aber als Entwickler mÃ¶chte ich nicht daran denken, drei Instanzen von Tarantool beim Schreiben von Code zu starten.  Ich muss die Tests ausfÃ¼hren und Ã¼berprÃ¼fen, ob ich den Gateway-Code korrekt geschrieben habe.  Oder ich mÃ¶chte meinen Mitarbeitern eine neue Funktion zeigen.  Warum sollte ich Probleme mit der Bereitstellung von drei Instanzen haben?  So wurde das Konzept der Rollen geboren.  Eine Rolle ist ein regulÃ¤res Lua-Modul, und Cartridge verwaltet seinen Lebenszyklus.  In diesem Beispiel gibt es vier davon: Gateway, Router, Speicher und Scheduler.  Ein anderes Projekt hat mÃ¶glicherweise mehr Rollen.  Alle Rollen kÃ¶nnen in einem Prozess gestartet werden, und es wÃ¼rde ausreichen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e1/49c/95a/1e149c95aed1d5dc7cf73e298198c719.png"></div><br>  Wenn es um die Bereitstellung fÃ¼r Staging oder Produktion geht, weisen wir jedem Tarantool-Prozess abhÃ¤ngig von den zugrunde liegenden Hardwarefunktionen einen separaten Rollensatz zu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f9/b59/1d7/1f9b591d794e4b459b863f0da01f042b.png"></div><br><h2>  Topologieverwaltung </h2><br>  Wir sollten auch irgendwo Informationen Ã¼ber die laufenden Rollen speichern.  Und "irgendwo" bedeutet die oben erwÃ¤hnte verteilte Konfiguration.  Das Wichtigste dabei ist die Clustertopologie.  Hier sehen Sie 3 Replikationsgruppen von 5 Tarantool-Prozessen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb6/118/a0f/eb6118a0f7c2381ce82491bd65272ec5.png"></div><br>  Wir mÃ¶chten die Daten nicht verlieren, deshalb behandeln wir die Informationen Ã¼ber die laufenden Prozesse mit Sorgfalt.  Cartridge Ã¼berwacht die Konfiguration mithilfe eines zweiphasigen Commits.  Sobald wir die Konfiguration aktualisieren mÃ¶chten, wird zunÃ¤chst geprÃ¼ft, ob die Instanzen verfÃ¼gbar und bereit sind, die neue Konfiguration zu akzeptieren.  Danach wird die Konfiguration in der zweiten Phase angewendet.  Selbst wenn eine Instanz vorÃ¼bergehend nicht verfÃ¼gbar ist, kann nichts schief gehen.  Die Konfiguration wird einfach nicht angewendet und Sie werden im Voraus einen Fehler sehen. <br><br>  Der Topologieabschnitt enthÃ¤lt auch einen so wichtigen Parameter wie den Leiter jeder Replikationsgruppe.  Normalerweise ist dies die Instanz, die die SchreibvorgÃ¤nge akzeptiert.  Der Rest ist meistens schreibgeschÃ¼tzt, obwohl es Ausnahmen geben kann.  Manchmal haben mutige Entwickler keine Angst vor Konflikten und kÃ¶nnen Daten gleichzeitig auf mehrere Replikate schreiben.  Einige Operationen sollten jedoch nicht zweimal ausgefÃ¼hrt werden.  Deshalb haben wir einen FÃ¼hrer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f96/b85/7f3/f96b857f346a756f27c05651b85a9886.png"></div><br><h2>  Rollenlebenszyklus </h2><br>  Damit eine Projektarchitektur abstrakte Rollen enthÃ¤lt, muss das Framework diese irgendwie verwalten kÃ¶nnen.  NatÃ¼rlich werden die Rollen verwaltet, ohne den Tarantool-Prozess neu zu starten.  Es gibt vier RÃ¼ckrufe fÃ¼r das Rollenmanagement.  Cartridge selbst ruft sie abhÃ¤ngig von den Informationen aus der verteilten Konfiguration auf und wendet dabei die Konfiguration auf die spezifischen Rollen an. <br><br><pre> <code class="plaintext hljs">function init() function validate_config() function apply_config() function stop()</code> </pre> <br>  Jede Rolle hat eine <code>init</code> Funktion.  Es wird einmal aufgerufen: entweder wenn die Rolle aktiviert ist oder wenn Tarantool neu gestartet wird.  Hier ist es beispielsweise praktisch, box.space.create zu initialisieren, oder der Scheduler kann eine Hintergrundfaser ausfÃ¼hren, die die Aufgabe in regelmÃ¤ÃŸigen AbstÃ¤nden erledigt. <br><br>  Die <code>init</code> Funktion allein reicht mÃ¶glicherweise nicht aus.  Mit Cartridge kÃ¶nnen die Rollen auf die verteilte Konfiguration zugreifen, die zum Speichern der Topologie verwendet wird.  In derselben Konfiguration kÃ¶nnen wir einen neuen Abschnitt deklarieren und dort einen Teil der GeschÃ¤ftskonfiguration speichern.  In meinem Beispiel kann dies ein Datenschema oder Zeitplaneinstellungen fÃ¼r die Scheduler-Rolle sein. <br><br>  Der Cluster ruft jedes Mal <code>validate_config</code> und <code>apply_config</code> auf, wenn sich die verteilte Konfiguration Ã¤ndert.  Wenn eine Konfiguration in einem zweiphasigen Commit angewendet wird, Ã¼berprÃ¼ft der Cluster, ob jede Rolle auf jedem Server bereit ist, diese neue Konfiguration zu akzeptieren, und meldet dem Benutzer gegebenenfalls einen Fehler.  Wenn alle mit der Konfiguration einverstanden sind, wird <code>apply_config</code> aufgerufen. <br><br>  Rollen unterstÃ¼tzen auch eine <code>stop</code> zum Reinigen des MÃ¼lls.  Wenn wir sagen, dass der Scheduler auf diesem Server nicht benÃ¶tigt wird, kann er die Fasern stoppen, die er mit <code>init</code> gestartet hat. <br><br>  Rollen kÃ¶nnen miteinander interagieren.  Wir sind es gewohnt, Lua-Funktionsaufrufe zu schreiben, aber der Prozess hat mÃ¶glicherweise nicht die erforderliche Rolle.  Um den Netzwerkzugriff zu erleichtern, verwenden wir ein Hilfsmodul namens rpc (Remote Procedure Call), das auf dem Standardmodul Tarantool net.box basiert.  Dies kann beispielsweise nÃ¼tzlich sein, wenn Ihr Gateway den Scheduler direkt anfordern mÃ¶chte, die Aufgabe jetzt und nicht an einem Tag auszufÃ¼hren. <br><br>  Ein weiterer wichtiger Punkt ist die GewÃ¤hrleistung der Fehlertoleranz.  Cartridge verwendet das SWIM-Protokoll <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[4]</a> , um den Zustand zu Ã¼berwachen.  Kurz gesagt, die Prozesse tauschen Ã¼ber UDP "GerÃ¼chte" miteinander aus, dh jeder Prozess teilt seinen Nachbarn die neuesten Nachrichten mit und sie antworten.  Wenn es plÃ¶tzlich keine Antwort mehr gibt, vermutet Tarantool, dass etwas nicht stimmt, und nach einer Weile erklÃ¤rt es den Tod und sendet diese Nachricht an alle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/748/1ff/6f2/7481ff6f235c9833ac93d4aa310e2911.png"></div><br>  Basierend auf diesem Protokoll organisiert Cartridge ein automatisches Failover.  Jeder Prozess Ã¼berwacht seine Umgebung. Wenn der Leiter plÃ¶tzlich nicht mehr reagiert, kann das Replikat seine Rolle beanspruchen, und Cartridge konfiguriert die ausgefÃ¼hrten Rollen entsprechend. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49a/925/53b/49a92553be1edd2834c373b14cf17431.png"></div><br>  Hier mÃ¼ssen Sie vorsichtig sein, da hÃ¤ufiges Hin- und Herwechseln zu Datenkonflikten wÃ¤hrend der Replikation fÃ¼hren kann.  Das automatische Failover sollte auf keinen Fall zufÃ¤llig aktiviert werden.  Sie sollten eine klare Vorstellung davon haben, was vor sich geht, und sicherstellen, dass die Replikation nicht abstÃ¼rzt, wenn der AnfÃ¼hrer sich erholt und seine Krone wiedererlangt. <br><br>  Nach allem, was gesagt wurde, scheinen die Rollen den Mikrodiensten Ã¤hnlich zu sein.  In gewissem Sinne sind sie nur Module in Tarantool-Prozessen, und es gibt mehrere grundlegende Unterschiede.  Erstens mÃ¼ssen alle Projektrollen in derselben Codebasis leben.  Alle Tarantool-Prozesse sollten auf derselben Codebasis ausgefÃ¼hrt werden, damit es keine Ãœberraschungen gibt, beispielsweise wenn wir versuchen, den Scheduler zu initialisieren, aber es gibt einfach keinen Scheduler.  AuÃŸerdem sollten wir keine Unterschiede in den Codeversionen zulassen, da das Systemverhalten in einer solchen Situation kompliziert vorherzusagen und zu debuggen ist. <br><br>  Im Gegensatz zu Docker kÃ¶nnen wir nicht einfach ein "Image" einer Rolle erstellen, es auf einen anderen Computer Ã¼bertragen und dort ausfÃ¼hren.  Unsere Rollen sind nicht so isoliert wie Docker-Container.  DarÃ¼ber hinaus kÃ¶nnen wir nicht zwei identische Rollen auf derselben Instanz ausfÃ¼hren.  Die Rolle ist entweder da oder nicht;  In gewissem Sinne ist es ein Singleton.  Und drittens sollten die Rollen innerhalb der gesamten Replikationsgruppe gleich sein, da dies sonst lÃ¤cherlich aussehen wÃ¼rde: Die Daten sind gleich, aber das Verhalten ist unterschiedlich. <br><br><h2>  Bereitstellungstools </h2><br>  Ich habe versprochen, Ihnen zu zeigen, wie Cartridge bei der Bereitstellung von Anwendungen helfen kann.  Um das Leben einfacher zu machen, erstellt das Framework RPM-Pakete: <br><br><pre> <code class="plaintext hljs">$ cartridge pack rpm myapp # will create ./myapp-0.1.0-1.rpm $ sudo yum install ./myapp-0.1.0-1.rpm</code> </pre> <br>  Das installierte Paket enthÃ¤lt fast alles, was Sie benÃ¶tigen: sowohl die Anwendung als auch die installierten Lua-AbhÃ¤ngigkeiten.  Tarantool kommt auch als RPM-PaketabhÃ¤ngigkeit auf den Server, und unser Service ist startbereit.  Dies geschieht alles mit systemd, aber zuerst sollten wir eine Konfiguration vornehmen, zumindest den URI jedes Prozesses angeben.  Drei wÃ¤ren genug fÃ¼r unser Beispiel. <br><br><pre> <code class="plaintext hljs">$ sudo tee /etc/tarantool/conf.d/demo.yml &lt;&lt;CONFIG myapp.router: {"advertise_uri": "localhost:3301", "http_port": 8080} myapp.storage_A: {"advertise_uri": "localhost:3302", "http_enabled": False} myapp.storage_B: {"advertise_uri": "localhost:3303", "http_enabled": False} CONFIG</code> </pre> <br>  Es gibt einen interessanten Aspekt, der berÃ¼cksichtigt werden sollte: Anstatt nur den binÃ¤ren Protokollport anzugeben, geben wir die Ã¶ffentliche Adresse des gesamten Prozesses an, einschlieÃŸlich des Hostnamens.  Wir tun dies, weil die Clusterknoten wissen sollten, wie sie sich miteinander verbinden.  Es wÃ¤re eine schlechte Idee, die 0.0.0.0-Adresse als Advertise_uri zu verwenden, da es sich um eine externe IP-Adresse und nicht um eine Socket-Bindung handeln sollte.  Ohne funktioniert nichts, sodass Cartridge den Knoten mit der falschen Advertise_uri einfach nicht starten lÃ¤sst. <br><br>  Nachdem die Konfiguration fertig ist, kÃ¶nnen wir die Prozesse starten.  Da eine normale systemd-Einheit nicht das Starten mehrerer Prozesse erlaubt, installieren die sogenannten instanziierten Einheiten die Anwendungen auf Cartridge: <br><br><pre> <code class="plaintext hljs">$ sudo systemctl start myapp@router $ sudo systemctl start myapp@storage_A $ sudo systemctl start myapp@storage_B</code> </pre> <br>  Wir haben den HTTP-Port fÃ¼r die Cartridge-WeboberflÃ¤che in der Konfiguration angegeben: 8080. Gehen wir dort hin und schauen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4d/c41/8fc/c4dc418fca8a18c3f3dd2c4430bd1eaa.png"></div><br>  Wir kÃ¶nnen sehen, dass die Prozesse noch nicht konfiguriert sind, obwohl sie bereits ausgefÃ¼hrt werden.  Cartridge weiÃŸ noch nicht, wie die Replikation durchgefÃ¼hrt werden soll, und kann nicht selbst entscheiden. Daher wartet es auf unsere Aktionen.  Wir haben keine groÃŸe Auswahl: Die Lebensdauer eines neuen Clusters beginnt mit der Konfiguration des ersten Knotens.  AnschlieÃŸend fÃ¼gen wir dem Cluster weitere Knoten hinzu, weisen ihnen Rollen zu, und die Bereitstellung kann als erfolgreich abgeschlossen betrachtet werden. <br><br>  GieÃŸen wir uns einen Drink ein und entspannen uns nach einer langen Arbeitswoche.  Die Anwendung ist einsatzbereit. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95e/78c/fc5/95e78cfc50600fc8b3acf86d3f553242.png"></div><br><h2>  Ergebnisse </h2><br>  Was ist mit den Ergebnissen?  Bitte testen, verwenden, Feedback geben und Tickets auf Github erstellen. <br><br><h2>  Referenzen </h2><br>  [1] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tarantool Â»2.2Â» Referenz Â»Rocks ReferenzÂ» Modul vshard</a> <br>  [2] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie wir den Kern des auf Tarantool basierenden InvestmentgeschÃ¤fts der Alfa-Bank implementiert haben</a> <br>  [3] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abrechnungsarchitektur der nÃ¤chsten Generation: Ãœbergang zu Tarantool</a> <br>  [4] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SWIM - Cluster Building Protocol</a> <br>  [5] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub - tarantool / cartridge-cli</a> <br>  [6] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub - Tarantool / Cartridge</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470812/">https://habr.com/ru/post/de470812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470800/index.html">P - Antizipation sowie das vorlÃ¤ufige DUMP Kazan Programm. Siehe die Berichte, die die Fleischwolfauswahl bestanden haben</a></li>
<li><a href="../de470802/index.html">Backup, Teil 6: Vergleichen der Backup-Tools</a></li>
<li><a href="../de470804/index.html">Alice Award: 5 Einblicke vom Gewinner</a></li>
<li><a href="../de470806/index.html">Grundlegendes Testproblem</a></li>
<li><a href="../de470808/index.html">Astra Linux "Eagle" Common Edition: Gibt es ein Leben nach Windows?</a></li>
<li><a href="../de470814/index.html">Materialien von android-mitap: Tools fÃ¼r Autotests | Yandex Mapkit 3 | Anwendungsdesign | Servergesteuerte BenutzeroberflÃ¤che</a></li>
<li><a href="../de470816/index.html">Russland - TPA - WeiÃŸrussland: Hier ist der dritte Ã¼berhaupt nicht Ã¼berflÃ¼ssig</a></li>
<li><a href="../de470818/index.html">Bug Hunt, Blind-XSS und Fox Tricks</a></li>
<li><a href="../de470820/index.html">Ein kurzer Test von Dutzenden von Hypothesen: Wie wir aus der Routine ausbrechen und in einer anderen Stadt diskutieren</a></li>
<li><a href="../de470822/index.html">TemperaturÃ¼berwachung im Unternehmen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>