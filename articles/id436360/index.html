<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ– â˜‚ï¸ ğŸ’¿ Gotta Go Fast: Membangun untuk Kecepatan di iOS. Bagian 1 ğŸ¥Œ ğŸ‘¨ğŸ»â€ğŸ¨ ğŸ“Œ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ada banyak tips dan trik yang memungkinkan pengembang iOS tahu bagaimana membuat optimasi kinerja agar animasi dalam aplikasi berjalan dengan lancar. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gotta Go Fast: Membangun untuk Kecepatan di iOS. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/e-Legion/blog/436360/"><img src="https://habrastorage.org/webt/cl/ww/k-/clwwk-yxw7f1pbfvtly5lytqnac.png"><br><br>  Ada banyak tips dan trik yang memungkinkan pengembang iOS tahu bagaimana membuat optimasi kinerja agar animasi dalam aplikasi berjalan dengan lancar.  Setelah membaca artikel Anda akan menyadari apa artinya 16,67 milidetik untuk pengembang iOS, dan alat mana yang lebih baik untuk digunakan untuk melacak kode. <br><br>  Artikel ini didasarkan pada ceramah utama yang disampaikan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Luke Parham</a> , saat ini seorang insinyur iOS di Apple dan penulis tutorial untuk pengembangan iOS di RayWenderlich.com, di Konferensi Pengembang Seluler Internasional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MBLT DEV 2017</a> . <a name="habracut"></a><br><br><blockquote>  "Hai teman-teman.  Jika Anda bisa, katakanlah, Anda dapat mencukur 10 detik dari waktu boot, kalikan dengan 5 juta pengguna dan itu 50 juta detik setiap hari.  Lebih dari satu tahun, itu mungkin puluhan masa hidup.  Jadi jika Anda membuatnya boot sepuluh detik lebih cepat, Anda telah menyelamatkan selusin nyawa.  Itu benar-benar layak, bukan begitu? â€ </blockquote><br>  <i>Steve Jobs tentang kinerja (waktu boot Apple II).</i> <br><br><h2>  Performa di iOS atau cara keluar dari main </h2><br>  Utas utama bertanggung jawab untuk menerima input pengguna dan menampilkan hasil ke layar.  Menerima ketukan, wajan, semua gerakan dan kemudian rendering.  Sebagian besar ponsel modern menghasilkan 60 frame per detik.  Ini berarti bahwa semua orang ingin melakukan semua pekerjaan dalam 16,67 milidetik.  Jadi, keluar dari utas utama adalah hal yang sangat besar. <br><br>  Jika sesuatu membutuhkan waktu lebih lama dari 16,67 milidetik, maka Anda akan secara otomatis menjatuhkan bingkai, dan pengguna Anda akan melihatnya ketika ada animasi.  Beberapa perangkat bahkan memiliki lebih sedikit waktu untuk melakukan, misalnya, iPad baru memiliki 120 Hertz, sehingga hanya ada 8 milidetik per frame untuk melakukan pekerjaan. <br><br><h2>  Frame yang terjatuh </h2><br><h3>  Aturan # 1: gunakan CADisplayLink untuk melacak frame yang terjatuh </h3><br>  CADisplayLink adalah timer khusus yang menyala pada Vsync.  Vsync adalah ketika aplikasi menampilkan layar, dan itu terjadi setiap 16 milidetik.  Untuk tujuan pengujian, di AppDelegate Anda, Anda dapat mengatur CADisplayLink ditambahkan ke loop run utama dan kemudian hanya memiliki fungsi lain di mana Anda melakukan sedikit matematika.  Kemudian Anda melacak berapa lama aplikasi telah berjalan dan sudah berapa lama sejak terakhir kali fungsi ini dipecat.  Dan lihat apakah butuh lebih dari 16 milidetik. <br><br><img src="https://habrastorage.org/webt/pm/jv/r_/pmjvr_ketfth1a_vhcp36_lu-mu.png"><br><br>  Ini hanya menyala ketika benar-benar bisa di-render.  Jika Anda melakukan banyak pekerjaan dan Anda memperlambat utas utama, ini akan berjalan 100 milidetik kemudian, yang berarti Anda telah melakukan terlalu banyak pekerjaan dan Anda telah menjatuhkan bingkai pada waktu itu. <br><br>  Sebagai contoh, ini adalah Catstagram aplikasi.  Memiliki gagap ketika gambar sedang dimuat.  Dan kemudian Anda dapat melihat bahwa bingkai dijatuhkan pada waktu tertentu dan memiliki waktu yang berlalu seperti 200 milidetik.  Itu berarti aplikasi ini melakukan sesuatu yang terlalu lama. <br><br><img src="https://habrastorage.org/webt/tz/8b/_u/tz8b_u-2r_f5-p7k9pjll9hvhfk.gif"><br><br>  Pengguna tidak menyukai pengalaman seperti itu terutama jika aplikasi tersebut mendukung perangkat yang lebih tua seperti iPhone 5, iPod lama, dll. <br><br><h3>  Profiler waktu </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Time Profiler</a> mungkin adalah alat yang paling berguna untuk melacak barang-barang tersebut.  Alat-alat lain berguna tetapi, pada akhirnya, di Fyusion kami menggunakan Time Profiler seperti 90% dari waktu.  Tersangka aplikasi yang biasa adalah scrollview, teks, dan gambar. <br><br>  Gambar adalah gambar yang sangat besar.  Kami memiliki decoding JPEG - "UIImageView" sama dengan beberapa UIImage.  UIimages mendekode semua JPEG untuk aplikasi.  Mereka melakukannya perlahan sehingga Anda tidak dapat benar-benar melacak kinerja secara langsung.  Itu tidak terjadi tepat ketika Anda mengatur gambar tetapi Anda dapat melihatnya dalam jejak profiler waktu. <br>  Pengukuran teks adalah hal besar lainnya.  Itu muncul, misalnya jika Anda memiliki banyak yang sangat kompleks seperti Jepang atau Cina.  Ini bisa memakan waktu lama untuk melakukan pengukuran garis. <br><br>  Tata letak hierarki juga memperlambat rendering aplikasi.  Ini terutama berlaku dengan Tata Letak Otomatis.  Ini nyaman tetapi juga lambat secara agresif dibandingkan dengan melakukan tata letak manual.  Jadi itu adalah salah satu dari kompromi tersebut.  Jika itu memperlambat aplikasi, mungkin sudah saatnya untuk beralih dari itu dan mencoba beberapa teknik tata letak lainnya. <br><br><h3>  Contoh jejak </h3><br><br><img src="https://habrastorage.org/webt/sx/od/dw/sxoddwfs536ehipsoclxey4yysw.png"><br><br>  Pada pohon panggilan contoh, Anda dapat melihat seberapa banyak pekerjaan CPU Anda lakukan.  Anda dapat mengubah tampilan, melihatnya dengan utas, melihatnya dengan CPU.  Biasanya, hal yang paling menarik adalah memisahkan dengan utas dan kemudian melihat apa yang ada di utama. <br><br>  Banyak kali ketika Anda pertama kali mulai melihat ini, tampaknya sangat luar biasa.  Anda kadang-kadang memiliki perasaan: "Apa semua sampah ini?  Saya tidak tahu apa artinya ini "FRunLoopDoSource0". <br><br>  Tetapi itu adalah salah satu hal di mana Anda dapat menggali dan memahami bagaimana berbagai hal bekerja dan itu mulai masuk akal.  Jadi Anda dapat mengikuti jejak stack dan melihat semua hal sistem yang tidak Anda tulis.  Tetapi di bagian bawah, Anda dapat melihat kode Anda yang sebenarnya. <br><br><h3>  Pohon panggilan </h3><br>  Sebagai contoh, kami memiliki aplikasi yang sangat sederhana yang memiliki fungsi utama, dan kemudian memanggil beberapa metode di dalamnya.  Apa yang dilakukan profiler waktu adalah mengambil snapshot dari apa pun jejak tumpukan Anda sekarang secara default setiap milidetik.  Kemudian ia menunggu satu milidetik dan mengambil snapshot, di mana Anda telah memanggil "main" yang disebut "foo" yang disebut "bar".  Ada jejak tumpukan pertama di atas tangkapan layar.  Sehingga dikumpulkan.  Kami memiliki hitungan ini: 1, 1, 1. <br><br><img src="https://habrastorage.org/webt/uc/rc/uq/ucrcuqen-b5unzzu3hinwhxny6e.png"><br><br>  Masing-masing fungsi ini disebut satu kali.  Kemudian milidetik kemudian kami menangkap tumpukan lain.  Dan kali ini, itu adalah hal yang persis sama, kita menghitung semua dengan 2. <br><br><img src="https://habrastorage.org/webt/r2/ak/ez/r2akezneiolgd_p4robekqxddtg.jpeg"><br><br>  Kemudian pada milidetik ketiga, kita memiliki tumpukan panggilan yang sedikit berbeda.  Main memanggil "bar" secara langsung.  Utama dan bar naik satu per satu.  Tapi kemudian kita harus berpisah.  Terkadang panggilan utama â€œfooâ€, terkadang panggilan utama â€œbarâ€ secara langsung.  Itu terjadi satu kali.  Satu metode telah dipanggil di dalam yang lain. <br><br>  Lebih jauh, satu metode telah dipanggil di dalam yang lain yang memanggil metode ketiga.  Kita melihat bahwa "buz" dipanggil dua kali.  Tetapi ini adalah metode kecil yang terjadi antara satu milidetik. <br><br>  Menggunakan waktu profiler, penting untuk diingat bahwa itu tidak memberikan waktu yang tepat.  Tidak tahu persis berapa lama suatu metode.  Ini memberitahu seberapa sering muncul dalam snapshot, yang hanya bisa memperkirakan berapa lama eksekusi dari setiap metode.  Karena jika ada sesuatu yang cukup pendek, itu tidak akan pernah muncul. <br><br><img src="https://habrastorage.org/webt/2x/9_/3a/2x9_3a7jrotn2hmb7qwcrstnqq8.jpeg"><br><br>  Jika Anda beralih ke mode konsol di pohon panggilan, Anda dapat melihat semua peristiwa penurunan frame dan Anda dapat mencocokkannya.  Kami memiliki banyak bingkai yang terjatuh dan kami memiliki banyak pekerjaan yang terjadi.  Anda dapat memperbesar dalam profiler waktu dan melihat apa yang sedang dieksekusi hanya di bagian ini. <br><br><img src="https://habrastorage.org/webt/py/rr/mg/pyrrmgpd2zi_g7sfmd0bxkrb0jw.jpeg"><br><br>  Sebenarnya, di Mac, secara umum, Anda bisa mengklik opsi pada segitiga pengungkapan dan itu secara ajaib akan terbuka dan menunjukkan kepada Anda apa pun yang paling penting di sana.  Ini akan jatuh ke apa pun yang melakukan sebagian besar pekerjaan.  Dan 90% dari waktu itu akan menjadi CFRunLoopRun, dan kemudian callback. <br><br><img src="https://habrastorage.org/webt/a9/v-/u0/a9v-u04m0cv1rlw6iodwjhale3y.jpeg"><br><br>  Seluruh aplikasi didasarkan pada Run Loop.  Anda memiliki loop ini yang berlangsung selamanya dan kemudian pada setiap iterasi dari loop, callback dipanggil.  Ketika Anda sampai pada titik ini, Anda dapat menelusuri masing-masing dan pada dasarnya melihat apa yang menjadi tiga atau empat hambatan utama Anda. <br><br>  Jika kita menelusuri salah satu dari ini, kita dapat melihat hal-hal seperti itu di mana sangat mudah untuk melihatnya, dan menjadi seperti: "Wow, saya tidak tahu apa yang sedang dilakukan."  Seperti renders, penyedia gambar, IO. <br><br><img src="https://habrastorage.org/webt/jd/ay/wp/jdaywpohjztghohyu9qnxpgqkky.jpeg"><br><br>  Ada opsi untuk menyembunyikan pustaka sistem.  Sangat menggoda untuk bersembunyi, tetapi pada kenyataannya, ini sebenarnya adalah hambatan terbesar dalam aplikasi. <br><br>  Ada bobot yang menunjukkan persentase pekerjaan yang dilakukan fungsi atau metode tertentu ini.  Dan jika kita menelusuri contohnya, kita memiliki 34% dan itu terjadi karena Apple jpeg_decode_image_all.  Setelah sedikit riset, menjadi jelas bahwa itu berarti bahwa decoding JPEG terjadi pada utas utama dan menyebabkan sebagian besar frame turun. <br><br><img src="https://habrastorage.org/webt/ke/zk/zl/kezkzlggrh1akcegmmvuqefzl7u.png"><br><br><h3>  Aturan # 2 </h3><br>  Secara umum, lebih baik untuk memecahkan kode JPEG di latar belakang.  Sebagian besar perpustakaan pihak ketiga (AsyncDisplayKit, SDWebImage, ...) melakukan ini di luar kotak.  Jika Anda tidak ingin menggunakan kerangka kerja, Anda bisa melakukannya sendiri.  Apa yang Anda lakukan adalah Anda memasukkan gambar, dalam hal ini, itu adalah perluasan dari UIImage, dan kemudian Anda mengatur konteks dan Anda menggambar gambar secara manual ke dalam konteks ke dalam CGBitmap. <br><br><img src="https://habrastorage.org/webt/yu/7j/k3/yu7jk3lnsy0csn-k2kddmjha-_w.jpeg"><br><br>  Ketika Anda melakukannya, Anda dapat memanggil metode Decoded Image () dari utas latar belakang.  Itu akan selalu mengembalikan gambar yang diterjemahkan.  Tidak ada cara untuk memeriksa apakah UIImage tertentu sudah diterjemahkan, dan Anda harus selalu melewati mereka di sini.  Tetapi jika Anda melakukan cache dengan benar, itu tidak melakukan pekerjaan ekstra. <br><br>  Melakukan ini secara teknis kurang efisien.  Menggunakan UIimageView sangat dioptimalkan, sangat efisien.  Ini akan melakukan decoding perangkat keras sehingga merupakan trade-off.  Gambar Anda akan diterjemahkan lebih lambat dengan cara ini.  Tetapi hal baiknya adalah Anda dapat mengirim ke antrian latar belakang, mendekode gambar Anda dengan metode yang baru saja kita lihat, dan kemudian melompat kembali ke utas utama dan mengatur konten Anda. <br><br><img src="https://habrastorage.org/webt/xu/lv/dg/xulvdgmhnxm6zk4hrfaslok81fg.png"><br><br>  Meskipun pekerjaan itu memakan waktu lebih lama, mungkin itu tidak terjadi pada utas utama, jadi itu tidak memblokir interaksi pengguna karena tidak memblokir gulir.  Jadi itu adalah kemenangan. <br><br><h3>  Peringatan memori </h3><br>  Tanda apa pun yang Anda dapatkan peringatan memori Anda ingin meninggalkan semuanya, hapus semua memori yang tidak terpakai yang Anda bisa.  Tetapi jika Anda memiliki hal-hal yang terjadi pada utas latar belakang, mengalokasikan JPEG yang didekodekan besar ini membutuhkan banyak memori baru pada utas latar belakang. <br><br>  Ini terjadi di aplikasi Fyuse.  Jika saya akan melompat ke utas latar belakang, men-decode semua JPEG saya, dalam beberapa kasus seperti telepon yang lebih tua, sistem akan membunuhnya secara instan.  Dan itu karena mengirimkan peringatan memori yang mengatakan seperti: "Hei!  Singkirkan memori Anda â€tetapi antrian latar tidak mendengarkan.  Apa yang terjadi jika Anda mengalokasikan semua gambar ini dan kemudian crash setiap waktu.  Cara mengatasi ini adalah dengan ping utas utama dari utas latar belakang. <br><br><img src="https://habrastorage.org/webt/i2/pj/fb/i2pjfbbvytxdsiut5jqirpaibvi.png"><br><br>  Secara umum, utas utama adalah antrian.  Banyak hal menjadi antri dan terjadi di utas utama.  Ketika Anda pergi ke latar belakang di Objective-C, Anda dapat menggunakan performSelectorOnMainThread: withObject: waitUntilDone:.  Ini akan meletakkannya di akhir baris antrian utama sehingga jika antrian utama sedang sibuk memproses peringatan memori, panggilan fungsi ini akan pergi ke akhir baris dan menunggu semua peringatan memori diproses sebelum melakukan semua alokasi memori <br><br>  Di Swift, ini lebih sederhana.  Anda dapat melakukan pengiriman blok kosong utama secara serempak di utama. <br><br>  Berikut adalah contoh di mana kami telah membereskan dan kami sedang melakukan decoding gambar pada antrian latar belakang.  Dan menggulir secara visual jauh lebih cantik.  Kami masih memiliki penurunan bingkai tetapi ini pada iPod 5g, jadi ini adalah salah satu hal terburuk yang dapat Anda uji pada yang masih mendukung seperti iOS 10 dan 11. <br><br><img src="https://habrastorage.org/webt/bw/fa/og/bwfaog8aavwenf4h1lkqipapnds.gif"><br><br>  Ketika Anda memiliki bingkai tetes ini, Anda bisa terus mencari.  Masih ada pekerjaan yang terjadi dan menyebabkan penurunan bingkai ini.  Ada banyak hal yang dapat Anda lakukan untuk membuatnya lebih cepat. <br><br>  Singkatnya, itu tidak selalu mudah, tetapi jika Anda memiliki hal-hal kecil yang menghabiskan banyak waktu, Anda dapat melakukannya di latar belakang. <br><br>  Pastikan itu tidak terkait dengan UIKit.  Banyak kelas UIKit yang tidak aman untuk thread dan Anda tidak dapat mengalokasikan UIView di latar belakang. <br><br>  Gunakan Core Graphics jika Anda perlu melakukan hal-hal gambar di latar belakang.  Jangan sembunyikan pustaka sistem.  Dan jangan lupa tentang peringatan memori. <br><br>  Ini adalah bagian pertama dari sebuah artikel berdasarkan presentasi Luke Parham.  Jika Anda ingin mempelajari lebih lanjut tentang cara kerja UI di iOS, mengapa harus menggunakan jalur bezier dan kapan harus kembali ke manajemen memori manual, baca bagian kedua dari artikel di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h2>  Video </h2><br>  Tonton pembicaraan lengkap di sini: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/tZIQjrPdFcI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436360/">https://habr.com/ru/post/id436360/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436350/index.html">Pelajari Taktik Adversarial, Teknik & Pengetahuan Umum (ATT @ CK). Taktik Perusahaan. Bagian 7</a></li>
<li><a href="../id436352/index.html">Intisari berita PostgreSQL. Edisi No14</a></li>
<li><a href="../id436354/index.html">Militer AS mengabaikan masalah keamanan siber</a></li>
<li><a href="../id436356/index.html">[Menarik dari belakang bukit] Bagaimana kita menghentikan ketergantungan teknologi?</a></li>
<li><a href="../id436358/index.html">Mengapa pengembang senior mengajar siswa</a></li>
<li><a href="../id436364/index.html">Liveprof akan menunjukkan kapan dan mengapa kinerja aplikasi PHP Anda telah berubah</a></li>
<li><a href="../id436370/index.html">Infrastruktur Kunci Publik X509 v.3 Rantai Sertifikat Root</a></li>
<li><a href="../id436372/index.html">Plugin Isometrik untuk Unity3D</a></li>
<li><a href="../id436374/index.html">Tren desain UI dan UX 2019</a></li>
<li><a href="../id436376/index.html">Sekilas tentang robot semua medan EZ-Robot Roli Rover</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>