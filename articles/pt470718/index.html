<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂🏽 🔶 🧝🏽 "Efeitos algébricos" na linguagem humana 👩🏻‍🚒 👦🏾 🧕🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Comentário do tradutor: Esta é uma tradução de um ótimo artigo de Dan Abramov, colaborador do React. Seus exemplos foram escritos para JS, mas serão i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Efeitos algébricos" na linguagem humana</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470718/">  Comentário do tradutor: Esta é uma tradução de um ótimo artigo de Dan Abramov, colaborador do React.  Seus exemplos foram escritos para JS, mas serão igualmente claros para os desenvolvedores em qualquer idioma.  A ideia é comum a todos. <br><br><h3>  Você já ouviu falar sobre efeitos algébricos? </h3><br><p>  Minhas primeiras tentativas de descobrir quem são e por que deveriam me excitar não tiveram êxito.  Encontrei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vários</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PDFs</a> , mas eles me confundiram ainda mais.  (Por alguma razão, adormeço ao ler artigos acadêmicos.) </p><br><p>  Mas meu colega Sebastian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">continuou a</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">chamá-</a> los de modelo mental de algumas das coisas que fazemos no React.  (Sebastian trabalha na equipe React e apresentou muitas idéias, incluindo Hooks e Suspense.) Em algum momento, tornou-se um meme local na equipe React, e muitas de nossas conversas terminaram com o seguinte: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xb/xm/oi/xbxmoi1bn7whmzill63sq1yz1tw.jpeg"></div><br><p>  Aconteceu que os efeitos algébricos são um conceito interessante, e não é tão assustador quanto me pareceu a princípio depois de ler esses PDFs.  Se você acabou de usar o React, não precisa saber nada sobre eles, mas se você, como eu, estiver interessado, continue lendo. </p><a name="habracut"></a><br><p>  (Isenção de responsabilidade: eu não sou um pesquisador no campo de linguagens de programação e pode ter estragado algo em minha explicação. Então, deixe-me saber se estou errado!) </p><br><h3>  Ainda é cedo na produção </h3><br><p> Efeitos algébricos são atualmente um conceito experimental do campo de estudo de linguagens de programação.  Isso significa que, diferentemente de <code>if</code> , <code>for</code> ou mesmo <code>async/await</code> expressões, você provavelmente não poderá usá-las agora na produção.  Eles são suportados por apenas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">alguns</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">idiomas</a> que foram criados especificamente para estudar essa idéia.  Há progresso em sua implementação no OCaml, que ... ainda está em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">andamento</a> .  Em outras palavras, observe, mas não toque com as mãos. </p><br><h3>  Por que deveria me incomodar? </h3><br><p>  Imagine que você está escrevendo código usando <code>goto</code> , e alguém está lhe dizendo sobre a existência de construções <code>if</code> e <code>for</code> .  Ou talvez você esteja atolado em um inferno de retorno de chamada e alguém esteja lhe mostrando <code>async/await</code> .  Muito legal, não é? </p><br><p>  Se você é do tipo de pessoa que gosta de aprender inovações de programação alguns anos antes de se tornar moda, talvez seja hora de se interessar por efeitos algébricos.  Embora não seja necessário.  É assim que se fala sobre <code>async/await</code> em 1999. </p><br><h3>  Bem, que tipo de efeitos são esses? </h3><br><p>  O nome pode ser um pouco confuso, mas a ideia é simples.  Se você estiver familiarizado com <code>try/catch</code> blocos <code>try/catch</code> , entenderá rapidamente os efeitos algébricos. </p><br><p>  Vamos relembrar <code>try/catch</code> .  Digamos que você tenha uma função que lança exceções.  Talvez haja várias chamadas aninhadas entre ele e o <code>catch</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'  '</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeFriends</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user1, user2</span></span></span><span class="hljs-function">) </span></span>{ user1.friendNames.add(getName(user2)); user2.friendNames.add(getName(user1)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arya = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gendry = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">",   : "</span></span>, err); }</code> </pre> <br><p>  Lançamos uma exceção dentro de <code>getName</code> , mas ela aparece através do <code>makeFriends</code> até o <code>catch</code> mais próximo.  Essa é a principal propriedade do <code>try/catch</code> .  <strong>O código intermediário não é necessário para se preocupar com o tratamento de erros.</strong> </p><br><p>  Ao contrário dos códigos de erro em idiomas como C, ao usar o <code>try/catch</code> você não precisa passar manualmente os erros por cada nível intermediário para lidar com o erro no nível superior.  Exceções aparecem automaticamente. </p><br><p>  O que isso tem a ver com efeitos algébricos? </p><br><p>  No exemplo acima, assim que virmos um erro, não poderemos continuar executando o programa.  Quando nos encontramos em um <code>catch</code> , a execução normal do programa para. </p><br><p>  Está tudo acabado.  É tarde demais.  O melhor que podemos fazer é nos recuperar do fracasso e, de alguma forma, repetir o que estávamos fazendo, mas não podemos magicamente “voltar” para onde estávamos e fazer outra coisa.  E com efeitos algébricos, nós podemos. </p><br><p>  Este é um exemplo escrito em um dialeto JavaScript hipotético (vamos chamá-lo de ES2025 por diversão), que nos permite <em>continuar</em> trabalhando após a falta de <code>user.name</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { name = perform <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeFriends</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user1, user2</span></span></span><span class="hljs-function">) </span></span>{ user1.friendNames.add(getName(user2)); user2.friendNames.add(getName(user1)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arya = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gendry = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect === <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>) { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre><br><p>  (Peço desculpas a todos os leitores de 2025 que pesquisam na Internet "ES2025" e se enquadram neste artigo. Se, a essa altura, os efeitos algébricos se tornarem parte do JavaScript, ficarei feliz em atualizar o artigo!) </p><br><p>  Em vez de <code>throw</code> usamos a palavra-chave hipotética <code>perform</code> .  Da mesma forma, em vez de <code>try/catch</code> usamos o <code>try/handle</code> hipotético.  A <strong>sintaxe</strong> exata <strong>não importa aqui</strong> - apenas inventei algo para ilustrar a idéia. </p><br><p>  Então, o que está acontecendo aqui?  Vamos dar uma olhada. </p><br><p>  Em vez de gerar um erro, <em>realizamos o efeito</em> .  Assim como podemos <em>jogar</em> qualquer objeto, aqui podemos passar algum valor para o <em>processamento</em> .  Neste exemplo, passo uma string, mas ela pode ser um objeto ou qualquer outro tipo de dados: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { name = perform <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; }</code> </pre> <br><p>  Quando lançamos uma exceção, o mecanismo procura o manipulador de <code>try/catch</code> mais próximo na pilha de chamadas.  Da mesma forma, quando executamos um <em>efeito</em> , o mecanismo procurará o <code>try/handle</code> efeito <code>try/handle</code> mais próximo no topo da pilha: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect === <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>) { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre> <br><p>  Esse efeito nos permite decidir como lidar com a situação quando o nome não for especificado.  Novo aqui (comparado às exceções) é o <code>resume with</code> hipotético <code>resume with</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect === <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>) { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre><br><p>  Isso é algo que você não pode fazer com o <code>try/catch</code> .  Isso nos permite <strong>voltar para onde realizamos o efeito e passar algo do manipulador</strong> .  : -O </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// 1.     name = perform 'ask_name'; // 4. ...     (name   ' ') } return name; } // ... try { makeFriends(arya, gendry); } handle(effect) { // 2.    ( try/catch)  (effect === 'ask_name') { // 3. ,      (    try/catch!) resume with ' '; } }</span></span></code> </pre><br><p>  Demora um pouco para ficar confortável, mas conceitualmente isso não é muito diferente de <code>try/catch</code> com um retorno. </p><br><p>  Observe, no entanto, que os efeitos algébricos são uma ferramenta muito mais poderosa do que apenas <code>try/catch</code> .  A recuperação de erros é apenas um dos muitos casos de uso possíveis.  Comecei com este exemplo apenas porque era mais fácil para mim entender. </p><br><br><h3>  Função não tem cor </h3><br><p>  Efeitos algébricos têm implicações interessantes para código assíncrono. </p><br><p>  Em idiomas com <code>async/await</code> funções geralmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">têm uma "cor"</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">russo</a> ).  Por exemplo, no JavaScript, não podemos simplesmente tornar <code>getName</code> assíncrono sem infectar o <code>makeFriends</code> e suas funções de chamada com async.  Isso pode ser um problema real se parte do código às vezes precisar ser síncrona e, às vezes, assíncrona. </p><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//       ... async getName(user) { // ... } //       ... async function makeFriends(user1, user2) { user1.friendNames.add(await getName(user2)); user2.friendNames.add(await getName(user1)); } //   ... async getName(user) { // ... }</span></span></code> </pre><br><p>  Os geradores JavaScript funcionam de maneira <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">semelhante</a> : se você trabalha com geradores, todo o código intermediário também deve saber sobre geradores. </p><br><p>  Bem, o que isso tem a ver com isso? </p><br><p>  Por um momento, vamos esquecer o assíncrono / aguardar e voltar ao nosso exemplo: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { name = perform <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeFriends</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user1, user2</span></span></span><span class="hljs-function">) </span></span>{ user1.friendNames.add(getName(user2)); user2.friendNames.add(getName(user1)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arya = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gendry = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect === <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>) { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre><br><p>  E se o nosso manipulador de efeitos não puder retornar o "nome reserva" de forma síncrona?  E se quisermos obtê-lo do banco de dados? </p><br><p>  Acontece que podemos chamar <code>resume with</code> assincronamente do nosso manipulador de efeitos sem fazer alterações em <code>getName</code> ou <code>makeFriends</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { name = perform <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeFriends</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user1, user2</span></span></span><span class="hljs-function">) </span></span>{ user1.friendNames.add(getName(user2)); user2.friendNames.add(getName(user1)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arya = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gendry = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect === <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>) { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span>; }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); } }</code> </pre><br><p>  Neste exemplo, chamamos <code>resume with</code> apenas um segundo depois.  Você pode considerar <code>resume with</code> retorno de chamada, o qual você pode chamar apenas uma vez.  (Você também pode se mostrar aos amigos chamando isso de "uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">continuação limitada</a> única" (o termo <i>continuação delimitada</i> ainda não recebeu uma tradução estável para o russo - aprox. Transl.).) </p><br><p>  Agora a mecânica dos efeitos algébricos deve ser um pouco mais clara.  Quando lançamos um erro, o mecanismo JavaScript gira a pilha destruindo variáveis ​​locais no processo.  No entanto, quando <em>executamos o</em> efeito, nosso mecanismo hipotético cria um retorno de chamada (na verdade, um “quadro de continuação”, aprox. Transl.). Com o restante de nossa função, e <code>resume with</code> a chamada. </p><br><p>  Novamente, um lembrete: a sintaxe específica e as palavras-chave específicas são inteiramente inventadas apenas para este artigo.  O ponto não está nele, mas na mecânica. </p><br><br><h3>  Nota de limpeza </h3><br><p>  Vale ressaltar que os efeitos algébricos surgiram como resultado do estudo da programação funcional.  Alguns dos problemas que eles resolvem são exclusivos apenas da programação funcional.  Por exemplo, em idiomas que não permitem efeitos colaterais arbitrários (como Haskell), você deve usar conceitos como mônadas para arrastar efeitos pelo seu programa.  Se você já leu o tutorial da mônada, sabe que pode ser difícil de entender.  Efeitos algébricos ajudam a fazer algo semelhante com um pouco menos de esforço. </p><br><p>  É por isso que a maioria das discussões sobre efeitos algébricos são completamente incompreensíveis para mim.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Não conheço Haskell</a> e seus "amigos".) No entanto, acho que mesmo em uma linguagem impura como JavaScript, os efeitos algébricos podem ser uma ferramenta muito poderosa para separar o "o quê" do "como" no seu código. </p><br><p>  Eles permitem que você escreva um código que descreva o <em>que</em> você está fazendo: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enumerateFiles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dir</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> contents = perform OpenDirectory(dir); perform Log(<span class="hljs-string"><span class="hljs-string">'Enumerating files in '</span></span>, dir); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> file <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> contents.files) { perform HandleFile(file); } perform Log(<span class="hljs-string"><span class="hljs-string">'Enumerating subdirectories in '</span></span>, dir); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> directory <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> contents.dir) { <span class="hljs-comment"><span class="hljs-comment">//           enumerateFiles(directory); } perform Log('Done'); }</span></span></code> </pre> <br><p>  E depois envolva-o com algo que descreve o "como" você faz: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> files = []; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { enumerateFiles(<span class="hljs-string"><span class="hljs-string">'C:\\'</span></span>); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Log) { myLoggingLibrary.log(effect.message); resume; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> OpenDirectory) { myFileSystemImpl.openDir(effect.dirName, (contents) =&gt; { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> contents; }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> HandleFile) { files.push(effect.fileName); resume; } } <span class="hljs-comment"><span class="hljs-comment">//  `files`    </span></span></code> </pre><br><p>  O que significa que essas partes podem se tornar uma biblioteca: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { withMyLoggingLibrary } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'my-log'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { withMyFileSystem } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'my-fs'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ourProgram</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ enumerateFiles(<span class="hljs-string"><span class="hljs-string">'C:\\'</span></span>); } withMyLoggingLibrary(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { withMyFileSystem(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { ourProgram(); }); });</code> </pre><br><p>  Ao contrário de assíncrono / espera ou geradores, efeitos algébricos não exigem a complicação de funções "intermediárias".  Nossa chamada para <code>enumerateFiles</code> pode estar dentro do nosso programa, mas, desde que em algum lugar acima exista um manipulador de efeitos para cada um dos efeitos que ele pode executar, nosso código continuará funcionando. </p><br><p>  Os manipuladores de efeitos nos permitem separar a lógica do programa das implementações específicas de seus efeitos sem danças e códigos desnecessários.  Por exemplo, podemos redefinir completamente o comportamento nos testes para usar o sistema de arquivos falso e fazer instantâneos de logs em vez de exibi-los no console: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { withFakeFileSystem } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'fake-fs'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">withLogSnapshot</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> logs = []; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { fn(); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Log) { logs.push(effect.message); resume; } } <span class="hljs-comment"><span class="hljs-comment">// Snapshot  . expect(logs).toMatchSnapshot(); } test('my program', () =&gt; { const fakeFiles = [ /* ... */ ]; withFakeFileSystem(fakeFiles, () =&gt; { withLogSnapshot(() =&gt; { ourProgram(); }); }); });</span></span></code> </pre><br><p>  Como as funções não possuem uma "cor" (o código intermediário não precisa saber sobre efeitos) e os manipuladores de efeitos podem ser compostos (eles podem ser aninhados), você pode criar abstrações muito expressivas com elas. </p><br><br><h3>  Tipos Nota </h3><br><p>  Como os efeitos algébricos vêm de linguagens estaticamente tipificadas, a maior parte do debate sobre eles se concentra em como expressá-los em tipos.  Isso é sem dúvida importante, mas também pode complicar a compreensão do conceito.  É por isso que este artigo não fala sobre tipos.  No entanto, devo observar que geralmente o fato de uma função poder executar um efeito será codificado em uma assinatura de seu tipo.  Assim, você estará protegido de uma situação em que efeitos imprevisíveis são executados ou não pode rastrear de onde eles vêm. </p><br><p>  Aqui você pode dizer que os efeitos tecnicamente algébricos “dão cor” às funções em linguagens estaticamente tipadas, uma vez que os efeitos fazem parte de uma assinatura de tipo.  É mesmo.  No entanto, corrigir a anotação de tipo para uma função intermediária para incluir um novo efeito não é, por si só, uma mudança semântica - ao contrário de adicionar assíncrono ou transformar uma função em um gerador.  A inferência de tipo também pode ajudar a evitar a necessidade de alterações em cascata.  Uma diferença importante é que você pode "suprimir" os efeitos inserindo um stub vazio ou uma implementação temporária (por exemplo, uma chamada de sincronização para um efeito assíncrono), que, se necessário, permite impedir o efeito no código externo - ou transformá-lo em outro efeito. </p><br><br><h3>  Preciso de efeitos algébricos em JavaScript? </h3><br><p>  Honestamente, eu não sei.  Eles são muito poderosos, e pode-se argumentar que eles são muito poderosos para uma linguagem como o JavaScript. </p><br><p>  Eu acho que eles podem ser muito úteis para linguagens onde a mutabilidade é rara e onde a biblioteca padrão suporta totalmente os efeitos.  Se você executar pela primeira vez o <code>perform Timeout(1000), perform Fetch('http://google.com')</code> e <code>perform ReadFile('file.txt')</code> , e seu idioma terá “correspondência de padrão” e digitação estática para efeitos, esse pode ser um ambiente de programação muito agradável. </p><br><p>  Talvez essa linguagem seja compilada em JavaScript! </p><br><br><h3>  O que isso tem a ver com o React? </h3><br><p>  Não é muito grande.  Você pode até dizer que eu puxo uma coruja em um globo. </p><br><p>  Se você assistiu à minha conversa sobre Time Slicing and Suspense, a segunda parte inclui componentes que lêem dados do cache: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MovieDetails</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ id }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//         ? const movie = movieCache.read(id); }</span></span></code> </pre><br><p>  (O relatório usa uma API um pouco diferente, mas não é esse o ponto.) </p><br><p>  Esse código é baseado na função React para amostras de dados denominadas " <code>Suspense</code> ", que está atualmente em desenvolvimento ativo.  O interessante aqui, é claro, é que os dados ainda não estão no movieCache - nesse caso, precisamos fazer algo primeiro, porque não podemos continuar a execução.  Tecnicamente, nesse caso, a chamada para read () lança Promise (sim, lança Promise - você precisa engolir esse fato).  Isso interrompe a execução.  O React intercepta esta promessa e lembra que é necessário repetir a renderização da árvore de componentes após o cumprimento da promessa lançada. </p><br><p>  Este não é um efeito algébrico em si, embora a criação desse truque tenha sido <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">inspirada por</a> eles.  Esse truque alcança o mesmo objetivo: parte do código abaixo na pilha de chamadas é temporariamente inferior a algo mais alto na pilha de chamadas (neste caso, React), enquanto todas as funções intermediárias não precisam saber sobre isso ou serem “envenenadas” por assíncronos ou geradores.  Obviamente, não podemos "realmente" retomar a execução em JavaScript, mas do ponto de vista do React, exibir novamente a árvore de componentes após a permissão Promise ser quase a mesma.  Você pode trapacear quando o seu modelo de programação assume idempotência! </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ganchos</a> são outro exemplo que pode lembrá-lo de efeitos algébricos.  Uma das primeiras perguntas que as pessoas fazem é: aonde o useState chama “sabe” a qual componente se refere? </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LikeButton</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  useState ,    ? const [isLiked, setIsLiked] = useState(false); }</span></span></code> </pre><br><p>  Eu já expliquei isso no final <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">deste artigo</a> : no objeto React, existe um estado mutável "despachante atual", que indica a implementação que você está usando no momento (por exemplo, como em <code>react-dom</code> ).  Da mesma forma, existe uma propriedade atual do componente que aponta para a estrutura de dados interna do LikeButton.  Veja como o useState descobre o que fazer. </p><br><p>  Antes de se acostumar, as pessoas costumam pensar que parece um truque sujo por um motivo óbvio.  É errado confiar em um estado mutável geral.  (Nota: como você acha que o try / catch está implementado no mecanismo JavaScript?) </p><br><p>  No entanto, conceitualmente, você pode considerar useState () como um efeito da execução de State (), que é processada pelo React quando seu componente é executado.  Isso "explica" por que o React (o que seu componente chama) pode fornecer o estado (é mais alto na pilha de chamadas, portanto, pode fornecer um manipulador de efeitos).  De fato, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">implementação</a> explícita do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estado</a> é um dos exemplos mais comuns em livros didáticos sobre efeitos algébricos que encontrei. </p><br><p>  Novamente, é claro, não é assim que o React realmente funciona, porque não temos efeitos algébricos no JavaScript.  Em vez disso, há um campo oculto no qual salvamos o componente atual, bem como um campo que aponta para o "despachante" atual com a implementação useState.  Como uma otimização de desempenho, existem até implementações useState separadas para <a href="">montagens e atualizações</a> .  Mas se você agora está muito distorcido por esse código, pode considerá-los manipuladores de efeitos comuns. </p><br><p>  Resumindo, podemos dizer que no JavaScript, o <code>throw</code> pode funcionar como uma primeira aproximação para efeitos de E / S (desde que o código possa ser reexecutado com segurança mais tarde, e desde que não esteja vinculado à CPU), e o campo variável " O dispatcher "restaurado em try / finalmente pode servir como uma aproximação aproximada para manipuladores de efeitos síncronos. </p><br><p>  Você pode obter uma implementação de efeitos de qualidade muito mais alta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">usando geradores</a> , mas isso significa que você deve abandonar a natureza "transparente" das funções JavaScript e precisa fazer tudo com geradores.  E isso é "bem, isso ..." </p><br><h3>  Onde descobrir mais </h3><br><p>  Pessoalmente, fiquei surpreso com o sentido que os efeitos algébricos adquiriram para mim.  Eu sempre tentei o meu melhor para entender conceitos abstratos, como mônadas, mas os efeitos algébricos simplesmente pegaram e "ligaram" a cabeça.  Espero que este artigo os ajude a se juntar a você. </p><br><p>  Não sei se eles começarão a ser usados ​​a granel.  Acho que ficarei desapontado se eles não se enraizarem em nenhum dos principais idiomas até 2025.  Lembre-me de verificar em cinco anos! </p><br><p>  Estou certo de que você pode fazer muito mais interessante com eles, mas é realmente difícil sentir a força deles até começar a escrever o código e usá-lo.  Se este post despertou sua curiosidade, aqui estão mais alguns recursos onde você pode ler com mais detalhes: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github.com/ocamllabs/ocaml-effects-tutorial</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.janestreet.com/tech-talks/effective-programming</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.youtube.com/watch?v=hrBq8R_kxI0</a> </li></ul><br><p>  Muitas pessoas também apontaram que, se você omitir o aspecto da digitação (como fiz neste artigo), poderá encontrar um uso anterior dessa técnica em um sistema de condições no Common Lisp.      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  </a>  ,   ,   call/cc          . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt470718/">https://habr.com/ru/post/pt470718/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt470696/index.html">Por que Kaldi é bom para reconhecimento de fala? (atualizado em 25.12.2019)</a></li>
<li><a href="../pt470700/index.html">Mesa. Metálico Silencioso O seu</a></li>
<li><a href="../pt470706/index.html">Python + Keras + LSTM: faça um tradutor de texto em meia hora</a></li>
<li><a href="../pt470710/index.html">Machine Learning para sua caça plana. Parte 2</a></li>
<li><a href="../pt470714/index.html">Como fui para a final do avanço digital</a></li>
<li><a href="../pt470720/index.html">Como escrever um contrato inteligente com Python ontologia? Parte 2: API de armazenamento</a></li>
<li><a href="../pt470722/index.html">Como escrever um contrato inteligente com Python ontologia? Parte 3: API de tempo de execução</a></li>
<li><a href="../pt470726/index.html">Como não se afogar na rotina, ou Nossa experiência na comparação de depósitos de AWR durante testes de estresse</a></li>
<li><a href="../pt470728/index.html">Azure PowerShell: Principalmente inofensivo</a></li>
<li><a href="../pt470730/index.html">Azure PowerShell: "principalmente inofensivo"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>