<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤴🏼 🏮 🌰 Comment obtenir un élément d'un arbre binaire par index dans un délai raisonnable? 👨🏾‍🔧 😔 💃🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! 

 Il y a six mois, j'ai réfléchi à la façon d'obtenir un élément à partir d'un arbre binaire dans O (log (N)). La réponse est venue as...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment obtenir un élément d'un arbre binaire par index dans un délai raisonnable?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479142/">  Bonjour, Habr! <br><br>  Il y a six mois, j'ai réfléchi à la façon d'obtenir un élément à partir d'un arbre binaire dans O (log (N)).  La réponse est venue assez rapidement - Lazy Propagation.  Mais j'étais trop paresseux pour implémenter cela dans le code.  Maintenant, nous devons prendre le projet de fin d'études à l'université, donc je fais tout sauf ça.  C’est ainsi que je me suis assis pour le mettre en œuvre. <br><a name="habracut"></a><br>  <b>Quelques notes:</b> <br><br><ul><li>  L'arbre n'est pas équilibré (jusqu'à présent, car le projet de graduation doit encore être écrit), ce qui fait que l'estimation O (log (N)) est partout amortie pour les données d'entrée aléatoires. </li><li>  Je n'ai pas trouvé de structure de données similaire, les collègues et amis à qui j'ai posé la question n'ont pas non plus offert quelque chose de similaire.  Si vous connaissez la mise en œuvre d'une telle idée, faites-le moi savoir. </li><li>  Dans la classe vertex, on pourrait se passer du champ parent en passant le parent aux méthodes. </li></ul><br>  <b>Description de l'idée</b> <br><br>  Stockons pour chaque sommet le nombre de sommets qui se trouvent à sa gauche, appelons ce champ au vertex countLefter.  Mais ensuite, si nous ajoutons l'élément le plus à gauche à l'arbre, nous devons changer countLefter pour tous les autres sommets, qui peuvent être douloureusement longs et à la racine (oh, ce jeu de mots), ne correspond pas aux principes d'un arbre binaire.  Pour éviter cela, saisissons un champ d'ajout pour chaque sommet, dans lequel nous stockons la quantité que nous devons ajouter au champ countLefter pour chaque sommet de sa sous-arborescence, y compris ce sommet lui-même.  Ainsi, en ajoutant l'élément le plus à gauche à l'arborescence, il vous suffit de: <br><br><ul><li>  Augmentez countLefter le long du chemin entier jusqu'au point d'insertion du nouveau sommet </li><li>  Pour tous les sommets situés à droite de ce qui précède, augmentez ajouter de 1 </li></ul><br>  Il est maintenant logique d'introduire la méthode push (), qui ajoutera add au countLefter du sommet lui-même et de ses deux descendants. <br><br><div class="spoiler">  <b class="spoiler_title">C'est ainsi qu'est née la classe vertex:</b> <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UNode</span></span></span><span class="hljs-class"> </span></span>{ UNode parent; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> key; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> countLefter; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> add; UNode left; UNode right; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UNode parent, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> countLefter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> add, UNode left, UNode right)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parent = parent; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.key = key; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.countLefter = countLefter; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.add = add; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.left = left; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.right = right; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ countLefter += add; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) left.add += add; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (right != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) right.add += add; add = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Node{"</span></span> + <span class="hljs-string"><span class="hljs-string">"key="</span></span> + key + <span class="hljs-string"><span class="hljs-string">", countLefter="</span></span> + countLefter + <span class="hljs-string"><span class="hljs-string">'}'</span></span>; } }</code> </pre> <br></div></div><br>  Super, vous pouvez maintenant commencer à <b>construire un arbre!</b> <br><br>  La première chose que nous faisons, aller en haut - nous appelons la méthode push (). <br><br>  Nous allons supprimer l'élément par suppression à gauche (nous prenons le plus à droite des sommets qui sont à gauche de celui supprimé). <br><br>  Pour obtenir un élément par index, nous agissons bien évidemment: si index &lt;countLefter du sommet courant, allez à gauche.  Si les valeurs sont égales, nous avons trouvé un sommet avec un indice donné.  Sinon, nous allons à droite. <br><br>  La suppression et l'ajout d'un élément, en principe, n'est pas très différent d'un arbre binaire normal, sauf pour changer le countLefter et ajouter des champs.  Si nous retournons en haut à gauche après l'ajout / suppression réussi, ces champs devront être modifiés.  Si à droite, non. <br><br><div class="spoiler">  <b class="spoiler_title">Voici le code arborescent:</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.LinkedList; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UTree</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> UNode root; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(index, root); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UNode(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, key, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); size++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> res = add(key, root); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res) size++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.root.key) { root.push(); removeRoot(); size--; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> res = remove(key, root); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res) size--; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, UNode root)</span></span></span><span class="hljs-function"> </span></span>{ root.push(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index == root.countLefter) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> root.key; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index &lt; root.countLefter) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(index, root.left); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(index, root.right); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key, UNode root)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key == root.key) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; root.push(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key &lt; root.key) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.left != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> res = add(key, root.left); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res) { root.countLefter++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.right != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) root.right.add++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { root.left = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UNode(root, key, root.countLefter, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); root.countLefter++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.right != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) root.right.add++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.right != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> add(key, root.right); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { root.right = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UNode(root, key, root.countLefter + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeByIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.root == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; root.push(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.root.countLefter) { removeRoot(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> res = removeByIndex(index, root); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res) size--; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeByIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, UNode root)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; root.push(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index == root.countLefter) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> removeNode(root); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index &lt; root.countLefter) { <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> res = removeByIndex(index, root.left); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res) { root.countLefter--; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.right != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) root.right.add--; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> removeByIndex(index, root.right); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UNode root)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.left == root.right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.parent.left == root) root.parent.left = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> root.parent.right = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.left == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.parent.left == root) { root.parent.left = root.right; root.right.add--; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { root.parent.right = root.right; root.right.add--; } root.right.parent = root.parent; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.right == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.parent.left == root) root.parent.left = root.left; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> root.parent.right = root.left; root.left.parent = root.parent; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } UNode right = getRight(root.left); cut(right); root.key = right.key; root.countLefter--; root.right.add--; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key, UNode root)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; root.push(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key == root.key) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> removeNode(root); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key &lt; root.key) { <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> res = remove(key, root.left); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res) { root.countLefter--; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.right != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) root.right.add--; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> remove(key, root.right); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeRoot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.left == root.right) { root = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.left == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { root = root.right; root.add--; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.right == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { root = root.left; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } UNode right = getRight(root.left); cut(right); root.key = right.key; root.countLefter--; root.right.add--; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UNode node)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.parent.left == node) node.parent.left = node.left; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> node.parent.right = node.left; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.left != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) node.left.parent = node.parent; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> UNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UNode root)</span></span></span><span class="hljs-function"> </span></span>{ root.push(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.right == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> root; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getRight(root.right); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ printTree(root); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UNode root)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; root.push(); printTree(root.left); System.out.println(root); printTree(root.right); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> LinkedList&lt;UNode&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ LinkedList&lt;UNode&gt; res = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LinkedList&lt;&gt;(); getAll(root, res); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UNode root, LinkedList&lt;UNode&gt; res)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; root.push(); getAll(root.left, res); res.add(root); getAll(root.right, res); } }</code> </pre><br></div></div><br>  → <a href="https://github.com/AlexanderUsatov/UTree" rel="nofollow">Ici, le</a> code peut être trouvé sur le github. <br><br>  Je vais donner quelques résultats de la vitesse de travail.  Des tests ont été effectués sur: <br><br><img src="https://habrastorage.org/webt/ym/h3/i4/ymh3i4awvgvvgxntnc8pa9n2tlo.png"><br><br>  <b>Ajout à l'arbre:</b> <br><br>  Donc, en ajoutant un million d'éléments aléatoires dans la plage [0;  1_000): <br>  Environ 100 ms.  TreeSet a accompli cette tâche en 130 ms environ. <br><br>  Ajout d'un million d'éléments aléatoires dans la plage [0;  10_000): <br>  Environ 150 ms.  TreeSet a accompli cette tâche en environ 190 ms. <br><br>  Ajout d'un million d'éléments aléatoires dans la plage [0;  100_000): <br>  Environ 320 ms.  TreeSet a accompli cette tâche en 415 ms environ. <br><br>  Ajout d'un million d'éléments aléatoires dans la plage [0;  1_000_000): <br>  Environ 510 ms.  TreeSet a accompli cette tâche en environ 700 ms. <br><br>  Ajout d'un million d'éléments aléatoires dans la plage [0;  10_000_000): <br>  Environ 590 ms.  TreeSet a accompli cette tâche en environ 750 ms. <br><br>  <b>Suppression maintenant</b> <br><br>  Ajoutez au hasard un million de nombres à l'arbre.  Ensuite, nous essayons de supprimer un nombre aléatoire un million de fois.  Dans les tests, seul le temps de retrait est pris en compte. <br><br>  La plage d'ajout et de suppression de [0;  10_000_000): <br>  Environ 740 ms.  TreeSet a accompli cette tâche en environ 750 ms. <br><br>  La plage d'ajout et de suppression de [0;  1_000_000): <br>  Environ 600 ms.  TreeSet a terminé cette tâche en environ 800 ms (plus que lors du test précédent). <br><br>  La plage d'ajout et de suppression de [0;  100_000): <br>  Environ 130 ms.  TreeSet a accompli cette tâche en environ 160 ms. <br><br>  La plage d'ajout et de suppression de [0;  10_000): <br>  Environ 45 ms.  TreeSet a accompli cette tâche en environ 50 ms. <br><br>  La plage d'ajout et de suppression de [0;  1_000): <br>  Environ 30 ms.  TreeSet a accompli cette tâche en environ 37 ms. <br><br>  <b>Et enfin, pour le bien de tout a commencé, l'accès par index</b> <br><br>  TreeSet n'a pas cette fonctionnalité.  Je ne donnerai donc les résultats que pour UTree.  Encore une fois, nous ajoutons un million d'éléments, puis nous obtenons l'élément à un indice aléatoire de 0 au nombre d'éléments dans l'arbre.  Le temps n'est pris en compte que pour l'accès par index. <br><br>  Plage d'addition [0;  1000): 85 ms <br><br>  Plage d'addition [0;  10_000): 140 ms <br><br>  Plage d'addition [0;  100_000): 300 ms <br><br>  Plage d'addition [0;  1_000_000): 655 ms <br><br>  J'espère que quelqu'un trouvera mon idée utile, mais peut-être que pour quelqu'un ce sera l'occasion de s'occuper des arbres binaires, si vous ne l'avez pas fait :) <br><br>  <b>PS</b> <br><br>  Je prévois d'être perplexe avec l'équilibre de l'arbre après le nouvel an.  Si je le fais, le lien pour continuer apparaîtra ici. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr479142/">https://habr.com/ru/post/fr479142/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr479126/index.html">Python dans le développement mobile</a></li>
<li><a href="../fr479128/index.html">Comment fonctionne le service médical de l'aéroport</a></li>
<li><a href="../fr479132/index.html">Composant externe pour la plate-forme mobile 1C (BroadcastReceiver)</a></li>
<li><a href="../fr479136/index.html">Informatique quantique: la fin de la blockchain?</a></li>
<li><a href="../fr479140/index.html">Profiter de Flutter Interact Worldwide au bureau d'Ozon</a></li>
<li><a href="../fr479144/index.html">Dois-je enregistrer ma marque</a></li>
<li><a href="../fr479146/index.html">Comparaison des outils de contournement \ VPN</a></li>
<li><a href="../fr479150/index.html">Les robots agricoles avancent</a></li>
<li><a href="../fr479152/index.html">React et Vue sans npm et builds</a></li>
<li><a href="../fr479154/index.html">Toujours un combat ou assez?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>