<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎲 👩🏼‍🍳 📡 OpenSource di Clojure 👩🏾‍🤝‍👩🏽 👌🏼 👩🏾‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Run Loop mengundang mereka yang membuat produk keren dengan tangan mereka sendiri. Nikita Prokopov ( tonsky ) - seorang pria dan sebuah kapal, berhasi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSource di Clojure</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/420147/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Run Loop</a> mengundang mereka yang membuat produk keren dengan tangan mereka sendiri.  Nikita Prokopov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">tonsky</a> ) - seorang pria dan sebuah kapal, berhasil membuat beberapa proyek OpenSource yang dinikmati orang lain. <br><br>  Pertama-tama, mari kita bicara tentang font FiraCode, Clojure, dan proyek yang sama sekali berbeda, misalnya, pembungkus ClojureScript untuk React.  Dan kemudian mari kita beralih ke diskusi yang lebih umum tentang antarmuka yang baik, akal sehat, dan model pelatihan untuk programmer. <br><br><img src="https://habrastorage.org/webt/ir/pp/r5/irppr5opuwb6vnw9hmgkjohgota.jpeg"><br><br>  <strong>Tentang tamu</strong> : Nikita Prokopov terkenal karena ia menciptakan FiraCode, memberikan kontribusi signifikan pada pengembangan komunitas Clojure dan menerbitkan proyek-proyek seperti Datascript dan Rum di OpenSource.  Selain itu, ia menulis di Objective-C di bawah macOS: program AnyBar akan memberi tahu Anda tentang terjadinya suatu peristiwa di bilah status, oh, menubar komputer Anda. <br><br>  <strong>Penyaji</strong> : Roman Busygin (pengembang Yandex.Music untuk iOS) dan Alexey Mileev (App in the Air). <br><a name="habracut"></a><br>  <strong>Nikita</strong> : Saya seorang programmer dari Novosibirsk, tetapi sekarang saya tinggal di Moskow.  Dia terlibat dalam proyek web terutama, saya suka antarmuka.  Baru-baru ini saya telah pemrograman di Clojure. <br><br>  <strong>Roman</strong> : Saya mengusulkan untuk membangun percakapan hari ini dengan Open Source dan proyek publik Anda.  Saya ingin memulai dengan hal pertama dan paling menarik bagi saya - ini adalah font <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FiraCode</a> .  Ini digunakan oleh banyak rekan saya dan saya sendiri.  Saya selalu tertarik pada cara membuat font saya sendiri, bagaimana hal itu terjadi, apakah ada program khusus, pengetahuan apa yang perlu Anda miliki untuk membuat font Anda sendiri.  Tolong beri tahu tentang ini. <br><br><h2>  Firacode <br></h2><br>  <strong>Nikita</strong> : Tidak sepenuhnya benar untuk mengatakan bahwa ini adalah font saya.  Saya mengambil font monospace yang sudah jadi dan menyelesaikan ligatur, saya tidak menggambar sendiri.  Untuk membuat surat sendiri, Anda membutuhkan banyak pengalaman dan ketekunan.  Sangat sulit, ada sejuta kehalusan halus.  Ada font amatir dan Anda selalu dapat melihat bahwa mereka canggung, tetapi tidak selalu jelas apa yang canggung ini. <br><br>  Saya mengambil font FiraMono yang bagus dari Mozilla dan menggambar ligatur di sana, ada beberapa program untuk ini.  Saya menggunakan program Glyph yang cukup populer.  Saya bukan ahli dalam desain font, jadi saya melihat apa yang orang lain gunakan, dan saya menggunakannya juga.  Mungkin mengejutkan bahwa itu cukup mahal, tetapi mereka memberi saya lisensi untuk mengembangkan FiraCode.  Mesin terbang seperti editor grafis vektor.  Anda membuka, ada huruf, Anda menemukan sel dan menggambar.  Plus, segala macam seluk-beluk yang terkait dengan font, misalnya, bahwa huruf memiliki ukuran, titik jangkar, transisi dari cetak tebal ke cetak tebal.  Semuanya cukup sederhana. <br><br>  Menariknya, di dalam font OpenType terdapat bahasa pemrograman atas dasar penggantian ligatures ini.  Awalnya, ini dibuat sebagai sarana untuk implementasi semua jenis trik dalam font.  Misalnya, ligatur, ketika fi, ffi dan sejenisnya dalam font biasa diganti dengan ligatur.  Plus, ada variabilitas, gaya akhir huruf: jika huruf di awal dan akhir kata, beberapa ekor ditambahkan ke dalamnya.  Ini semua dapat diprogram menggunakan pola yang rumit, dan juga ligatur yang dibuatnya. <br><br>  <strong>Roman</strong> : Berapa lama untuk menyelesaikan FiraMono menjadi jenis FiraCode yang digunakan semua orang sekarang? <br><br>  <strong>Nikita</strong> : Akan sulit untuk menghitung.  Versi pertama tidak terlalu sulit.  Seperti biasa, semuanya dimulai dengan sangat cepat, tetapi butuh beberapa waktu untuk mencari tahu apa yang sedang terjadi, bagaimana menerapkannya: tidak ada banyak contoh. <br><br>  <strong>Roman</strong> : Yaitu, ada juga beberapa versi.  Bagaimana mereka berbeda? <br><br>  <strong>Nikita</strong> : Ya, dan versinya sedang diperbarui.  Pertama, saya menyelesaikan ligatur baru, kadang-kadang menghapus yang lama jika mereka bertentangan dalam sesuatu.  Pada titik tertentu, mekanisme untuk menggambar ligatur berubah di sana.  Di dalamnya ada masalah algoritmik yang sangat menarik: ada urutan karakter yang panjang, dari sana Anda perlu mengisolasi kombinasi yang membentuk ligatur, tetapi jika mereka berpotongan, maka harus ada pengganti lain.  Saya bahkan memiliki program Clojure yang menghasilkan seperangkat aturan yang kemudian dimasukkan ke dalam font - cukup sulit.  Hal ini telah berubah, metode rendering pengikat telah berubah.  Sebelumnya, mereka digantikan oleh satu karakter, sekarang mereka digantikan oleh tiga karakter.  Bahkan, untuk pengguna semakin baik, lebih sedikit bug, lebih banyak pengikat. <br><br>  <strong>Roman</strong> : Menarik.  Saya tidak pernah berpikir bahwa mungkin ada bug dalam font.  Aturan dimana pelukis memutuskan kapan harus memasukkan ligatur dan kapan tidak, dijelaskan dalam bahasa pemrograman khusus atau hanya secara deklaratif? <br><br>  <strong>Nikita</strong> : Secara deklaratif, dan kemudian secara internal menerjemahkan cukup efisien ke dalam tabel penggantian. <br><br><h3>  Atur untuk versi pertama dari ligatures <br></h3><br>  <strong>Roman</strong> : Katakan padaku, kapan kamu membuat satu set ligatur, apakah kamu melihat bahasa pemrograman tertentu atau adakah daftar umum yang dibutuhkan orang dalam kehidupan sehari-hari? <br><br>  <strong>Nikita</strong> : Saya sendiri tidak menemukan ide ini.  Saya melihat bahwa ada font Hasklig yang dibuat khusus untuk Haskell.  Tetapi saya tidak membutuhkan Haskell, jadi saya pikir saya perlu membuat font yang sama, tetapi, pertama, berdasarkan font yang saya suka, dan kedua, untuk bahasa apa pun.  Lalu aku mengambil semua <strong>yang terpikir olehku</strong> .  Hal-hal pertama sudah jelas: &lt;=,&gt; =, -&gt;, &lt;-.  Anda menulis seperti dalam C, tetapi diganti dengan panah.  Menurut saya, ini semua dimulai. <br><br><h2>  Clojure <br></h2><br>  <strong>Alexei</strong> : pada awalnya, kamu menyebutkan bahwa kamu menulis tentang Clojure sekarang.  Ceritakan bagaimana Anda datang ke Clojure, bagaimana semuanya dimulai, bagaimana Anda sampai pada bahasa ini? <br><br>  <strong>Nikita</strong> : Saya menonton beberapa ceramah oleh Rich Hickey (saya sarankan, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> ).  Mereka keren dan serbaguna tentang topik bagaimana kepala programmer bekerja, secara kasar, bagaimana merancang sistem.  Ceramah-ceramah itu membuka banyak sekali informasi penting baru yang penting bagi saya, dan saya adalah penggemar Rich Hickey.  Kemudian dia menjadi tertarik pada apa yang telah dia lakukan.  Ternyata dia membuat bahasa Clojure.  Saya pergi untuk membacanya, memikirkan semuanya dan kami pergi. <br><br>  <strong>Roman</strong> : Saya juga bisa direkam sebagai penggemar Rich Hickey.  Saya melihat penampilannya: keduanya panjang dan, yang paling penting, menarik.  Artinya, ia berhasil menjaga perhatian pendengar untuk waktu yang lama. <br><br>  <strong>Alexei</strong> : apa yang sebenarnya kamu suka dari Clojure? <br><br>  <strong>Nikita</strong> : Pada konferensi terakhir, Rich Hickey membuat pernyataan berikut: <br><br><blockquote>  Clojure adalah bahasa untuk programmer yang lebih tua dan lelah. <br></blockquote><br>  Mereka tidak datang kepadanya di awal karir, tetapi dia menjadi menarik setelah 10-15 tahun.  Pertama-tama, Anda memiliki kebebasan absolut.  Semua yang Anda butuhkan, Anda lakukan sendiri atau ambil dari perpustakaan.  <strong>Dalam bahasa itu sendiri, hal-hal minimum dijahit</strong> .  Segala sesuatu yang Anda desain, lakukan persis seperti yang Anda butuhkan.  Semuanya buatan sendiri dan bisa diubah.  Ini berbahaya ketika Anda seorang pemula, tetapi berguna jika Anda sudah ahli dan tahu apa yang Anda butuhkan. <br><br>  Dalam bahasa ini, pikiran diungkapkan sejelas dan seringkas mungkin.  Yaitu, jarak minimum antara kerumitan apa yang Anda coba ekspresikan dan kerumitan bagaimana itu ditulis.  Di Jawa, misalnya, Anda dapat melakukan beberapa hal yang benar-benar sepele, tetapi itu akan membentang selama 10 baris, dan Anda akan lelah.  Dalam Clojure, jika sesuatu itu sepele, maka itu ditulis, kemungkinan besar, sepele, dalam satu atau dua baris. <br><br>  <strong>Roman</strong> : Saya menyadari bahwa Anda menjawab pertanyaan saya.  Ketika saya mendengar bahwa Clojure tidak memaksakan batasan pada Anda, untuk beberapa alasan saya langsung ingat C, yang entah bagaimana juga berdiri di telinganya.  Tetapi kemudian saya mendengar jawaban bahwa itu bukan hanya gula sintaksis, tetapi juga bahasa yang praktis dan praktis yang memungkinkan Anda untuk mengekspresikan pikiran Anda dengan kode yang lebih sedikit. <br><br>  <strong>Nikita</strong> : Ya, levelnya sangat tinggi, dan C levelnya rendah. <br><br>  <strong>Alexei</strong> : Saya bertanya-tanya apakah kebebasan bahasa seperti itu tidak mengganggu pekerjaan dalam proyek-proyek besar dengan sejumlah besar orang.  Atau di OpenSource, di mana Anda perlu memonitor setiap perubahan dengan hati-hati?  Sejauh yang saya dengar, hal-hal yang diperbolehkan di Clojure hingga <strong>mengubah sintaks bahasa</strong> .  Apakah itu tidak mengganggu Anda? <br><br>  Itu mengingatkan saya pada situasi dengan Scala, ketika bahasa tahu banyak hal, dan dalam setiap proyek besar setiap orang dibungkus dengan semacam penggaruk sendiri.  Akibatnya, mereka melakukan beberapa praktik umum, yang kami gunakan, dan ini tidak.  Akibatnya, <strong>Scala dalam satu proyek dan Scala dalam yang lain adalah dua Scala yang berbeda</strong> .  Apakah ada masalah seperti itu di Clojure? <br><br>  <strong>Nikita</strong> : Saya tidak bekerja di proyek-proyek besar.  Di tempat dia bekerja, ada sedikit variasi.  Bahkan, untuk beberapa alasan, kebingungan langsung seperti itu tidak terjadi.  Sepertinya bagi saya ini karena di Scala, katakanlah, ada penggemar yang membuat teori dan berspekulasi tentang cara melakukan sesuatu yang paling benar.  Seperti yang Anda katakan, ada banyak segalanya - Anda dapat memilih bukan itu.  Di Clojure, sebaliknya, tidak banyak - Anda tidak dapat memilih hal yang salah.  Ini adalah bahasa yang sangat praktis.  Clojure tidak suka membuat abstraksi untuk masa depan.  Jika Anda perlu mencetak sesuatu, misalnya, maka Anda cukup mencetak sepraktis mungkin dan tidak khawatir dari mana asal printer, antarmuka apa, protokol yang Anda laksanakan.  Anda melakukan apa yang Anda butuhkan.  Oleh karena itu, kepraktisan ini mungkin merupakan penyebut yang umum. <br><br><h2>  Proyek di Clojure <br></h2><br>  <strong>Roman</strong> : Sejauh yang saya bisa lihat, Anda memiliki beberapa proyek tentang Clojure di GitHub.  Ceritakan lebih banyak tentang mereka kepada kami. <br><br><h3>  Datascript <br></h3><br>  <strong>Nikita</strong> : Proyek OpenSource pertama saya yang relatif sukses adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Datascript</a> .  Ini adalah penyimpanan klien untuk browser.  Ini mungkin tidak terlalu berguna untuk situs, dan jika Anda menulis semacam aplikasi interaktif di browser, maka Anda perlu menyimpan status di suatu tempat.  Datascript hanyalah repositori untuk status.  Keripiknya: <br><br><ul><li>  <strong>Dia tidak berubah</strong> .  Artinya, itu tidak merusak versi sebelumnya, hanya membuat salinan penyimpanan baru dengan cukup efisien. <br></li><li>  <strong>Dia disortir</strong> .  Secara otomatis mendukung indeks pada atribut, pada entitas_id apa pun, dan sebagainya.  Ini memungkinkan Anda untuk dengan cepat menemukan semua yang Anda butuhkan.  semua yang kamu butuhkan. <br></li><li>  <strong>Itu datar</strong> .  Jika Anda belum benar-benar berpikir tentang cara menerapkan penyimpanan pada klien, maka hal pertama yang akan Anda lakukan adalah struktur JSON bersarang.  Di Datascript penyimpanannya rata, kapan saja Anda bisa pergi ke mana saja dan menemukan yang Anda butuhkan. <br></li></ul><br>  Secara umum, ini adalah akses yang relatif mudah ke data, dua arah: Anda dapat beralih dari orang tua ke anak, atau Anda juga dapat beralih dari anak ke orang tua. <br><br>  Untuk komunitas Clojure, ia memiliki satu keuntungan lagi: dibuat dengan API yang sama dengan Datomic.  Datomic adalah database Clojure.  Karena mereka memiliki antarmuka yang sama, jika Anda tahu Datomic, - Anda tahu Datascript.  Ada juga kueri di sana, Anda dapat menulis kueri data dalam bahasa Datalog.  Saya tidak menemukan fitur ini sangat berguna untuk antarmuka, tetapi ada orang yang menemukan berguna dalam hal ini.  Ini seperti SQL, Anda dapat membuka kondisi dan mendapatkan hasil dari repositori klien. <br><br>  <strong>Roman</strong> : Tolong beri tahu kami mengapa Datascript unik.  Tugas menyimpan keadaan pada klien dalam aplikasi interaktif cukup umum.  Tampaknya sudah seharusnya tertanam di suatu tempat baik dalam bahasa itu sendiri atau dalam semacam kerangka kerja.  Namun, Anda memutuskan untuk membuat keputusan.  Apa yang mendorongmu? <br><br>  <strong>Nikita</strong> : Saya bertanya-tanya apakah saya bisa membuat alat kecil Datomic.  Sangat menarik untuk mengulangi sistem yang ada.  Kemudian ternyata ini adalah ide yang bagus, dan sangat nyaman untuk mengatur dan mengakses keadaan dengan cara ini.  Mungkin ada solusi serupa di dunia JavaScript.  Ada yang namanya Relay.  Sejauh yang saya ingat, ini memecahkan masalah sinkronisasi dan penyimpanan data.  Dia agak mirip, tetapi, menurut saya, kemudian muncul. <br><br><h3>  Rum <br></h3><br>  <b>Alexey</b> : Ada satu lagi perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rum</a> Anda.  Tolong beritahu saya tentang dia. <br><br>  <strong>Nikita</strong> : Rum hanyalah pembungkus React untuk ClojureScript.  Bereaksi itu keren, hebat, dan semua orang menyukainya.  Saya ingin menggunakannya b di ClojureScript untuk digunakan.  Dia adalah skrip Java, tapi saya ingin menggunakannya dalam Clojurescript.  Ada beberapa solusi di dunia ClojureScript, tetapi semuanya terlalu konseptual.  Mereka menawarkan model mereka, yang secara internal menggunakan React.  Artinya, tidak murni, tetapi konsepnya sendiri, yang menggunakan React. <br><br>  Gagasan Rum muncul dari fakta bahwa Anda tidak dapat menggunakan Datascript dengan pengikat sebelumnya, tetapi saya ingin menggunakannya.  Akibatnya, saya sampai pada desain di mana Rum adalah ikatan paling transparan dan sepele untuk Bereaksi.  Kami menawarkan semuanya sama seperti di Bereaksi, hanya dibungkus dengan antarmuka yang nyaman untuk menggunakan ClojureScript.  Tidak menyembunyikan apa pun, Anda bisa mendapatkan komponen asli React.  Ia seorang agnostik, sesuka Anda, dan mengatur aplikasi dan arsitektur. <br><br>  <strong>Roman</strong> : Menurut cerita dari huruf yang sudah dikenal, dan secara umum, melihat ke arah React and React Native, saya melihat betapa gilanya proyek Anda mendapatkan popularitas.  Anda bilang itu pembungkus React.  Tetapi React adalah proyek besar, dan Anda berhasil membuat Rum sangat kecil tanpa mempelajari banyak sumber Bereaksi.  Bagaimana kamu melakukannya? <br><br>  <strong>Nikita</strong> : Bereaksi sebenarnya bukan proyek besar.  Semua hal-hal penting yang ada di Bereaksi berada di perpustakaan Preact, yang hanya membutuhkan 3 KB.  React memiliki API yang cukup kecil plus banyak peretasan untuk peramban baru, tidak masuk akal untuk mempelajari peretasan, semuanya ada di dalam React. <br><br>  <strong>Roman</strong> : Apakah G6 bagian dari React atau tidak? <br><br>  <strong>Nikita</strong> : Secara resmi - tidak, ini adalah komponen yang terpisah. <br><br>  <strong>Roman</strong> : Apakah Anda porting atau kesampingkan? <br><br>  <strong>Nikita</strong> : Tidak, saya belum porting; Anda tidak menggunakannya di ClojureScript.  Di ClojureScript, kode adalah data dan semua itu, Anda bahkan tidak memerlukan sesuatu seperti G6, Anda sudah memiliki sintaks berbasis vektor sendiri, yang diterima di komunitas Clojure.  Menggunakan data, kami menyajikan hal yang sama yang dilakukan di G6 oleh makro dan preprocessing sumber. <br><br>  <strong>Roman</strong> : Wow!  Sekarang saya mengusulkan untuk beralih ke proyek berikutnya.  Saya sangat terkejut dan senang ketika saya melihat bahwa Anda, Nikita, menulis proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AnyBar</a> - aplikasi menubar yang menunjukkan indikator berbeda di dekat jam.  Anehnya, proyek MacOS pertama saya juga merupakan aplikasi menubar yang memperlihatkan notifikasi surat-surat baru dari Yandex.Mail.  Saya melihat sumbernya dan langsung kembali ke 8 tahun yang lalu. <br><br>  Proyek ini sangat sederhana dan populer.  Tentunya, mereka menggunakannya untuk beberapa tugas terapan.  Tolong beritahu saya bagaimana proyek itu muncul, bagaimana Anda menggunakannya sendiri, atau, mungkin, Anda tahu bagaimana seseorang menggunakannya? <br><br><h3>  Anybar <br></h3><br>  <strong>Nikita</strong> : Proyek ini muncul secara tidak sengaja.  Anda tahu, programmer suka menulis sesuatu, dan di sini.  Kode Clojure tidak perlu dikompilasi; Kode ClojureScript tidak.  Setiap kali Anda mengubah sumber, itu dikompilasi ulang.  Ini membutuhkan waktu: mulai dingin membutuhkan 30-40 detik, misalnya, dan membangun bertahap dari satu detik ke sepuluh detik.  Anda mengubah sumber, beralih ke browser, dan Anda masih tidak tahu apakah Anda sudah bisa menonton atau masih harus menunggu, karena sumbernya belum dikompilasi.  Untuk mengetahui ini, saya datang dengan indikator. <br><br>  Semua bekerja terutama pada laptop, tidak ada banyak ruang, di mana mendapatkannya.  Anda harus beralih ke terminal dan menunggu sampai semuanya dikompilasi di terminal, dan kemudian beralih ke browser.  Agar tidak pergi ke terminal lagi, saya menjadikan diri saya indikator dalam menubar, yang menunjukkan status build: mengkompilasi, mengkompilasi, dan dikompilasi dengan kesalahan.  Jika terjadi kesalahan, maka Anda tidak perlu me-refresh halaman seratus kali, masih tidak ada yang berlaku. <br><br>  Saya tidak melakukannya dengan cara tertentu, tetapi saya melakukannya secara universal.  Untuk mengubah warna indikator di AnyBar, Anda hanya perlu mengirim paket UDP, ini adalah cara paling sederhana untuk komunikasi silang.  Ternyata ini adalah hal yang super fleksibel, yang sepele untuk skrip.  Saya digunakan terutama untuk membangun status saja. <br><br>  Seseorang, misalnya, baru-baru ini mentweet bahwa ia telah membuat indikator status kursi kosong di kedutaan.  Sehingga Anda bisa segera membuat janji, ketika ada kursi kosong.  Itu juga ditampilkan di AnyBar. <br><br>  <strong>Roman</strong> : Nikita, apakah benda ini hanya berfungsi di Localhost, atau bisakah mesin virtual saya di Belanda mem-ping laptop saya dan menampilkan sesuatu dalam menubar? <br><br>  <strong>Nikita</strong> : Jika Anda dapat mengirim paket UDP dari mesin virtual Anda untuk laptop, maka ya. <br><br>  <strong>Alexei</strong> : Setelah mendengar tentang waktu membangun dingin 30-40 detik dan kemudian panas kembali selama satu atau dua detik, tentu saja, saya hanya bisa iri dari dunia Android.  Tapi di sini saya punya pertanyaan ini: apakah semua ini telah ditumbuhi dengan set skrip shell yang sudah jadi, plug-in yang sudah jadi yang bahkan tidak bisa Anda tulis, tetapi cukup dicolokkan sehingga semuanya langsung bekerja? <br><br>  <strong>Nikita</strong> : Itu tidak ditumbuhi, karena saya tidak banyak melakukannya.  Saya bahkan terkejut bahwa ada orang lain yang tertarik.  Ada banyak hal: banyak ide, bahkan banyak klon.  Orang ingin menampilkan teks atau beberapa indikator dan sebagainya.  Saya akan melakukan semua ini, tetapi tangan saya tidak mencapai. <br><br><h2>  grumpy.website </h2><br>  <strong>Alexei</strong> : ayo beralih ke proyek selanjutnya.  Katakan padaku apa itu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">grumpy.website.</a> <br><br>  <strong>Nikita</strong> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">grumpy.website</a> adalah blog tentang contoh antarmuka buruk.  Kami mengumpulkan setiap jambs di antarmuka komputer dan non-komputer, berdiskusi, mengeluh tentang mereka. <br><br>  <strong>Alexey</strong> : Berapa lama situs ini muncul? <br><br>  <strong>Nikita</strong> : Sekitar setahun yang lalu. <br><br>  <strong>Alexei</strong> : berapa banyak orang yang memposting sesuatu di sana? <br><br>  <strong>Nikita</strong> : Ini adalah proyek penulis, kami sekarang memiliki empat penulis.  Kami terutama memposting, tetapi lima orang lagi secara berkala mengirimkan saran mereka.  Ini adalah mesin yang sepenuhnya khusus ditulis di Clojure langsung di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saluran YouTube</a> saya.  Butuh 13-14 masalah udara, deskripsi lengkap yang ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gist</a> .  Jika Anda tertarik bagaimana cara membuat aplikasi web di Clojure dari awal, Anda bisa melihatnya. <br><br>  <strong>Roman</strong> : Apakah kursus ini sudah selesai, atau apakah proyek masih diselesaikan, dan apakah Anda memposting catatan saat sedang diselesaikan? <br><br>  Nikita: Ini lebih dari blog video.  Itu berakhir pada keadaan di mana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">grumpy.website</a> sekarang berada - itu secara real time.  Apa yang sekarang ada di situs, lalu di blog. <br><br><h2>  Desain dan kegunaan <br></h2><br>  <strong>Roman</strong> : Anda, sebagai orang yang mengangkat proyek tentang kebodohan desain antarmuka, kemungkinan besar berpengalaman dalam desain dan kegunaan.  Bagaimana Anda bisa masuk ke area ini?  Bagaimana Anda tertarik dengan ini? <br><br>  <strong>Nikita</strong> : Itu terjadi cukup awal, di awal karier.  Saya terlibat dalam proyek web, dan bagi saya tampaknya untuk melakukan antarmuka dengan baik, saya perlu memahami apa yang kami lakukan.  Ada perasaan bahwa semuanya tidak beres dengan antarmuka komputer. <br><br>  Saya membaca beberapa buku terkenal dan kedengarannya sangat masuk akal.  Di satu sisi, Anda perlu mengawasi antarmuka yang bagus.  Akal sehat, di sisi lain.  Untuk membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">grumpy.website</a> , Anda tidak perlu menjadi ahli di antarmuka, akal sehat cukup untuk memahami bahwa ini adalah horor-horor. <br><br>  <strong>Roman</strong> : Saya ingat bahwa setelah membaca buku "Desain hal-hal yang akrab" oleh Donald Norman, saya benar-benar mulai melihat lebih banyak.  Tetapi sebelum itu, saya menggunakan omong kosong ini, kekurangan ini dan mata saya tidak melekat. <br><br><h2>  Laporan AppsConf </h2><br>  <strong>Alexey</strong> : Nikita akan berbicara di AppsConf dengan laporan " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Akuisisi keterampilan</a> ".  Nikita, katakan padaku bagaimana laporan seperti itu muncul. <br><br>  <strong>Nikita</strong> : Saya menonton laporan tentang model driftfus.  Ini adalah model untuk memperoleh keterampilan, yang menurutnya setiap orang, mempelajari bidang baru, melewati tahapan yang berbeda: pemula, kompeten, spesialis, ahli, ahli.  Saya pergi membaca, mencari tahu apa level-level ini, bagaimana perbedaannya, menemukan bagaimana hal itu jatuh pada pemrograman dan semua yang saya lihat di sekitar pemrograman: kursus, buku, diskusi di Internet, bahasa pemrograman perangkat.  Yaitu, sehubungan dengan berbagai tingkat programmer atau pemrograman.  Ternyata ini adalah model yang menarik yang menjelaskan banyak hal.     ,         ,             . <br><br> ,    :   ,        .   — ,  —  .     .   ,   ,   ,     . <br><br> <strong></strong> : ,     ,      ,      ,      ,    . ,      . ,   . <br><blockquote>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AppsConf</a>    — 8  9 .          .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> (   : ,   ),     . <br><br>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">YouTube-</a> ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>      . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420147/">https://habr.com/ru/post/id420147/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420135/index.html">Ini juga Toshiba: produk yang tidak terduga dari perusahaan Jepang</a></li>
<li><a href="../id420139/index.html">Buku “Rekayasa Keandalan Situs. Keandalan dan keandalan seperti di Google »</a></li>
<li><a href="../id420141/index.html">Dari MPMS DBMS yang dimuat - Danau Data peppy dengan alat analitis: bagikan detail pembuatannya</a></li>
<li><a href="../id420143/index.html">Performa Kotlin di Android</a></li>
<li><a href="../id420145/index.html">Bagaimana hari kerja para anggota PC AppsConf</a></li>
<li><a href="../id420151/index.html">Lebih mudah daripada kedengarannya. Bab 12</a></li>
<li><a href="../id420153/index.html">Pencetakan 3D bagian kompleks yang terbuat dari ABS dan PLA dengan banyak dukungan</a></li>
<li><a href="../id420155/index.html">Intel Datacenter SSD. Volume besar dan nama baru</a></li>
<li><a href="../id420157/index.html">Pemodelan Fungsional SJ-meetup Menggunakan Kasus Penggunaan</a></li>
<li><a href="../id420159/index.html">Layanan Web Docking dalam R dan Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>