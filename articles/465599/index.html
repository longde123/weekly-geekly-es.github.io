<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧙🏿 🅾️ 🙍 IPFS sin dolor (pero eso no es exacto) 🧔🏿 🤮 🤶🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A pesar de que en Habré ya no había un artículo sobre IPFS . 

 Aclararé de inmediato que no soy un experto en este campo, pero he mostrado interés en...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>IPFS sin dolor (pero eso no es exacto)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465599/"><img src="https://habrastorage.org/webt/wi/od/vh/wiodvhs9bp_gm6uff-4kp8ly0ni.jpeg"><br><br>  A pesar de que en Habré ya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no</a> había <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un artículo sobre IPFS</a> . <br><br>  Aclararé de inmediato que no soy un experto en este campo, pero he mostrado interés en esta tecnología más de una vez, pero intentar jugar con ella a menudo causaba algo de dolor.  Hoy retomé los experimentos y obtuve algunos resultados que me gustaría compartir.  En resumen, se describirá el proceso de instalación de IPFS y algunos chips (todo se hizo en ubuntu, en otras plataformas que no probé). <br><a name="habracut"></a><br>  <i>Si se perdió lo que es IPFS, está escrito con algún detalle aquí: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">habr.com/en/post/314768</a></i> <br><br><h2>  Instalación </h2><br>  <i>Para la pureza del experimento, propongo instalarlo de inmediato en algún servidor externo, ya que consideraremos algunas dificultades al trabajar en modo local y remoto.</i>  <i>Entonces, si lo desea, no será demolido por mucho tiempo, no hay muchos.</i> <br><br><h3>  Listo </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Documentación oficial</a> <br>  Vea la versión actual en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">golang.org/dl</a> <br><br>  <i>Nota: es mejor instalar IPFS en nombre del usuario, que se supone que debe usar los más frecuentes.</i>  <i>El hecho es que a continuación consideraremos la opción de montaje a través de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FUSE</a> y hay sutilezas allí.</i> <br><br><pre><code class="plaintext hljs">cd ~ curl -O https://dl.google.com/go/go1.12.9.linux-amd64.tar.gz tar xvf go1.12.9.linux-amd64.tar.gz sudo chown -R root:root ./go sudo mv go /usr/local rm go1.12.9.linux-amd64.tar.gz</code> </pre> <br>  Luego debe actualizar el entorno (más detalles aquí: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">golang.org/doc/code.html#GOPATH</a> ). <br><br><pre> <code class="plaintext hljs">echo 'export GOPATH=$HOME/work' &gt;&gt; ~/.bashrc echo 'export PATH=$PATH:/usr/local/go/bin:$GOPATH/bin' &gt;&gt; ~/.bashrc source ~/.bashrc</code> </pre><br>  Verifique que go esté instalado <br><br><pre> <code class="plaintext hljs">go version</code> </pre> <br><h3>  Instalar IPFS </h3><br>  Me gustó la forma de instalar a través de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ipfs-update más</a> . <br><br>  Instalarlo con el comando <br><br><pre> <code class="plaintext hljs">go get -v -u github.com/ipfs/ipfs-update</code> </pre><br>  Después de eso, puede ejecutar los siguientes comandos: <br><br>  <b>versiones de actualización de ipfs</b> : para ver todas las versiones disponibles para descargar. <br>  <b>versión de actualización de ipfs</b> : para ver la versión instalada actual (hasta que tengamos instalado IPFS, no será ninguna). <br>  <b>ipfs-update install latest</b> : instala la última versión de IPFS.  En lugar de la última, respectivamente, puede especificar cualquier versión deseada de la lista de disponibles. <br><br>  Instalar ipfs <br><br><pre> <code class="plaintext hljs">ipfs-update install latest</code> </pre><br>  Cheque <br><br><pre> <code class="plaintext hljs">ipfs --version</code> </pre> <br>  Directamente con la instalación en términos generales, todo. <br><br><h2>  Lanzamiento de IPFS </h2><br><h3>  Inicialización </h3><br>  Primero debes realizar la inicialización. <br><br><pre> <code class="plaintext hljs">ipfs init</code> </pre> <br>  En respuesta, obtendrá algo como esto: <br><br><pre> <code class="plaintext hljs"> ipfs init initializing IPFS node at /home/USERNAME/.ipfs generating 2048-bit RSA keypair...done peer identity: QmeCWX1DD7HnXXXXXXXXXXXXXXXXXXXXXXXXxxx to get started, enter: ipfs cat /ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv/readme</code> </pre><br>  Puedes ejecutar el comando propuesto <br><br><pre> <code class="plaintext hljs">ipfs cat /ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv/readme</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Resultado</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">Hello and Welcome to IPFS! ██╗██████╗ ███████╗███████╗ ██║██╔══██╗██╔════╝██╔════╝ ██║██████╔╝█████╗ ███████╗ ██║██╔═══╝ ██╔══╝ ╚════██║ ██║██║ ██║ ███████║ ╚═╝╚═╝ ╚═╝ ╚══════╝ If you're seeing this, you have successfully installed IPFS and are now interfacing with the ipfs merkledag! ------------------------------------------------------- | Warning: | | This is alpha software. Use at your own discretion! | | Much is missing or lacking polish. There are bugs. | | Not yet secure. Read the security notes for more. | ------------------------------------------------------- Check out some of the other files in this directory: ./about ./help ./quick-start &lt;-- usage examples ./readme &lt;-- this file ./security-notes</code> </pre><br></div></div><br>  Aquí, en mi opinión, lo interesante ya está comenzando.  En la etapa de instalación, los chicos ya están comenzando a usar sus propias tecnologías.  El hash propuesto QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv, no generado específicamente para usted, pero cosido en el lanzamiento.  Es decir, antes del lanzamiento, prepararon un texto de bienvenida, lo vertieron en IPFS y agregaron la dirección al instalador.  En mi opinión, esto es muy bueno.  Y este archivo (más precisamente, la carpeta completa) ahora se puede ver no solo localmente, sino también en la puerta de enlace oficial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ipfs.io/ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv</a> .  Al mismo tiempo, puede estar seguro de que el contenido de la carpeta no cambió de ninguna manera, porque si hubiera cambiado, el hash también habría cambiado. <br><br>  <i>Por cierto, en este caso, IPFS tiene algunas similitudes con el servidor de control de versiones.</i>  <i>Si realiza cambios en los archivos de origen de la carpeta y vuelve a verter la carpeta en IPFS, recibirá una nueva dirección.</i>  <i>Al mismo tiempo, la carpeta anterior no irá a ningún lado así y estará disponible en su dirección anterior.</i> <br><br><h3>  Lanzamiento directo </h3><br><pre> <code class="plaintext hljs">ipfs daemon</code> </pre> <br>  Deberían obtener una respuesta como esta: <br><br><pre> <code class="plaintext hljs">ipfs daemon Initializing daemon... go-ipfs version: 0.4.22- Repo version: 7 System version: amd64/linux Golang version: go1.12.7 Swarm listening on /ip4/xxxx/tcp/4001 Swarm listening on /ip4/127.0.0.1/tcp/4001 Swarm listening on /ip6/::1/tcp/4001 Swarm listening on /p2p-circuit Swarm announcing /ip4/127.0.0.1/tcp/4001 Swarm announcing /ip6/::1/tcp/4001 API server listening on /ip4/127.0.0.1/tcp/5001 WebUI: http://127.0.0.1:5001/webui Gateway (readonly) server listening on /ip4/127.0.0.1/tcp/8080 Daemon is ready</code> </pre><br><h4>  Abrimos la puerta a internet </h4><br>  Presta atención a estas dos líneas: <br><br><pre> <code class="plaintext hljs">WebUI: http://127.0.0.1:5001/webui Gateway (readonly) server listening on /ip4/127.0.0.1/tcp/8080</code> </pre><br>  Si instaló IPFS localmente, accederá a las interfaces IPFS en las direcciones locales y todo estará disponible para usted (por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">localhost</a> : 5001 / webui /).  Pero cuando se instala en un servidor externo, por defecto, las puertas de enlace están cerradas a Internet.  Hay dos puertas de enlace: <br><br><ol><li>  Admin webui ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github</a> ) en el puerto 5001. </li><li>  API externa en el puerto 8080 (solo lectura). </li></ol><br>  Hasta ahora, puede abrir ambos puertos para experimentos (5001 y 8080), pero, por supuesto, en el servidor de batalla, el puerto 5001 debe cerrarse con un firewall.  Hay 4001 puertos, es necesario para que otros pares puedan encontrarte.  Debe dejarse abierto a solicitudes externas. <br><br>  Abra ~ / .ipfs / config para editar y encuentre estas líneas en él: <br><br><pre> <code class="plaintext hljs">"Addresses": { "Swarm": [ "/ip4/0.0.0.0/tcp/4001", "/ip6/::/tcp/4001" ], "Announce": [], "NoAnnounce": [], "API": "/ip4/127.0.0.1/tcp/5001", "Gateway": "/ip4/127.0.0.1/tcp/8080" }</code> </pre> <br>  Cambie 127.0.0.1 a la ip de su servidor y guarde el archivo, luego reinicie ipfs (detenga el comando de ejecución Ctrl + C y vuelva a ejecutar). <br><br>  Debe obtener <br><br><pre> <code class="plaintext hljs">... WebUI: http://ip__:5001/webui Gateway (readonly) server listening on /ip4/ip__/tcp/8080</code> </pre><br>  Ahora las interfaces externas deberían estar disponibles. <br><br>  Echa un vistazo <br><br><pre> <code class="plaintext hljs">http://__ip_:8080/ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv/readme</code> </pre> <br>  El archivo Léame anterior debería abrirse. <br><br><pre> <code class="plaintext hljs">http://__ip_:5001/webui/</code> </pre> <br>  La interfaz web debería abrirse. <br><br>  <i>Si webui funciona para usted, la configuración de IPFS se puede cambiar directamente en él, incluidas las estadísticas de visualización, pero a continuación consideraré las opciones de configuración directamente a través del archivo de configuración, que generalmente no es crítico.</i>  <i>Es mejor recordar exactamente dónde se encuentra la configuración y qué hacer con ella, y si la cara web no funciona, será más difícil.</i> <br><br><h3>  Configure una interfaz web para trabajar con su servidor </h3><br>  Aquí está el primer escollo, que pasó unas tres horas. <br><br>  Si instaló IPFS en un servidor externo, pero no instaló o inició IPFS localmente, cuando acceda a / webui en la interfaz web, debería ver un error de conexión: <br><br><img src="https://habrastorage.org/webt/bp/l7/jj/bpl7jjxzunvmtl9ffvvkiwphmue.png"><br><br>  El hecho es que webui, en mi opinión, funciona de manera muy ambigua.  Primero, intenta conectarse a la API del servidor donde está abierta la interfaz (por supuesto, según la dirección en el navegador).  y si no funciona allí, intenta conectarse a la puerta de enlace local.  Y si tiene IPFS ejecutándose localmente, su webui funcionará bien, solo usted trabajará con IPFS local, no externo, aunque abrió webui en un servidor externo.  Luego suba los archivos, pero por alguna razón no los ve así en un servidor externo ... <br><br>  Y si no se ejecuta localmente, obtenemos un error de conexión.  En nuestro caso, el error probablemente se deba a CORS, que también se indica mediante webui, que propone agregar una configuración. <br><br><pre> <code class="plaintext hljs">ipfs config --json API.HTTPHeaders.Access-Control-Allow-Origin '["http://ip_ :5001", "http://127.0.0.1:5001", "https://webui.ipfs.io"]' ipfs config --json API.HTTPHeaders.Access-Control-Allow-Methods '["PUT", "GET", "POST"]'</code> </pre> <br>  Acabo de registrar un comodín <br><br><pre> <code class="plaintext hljs">ipfs config --json API.HTTPHeaders.Access-Control-Allow-Origin '["*"]'</code> </pre> <br>  Los encabezados agregados se pueden encontrar en el mismo ~ / .ipfs / config.  En mi caso es <br><br><pre> <code class="plaintext hljs"> "API": { "HTTPHeaders": { "Access-Control-Allow-Origin": [ "*" ] } },</code> </pre><br>  Reiniciamos ipfs y vemos que webui se ha conectado con éxito (al menos debería hacerlo si abrió las puertas de enlace para solicitudes desde el exterior, como se describe anteriormente). <br><br>  Ahora puede cargar directamente carpetas y archivos a través de la interfaz web, así como crear sus propias carpetas. <br><br><h3>  Montar el sistema de archivos FUSE </h3><br>  Este es un truco bastante interesante. <br><br>  Podemos agregar archivos (así como carpetas) no solo a través de la interfaz web, sino también directamente en el terminal, por ejemplo <br><br><pre> <code class="plaintext hljs">ipfs add test -r added QmfYuz2gegRZNkDUDVLNa5DXzKmxxxxxxxxxx test/test.txt added QmbnzgRVAP4fL814h5mQttyqk1aURxxxxxxxxxxxx test</code> </pre><br>  El último hash es el hash de la carpeta raíz. <br><br>  Con este hash, podemos abrir la carpeta en cualquier nodo de ipfs (que puede encontrar nuestro nodo y obtener el contenido), podemos hacerlo en la interfaz web en el puerto 5001 u 8080, o podemos hacerlo localmente a través de ipfs. <br><br><pre> <code class="plaintext hljs">ipfs ls QmbnzgRVAP4fL814h5mQttyqk1aUxxxxxxxxxxxxx QmfYuz2gegRZNkDUDVLNa5DXzKmKVxxxxxxxxxxxxxx 10 test.txt</code> </pre><br>  Pero aún puede abrirlo como una carpeta normal. <br><br>  Creemos dos carpetas en la raíz y otorguemos derechos a nuestro usuario. <br><br><pre> <code class="plaintext hljs">sudo mkdir /ipfs /ipns sudo chown USERNAME /ipfs /ipns</code> </pre><br>  y reinicie ipfs con el indicador --mount <br><br><pre> <code class="plaintext hljs">ipfs daemon --mount</code> </pre> <br>  <i>Puede crear carpetas en otros lugares y especificarles la ruta a través del demonio ipfs --mount --mount-ipfs / ipfs_path --mount-ipns / ipns_path</i> <br><br>  Ahora leer de esta carpeta es algo inusual. <br><br><pre> <code class="plaintext hljs">ls -la /ipfs ls: reading directory '/ipfs': Operation not permitted total 0</code> </pre><br>  Es decir, no hay acceso directo a la raíz de esta carpeta.  Pero luego puedes obtener el contenido, conociendo el hash. <br><br><pre> <code class="plaintext hljs">ls -la /ipfs/QmbnzgRVAP4fL814h5mQttyqxxxxxxxxxxxxxxxxx total 0 -r--r--r-- 1 root root 10 Aug 31 07:03 test.txt</code> </pre><br><pre> <code class="plaintext hljs">cat /ipfs/QmbnzgRVAP4fL814h5mQttyqxxxxxxxxxxxxxxxxx/test.txt test test</code> </pre><br>  Además, incluso el autocompletado dentro de la carpeta funciona al especificar una ruta. <br><br>  Como dije anteriormente, hay sutilezas con tal montaje: de manera predeterminada, las carpetas FUSE montadas son accesibles solo para el usuario actual (incluso la raíz no puede leer desde dicha carpeta, sin mencionar a otros usuarios en el sistema).  Si desea hacer que estas carpetas sean accesibles para otros usuarios, entonces en la configuración debe cambiar "FuseAllowOther": falso a "FuseAllowOther": verdadero.  Pero eso no es todo.  Si ejecuta IPFS como root, entonces todo está bien.  Y si en nombre de un usuario normal (aunque sudo), obtiene un error <br><br><pre> <code class="plaintext hljs">mount helper error: fusermount: option allow_other only allowed if 'user_allow_other' is set in /etc/fuse.conf</code> </pre> <br>  En este caso, debe corregir /etc/fuse.conf descomentando la línea #user_allow_other. <br><br>  Después de eso reiniciamos ipfs. <br><br><h4>  Problemas conocidos con FUSE </h4><br>  Más de una vez se notó el problema de que después de reiniciar ipfs con el montaje (o tal vez en otros casos), los puntos de montaje / ipfs y / ipns dejan de estar disponibles.  No hay acceso a ellos, pero ls -la / ipfs muestra ????  en la lista de derechos. <br><br>  Encontré tal solución: <br><br><pre> <code class="plaintext hljs">fusermount -z -u /ipfs fusermount -z -u /ipns</code> </pre> <br>  Luego reinicie ipfs. <br><br><h3>  Agregar servicio </h3><br>  Por supuesto, el lanzamiento en la terminal solo es adecuado para pruebas primarias.  En modo combate, el demonio debería iniciarse automáticamente cuando se inicia el sistema. <br><br>  En nombre de sudo, cree el archivo /etc/systemd/system/ipfs.service y escríbalo: <br><br><pre> <code class="plaintext hljs">[Unit] Description=IPFS Daemon After=syslog.target network.target remote-fs.target nss-lookup.target [Service] Type=simple ExecStart=/home/USERNAME/work/bin/ipfs daemon --mount User=USERNAME Restart=always [Install] WantedBy=multi-user.target</code> </pre><br>  USERNAME, por supuesto, debe ser reemplazado por su usuario (y tal vez la ruta completa al programa ipfs será diferente para usted (debe especificar la ruta completa)). <br><br>  Activamos el servicio. <br><br><pre> <code class="plaintext hljs">sudo systemctl enable ipfs.service</code> </pre> <br>  Iniciamos el servicio. <br><br><pre> <code class="plaintext hljs">sudo service ipfs start</code> </pre> <br>  Verifique el estado del servicio. <br><br><pre> <code class="plaintext hljs">sudo service ipfs status</code> </pre> <br>  Para la pureza del experimento, será posible reiniciar el servidor en el futuro para verificar que ipfs se inicie con éxito automáticamente. <br><br><h3>  Agrega las fiestas que conocemos </h3><br>  Considere la situación cuando tenemos nodos IPFS instalados tanto en un servidor externo como localmente.  En un servidor externo, agregamos algún tipo de archivo e intentamos obtenerlo a través de IPFS localmente mediante CID.  Que va a pasar  Por supuesto, es muy probable que el servidor local no sepa nada sobre nuestro servidor externo y simplemente tratará de encontrar el archivo por CID "preguntando" a todos los pares de IPFS disponibles (con los cuales ya ha logrado "conocer").  Esos, a su vez, preguntarán a los demás.  Y así, hasta que se encuentre el archivo.  En realidad, sucede lo mismo cuando intentamos obtener el archivo a través de la puerta de enlace oficial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ipfs.io.</a>  Si tiene suerte, el archivo se encontrará en unos segundos.  Y si no, no se encontrará en unos minutos, lo que afecta en gran medida la comodidad del trabajo.  Pero sabemos dónde aparecerá este archivo por primera vez.  Entonces, ¿por qué no le decimos inmediatamente a nuestro servidor local "Mire allí primero"?  Aparentemente, esto se puede hacer. <br><br>  1. Vaya al servidor remoto y busque ~ / .ipfs / config en la configuración <br><br><pre> <code class="plaintext hljs">"Identity": { "PeerID": "QmeCWX1DD7HnPSuMHZSh6tFuxxxxxxxxxxxxxxxx",</code> </pre><br>  2. Ejecutamos el estado de sufs service ipfs y buscamos entradas de Swarm en él, por ejemplo: <br><br><pre> <code class="plaintext hljs">Swarm announcing /ip4/ip__/tcp/4001</code> </pre> <br>  3. A partir de esto, agregamos la dirección general del formulario "/ ip4 / ip_your_server / tcp / 4001 / ipfs / $ PeerID". <br><br>  4. Para mayor confiabilidad, a través de nuestro sitio web local, intentaremos agregar esta dirección a sus pares. <br><br><img src="https://habrastorage.org/webt/g5/y2/oh/g5y2ohfylmp2be51tzh0iohq1y8.png"><br><br>  5. Si todo está bien, abra la configuración local ~ / .ipfs / config, busque "Bootstrap" en ella: [... <br>  y agregue la dirección recibida primero a la matriz. <br><br>  Reinicie IPFS. <br><br>  Ahora agregue el archivo al servidor externo e intente solicitarlo en el servidor local.  Debe volar rápido. <br><br>  Pero esta funcionalidad aún es inestable.  Por lo que yo entiendo, incluso si especificamos la dirección de pares en Bootstrap, en el curso del trabajo, ipfs cambia la lista de conexiones activas con pares.  En cualquier caso, se está discutiendo esto y los deseos sobre la posibilidad de indicar pares constantes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> y parece <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">que se supone que debe</a> agregar alguna funcionalidad a ipfs@5.0+ <br><br>  Se puede ver una lista de pares actuales tanto en webui como en la terminal. <br><br><pre> <code class="plaintext hljs">ipfs swarm peers</code> </pre> <br>  Tanto allí como allí puedes agregar tu fiesta manualmente. <br><br><pre> <code class="plaintext hljs">ipfs swarm connect "/ip4/ip__/tcp/4001/ipfs/$PeerID"</code> </pre> <br>  Hasta que haya mejorado esta funcionalidad, puede escribir una herramienta para verificar una conexión con el par deseado, y si no, para agregar una conexión. <br><br><h2>  Razonamiento </h2><br>  Entre aquellos que ya están familiarizados con IPFS, existen argumentos a favor y en contra de IPFS.  En principio, anteayer la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">discusión</a> de ayer me impulsó a cavar IPFS nuevamente.  Y con respecto a la discusión mencionada anteriormente: no puedo decir que estoy firmemente en contra de algunos de los argumentos expresados ​​anteriormente (no estoy de acuerdo con el hecho de que un programa y medio usan IPFS).  En general, ambos tienen razón a su manera (especialmente los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comentarios sobre cheques</a> te hacen pensar).  Pero si descarta la evaluación moral y legal, ¿quién dará una evaluación técnica de esta tecnología?  Personalmente, tengo algún tipo de sentimiento interno de que "esto es necesario seguro, tiene ciertas perspectivas".  Pero por qué exactamente, no hay una redacción clara.  Al igual que si observa las herramientas centralizadas existentes, en muchos aspectos están muy por delante (estabilidad, velocidad, capacidad de administración, etc.).  Sin embargo, tengo un pensamiento, que parece tener sentido y que difícilmente se puede implementar sin sistemas descentralizados.  Por supuesto, realmente me muevo, pero lo formularía de esta manera: el principio de diseminar información en Internet necesita ser cambiado. <br><br>  Te lo explicaré.  Si lo cree así, ahora nuestra información se difunde según el principio "Espero que la persona a quien la transfirí la proteja y no se pierda o reciba a aquellos a quienes no estaba destinada".  Por ejemplo, es fácil considerar varios servicios de correo, almacenamiento en la nube, etc.  ¿Y qué tenemos al final?  En Habré Hub, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la seguridad de la información está</a> en la primera línea y casi todos los días recibimos noticias sobre otra fuga global.  En principio, todo lo más interesante aparece en el artículo &lt;irony&gt; maravilloso &lt;/ ironía&gt; El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">verano está por terminar.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Casi no se filtraron datos</a> .  Es decir, los principales gigantes de Internet se están volviendo más grandes, están acumulando más y más información, y esas filtraciones son una especie de explosiones atómicas informativas.  Esto nunca ha sucedido, y aquí de nuevo.  Al mismo tiempo, aunque muchos entienden que existen riesgos, continuarán confiando sus datos con compañías de terceros.  En primer lugar, no hay mucha alternativa, y en segundo lugar, prometen haber reparado todos los agujeros y esto nunca volverá a suceder. <br><br>  ¿Qué opción veo?  Me parece que los datos deberían distribuirse inicialmente abiertamente.  Pero la apertura en este caso no significa que todo deba ser fácil de leer.  Estoy hablando de la apertura del almacenamiento y la distribución, pero no de la apertura total en la lectura.  Supongo que la información debe distribuirse con claves públicas.  Después de todo, el principio de las claves públicas / privadas ya es antiguo, casi como Internet.  Si la información no es confidencial y está diseñada para un amplio rango, se presenta de inmediato con la clave pública (pero aún en forma cifrada, cualquiera puede descifrarla con la clave existente).  Y si no, se presenta sin una clave pública, y la clave misma se transmite a la que debe tener acceso a esta información.  Al mismo tiempo, el que necesita leerlo debe tener solo una clave, y dónde obtener esta información, no debe estar volando, simplemente la extrae de la red (este es el nuevo principio de distribución al contenido, no a la dirección). <br><br>  Por lo tanto, para un ataque masivo, los atacantes necesitarán obtener una gran cantidad de claves privadas, y es poco probable que puedan hacerlo en un solo lugar.  Esta tarea, según lo veo, es más difícil que hackear un servicio en particular. <br><br>  Y aquí se cierra otro problema: la confirmación de la autoría.  Ahora en Internet puedes encontrar muchas citas escritas por nuestros amigos.  ¿Pero dónde está la garantía de que los escribieron?  Ahora, si cada grabación estuviera acompañada de una firma digital, sería mucho más simple.  Y no importa dónde se encuentre esta información, lo principal es la firma, que, obviamente, es difícil de falsificar. <br><br>  Y esto es lo que es interesante aquí: IPFS ya tiene herramientas de cifrado (después de todo, está basado en la tecnología blockchain).  La clave privada se especifica inmediatamente en la configuración. <br><br><pre> <code class="plaintext hljs"> "Identity": { "PeerID": "QmeCWX1DD7HnPSuMHZSh6tFuMxxxxxxxxxxxxxx", "PrivKey": "CAASqAkwggSkAgEAAoIBAQClZedVmj8JkPvT92sGrNIQmofVF3ne8xSWZIGqkm+t9IHNN+/NDI51jA0MRzpBviM3o/c/Nuz30wo95vWToNyWzJlyAISXnUHxnVhvpeJAbaeggQRcFxO9ujO9DH61aqgN1m+JoEplHjtc4KS5 pUEDqamve+xAJO8BWt/LgeRKA70JN4hlsRSghRqNFFwjeuBkT1kB6tZsG3YmvAXJ0o2uye+y+7LMS7jKpwJNJBiFAa/Kuyu3W6PrdOe7SqrXfjOLHQ0uX1oYfcqFIKQsBNj/Fb+GJMiciJUZaAjgHoaZrrf2b/Eii3z0i+QIVG7OypXT3Z9JUS60 KKLfjtJ0nVLjAgMBAAECggEAZqSR5sbdffNSxN2TtsXDa3hq+WwjPp/908M10QQleH/3mcKv98FmGz65zjfZyHjV5C7GPp24e6elgHr3RhGbM55vT5dQscJu7SGng0of2bnzQCEw8nGD18dZWmYJsE4rUsMT3wXxhUU4s8/Zijgq27oLyxKNr9T7 2gxqPCI06VTfMiCL1wBBUP1wHdFmD/YLJwOjV/sVzbsl9HxqzgzlDtfMn/bJodcURFI1sf1e6WO+MyTc3.................</code> + / NDI51jA0MRzpBviM3o / c / Nuz30wo95vWToNyWzJlyAISXnUHxnVhvpeJAbaeggQRcFxO9ujO9DH61aqgN1m + JoEplHjtc4KS5 <code class="plaintext hljs"> "Identity": { "PeerID": "QmeCWX1DD7HnPSuMHZSh6tFuMxxxxxxxxxxxxxx", "PrivKey": "CAASqAkwggSkAgEAAoIBAQClZedVmj8JkPvT92sGrNIQmofVF3ne8xSWZIGqkm+t9IHNN+/NDI51jA0MRzpBviM3o/c/Nuz30wo95vWToNyWzJlyAISXnUHxnVhvpeJAbaeggQRcFxO9ujO9DH61aqgN1m+JoEplHjtc4KS5 pUEDqamve+xAJO8BWt/LgeRKA70JN4hlsRSghRqNFFwjeuBkT1kB6tZsG3YmvAXJ0o2uye+y+7LMS7jKpwJNJBiFAa/Kuyu3W6PrdOe7SqrXfjOLHQ0uX1oYfcqFIKQsBNj/Fb+GJMiciJUZaAjgHoaZrrf2b/Eii3z0i+QIVG7OypXT3Z9JUS60 KKLfjtJ0nVLjAgMBAAECggEAZqSR5sbdffNSxN2TtsXDa3hq+WwjPp/908M10QQleH/3mcKv98FmGz65zjfZyHjV5C7GPp24e6elgHr3RhGbM55vT5dQscJu7SGng0of2bnzQCEw8nGD18dZWmYJsE4rUsMT3wXxhUU4s8/Zijgq27oLyxKNr9T7 2gxqPCI06VTfMiCL1wBBUP1wHdFmD/YLJwOjV/sVzbsl9HxqzgzlDtfMn/bJodcURFI1sf1e6WO+MyTc3.................</code> 7LMS7jKpwJNJBiFAa / Kuyu3W6PrdOe7SqrXfjOLHQ0uX1oYfcqFIKQsBNj / Fb + GJMiciJUZaAjgHoaZrrf2b / Eii3z0i + QIVG7OypXT3Z9JUS60 <code class="plaintext hljs"> "Identity": { "PeerID": "QmeCWX1DD7HnPSuMHZSh6tFuMxxxxxxxxxxxxxx", "PrivKey": "CAASqAkwggSkAgEAAoIBAQClZedVmj8JkPvT92sGrNIQmofVF3ne8xSWZIGqkm+t9IHNN+/NDI51jA0MRzpBviM3o/c/Nuz30wo95vWToNyWzJlyAISXnUHxnVhvpeJAbaeggQRcFxO9ujO9DH61aqgN1m+JoEplHjtc4KS5 pUEDqamve+xAJO8BWt/LgeRKA70JN4hlsRSghRqNFFwjeuBkT1kB6tZsG3YmvAXJ0o2uye+y+7LMS7jKpwJNJBiFAa/Kuyu3W6PrdOe7SqrXfjOLHQ0uX1oYfcqFIKQsBNj/Fb+GJMiciJUZaAjgHoaZrrf2b/Eii3z0i+QIVG7OypXT3Z9JUS60 KKLfjtJ0nVLjAgMBAAECggEAZqSR5sbdffNSxN2TtsXDa3hq+WwjPp/908M10QQleH/3mcKv98FmGz65zjfZyHjV5C7GPp24e6elgHr3RhGbM55vT5dQscJu7SGng0of2bnzQCEw8nGD18dZWmYJsE4rUsMT3wXxhUU4s8/Zijgq27oLyxKNr9T7 2gxqPCI06VTfMiCL1wBBUP1wHdFmD/YLJwOjV/sVzbsl9HxqzgzlDtfMn/bJodcURFI1sf1e6WO+MyTc3.................</code> Zijgq27oLyxKNr9T7 <code class="plaintext hljs"> "Identity": { "PeerID": "QmeCWX1DD7HnPSuMHZSh6tFuMxxxxxxxxxxxxxx", "PrivKey": "CAASqAkwggSkAgEAAoIBAQClZedVmj8JkPvT92sGrNIQmofVF3ne8xSWZIGqkm+t9IHNN+/NDI51jA0MRzpBviM3o/c/Nuz30wo95vWToNyWzJlyAISXnUHxnVhvpeJAbaeggQRcFxO9ujO9DH61aqgN1m+JoEplHjtc4KS5 pUEDqamve+xAJO8BWt/LgeRKA70JN4hlsRSghRqNFFwjeuBkT1kB6tZsG3YmvAXJ0o2uye+y+7LMS7jKpwJNJBiFAa/Kuyu3W6PrdOe7SqrXfjOLHQ0uX1oYfcqFIKQsBNj/Fb+GJMiciJUZaAjgHoaZrrf2b/Eii3z0i+QIVG7OypXT3Z9JUS60 KKLfjtJ0nVLjAgMBAAECggEAZqSR5sbdffNSxN2TtsXDa3hq+WwjPp/908M10QQleH/3mcKv98FmGz65zjfZyHjV5C7GPp24e6elgHr3RhGbM55vT5dQscJu7SGng0of2bnzQCEw8nGD18dZWmYJsE4rUsMT3wXxhUU4s8/Zijgq27oLyxKNr9T7 2gxqPCI06VTfMiCL1wBBUP1wHdFmD/YLJwOjV/sVzbsl9HxqzgzlDtfMn/bJodcURFI1sf1e6WO+MyTc3.................</code> </pre> <br>  No soy un especialista en seguridad y no puedo saber exactamente cómo usarlo correctamente, pero me parece que estas claves se usan a nivel de intercambio entre nodos IPFS.  Y también <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">js-ipfs</a> y proyectos de ejemplo como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">orbit-db</a> , en el que funciona <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">orbit.chat</a> .  Es decir, en teoría, cada dispositivo (móvil y no solo) puede equiparse fácilmente con sus propias máquinas de cifrado-descifrado.  En este caso, solo queda que todos se encarguen de mantener sus claves privadas y todos serán responsables de su propia seguridad, y no serán rehenes de otro factor humano en algún gigante de Internet súper popular. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/465599/">https://habr.com/ru/post/465599/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../465587/index.html">Análisis: qué es el mercado OTC y qué transacciones se realizan allí</a></li>
<li><a href="../465589/index.html">Guía de inicio rápido de Pilot y PoC</a></li>
<li><a href="../465591/index.html">La conferencia PHP de Europa Central se canceló debido al hecho de que no había mujeres entre los oradores</a></li>
<li><a href="../465595/index.html">5G viene a nosotros?</a></li>
<li><a href="../465597/index.html">Aprendizaje STM8S Inicio lento. Parte 0</a></li>
<li><a href="../465601/index.html">¿Por qué necesita DevOps y quiénes son especialistas en DevOps?</a></li>
<li><a href="../465603/index.html">Cursos vs prácticas. ¿Cómo enseñamos midbells en SimbirSoft?</a></li>
<li><a href="../465605/index.html">El libro "Aprendizaje de refuerzo profundo en Python. OpenAI Gym y TensorFlow para profesionales »</a></li>
<li><a href="../465607/index.html">Comprensión de Lean y Agile en el desarrollo de software</a></li>
<li><a href="../465609/index.html">Por qué 1C-Bitrix del 1 de diciembre de 2019 puede convertirse en una calabaza</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>