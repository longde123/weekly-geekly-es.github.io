<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤½ğŸ½ ğŸ‘¨ğŸ»â€ğŸ”§ ğŸ“² Merender font menggunakan masker cakupan, bagian 1 ğŸ® ğŸ§  ğŸ‘©ğŸ¿â€âš•ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ketika kami mulai mengembangkan profiler kinerja kami, kami tahu bahwa kami akan melakukan hampir semua rendering UI sendiri. Segera kami harus memutu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Merender font menggunakan masker cakupan, bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433670/"><div style="text-align:center;"><img width="310" height="458" src="https://habrastorage.org/getpro/habr/post_images/a00/1c5/f74/a001c5f74ba839b1e77da01aadac6912.png" alt="gambar"></div><br>  Ketika kami mulai mengembangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">profiler kinerja</a> kami, kami tahu bahwa kami akan melakukan hampir semua rendering UI sendiri.  Segera kami harus memutuskan pendekatan mana yang akan dipilih untuk rendering font.  Kami memiliki persyaratan berikut: <br><br><ol><li>  Kita harus dapat me-render font apa pun dalam ukuran apa pun secara waktu nyata untuk beradaptasi dengan font sistem dan ukurannya yang dipilih oleh pengguna Windows. </li><li>  Rendering font harus sangat cepat, tidak ada pengereman saat rendering font diizinkan. </li><li>  UI kami memiliki banyak animasi yang halus, sehingga teks harus dapat bergerak dengan lancar di sekitar layar. </li><li>  Ini harus dapat dibaca dengan ukuran font kecil. </li></ol><br>  Tidak menjadi spesialis hebat pada waktu itu, saya mencari informasi di Internet dan menemukan banyak teknik yang digunakan untuk membuat font.  Saya juga berbicara dengan Direktur Teknis Permainan Gerilya Michail van der Leu.  Perusahaan ini bereksperimen dengan banyak cara untuk merender font, dan mesin rendering mereka adalah salah satu yang terbaik di dunia.  Mihil secara singkat menguraikan idenya untuk teknik rendering font baru.  Meskipun kami sudah memiliki cukup teknik yang sudah tersedia, ide ini menggelitik saya dan saya mulai menerapkannya, tidak memperhatikan dunia indah rendering font yang terbuka untuk saya. <br><a name="habracut"></a><br>  Dalam seri artikel ini, saya akan menjelaskan secara rinci teknik yang kami gunakan, membagi deskripsi menjadi tiga bagian: <br><br><ul><li>  Pada bagian <strong>pertama,</strong> kita akan belajar cara membuat mesin terbang secara real time menggunakan 16xAA, disampel dari grid yang seragam. </li><li>  Pada bagian <strong>kedua,</strong> kita akan beralih ke grid yang diputar untuk melakukan antialiasing tepi horizontal dan vertikal dengan indah.  Kita juga akan melihat bagaimana shader jadi hampir sepenuhnya dikurangi menjadi satu tekstur dan tabel pencarian. </li><li>  Pada bagian <strong>ketiga,</strong> kita akan belajar cara meraster mesin terbang secara real time menggunakan Compute dan CPU. </li></ul><br>  Anda juga dapat melihat hasil yang selesai di profiler, tetapi di sini adalah contoh layar dengan font Segoe UI yang dirender menggunakan font renderer kami: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/518/faf/57f/518faf57f2f977406e864ddbd939af6b.png"></div><br>  Inilah peningkatan huruf S, ukuran raster hanya 6x9 texels.  Data vektor asli dirender sebagai lintasan, dan pola sampel yang diputar dirender dari persegi panjang hijau dan merah.  Karena ini diberikan dengan resolusi yang jauh lebih besar dari 6 Ã— 9, warna abu-abu tidak terwakili dalam rona akhir piksel, ini menampilkan rona subpixel.  Ini adalah visualisasi debugging yang sangat berguna untuk memastikan bahwa semua perhitungan di tingkat subpixel berfungsi dengan benar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba1/aa9/5b3/ba1aa95b30f977d242d90994416b8ef8.png"></div><br><h1>  Ide: menyimpan pelapis alih-alih warna </h1><br>  Masalah utama yang perlu ditangani oleh penyaji font adalah menampilkan data font vektor yang dapat diskalakan dalam kotak piksel tetap.  Metode transisi dari ruang vektor ke piksel jadi dalam teknik yang berbeda sangat berbeda.  Dalam sebagian besar teknik ini, data kurva dirasterisasi sebelum dirender ke penyimpanan sementara (misalnya, tekstur) untuk mendapatkan ukuran tertentu dalam piksel.  Penyimpanan sementara digunakan sebagai cache mesin terbang: ketika mesin terbang yang sama diberikan beberapa kali, mesin terbang diambil dari cache dan digunakan kembali untuk menghindari rasterisasi lagi. <br><br>  Perbedaan dalam teknik terlihat jelas dalam bagaimana data disimpan dalam format data menengah.  Sebagai contoh, sistem font Windows rasterisasi mesin terbang ke ukuran tertentu dalam piksel.  Data disimpan sebagai <strong>rona</strong> per piksel.  Bayangan menggambarkan perkiraan terbaik dari cakupan oleh mesin terbang pixel ini.  Saat merender, piksel disalin dari cache mesin terbang ke grid piksel target.  Ketika mengkonversi data ke format piksel, mereka tidak skala dengan baik, oleh karena itu, ketika memperkecil, fuzzy glyph muncul, dan ketika memperbesar, glyph muncul di mana blok terlihat jelas.  Oleh karena itu, untuk setiap ukuran akhir, mesin terbang dirender ke dalam cache mesin terbang. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bidang Jarak Jauh yang Ditandatangani</a> menggunakan pendekatan yang berbeda.  Alih-alih rona untuk piksel, <strong>jarak</strong> ke tepi terdekat mesin terbang dipertahankan.  Keuntungan dari metode ini adalah bahwa untuk tepi melengkung, skala data jauh lebih baik daripada nuansa.  Saat mesin terbang memperbesar, kurva tetap halus.  Kelemahan dari pendekatan ini adalah tepi yang lurus dan tajam dihaluskan.  Jauh lebih baik daripada SDF dicapai oleh solusi canggih seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FreeType</a> , yang menyimpan data warna. <br><br>  Dalam kasus di mana rona dipertahankan untuk piksel, Anda harus terlebih dahulu menghitung cakupannya.  Sebagai contoh, stb_truetype memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh yang</a> baik tentang bagaimana Anda dapat menghitung cakupan dan rona.  Cara populer lainnya untuk memperkirakan cakupan adalah dengan sampel mesin terbang pada frekuensi yang lebih tinggi daripada resolusi akhir.  Ini menghitung jumlah sampel yang sesuai dengan mesin terbang di area piksel target.  Jumlah hit dibagi dengan jumlah sampel maksimum yang mungkin menentukan rona.  Karena cakupan telah dikonversi ke rona untuk resolusi dan <strong>penyejajaran</strong> grid piksel tertentu, mustahil untuk menempatkan mesin terbang di antara piksel target: rona tidak akan dapat dengan benar mencerminkan cakupan yang sebenarnya dengan sampel dari jendela piksel target.  Untuk ini, serta beberapa alasan lain yang akan kami pertimbangkan nanti, sistem seperti itu tidak mendukung gerakan subpixel. <br><br>  Tetapi bagaimana jika kita perlu dengan bebas memindahkan mesin terbang antar piksel?  Jika rona dihitung terlebih dahulu, kami tidak dapat menemukan apa rona yang seharusnya ketika bergerak di antara piksel di area piksel target.  Namun, kami dapat menunda konversi dari cakupan ke rona pada saat render.  Untuk melakukan ini, kami tidak akan menyimpan tempat teduh, tetapi <strong>lapisan</strong> .  Kami mencicipi mesin terbang dengan frekuensi 16 resolusi target, dan untuk setiap sampel kami menyimpan sedikit pun.  Saat mengambil sampel pada kisi 4 Ã— 4, cukup untuk menyimpan hanya 16 bit per piksel.  Ini akan menjadi <strong>topeng penutup</strong> kami.  Selama rendering, kita perlu menghitung berapa banyak bit yang masuk ke jendela target pixel, yang memiliki resolusi yang sama dengan repositori texel, tetapi secara fisik tidak melekat padanya.  Animasi di bawah ini menunjukkan sebagian mesin terbang (biru) yang dirasterisasi dalam empat texels.  Setiap texel dibagi menjadi kotak 4 Ã— 4 sel.  Kotak abu-abu menunjukkan jendela piksel yang bergerak dinamis melintasi mesin terbang.  Pada waktu berjalan, jumlah sampel yang jatuh ke dalam jendela piksel dihitung untuk menentukan rona. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f79/6d3/dca/f796d3dcaf7c4b1763ff8ee5621c09c9.gif"></div><br><h2>  Secara singkat tentang teknik rendering font dasar </h2><br>  Sebelum beralih ke membahas implementasi sistem rendering font kami, saya ingin secara singkat berbicara tentang teknik utama yang digunakan dalam proses ini: font hinting dan rendering subpixel (teknik ini disebut ClearType pada Windows).  Anda dapat melewati bagian ini jika Anda hanya tertarik pada teknik antialiasing. <br><br>  Dalam proses penerapan renderer, saya belajar lebih banyak tentang sejarah panjang pengembangan rendering font.  Penelitian berfokus sepenuhnya pada satu-satunya aspek rendering font - keterbacaan pada ukuran kecil.  Membuat penyaji yang sangat baik untuk font besar cukup sederhana, tetapi sangat sulit untuk menulis sistem yang mempertahankan keterbacaan pada ukuran kecil.  Studi rendering font memiliki sejarah yang panjang, sangat mencolok.  Baca, misalnya, tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tragedi raster</a> .  Adalah logis bahwa ini adalah masalah utama bagi spesialis komputer, karena pada tahap awal komputer, resolusi layarnya cukup rendah.  Ini pasti salah satu tugas pertama yang harus dihadapi pengembang OS: bagaimana membuat teks dapat dibaca pada perangkat dengan resolusi layar rendah?  Yang mengejutkan saya, sistem rendering font berkualitas tinggi sangat berorientasi pixel.  Misalnya, mesin terbang dibangun sedemikian rupa sehingga mulai di perbatasan piksel, lebarnya adalah kelipatan dari jumlah piksel, dan konten disesuaikan agar sesuai dengan piksel.  Teknik ini disebut meshing.  Saya sudah terbiasa bekerja dengan permainan komputer dan grafik 3D, di mana dunia dibangun dari unit dan diproyeksikan ke piksel, jadi saya sedikit terkejut.  Saya menemukan bahwa di bidang rendering font ini adalah pilihan yang sangat penting. <br><br>  Untuk menunjukkan pentingnya menghubungkan, mari kita lihat skenario yang mungkin untuk rasterisasi mesin terbang.  Bayangkan bahwa mesin terbang dirasterisasi pada grid pixel, tetapi bentuk mesin terbang tidak cocok dengan struktur grid: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c2/b4f/aa1/2c2b4faa132766685d630964d582d9dd.png"></div><br>  Antialiasing akan membuat piksel di kanan dan kiri mesin terbang menjadi sama abu-abu.  Jika mesin terbang sedikit bergeser sehingga lebih cocok dengan batas piksel, maka hanya satu piksel yang akan diwarnai, dan itu akan menjadi benar-benar hitam: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b5/c63/1b0/9b5c631b00fcdcfcd2a3a36f06ab9d2d.png"></div><br>  Sekarang mesin terbang cocok dengan piksel dengan baik, warnanya menjadi kurang buram.  Perbedaan ketajamannya sangat besar.  Font barat memiliki banyak mesin terbang dengan garis-garis horizontal dan vertikal, dan jika mereka tidak cocok dengan grid pixel dengan baik, nuansa abu-abu membuat font menjadi buram.  Bahkan teknik anti-aliasing terbaik tidak mampu mengatasi masalah ini. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Petunjuk font</a> diusulkan sebagai solusi.  Pembuat font harus menambahkan informasi ke font mereka tentang bagaimana mesin terbang harus snap ke piksel jika mereka tidak cocok dengan sempurna.  Sistem rendering font mendistorsi kurva ini untuk memasangnya ke grid pixel.  Ini sangat meningkatkan kejelasan font, tetapi harus dibayar: <br><br><ul><li>  Font menjadi sedikit <em>terdistorsi</em> .  Font tidak terlihat persis seperti yang dimaksudkan. </li><li>  Semua mesin terbang harus dilampirkan ke grid piksel: awal mesin terbang dan lebar mesin terbang.  Oleh karena itu, mustahil untuk menghidupkannya di antara piksel. </li></ul><br>  Menariknya, dalam menyelesaikan masalah ini, Apple dan Microsoft melakukan berbagai cara.  Microsoft mematuhi kejelasan absolut, dan Apple berupaya menampilkan font dengan lebih akurat.  Di Internet Anda dapat menemukan orang-orang mengeluh tentang font yang buram pada mesin Apple, tetapi banyak orang menyukai apa yang mereka lihat di Apple.  Itu sebagian soal selera.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ini adalah</a> tulisan Joel di Perangkat Lunak, dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini adalah</a> tulisan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peter Bilak</a> tentang topik ini, tetapi jika Anda mencari di internet, Anda dapat menemukan lebih banyak informasi. <br><br>  Karena resolusi DPI di layar modern meningkat dengan cepat, muncul pertanyaan apakah pengisyaratkan font akan diperlukan di masa depan, seperti sekarang ini.  Dalam kondisi saya saat ini, saya menemukan font yang mengisyaratkan teknik yang sangat berharga untuk rendering font dengan jelas.  Namun, teknik yang dijelaskan dalam artikel saya dapat menjadi alternatif yang menarik di masa depan, karena mesin terbang dapat dengan bebas ditempatkan di atas kanvas tanpa distorsi.  Dan karena ini pada dasarnya adalah teknik anti-aliasing, itu dapat digunakan untuk tujuan apa pun, dan tidak hanya untuk rendering font. <br><br>  Akhirnya, saya akan berbicara singkat tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rendering subpixel</a> .  Di masa lalu, orang menyadari bahwa Anda dapat melipattigakan resolusi horizontal layar dengan menggunakan sinar monitor komputer merah, hijau, dan biru.  Setiap piksel dibangun dari sinar-sinar ini, yang secara fisik terpisah.  Mata kita mencampurkan nilainya, menciptakan warna piksel tunggal.  Ketika mesin terbang hanya mencakup sebagian dari pixel, maka hanya balok yang ditumpangkan pada mesin terbang dihidupkan, yang tiga kali lipat resolusi horizontal.  Jika Anda memperbesar gambar layar menggunakan teknik seperti ClearType, Anda dapat melihat warna di sekitar tepi mesin terbang: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fff/998/d3e/fff998d3e0cc29ff6abe7b18a0725e61.png"></div><br>  Menariknya, pendekatan yang akan saya bahas dalam artikel ini dapat diperluas ke rendering sub-pixel.  Saya sudah mengimplementasikan prototipe-nya.  Satu-satunya kelemahan adalah bahwa karena penambahan pemfilteran dalam teknik seperti ClearType, kita perlu mengambil lebih banyak sampel tekstur.  Mungkin saya akan mempertimbangkan ini di masa depan. <br><br><h1>  Rendering mesin terbang menggunakan grid seragam </h1><br>  Misalkan kita mengambil sampel mesin terbang dengan resolusi 16 kali target dan menyimpannya dalam tekstur.  Saya akan menjelaskan bagaimana ini dilakukan di bagian ketiga artikel.  Pola pengambilan sampel adalah kisi yang seragam, yaitu, 16 titik pengambilan sampel didistribusikan secara merata di atas texel.  Setiap mesin terbang diberikan dengan resolusi yang sama dengan resolusi target, kami menyimpan 16 bit per texel, dan masing-masing bit sesuai dengan sampel.  Seperti yang akan kita lihat dalam proses penghitungan masker cakupan, urutan penyimpanan sampel adalah penting.  Secara umum, titik pengambilan sampel dan posisi mereka untuk satu texel terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7b/b2c/7f4/a7bb2c7f477e44883b531d2bae004058.png"></div><br><h2>  Mendapatkan texels </h2><br>  Kami akan menggeser jendela piksel dengan bit cakupan yang tersimpan di texels.  Kita perlu menjawab pertanyaan berikut: berapa banyak sampel yang akan masuk ke jendela piksel kita?  Diilustrasikan oleh gambar berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/027/d8f/bf0/027d8fbf08ed742fa9d5c529778f91a3.png"></div><br>  Di sini kita melihat empat texels, di mana mesin terbang sebagian overlay.  Satu piksel (ditunjukkan dengan warna biru) mencakup bagian dari texels.  Kita perlu menentukan berapa banyak sampel yang dilewati jendela piksel kita.  Pertama kita perlu yang berikut ini: <br><br><ul><li>  Hitung posisi relatif dari jendela piksel dibandingkan dengan 4 texels. </li><li>  Dapatkan texels yang berpotongan dengan jendela piksel kami. </li></ul><br>  Implementasi kami didasarkan pada OpenGL, jadi asal ruang tekstur dimulai dari kiri bawah.  Mari kita mulai dengan menghitung posisi relatif dari jendela piksel.  Koordinat UV yang diteruskan ke pixel shader adalah koordinat UV dari pusat piksel.  Dengan asumsi bahwa UV dinormalisasi, pertama-tama kita dapat mengkonversi UV ke ruang texel dengan mengalikannya dengan ukuran tekstur.  Mengurangkan 0,5 dari pusat piksel, kita mendapatkan sudut kiri bawah dari jendela piksel.  Dengan membulatkan nilai ini ke bawah, kami menghitung posisi kiri bawah dari texel kiri bawah.  Gambar menunjukkan contoh dari tiga titik ini dalam ruang texel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82b/437/a14/82b437a149bdf438c840e6d7a61695ba.png"></div><br>  Perbedaan antara sudut kiri bawah piksel dan sudut kiri bawah texel grid adalah posisi relatif dari jendela piksel dalam koordinat yang dinormalisasi.  Pada gambar ini, posisi jendela piksel adalah [0,69, 0,37].  Dalam kode: <br><br> <code>vec2 bottomLeftPixelPos = uv * size -0.5; <br> vec2 bottomLeftTexelPos = floor(bottomLeftPixelPos); <br> vec2 weigth = bottomLeftPixelPos - bottomLeftTexelPos;</code> <br> <br>  Dengan menggunakan petunjuk textGather, kita bisa mendapatkan empat texels sekaligus.  Ini hanya tersedia di OpenGL 4.0 dan lebih tinggi, sehingga Anda dapat menjalankan empat texelFetch sebagai gantinya.  Jika kita baru saja melewati tekstur. Kumpulkan koordinat UV, maka dengan kecocokan sempurna dari jendela piksel dengan texel, masalah akan muncul: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d19/f39/8ab/d19f398abc0e3f871f186fec042975cf.png"></div><br>  Di sini kita melihat tiga texel horizontal dengan jendela pixel (diperlihatkan dengan warna biru) persis cocok dengan texel pusat.  Berat yang dihitung mendekati 1.0, tetapi teksturTujuan memilih texels tengah dan kanan sebagai gantinya.  Alasannya adalah bahwa perhitungan yang dilakukan oleh tekstur Mengumpulkan mungkin sedikit berbeda dari perhitungan berat floating point.  Perbedaan dalam pembulatan perhitungan GPU dan perhitungan bobot titik mengambang menghasilkan gangguan di sekitar pusat piksel. <br><br>  Untuk mengatasi masalah ini, Anda harus memastikan bahwa perhitungan berat dijamin agar sesuai dengan sampling teksturGather.  Untuk melakukan ini, kami tidak akan pernah mencicipi pusat piksel, dan sebagai gantinya, kami akan selalu mengambil sampel di tengah kisi texel 2 Ã— 2.  Dari posisi bawah texel kiri yang dihitung dan sudah dibulatkan ke bawah, kami menambahkan texel penuh untuk sampai ke pusat kisi texel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f4a/34c/730/f4a34c7308653a6b1f19d429adb11bf4.png"></div><br>  Gambar ini menunjukkan bahwa menggunakan pusat grid texel, empat titik pengambilan sampel yang diambil oleh teksturGather akan selalu berada di tengah texel.  Dalam kode: <br><br> <code>vec2 centerTexelPos = (bottomLeftTexelPos + vec2(1.0, 1.0)) / size; <br> uvec4 result = textureGather(fontSampler, centerTexelPos, 0);</code> <br> <br><h2>  Masker horizontal jendela piksel </h2><br>  Kami mendapat empat texels dan bersama-sama mereka membentuk grid 8 Ã— 8 bit cakupan.  Untuk menghitung bit dalam jendela piksel, pertama-tama kita perlu mengatur ulang bit di luar jendela piksel.  Untuk melakukan ini, kita akan membuat window mask pixel dan melakukan bitwise AND antara mask pixel dan mask cakupan texel.  Masker horisontal dan vertikal dilakukan secara terpisah. <br><br>  Topeng pixel horisontal harus bergerak bersama dengan berat horisontal, seperti yang ditunjukkan dalam animasi ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c08/6e0/195/c086e01955d3c85a93bd655bddff089d.gif"></div><br>  Gambar menunjukkan topeng 8-bit dengan nilai 0x0F0 bergeser ke kanan (nol dimasukkan di sebelah kiri).  Dalam animasi, topeng dianimasikan secara linear dengan berat, tetapi dalam kenyataannya, sedikit pergeseran adalah operasi selangkah demi selangkah.  Topeng mengubah nilai ketika jendela piksel melintasi batas sampel.  Dalam animasi berikutnya, ini ditampilkan dalam kolom merah dan hijau, animasi langkah demi langkah.  Nilai hanya berubah ketika pusat sampel berpotongan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a10/cfe/946/a10cfe946385aec1041c87eef64d707f.gif"></div><br>  Agar topeng hanya bergerak di tengah sel, tetapi tidak pada tepinya, pembulatan sederhana sudah cukup: <br><br> <code>unsigned int pixelMask = 0x0F0 &gt;&gt; int(round(weight.x * 4.0));</code> <br> <br>  Sekarang kita memiliki topeng pixel dari string 8-bit penuh yang mencakup dua texels.  Jika kita memilih jenis penyimpanan yang tepat dalam cakupan 16-bit kami, ada cara untuk menggabungkan texel kiri dan kanan dan melakukan penyembunyian piksel horizontal untuk garis 8-bit penuh pada satu waktu.  Namun, ini menjadi masalah dengan masking vertikal ketika kita pindah ke grid yang diputar.  Karena itu, sebagai gantinya, kami menggabungkan satu sama lain dua texels kiri dan secara terpisah dua texels kanan untuk membuat dua topeng cakupan 32-bit.  Kami menutupi hasil kiri dan kanan secara terpisah. <br><br>  Topeng untuk texels kiri menggunakan 4 bit atas dari topeng pixel, dan masker untuk texels kanan menggunakan 4 bit yang lebih rendah.  Dalam kisi yang seragam, setiap baris memiliki mask horizontal yang sama, jadi kita bisa menyalin mask untuk setiap baris, setelah itu mask horizontal akan siap: <br><br> <code>unsigned int leftRowMask = pixelMask &gt;&gt; 4; <br> unsigned int rightRowMask = pixelMask &amp; 0xF; <br> unsigned int leftMask = (leftRowMask &lt;&lt; 12) | (leftRowMask &lt;&lt; 8) | (leftRowMask &lt;&lt; 4) | leftRowMask; <br> unsigned int rightMask = (rightRowMask &lt;&lt; 12) | (rightRowMask &lt;&lt; 8) | (rightRowMask &lt;&lt; 4) | rightRowMask;</code> <br> <br>  Untuk menutupi, kami menggabungkan dua texels kiri dan dua texels kanan, dan kemudian menutupi garis horizontal: <br><br> <code>unsigned int left = ((topLeft &amp; leftMask) &lt;&lt; 16) | (bottomLeft &amp; leftMask); <br> unsigned int right = ((topRight &amp; rightMask) &lt;&lt; 16) | (bottomRight &amp; rightMask);</code> <br> <br>  Sekarang hasilnya mungkin terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a4/c67/0a8/2a4c670a8c523334f9b01dddd790d11e.png"></div><br>  Kita sudah dapat menghitung bit dari hasil ini menggunakan instruksi bitCount.  Kita harus membaginya bukan dengan 16, tetapi oleh 32, karena setelah masking vertikal kita masih bisa memiliki 32 bit potensial, dan bukan 16. Berikut adalah render lengkap mesin terbang pada tahap ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae9/334/c6f/ae9334c6fdaedfcd4c17b75c26e4836b.png"></div><br>  Di sini kita melihat huruf S yang diperbesar yang diberikan berdasarkan data vektor asli (garis putih) dan visualisasi titik pengambilan sampel.  Jika titik berwarna hijau, maka di dalam mesin terbang, jika merah, maka tidak.  Grayscale menampilkan rona yang dihitung pada tahap ini.  Dalam proses rendering font, ada banyak kemungkinan kesalahan, mulai dari rasterisasi, metode menyimpan data dalam atlas tekstur, dan untuk menghitung rona akhir.  Visualisasi semacam itu sangat berguna untuk memvalidasi perhitungan.  Mereka sangat penting untuk men-debug artefak di tingkat sub-pixel. <br><br><h2>  Penutup vertikal </h2><br>  Sekarang kita siap untuk menutupi bit vertikal.  Untuk menutupi secara vertikal, kami menggunakan metode yang sedikit berbeda.  Untuk menghadapi pergeseran vertikal, penting untuk mengingat bagaimana kami menyimpan bit: dalam urutan yang bijaksana.  Intinya adalah empat bit paling signifikan, dan garis atas adalah empat bit paling signifikan.  Kita cukup membersihkan satu per satu, menggesernya berdasarkan posisi vertikal dari jendela piksel. <br><br>  Kami akan membuat topeng tunggal yang menutupi seluruh ketinggian dua texels.  Sebagai hasilnya, kami ingin menyimpan empat baris <strong>penuh</strong> texels dan menutupi semua yang lain, yaitu, mask akan menjadi 4 Ã— 4 bit, yang sama dengan 0xFFFF.  Berdasarkan posisi jendela piksel, kami menggeser garis bawah dan menghapus garis atas. <br><br> <code>int shiftDown = int(round(weightY * 4.0)) * 4; <br> left = (left &gt;&gt; shiftDown) &amp; 0xFFFF; <br> right = (right &gt;&gt; shiftDown) &amp; 0xFFFF;</code> <br> <br>  Akibatnya, kami juga menutupi bit vertikal di luar jendela piksel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d9e/007/90d/d9e00790d66da0f0caac1226937136dc.png"></div><br>  Sekarang cukup bagi kita untuk menghitung bit yang tersisa di texels, yang dapat dilakukan dengan operasi bitCount, kemudian bagi hasilnya dengan 16 dan dapatkan warna yang diinginkan! <br><br> <code>float shade = (bitCount(left) + bitCount(right)) / 16.0;</code> <br> <br>  Sekarang render penuh dari surat itu terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a00/1c5/f74/a001c5f74ba839b1e77da01aadac6912.png"></div><br><h1>  Dilanjutkan ... </h1><br>  Pada bagian kedua, kita akan mengambil langkah berikutnya dan melihat bagaimana Anda dapat menerapkan teknik ini ke grid yang dirotasi.  Kami akan menghitung skema ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/f7a/c09/ee0f7ac0925a10db70b9b7330a879961.png"></div><br>  Dan kita akan melihat bahwa hampir semua ini dapat dikurangi menjadi beberapa tabel. <br><br>  Terima kasih kepada Sebastian Aaltonen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">@SebAaltonen</a> ) atas bantuannya dalam menyelesaikan masalah teksturKumpulkan dan, tentu saja, kepada Michael van der Leu ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">@MvdleeuwGG</a> ) untuk ide-idenya dan percakapan yang menarik di malam hari. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433670/">https://habr.com/ru/post/id433670/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433652/index.html">5G melalui mata pengguna. Harapan dan Kekhawatiran</a></li>
<li><a href="../id433658/index.html">TI di Jerman - cara mencari pekerjaan di kota-kota besar di Jerman</a></li>
<li><a href="../id433660/index.html">Bagaimana saya berbicara di DefCamp untuk kelima kalinya</a></li>
<li><a href="../id433664/index.html">SATA SSD Enterprise di Infortrend 2-Controller Storage - Pengukuran Kinerja</a></li>
<li><a href="../id433666/index.html">Kamus Funcorp</a></li>
<li><a href="../id433672/index.html">Guys, apakah Ruby mati atau tidak?</a></li>
<li><a href="../id433674/index.html">Terowongan Uji Perusahaan Boring Dibuka Di California Malam Ini</a></li>
<li><a href="../id433676/index.html">Siapa yang menghasilkan lebih banyak uang di TI: karyawan kantor atau jarak jauh?</a></li>
<li><a href="../id433678/index.html">Crypto-hacking - jenis serangan baru di pusat data</a></li>
<li><a href="../id433680/index.html">Acara musim dingin untuk industri game di HSE dan simulator gamedev desktop</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>