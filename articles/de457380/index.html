<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé† üìö üêª Ultramodernes OpenGL. Teil 2 üõ∑ üò® üë©üèª‚Äçüè≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alles gute Laune und niedrigere Temperatur vor dem Fenster. Wie versprochen ver√∂ffentliche ich eine Fortsetzung des Artikels √ºber den Super-Duper des ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ultramodernes OpenGL. Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457380/"><img src="https://habrastorage.org/webt/ui/wu/2k/uiwu2kjzkvznzwubjaqnk7lkoz0.jpeg"><br><br>  Alles gute Laune und niedrigere Temperatur vor dem Fenster.  Wie versprochen ver√∂ffentliche ich eine Fortsetzung des Artikels √ºber den Super-Duper des modernen OpenGL.  Wer hat den ersten Teil nicht gelesen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ultramodern OpenGL.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> <br><br>  Vielleicht hast du Gl√ºck und ich kann das restliche Material in diesen Artikel schieben, das ist nicht sicher ... <br><a name="habracut"></a><br><h3>  <font color="#4682B4">Array-Textur</font> </h3><br>  Textur-Arrays wurden bereits in OpenGL 3.0 hinzugef√ºgt, aber aus irgendeinem Grund schreiben nur wenige Leute dar√ºber (Informationen werden von Masons zuverl√§ssig versteckt).  Sie alle sind mit der Programmierung vertraut und wissen, was ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Array ist</a> , obwohl ich mich besser von der anderen Seite ‚Äûn√§hern‚Äú sollte. <br><br>  Um die Anzahl der Umschaltungen zwischen Texturen und damit die Umschaltvorg√§nge zu verringern, verwenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benutzer Texturatlanten</a> (eine Textur, in der Daten f√ºr mehrere Objekte gespeichert werden).  Aber kluge Jungs von Khronos haben eine Alternative f√ºr uns entwickelt - Array-Textur.  Jetzt k√∂nnen wir Texturen als Ebenen in diesem Array speichern, dh es ist eine Alternative zu Atlanten.  Das OpenGL-Wiki hat eine etwas andere Beschreibung von Mipmaps usw., aber es scheint mir zu kompliziert ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> ). <br><br>  Die Vorteile dieses Ansatzes im Vergleich zu Atlanten bestehen darin, dass jede Schicht in Bezug auf Umh√ºllung und Mipmapping als separate Textur betrachtet wird. <br><br>  Aber zur√ºck zu unseren Widdern ... Das Texturarray hat drei Arten von Zielen: <br><br><ul><li>  GL_TEXTURE_1D_ARRAY </li><li>  GL_TEXTURE_2D_ARRAY </li><li>  GL_TEXTURE_CUBE_MAP_ARRAY </li></ul><br>  Code zum Erstellen eines Texturarrays: <br><br><pre><code class="cpp hljs">GLsizei width = <span class="hljs-number"><span class="hljs-number">512</span></span>; GLsizei height = <span class="hljs-number"><span class="hljs-number">512</span></span>; GLsizei layers = <span class="hljs-number"><span class="hljs-number">3</span></span>; glCreateTextures(GL_TEXTURE_2D_ARRAY, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;texture_array); glTextureStorage3D(texture_array, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGBA8, width, height, layers);</code> </pre> <br>  Die aufmerksamsten haben bemerkt, dass wir ein Repository f√ºr 2D-Texturen erstellen, aber aus irgendeinem Grund, wenn wir ein 3D-Array verwenden, gibt es hier keinen Fehler oder Tippfehler.  Wir speichern 2D-Texturen, aber da sie sich in ‚ÄûEbenen‚Äú befinden, erhalten wir ein 3D-Array (tats√§chlich werden Pixeldaten gespeichert, keine Texturen. Das 3D-Array enth√§lt 2D-Ebenen mit Pixeldaten). <br><br>  Hier ist es am Beispiel der 1D-Textur leicht zu verstehen.  Jede Zeile in einem 2D-Pixelarray ist eine separate 1D-Schicht.  Mipmap-Texturen k√∂nnen auch automatisch erstellt werden. <br><br>  Damit enden alle Schwierigkeiten und das Hinzuf√ºgen eines Bildes zu einer bestimmten Ebene ist ganz einfach: <br><br><pre> <code class="cpp hljs">glTextureSubImage3D(texarray, mipmap_level, offset.x, offset.y, layer, width, height, <span class="hljs-number"><span class="hljs-number">1</span></span>, GL_RGBA, GL_UNSIGNED_BYTE, pixels);</code> </pre> <br>  Bei der Verwendung von Arrays m√ºssen wir den Shader ein wenig √§ndern <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core layout (location = 0) out vec4 color; layout (location = 0) in vec2 texture_0; uniform sampler2DArray texture_array; uniform uint diffuse_layer; float getCoord(uint capacity, uint layer) { return max(0, min(float(capacity - 1), floor(float(layer) + 0.5))); } void main() { color = texture(texture_array, vec3(texture_0, getCoord(3, diffuse_layer))); }</span></span></code> </pre> <br>  Die beste Option w√§re, die gew√ºnschte Ebene au√üerhalb des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shaders</a> zu berechnen. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hierf√ºr</a> k√∂nnen wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UBO</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SSBO verwenden</a> (es wird auch zum √úbertragen von Matrizen und vielen anderen Daten verwendet, aber es ist irgendwie ein anderes Mal).  Wenn jemand nicht auf <a href="">tyk_1</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tyk_2</a> warten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kann</a> , k√∂nnen Sie lesen. <br><br>  Was die Gr√∂√üen betrifft, d. H. GL_MAX_ARRAY_TEXTURE_LAYERS, die in OpenGL 3.3 256 und in OpenGL 4.5 2048 betr√§gt. <br><br>  Es lohnt sich, etwas √ºber das Sampler-Objekt zu erz√§hlen (nicht in Bezug auf die Array-Textur, aber eine n√ºtzliche Sache) - dies ist ein Objekt, mit dem der Status einer Textureinheit angepasst wird, unabh√§ngig davon, welches Objekt derzeit an die Einheit angeh√§ngt ist.  Es hilft dabei, Sampler-Zust√§nde von einem bestimmten Texturobjekt zu trennen, wodurch die Abstraktion verbessert wird. <br><br><pre> <code class="cpp hljs">GLuint sampler_state = <span class="hljs-number"><span class="hljs-number">0</span></span>; glGenSamplers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;sampler_state); glSamplerParameteri(sampler_state, GL_TEXTURE_WRAP_S, GL_REPEAT); glSamplerParameteri(sampler_state, GL_TEXTURE_WRAP_T, GL_REPEAT); glSamplerParameteri(sampler_state, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glSamplerParameteri(sampler_state, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glSamplerParameterf(sampler_state, GL_TEXTURE_MAX_ANISOTROPY_EXT, <span class="hljs-number"><span class="hljs-number">16.0f</span></span>);</code> </pre> <br>  Ich habe gerade ein Sampler-Objekt erstellt, die lineare Filterung und die 16-fache anisotrope Filterung f√ºr jede Textureinheit aktiviert. <br><br><pre> <code class="cpp hljs">GLuint texture_unit = <span class="hljs-number"><span class="hljs-number">0</span></span>; glBindSampler(texture_unit, sampler_state);</code> </pre> <br>  Hier binden wir den Sampler einfach an die gew√ºnschte Textureinheit, und wenn er nicht mehr das gew√ºnschte Bindim 0 ist, an diese Einheit. <br><br><pre> <code class="cpp hljs">glBindSampler(texture_unit, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Wenn wir den Sampler verkn√ºpft haben, haben seine Einstellungen Vorrang vor den Einstellungen der Textureinheit.  Ergebnis: Es ist nicht erforderlich, die vorhandene Codebasis zu √§ndern, um Sampler-Objekte hinzuzuf√ºgen.  Sie k√∂nnen die Texturerstellung unver√§ndert lassen (mit ihren eigenen Sampler-Zust√§nden) und einfach Code hinzuf√ºgen, um die Sampler-Objekte zu steuern und zu verwenden. <br><br>  Wenn es Zeit ist, das Objekt zu l√∂schen, rufen wir einfach diese Funktion auf: <br><br><pre> <code class="cpp hljs">glDeleteSamplers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;sampler_state);</code> </pre> <br><h3>  <font color="#4682B4">Texturansicht</font> </h3><br>  Ich werde dies als "Texturzeiger (er ist m√∂glicherweise korrekter als der Link, ich bin xs)" √ºbersetzen, da ich die beste √úbersetzung nicht kenne. <br><br>  Was sind Hinweise aus Sicht von OpenGL? <br><br>  Alles ist sehr einfach, dies ist ein Zeiger auf die Daten einer unver√§nderlichen (n√§mlich ver√§nderlichen) Textur, wie wir im Bild unten sehen. <br><br><img src="https://habrastorage.org/webt/ul/r0/sy/ulr0syubsujlqfshyemnh6sqdoq.jpeg"><br><br>  Tats√§chlich ist dies ein Objekt, das die Texeldaten eines bestimmten Texturobjekts gemeinsam nutzt. Analog k√∂nnen wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: shared_ptr aus C ++ verwenden</a> .  Solange mindestens ein Texturzeiger vorhanden ist, wird die urspr√ºngliche Textur vom Treiber nicht entfernt. <br><br>  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wiki</a> wird ausf√ºhrlicher beschrieben und es lohnt sich, √ºber die Arten der Textur und des Ziels zu lesen (sie m√ºssen nicht √ºbereinstimmen). <br><br>  Um einen Zeiger zu erstellen, m√ºssen wir einen Texturdeskriptor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">abrufen,</a> indem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wir glGenTexture</a> aufrufen (keine Initialisierung erforderlich) und dann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">glTextureView</a> . <br><br><pre> <code class="cpp hljs">glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;texture_view); glTextureView(texture_view, GL_TEXTURE_2D, source_name, internal_format, min_level, level_count, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Texturzeiger k√∂nnen auf die N-te Ebene der Mipmap verweisen, was sehr n√ºtzlich und praktisch ist.  Zeiger k√∂nnen entweder Texturarrays, Teile von Arrays, eine bestimmte Ebene in diesem Array oder ein Ausschnitt einer 3D-Textur als 2D-Textur sein. <br><br><h3>  <font color="#4682B4">Einzelpuffer f√ºr Index und Vertex</font> </h3><br>  Nun, alles wird schnell und einfach gehen.  Fr√ºher wurde in der OpenGL-Spezifikation f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vertex Buffer Object</a> empfohlen, dass der Entwickler Vertex- und Indexdaten in verschiedene Puffer aufteilt. Jetzt ist dies jedoch nicht erforderlich (eine lange Geschichte, warum nicht). <br>  Alles, was wir tun m√ºssen, ist, die Indizes vor den Scheitelpunkten zu speichern und anzugeben, wo die Scheitelpunkte beginnen (genauer gesagt der Versatz). Dazu gibt es einen Befehl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">glVertexArrayVertexBuffer</a> <br><br>  So w√ºrden wir es machen: <br><br><pre> <code class="cpp hljs">GLint alignment = GL_NONE; glGetIntegerv(GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT, &amp;alignment); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLsizei ind_len = GLsizei(ind_buffer.size() * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">element_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLsizei vrt_len = GLsizei(vrt_buffer.size() * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">vertex_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLuint ind_len_aligned = align(ind_len, alignment); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLuint vrt_len_aligned = align(vrt_len, alignment); GLuint buffer = GL_NONE; glCreateBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;buffer); glNamedBufferStorage(buffer, ind_len_aligned + vrt_len_aligned, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, GL_DYNAMIC_STORAGE_BIT); glNamedBufferSubData(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, ind_len, ind_buffer.data()); glNamedBufferSubData(buffer, ind_len_aligned, vrt_len, vrt_buffer.data()); GLuint vao = GL_NONE; glCreateVertexArrays(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;vao); glVertexArrayVertexBuffer(vao, <span class="hljs-number"><span class="hljs-number">0</span></span>, buffer, ind_len_aligned, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">vertex_t</span></span>)); glVertexArrayElementBuffer(vao, buffer);</code> </pre> <br><br><h3>  <font color="#4682B4">Tessellation und Berechnungsschattierung</font> </h3><br>  Ich werde Ihnen nichts √ºber den Tessellation-Shader erz√§hlen, da es in Google viel Material dazu gibt (auf Russisch). Hier sind einige Lektionen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3</a> .  Wir werden den Shader f√ºr Berechnungen betrachten (bliiin, auch viel Material, werde ich Ihnen kurz sagen). <br><br>  Grafikkarten bieten den Vorteil von Grafikkarten in einer sehr gro√üen Anzahl von Kernen und sind f√ºr eine gro√üe Anzahl kleiner Aufgaben ausgelegt, die parallel ausgef√ºhrt werden k√∂nnen.  Der Berechnungs-Shader erm√∂glicht es, wie der Name schon sagt, Probleme zu l√∂sen, die nicht mit Grafiken zusammenh√§ngen (nicht erforderlich). <br><br>  Ein Bild, ich wei√ü nicht, wie ich es nennen soll (wie Streams gruppiert sind). <br><br><img src="https://habrastorage.org/webt/tw/3a/x_/tw3ax_rzsrwx5look90ggm5xehw.jpeg"><br><br>  Wof√ºr k√∂nnen wir verwenden? <br><br><ul><li>  Bildverarbeitung <ol><li>  Bl√ºte </li><li>  Kachelbasierte Algorithmen (verz√∂gerte Schattierung) </li></ol></li><li>  Simulationen <br><ol><li>  Partikel </li><li>  Wasser </li></ol></li></ul><br>  Au√üerdem sehe ich keinen Grund zum Schreiben, es gibt auch viele Informationen in Google, hier ein einfaches Anwendungsbeispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     glUseProgramStages( pipeline, GL_COMPUTE_SHADER_BIT, cs); // ,    / glBindImageTexture( 0, tex, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA8); // 80x45   (  1280720) glDispatchCompute( 80, 45, 1);</span></span></code> </pre> <br><br>  Hier ist ein Beispiel f√ºr einen leeren Compute-Shader: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 430 layout(local_size_x = 1, local_size_y = 1) in; layout(rgba32f, binding = 0) uniform image2D img_output; void main() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// base pixel color for image vec4 pixel = vec4(0.0, 0.0, 0.0, 1.0); // get index in global work group ie x,y position ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy); // // interesting stuff happens here later // // output to a specific pixel in the image imageStore(img_output, pixel_coords, pixel); }</span></span></span></span></code> </pre> <br><br>  Hier sind einige Links f√ºr einen tieferen Blick auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4</a> . <br><br><h3>  <font color="#4682B4">Pfadwiedergabe</font> </h3><br>  Dies ist eine neue (nicht neue) Erweiterung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NVidia</a> , deren Hauptziel das Vektor-2D-Rendering ist.  Wir k√∂nnen es f√ºr Texte oder Benutzeroberfl√§chen verwenden, und da die Grafiken Vektoren sind, h√§ngt es nicht von der Aufl√∂sung ab, was zweifellos ein gro√ües Plus ist und unsere Benutzeroberfl√§che wird gro√üartig aussehen. <br><br>  Das Grundkonzept ist eine Schablone, dann ein Cover (Cover im Original).  Stellen Sie die Pfadschablone ein und visualisieren Sie die Pixel. <br><br>  F√ºr die Verwaltung wird Standard-GLuint verwendet, und die Funktionen zum Erstellen und L√∂schen haben eine Standard-Namenskonvention. <br><br><pre> <code class="cpp hljs">glGenPathsNV <span class="hljs-comment"><span class="hljs-comment">//  glDeletePathsNV // </span></span></code> </pre> <br><br>  Hier ist ein wenig dar√ºber, wie wir den Weg finden k√∂nnen: <br><ul><li>  SVG oder PostScript in string'e <pre> <code class="cpp hljs">glPathStringNV</code> </pre> </li><li>  Array von Befehlen mit entsprechenden Koordinaten <pre> <code class="cpp hljs">glPathCommandsNV</code> </pre>  und zum Aktualisieren von Daten <pre> <code class="cpp hljs">glPathSubCommands, glPathCoords, glPathSubCoords</code> </pre> </li><li>  Schriftarten <pre> <code class="cpp hljs">glPathGlyphsNV, glPathGlyphRangeNV</code> </pre> </li><li>  lineare Kombinationen vorhandener Pfade (Interpolation von einem, zwei oder mehr Pfaden) <pre> <code class="cpp hljs">glCopyPathNV, glInterpolatePathsNV, glCombinePathsNV</code> </pre> </li><li>  lineare Transformation eines vorhandenen Pfades <pre> <code class="cpp hljs">glTransformPathNV</code> </pre> </li></ul><br>  Liste der Standardbefehle: <br><br><ul><li>  Verschieben nach (x, y) </li><li>  Nahweg </li><li>  Linie zu (x, y) </li><li>  quadratische Kurve (x1, y1, x2, y2) </li><li>  kubische Kurve (x1, y1, x2, y2, x3, y3) </li><li>  glatte quadratische Kurve (x, y) </li><li>  glatte kubische Kurve (x1, y1, x2, y2) </li><li>  Ellipsentrainer (rx, ry, x-Achsen-Rotation, Gro√übogen-Flagge, Sweep-Flagge, x, y) </li></ul><br>  So sieht die Pfadzeichenfolge in PostScript aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"100 180 moveto 40 10 lineto 190 120 lineto 10 120 lineto 160 10 lineto closepath‚Äù // "</span></span><span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span> moveto <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">400</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> curveto <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">400</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span> curveto closepath‚Äù <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre> <br>  Und hier in SVG: <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"M100,180 L40,10 L190,120 L10,120 L160,10 z‚Äù // "</span></span>M300 <span class="hljs-number"><span class="hljs-number">300</span></span> C <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">400</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span>,<span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">400</span></span>,<span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span>Z‚Äù <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre> <br>  Es gibt immer noch alle Arten von Br√∂tchen mit Arten von F√ºllungen, Kanten, Biegungen: <br><br><img src="https://habrastorage.org/webt/wx/uy/wv/wxuywvdg2rfuxlrrasn_hh9yzkm.jpeg"><br><br>  Ich werde hier nicht alles beschreiben, da es viel Material gibt und es einen ganzen Artikel braucht (wenn es interessant ist, werde ich es irgendwie schreiben). <br><br>  Hier ist eine Liste der Rendering-Grundelemente <br><br><ul><li>  Kubische Kurven </li><li>  Quadratische Kurven </li><li>  Linien </li><li>  Schriftzeichen </li><li>  B√∂gen </li><li>  Dash &amp; Endcap Style </li></ul><br>  Hier ist ein Code, und dann gibt es viel Text: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// SVG  glPathStringNV( pathObj, GL_PATH_FORMAT_SVG_NV, strlen(svgPathString), svgPathString); //  glStencilFillPathNV( pathObj, GL_COUNT_UP_NV, 0x1F); // //  ( ) glCoverFillPathNV( pathObj, GL_BOUNDING_BOX_NV);</span></span></code> </pre> <br>  Das ist alles. <br><br>  Es scheint mir, dass dieser Artikel weniger interessant und informativ herauskam, es war schwierig, die Hauptsache im Material herauszuarbeiten.  Wenn jemand mehr dar√ºber erfahren m√∂chte, kann ich einige NVidia-Materialien und Links zu Spezifikationen verwerfen (wenn ich mich erinnere, wo ich sie gespeichert habe).  Ich freue mich auch √ºber jede Hilfe bei der Bearbeitung des Artikels. <br><br>  Wie versprochen werde ich den folgenden Artikel √ºber die Optimierung und Reduzierung von Draw Calls schreiben.  Ich m√∂chte Sie bitten, in den Kommentaren dar√ºber zu schreiben, was Sie sonst noch lesen m√∂chten und woran Sie interessiert sind: <br><ul><li>  Ein Spiel auf cocos2d-x schreiben (nur √ºben, kein Wasser) </li><li>  √úbersetzung einer Artikelserie √ºber Vulkan </li><li>  Einige Themen zu OpenGL (Quaternionen, neue Funktionen) </li><li>  Computergrafik-Algorithmen (Beleuchtung, Raumbild-Umgebungsokklusion, Raumbildschirmreflexion) </li><li>  Ihre M√∂glichkeiten </li></ul><br><br>  Vielen Dank f√ºr Ihre Aufmerksamkeit. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457380/">https://habr.com/ru/post/de457380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457354/index.html">Datenverschleierung f√ºr Leistungstests</a></li>
<li><a href="../de457362/index.html">Promotion von RUVDS: Bereiten Sie den Server im Sommer vor</a></li>
<li><a href="../de457366/index.html">Ein Fanatiker, ein St√ºck Eisen oder ein Zuschauer - was f√ºr ein Spieler bist du?</a></li>
<li><a href="../de457374/index.html">Reduzieren Sie die Erstellungszeit Ihrer Android-Projekte</a></li>
<li><a href="../de457378/index.html">Wie id Software Wolfenstein 3D basierend auf der Technologie von Commander Keen erstellt hat</a></li>
<li><a href="../de457382/index.html">7 Gewohnheiten von Hochleistungsprogrammierern</a></li>
<li><a href="../de457386/index.html">Einf√ºhrung in virtuelle Linux-Schnittstellen: Tunnel</a></li>
<li><a href="../de457390/index.html">Madagaskar - Insel der Kontraste</a></li>
<li><a href="../de457392/index.html">Einsparungen bei der plattform√ºbergreifenden mobilen Entwicklung: Skyeng-Fallstudie</a></li>
<li><a href="../de457396/index.html">Automatisches Entsperren des Root-LUKS-Containers nach einem Hot-Boot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>