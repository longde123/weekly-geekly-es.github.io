<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëçüèº üêÇ üöµüèø Interfaz de generador de cliente basada en la base de datos de Golang üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë© üë©üèæ‚Äç‚öñÔ∏è üåõ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Generador de cliente de base de datos Golang basado en la interfaz. 





 Para trabajar con bases de datos, Golang ofrece el paquete database/sql , q...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interfaz de generador de cliente basada en la base de datos de Golang</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431984/"><p>  Generador de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cliente de</a> base de datos Golang basado en la interfaz. </p><br><p><img src="https://habrastorage.org/webt/jn/y8/f1/jny8f1pghqry-6htgynybbcufbi.png"></p><br><p> Para trabajar con bases de datos, Golang ofrece el paquete <code>database/sql</code> , que es una abstracci√≥n de la interfaz de programaci√≥n de bases de datos relacionales.  Por un lado, el paquete incluye una potente funcionalidad para administrar el grupo de conexiones, trabajar con declaraciones preparadas, transacciones y la interfaz de consulta de la base de datos.  Por otro lado, debe escribir una cantidad considerable del mismo tipo de c√≥digo en una aplicaci√≥n web para interactuar con una base de datos.  La biblioteca go-gad / sal ofrece una soluci√≥n en forma de generar el mismo tipo de c√≥digo basado en la interfaz descrita. </p><a name="habracut"></a><br><h2 id="motivation">  Motivaci√≥n </h2><br><p>  Hoy en d√≠a, hay un n√∫mero suficiente de bibliotecas que ofrecen soluciones en forma de ORM, ayudantes para generar consultas, generando ayudantes basados ‚Äã‚Äãen un esquema de base de datos. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/jmoiron/sqlx</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/go-reform/reform</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/jinzhu/gorm</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/Masterminds/squirrel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/volatiletech/sqlboiler</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/drone/sqlgen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/gocraft/dbr</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/go-gorp/gorp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/doug-martin/goqu</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/src-d/go-kallax</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/go-pg/pg</a> </li></ul><br><p>  Cuando cambi√© al idioma Golang hace varios a√±os, ya ten√≠a experiencia trabajando con bases de datos en diferentes idiomas.  Usando ORM, como ActiveRecord, y sin.  Despu√©s de pasar del amor al odio, no tener problemas para escribir algunas l√≠neas de c√≥digo adicionales, interactuar con la base de datos en Golang surgi√≥ algo as√≠ como un patr√≥n de repositorio.  Describimos la interfaz para trabajar con la base de datos, la implementamos usando db.Query, row.Scan est√°ndar.  Usar envoltorios adicionales simplemente no ten√≠a sentido, era opaco, obligar√≠a a estar alerta. </p><br><p>  El lenguaje SQL en s√≠ mismo ya es una abstracci√≥n entre su programa y los datos en el repositorio.  Siempre me pareci√≥ il√≥gico tratar de describir un esquema de datos y luego crear consultas complejas.  La estructura de respuesta en este caso es diferente del esquema de datos.  Resulta que el contrato debe describirse no a nivel del esquema de datos, sino a nivel de solicitud y respuesta.  Utilizamos este enfoque en el desarrollo web cuando describimos las estructuras de datos de las solicitudes y respuestas API.  Al acceder al servicio usando RESTful JSON o gRPC, declaramos el contrato a nivel de solicitud y respuesta usando JSON Schema o Protobuf, y no el esquema de datos de las entidades dentro de los servicios. </p><br><p>  Es decir, interactuar con la base de datos se redujo a un m√©todo similar: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> User <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { FindUser(id <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>) (*User, error) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Postgres <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { DB *sql.DB } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pg *Postgres)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*User, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resp User err := pg.DB.QueryRow(<span class="hljs-string"><span class="hljs-string">"SELECT id, name FROM users WHERE id=$1"</span></span>, id).Scan(&amp;resp.ID, &amp;resp.Name) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;resp, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HanlderFindUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s Store, id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*User, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// logic of service object user, err := s.FindUser(id) //... }</span></span></code> </pre> <br><p>  De esta manera, su programa es predecible.  Pero para ser sincero, este no es el sue√±o de un poeta.  Queremos reducir la cantidad de c√≥digo repetitivo para componer una consulta, completar estructuras de datos, usar enlace variable, etc.  Trat√© de formular una lista de requisitos que el conjunto deseado de utilidades deber√≠a satisfacer. </p><br><h2 id="requirements">  Requisitos </h2><br><ul><li>  Descripci√≥n de la interacci√≥n en forma de interfaz. </li><li>  La interfaz se describe mediante m√©todos y mensajes de solicitudes y respuestas. </li><li>  Soporte para variables vinculantes y declaraciones preparadas. </li><li>  Soporte para argumentos con nombre. </li><li>  Vinculaci√≥n de la respuesta de la base de datos a los campos de la estructura de datos del mensaje. </li><li>  Soporte para estructuras de datos at√≠picos (array, json). </li><li>  Trabajo transparente con transacciones. </li><li>  Soporte nativo para middleware. </li></ul><br><p>  Queremos abstraer la implementaci√≥n de la interacci√≥n con la base de datos utilizando la interfaz.  Esto nos permitir√° implementar algo similar a un patr√≥n de dise√±o, como un repositorio.  En el ejemplo anterior, describimos la interfaz de la Tienda.  Ahora podemos usarlo como una dependencia.  En la etapa de prueba, podemos pasar un c√≥digo auxiliar generado en base a esta interfaz, y en el producto usaremos nuestra implementaci√≥n basada en la estructura de Postgres. </p><br><p>  Cada m√©todo de interfaz describe una consulta de base de datos.  Los par√°metros de entrada y salida del m√©todo deben ser parte del contrato para la solicitud.  La cadena de consulta debe poder formatear seg√∫n los par√°metros de entrada.  Esto es especialmente cierto cuando se compilan consultas con una condici√≥n de muestreo compleja. </p><br><p>  Al compilar una consulta, queremos usar sustituci√≥n y enlace variable.  Por ejemplo, en PostgreSQL, escribe <code>$1</code> lugar de un valor y, junto con la consulta, pasa una matriz de argumentos.  El primer argumento se usar√° como el valor en la consulta convertida.  La compatibilidad con expresiones preparadas le permite no preocuparse por organizar el almacenamiento de estas mismas expresiones.  La base de datos / biblioteca sql proporciona una herramienta poderosa para soportar expresiones preparadas; en s√≠ misma se encarga del grupo de conexiones, conexiones cerradas.  Pero por parte del usuario, es necesaria una acci√≥n adicional para reutilizar la expresi√≥n preparada en la transacci√≥n. </p><br><p>  Las bases de datos, como PostgreSQL y MySQL, usan una sintaxis diferente para usar sustituciones y enlaces variables.  PostgreSQL usa el formato <code>$1</code> , <code>$2</code> , ... ¬øMySQL usa <code>?</code>  independientemente de la ubicaci√≥n del valor.  La base de datos / biblioteca sql propuso un formato universal para argumentos con nombre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://golang.org/pkg/database/sql/#NamedArg</a> .  Ejemplo de uso: </p><br><pre> <code class="go hljs">db.ExecContext(ctx, <span class="hljs-string"><span class="hljs-string">`DELETE FROM orders WHERE created_at &lt; @end`</span></span>, sql.Named(<span class="hljs-string"><span class="hljs-string">"end"</span></span>, endTime))</code> </pre> <br><p>  Es preferible utilizar el soporte para este formato en comparaci√≥n con las soluciones PostgreSQL o MySQL. </p><br><p>  La respuesta de la base de datos que procesa el controlador de software se puede representar condicionalmente de la siguiente manera: </p><br><pre> <code class="sql hljs">dev &gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> rubrics; id | created_at | title | url <span class="hljs-comment"><span class="hljs-comment">----+-------------------------+-------+------------ 1 | 2012-03-13 11:17:23.609 | Tech | technology 2 | 2015-07-21 18:05:43.412 | Style | fashion (2 rows)</span></span></code> </pre> <br><p>  Desde el punto de vista del usuario a nivel de interfaz, es conveniente describir el par√°metro de salida como una matriz de estructuras de la forma: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GetRubricsResp <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CreatedAt time.Time Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> URL <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br><p>  A continuaci√≥n, proyecte el valor de <code>id</code> en <code>resp.ID</code> y as√≠ sucesivamente.  En general, esta funcionalidad cubre la mayor√≠a de las necesidades. </p><br><p>  Al declarar mensajes a trav√©s de estructuras de datos internas, surge la pregunta de c√≥mo admitir tipos de datos no est√°ndar.  Por ejemplo, una matriz.  Si usa el controlador github.com/lib/pq cuando trabaja con PostgreSQL, puede usar funciones auxiliares como <code>pq.Array(&amp;x)</code> al pasar argumentos de consulta o escanear una respuesta.  Ejemplo de la documentaci√≥n: </p><br><pre> <code class="go hljs">db.Query(<span class="hljs-string"><span class="hljs-string">`SELECT * FROM t WHERE id = ANY($1)`</span></span>, pq.Array([]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">235</span></span>, <span class="hljs-number"><span class="hljs-number">401</span></span>})) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x []sql.NullInt64 db.QueryRow(<span class="hljs-string"><span class="hljs-string">'SELECT ARRAY[235, 401]'</span></span>).Scan(pq.Array(&amp;x))</code> </pre> <br><p>  En consecuencia, debe haber formas de preparar estructuras de datos. </p><br><p>  Al ejecutar cualquiera de los m√©todos de interfaz, se puede utilizar una conexi√≥n de base de datos en forma de un <code>*sql.DB</code>  Si necesita ejecutar varios m√©todos dentro de una sola transacci√≥n, quiero usar una funcionalidad transparente con un enfoque similar para trabajar fuera de una transacci√≥n, no pasar argumentos adicionales. </p><br><p>  Al trabajar con implementaciones de interfaz, es vital para nosotros poder incrustar el kit de herramientas.  Por ejemplo, registrar todas las solicitudes.  El kit de herramientas debe tener acceso a las variables de solicitud, error de respuesta, tiempo de ejecuci√≥n, nombre del m√©todo de interfaz. </p><br><p>  En su mayor parte, los requisitos se formularon como una sistematizaci√≥n de escenarios de bases de datos. </p><br><h2 id="solution-go-gadsal">  Soluci√≥n: go-gad / sal </h2><br><p>  Una forma de lidiar con el c√≥digo repetitivo es generarlo.  Afortunadamente, Golang tiene herramientas y ejemplos para este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://blog.golang.org/generate</a> .  El enfoque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/golang/mock</a> de GoMock se tom√≥ como una soluci√≥n arquitect√≥nica para la generaci√≥n, donde el an√°lisis de la interfaz se realiza mediante la reflexi√≥n.  Seg√∫n este enfoque, de acuerdo con los requisitos, se escribieron la utilidad salgen y la biblioteca sal, que generan c√≥digo de implementaci√≥n de interfaz y proporcionan un conjunto de funciones auxiliares. </p><br><p>  Para comenzar a usar esta soluci√≥n, es necesario describir una interfaz que describa el comportamiento de la capa de interacci√≥n con la base de datos.  Especifique la directiva <code>go:generate</code> con un conjunto de argumentos y comience la generaci√≥n.  Obtendr√° un constructor y un mont√≥n de c√≥digo repetitivo, listo para usar. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> repo <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-comment"><span class="hljs-comment">//go:generate salgen -destination=./postgres_client.go -package=dev/taxi/repo dev/taxi/repo Postgres type Postgres interface { CreateDriver(ctx context.Context, r *CreateDriverReq) error } type CreateDriverReq struct { taxi.Driver } func (r *CreateDriverReq) Query() string { return `INSERT INTO drivers(id, name) VALUES(@id, @name)` }</span></span></code> </pre> <br><h4 id="interface">  Interfaz </h4><br><p>  Todo comienza con la declaraci√≥n de la interfaz y un comando especial para la utilidad <code>go generate</code> : </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//go:generate salgen -destination=./client.go -package=github.com/go-gad/sal/examples/profile/storage github.com/go-gad/sal/examples/profile/storage Store type Store interface { ...</span></span></code> </pre> <br><p>  Aqu√≠ se describe que para nuestra interfaz de <code>Store</code> , la utilidad de consola <code>salgen</code> se llamar√° desde el paquete, con dos opciones y dos argumentos.  La primera opci√≥n <code>-destination</code> determina en qu√© archivo se escribir√° el c√≥digo generado.  La segunda opci√≥n <code>-package</code> define la ruta completa (ruta de importaci√≥n) de la biblioteca para la implementaci√≥n generada.  Los siguientes son dos argumentos.  El primero describe la ruta completa del paquete ( <code>github.com/go-gad/sal/examples/profile/storage</code> ) donde se encuentra la interfaz, el segundo indica el nombre de la interfaz en s√≠.  Tenga en cuenta que el comando para <code>go generate</code> puede ubicarse en cualquier lugar, no necesariamente al lado de la interfaz de destino. </p><br><p>  Despu√©s de ejecutar el comando <code>go generate</code> , obtenemos un constructor cuyo nombre se construye agregando el prefijo <code>New</code> al nombre de la interfaz.  El constructor toma un par√°metro requerido correspondiente a la interfaz <code>sal.QueryHandler</code> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> QueryHandler <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { QueryContext(ctx context.Context, query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, args ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) (*sql.Rows, error) ExecContext(ctx context.Context, query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, args ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) (sql.Result, error) PrepareContext(ctx context.Context, query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) (*sql.Stmt, error) }</code> </pre> <br><p>  Esta interfaz corresponde al objeto <code>*sql.DB</code> </p><br><pre> <code class="go hljs">connStr := <span class="hljs-string"><span class="hljs-string">"user=pqgotest dbname=pqgotest sslmode=verify-full"</span></span> db, err := sql.Open(<span class="hljs-string"><span class="hljs-string">"postgres"</span></span>, connStr) client := storage.NewStore(db)</code> </pre> <br><h4 id="methods">  M√©todos </h4><br><p>  Los m√©todos de interfaz determinan el conjunto de consultas de bases de datos disponibles. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { CreateAuthor(ctx context.Context, req CreateAuthorReq) (CreateAuthorResp, error) GetAuthors(ctx context.Context, req GetAuthorsReq) ([]*GetAuthorsResp, error) UpdateAuthor(ctx context.Context, req *UpdateAuthorReq) error }</code> </pre> <br><ul><li>  El n√∫mero de argumentos siempre es estrictamente dos. </li><li>  El primer argumento es el contexto. </li><li>  El segundo argumento contiene datos para variables de enlace y define la cadena de consulta. </li><li>  El primer par√°metro de salida puede ser un objeto, una matriz de objetos o estar ausente. </li><li>  El √∫ltimo par√°metro de salida es siempre un error. </li></ul><br><p>  El primer argumento es siempre el objeto <code>context.Context</code> .  Este contexto se transmitir√° al invocar la base de datos y el kit de herramientas.  El segundo argumento espera un par√°metro con el tipo base <code>struct</code> (o un puntero a <code>struct</code> ).  El par√°metro debe satisfacer la siguiente interfaz: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Queryer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Query() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br><p>  Se llamar√° al m√©todo <code>Query()</code> antes de ejecutar una consulta de base de datos.  La cadena resultante se convertir√° a un formato espec√≠fico de la base de datos.  Es decir, para PostgreSQL, <code>@end</code> se reemplazar√° con <code>$1</code> , y el valor <code>&amp;req.End</code> pasar√° a la matriz de argumentos </p><br><p>  Dependiendo de los par√°metros de salida, se determina a cu√°l de los m√©todos (Query / Exec) se llamar√°: </p><br><ul><li>  Si el primer par√°metro es del tipo base <code>struct</code> (o un puntero a <code>struct</code> ), se <code>QueryContext</code> m√©todo <code>QueryContext</code> .  Si la respuesta de la base de datos no contiene una sola fila, se <code>sql.ErrNoRows</code> error <code>sql.ErrNoRows</code> .  Es decir, el comportamiento es similar a <code>db.QueryRow</code> . </li><li>  Si el primer par√°metro es con el <code>slice</code> tipo base, se <code>QueryContext</code> m√©todo <code>QueryContext</code> .  Si la respuesta de la base de datos no contiene filas, se devolver√° una lista vac√≠a.  El tipo base del elemento de la lista debe ser <code>stuct</code> (o un puntero a una <code>struct</code> ). </li><li>  Si el par√°metro de salida es uno con el tipo de <code>error</code> , se <code>ExecContext</code> m√©todo <code>ExecContext</code> . </li></ul><br><h4 id="prepared-statements">  Declaraciones preparadas </h4><br><p>  El c√≥digo generado admite expresiones preparadas.  Las expresiones preparadas se almacenan en cach√©.  Despu√©s de la primera preparaci√≥n de la expresi√≥n, se almacena en cach√©.  La propia base de datos / biblioteca sql garantiza que las expresiones preparadas se apliquen de forma transparente a la conexi√≥n de base de datos deseada, incluido el procesamiento de conexiones cerradas.  A su vez, la biblioteca <code>go-gad/sal</code> se encarga de reutilizar la declaraci√≥n preparada en el contexto de la transacci√≥n.  Cuando se ejecuta la expresi√≥n preparada, los argumentos se pasan utilizando el enlace variable, transparente para el desarrollador. </p><br><p>  Para admitir argumentos con nombre en el lado de la biblioteca <code>go-gad/sal</code> , la solicitud se convierte en una vista adecuada para la base de datos.  Ahora hay soporte de conversi√≥n para PostgreSQL.  Los nombres de campo del objeto de consulta se utilizan para sustituir en argumentos con nombre.  Para especificar un nombre diferente en lugar del nombre del campo del objeto, debe usar la etiqueta <code>sql</code> para los campos de estructura.  Considere un ejemplo: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> DeleteOrdersRequest <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { UserID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"user_id"`</span></span> CreateAt time.Time <span class="hljs-string"><span class="hljs-string">`sql:"created_at"`</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r * DeleteOrdersRequest)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`DELETE FROM orders WHERE user_id=@user_id AND created_at&lt;@end`</span></span> }</code> </pre> <br><p>  La cadena de consulta se convertir√° y, utilizando la tabla de correspondencia y el enlace variable, se pasar√° una lista a los argumentos de ejecuci√≥n de la consulta: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// generated code: db.Query("DELETE FROM orders WHERE user_id=$1 AND created_at&lt;$2", &amp;req.UserID, &amp;req.CreatedAt)</span></span></code> </pre> <br><h4 id="map-structs-to-requests-arguments-and-response-messages">  Asignar estructuras a los argumentos de solicitud y mensajes de respuesta </h4><br><p>  La biblioteca <code>go-gad/sal</code> se encarga de asociar las l√≠neas de respuesta de la base de datos con las estructuras de respuesta, las columnas de la tabla con los campos de estructura: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GetRubricsReq <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r GetRubricReq)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`SELECT * FROM rubrics`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Rubric <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"id"`</span></span> CreateAt time.Time <span class="hljs-string"><span class="hljs-string">`sql:"created_at"`</span></span> Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"title"`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GetRubricsResp []*Rubric <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GetRubrics(ctx context.Context, req GetRubricsReq) (GetRubricsResp, error) }</code> </pre> <br><p>  Y si la respuesta de la base de datos es: </p><br><pre> <code class="sql hljs">dev &gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> rubrics; id | created_at | title <span class="hljs-comment"><span class="hljs-comment">----+-------------------------+------- 1 | 2012-03-13 11:17:23.609 | Tech 2 | 2015-07-21 18:05:43.412 | Style (2 rows)</span></span></code> </pre> <br><p>  Luego, la lista GetRubricsResp volver√° a nosotros, cuyos elementos ser√°n punteros a Rubric, donde los campos se rellenan con valores de las columnas que corresponden a los nombres de las etiquetas. </p><br><p>  Si la respuesta de la base de datos contiene columnas con el mismo nombre, los campos de estructura correspondientes se seleccionar√°n en el orden de la declaraci√≥n. </p><br><pre> <code class="sql hljs">dev &gt; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rubrics, subrubrics; id | title | id | title <span class="hljs-comment"><span class="hljs-comment">----+-------+----+---------- 1 | Tech | 3 | Politics</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Rubric <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"id"`</span></span> Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"title"`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Subrubric <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"id"`</span></span> Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"title"`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GetCategoryResp <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Rubric Subrubric }</code> </pre> <br><h4 id="non-standard-data-types">  Tipos de datos no est√°ndar </h4><br><p>  El paquete de <code>database/sql</code> proporciona soporte para tipos de datos b√°sicos (cadenas, n√∫meros).  Para procesar tipos de datos como array o json en una solicitud o respuesta, es necesario admitir las <code>sql.Scanner</code> <code>driver.Valuer</code> y <code>sql.Scanner</code> .  Las diferentes implementaciones de controladores tienen funciones auxiliares especiales.  Por ejemplo <code>lib/pq.Array</code> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://godoc.org/github.com/lib/pq#Array</a> ): </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span> { driver.Valuer sql.Scanner }</code> </pre> <br><p>  Por defecto, la biblioteca <code>go-gad/sql</code> para ver los campos de estructura </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> DeleteAuthrosReq <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Tags []<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"tags"`</span></span> }</code> </pre> <br><p>  utilizar√° el valor <code>&amp;req.Tags</code> .  Si la estructura satisface la interfaz <code>sal.ProcessRower</code> , </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ProcessRower <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { ProcessRow(rowMap RowMap) }</code> </pre> <br><p>  entonces el valor utilizado se puede ajustar </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *DeleteAuthorsReq)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessRow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rowMap sal.RowMap)</span></span></span></span> { rowMap.Set(<span class="hljs-string"><span class="hljs-string">"tags"</span></span>, pq.Array(r.Tags)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *DeleteAuthorsReq)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`DELETE FROM authors WHERE tags=ANY(@tags::UUID[])`</span></span> }</code> </pre> <br><p>  Este controlador se puede usar para argumentos de solicitud y respuesta.  En el caso de una lista en la respuesta, el m√©todo debe pertenecer al elemento de la lista. </p><br><h4 id="transactions">  Transacciones </h4><br><p>  Para admitir transacciones, la interfaz (Tienda) debe ampliarse con los siguientes m√©todos: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { BeginTx(ctx context.Context, opts *sql.TxOptions) (Store, error) sal.Txer ...</code> </pre> <br><p>  Se generar√° la implementaci√≥n de los m√©todos.  El m√©todo <code>BeginTx</code> usa la conexi√≥n desde el objeto actual <code>sal.QueryHandler</code> y abre la transacci√≥n <code>db.BeginTx(...)</code> ;  devuelve un nuevo objeto de implementaci√≥n de la interfaz de la <code>Store</code> , pero usa el objeto recibido <code>*sql.Tx</code> como <code>*sql.Tx</code> </p><br><h4 id="middleware">  Middleware </h4><br><p>  Se proporcionan ganchos para incrustar herramientas. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> BeforeQueryFunc <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, query </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, req </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context.Context, FinalizerFunc)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FinalizerFunc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, err error)</span></span></span></span></code> </pre> <br><p>  Se <code>BeforeQueryFunc</code> gancho <code>BeforeQueryFunc</code> antes de <code>db.PrepareContext</code> o <code>db.Query</code> .  Es decir, al comienzo del programa, cuando la memoria cach√© de expresiones preparada est√° vac√≠a, cuando <code>store.GetAuthors</code> llama a <code>store.GetAuthors</code> llamar√° al gancho <code>BeforeQueryFunc</code> dos veces.  El <code>BeforeQueryFunc</code> puede devolver un <code>BeforeQueryFunc</code> <code>FinalizerFunc</code> , que se llamar√° antes de salir del m√©todo de usuario, en nuestra <code>store.GetAuthors</code> casos. <code>store.GetAuthors</code> , usando <code>defer</code> . </p><br><p>  En el momento de la ejecuci√≥n de los ganchos, el contexto se llena con claves de servicio con los siguientes valores: </p><br><ul><li>  <code>ctx.Value(sal.ContextKeyTxOpened)</code> valor booleano determina si el m√©todo se llama en el contexto de la transacci√≥n o no. </li><li>  <code>ctx.Value(sal.ContextKeyOperationType)</code> , el valor de cadena del tipo de operaci√≥n, <code>"QueryRow"</code> , <code>"Query"</code> , <code>"Exec"</code> , <code>"Commit"</code> , etc. </li><li>  <code>ctx.Value(sal.ContextKeyMethodName)</code> valor de cadena del m√©todo de interfaz, como <code>"GetAuthors"</code> . </li></ul><br><p>  Como argumentos, el <code>BeforeQueryFunc</code> acepta la cadena sql de la consulta y el argumento <code>req</code> del m√©todo de consulta del usuario.  El gancho <code>FinalizerFunc</code> toma una variable <code>err</code> como argumento. </p><br><pre> <code class="go hljs">beforeHook := <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, query </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, req </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context.Context, sal.FinalizerFunc)</span></span></span></span> { start := time.Now() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ctx, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, err error)</span></span></span></span> { log.Printf( <span class="hljs-string"><span class="hljs-string">"%q &gt; Opeartion %q: %q with req %#v took [%v] inTx[%v] Error: %+v"</span></span>, ctx.Value(sal.ContextKeyMethodName), ctx.Value(sal.ContextKeyOperationType), query, req, time.Since(start), ctx.Value(sal.ContextKeyTxOpened), err, ) } } client := NewStore(db, sal.BeforeQuery(beforeHook))</code> </pre> <br><p>  Ejemplos de salida: </p><br><pre> <code class="plaintext hljs">"CreateAuthor" &gt; Opeartion "Prepare": "INSERT INTO authors (Name, Desc, CreatedAt) VALUES($1, $2, now()) RETURNING ID, CreatedAt" with req &lt;nil&gt; took [50.819¬µs] inTx[false] Error: &lt;nil&gt; "CreateAuthor" &gt; Opeartion "QueryRow": "INSERT INTO authors (Name, Desc, CreatedAt) VALUES(@Name, @Desc, now()) RETURNING ID, CreatedAt" with req bookstore.CreateAuthorReq{BaseAuthor:bookstore.BaseAuthor{Name:"foo", Desc:"Bar"}} took [150.994¬µs] inTx[false] Error: &lt;nil&gt;</code> </pre> <br><h3 id="whats-next">  Que sigue </h3><br><ul><li>  Soporte para variables de enlace y expresiones preparadas para MySQL. </li><li>  Gancho RowAppender para ajustar la respuesta. </li><li>  Devuelve el valor de <code>Exec.Result</code> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es431984/">https://habr.com/ru/post/es431984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es431972/index.html">Datos de usuario de Quora filtrados</a></li>
<li><a href="../es431974/index.html">Tumblr abandona por completo el contenido de "fresa"</a></li>
<li><a href="../es431976/index.html">D√≠a de la inform√°tica en Rusia: la historia del primer proyecto de una computadora autom√°tica</a></li>
<li><a href="../es431978/index.html">Promoci√≥n de la tienda en l√≠nea: lo que habr√° que arreglar</a></li>
<li><a href="../es431982/index.html">Digerati, Hakerazzi y colesterol en los datos: sobre la jerga inform√°tica</a></li>
<li><a href="../es431986/index.html">Fuck Up story: c√≥mo me decepcion√© en los servicios digitales para empresas y tuve mi propio negocio (bueno, casi)</a></li>
<li><a href="../es431988/index.html">Cuando el teorema se convirti√≥ en un axioma: ONYX BOOX Euclid review</a></li>
<li><a href="../es431990/index.html">Gaps ganados. Traducci√≥n de documentaci√≥n de convenciones de codificaci√≥n de Kotlin de JetBrains</a></li>
<li><a href="../es431992/index.html">Biometr√≠a: c√≥mo est√°n las cosas con nosotros y con ellos</a></li>
<li><a href="../es431994/index.html">Discusi√≥n de la licencia gratuita de PVS-Studio para proyectos alojados en GitHub</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>