<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👍🏼 🐂 🚵🏿 Interfaz de generador de cliente basada en la base de datos de Golang 👩‍❤️‍💋‍👩 👩🏾‍⚖️ 🌛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Generador de cliente de base de datos Golang basado en la interfaz. 





 Para trabajar con bases de datos, Golang ofrece el paquete database/sql , q...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interfaz de generador de cliente basada en la base de datos de Golang</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431984/"><p>  Generador de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cliente de</a> base de datos Golang basado en la interfaz. </p><br><p><img src="https://habrastorage.org/webt/jn/y8/f1/jny8f1pghqry-6htgynybbcufbi.png"></p><br><p> Para trabajar con bases de datos, Golang ofrece el paquete <code>database/sql</code> , que es una abstracción de la interfaz de programación de bases de datos relacionales.  Por un lado, el paquete incluye una potente funcionalidad para administrar el grupo de conexiones, trabajar con declaraciones preparadas, transacciones y la interfaz de consulta de la base de datos.  Por otro lado, debe escribir una cantidad considerable del mismo tipo de código en una aplicación web para interactuar con una base de datos.  La biblioteca go-gad / sal ofrece una solución en forma de generar el mismo tipo de código basado en la interfaz descrita. </p><a name="habracut"></a><br><h2 id="motivation">  Motivación </h2><br><p>  Hoy en día, hay un número suficiente de bibliotecas que ofrecen soluciones en forma de ORM, ayudantes para generar consultas, generando ayudantes basados ​​en un esquema de base de datos. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/jmoiron/sqlx</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/go-reform/reform</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/jinzhu/gorm</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/Masterminds/squirrel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/volatiletech/sqlboiler</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/drone/sqlgen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/gocraft/dbr</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/go-gorp/gorp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/doug-martin/goqu</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/src-d/go-kallax</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/go-pg/pg</a> </li></ul><br><p>  Cuando cambié al idioma Golang hace varios años, ya tenía experiencia trabajando con bases de datos en diferentes idiomas.  Usando ORM, como ActiveRecord, y sin.  Después de pasar del amor al odio, no tener problemas para escribir algunas líneas de código adicionales, interactuar con la base de datos en Golang surgió algo así como un patrón de repositorio.  Describimos la interfaz para trabajar con la base de datos, la implementamos usando db.Query, row.Scan estándar.  Usar envoltorios adicionales simplemente no tenía sentido, era opaco, obligaría a estar alerta. </p><br><p>  El lenguaje SQL en sí mismo ya es una abstracción entre su programa y los datos en el repositorio.  Siempre me pareció ilógico tratar de describir un esquema de datos y luego crear consultas complejas.  La estructura de respuesta en este caso es diferente del esquema de datos.  Resulta que el contrato debe describirse no a nivel del esquema de datos, sino a nivel de solicitud y respuesta.  Utilizamos este enfoque en el desarrollo web cuando describimos las estructuras de datos de las solicitudes y respuestas API.  Al acceder al servicio usando RESTful JSON o gRPC, declaramos el contrato a nivel de solicitud y respuesta usando JSON Schema o Protobuf, y no el esquema de datos de las entidades dentro de los servicios. </p><br><p>  Es decir, interactuar con la base de datos se redujo a un método similar: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> User <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { FindUser(id <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>) (*User, error) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Postgres <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { DB *sql.DB } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pg *Postgres)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*User, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resp User err := pg.DB.QueryRow(<span class="hljs-string"><span class="hljs-string">"SELECT id, name FROM users WHERE id=$1"</span></span>, id).Scan(&amp;resp.ID, &amp;resp.Name) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;resp, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HanlderFindUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s Store, id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*User, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// logic of service object user, err := s.FindUser(id) //... }</span></span></code> </pre> <br><p>  De esta manera, su programa es predecible.  Pero para ser sincero, este no es el sueño de un poeta.  Queremos reducir la cantidad de código repetitivo para componer una consulta, completar estructuras de datos, usar enlace variable, etc.  Traté de formular una lista de requisitos que el conjunto deseado de utilidades debería satisfacer. </p><br><h2 id="requirements">  Requisitos </h2><br><ul><li>  Descripción de la interacción en forma de interfaz. </li><li>  La interfaz se describe mediante métodos y mensajes de solicitudes y respuestas. </li><li>  Soporte para variables vinculantes y declaraciones preparadas. </li><li>  Soporte para argumentos con nombre. </li><li>  Vinculación de la respuesta de la base de datos a los campos de la estructura de datos del mensaje. </li><li>  Soporte para estructuras de datos atípicos (array, json). </li><li>  Trabajo transparente con transacciones. </li><li>  Soporte nativo para middleware. </li></ul><br><p>  Queremos abstraer la implementación de la interacción con la base de datos utilizando la interfaz.  Esto nos permitirá implementar algo similar a un patrón de diseño, como un repositorio.  En el ejemplo anterior, describimos la interfaz de la Tienda.  Ahora podemos usarlo como una dependencia.  En la etapa de prueba, podemos pasar un código auxiliar generado en base a esta interfaz, y en el producto usaremos nuestra implementación basada en la estructura de Postgres. </p><br><p>  Cada método de interfaz describe una consulta de base de datos.  Los parámetros de entrada y salida del método deben ser parte del contrato para la solicitud.  La cadena de consulta debe poder formatear según los parámetros de entrada.  Esto es especialmente cierto cuando se compilan consultas con una condición de muestreo compleja. </p><br><p>  Al compilar una consulta, queremos usar sustitución y enlace variable.  Por ejemplo, en PostgreSQL, escribe <code>$1</code> lugar de un valor y, junto con la consulta, pasa una matriz de argumentos.  El primer argumento se usará como el valor en la consulta convertida.  La compatibilidad con expresiones preparadas le permite no preocuparse por organizar el almacenamiento de estas mismas expresiones.  La base de datos / biblioteca sql proporciona una herramienta poderosa para soportar expresiones preparadas; en sí misma se encarga del grupo de conexiones, conexiones cerradas.  Pero por parte del usuario, es necesaria una acción adicional para reutilizar la expresión preparada en la transacción. </p><br><p>  Las bases de datos, como PostgreSQL y MySQL, usan una sintaxis diferente para usar sustituciones y enlaces variables.  PostgreSQL usa el formato <code>$1</code> , <code>$2</code> , ... ¿MySQL usa <code>?</code>  independientemente de la ubicación del valor.  La base de datos / biblioteca sql propuso un formato universal para argumentos con nombre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://golang.org/pkg/database/sql/#NamedArg</a> .  Ejemplo de uso: </p><br><pre> <code class="go hljs">db.ExecContext(ctx, <span class="hljs-string"><span class="hljs-string">`DELETE FROM orders WHERE created_at &lt; @end`</span></span>, sql.Named(<span class="hljs-string"><span class="hljs-string">"end"</span></span>, endTime))</code> </pre> <br><p>  Es preferible utilizar el soporte para este formato en comparación con las soluciones PostgreSQL o MySQL. </p><br><p>  La respuesta de la base de datos que procesa el controlador de software se puede representar condicionalmente de la siguiente manera: </p><br><pre> <code class="sql hljs">dev &gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> rubrics; id | created_at | title | url <span class="hljs-comment"><span class="hljs-comment">----+-------------------------+-------+------------ 1 | 2012-03-13 11:17:23.609 | Tech | technology 2 | 2015-07-21 18:05:43.412 | Style | fashion (2 rows)</span></span></code> </pre> <br><p>  Desde el punto de vista del usuario a nivel de interfaz, es conveniente describir el parámetro de salida como una matriz de estructuras de la forma: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GetRubricsResp <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CreatedAt time.Time Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> URL <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br><p>  A continuación, proyecte el valor de <code>id</code> en <code>resp.ID</code> y así sucesivamente.  En general, esta funcionalidad cubre la mayoría de las necesidades. </p><br><p>  Al declarar mensajes a través de estructuras de datos internas, surge la pregunta de cómo admitir tipos de datos no estándar.  Por ejemplo, una matriz.  Si usa el controlador github.com/lib/pq cuando trabaja con PostgreSQL, puede usar funciones auxiliares como <code>pq.Array(&amp;x)</code> al pasar argumentos de consulta o escanear una respuesta.  Ejemplo de la documentación: </p><br><pre> <code class="go hljs">db.Query(<span class="hljs-string"><span class="hljs-string">`SELECT * FROM t WHERE id = ANY($1)`</span></span>, pq.Array([]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">235</span></span>, <span class="hljs-number"><span class="hljs-number">401</span></span>})) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x []sql.NullInt64 db.QueryRow(<span class="hljs-string"><span class="hljs-string">'SELECT ARRAY[235, 401]'</span></span>).Scan(pq.Array(&amp;x))</code> </pre> <br><p>  En consecuencia, debe haber formas de preparar estructuras de datos. </p><br><p>  Al ejecutar cualquiera de los métodos de interfaz, se puede utilizar una conexión de base de datos en forma de un <code>*sql.DB</code>  Si necesita ejecutar varios métodos dentro de una sola transacción, quiero usar una funcionalidad transparente con un enfoque similar para trabajar fuera de una transacción, no pasar argumentos adicionales. </p><br><p>  Al trabajar con implementaciones de interfaz, es vital para nosotros poder incrustar el kit de herramientas.  Por ejemplo, registrar todas las solicitudes.  El kit de herramientas debe tener acceso a las variables de solicitud, error de respuesta, tiempo de ejecución, nombre del método de interfaz. </p><br><p>  En su mayor parte, los requisitos se formularon como una sistematización de escenarios de bases de datos. </p><br><h2 id="solution-go-gadsal">  Solución: go-gad / sal </h2><br><p>  Una forma de lidiar con el código repetitivo es generarlo.  Afortunadamente, Golang tiene herramientas y ejemplos para este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://blog.golang.org/generate</a> .  El enfoque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/golang/mock</a> de GoMock se tomó como una solución arquitectónica para la generación, donde el análisis de la interfaz se realiza mediante la reflexión.  Según este enfoque, de acuerdo con los requisitos, se escribieron la utilidad salgen y la biblioteca sal, que generan código de implementación de interfaz y proporcionan un conjunto de funciones auxiliares. </p><br><p>  Para comenzar a usar esta solución, es necesario describir una interfaz que describa el comportamiento de la capa de interacción con la base de datos.  Especifique la directiva <code>go:generate</code> con un conjunto de argumentos y comience la generación.  Obtendrá un constructor y un montón de código repetitivo, listo para usar. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> repo <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-comment"><span class="hljs-comment">//go:generate salgen -destination=./postgres_client.go -package=dev/taxi/repo dev/taxi/repo Postgres type Postgres interface { CreateDriver(ctx context.Context, r *CreateDriverReq) error } type CreateDriverReq struct { taxi.Driver } func (r *CreateDriverReq) Query() string { return `INSERT INTO drivers(id, name) VALUES(@id, @name)` }</span></span></code> </pre> <br><h4 id="interface">  Interfaz </h4><br><p>  Todo comienza con la declaración de la interfaz y un comando especial para la utilidad <code>go generate</code> : </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//go:generate salgen -destination=./client.go -package=github.com/go-gad/sal/examples/profile/storage github.com/go-gad/sal/examples/profile/storage Store type Store interface { ...</span></span></code> </pre> <br><p>  Aquí se describe que para nuestra interfaz de <code>Store</code> , la utilidad de consola <code>salgen</code> se llamará desde el paquete, con dos opciones y dos argumentos.  La primera opción <code>-destination</code> determina en qué archivo se escribirá el código generado.  La segunda opción <code>-package</code> define la ruta completa (ruta de importación) de la biblioteca para la implementación generada.  Los siguientes son dos argumentos.  El primero describe la ruta completa del paquete ( <code>github.com/go-gad/sal/examples/profile/storage</code> ) donde se encuentra la interfaz, el segundo indica el nombre de la interfaz en sí.  Tenga en cuenta que el comando para <code>go generate</code> puede ubicarse en cualquier lugar, no necesariamente al lado de la interfaz de destino. </p><br><p>  Después de ejecutar el comando <code>go generate</code> , obtenemos un constructor cuyo nombre se construye agregando el prefijo <code>New</code> al nombre de la interfaz.  El constructor toma un parámetro requerido correspondiente a la interfaz <code>sal.QueryHandler</code> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> QueryHandler <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { QueryContext(ctx context.Context, query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, args ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) (*sql.Rows, error) ExecContext(ctx context.Context, query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, args ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) (sql.Result, error) PrepareContext(ctx context.Context, query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) (*sql.Stmt, error) }</code> </pre> <br><p>  Esta interfaz corresponde al objeto <code>*sql.DB</code> </p><br><pre> <code class="go hljs">connStr := <span class="hljs-string"><span class="hljs-string">"user=pqgotest dbname=pqgotest sslmode=verify-full"</span></span> db, err := sql.Open(<span class="hljs-string"><span class="hljs-string">"postgres"</span></span>, connStr) client := storage.NewStore(db)</code> </pre> <br><h4 id="methods">  Métodos </h4><br><p>  Los métodos de interfaz determinan el conjunto de consultas de bases de datos disponibles. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { CreateAuthor(ctx context.Context, req CreateAuthorReq) (CreateAuthorResp, error) GetAuthors(ctx context.Context, req GetAuthorsReq) ([]*GetAuthorsResp, error) UpdateAuthor(ctx context.Context, req *UpdateAuthorReq) error }</code> </pre> <br><ul><li>  El número de argumentos siempre es estrictamente dos. </li><li>  El primer argumento es el contexto. </li><li>  El segundo argumento contiene datos para variables de enlace y define la cadena de consulta. </li><li>  El primer parámetro de salida puede ser un objeto, una matriz de objetos o estar ausente. </li><li>  El último parámetro de salida es siempre un error. </li></ul><br><p>  El primer argumento es siempre el objeto <code>context.Context</code> .  Este contexto se transmitirá al invocar la base de datos y el kit de herramientas.  El segundo argumento espera un parámetro con el tipo base <code>struct</code> (o un puntero a <code>struct</code> ).  El parámetro debe satisfacer la siguiente interfaz: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Queryer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Query() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br><p>  Se llamará al método <code>Query()</code> antes de ejecutar una consulta de base de datos.  La cadena resultante se convertirá a un formato específico de la base de datos.  Es decir, para PostgreSQL, <code>@end</code> se reemplazará con <code>$1</code> , y el valor <code>&amp;req.End</code> pasará a la matriz de argumentos </p><br><p>  Dependiendo de los parámetros de salida, se determina a cuál de los métodos (Query / Exec) se llamará: </p><br><ul><li>  Si el primer parámetro es del tipo base <code>struct</code> (o un puntero a <code>struct</code> ), se <code>QueryContext</code> método <code>QueryContext</code> .  Si la respuesta de la base de datos no contiene una sola fila, se <code>sql.ErrNoRows</code> error <code>sql.ErrNoRows</code> .  Es decir, el comportamiento es similar a <code>db.QueryRow</code> . </li><li>  Si el primer parámetro es con el <code>slice</code> tipo base, se <code>QueryContext</code> método <code>QueryContext</code> .  Si la respuesta de la base de datos no contiene filas, se devolverá una lista vacía.  El tipo base del elemento de la lista debe ser <code>stuct</code> (o un puntero a una <code>struct</code> ). </li><li>  Si el parámetro de salida es uno con el tipo de <code>error</code> , se <code>ExecContext</code> método <code>ExecContext</code> . </li></ul><br><h4 id="prepared-statements">  Declaraciones preparadas </h4><br><p>  El código generado admite expresiones preparadas.  Las expresiones preparadas se almacenan en caché.  Después de la primera preparación de la expresión, se almacena en caché.  La propia base de datos / biblioteca sql garantiza que las expresiones preparadas se apliquen de forma transparente a la conexión de base de datos deseada, incluido el procesamiento de conexiones cerradas.  A su vez, la biblioteca <code>go-gad/sal</code> se encarga de reutilizar la declaración preparada en el contexto de la transacción.  Cuando se ejecuta la expresión preparada, los argumentos se pasan utilizando el enlace variable, transparente para el desarrollador. </p><br><p>  Para admitir argumentos con nombre en el lado de la biblioteca <code>go-gad/sal</code> , la solicitud se convierte en una vista adecuada para la base de datos.  Ahora hay soporte de conversión para PostgreSQL.  Los nombres de campo del objeto de consulta se utilizan para sustituir en argumentos con nombre.  Para especificar un nombre diferente en lugar del nombre del campo del objeto, debe usar la etiqueta <code>sql</code> para los campos de estructura.  Considere un ejemplo: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> DeleteOrdersRequest <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { UserID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"user_id"`</span></span> CreateAt time.Time <span class="hljs-string"><span class="hljs-string">`sql:"created_at"`</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r * DeleteOrdersRequest)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`DELETE FROM orders WHERE user_id=@user_id AND created_at&lt;@end`</span></span> }</code> </pre> <br><p>  La cadena de consulta se convertirá y, utilizando la tabla de correspondencia y el enlace variable, se pasará una lista a los argumentos de ejecución de la consulta: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// generated code: db.Query("DELETE FROM orders WHERE user_id=$1 AND created_at&lt;$2", &amp;req.UserID, &amp;req.CreatedAt)</span></span></code> </pre> <br><h4 id="map-structs-to-requests-arguments-and-response-messages">  Asignar estructuras a los argumentos de solicitud y mensajes de respuesta </h4><br><p>  La biblioteca <code>go-gad/sal</code> se encarga de asociar las líneas de respuesta de la base de datos con las estructuras de respuesta, las columnas de la tabla con los campos de estructura: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GetRubricsReq <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r GetRubricReq)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`SELECT * FROM rubrics`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Rubric <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"id"`</span></span> CreateAt time.Time <span class="hljs-string"><span class="hljs-string">`sql:"created_at"`</span></span> Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"title"`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GetRubricsResp []*Rubric <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GetRubrics(ctx context.Context, req GetRubricsReq) (GetRubricsResp, error) }</code> </pre> <br><p>  Y si la respuesta de la base de datos es: </p><br><pre> <code class="sql hljs">dev &gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> rubrics; id | created_at | title <span class="hljs-comment"><span class="hljs-comment">----+-------------------------+------- 1 | 2012-03-13 11:17:23.609 | Tech 2 | 2015-07-21 18:05:43.412 | Style (2 rows)</span></span></code> </pre> <br><p>  Luego, la lista GetRubricsResp volverá a nosotros, cuyos elementos serán punteros a Rubric, donde los campos se rellenan con valores de las columnas que corresponden a los nombres de las etiquetas. </p><br><p>  Si la respuesta de la base de datos contiene columnas con el mismo nombre, los campos de estructura correspondientes se seleccionarán en el orden de la declaración. </p><br><pre> <code class="sql hljs">dev &gt; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rubrics, subrubrics; id | title | id | title <span class="hljs-comment"><span class="hljs-comment">----+-------+----+---------- 1 | Tech | 3 | Politics</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Rubric <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"id"`</span></span> Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"title"`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Subrubric <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"id"`</span></span> Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"title"`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GetCategoryResp <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Rubric Subrubric }</code> </pre> <br><h4 id="non-standard-data-types">  Tipos de datos no estándar </h4><br><p>  El paquete de <code>database/sql</code> proporciona soporte para tipos de datos básicos (cadenas, números).  Para procesar tipos de datos como array o json en una solicitud o respuesta, es necesario admitir las <code>sql.Scanner</code> <code>driver.Valuer</code> y <code>sql.Scanner</code> .  Las diferentes implementaciones de controladores tienen funciones auxiliares especiales.  Por ejemplo <code>lib/pq.Array</code> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://godoc.org/github.com/lib/pq#Array</a> ): </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span> { driver.Valuer sql.Scanner }</code> </pre> <br><p>  Por defecto, la biblioteca <code>go-gad/sql</code> para ver los campos de estructura </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> DeleteAuthrosReq <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Tags []<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"tags"`</span></span> }</code> </pre> <br><p>  utilizará el valor <code>&amp;req.Tags</code> .  Si la estructura satisface la interfaz <code>sal.ProcessRower</code> , </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ProcessRower <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { ProcessRow(rowMap RowMap) }</code> </pre> <br><p>  entonces el valor utilizado se puede ajustar </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *DeleteAuthorsReq)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessRow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rowMap sal.RowMap)</span></span></span></span> { rowMap.Set(<span class="hljs-string"><span class="hljs-string">"tags"</span></span>, pq.Array(r.Tags)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *DeleteAuthorsReq)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`DELETE FROM authors WHERE tags=ANY(@tags::UUID[])`</span></span> }</code> </pre> <br><p>  Este controlador se puede usar para argumentos de solicitud y respuesta.  En el caso de una lista en la respuesta, el método debe pertenecer al elemento de la lista. </p><br><h4 id="transactions">  Transacciones </h4><br><p>  Para admitir transacciones, la interfaz (Tienda) debe ampliarse con los siguientes métodos: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { BeginTx(ctx context.Context, opts *sql.TxOptions) (Store, error) sal.Txer ...</code> </pre> <br><p>  Se generará la implementación de los métodos.  El método <code>BeginTx</code> usa la conexión desde el objeto actual <code>sal.QueryHandler</code> y abre la transacción <code>db.BeginTx(...)</code> ;  devuelve un nuevo objeto de implementación de la interfaz de la <code>Store</code> , pero usa el objeto recibido <code>*sql.Tx</code> como <code>*sql.Tx</code> </p><br><h4 id="middleware">  Middleware </h4><br><p>  Se proporcionan ganchos para incrustar herramientas. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> BeforeQueryFunc <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, query </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, req </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context.Context, FinalizerFunc)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FinalizerFunc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, err error)</span></span></span></span></code> </pre> <br><p>  Se <code>BeforeQueryFunc</code> gancho <code>BeforeQueryFunc</code> antes de <code>db.PrepareContext</code> o <code>db.Query</code> .  Es decir, al comienzo del programa, cuando la memoria caché de expresiones preparada está vacía, cuando <code>store.GetAuthors</code> llama a <code>store.GetAuthors</code> llamará al gancho <code>BeforeQueryFunc</code> dos veces.  El <code>BeforeQueryFunc</code> puede devolver un <code>BeforeQueryFunc</code> <code>FinalizerFunc</code> , que se llamará antes de salir del método de usuario, en nuestra <code>store.GetAuthors</code> casos. <code>store.GetAuthors</code> , usando <code>defer</code> . </p><br><p>  En el momento de la ejecución de los ganchos, el contexto se llena con claves de servicio con los siguientes valores: </p><br><ul><li>  <code>ctx.Value(sal.ContextKeyTxOpened)</code> valor booleano determina si el método se llama en el contexto de la transacción o no. </li><li>  <code>ctx.Value(sal.ContextKeyOperationType)</code> , el valor de cadena del tipo de operación, <code>"QueryRow"</code> , <code>"Query"</code> , <code>"Exec"</code> , <code>"Commit"</code> , etc. </li><li>  <code>ctx.Value(sal.ContextKeyMethodName)</code> valor de cadena del método de interfaz, como <code>"GetAuthors"</code> . </li></ul><br><p>  Como argumentos, el <code>BeforeQueryFunc</code> acepta la cadena sql de la consulta y el argumento <code>req</code> del método de consulta del usuario.  El gancho <code>FinalizerFunc</code> toma una variable <code>err</code> como argumento. </p><br><pre> <code class="go hljs">beforeHook := <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, query </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, req </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context.Context, sal.FinalizerFunc)</span></span></span></span> { start := time.Now() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ctx, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, err error)</span></span></span></span> { log.Printf( <span class="hljs-string"><span class="hljs-string">"%q &gt; Opeartion %q: %q with req %#v took [%v] inTx[%v] Error: %+v"</span></span>, ctx.Value(sal.ContextKeyMethodName), ctx.Value(sal.ContextKeyOperationType), query, req, time.Since(start), ctx.Value(sal.ContextKeyTxOpened), err, ) } } client := NewStore(db, sal.BeforeQuery(beforeHook))</code> </pre> <br><p>  Ejemplos de salida: </p><br><pre> <code class="plaintext hljs">"CreateAuthor" &gt; Opeartion "Prepare": "INSERT INTO authors (Name, Desc, CreatedAt) VALUES($1, $2, now()) RETURNING ID, CreatedAt" with req &lt;nil&gt; took [50.819µs] inTx[false] Error: &lt;nil&gt; "CreateAuthor" &gt; Opeartion "QueryRow": "INSERT INTO authors (Name, Desc, CreatedAt) VALUES(@Name, @Desc, now()) RETURNING ID, CreatedAt" with req bookstore.CreateAuthorReq{BaseAuthor:bookstore.BaseAuthor{Name:"foo", Desc:"Bar"}} took [150.994µs] inTx[false] Error: &lt;nil&gt;</code> </pre> <br><h3 id="whats-next">  Que sigue </h3><br><ul><li>  Soporte para variables de enlace y expresiones preparadas para MySQL. </li><li>  Gancho RowAppender para ajustar la respuesta. </li><li>  Devuelve el valor de <code>Exec.Result</code> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es431984/">https://habr.com/ru/post/es431984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es431972/index.html">Datos de usuario de Quora filtrados</a></li>
<li><a href="../es431974/index.html">Tumblr abandona por completo el contenido de "fresa"</a></li>
<li><a href="../es431976/index.html">Día de la informática en Rusia: la historia del primer proyecto de una computadora automática</a></li>
<li><a href="../es431978/index.html">Promoción de la tienda en línea: lo que habrá que arreglar</a></li>
<li><a href="../es431982/index.html">Digerati, Hakerazzi y colesterol en los datos: sobre la jerga informática</a></li>
<li><a href="../es431986/index.html">Fuck Up story: cómo me decepcioné en los servicios digitales para empresas y tuve mi propio negocio (bueno, casi)</a></li>
<li><a href="../es431988/index.html">Cuando el teorema se convirtió en un axioma: ONYX BOOX Euclid review</a></li>
<li><a href="../es431990/index.html">Gaps ganados. Traducción de documentación de convenciones de codificación de Kotlin de JetBrains</a></li>
<li><a href="../es431992/index.html">Biometría: cómo están las cosas con nosotros y con ellos</a></li>
<li><a href="../es431994/index.html">Discusión de la licencia gratuita de PVS-Studio para proyectos alojados en GitHub</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>