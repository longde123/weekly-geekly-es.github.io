<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤽🏽 📬 ☄️ Como reverter e invadir o disco rígido externo auto-criptografado do Aigo. Parte 2: Despejando com Cypress PSoC 👨🏻‍🚀 🤵🏿 🖕🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta é a segunda e última parte do artigo sobre como invadir unidades externas de criptografia automática. Recordo que um colega recentemente me troux...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como reverter e invadir o disco rígido externo auto-criptografado do Aigo. Parte 2: Despejando com Cypress PSoC</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455529/"><p>  Esta é a segunda e última parte do artigo sobre como invadir unidades externas de criptografia automática.  Recordo que um colega recentemente me trouxe um disco rígido Patriot (Aigo) SK8671, e decidi revertê-lo, e agora estou compartilhando o que veio dele.  Antes de continuar a leitura, leia a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeira parte do</a> artigo. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4. Começamos a remover o despejo da unidade flash interna PSoC</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">5. protocolo ISSP</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">5.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O que é um ISSP?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">5.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Desmistificação de vetores</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">5.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conversar com PSoC</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">- 5.4</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Identificação de registros intra-chip</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">- 5.5</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bits de proteção</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">6. Primeiro ataque (com falha): ROMX</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">7. Segundo ataque: rastreamento com reset a frio</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">- 7.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Implementação</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">7.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Leia o resultado</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">7.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Reconstrução do binário flash</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">- 7.4</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Encontre o endereço de armazenamento do código PIN</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">- 7,5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nós removemos o despejo do bloco n ° 126</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">- 7.6</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Recuperação Pincode</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">8. O que vem depois?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">9. Conclusão</a> </p><br><p><img src="https://habrastorage.org/webt/wx/nm/gk/wxnmgkeurrmiurx87rujoynxrsq.jpeg"></p><a name="habracut"></a><br><a name="a4"></a><br><h1 id="4-nachinaem-snimat-damp-s-vnutrenney-fleshki-psoc">  4. Começamos a remover o despejo da unidade flash interna PSoC </h1><br><p>  Portanto, tudo indica (como estabelecemos em [a primeira parte] ()) que o código PIN é armazenado nas entranhas do flash PSoC.  Portanto, precisamos ler esses intestinos instantâneos.  Frente do trabalho necessário: </p><br><ul><li>  assumir o controle da "comunicação" com o microcontrolador; </li><li>  encontre uma maneira de verificar se essa "comunicação" está protegida da leitura externa; </li><li>  encontre uma maneira de contornar a segurança. </li></ul><br><p>  Há dois lugares em que faz sentido procurar um código PIN válido: </p><br><ul><li>  memória flash interna; </li><li>  SRAM, onde o código PIN pode ser armazenado para compará-lo com o código PIN inserido pelo usuário. </li></ul><br><p>  Olhando para o futuro, observo que ainda consegui remover o despejo da unidade flash interna do PSoC, ignorando seu sistema de proteção, com a ajuda do ataque de hardware "trace with cold reset", depois de reverter os recursos não documentados do protocolo ISSP.  Isso me permitiu despejar diretamente o código PIN atual. </p><br><pre><code class="plaintext hljs">$ ./psoc.py syncing: KO OK [...] PIN: 1 2 3 4 5 6 7 8 9</code> </pre> <br><p>  O código do programa resultante: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Código Arduino para HSSP</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Driver Python e desmontador do ISSP</a> . </li></ul><br><a name="a5"></a><br><h1 id="5-issp-protokol">  5. protocolo ISSP </h1><br><a name="a51"></a><br><h2 id="51-chto-takoe-issp">  5.1  O que é um ISSP? </h2><br><p>  “Comunicação” com o microcontrolador pode significar coisas diferentes: de “fornecedor para fornecedor”, para interação usando um protocolo serial (por exemplo, ICSP para PIC da Microchip). </p><br><p>  O Cypress possui seu próprio protocolo proprietário, chamado ISSP (protocolo de programação serial no sistema), que é parcialmente descrito na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">especificação técnica</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">US7185162</a> também fornece algumas informações.  Há também um analógico de código aberto chamado HSSP (vamos usá-lo um pouco mais tarde).  O ISSP funciona da seguinte maneira: </p><br><ul><li>  reinicie o PSoC; </li><li>  traga o número mágico para a seção de dados seriais deste PSoC;  para entrar no modo de programação externa; </li><li>  envie comandos que são longas cadeias de bits chamadas "vetores". </li></ul><br><p>  Na documentação do ISSP, esses vetores são definidos apenas para um pequeno punhado de comandos: </p><br><ul><li>  Inicializar-1 </li><li>  Initialize-2 </li><li>  Initialize-3 (opções de 3V e 5V) </li><li>  ID-SETUP </li><li>  LEIA-ID-PALAVRA </li><li>  SET-BLOCK-NUM: 10011111010dddddddd111, em que dddddddd = bloco # </li><li>  ERASE A GRANEL </li><li>  BLOCO DE PROGRAMA </li><li>  VERIFICAR CONFIGURAÇÃO </li><li>  READ-BYTE: 10110aaaaaaZDDDDDDDDDZ1, em que DDDDDDDDDD = saída de dados, aaaaaa = endereço (6 bits) </li><li>  WRITE-BYTE: 10010aaaaaadddddddd111, em que dddddddd = entrada de dados, aaaaaa = endereço (6 bits) </li><li>  Seguro </li><li>  CONFIGURAÇÃO DE CHECKSUM </li><li>  READ-CHECKSUM: 10111111001ZDDDDDDDDDZ110111111000ZDDDDDDDDZ1, em que DDDDDDDDDDDDDDDDD = saída de dados: soma de verificação do dispositivo </li><li>  APAGAR BLOCO </li></ul><br><p>  Por exemplo, o vetor para Initialize-2: </p><br><pre> <code class="plaintext hljs">1101111011100000000111 1101111011000000000111 1001111100000111010111 1001111100100000011111 1101111010100000000111 1101111010000000011111 1001111101110000000111 1101111100100110000111 1101111101001000000111 1001111101000000001111 1101111000000000110111 1101111100000000000111 1101111111100010010111</code> </pre> <br><p>  Todos os vetores têm o mesmo comprimento: 22 bits.  A documentação do HSSP possui algumas informações adicionais sobre os ISSPs: "Um vetor ISSP nada mais é do que uma sequência de bits que representa um conjunto de instruções". </p><br><a name="a52"></a><br><h2 id="52-demistifikaciya-vektorov">  5.2  Desmistificação de vetores </h2><br><p>  Vamos ver o que acontece aqui.  Inicialmente, assumi que esses mesmos vetores são variantes brutas das instruções M8C; no entanto, tendo testado essa hipótese, descobri que os códigos de operação das operações não correspondem. </p><br><p>  Depois, pesquisei no vetor acima e me deparei com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este</a> estudo, onde o autor, embora não entre em detalhes, fornece algumas dicas práticas: “Cada instrução começa com três bits que correspondem a uma das quatro mnemônicas (leia da RAM, escreva para RAM , leia o registro, escreva o registro).  Depois vem o endereço de 8 bits, seguido por 8 bits de dados (lidos ou gravados) e, finalmente, três bits de parada. ” </p><br><p>  Pude reunir algumas informações muito úteis na seção ROM de supervisão (SROM) do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">manual técnico</a> .  SROM é uma ROM codificada no PSoC que fornece funções de serviço (semelhantes ao Syscall) para código de software em execução no espaço do usuário: </p><br><ul><li>  00h: SWBootReset </li><li>  01h: ReadBlock </li><li>  02h: WriteBlock </li><li>  03h: EraseBlock </li><li>  06h: Leitura da tabela </li><li>  07h: CheckSum </li><li>  08h: Calibrar0 </li><li>  09h: Calibrar1 </li></ul><br><p>  Comparando nomes de vetores com funções SROM, podemos mapear as várias operações suportadas por este protocolo para os parâmetros SROM esperados.  Graças a isso, podemos decodificar os três primeiros bits dos vetores ISSP: </p><br><ul><li>  100 =&gt; "wrmem" </li><li>  101 =&gt; "rdmem" </li><li>  110 =&gt; "wrreg" </li><li>  111 =&gt; "rdreg" </li></ul><br><p>  No entanto, um entendimento completo dos processos intra-chip só pode ser obtido através da comunicação direta com o PSoC. </p><br><a name="a53"></a><br><h2 id="53-obschenie-s-psoc">  5.3  Conversar com PSoC </h2><br><p>  Como Dirk Petrautsky já <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">portou o</a> código Cypress HSSP para o Arduino, usei o Arduino Uno para conectar a placa do teclado ao conector ISSP. </p><br><p>  Observe que, durante minha pesquisa, mudei praticamente o código Dirk.  Você pode encontrar minha modificação no GitHub: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui está o</a> script Python correspondente para se comunicar com o Arduino, no meu repositório <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cypress_psoc_tools</a> . </p><br><p>  Então, usando o Arduino, no começo eu usei apenas vetores “oficiais” para “comunicação”.  Tentei ler a ROM interna usando o comando VERIFY.  Como esperado, eu não poderia fazer isso.  Provavelmente devido ao fato de que os bits de proteção de leitura são ativados dentro da unidade flash. </p><br><p>  Então eu criei alguns dos meus vetores simples para escrever e ler a memória / registros.  Observe que podemos ler o SROM inteiro, mesmo que a unidade flash esteja protegida! </p><br><a name="a54"></a><br><h2 id="54-identifikaciya-vnutrichipovyh-registrov">  5.4  Identificação de registros intra-chip </h2><br><p>  Observando os vetores "desmontados", descobri que o dispositivo usa registros não documentados (0xF8-0xFA) para indicar opcodes M8C que são executados diretamente, ignorando a proteção.  Isso me permitiu executar vários códigos de operação, como "ADD", "MOV A, X", "PUSH" ou "JMP".  Graças a eles (observando os efeitos colaterais que eles causam nos registros), pude determinar qual dos registros não documentados são na verdade registros regulares (A, X, SP e PC). </p><br><p>  Como resultado, o código "desmontado" gerado pela ferramenta HSSP_disas.rb se parece com isso (para maior clareza, adicionei comentários): </p><br><pre> <code class="plaintext hljs">--== init2 ==-- [DE E0 1C] wrreg CPU_F (f7), 0x00 #   [DE C0 1C] wrreg SP (f6), 0x00 #  SP [9F 07 5C] wrmem KEY1, 0x3A #    SSC [9F 20 7C] wrmem KEY2, 0x03 #  [DE A0 1C] wrreg PCh (f5), 0x00 #  PC (MSB) ... [DE 80 7C] wrreg PCl (f4), 0x03 # (LSB) ...  3 ?? [9F 70 1C] wrmem POINTER, 0x80 # RAM-    [DF 26 1C] wrreg opc1 (f9), 0x30 #  1 =&gt; "HALT" [DF 48 1C] wrreg opc2 (fa), 0x40 #  2 =&gt; "NOP" [9F 40 3C] wrmem BLOCKID, 0x01 # BLOCK ID   SSC [DE 00 DC] wrreg A (f0), 0x06 #  "Syscall" : TableRead [DF 00 1C] wrreg opc0 (f8), 0x00 #   SSC, "Supervisory SROM Call" [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12 #  :   </code> </pre> <br><a name="a55"></a><br><h2 id="55-zaschitnye-bity">  5.5  Bits de proteção </h2><br><p>  Nesta fase, já posso me comunicar com o PSoC, mas ainda não tenho informações confiáveis ​​sobre os bits de proteção da unidade flash.  Fiquei muito surpreso com o fato de o Cypress não fornecer ao usuário do dispositivo meios para verificar se a proteção está ativada.  Entrei profundamente no Google para finalmente entender que o código HSSP fornecido pelo Cypress foi atualizado depois que Dirk lançou sua modificação.  E lá vai você!  Aqui está um novo vetor como este: </p><br><pre> <code class="plaintext hljs">[DE E0 1C] wrreg CPU_F (f7), 0x00 [DE C0 1C] wrreg SP (f6), 0x00 [9F 07 5C] wrmem KEY1, 0x3A [9F 20 7C] wrmem KEY2, 0x03 [9F A0 1C] wrmem 0xFD, 0x00 #   [9F E0 1C] wrmem 0xFF, 0x00 #  [DE A0 1C] wrreg PCh (f5), 0x00 [DE 80 7C] wrreg PCl (f4), 0x03 [9F 70 1C] wrmem POINTER, 0x80 [DF 26 1C] wrreg opc1 (f9), 0x30 [DF 48 1C] wrreg opc2 (fa), 0x40 [DE 02 1C] wrreg A (f0), 0x10 #  syscall ! [DF 00 1C] wrreg opc0 (f8), 0x00 [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12</code> </pre> <br><p>  Usando esse vetor (consulte read_security_data em psoc.py), obtemos todos os bits de proteção na SRAM em 0x80, onde cada bit é protegido com dois bits. </p><br><p>  O resultado é deprimente: tudo é protegido no modo "desativar leitura e gravação externas".  Portanto, não podemos apenas ler qualquer coisa da unidade flash USB, mas também escrevê-la (por exemplo, para introduzir um dumper de ROM).  E a única maneira de desativar a proteção é apagar completamente o chip inteiro.  :-( </p><br><a name="a6"></a><br><h1 id="6-pervaya-neudavshayasya-ataka-romx">  6. Primeiro ataque (com falha): ROMX </h1><br><p>  No entanto, podemos tentar o seguinte truque: como temos a capacidade de executar códigos opcionais arbitrários, por que não executar o ROMX, que é usado para ler a memória flash?  Essa abordagem tem uma boa chance de sucesso.  Como a função ReadBlock, que lê dados do SROM (usado por vetores), verifica se é chamada pelo ISSP.  No entanto, o código de operação ROMX, presumivelmente, pode não ter essa verificação.  Então, aqui está o código Python (depois de adicionar algumas classes auxiliares ao código Arduino C): </p><br><pre> <code class="plaintext hljs">for i in range(0, 8192): write_reg(0xF0, i&gt;&gt;8) # A = 0 write_reg(0xF3, i&amp;0xFF) # X = 0 exec_opcodes("\x28\x30\x40") # ROMX, HALT, NOP byte = read_reg(0xF0) # ROMX reads ROM[A|X] into A print "%02x" % ord(byte[0]) # print ROM byte</code> </pre> <br><p>  Infelizmente, esse código não funciona.  :-( Em vez disso, funciona, mas na saída obtemos nossos próprios opcodes (0x28 0x30 0x40)! Não acho que a funcionalidade correspondente do dispositivo seja um elemento de proteção de leitura. Isso é mais um truque de engenharia: ao executar opcodes externos, o barramento de ROM é redirecionado para um buffer temporário. </p><br><a name="a7"></a><br><h1 id="7-vtoraya-ataka-trassirovka-s-holodnoy-perezagruzkoy">  7. Segundo ataque: rastreamento com reset a frio </h1><br><p>  Como o truque do ROMX não funcionou, comecei a pensar em outra variação desse truque - descrita na publicação <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Lançar muita luz na proteção de firmware de um microcontrolador"</a> . </p><br><a name="a71"></a><br><h2 id="71-realizaciya">  7.1  Implementação </h2><br><p>  O seguinte vetor para CHECKSUM-SETUP está listado na documentação do ISSP: </p><br><pre> <code class="plaintext hljs">[DE E0 1C] wrreg CPU_F (f7), 0x00 [DE C0 1C] wrreg SP (f6), 0x00 [9F 07 5C] wrmem KEY1, 0x3A [9F 20 7C] wrmem KEY2, 0x03 [DE A0 1C] wrreg PCh (f5), 0x00 [DE 80 7C] wrreg PCl (f4), 0x03 [9F 70 1C] wrmem POINTER, 0x80 [DF 26 1C] wrreg opc1 (f9), 0x30 [DF 48 1C] wrreg opc2 (fa), 0x40 [9F 40 1C] wrmem BLOCKID, 0x00 [DE 00 FC] wrreg A (f0), 0x07 [DF 00 1C] wrreg opc0 (f8), 0x00 [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12</code> </pre> <br><p>  Aqui, em essência, a função SROM 0x07 é chamada, conforme apresentado na documentação (itálico meu): </p><br><blockquote>  Esta função soma de verificação soma de verificação.  Ele calcula uma soma de verificação de 16 bits do número de blocos definido pelo usuário em um banco flash, contando a partir de zero.  O parâmetro BLOCKID é usado para transferir o número de blocos que serão usados ​​ao calcular a soma de verificação.  Um valor de "1" calculará a soma de verificação apenas para o bloco zero;  enquanto <em>"0" levará ao fato de que a soma total de verificação de todos os 256 blocos do banco flash será calculada.</em>  <em>Uma soma de verificação de 16 bits é retornada via KEY1 e KEY2.</em>  No parâmetro KEY1, os 8 bits baixos da soma de verificação são fixos e, na KEY2, os 8 bits altos são registrados.  Para dispositivos com vários bancos de flash, a função de soma de verificação é chamada para cada um individualmente.  O número do banco com o qual ele trabalhará é definido pelo registro FLS_PR1 (configurando um bit correspondente ao banco flash de destino). </blockquote><p>  Observe que esta é a soma de verificação mais simples: os bytes são simplesmente somados um por um;  sem peculiaridades sofisticadas da CRC.  Além disso, sabendo que o conjunto de registros no núcleo M8C é muito pequeno, presumi que, ao calcular a soma de verificação, os valores intermediários serão fixados nas mesmas variáveis ​​que eventualmente serão geradas: KEY1 (0xF8) / KEY2 (0xF9). </p><br><p>  Então, em teoria, meu ataque é assim: </p><br><ol><li>  Conecte-se através do ISSP. </li><li>  Iniciamos o cálculo da soma de verificação usando o vetor CHECKSUM-SETUP. </li><li>  Reiniciamos o processador após o tempo especificado T. </li><li>  Leia RAM para obter a soma de verificação atual C. </li><li>  Repita as etapas 3 e 4, aumentando cada vez mais T. </li><li>  Recuperamos os dados da unidade flash subtraindo a soma de verificação C anterior da atual. </li></ol><br><p>  No entanto, surgiu um problema: o vetor Initialize-1, que devemos enviar após a reinicialização, substitui KEY1 e KEY2: </p><br><pre> <code class="plaintext hljs">1100101000000000000000 # ,  PSoC    nop nop nop nop nop [DE E0 1C] wrreg CPU_F (f7), 0x00 [DE C0 1C] wrreg SP (f6), 0x00 [9F 07 5C] wrmem KEY1, 0x3A #     [9F 20 7C] wrmem KEY2, 0x03 #   [DE A0 1C] wrreg PCh (f5), 0x00 [DE 80 7C] wrreg PCl (f4), 0x03 [9F 70 1C] wrmem POINTER, 0x80 [DF 26 1C] wrreg opc1 (f9), 0x30 [DF 48 1C] wrreg opc2 (fa), 0x40 [DE 01 3C] wrreg A (f0), 0x09 # SROM- 9 [DF 00 1C] wrreg opc0 (f8), 0x00 # SSC [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12</code> </pre> <br><p>  Esse código substitui nossa preciosa soma de verificação, chamando Calibrate1 (função SROM 9) ... Talvez possamos simplesmente entrar no modo de programação enviando o número mágico (do início do código acima) e depois ler SRAM?  E sim, funciona!  O código do Arduino que implementa esse ataque é bastante simples: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Cmnd_STK_START_CSUM: checksum_delay = ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)getch())&lt;&lt;<span class="hljs-number"><span class="hljs-number">24</span></span>; checksum_delay |= ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)getch())&lt;&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>; checksum_delay |= ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)getch())&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; checksum_delay |= getch(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(checksum_delay &gt; <span class="hljs-number"><span class="hljs-number">10000</span></span>) { ms_delay = checksum_delay/<span class="hljs-number"><span class="hljs-number">1000</span></span>; checksum_delay = checksum_delay%<span class="hljs-number"><span class="hljs-number">1000</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ms_delay = <span class="hljs-number"><span class="hljs-number">0</span></span>; } send_checksum_v(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(checksum_delay) delayMicroseconds(checksum_delay); delay(ms_delay); start_pmode();</code> </pre> <br><ol><li>  Leia checkum_delay. </li><li>  Execute o cálculo da soma de verificação (send_checksum_v). </li><li>  Aguarde um determinado período de tempo;  dadas as seguintes armadilhas: <br><ul><li>  Passei muito tempo até descobrir que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">delayMicrosegundos acabou</a> funcionando corretamente apenas com atrasos não superiores a 16383mks; </li><li>  e, em seguida, novamente matou a mesma quantidade de tempo até descobrir que delayMicroseconds, se passou 0 para sua entrada, funcionou completamente errado! </li></ul></li><li>  Recarregue o PSoC no modo de programação (basta enviar o número mágico, sem enviar vetores de inicialização). </li></ol><br><p>  O código Python resultante: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> delay <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">150000</span></span>): <span class="hljs-comment"><span class="hljs-comment">#    for i in range(0, 10): #      try: reset_psoc(quiet=True) #       send_vectors() #    ser.write("\x85"+struct.pack("&gt;I", delay)) #    +    res = ser.read(1) #  arduino ACK except Exception as e: print e ser.close() os.system("timeout -s KILL 1s picocom -b 115200 /dev/ttyACM0 2&gt;&amp;1 &gt; /dev/null") ser = serial.Serial('/dev/ttyACM0', 115200, timeout=0.5) #    continue print "%05d %02X %02X %02X" % (delay, #  RAM- read_regb(0xf1), read_ramb(0xf8), read_ramb(0xf9))</span></span></code> </pre> <br><p>  Em poucas palavras, o que esse código faz: </p><br><ol><li>  Recarrega o PSoC (e envia um número mágico). </li><li>  Envia vetores de inicialização completos. </li><li>  Chama a função Arduino Cmnd_STK_START_CSUM (0x85), onde o atraso em microssegundos é passado como um parâmetro. </li><li>  Lê a soma de verificação (0xF8 e 0xF9) e o registro não documentado 0xF1. </li></ol><br><p>  Este código é executado 10 vezes em 1 microssegundo.  0xF1 está incluído aqui porque foi o único registro que foi alterado ao calcular a soma de verificação.  Talvez este seja algum tipo de variável temporária usada pelo dispositivo lógico aritmético.  Preste atenção ao feio truque que eu reinicio o Arduino usando picocom quando o Arduino para de dar sinais de vida (não faço ideia do porquê). </p><br><a name="a72"></a><br><h2 id="72-schityvaem-rezultat">  7.2  Leia o resultado </h2><br><p>  O resultado do script Python se parece com este (simplificado para facilitar a leitura): </p><br><pre> <code class="plaintext hljs">DELAY F1 F8 F9 # F1 –    # F8     # F9     00000 03 E1 19 [...] 00016 F9 00 03 00016 F9 00 00 00016 F9 00 03 00016 F9 00 03 00016 F9 00 03 00016 F9 00 00 #     0 00017 FB 00 00 [...] 00023 F8 00 00 00024 80 80 00 # 1- : 0x0080-0x0000 = 0x80 00024 80 80 00 00024 80 80 00 [...] 00057 CC E7 00 # 2- : 0xE7-0x80: 0x67 00057 CC E7 00 00057 01 17 01 #   ,    00057 01 17 01 00057 01 17 01 00058 D0 17 01 00058 D0 17 01 00058 D0 17 01 00058 D0 17 01 00058 F8 E7 00 #  E7? 00058 D0 17 01 [...] 00059 E7 E7 00 00060 17 17 00 #  [...] 00062 00 17 00 00062 00 17 00 00063 01 17 01 # , !        00063 01 17 01 [...] 00075 CC 17 01 # , 0x117-0xE7: 0x30</code> </pre> <br><p>  Ao mesmo tempo, temos um problema: como operamos na soma de verificação real, um byte zero não altera o valor de leitura.  No entanto, como todo o procedimento de cálculo (8192 bytes) leva 0,1478 segundos (com pequenos desvios a cada inicialização), o que corresponde aproximadamente a 18,04 μs por byte, podemos usar esse tempo para verificar o valor da soma de verificação em momentos adequados.  Nas primeiras execuções, tudo é lido com muita facilidade, pois a duração do procedimento computacional é sempre quase a mesma.  No entanto, o final desse despejo é menos preciso, porque os "desvios insignificantes no tempo" a cada execução são resumidos e se tornam significativos: </p><br><pre> <code class="plaintext hljs">134023 D0 02 DD 134023 CC D2 DC 134023 CC D2 DC 134023 CC D2 DC 134023 FB D2 DC 134023 3F D2 DC 134023 CC D2 DC 134024 02 02 DC 134024 CC D2 DC 134024 F9 02 DC 134024 03 02 DD 134024 21 02 DD 134024 02 D2 DC 134024 02 02 DC 134024 02 02 DC 134024 F8 D2 DC 134024 F8 D2 DC 134025 CC D2 DC 134025 EF D2 DC 134025 21 02 DD 134025 F8 D2 DC 134025 21 02 DD 134025 CC D2 DC 134025 04 D2 DC 134025 FB D2 DC 134025 CC D2 DC 134025 FB 02 DD 134026 03 02 DD 134026 21 02 DD</code> </pre> <br><p>  São 10 despejos para cada atraso de microssegundo.  O tempo total de operação para descarregar todos os 8192 bytes de uma unidade flash é de aproximadamente 48 horas. </p><br><a name="a73"></a><br><h2 id="73-rekonstrukciya-flesh-binarnika">  7.3  Reconstrução do binário flash </h2><br><p>  Ainda não terminei de escrever um código que reconstrua completamente o código do programa da unidade flash, levando em consideração todos os desvios no tempo.  No entanto, eu já restaurei o início desse código.  Para garantir que eu fiz corretamente, desmontei-o usando o m8cdis: </p><br><pre> <code class="plaintext hljs">0000: 80 67 jmp 0068h ; Reset vector [...] 0068: 71 10 or F,010h 006a: 62 e3 87 mov reg[VLT_CR],087h 006d: 70 ef and F,0efh 006f: 41 fe fb and reg[CPU_SCR1],0fbh 0072: 50 80 mov A,080h 0074: 4e swap A,SP 0075: 55 fa 01 mov [0fah],001h 0078: 4f mov X,SP 0079: 5b mov A,X 007a: 01 03 add A,003h 007c: 53 f9 mov [0f9h],A 007e: 55 f8 3a mov [0f8h],03ah 0081: 50 06 mov A,006h 0083: 00 ssc [...] 0122: 18 pop A 0123: 71 10 or F,010h 0125: 43 e3 10 or reg[VLT_CR],010h 0128: 70 00 and F,000h ; Paging mode changed from 3 to 0 012a: ef 62 jacc 008dh 012c: e0 00 jacc 012dh 012e: 71 10 or F,010h 0130: 62 e0 02 mov reg[OSC_CR0],002h 0133: 70 ef and F,0efh 0135: 62 e2 00 mov reg[INT_VC],000h 0138: 7c 19 30 lcall 1930h 013b: 8f ff jmp 013bh 013d: 50 08 mov A,008h 013f: 7f ret</code> </pre> <br><p>  Parece bastante crível! </p><br><a name="a74"></a><br><h2 id="74-nahodim-adres-hraneniya-pinkoda">  7.4  Encontre o endereço de armazenamento do código PIN </h2><br><p>  Agora que podemos ler a soma de verificação no momento em que precisamos, podemos verificar facilmente como e onde ela muda quando: </p><br><ul><li>  digite o código errado; </li><li>  mude o código PIN. </li></ul><br><p>  Primeiro, para encontrar o endereço de armazenamento aproximado, fiz um despejo de soma de verificação em incrementos de 10 ms após uma reinicialização.  Então entrei no código PIN errado e fiz o mesmo. </p><br><p>  O resultado não foi muito agradável, pois houve muitas mudanças.  Mas, no final, pude estabelecer que a soma de verificação mudou em algum lugar no intervalo entre 120.000 µs e 140.000 µs de atraso.  Mas o “código PIN” que cheguei lá estava completamente errado - devido ao artefato delayMicroseconds do procedimento, que faz coisas estranhas quando obtém 0. </p><br><p>  Depois de passar quase três horas, lembrei que a chamada do sistema CheckSum SROM na entrada recebe um argumento especificando o número de blocos para a soma de verificação!  T.O.  podemos localizar facilmente o endereço de armazenamento do código PIN e o contador de "tentativas incorretas", precisas para o bloco de 64 bytes. </p><br><p>  Minhas execuções iniciais deram o seguinte resultado: </p><br><p><img src="https://habrastorage.org/webt/0n/ol/xc/0nolxcgp8espvfdubrhrmvmbgrg.png"></p><br><p>  Então mudei o código PIN de "123456" para "1234567" e recebi: </p><br><p><img src="https://habrastorage.org/webt/0r/zp/s2/0rzps2e2mwldmhtot1tswiv7mdq.png"></p><br><p>  Assim, o código PIN e o contador de tentativas incorretas parecem estar armazenados no bloco nº 126. </p><br><a name="a75"></a><br><h2 id="75-snimaem-damp-bloka-126">  7.5  Nós removemos o despejo do bloco n ° 126 </h2><br><p>  O bloco nº 126 deve estar localizado em algum lugar na região de 125x64x18 = 144000mks, desde o início do cálculo da soma de verificação, no meu despejo completo, e parece bastante crível.  Então, depois de selecionar manualmente vários dumps inválidos (devido ao acúmulo de "pequenos desvios no tempo"), finalmente obtive esses bytes (com um atraso de 145527 μs): </p><br><p><img src="https://habrastorage.org/webt/ji/31/ye/ji31yewphovunymnjxp0fcpwrdw.png"></p><br><p>  É claro que o código PIN é armazenado em forma não criptografada!  É claro que esses valores não estão escritos em códigos ASCII, mas, como se vê, refletem as leituras obtidas no teclado capacitivo. </p><br><p>  Por fim, executei mais alguns testes para descobrir onde o contador de tentativas incorretas está armazenado.  Aqui está o resultado: </p><br><p><img src="https://habrastorage.org/webt/dc/r5/tf/dcr5tf0yevdxcg5lyrbcr9srowu.png"></p><br><p>  0xFF - significa "15 tentativas" e diminui a cada tentativa incorreta. </p><br><a name="a76"></a><br><h2 id="76-vosstanovlenie-pinkoda">  7.6  Recuperação Pincode </h2><br><p>  Aqui está o meu código feio que reúne todos os itens acima: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dump_pin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> pin_map = {<span class="hljs-number"><span class="hljs-number">0x24</span></span>: <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-number"><span class="hljs-number">0x25</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-number"><span class="hljs-number">0x26</span></span>: <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-number"><span class="hljs-number">0x27</span></span>:<span class="hljs-string"><span class="hljs-string">"3"</span></span>, <span class="hljs-number"><span class="hljs-number">0x20</span></span>: <span class="hljs-string"><span class="hljs-string">"4"</span></span>, <span class="hljs-number"><span class="hljs-number">0x21</span></span>: <span class="hljs-string"><span class="hljs-string">"5"</span></span>, <span class="hljs-number"><span class="hljs-number">0x22</span></span>: <span class="hljs-string"><span class="hljs-string">"6"</span></span>, <span class="hljs-number"><span class="hljs-number">0x23</span></span>: <span class="hljs-string"><span class="hljs-string">"7"</span></span>, <span class="hljs-number"><span class="hljs-number">0x2c</span></span>: <span class="hljs-string"><span class="hljs-string">"8"</span></span>, <span class="hljs-number"><span class="hljs-number">0x2d</span></span>: <span class="hljs-string"><span class="hljs-string">"9"</span></span>} last_csum = <span class="hljs-number"><span class="hljs-number">0</span></span> pin_bytes = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> delay <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">145495</span></span>, <span class="hljs-number"><span class="hljs-number">145719</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>): csum = csum_at(delay, <span class="hljs-number"><span class="hljs-number">1</span></span>) byte = (csum-last_csum)&amp;<span class="hljs-number"><span class="hljs-number">0xFF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"%05d %04x (%04x) =&gt; %02x"</span></span> % (delay, csum, last_csum, byte) pin_bytes.append(byte) last_csum = csum <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"PIN: "</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(pin_bytes)): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pin_bytes[i] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pin_map: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> pin_map[pin_bytes[i]], <span class="hljs-keyword"><span class="hljs-keyword">print</span></span></code> </pre> <br><p>  Aqui está o resultado de sua execução: </p><br><pre> <code class="plaintext hljs">$ ./psoc.py syncing: KO OK Resetting PSoC: KO Resetting PSoC: KO Resetting PSoC: OK 145495 53e2 (0000) =&gt; e2 145511 5407 (53e2) =&gt; 25 145527 542d (5407) =&gt; 26 145543 5454 (542d) =&gt; 27 145559 5474 (5454) =&gt; 20 145575 5495 (5474) =&gt; 21 145591 54b7 (5495) =&gt; 22 145607 54da (54b7) =&gt; 23 145623 5506 (54da) =&gt; 2c 145639 5506 (5506) =&gt; 00 145655 5533 (5506) =&gt; 2d 145671 554c (5533) =&gt; 19 145687 554e (554c) =&gt; 02 145703 554e (554e) =&gt; 00 PIN: 1 2 3 4 5 6 7 8 9</code> </pre> <br><p>  Viva!  Isso funciona! </p><br><p>  Observe que os valores de atraso usados ​​por mim são provavelmente relevantes para um PSoC específico - o que eu usei. </p><br><a name="a8"></a><br><h1 id="8-chto-dalshe">  8. O que vem depois? </h1><br><p> ,     PSoC,     Aigo: </p><br><ul><li>    SRAM,      ; </li><li>      ,   «   »,    . </li></ul><br><p>   ,       – -   .       : </p><br><ul><li>       ,      «   »; </li><li>  FPGA-       (    Arduino); </li><li>    :    ,     RAM,   ,       RAM,  .   Arduino    - ,    Arduino  5 ,            3,3 . </li></ul><br><p>   ,      –   ,     .     ,         , –  ,          . </p><br><p>  SROM,        ReadBlock,       ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>     –     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">«REcon Brussels 2017»</a> . </p><br><p>    ,      –    :    SRAM,      . </p><br><a name="a9"></a><br><h1 id="9-zaklyuchenie"> 9.  </h1><br><p> ,      ,         ( «») …      (),         ! </p><br><p>     Aigo?  -   HDD-,   2015   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>  SyScan,        HDD-,   ,       . :-) </p><br><p>          .     40 .     (   )    ( ).    40   ,       .    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt455529/">https://habr.com/ru/post/pt455529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt455517/index.html">Formado no curso de Netologia “Data Science” sobre seu trabalho no setor bancário</a></li>
<li><a href="../pt455519/index.html">Como implementamos a integração de novos desenvolvedores</a></li>
<li><a href="../pt455523/index.html">Implementação da interface do usuário do OpenStack LBaaS</a></li>
<li><a href="../pt455525/index.html">Zimbra e Mail Bomb Defense</a></li>
<li><a href="../pt455527/index.html">O que está escrito nisso? Nos bastidores dos objetos JavaScript</a></li>
<li><a href="../pt455533/index.html">Física da bolha: uma busca pelo mecanismo de destruição da espuma</a></li>
<li><a href="../pt455535/index.html">Gerenciando certificados SSL / TLS nas nuvens e contêineres - não no trabalho humano</a></li>
<li><a href="../pt455537/index.html">Otimização de pesquisa ampla: como processar um gráfico com 10 bilhões de estados</a></li>
<li><a href="../pt455539/index.html">Videntes móveis: 10 fatos novos sobre como os dispositivos vestíveis estão observando você</a></li>
<li><a href="../pt455543/index.html">O Kubernetes Cluster é fácil e conveniente de preparar? Anunciar addon-operator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>