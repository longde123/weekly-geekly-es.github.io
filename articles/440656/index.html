<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè¥ üëéüèº üë©üèª‚Äçüç≥ Contenedor profesional de aplicaciones Node.js usando Docker üë®üèΩ‚Äçüåæ ‚öíÔ∏è üßõüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El autor del material, cuya traducci√≥n publicamos hoy, es un ingeniero de DevOps. √âl dice que tiene que usar Docker . En particular, esta plataforma d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Contenedor profesional de aplicaciones Node.js usando Docker</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/440656/">  El autor del material, cuya traducci√≥n publicamos hoy, es un ingeniero de DevOps.  √âl dice que tiene que usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Docker</a> .  En particular, esta plataforma de gesti√≥n de contenedores se utiliza en varias etapas del ciclo de vida de las aplicaciones Node.js.  El uso de Docker, una tecnolog√≠a que recientemente ha sido extremadamente popular, le permite optimizar el proceso de desarrollo y salida de los proyectos Node.js en producci√≥n. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/0c1/c88/f14/0c1c88f14934b3bb68342f9c5a18eee6.png" alt="imagen"></a> <br><br>  Ahora estamos publicando una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">serie de art√≠culos</a> sobre Docker dise√±ados para aquellos que desean aprender esta plataforma para su uso en una variedad de situaciones.  El mismo material se centra principalmente en el uso profesional de Docker en el desarrollo de Node.js. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">¬øQu√© es un acoplador?</font> </h2><br>  Docker es un programa dise√±ado para organizar la virtualizaci√≥n a nivel del sistema operativo (contenedorizaci√≥n).  En el coraz√≥n de los contenedores hay im√°genes en capas.  En pocas palabras, Docker es una herramienta que le permite crear, implementar y ejecutar aplicaciones utilizando contenedores independientes del sistema operativo en el que se ejecutan.  El contenedor incluye una imagen del sistema operativo base necesario para que la aplicaci√≥n funcione, la biblioteca de la que depende esta aplicaci√≥n y esta aplicaci√≥n en s√≠.  Si varios contenedores se ejecutan en la misma computadora, entonces usan los recursos de esta computadora juntos.  Los contenedores Docker pueden empaquetar proyectos creados usando una variedad de tecnolog√≠as.  Estamos interesados ‚Äã‚Äãen proyectos basados ‚Äã‚Äãen Node.js. <br><br><h2>  <font color="#3AC1EF">Crear un proyecto Node.js</font> </h2><br>  Antes de empaquetar un proyecto Node.js en un contenedor Docker, necesitamos crear este proyecto.  Hag√°moslo  Aqu√≠ est√° el archivo <code>package.json</code> de este proyecto: <br><br><pre> <code class="bash hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"node-app"</span></span>, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"The best way to manage your Node app using Docker"</span></span>, <span class="hljs-string"><span class="hljs-string">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"index.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"start"</span></span>: <span class="hljs-string"><span class="hljs-string">"node index.js"</span></span> }, <span class="hljs-string"><span class="hljs-string">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"Ankit Jain &lt;ankitjain28may77@gmail.com&gt;"</span></span>, <span class="hljs-string"><span class="hljs-string">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"ISC"</span></span>, <span class="hljs-string"><span class="hljs-string">"dependencies"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"express"</span></span>: <span class="hljs-string"><span class="hljs-string">"^4.16.4"</span></span> } }</code> </pre> <br>  Para instalar las dependencias del proyecto, ejecute el <code>npm install</code> .  En el curso de este comando, entre otras cosas, se <code>package-lock.json</code> archivo <code>package-lock.json</code> .  Ahora cree el archivo <code>index.js</code> , que contendr√° el c√≥digo del proyecto: <br><br><pre> <code class="bash hljs">const express = require(<span class="hljs-string"><span class="hljs-string">'express'</span></span>); const app = express(); app.get(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, (req, res) =&gt; { res.send(<span class="hljs-string"><span class="hljs-string">'The best way to manage your Node app using Docker\n'</span></span>); }); app.listen(3000); console.log(<span class="hljs-string"><span class="hljs-string">'Running on http://localhost:3000'</span></span>);</code> </pre> <br>  Como puede ver, aqu√≠ describimos un servidor simple que devuelve algo de texto en respuesta a las solicitudes. <br><br><h2>  <font color="#3AC1EF">Crear Dockerfile</font> </h2><br>  Ahora que la aplicaci√≥n est√° lista, hablemos sobre c√≥mo empaquetarla en un contenedor Docker.  A saber, se tratar√° de cu√°l es la parte m√°s importante de cualquier proyecto basado en Docker, sobre el Dockerfile. <br><br>  Un Dockerfile es un archivo de texto que contiene instrucciones para crear una imagen Docker para una aplicaci√≥n.  Las instrucciones en este archivo, si no entra en detalles, describen la creaci√≥n de capas de un sistema de archivos multinivel, que tiene todo lo que una aplicaci√≥n necesita para funcionar.  La plataforma Docker puede almacenar en cach√© las capas de imagen, lo que, al reutilizar las capas que ya est√°n en el cach√©, acelera el proceso de creaci√≥n de im√°genes. <br><br>  En la programaci√≥n orientada a objetos, existe una clase.  Las clases se usan para crear objetos.  En Docker, las im√°genes se pueden comparar con clases y los contenedores se pueden comparar con instancias de im√°genes, es decir, con objetos.  Considere el proceso de generar un Dockerfile, que nos ayudar√° a resolver esto. <br><br>  Cree un Dockerfile vac√≠o: <br><br><pre> <code class="bash hljs">touch Dockerfile</code> </pre> <br>  Dado que vamos a construir un contenedor para la aplicaci√≥n Node.js, lo primero que necesitamos poner en el contenedor es la imagen de Nodo base, que se puede encontrar en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Docker Hub</a> .  Utilizaremos la versi√≥n LTS de Node.js.  Como resultado, la primera declaraci√≥n de nuestro Dockerfile ser√° la siguiente declaraci√≥n: <br><br><pre> <code class="bash hljs">FROM node:8</code> </pre> <br>  Despu√©s de eso, cree un directorio para nuestro c√≥digo.  Al mismo tiempo, gracias a la instrucci√≥n <code>ARG</code> utilizada aqu√≠, podemos, si es necesario, especificar el nombre del directorio de la aplicaci√≥n que no sea <code>/app</code> durante el ensamblaje del contenedor.  Los detalles sobre este manual se pueden encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   ARG APP_DIR=app RUN mkdir -p ${APP_DIR} WORKDIR ${APP_DIR}</span></span></code> </pre> <br>  Como usamos la imagen Node, las plataformas Node.js y npm ya estar√°n instaladas en ella.  Usando lo que ya est√° en la imagen, puede organizar la instalaci√≥n de las dependencias del proyecto.  Usando el indicador <code>NODE_ENV</code> (o si la <code>NODE_ENV</code> entorno <code>NODE_ENV</code> establecida en <code>production</code> ) npm no instalar√° los m√≥dulos listados en la secci√≥n <code>devDependencies</code> del archivo <code>devDependencies</code> . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   COPY package*.json ./ RUN npm install #     # RUN npm install --production</span></span></code> </pre> <br>  Aqu√≠ estamos copiando el <code>package*.json</code> a la imagen, en lugar de, por ejemplo, copiar todos los archivos del proyecto.  Hacemos eso precisamente porque las instrucciones Dockerfile <code>RUN</code> , <code>COPY</code> y <code>ADD</code> crean capas de im√°genes adicionales, por lo que puede usar las funciones de almacenamiento en cach√© de las capas de la plataforma Docker.  Con este enfoque, la pr√≥xima vez que recopilemos una imagen similar, Docker descubrir√° si es posible reutilizar las capas de im√°genes que ya est√°n en el cach√© y, de ser as√≠, aprovechar√° lo que ya est√° all√≠, en lugar de crear otras nuevas. capas  Esto le permite ahorrar mucho tiempo al ensamblar capas en el curso del trabajo en proyectos grandes, que incluyen muchos m√≥dulos npm. <br><br>  Ahora copie los archivos del proyecto al directorio de trabajo actual.  Aqu√≠ no usaremos la instrucci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ADD</a> , sino la instrucci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">COPY</a> .  De hecho, en la mayor√≠a de los casos se recomienda dar preferencia a la instrucci√≥n <code>COPY</code> . <br><br>  La instrucci√≥n <code>ADD</code> , en comparaci√≥n con <code>COPY</code> , tiene algunas caracter√≠sticas que, sin embargo, no siempre son necesarias.  Por ejemplo, estamos hablando de opciones para desempaquetar archivos .tar y descargar archivos por URL. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#    COPY . .</span></span></code> </pre> <br>  Los contenedores Docker son entornos aislados.  Esto significa que cuando lancemos la aplicaci√≥n en el contenedor, no podremos interactuar con ella directamente sin abrir el puerto en el que escucha esta aplicaci√≥n.  Para informar a Docker que hay una aplicaci√≥n en un determinado contenedor que escucha en un determinado puerto, puede usar la instrucci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">EXPOSE</a> . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   ,      EXPOSE 3000</span></span></code> </pre> <br>  Hasta la fecha, nosotros, utilizando el Dockerfile, hemos descrito la imagen que contendr√° la aplicaci√≥n y todo lo que necesita para iniciarse con √©xito.  Ahora agregue las instrucciones al archivo que le permite iniciar la aplicaci√≥n.  Esta es una instrucci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CMD</a> .  Le permite especificar un determinado comando con par√°metros que se ejecutar√°n cuando se inicie el contenedor y, si es necesario, pueden ser anulados por las herramientas de l√≠nea de comandos. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   CMD ["npm", "start"]</span></span></code> </pre> <br>  As√≠ se ver√° el Dockerfile terminado: <br><br><pre> <code class="bash hljs">FROM node:8 <span class="hljs-comment"><span class="hljs-comment">#   ARG APP_DIR=app RUN mkdir -p ${APP_DIR} WORKDIR ${APP_DIR} #   COPY package*.json ./ RUN npm install #     # RUN npm install --production #    COPY . . #   ,      EXPOSE 3000 #   CMD ["npm", "start"]</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Asamblea de imagen</font> </h2><br>  Hemos preparado un archivo Dockerfile que contiene instrucciones para construir la imagen, sobre la base de la cual se crear√° un contenedor con una aplicaci√≥n en ejecuci√≥n.  Ensamble la imagen ejecutando un comando de la siguiente forma: <br><br><pre> <code class="bash hljs">docker build --build-arg &lt;build arguments&gt; -t &lt;user-name&gt;/&lt;image-name&gt;:&lt;tag-name&gt; /path/to/Dockerfile</code> </pre> <br>  En nuestro caso, se ver√° as√≠: <br><br><pre> <code class="bash hljs">docker build --build-arg APP_DIR=var/app -t ankitjain28may/node-app:V1 .</code> </pre> <br>  Dockerfile tiene una declaraci√≥n <code>ARG</code> que describe el argumento <code>APP_DIR</code> .  Aqu√≠ establecemos su significado.  Si esto no se hace, tomar√° el valor que se le asigna en el archivo, es decir, la <code>app</code> . <br><br>  Despu√©s de ensamblar la imagen, verifique si Docker la ve.  Para hacer esto, ejecute el siguiente comando: <br><br><pre> <code class="bash hljs">docker images</code> </pre> <br>  En respuesta a este comando, se debe generar aproximadamente lo siguiente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51d/c22/3e0/51dc223e0030bb0275c3d61fa01562e5.png"></div><br>  <i><font color="#999999">Im√°genes de Docker</font></i> <br><br><h2>  <font color="#3AC1EF">Lanzamiento de imagen</font> </h2><br>  Despu√©s de haber ensamblado la imagen de Docker, podemos ejecutarla, es decir, crear una instancia de ella, representada por un contenedor de trabajo.  Para hacer esto, use un comando de este tipo: <br><br><pre> <code class="bash hljs">docker run -p &lt;External-port:exposed-port&gt; -d --name &lt;name of the container&gt; &lt;user-name&gt;/&lt;image-name&gt;:&lt;tag-name&gt;</code> </pre> <br>  En nuestro caso, se ver√° as√≠: <br><br><pre> <code class="bash hljs">docker run -p 8000:3000 -d --name node-app ankitjain28may/node-app:V1</code> </pre> <br>  Le pediremos al sistema informaci√≥n sobre contenedores que funcionan con este comando: <br><br><pre> <code class="bash hljs">docker ps</code> </pre> <br>  En respuesta a esto, el sistema deber√≠a generar algo como lo siguiente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87f/bc0/fcf/87fbc0fcf1bdeecef051e2874d48d91e.png"></div><br>  <i><font color="#999999">Contenedores Docker</font></i> <br><br>  Hasta ahora, todo va como se esperaba, aunque a√∫n no hemos intentado acceder a la aplicaci√≥n que se ejecuta en el contenedor.  A saber, nuestro contenedor, denominado <code>node-app</code> , escucha en el puerto <code>8000</code> .  Para intentar acceder a √©l, puede abrir un navegador y acceder a √©l en <code>localhost:8000</code> .  Adem√°s, para verificar el estado del contenedor, puede usar el siguiente comando: <br><br><pre> <code class="bash hljs">curl -i localhost:8000</code> </pre> <br>  Si el contenedor realmente funciona, se devolver√° algo como el que se muestra en la siguiente figura en respuesta a este comando. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea4/407/9ba/ea44079bab09d56c402af3c58eb6a638.png"></div><br>  <i><font color="#999999">Resultado del control de salud del contenedor</font></i> <br><br>  Sobre la base de la misma imagen, por ejemplo, sobre la base de reci√©n creado, es posible crear muchos contenedores.  Adem√°s, puede enviar nuestra imagen al registro de Docker Hub, lo que permitir√° a otros desarrolladores cargar nuestra imagen y lanzar los contenedores apropiados en casa.  Este enfoque simplifica el trabajo con proyectos. <br><br><h2>  <font color="#3AC1EF">Recomendaciones</font> </h2><br>  Aqu√≠ hay algunas sugerencias que vale la pena considerar para aprovechar el poder de Docker y crear im√°genes tan compactas como sea posible. <br><br><h3>  <font color="#3AC1EF">‚ñç1.</font>  <font color="#3AC1EF">Siempre cree un archivo .dockerignore</font> </h3><br>  En la carpeta del proyecto que planea colocar en el contenedor, siempre necesita crear un archivo <code>.dockerignore</code> .  Le permite ignorar archivos y carpetas que no son necesarios al construir la imagen.  Con este enfoque, podemos reducir el llamado contexto de construcci√≥n, que nos permitir√° ensamblar r√°pidamente la imagen y reducir su tama√±o.  Este archivo admite plantillas de nombre de archivo, en este caso es similar a un archivo <code>.gitignore</code> .  Se recomienda agregar un comando a <code>.dockerignore</code> debido a que Docker ignorar√° la carpeta <code>/.git</code> , ya que esta carpeta generalmente contiene materiales grandes (especialmente durante el desarrollo de un proyecto) y agregarla a la imagen conduce a un aumento en su tama√±o.  Adem√°s, copiar esta carpeta en una imagen no tiene mucho sentido. <br><br><h3>  <font color="#3AC1EF">‚ñç2.</font>  <font color="#3AC1EF">Utilice el proceso de ensamblaje de im√°genes en varias etapas</font> </h3><br>  Considere el ejemplo cuando recopilamos un proyecto para una determinada organizaci√≥n.  Este proyecto utiliza muchos paquetes npm, y cada uno de estos paquetes puede instalar paquetes adicionales de los que depende.  La realizaci√≥n de todas estas operaciones lleva a un tiempo adicional dedicado al proceso de ensamblar la imagen (aunque esto, gracias a las capacidades de almacenamiento en cach√© de Docker, no es tan importante).  Peor a√∫n, la imagen resultante que contiene las dependencias de un determinado proyecto es bastante grande.  Aqu√≠, si hablamos de proyectos front-end, podemos recordar que dichos proyectos generalmente se procesan utilizando paquetes como webpack, que permiten empaquetar convenientemente todo lo que una aplicaci√≥n necesita en un paquete de ventas.  Como resultado, los archivos de paquete npm para dicho proyecto son innecesarios.  Y esto significa que podemos deshacernos de dichos archivos despu√©s de construir el proyecto usando el mismo paquete web. <br><br>  Armado con esta idea, intente hacer esto: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   COPY package*.json ./ RUN npm install --production # - COPY . . RUN npm run build:production #    npm- RUN rm -rf node_modules</span></span></code> </pre> <br>  Tal enfoque, sin embargo, no nos conviene.  Como ya dijimos, las instrucciones <code>RUN</code> , <code>ADD</code> y <code>COPY</code> crean capas almacenadas en cach√© por Docker, por lo que debemos encontrar una manera de manejar la instalaci√≥n de dependencias, construir el proyecto y luego eliminar archivos innecesarios con un solo comando.  Por ejemplo, podr√≠a verse as√≠: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#      COPY . . #  ,      RUN npm install --production &amp;&amp; npm run build:production &amp;&amp; rm -rf node_module</span></span></code> </pre> <br>  En este ejemplo, solo hay una instrucci√≥n <code>RUN</code> que instala las dependencias, <code>node_modules</code> proyecto y elimina la carpeta <code>node_modules</code> .  Esto lleva al hecho de que el tama√±o de la imagen no ser√° tan grande como el tama√±o de la imagen que incluye la carpeta <code>node_modules</code> .  Usamos los archivos de esta carpeta solo durante el proceso de compilaci√≥n del proyecto y luego lo eliminamos.  Es cierto que este enfoque es malo, ya que lleva mucho tiempo instalar dependencias npm.  Puede eliminar este inconveniente utilizando la tecnolog√≠a de ensamblaje de im√°genes en varias etapas. <br><br>  Imagine que estamos trabajando en un proyecto frontend que tiene muchas dependencias, y usamos webpack para construir este proyecto.  Con este enfoque, podemos, en aras de reducir el tama√±o de la imagen, aprovechar las capacidades de Docker para el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ensamblaje de im√°genes</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">varias etapas</a> . <br><br><pre> <code class="bash hljs">FROM node:8 As build <span class="hljs-comment"><span class="hljs-comment">#  RUN mkdir /app &amp;&amp; mkdir /src WORKDIR /src #   COPY package*.json ./ RUN npm install #     # RUN npm install --production #       COPY . . RUN npm run build:production #    ,     FROM node:alpine #      build   app COPY --from=build ./src/build/* /app/ ENTRYPOINT ["/app"] CMD ["--help"]</span></span></code> </pre> <br>  Con este enfoque, la imagen resultante es mucho m√°s peque√±a que la imagen anterior, y tambi√©n utilizamos el <code>node:alpine</code> imagen <code>node:alpine</code> , que es muy peque√±a.  Y aqu√≠ hay una comparaci√≥n de un par de im√°genes, durante las cuales se puede ver que la imagen del <code>node:alpine</code> mucho m√°s peque√±a que la imagen del <code>node:8</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/565/c80/c3b/565c80c3bb0498e0ebcdf53022bdab6e.png"></div><br>  <i><font color="#999999">Comparaci√≥n de im√°genes del repositorio de nodos</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñç3.</font>  <font color="#3AC1EF">Usar cach√© de Docker</font> </h3><br>  Esfu√©rcese por utilizar las capacidades de almacenamiento en cach√© de Docker para crear sus im√°genes.  Ya prestamos atenci√≥n a esta caracter√≠stica cuando trabajamos con un archivo al que se accedi√≥ mediante el <code>package*.json</code> nombres <code>package*.json</code> .  Esto reduce el tiempo de construcci√≥n de la imagen.  Pero esta oportunidad no se debe usar precipitadamente. <br><br>  Supongamos que describimos en Dockerfile la instalaci√≥n de paquetes en una imagen creada a partir de la imagen base de <code>Ubuntu:16.04</code> : <br><br><pre> <code class="bash hljs">FROM ubuntu:16.04 RUN apt-get update &amp;&amp; apt-get install -y \   curl \   package-1 \   .   .</code> </pre> <br>  Cuando el sistema procesar√° este archivo, si hay muchos paquetes instalados, las operaciones de actualizaci√≥n e instalaci√≥n tomar√°n mucho tiempo.  Para mejorar la situaci√≥n, decidimos aprovechar las capacidades de almacenamiento en cach√© de capas de Docker y reescribimos el Dockerfile de la siguiente manera: <br><br><pre> <code class="bash hljs">FROM ubuntu:16.04 RUN apt-get update RUN apt-get install -y \   curl \   package-1 \   .   .</code> </pre> <br>  Ahora, al ensamblar la imagen por primera vez, todo sale como deber√≠a, ya que el cach√© a√∫n no se ha formado.  Imagine ahora que necesitamos instalar otro paquete, <code>package-2</code> .  Para hacer esto, reescribimos el archivo: <br><br><pre> <code class="bash hljs">FROM ubuntu:16.04 RUN apt-get update RUN apt-get install -y \   curl \   package-1 \   package-2 \   .   .</code> </pre> <br>  Como resultado de dicho comando, <code>package-2</code> no se instalar√° ni actualizar√°.  Por qu√©  El hecho es que al ejecutar la instrucci√≥n <code>RUN apt-get update</code> , Docker no ve ninguna diferencia entre esta instrucci√≥n y la instrucci√≥n ejecutada anteriormente, como resultado, toma datos del cach√©.  Y estos datos ya est√°n desactualizados.  Al procesar la instrucci√≥n <code>RUN apt-get install</code> sistema la ejecuta, ya que no parece una instrucci√≥n similar en el Dockerfile anterior, pero durante la instalaci√≥n, pueden producirse errores o se instalar√° la versi√≥n anterior de los paquetes.  Como resultado, resulta que los comandos de <code>update</code> e <code>install</code> deben ejecutarse dentro de la misma instrucci√≥n <code>RUN</code> , como se hace en el primer ejemplo.  El almacenamiento en cach√© es una gran caracter√≠stica, pero el uso imprudente de esta caracter√≠stica puede generar problemas. <br><br><h3>  <font color="#3AC1EF">‚ñç4.</font>  <font color="#3AC1EF">Minimiza el n√∫mero de capas de imagen</font> </h3><br>  Se recomienda, siempre que sea posible, esforzarse por minimizar el n√∫mero de capas de imagen, ya que cada capa es el sistema de archivos de la imagen Docker, lo que significa que cuanto m√°s peque√±as sean las capas en la imagen, m√°s compacta ser√°.  Cuando se usa el proceso de m√∫ltiples etapas de ensamblar im√°genes, se logra una reducci√≥n en el n√∫mero de capas en la imagen y una disminuci√≥n en el tama√±o de la imagen. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  En este art√≠culo, analizamos el proceso de empaquetar aplicaciones Node.js en contenedores Docker y trabajar con dichos contenedores.  Adem√°s, hicimos algunas recomendaciones que, por cierto, pueden usarse no solo al crear contenedores para proyectos de Node.js. <br><br>  <b>Estimados lectores!</b>  Si utiliza Docker profesionalmente cuando trabaja con proyectos Node.js, comparta recomendaciones sobre el uso efectivo de este sistema con principiantes. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/440656/">https://habr.com/ru/post/440656/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../440646/index.html">Frontend Weekly Digest (11-17 de febrero de 2019)</a></li>
<li><a href="../440648/index.html">Descripci√≥n general de la legislaci√≥n rusa en el campo de la accesibilidad web</a></li>
<li><a href="../440650/index.html">C√≥mo funciona la conciencia: conclusiones del libro de Alexander Nevzorov</a></li>
<li><a href="../440652/index.html">Video computarizado en 755 megap√≠xeles: ple√≥pticos ayer, hoy y ma√±ana</a></li>
<li><a href="../440654/index.html">Python de aprendizaje: m√≥dulo argparse</a></li>
<li><a href="../440658/index.html">Explorando Docker, Parte 4: Reduciendo el tama√±o de las im√°genes y acelerando su ensamblaje</a></li>
<li><a href="../440660/index.html">Aprendizaje Docker, Parte 5: Comandos</a></li>
<li><a href="../440662/index.html">Tutorial React Parte 18: La sexta fase de trabajar en una aplicaci√≥n TODO</a></li>
<li><a href="../440666/index.html">Clasificaci√≥n de dibujos escritos a mano. Informar en Yandex</a></li>
<li><a href="../440670/index.html">El Banco Central public√≥ recomendaciones sobre la protecci√≥n criptogr√°fica de EBS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>