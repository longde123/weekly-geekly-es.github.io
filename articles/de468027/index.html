<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õπüèª üçõ üèà Codeoptimierungsmethoden f√ºr Redd. Teil 2: Nicht zwischenspeicherbarer Speicher und paralleler Busbetrieb üßóüèø ü•ó üë©üèæ‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im letzten Artikel haben wir herausgefunden, dass der Cache sicherlich eine n√ºtzliche Sache ist, aber in Bezug auf die Controller-Logik f√ºhrt dies man...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Codeoptimierungsmethoden f√ºr Redd. Teil 2: Nicht zwischenspeicherbarer Speicher und paralleler Busbetrieb</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468027/">  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzten Artikel haben</a> wir herausgefunden, dass der Cache sicherlich eine n√ºtzliche Sache ist, aber in Bezug auf die Controller-Logik f√ºhrt dies manchmal zu Schwierigkeiten.  Insbesondere f√ºhrt dies zu einer Unvorhersehbarkeit von Impulsdauern oder anderen Verz√∂gerungen bei der programmatischen Erstellung von Zeitdiagrammen.  Nun, und im "allgemeinen programmatischen" Plan kann die schlechte Position der Funktion die Verst√§rkung aus dem Cache auf nichts reduzieren und ihn st√§ndig dazu veranlassen, aus einem langsamen Speicher neu zu starten.  Ich erw√§hnte, dass wir vor 15 Jahren einen speziellen Pr√§prozessor herstellen mussten, der die f√ºr den SPARC-8-Prozessor auftretenden Probleme behebt, und versprach zu erkl√§ren, wie einfach es sein w√ºrde, solche Schwierigkeiten bei der Entwicklung eines synthetisierten Nios II-Prozessors zu beheben, der f√ºr die Verwendung im Redd-Paket empfohlen wird.  Es ist an der Zeit, das Versprechen zu erf√ºllen. <br><br><img src="https://habrastorage.org/webt/pr/sx/ix/prsxixkamqwdpusqqagnx0xnh1q.png"><br><a name="habracut"></a><br><h4>  Fr√ºhere Artikel in der Reihe: </h4><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung der einfachsten ‚ÄûFirmware‚Äú f√ºr in Redd installierte FPGAs und Debugging am Beispiel des Speichertests.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung der einfachsten ‚ÄûFirmware‚Äú f√ºr in Redd installierte FPGAs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2. Programmcode.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung eines eigenen Kerns zur Einbettung in ein FPGA-basiertes Prozessorsystem.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung von Programmen f√ºr den Zentralprozessor Redd am Beispiel des Zugriffs auf das FPGA.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die ersten Experimente am Streaming-Protokoll am Beispiel der Verbindung von CPU und Prozessor im FPGA des Redd-Komplexes.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Merry Quartusel oder wie der Prozessor zu einem solchen Leben gekommen ist.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codeoptimierungsmethoden f√ºr Redd.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1: Cache-Effekt.</a> </li></ol><br>  Unser Nachschlagewerk wird heute das <b>Embedded Design Handbook</b> bzw. Abschnitt <b>7.5 sein.</b>  <b>Verwenden des eng gekoppelten Speichers mit dem Nios II-Prozessor-Lernprogramm</b> .  Der Abschnitt selbst ist bunt.  Heute entwerfen wir Prozessorsysteme f√ºr Intel FPGAs im Programm Platform Designer.  In den Tagen von Altera hie√ü es QSys (daher die Erweiterung <b>.qsys</b> der Projektdatei).  Bevor QSsys erschien, benutzte jeder seinen Vorfahren, den <b>SOPC</b> Builder (in dessen Speicher die <b>Dateierweiterung .sopcinfo verblieben war</b> ).  Obwohl das Dokument mit dem Intel-Logo gekennzeichnet ist, handelt es sich bei den darin enthaltenen Bildern um Screenshots dieses SOPC Builder.  Es wurde vor mehr als zehn Jahren klar geschrieben, und seitdem wurden nur Begriffe darin korrigiert.  Die Texte sind zwar recht modern, daher ist dieses Dokument als Schulungshandbuch sehr n√ºtzlich. <br><br><h2>  Ger√§tevorbereitung </h2><br>  Also.  Wir m√∂chten unserem spartanischen Prozessorsystem Speicher hinzuf√ºgen, der niemals zwischengespeichert wird und gleichzeitig mit der h√∂chstm√∂glichen Geschwindigkeit ausgef√ºhrt wird.  Dies wird nat√ºrlich der interne FPGA-Speicher sein.  Wir werden Speicher f√ºr Code und Daten hinzuf√ºgen, aber dies sind verschiedene Bl√∂cke.  Beginnen wir mit dem Datenspeicher als dem einfachsten.  Wir <b>f√ºgen</b> dem System <b>den</b> bereits bekannten <b>OnChip-Speicher hinzu</b> . <br><br><img src="https://habrastorage.org/webt/4g/vv/nx/4gvvnxooo_8rfteiku1wm4l6yr8.png"><br><br>  Nehmen wir an, das Volumen betr√§gt 2 Kilobyte (das Hauptproblem des internen Speichers des FPGA besteht darin, dass er klein ist, sodass Sie ihn speichern m√ºssen).  Der Rest ist gew√∂hnliche Erinnerung, die wir bereits hinzugef√ºgt haben. <br><br><img src="https://habrastorage.org/webt/jd/et/sj/jdetsj-2tvd6ou6xdr_rzggote4.png"><br><br>  Wir werden es aber nicht an den Datenbus anschlie√üen, sondern an einen speziellen Bus.  Um es erscheinen zu lassen, gehen wir in die Prozessoreigenschaften, gehen zur Registerkarte <b>Caches und Speicherschnittstellen</b> und w√§hlen in der Auswahlliste <b>Anzahl der eng zusammengew√ºrfelten Datenmaster-Ports</b> den Wert 1 aus. <br><br><img src="https://habrastorage.org/webt/bt/rj/m4/btrjm4ihtix-btomqh6ttgyjifs.png"><br><br>  Hier ist ein neuer Port f√ºr den Prozessor: <br><br><img src="https://habrastorage.org/webt/lm/j7/xu/lmj7xu6jk4lofwv9kdmdi1m4--u.png"><br><br>  Wir haben k√ºrzlich den neu hinzugef√ºgten Speicherblock damit verbunden! <br><br><img src="https://habrastorage.org/webt/ea/vf/t_/eavft_i05i9qb9sn5duyrxvgyda.png"><br><br>  Ein weiterer Trick besteht darin, diesem neuen Speicher Adressen zuzuweisen.  Das Dokument enth√§lt eine lange Reihe von √úberlegungen zur Optimalit√§t der Adressdecodierung.  Es besagt, dass nicht zwischengespeicherter Speicher von allen anderen Speichertypen durch ein klar ausgedr√ºcktes Bit der Adresse unterschieden werden muss.  Daher geh√∂rt im Dokument der gesamte nicht zwischenspeicherbare Speicher zum Bereich 0x2XXXXXXX.  Geben Sie also die Adresse 0x2000000 manuell ein und sperren Sie sie, damit sie sich bei den folgenden automatischen Zuweisungen nicht √§ndert. <br><br><img src="https://habrastorage.org/webt/nf/l3/qn/nfl3qn1zegllimprcc6xtol3yim.png"><br><br>  <b>Benennen</b> Sie den Block aus rein √§sthetischen <b>Gr√ºnden</b> um ... Nennen wir ihn beispielsweise <b>NonCachedData</b> . <br><br><img src="https://habrastorage.org/webt/7z/l-/8p/7zl-8pvknmn3thqgvx7cahpzzw8.png"><br><br>  Mit Hardware f√ºr nicht zwischengespeicherten Datenspeicher ist es soweit.  Wir √ºbergeben den Speicher zur Codespeicherung.  Hier ist fast alles gleich, aber etwas komplizierter.  Tats√§chlich kann alles vollst√§ndig identisch ausgef√ºhrt werden, nur der Bus-Master-Port wird in der Liste <b>Anzahl eng zusammengew√ºrfelter Befehls-Master-Ports</b> ge√∂ffnet, es ist jedoch nicht m√∂glich, ein solches System zu debuggen.  Wenn das Programm mit dem Debugger gef√ºllt ist, flie√üt es dort durch den Datenbus.  Beim Anhalten wird der zerlegte Code auch vom Debugger √ºber den Datenbus gelesen.  Und selbst wenn das Programm von einem externen Loader geladen wird (wir haben eine solche Methode noch nicht in Betracht gezogen, zumal wir in der kostenlosen Version der Entwicklungsumgebung nur mit dem angeschlossenen JTAG-Debugger arbeiten m√ºssen, aber im Allgemeinen verbietet dies niemand), geht die F√ºllung auch √ºber den Bus Daten.  Daher muss der Speicher Dual-Port ausf√ºhren.  Schlie√üen Sie an einen Port einen nicht zwischengespeicherten Anweisungsassistenten an, der in der Hauptzeit arbeitet, und an den anderen - einen zus√§tzlichen Vollzeitdatenbus.  Es wird verwendet, um das Programm von au√üen herunterzuladen und den RAM-Inhalt vom Debugger abzurufen.  Der Rest der Zeit wird dieser Reifen im Leerlauf sein.  So sieht alles im theoretischen Teil des Dokuments aus: <br><br><img src="https://habrastorage.org/webt/ks/sv/vt/kssvvtij9hdnujtgehodhaqwjmu.png"><br><blockquote>  Beachten Sie, dass das Dokument nicht erkl√§rt, warum, aber es wird angemerkt, dass selbst mit Dual-Port-Speicher nur ein Port mit einem nicht zwischengespeicherten Master verbunden werden kann.  Der zweite sollte an das √úbliche angeschlossen werden. </blockquote>  F√ºgen wir 8 Kilobyte Speicher hinzu, machen Sie es zu einem Dual-Port, lassen Sie den Rest standardm√§√üig: <br><br><img src="https://habrastorage.org/webt/kl/1q/_k/kl1q_kgyv67kvcjjzyiw-obrrm4.png"><br><br>  F√ºgen Sie dem Prozessor einen nicht zwischenspeicherbaren Anweisungsport hinzu: <br><br><img src="https://habrastorage.org/webt/tk/ib/2y/tkib2ydvc6f_lfi9nprwkzai0cu.png"><br><br>  Wir nennen den Speicher <b>NonCachedCode</b> , verbinden den Speicher mit den Bussen, weisen ihm die Adresse 0x20010000 zu und sperren ihn (f√ºr beide Ports).  Insgesamt bekommen wir so etwas: <br><br><img src="https://habrastorage.org/webt/84/1d/o_/841do_ssmf-r_a4ibqdyr2kksly.png"><br><br>  Das ist alles.  Wir speichern und generieren das System, sammeln das Projekt.  Die Hardware ist bereit.  Wir gehen zum Software-Teil √ºber. <br><br><h2>  Vorbereitung von BSP im Software-Teil </h2><br>  Normalerweise w√§hlen <b>Sie</b> nach dem √Ñndern des Prozessorsystems einfach den Men√ºpunkt <b>BSP generieren aus</b> , aber heute m√ºssen wir den BSP-Editor √∂ffnen.  Da wir dies selten tun, m√∂chte ich Sie daran erinnern, wo sich der entsprechende Men√ºpunkt befindet: <br><br><img src="https://habrastorage.org/webt/x4/nk/ub/x4nkubzhbxq26krtzce8nhuxmcw.png"><br><br>  Dort gehen wir zur Registerkarte <b>Linker Script</b> .  Wir sehen, dass wir Regionen hinzugef√ºgt haben, die Namen von RAM-Bl√∂cken erben: <br><br><img src="https://habrastorage.org/webt/qs/_t/af/qs_taf1wiql9vccnl_7s_frbqci.png"><br><br>  Ich werde zeigen, wie man einen Abschnitt hinzuf√ºgt, in dem der Code platziert wird.  Klicken Sie im Abschnitt auf Hinzuf√ºgen: <br><br><img src="https://habrastorage.org/webt/qa/8o/lu/qa8olur0jjxjhj2oz-dqwzmf3iy.png"><br><br>  Geben Sie im angezeigten Fenster den Namen des Abschnitts an (um Verwirrung im Artikel zu vermeiden, benenne ich ihn ganz anders als den Namen der Region, n√§mlich nccode) und ordne ihn der Region zu (ich habe <b>NonCachedCode</b> aus der Liste ausgew√§hlt): <br><br><img src="https://habrastorage.org/webt/ji/eo/to/jieotoad61gc1i-xarabcynmqyy.png"><br><br>  Das war's, generiere den BSP und schlie√üe den Editor. <br><br><h2>  Platzieren von Code in einem neuen Speicherbereich </h2><br>  Ich m√∂chte Sie daran erinnern, dass das Programm zwei Funktionen enth√§lt, die vom vorherigen Artikel √ºbernommen wurden: <b>MagicFunction1 ()</b> und <b>MagicFunction2 ()</b> .  Beim ersten Durchgang luden beide ihre K√∂rper in den Cache, der auf dem Oszilloskop sichtbar war.  Au√üerdem arbeiteten sie je nach Umgebungssituation entweder mit maximaler Geschwindigkeit oder rieben sich st√§ndig mit ihren K√∂rpern, was zu st√§ndigen Downloads von SDRAM f√ºhrte. <br><br>  Verschieben wir die erste Funktion in ein neues nicht zwischengespeichertes Segment, lassen die zweite an Ort und Stelle und f√ºhren dann einige L√§ufe durch. <br><blockquote>  F√ºgen Sie das <b>Abschnittsattribut</b> hinzu, um eine Funktion in einem neuen Abschnitt zu platzieren. </blockquote>  Bevor wir die <b>MagicFunction1 ()</b> -Funktion definieren, platzieren <b>wir</b> ihre Deklaration auch mit diesem Attribut: <br><br><pre><code class="plaintext hljs">void MagicFunction1()__attribute__ ((section("nccode"))); void MagicFunction1() { IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); ...</code> </pre> <br>  Wir f√ºhren den ersten Durchlauf einer Iteration der Schleife durch (ich habe einen Haltepunkt auf die while-Zeile gesetzt): <br><pre> <code class="plaintext hljs"> while (1) { MagicFunction1(); MagicFunction2(); }</code> </pre><br>  Wir sehen folgendes Ergebnis: <br><br><img src="https://habrastorage.org/webt/vh/1q/jx/vh1qjxzrvwbudd99po6eerz47ja.png"><br><br>  Wie Sie sehen k√∂nnen, wird die erste Funktion wirklich mit maximaler Geschwindigkeit ausgef√ºhrt, die zweite wird aus dem SDRAM geladen.  F√ºhren Sie den zweiten Lauf aus: <br><br><img src="https://habrastorage.org/webt/l9/ce/iv/l9ceivh_xyn8ip_xtyqv18u4i2a.png"><br><br>  Beide Funktionen arbeiten mit maximaler Geschwindigkeit.  Und die erste Funktion entl√§dt die zweite nicht aus dem Cache, obwohl zwischen ihnen die Einf√ºgung ist, die ich nach dem Schreiben des letzten Artikels hinterlassen habe: <br><br><pre> <code class="plaintext hljs">volatile void FuncBetween() { Nops256 Nops256 Nops256 Nops64 Nops64 Nops64 Nops16 Nops16 }</code> </pre><br>  Diese Einf√ºgung wirkt sich nicht mehr auf die relative Position der beiden Funktionen aus, da die erste in einem v√∂llig anderen Speicherbereich verbleibt. <br><br><h2>  Ein paar Worte zu Daten </h2><br>  In √§hnlicher Weise k√∂nnen Sie einen Abschnitt mit nicht zwischengespeicherten Daten erstellen und dort globale Variablen platzieren, indem Sie ihnen dasselbe Attribut zuweisen. Um jedoch Platz zu sparen, werde ich solche Beispiele nicht nennen. <br><br>  Wir haben eine Region f√ºr diesen Speicher erstellt. Die Zuordnung zum Abschnitt kann auf die gleiche Weise wie f√ºr den Codeabschnitt erfolgen.  Es bleibt nur zu verstehen, wie das entsprechende Attribut einer Variablen zugewiesen wird.  Hier ist das erste Beispiel f√ºr die Deklaration solcher Daten, die im Darm von automatisch generiertem Code gefunden wurden: <br><br><pre> <code class="plaintext hljs">volatile alt_u32 alt_log_boot_on_flag \ __attribute__ ((section (".sdata"))) = ALT_LOG_BOOT_ON_FLAG_SETTING;</code> </pre><br><h2>  Was gibt es uns? </h2><br>  Nun, eigentlich aus offensichtlichen Gr√ºnden: Jetzt k√∂nnen wir den Hauptteil des Codes in SDRAM platzieren und im nicht zwischenspeicherbaren Abschnitt jene Funktionen ausgeben, die programmgesteuert Zeitdiagramme bilden oder deren Leistung maximal sein sollte, was bedeutet, dass sie aufgrund von nicht verlangsamt werden sollten dass eine andere Funktion st√§ndig den entsprechenden Code aus dem Cache speichert. <br><br><h2>  Schauen Sie sich die Reifen genau an. </h2><br>  Schauen Sie sich nun die Reifen im resultierenden Prozessorsystem genau an.  Wir haben fast vier davon.  Ich kreiste rot um den Hauptbus (was die Vereinigung der beiden ist, weshalb ich ‚Äûfast‚Äú schrieb: physisch - es gibt zwei Reifen, aber logischerweise - einen).  Ich habe den Bus, der zum nicht zwischengespeicherten Befehlsspeicher f√ºhrt, gr√ºn hervorgehoben, blau - zum nicht zwischengespeicherten Datenspeicher.  <b>Diese drei Reifen arbeiten parallel und unabh√§ngig voneinander!</b> <br><br><img src="https://habrastorage.org/webt/kg/rv/wf/kgrvwfw1kncypo4x6mn4uehagng.png"><br><br>  Denken Sie daran, dass ich in dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel √ºber DMA</a> argumentiert habe, dass einer der leistungsbeschr√§nkenden Faktoren darin besteht, dass die Daten auf demselben Bus √ºbertragen werden.  Der DMA-Block liest Daten vom Bus, schreibt Daten darauf, und selbst zur gleichen Zeit verwendet der Prozessorkern denselben Bus.  Wie Sie sehen k√∂nnen, wird dieser Nachteil geschlossener Systeme im FPGA vollst√§ndig beseitigt.  Bei vorgefertigten Steuerungen sind Hersteller beim Verlegen von Verbindungen gezwungen, zwischen Anforderungen und F√§higkeiten zu wechseln.  Der Programmierer ben√∂tigt diese Option m√∂glicherweise.  Und so.  Und so.  Und so ... M√∂glicherweise sind viele Dinge erforderlich.  Aber Ressourcen kosten Geld und auf dem ausgew√§hlten Kristall ist nicht immer genug Platz f√ºr sie.  Sie k√∂nnen nicht alles posten.  Wir m√ºssen entscheiden, was jeder wirklich braucht und was in Einzelf√§llen ben√∂tigt wird.  Und welche Einzelf√§lle sollten eingef√ºhrt und welche vergessen werden.  Und dann erscheinen Kompromissl√∂sungen, deren Feinheiten der Programmierer ber√ºcksichtigen muss, wenn er sie verwenden m√∂chte.  In unserem Fall k√∂nnen wir ohne weiteres handeln.  Was wir heute brauchen, ist heute gelegt.  Unsere Ressource ist flexibel.  Wir geben es aus, damit die Ausr√ºstung f√ºr unsere heutige Aufgabe optimal ist.  F√ºr die Aufgaben von morgen und gestern m√ºssen keine Ressourcen reserviert werden.  In der heutigen Zeit werden wir jedoch alles so einstellen, dass das Programm so effizient wie m√∂glich funktioniert, ohne dass besondere Programmierfreuden erforderlich sind. <br><br>  Es war einmal an einer Universit√§t in einem Kurs √ºber Signalprozessoren, wie man zwei Busse parallel zu einem Team einsetzt.  Soweit ich wei√ü, erm√∂glicht in modernen ARM-Controllern die detaillierte Kenntnis der Busmatrix auch eine Optimierung.  Aber das alles ist gut, wenn ein Entwickler seit Jahren mit demselben System arbeitet.  Wenn Sie von Projekt zu Projekt v√∂llig unterschiedliche Hardwareteile fahren m√ºssen, k√∂nnen Sie sich nicht alles merken.  Bei FPGAs untersuchen wir nicht die Merkmale der Umgebung, sondern k√∂nnen die Umgebung selbst anpassen. <br><blockquote>  In Bezug auf den Ansatz ‚ÄûWir verbringen nicht viel Zeit mit Entwicklung‚Äú klingt dies folgenderma√üen: <br>  Wir m√ºssen keine Anstrengungen unternehmen, um die Verwendung von vorgefertigten Standardreifen zu optimieren. Wir k√∂nnen sie schnell und optimal f√ºr die zu l√∂sende Aufgabe verlegen, diese Hilfsentwicklung schnell abschlie√üen und den Prozess des Debuggens oder Testens des Hauptprojekts schnell sicherstellen. </blockquote>  Schauen wir uns ein Beispiel f√ºr die Aufnahme eines DMA-Blocks aus dem <b>IP-Benutzerhandbuch</b> f√ºr <b>eingebettete Peripherieger√§te</b> an, um das Material zu konsolidieren. <br><br><img src="https://habrastorage.org/webt/ww/hw/yg/wwhwygxdtfoxpuyftp00h2p_xde.png"><br><br>  Wir sehen drei unabh√§ngige Verbindungen.  Eingabedaten (in dieser Abbildung ist es ein auf den Speicher projizierter Bus), Ausgabedaten (in dieser Abbildung ist es ein v√∂llig anderer Bustyp - eine Stream-Schnittstelle) und die Kommunikation mit dem Steuerprozessor.  Niemand st√∂rt sich daran, alles an verschiedene Busse anzuschlie√üen, dann wird die Arbeit parallel verlaufen.  Eingabedaten (z. B. vom SDRAM) werden in einem Stream gespeichert, den niemand st√∂rt.  Die Ausgabe erfolgt in einem anderen Stream, beispielsweise an den FT245-FIFO-Kanal, den wir bereits ber√ºcksichtigt haben.  und der Zentralprozessor frisst nicht von diesen Taktbussen weg, da der Hauptbus isoliert ist.  Obwohl in diesem Fall nat√ºrlich der Speicher im SDRAM, der sich auf einem separaten Bus befindet, programmgesteuert nicht verf√ºgbar ist.  Aber niemand wird verhindern, dass es von DMA gelesen wird.  Wenn das Ziel darin besteht, mit dem Puffer eine hohe Leistung zu erzielen, muss dies um jeden Preis erreicht werden.  Es sei denn, das gesamte Programm muss in den im FPGA integrierten Speicher passen, da die Redd-Hardware keine anderen Speichereinheiten enth√§lt. <br><br>  Um Reifen zu parallelisieren, k√∂nnen Sie auch nicht zwischengespeicherte Reifen verwenden, da wir gesehen haben, dass es mehrere geben kann.  Slaves, die mit diesen Bussen verbunden sind, unterliegen einer Reihe von Einschr√§nkungen: <br><br><ul><li>  der Sklave ist immer einer im Bus; </li><li>  Der Slave verwendet den Busverz√∂gerungsmechanismus nicht. </li><li>  Die Schreiblatenz ist immer Null, die Leselatenz ist immer Eins. </li></ul><br>  Wenn diese Bedingungen erf√ºllt sind, kann ein solches Slave-Ger√§t an einen nicht zwischengespeicherten Bus angeschlossen werden.  Nat√ºrlich wird es h√∂chstwahrscheinlich ein Datenbus sein. <br><br>  Wenn Sie diese Grundprinzipien kennen, k√∂nnen Sie sie im Allgemeinen durchaus f√ºr reale Aufgaben verwenden.  Aber im Allgemeinen k√∂nnen Sie.  Sie k√∂nnen darauf verzichten, wenn das Ergebnis mit herk√∂mmlichen Mitteln erzielt wird.  Aber denken Sie daran.  Manchmal ist die Optimierung eines Systems durch diese Mechanismen einfacher als die Feinabstimmung des Programms. <br><br><h2>  Fazit </h2><br>  Wir haben eine Technik zum √úbertragen von Codeabschnitten untersucht, die f√ºr die Leistung oder die Vorhersagbarkeit der Verarbeitungsausf√ºhrung in einem nicht zwischenspeicherbaren Speicher von entscheidender Bedeutung sind.  Dabei haben wir die M√∂glichkeit einer Leistungsoptimierung durch den Einsatz mehrerer parallel und unabh√§ngig voneinander arbeitender Reifen untersucht. <br><br>  Um das Thema zu beenden, m√ºssen wir noch lernen, wie man die Systemtaktfrequenz erh√∂ht (jetzt ist sie auf die Komponente beschr√§nkt, die Taktimpulse f√ºr den SDRAM-Chip erzeugt).  Da die Artikel jedoch dem Prinzip ‚Äûeins - ein Artikel‚Äú folgen, werden wir dies beim n√§chsten Mal tun. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468027/">https://habr.com/ru/post/de468027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468017/index.html">Die Vielleicht-Monade √ºber Async / Warten in C # (ohne Aufgabe ov!)</a></li>
<li><a href="../de468019/index.html">Website-Entwicklung in WebAssembly mit NetCore 3 und Blazor</a></li>
<li><a href="../de468021/index.html">PHP, wie viel Abstraktion f√ºr die Menschen?</a></li>
<li><a href="../de468023/index.html">K√ºnstliche Intelligenz im Kampfspiel Shadow Fight 3</a></li>
<li><a href="../de468025/index.html">Wie konfiguriere ich SNI in Zimbra OSE?</a></li>
<li><a href="../de468031/index.html">Wir portieren ein Multiplayer-Spiel von C ++ mit Cheerp, WebRTC und Firebase ins Web</a></li>
<li><a href="../de468035/index.html">Laden Sie die Presse mit einem Gamecontroller oder 8 ungew√∂hnlichen Patenten f√ºr Eingabeger√§te herunter</a></li>
<li><a href="../de468039/index.html">Moskau Kubernetes Meetup # 6 bei Acronis (Fiztehpark) 10/03/2019</a></li>
<li><a href="../de468041/index.html">Ank√ºndigung der Kubernetes Web View-Weboberfl√§che (und eine kurze √úbersicht √ºber andere Web-Benutzeroberfl√§chen f√ºr Kubernetes)</a></li>
<li><a href="../de468043/index.html">So erstellen Sie ein UI-Kit, das zum Verkauf steht. Entwicklungsstadien eines kommerziellen Designsystems</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>