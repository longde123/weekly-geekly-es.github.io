<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛹🏻 🍛 🏈 Codeoptimierungsmethoden für Redd. Teil 2: Nicht zwischenspeicherbarer Speicher und paralleler Busbetrieb 🧗🏿 🥗 👩🏾‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im letzten Artikel haben wir herausgefunden, dass der Cache sicherlich eine nützliche Sache ist, aber in Bezug auf die Controller-Logik führt dies man...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Codeoptimierungsmethoden für Redd. Teil 2: Nicht zwischenspeicherbarer Speicher und paralleler Busbetrieb</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468027/">  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzten Artikel haben</a> wir herausgefunden, dass der Cache sicherlich eine nützliche Sache ist, aber in Bezug auf die Controller-Logik führt dies manchmal zu Schwierigkeiten.  Insbesondere führt dies zu einer Unvorhersehbarkeit von Impulsdauern oder anderen Verzögerungen bei der programmatischen Erstellung von Zeitdiagrammen.  Nun, und im "allgemeinen programmatischen" Plan kann die schlechte Position der Funktion die Verstärkung aus dem Cache auf nichts reduzieren und ihn ständig dazu veranlassen, aus einem langsamen Speicher neu zu starten.  Ich erwähnte, dass wir vor 15 Jahren einen speziellen Präprozessor herstellen mussten, der die für den SPARC-8-Prozessor auftretenden Probleme behebt, und versprach zu erklären, wie einfach es sein würde, solche Schwierigkeiten bei der Entwicklung eines synthetisierten Nios II-Prozessors zu beheben, der für die Verwendung im Redd-Paket empfohlen wird.  Es ist an der Zeit, das Versprechen zu erfüllen. <br><br><img src="https://habrastorage.org/webt/pr/sx/ix/prsxixkamqwdpusqqagnx0xnh1q.png"><br><a name="habracut"></a><br><h4>  Frühere Artikel in der Reihe: </h4><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung der einfachsten „Firmware“ für in Redd installierte FPGAs und Debugging am Beispiel des Speichertests.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung der einfachsten „Firmware“ für in Redd installierte FPGAs.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2. Programmcode.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung eines eigenen Kerns zur Einbettung in ein FPGA-basiertes Prozessorsystem.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung von Programmen für den Zentralprozessor Redd am Beispiel des Zugriffs auf das FPGA.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die ersten Experimente am Streaming-Protokoll am Beispiel der Verbindung von CPU und Prozessor im FPGA des Redd-Komplexes.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Merry Quartusel oder wie der Prozessor zu einem solchen Leben gekommen ist.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codeoptimierungsmethoden für Redd.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1: Cache-Effekt.</a> </li></ol><br>  Unser Nachschlagewerk wird heute das <b>Embedded Design Handbook</b> bzw. Abschnitt <b>7.5 sein.</b>  <b>Verwenden des eng gekoppelten Speichers mit dem Nios II-Prozessor-Lernprogramm</b> .  Der Abschnitt selbst ist bunt.  Heute entwerfen wir Prozessorsysteme für Intel FPGAs im Programm Platform Designer.  In den Tagen von Altera hieß es QSys (daher die Erweiterung <b>.qsys</b> der Projektdatei).  Bevor QSsys erschien, benutzte jeder seinen Vorfahren, den <b>SOPC</b> Builder (in dessen Speicher die <b>Dateierweiterung .sopcinfo verblieben war</b> ).  Obwohl das Dokument mit dem Intel-Logo gekennzeichnet ist, handelt es sich bei den darin enthaltenen Bildern um Screenshots dieses SOPC Builder.  Es wurde vor mehr als zehn Jahren klar geschrieben, und seitdem wurden nur Begriffe darin korrigiert.  Die Texte sind zwar recht modern, daher ist dieses Dokument als Schulungshandbuch sehr nützlich. <br><br><h2>  Gerätevorbereitung </h2><br>  Also.  Wir möchten unserem spartanischen Prozessorsystem Speicher hinzufügen, der niemals zwischengespeichert wird und gleichzeitig mit der höchstmöglichen Geschwindigkeit ausgeführt wird.  Dies wird natürlich der interne FPGA-Speicher sein.  Wir werden Speicher für Code und Daten hinzufügen, aber dies sind verschiedene Blöcke.  Beginnen wir mit dem Datenspeicher als dem einfachsten.  Wir <b>fügen</b> dem System <b>den</b> bereits bekannten <b>OnChip-Speicher hinzu</b> . <br><br><img src="https://habrastorage.org/webt/4g/vv/nx/4gvvnxooo_8rfteiku1wm4l6yr8.png"><br><br>  Nehmen wir an, das Volumen beträgt 2 Kilobyte (das Hauptproblem des internen Speichers des FPGA besteht darin, dass er klein ist, sodass Sie ihn speichern müssen).  Der Rest ist gewöhnliche Erinnerung, die wir bereits hinzugefügt haben. <br><br><img src="https://habrastorage.org/webt/jd/et/sj/jdetsj-2tvd6ou6xdr_rzggote4.png"><br><br>  Wir werden es aber nicht an den Datenbus anschließen, sondern an einen speziellen Bus.  Um es erscheinen zu lassen, gehen wir in die Prozessoreigenschaften, gehen zur Registerkarte <b>Caches und Speicherschnittstellen</b> und wählen in der Auswahlliste <b>Anzahl der eng zusammengewürfelten Datenmaster-Ports</b> den Wert 1 aus. <br><br><img src="https://habrastorage.org/webt/bt/rj/m4/btrjm4ihtix-btomqh6ttgyjifs.png"><br><br>  Hier ist ein neuer Port für den Prozessor: <br><br><img src="https://habrastorage.org/webt/lm/j7/xu/lmj7xu6jk4lofwv9kdmdi1m4--u.png"><br><br>  Wir haben kürzlich den neu hinzugefügten Speicherblock damit verbunden! <br><br><img src="https://habrastorage.org/webt/ea/vf/t_/eavft_i05i9qb9sn5duyrxvgyda.png"><br><br>  Ein weiterer Trick besteht darin, diesem neuen Speicher Adressen zuzuweisen.  Das Dokument enthält eine lange Reihe von Überlegungen zur Optimalität der Adressdecodierung.  Es besagt, dass nicht zwischengespeicherter Speicher von allen anderen Speichertypen durch ein klar ausgedrücktes Bit der Adresse unterschieden werden muss.  Daher gehört im Dokument der gesamte nicht zwischenspeicherbare Speicher zum Bereich 0x2XXXXXXX.  Geben Sie also die Adresse 0x2000000 manuell ein und sperren Sie sie, damit sie sich bei den folgenden automatischen Zuweisungen nicht ändert. <br><br><img src="https://habrastorage.org/webt/nf/l3/qn/nfl3qn1zegllimprcc6xtol3yim.png"><br><br>  <b>Benennen</b> Sie den Block aus rein ästhetischen <b>Gründen</b> um ... Nennen wir ihn beispielsweise <b>NonCachedData</b> . <br><br><img src="https://habrastorage.org/webt/7z/l-/8p/7zl-8pvknmn3thqgvx7cahpzzw8.png"><br><br>  Mit Hardware für nicht zwischengespeicherten Datenspeicher ist es soweit.  Wir übergeben den Speicher zur Codespeicherung.  Hier ist fast alles gleich, aber etwas komplizierter.  Tatsächlich kann alles vollständig identisch ausgeführt werden, nur der Bus-Master-Port wird in der Liste <b>Anzahl eng zusammengewürfelter Befehls-Master-Ports</b> geöffnet, es ist jedoch nicht möglich, ein solches System zu debuggen.  Wenn das Programm mit dem Debugger gefüllt ist, fließt es dort durch den Datenbus.  Beim Anhalten wird der zerlegte Code auch vom Debugger über den Datenbus gelesen.  Und selbst wenn das Programm von einem externen Loader geladen wird (wir haben eine solche Methode noch nicht in Betracht gezogen, zumal wir in der kostenlosen Version der Entwicklungsumgebung nur mit dem angeschlossenen JTAG-Debugger arbeiten müssen, aber im Allgemeinen verbietet dies niemand), geht die Füllung auch über den Bus Daten.  Daher muss der Speicher Dual-Port ausführen.  Schließen Sie an einen Port einen nicht zwischengespeicherten Anweisungsassistenten an, der in der Hauptzeit arbeitet, und an den anderen - einen zusätzlichen Vollzeitdatenbus.  Es wird verwendet, um das Programm von außen herunterzuladen und den RAM-Inhalt vom Debugger abzurufen.  Der Rest der Zeit wird dieser Reifen im Leerlauf sein.  So sieht alles im theoretischen Teil des Dokuments aus: <br><br><img src="https://habrastorage.org/webt/ks/sv/vt/kssvvtij9hdnujtgehodhaqwjmu.png"><br><blockquote>  Beachten Sie, dass das Dokument nicht erklärt, warum, aber es wird angemerkt, dass selbst mit Dual-Port-Speicher nur ein Port mit einem nicht zwischengespeicherten Master verbunden werden kann.  Der zweite sollte an das Übliche angeschlossen werden. </blockquote>  Fügen wir 8 Kilobyte Speicher hinzu, machen Sie es zu einem Dual-Port, lassen Sie den Rest standardmäßig: <br><br><img src="https://habrastorage.org/webt/kl/1q/_k/kl1q_kgyv67kvcjjzyiw-obrrm4.png"><br><br>  Fügen Sie dem Prozessor einen nicht zwischenspeicherbaren Anweisungsport hinzu: <br><br><img src="https://habrastorage.org/webt/tk/ib/2y/tkib2ydvc6f_lfi9nprwkzai0cu.png"><br><br>  Wir nennen den Speicher <b>NonCachedCode</b> , verbinden den Speicher mit den Bussen, weisen ihm die Adresse 0x20010000 zu und sperren ihn (für beide Ports).  Insgesamt bekommen wir so etwas: <br><br><img src="https://habrastorage.org/webt/84/1d/o_/841do_ssmf-r_a4ibqdyr2kksly.png"><br><br>  Das ist alles.  Wir speichern und generieren das System, sammeln das Projekt.  Die Hardware ist bereit.  Wir gehen zum Software-Teil über. <br><br><h2>  Vorbereitung von BSP im Software-Teil </h2><br>  Normalerweise wählen <b>Sie</b> nach dem Ändern des Prozessorsystems einfach den Menüpunkt <b>BSP generieren aus</b> , aber heute müssen wir den BSP-Editor öffnen.  Da wir dies selten tun, möchte ich Sie daran erinnern, wo sich der entsprechende Menüpunkt befindet: <br><br><img src="https://habrastorage.org/webt/x4/nk/ub/x4nkubzhbxq26krtzce8nhuxmcw.png"><br><br>  Dort gehen wir zur Registerkarte <b>Linker Script</b> .  Wir sehen, dass wir Regionen hinzugefügt haben, die Namen von RAM-Blöcken erben: <br><br><img src="https://habrastorage.org/webt/qs/_t/af/qs_taf1wiql9vccnl_7s_frbqci.png"><br><br>  Ich werde zeigen, wie man einen Abschnitt hinzufügt, in dem der Code platziert wird.  Klicken Sie im Abschnitt auf Hinzufügen: <br><br><img src="https://habrastorage.org/webt/qa/8o/lu/qa8olur0jjxjhj2oz-dqwzmf3iy.png"><br><br>  Geben Sie im angezeigten Fenster den Namen des Abschnitts an (um Verwirrung im Artikel zu vermeiden, benenne ich ihn ganz anders als den Namen der Region, nämlich nccode) und ordne ihn der Region zu (ich habe <b>NonCachedCode</b> aus der Liste ausgewählt): <br><br><img src="https://habrastorage.org/webt/ji/eo/to/jieotoad61gc1i-xarabcynmqyy.png"><br><br>  Das war's, generiere den BSP und schließe den Editor. <br><br><h2>  Platzieren von Code in einem neuen Speicherbereich </h2><br>  Ich möchte Sie daran erinnern, dass das Programm zwei Funktionen enthält, die vom vorherigen Artikel übernommen wurden: <b>MagicFunction1 ()</b> und <b>MagicFunction2 ()</b> .  Beim ersten Durchgang luden beide ihre Körper in den Cache, der auf dem Oszilloskop sichtbar war.  Außerdem arbeiteten sie je nach Umgebungssituation entweder mit maximaler Geschwindigkeit oder rieben sich ständig mit ihren Körpern, was zu ständigen Downloads von SDRAM führte. <br><br>  Verschieben wir die erste Funktion in ein neues nicht zwischengespeichertes Segment, lassen die zweite an Ort und Stelle und führen dann einige Läufe durch. <br><blockquote>  Fügen Sie das <b>Abschnittsattribut</b> hinzu, um eine Funktion in einem neuen Abschnitt zu platzieren. </blockquote>  Bevor wir die <b>MagicFunction1 ()</b> -Funktion definieren, platzieren <b>wir</b> ihre Deklaration auch mit diesem Attribut: <br><br><pre><code class="plaintext hljs">void MagicFunction1()__attribute__ ((section("nccode"))); void MagicFunction1() { IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); ...</code> </pre> <br>  Wir führen den ersten Durchlauf einer Iteration der Schleife durch (ich habe einen Haltepunkt auf die while-Zeile gesetzt): <br><pre> <code class="plaintext hljs"> while (1) { MagicFunction1(); MagicFunction2(); }</code> </pre><br>  Wir sehen folgendes Ergebnis: <br><br><img src="https://habrastorage.org/webt/vh/1q/jx/vh1qjxzrvwbudd99po6eerz47ja.png"><br><br>  Wie Sie sehen können, wird die erste Funktion wirklich mit maximaler Geschwindigkeit ausgeführt, die zweite wird aus dem SDRAM geladen.  Führen Sie den zweiten Lauf aus: <br><br><img src="https://habrastorage.org/webt/l9/ce/iv/l9ceivh_xyn8ip_xtyqv18u4i2a.png"><br><br>  Beide Funktionen arbeiten mit maximaler Geschwindigkeit.  Und die erste Funktion entlädt die zweite nicht aus dem Cache, obwohl zwischen ihnen die Einfügung ist, die ich nach dem Schreiben des letzten Artikels hinterlassen habe: <br><br><pre> <code class="plaintext hljs">volatile void FuncBetween() { Nops256 Nops256 Nops256 Nops64 Nops64 Nops64 Nops16 Nops16 }</code> </pre><br>  Diese Einfügung wirkt sich nicht mehr auf die relative Position der beiden Funktionen aus, da die erste in einem völlig anderen Speicherbereich verbleibt. <br><br><h2>  Ein paar Worte zu Daten </h2><br>  In ähnlicher Weise können Sie einen Abschnitt mit nicht zwischengespeicherten Daten erstellen und dort globale Variablen platzieren, indem Sie ihnen dasselbe Attribut zuweisen. Um jedoch Platz zu sparen, werde ich solche Beispiele nicht nennen. <br><br>  Wir haben eine Region für diesen Speicher erstellt. Die Zuordnung zum Abschnitt kann auf die gleiche Weise wie für den Codeabschnitt erfolgen.  Es bleibt nur zu verstehen, wie das entsprechende Attribut einer Variablen zugewiesen wird.  Hier ist das erste Beispiel für die Deklaration solcher Daten, die im Darm von automatisch generiertem Code gefunden wurden: <br><br><pre> <code class="plaintext hljs">volatile alt_u32 alt_log_boot_on_flag \ __attribute__ ((section (".sdata"))) = ALT_LOG_BOOT_ON_FLAG_SETTING;</code> </pre><br><h2>  Was gibt es uns? </h2><br>  Nun, eigentlich aus offensichtlichen Gründen: Jetzt können wir den Hauptteil des Codes in SDRAM platzieren und im nicht zwischenspeicherbaren Abschnitt jene Funktionen ausgeben, die programmgesteuert Zeitdiagramme bilden oder deren Leistung maximal sein sollte, was bedeutet, dass sie aufgrund von nicht verlangsamt werden sollten dass eine andere Funktion ständig den entsprechenden Code aus dem Cache speichert. <br><br><h2>  Schauen Sie sich die Reifen genau an. </h2><br>  Schauen Sie sich nun die Reifen im resultierenden Prozessorsystem genau an.  Wir haben fast vier davon.  Ich kreiste rot um den Hauptbus (was die Vereinigung der beiden ist, weshalb ich „fast“ schrieb: physisch - es gibt zwei Reifen, aber logischerweise - einen).  Ich habe den Bus, der zum nicht zwischengespeicherten Befehlsspeicher führt, grün hervorgehoben, blau - zum nicht zwischengespeicherten Datenspeicher.  <b>Diese drei Reifen arbeiten parallel und unabhängig voneinander!</b> <br><br><img src="https://habrastorage.org/webt/kg/rv/wf/kgrvwfw1kncypo4x6mn4uehagng.png"><br><br>  Denken Sie daran, dass ich in dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel über DMA</a> argumentiert habe, dass einer der leistungsbeschränkenden Faktoren darin besteht, dass die Daten auf demselben Bus übertragen werden.  Der DMA-Block liest Daten vom Bus, schreibt Daten darauf, und selbst zur gleichen Zeit verwendet der Prozessorkern denselben Bus.  Wie Sie sehen können, wird dieser Nachteil geschlossener Systeme im FPGA vollständig beseitigt.  Bei vorgefertigten Steuerungen sind Hersteller beim Verlegen von Verbindungen gezwungen, zwischen Anforderungen und Fähigkeiten zu wechseln.  Der Programmierer benötigt diese Option möglicherweise.  Und so.  Und so.  Und so ... Möglicherweise sind viele Dinge erforderlich.  Aber Ressourcen kosten Geld und auf dem ausgewählten Kristall ist nicht immer genug Platz für sie.  Sie können nicht alles posten.  Wir müssen entscheiden, was jeder wirklich braucht und was in Einzelfällen benötigt wird.  Und welche Einzelfälle sollten eingeführt und welche vergessen werden.  Und dann erscheinen Kompromisslösungen, deren Feinheiten der Programmierer berücksichtigen muss, wenn er sie verwenden möchte.  In unserem Fall können wir ohne weiteres handeln.  Was wir heute brauchen, ist heute gelegt.  Unsere Ressource ist flexibel.  Wir geben es aus, damit die Ausrüstung für unsere heutige Aufgabe optimal ist.  Für die Aufgaben von morgen und gestern müssen keine Ressourcen reserviert werden.  In der heutigen Zeit werden wir jedoch alles so einstellen, dass das Programm so effizient wie möglich funktioniert, ohne dass besondere Programmierfreuden erforderlich sind. <br><br>  Es war einmal an einer Universität in einem Kurs über Signalprozessoren, wie man zwei Busse parallel zu einem Team einsetzt.  Soweit ich weiß, ermöglicht in modernen ARM-Controllern die detaillierte Kenntnis der Busmatrix auch eine Optimierung.  Aber das alles ist gut, wenn ein Entwickler seit Jahren mit demselben System arbeitet.  Wenn Sie von Projekt zu Projekt völlig unterschiedliche Hardwareteile fahren müssen, können Sie sich nicht alles merken.  Bei FPGAs untersuchen wir nicht die Merkmale der Umgebung, sondern können die Umgebung selbst anpassen. <br><blockquote>  In Bezug auf den Ansatz „Wir verbringen nicht viel Zeit mit Entwicklung“ klingt dies folgendermaßen: <br>  Wir müssen keine Anstrengungen unternehmen, um die Verwendung von vorgefertigten Standardreifen zu optimieren. Wir können sie schnell und optimal für die zu lösende Aufgabe verlegen, diese Hilfsentwicklung schnell abschließen und den Prozess des Debuggens oder Testens des Hauptprojekts schnell sicherstellen. </blockquote>  Schauen wir uns ein Beispiel für die Aufnahme eines DMA-Blocks aus dem <b>IP-Benutzerhandbuch</b> für <b>eingebettete Peripheriegeräte</b> an, um das Material zu konsolidieren. <br><br><img src="https://habrastorage.org/webt/ww/hw/yg/wwhwygxdtfoxpuyftp00h2p_xde.png"><br><br>  Wir sehen drei unabhängige Verbindungen.  Eingabedaten (in dieser Abbildung ist es ein auf den Speicher projizierter Bus), Ausgabedaten (in dieser Abbildung ist es ein völlig anderer Bustyp - eine Stream-Schnittstelle) und die Kommunikation mit dem Steuerprozessor.  Niemand stört sich daran, alles an verschiedene Busse anzuschließen, dann wird die Arbeit parallel verlaufen.  Eingabedaten (z. B. vom SDRAM) werden in einem Stream gespeichert, den niemand stört.  Die Ausgabe erfolgt in einem anderen Stream, beispielsweise an den FT245-FIFO-Kanal, den wir bereits berücksichtigt haben.  und der Zentralprozessor frisst nicht von diesen Taktbussen weg, da der Hauptbus isoliert ist.  Obwohl in diesem Fall natürlich der Speicher im SDRAM, der sich auf einem separaten Bus befindet, programmgesteuert nicht verfügbar ist.  Aber niemand wird verhindern, dass es von DMA gelesen wird.  Wenn das Ziel darin besteht, mit dem Puffer eine hohe Leistung zu erzielen, muss dies um jeden Preis erreicht werden.  Es sei denn, das gesamte Programm muss in den im FPGA integrierten Speicher passen, da die Redd-Hardware keine anderen Speichereinheiten enthält. <br><br>  Um Reifen zu parallelisieren, können Sie auch nicht zwischengespeicherte Reifen verwenden, da wir gesehen haben, dass es mehrere geben kann.  Slaves, die mit diesen Bussen verbunden sind, unterliegen einer Reihe von Einschränkungen: <br><br><ul><li>  der Sklave ist immer einer im Bus; </li><li>  Der Slave verwendet den Busverzögerungsmechanismus nicht. </li><li>  Die Schreiblatenz ist immer Null, die Leselatenz ist immer Eins. </li></ul><br>  Wenn diese Bedingungen erfüllt sind, kann ein solches Slave-Gerät an einen nicht zwischengespeicherten Bus angeschlossen werden.  Natürlich wird es höchstwahrscheinlich ein Datenbus sein. <br><br>  Wenn Sie diese Grundprinzipien kennen, können Sie sie im Allgemeinen durchaus für reale Aufgaben verwenden.  Aber im Allgemeinen können Sie.  Sie können darauf verzichten, wenn das Ergebnis mit herkömmlichen Mitteln erzielt wird.  Aber denken Sie daran.  Manchmal ist die Optimierung eines Systems durch diese Mechanismen einfacher als die Feinabstimmung des Programms. <br><br><h2>  Fazit </h2><br>  Wir haben eine Technik zum Übertragen von Codeabschnitten untersucht, die für die Leistung oder die Vorhersagbarkeit der Verarbeitungsausführung in einem nicht zwischenspeicherbaren Speicher von entscheidender Bedeutung sind.  Dabei haben wir die Möglichkeit einer Leistungsoptimierung durch den Einsatz mehrerer parallel und unabhängig voneinander arbeitender Reifen untersucht. <br><br>  Um das Thema zu beenden, müssen wir noch lernen, wie man die Systemtaktfrequenz erhöht (jetzt ist sie auf die Komponente beschränkt, die Taktimpulse für den SDRAM-Chip erzeugt).  Da die Artikel jedoch dem Prinzip „eins - ein Artikel“ folgen, werden wir dies beim nächsten Mal tun. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468027/">https://habr.com/ru/post/de468027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468017/index.html">Die Vielleicht-Monade über Async / Warten in C # (ohne Aufgabe ov!)</a></li>
<li><a href="../de468019/index.html">Website-Entwicklung in WebAssembly mit NetCore 3 und Blazor</a></li>
<li><a href="../de468021/index.html">PHP, wie viel Abstraktion für die Menschen?</a></li>
<li><a href="../de468023/index.html">Künstliche Intelligenz im Kampfspiel Shadow Fight 3</a></li>
<li><a href="../de468025/index.html">Wie konfiguriere ich SNI in Zimbra OSE?</a></li>
<li><a href="../de468031/index.html">Wir portieren ein Multiplayer-Spiel von C ++ mit Cheerp, WebRTC und Firebase ins Web</a></li>
<li><a href="../de468035/index.html">Laden Sie die Presse mit einem Gamecontroller oder 8 ungewöhnlichen Patenten für Eingabegeräte herunter</a></li>
<li><a href="../de468039/index.html">Moskau Kubernetes Meetup # 6 bei Acronis (Fiztehpark) 10/03/2019</a></li>
<li><a href="../de468041/index.html">Ankündigung der Kubernetes Web View-Weboberfläche (und eine kurze Übersicht über andere Web-Benutzeroberflächen für Kubernetes)</a></li>
<li><a href="../de468043/index.html">So erstellen Sie ein UI-Kit, das zum Verkauf steht. Entwicklungsstadien eines kommerziellen Designsystems</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>