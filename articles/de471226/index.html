<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèóÔ∏è ‚ö°Ô∏è üëï Linux hat viele Gesichter: wie man an jeder Distribution arbeitet üë©üèª‚Äçüîß üë©üèΩ‚Äç‚öïÔ∏è üèöÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Erstellen einer Sicherungsanwendung, die auf einer beliebigen Distribution ausgef√ºhrt wird, ist keine einfache Aufgabe. Um sicherzustellen, dass V...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Linux hat viele Gesichter: wie man an jeder Distribution arbeitet</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/veeam/blog/471226/"><img src="https://habrastorage.org/webt/ry/zz/2e/ryzz2enp795e4whkxs9rgxbmwsm.jpeg"><br><br>  Das Erstellen einer Sicherungsanwendung, die auf einer beliebigen Distribution ausgef√ºhrt wird, ist keine einfache Aufgabe.  Um sicherzustellen, dass Veeam Agent f√ºr Linux auf Distributionen von RHEL 6 und Debian 6 ausgef√ºhrt wird, m√ºssen openSUSE Leap 15.1 und Ubuntu 19.04 eine Reihe von Problemen l√∂sen, insbesondere wenn Sie bedenken, dass das Kernelmodul Teil des Softwareprodukts ist. <br><br>  Dieser Artikel basiert auf einer Pr√§sentation auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LinuxPiter 2019-</a> Konferenz. <br><a name="habracut"></a><br>  Linux ist nicht nur eines der beliebtesten Betriebssysteme.  In der Tat ist dies eine Plattform, auf deren Grundlage Sie etwas Einzigartiges tun k√∂nnen, etwas Eigenes.  Aus diesem Grund hat Linux viele Distributionen, die sich in einer Reihe von Softwarekomponenten unterscheiden.  Und hier tritt das Problem auf: Damit das Softwareprodukt auf jeder Distribution funktioniert, m√ºssen Sie die jeweiligen Eigenschaften ber√ºcksichtigen. <br><br><h2>  Paketmanager.  .deb vs .rpm </h2><br>  Beginnen wir mit dem offensichtlichen Problem, das Produkt f√ºr verschiedene Distributionen zu vertreiben. <br>  Die typischste Methode zum Verteilen von Softwareprodukten besteht darin, das Paket im Repository abzulegen, damit der im System integrierte Paketmanager es von dort aus installieren kann. <br>  Wir haben jedoch zwei beliebte Paketformate: <i>rpm</i> und <i>deb</i> .  Also muss jeder unterst√ºtzen. <br><br>  In der Welt der Deb-Pakete ist die Kompatibilit√§t erstaunlich.  Das gleiche Paket l√§sst sich gleich gut installieren und funktioniert sowohl unter Debian 6 als auch unter Ubuntu 19.04.  Standards f√ºr den Prozess des Erstellens und Arbeitens mit Paketen, die in alten Debian-Distributionen festgelegt sind, bleiben in der neuen Linux Mint und dem elementaren Betriebssystem relevant.  Daher ist im Fall von Veeam Agent f√ºr Linux ein Deb-Paket f√ºr jede Hardwareplattform ausreichend. <br><br>  Aber in der Welt der Drehzahlpakete sind die Unterschiede gro√ü.  Erstens aufgrund der Tatsache, dass es zwei v√∂llig unabh√§ngige Distributoren von Red Hat und SUSE gibt, f√ºr die keine Kompatibilit√§t erforderlich ist.  Zweitens haben diese Distributoren Distributionen von diesen.  Unterst√ºtzung und experimentell.  Zwischen ihnen ist auch keine Kompatibilit√§t erforderlich.  Es stellte sich heraus, dass f√ºr el6, el7 und el8 ihre eigenen Pakete.  Separates Paket f√ºr Fedora.  Pakete f√ºr SLES11 und 12 und separat f√ºr openSUSE.  Das Hauptproblem sind Abh√§ngigkeiten und Paketnamen. <br><br><h2>  Abh√§ngigkeitsproblem </h2><br>  Leider landen dieselben Pakete h√§ufig unter unterschiedlichen Namen in unterschiedlichen Distributionen.  Unten finden Sie eine unvollst√§ndige Liste der veeam-Paketabh√§ngigkeiten. <br><div class="scrollable-table"><table><tbody><tr><th>  F√ºr EL7: </th><th>  F√ºr SLES 12: </th></tr><tr><td><ul><li>  libblkid </li><li>  libgcc </li><li>  libstdc ++ </li><li>  ncurses-libs </li><li>  Sicherungsbibliotheken </li><li>  Dateibibliotheken </li><li>  veeamsnap = 3.0.2.1185 </li></ul></td><td><ul><li>  libblkid1 </li><li>  libgcc_s1 </li><li>  libstdc ++ 6 </li><li>  libmagic1 </li><li>  libfuse2 </li><li>  veeamsnap-kmp = 3.0.2.1185 </li></ul></td></tr></tbody></table></div><br>  Infolgedessen ist die Liste der Abh√§ngigkeiten f√ºr die Verteilung eindeutig. <br><br>  Es wird schlimmer, wenn sich eine aktualisierte Version unter dem alten Paketnamen versteckt. <br><br>  <b>Ein Beispiel:</b> <br><br>  Fedora 24 hat das <i>ncurses-</i> Paket von Version 5 auf Version 6 aktualisiert. Unser Produkt wurde mit Version 5 erstellt, um die Kompatibilit√§t mit √§lteren Distributionen sicherzustellen.  Um die alte 5. Version der Bibliothek unter Fedora 24 zu verwenden, musste ich das Paket <i>ncurses-compatible-libs verwenden</i> . <br><br>  Infolgedessen werden f√ºr Fedora zwei Pakete mit unterschiedlichen Abh√§ngigkeiten angezeigt. <br><br>  Interessanter.  Nach dem n√§chsten Update des Distributionspakets ist das Paket <i>ncurses-compatible-libs</i> mit der 5. Version der Bibliothek nicht verf√ºgbar.  F√ºr einen Distributor ist es unrentabel, alte Bibliotheken in eine neue Distributionsversion zu ziehen.  Nach einiger Zeit wurde das Problem in SUSE-Distributionen wiederholt. <br><br>  Infolgedessen musste ich bei einigen Distributionen die explizite Abh√§ngigkeit von <i>ncurses-libs</i> aufgeben und das Produkt so reparieren, dass es mit jeder Version der Bibliothek funktioniert. <br><br>  √úbrigens gibt es in der 8. Version von Red Hat kein <i>Python</i> -Metapaket mehr, das auf das gute alte <i>Python 2.7</i> verweist.  Es gibt <i>Python2</i> und <i>Python</i> 3. <br><br><h2>  Alternative zu Paketmanagern </h2><br>  Das Problem mit Abh√§ngigkeiten ist alt und offensichtlich.  Erinnern Sie sich einfach an die Abh√§ngigkeitsh√∂lle. <br>  Kombinieren Sie eine Vielzahl von Bibliotheken und Anwendungen, damit alle stabil funktionieren und keine Konflikte auftreten. Tats√§chlich versucht jeder Linux-Distributor, dieses Problem zu l√∂sen. <br><br>  Der Canonical Package Manager <b>Snappy</b> versucht, dieses Problem ganz anders zu l√∂sen.  Die Hauptidee: Die Anwendung wird in einer Sandbox ausgef√ºhrt, die vom Hauptsystem isoliert und gesch√ºtzt ist.  Wenn die Anwendung Bibliotheken ben√∂tigt, werden diese mit der Anwendung selbst geliefert. <br><br>  <b>Mit Flatpak</b> k√∂nnen Sie auch Anwendungen in der Sandbox unter Verwendung von Linux-Containern ausf√ºhren.  Es gibt auch <b>AppImage</b> , mit dem Sie tragbare Bilder von Programmen erstellen k√∂nnen. <br><br>  Mit diesen L√∂sungen k√∂nnen Sie ein Paket f√ºr alle Distributionen erstellen.  Bei <b>Flatpak</b> und <b>AppImage ist die</b> Installation und der Start der Anwendung auch ohne Wissen des Administrators m√∂glich. <br><br>  Das Hauptproblem besteht darin, dass nicht alle Anwendungen in der Sandbox und ohne <i>Root-</i> Rechte ausgef√ºhrt werden k√∂nnen.  Einige ben√∂tigen direkten Zugriff auf die Plattform.  Ich spreche nicht von Kernelmodulen, die stark vom Kernel abh√§ngig sind und nicht in das Konzept der Sandbox passen. <br><br>  Das zweite Problem ist, dass die beliebten Distributionen von Red Hat und SUSE in der Unternehmensumgebung Snappy und Flatpak noch nicht unterst√ºtzen. <br><br>  In dieser Hinsicht ist Veeam Agent f√ºr Linux weder auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">snapcraft.io</a> noch auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">flathub.org verf√ºgbar</a> . <br><br>  Am Ende der Frage zu Paketmanagern stelle ich fest, dass es eine Option gibt, Paketmanager vollst√§ndig aufzugeben, indem Bin√§rdateien und ein Skript kombiniert werden, um sie in einem Paket zu installieren. <br><br>  Mit einem solchen Bundle k√∂nnen Sie ein gemeinsames Paket f√ºr verschiedene Distributionen und Plattformen erstellen, einen interaktiven Installationsprozess durchf√ºhren und die erforderlichen Anpassungen vornehmen.  Ich bin auf solche Pakete f√ºr Linux nur von VMware gesto√üen. <br><br><h2>  Update-Problem </h2><br><img src="https://habrastorage.org/webt/ny/8c/-k/ny8c-kdpc74mgrym0nszgkd0d04.png"><br>  Selbst wenn alle Abh√§ngigkeitsprobleme behoben sind, funktioniert das Programm m√∂glicherweise auf derselben Distribution unterschiedlich.  Der Punkt ist in den Updates. <br><br>  Es gibt 3 Upgrade-Strategien: <br><br><ul><li>  Am einfachsten ist es, niemals zu aktualisieren.  Server konfiguriert und vergessen.  Warum Updates, wenn alles funktioniert?  Probleme treten auf, wenn Sie sich zum ersten Mal an den Support wenden.  Der Ersteller der Distribution unterst√ºtzt nur eine aktualisierte Version. </li><li>  Sie k√∂nnen dem Distributor vertrauen und automatische Updates einrichten.  In diesem Fall ist ein Anruf beim Support wahrscheinlich unmittelbar nach einem erfolglosen Update. </li><li>  Die Option der manuellen Aktualisierung erst nach dem Ausf√ºhren in der Testinfrastruktur ist die zuverl√§ssigste, aber teuerste und zeitaufw√§ndigste.  Nicht jeder kann es sich leisten. </li></ul><br>  Da verschiedene Benutzer unterschiedliche Update-Strategien verwenden, m√ºssen Sie sowohl die neueste als auch alle zuvor ver√∂ffentlichten Versionen unterst√ºtzen.  Dies verkompliziert den Entwicklungsprozess und der Testprozess bereitet dem Support-Service Kopfschmerzen. <br><br><h2>  Vielzahl von Hardware-Plattformen </h2><br>  Verschiedene Hardwareplattformen sind ein Problem, das weitgehend spezifisch f√ºr nativen Code ist.  Sie m√ºssen mindestens Bin√§rdateien f√ºr jede unterst√ºtzte Plattform sammeln. <br><br>  Im Veeam Agent f√ºr Linux-Projekt k√∂nnen wir immer noch nicht mindestens etwas RISC-√§hnliches unterst√ºtzen. <br><br>  Ich werde nicht im Detail auf dieses Thema eingehen.  Ich werde nur die Hauptprobleme skizzieren: plattformabh√§ngige Typen wie <code>size_t</code> , Ausrichtung von Strukturen und Bytereihenfolge. <br><br><h2>  Statische und / oder dynamische Verkn√ºpfung </h2><br><img src="https://habrastorage.org/webt/x7/im/9v/x7im9v9gtvi7lkwmodbajd0au_g.jpeg"><br>  Und hier ist die Frage: "Wie kann man dynamisch oder statisch auf Bibliotheken verlinken?"  eine Diskussion wert. <br><br>  In der Regel verwenden C / C ++ Linux-Anwendungen dynamische Verkn√ºpfungen.  Dies funktioniert hervorragend, wenn die Anwendung speziell f√ºr eine bestimmte Distribution erstellt wurde. <br><br>  Wenn die Aufgabe darin besteht, eine Vielzahl von Distributionen mit einer Bin√§rdatei abzudecken, m√ºssen Sie sich auf die √§lteste unterst√ºtzte Distribution konzentrieren.  F√ºr uns ist dies Red Hat 6. Es enth√§lt gcc 4.4, das selbst der C ++ 11-Standard nicht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vollst√§ndig</a> unterst√ºtzt. <br><br>  Wir erstellen unser Projekt mit gcc 6.3, das C ++ 14 vollst√§ndig unterst√ºtzt.  In diesem Fall m√ºssen in Red Hat 6 nat√ºrlich die libstdc ++ - und die Boost-Bibliothek mitgeschleppt werden.  Der einfachste Weg, eine Verkn√ºpfung zu ihnen herzustellen, ist statisch. <br><br>  Leider k√∂nnen nicht alle Bibliotheken statisch verkn√ºpft werden. <br><br>  Erstens m√ºssen Systembibliotheken wie <i>libfuse</i> , <i>libblkid</i> dynamisch verkn√ºpft werden, um sicherzustellen, dass sie mit dem Kernel und seinen Modulen kompatibel sind. <br><br>  Zweitens gibt es eine Subtilit√§t mit Lizenzen. <br><br>  Die GPL-Lizenzierung erlaubt grunds√§tzlich die Verkn√ºpfung von Bibliotheken nur mit OpenSource-Code.  MIT und BSD erm√∂glichen die statische Verkn√ºpfung und die Aufnahme von Bibliotheken in das Projekt.  LGPL scheint der statischen Verkn√ºpfung jedoch nicht zu widersprechen, sondern erfordert die Freigabe der f√ºr die Verkn√ºpfung erforderlichen Dateien. <br><br>  Im Allgemeinen sch√ºtzt die Verwendung der dynamischen Verkn√ºpfung vor der Notwendigkeit, etwas bereitzustellen. <br><br><h2>  Erstellen von C / C ++ - Anwendungen </h2><br>  Um C / C ++ - Anwendungen f√ºr verschiedene Plattformen und Distributionen zu erstellen, reicht es aus, eine geeignete Version von gcc auszuw√§hlen oder zu kompilieren und Cross-Compiler f√ºr bestimmte Architekturen zu verwenden, um den gesamten Satz von Bibliotheken zu sammeln.  Diese Arbeit ist durchaus machbar, aber ziemlich m√ºhsam.  Es gibt keine Garantie daf√ºr, dass der ausgew√§hlte Compiler und die ausgew√§hlten Bibliotheken eine funktionsf√§hige Option bieten. <br><br>  Ein offensichtliches Plus: Die Infrastruktur ist stark vereinfacht, da der gesamte Montageprozess auf einer Maschine durchgef√ºhrt werden kann.  Dar√ºber hinaus reicht es aus, einen Satz von Bin√§rdateien f√ºr eine Architektur zu sammeln, und Sie k√∂nnen sie in Pakete f√ºr verschiedene Distributionen packen.  So werden veeam-Pakete f√ºr Veeam Agent f√ºr Linux erstellt. <br><br>  Im Gegensatz zu dieser Option k√∂nnen Sie einfach die Buildfarm vorbereiten, dh mehrere Maschinen f√ºr die Montage.  Jede solche Maschine bietet eine Zusammenstellung der Anwendung und Zusammenstellung des Pakets f√ºr eine bestimmte Distribution und eine bestimmte Architektur.  In diesem Fall erfolgt die Kompilierung mit den Mitteln, die der Distributor vorbereitet hat.  Das hei√üt, die Compiler-Vorbereitungsphase und die Auswahl der Bibliotheken werden nicht mehr ben√∂tigt.  Dar√ºber hinaus kann der Montageprozess einfach parallelisiert werden. <br><br>  Dieser Ansatz hat jedoch ein Minus: F√ºr jede Distribution innerhalb derselben Architektur m√ºssen Sie Ihre eigenen Bin√§rdateien zusammenstellen.  Ein Minus ist auch, dass so viele Maschinen gewartet werden m√ºssen, um eine gro√üe Menge an Speicherplatz und RAM zuzuweisen. <br><br>  Auf diese Weise werden die KMOD-Pakete des veeamsnap-Kernelmoduls f√ºr Red Hat-Distributionen zusammengestellt. <br><br><h2>  Open Build Service </h2><br>  SUSE-Kollegen versuchten, einen Mittelweg als speziellen Service zum Kompilieren von Anwendungen und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellen von</a> Paketen zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">implementieren</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">openbuildservice</a> . <br><br>  Tats√§chlich ist es ein Hypervisor, der eine virtuelle Maschine erstellt, alle erforderlichen Pakete darin installiert, die Anwendung kompiliert und das Paket in dieser isolierten Umgebung kompiliert. Danach wird eine solche virtuelle Maschine freigegeben. <br><br><img src="https://habrastorage.org/webt/y0/4p/uy/y04puyokz_w-fexue3zcgpvhcgc.png"><br><br>  Der in OpenBuildService implementierte Scheduler bestimmt, wie viele virtuelle Maschinen f√ºr die optimale Geschwindigkeit beim Erstellen von Paketen ausgef√ºhrt werden k√∂nnen.  Der integrierte Signaturmechanismus selbst signiert die Pakete und legt sie im integrierten Repository ab.  Das integrierte Versionskontrollsystem speichert den Verlauf von √Ñnderungen und Baugruppen.  Es bleibt einfach, Ihren Quellcode zu diesem System hinzuzuf√ºgen.  Auch der Server selbst muss nicht angehoben werden, aber Sie k√∂nnen den offenen verwenden. <br><br>  Hier gibt es jedoch ein Problem: Ein solcher M√§hdrescher l√§sst sich nur schwer in die vorhandene Infrastruktur einf√ºgen.  Zum Beispiel ist keine Versionskontrolle erforderlich, wir haben bereits eine eigene f√ºr die Quellen.  Der Signaturmechanismus ist anders: Es wird ein spezieller Server verwendet.  Das Repository wird ebenfalls nicht ben√∂tigt. <br><br>  Dar√ºber hinaus ist die Unterst√ºtzung f√ºr andere Distributionen - zum Beispiel Red Hat - eher schlecht implementiert, was verst√§ndlich ist. <br><br>  Der Vorteil dieses Dienstes ist die schnelle Unterst√ºtzung der n√§chsten Version der SUSE-Distribution.  Vor der offiziellen Ver√∂ffentlichung werden die f√ºr die Montage erforderlichen Pakete in das √∂ffentliche Repository hochgeladen.  Eine neue wird in der Liste der verf√ºgbaren Distributionen auf OpenBuildService angezeigt.  Wir setzen ein H√§kchen und es wird dem Montageplan hinzugef√ºgt.  Das Hinzuf√ºgen einer neuen Version der Distribution erfolgt somit mit fast einem Klick. <br><br>  In unserer Infrastruktur stellen wir mithilfe des OpenBuildService die gesamte Vielfalt der KMP-Pakete des veeamsnap-Kernelmoduls f√ºr SUSE-Distributionen zusammen. <br><br>  Dar√ºber hinaus m√∂chte ich auf Kernelmodule eingehen. <br><br><h2>  Kernel ABI </h2><br>  Linux-Kernelmodule wurden in der Vergangenheit in Quellform verteilt.  Tatsache ist, dass sich die Entwickler des Kernels nicht mit der Sorgfalt belasten, eine stabile API f√ºr Kernelmodule aufrechtzuerhalten, und dies erst recht auf bin√§rer Ebene als bei kABI. <br><br>  Um ein Modul f√ºr den Vanilla-Kernel zu erstellen, sind Header dieses bestimmten Kernels erforderlich, und es funktioniert nur auf diesem Kern. <br><br>  Mit DKMS k√∂nnen Sie den Assemblierungsprozess von Modulen beim Aktualisieren des Kernels automatisieren.  Infolgedessen verwenden Benutzer des Debian-Repositorys (und seiner vielen Verwandten) Kernelmodule entweder aus dem Distributor-Repository oder werden mithilfe von DKMS aus dem Quellcode zusammengestellt. <br><br>  Diese Situation ist jedoch im Enterprise-Segment nicht besonders angenehm.  Propriet√§re Code-Distributoren m√∂chten das Produkt in Form kompilierter Bin√§rdateien vertreiben. <br><br>  Administratoren m√∂chten aus Sicherheitsgr√ºnden keine Entwicklungstools auf Produktionsservern behalten.  Enterprise Linux-Distributoren wie Red Hat und SUSE haben entschieden, dass sie ihren Benutzern einen stabilen kABI bieten k√∂nnen.  Als Ergebnis wurden KMOD-Pakete f√ºr Red Hat und KMP-Pakete f√ºr SUSE angezeigt. <br><br>  Das Wesentliche dieser L√∂sung ist recht einfach.  Die Kernel-API ist f√ºr eine bestimmte Version der Distribution eingefroren.  Der Distributor erkl√§rt, dass er den Kernel verwendet, z. B. 3.10, und nimmt nur Korrekturen und Verbesserungen vor, die die Kernel-Schnittstellen in keiner Weise beeinflussen. Die f√ºr den allerersten Kernel zusammengestellten Module k√∂nnen ohne Neukompilierung f√ºr alle nachfolgenden verwendet werden. <br><br>  Red Hat k√ºndigt die kABI-Kompatibilit√§t f√ºr die Verteilung √ºber den gesamten Lebenszyklus an.  Das hei√üt, das zusammengestellte Modul f√ºr Rhel 6.0 (Version November 2010) sollte auch mit Version 6.10 (Version Juni 2018) funktionieren.  Und das sind fast 8 Jahre.  Die Aufgabe ist nat√ºrlich ziemlich kompliziert. <br>  Wir haben mehrere F√§lle aufgezeichnet, in denen das veeamsnap-Modul aufgrund von Problemen mit der kABI-Kompatibilit√§t nicht mehr funktionierte. <br><br>  Nachdem sich herausstellte, dass das f√ºr RHEL 7.0 kompilierte veeamsnap-Modul nicht mit dem Kernel von RHEL 7.5 kompatibel war, aber den Server geladen und garantiert fallen lie√ü, haben wir uns geweigert, die kABI-Kompatibilit√§t f√ºr RHEL 7 im Allgemeinen zu verwenden. <br><br>  Derzeit enth√§lt das KMOD-Paket f√ºr RHEL 7 eine Assembly f√ºr jede Release-Version und ein Skript, das das Laden von Modulen erm√∂glicht. <br><br>  SUSE ging die kABI-Kompatibilit√§tsaufgabe genauer an.  Sie bieten kABI-Kompatibilit√§t in nur einem Service Pack. <br><br>  Zum Beispiel fand die Ver√∂ffentlichung von SLES 12 im September 2014 statt. Und SLES 12 SP1 ist bereits im Dezember 2015, dh etwas mehr als ein Jahr ist vergangen.  Obwohl beide Releases den 3.12-Kernel verwenden, sind sie nicht mit kABI kompatibel.  Offensichtlich ist es viel einfacher, die kABI-Kompatibilit√§t nur ein Jahr lang aufrechtzuerhalten.  Der j√§hrliche Aktualisierungszyklus des Kernmoduls sollte den Erstellern der Module keine Probleme bereiten. <br><br>  Aufgrund dieser SUSE-Richtlinie konnten wir keine Probleme mit der kABI-Kompatibilit√§t in unserem veeamsnap-Modul beheben.  Die Anzahl der Pakete f√ºr SUSE ist zwar fast eine Gr√∂√üenordnung gr√∂√üer. <br><br><h2>  Patches und Backports </h2><br>  Trotz der Tatsache, dass Distributoren versuchen, die kABI-Kompatibilit√§t und die Kernelstabilit√§t sicherzustellen, versuchen sie auch, die Leistung zu verbessern und Fehler in diesem stabilen Kernel zu beseitigen. <br><br>  Zus√§tzlich zu ihrer eigenen ‚ÄûArbeit an Fehlern‚Äú verfolgen die Entwickler des Enterprise Linux-Kernels √Ñnderungen im Vanilla-Kernel und √ºbertragen sie auf ihren ‚Äûstabilen‚Äú. <br><br>  Manchmal f√ºhrt dies zu neuen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehlern</a> . <br><br>  Die neueste Version von Red Hat 6 hat bei einem der kleineren Updates einen Fehler gemacht.  Dies f√ºhrte dazu, dass das veeamsnap-Modul das System garantiert zum Absturz brachte, wenn der Snapshot ver√∂ffentlicht wurde.  Beim Vergleich der Kernelquellen vor und nach dem Update haben wir herausgefunden, dass der Backport schuld ist.  Ein √§hnlicher Fix wurde in der Vanillekernversion 4.19 vorgenommen.  Aber nur im Vanillekern funktionierte dieser Fix einwandfrei, und beim √úbertragen auf den ‚Äûstabilen‚Äú 2.6.32 gab es ein Problem mit dem Spin-Lock. <br><br>  Nat√ºrlich hat jeder immer Fehler, aber hat es sich gelohnt, den Code von 4.19 auf 2.6.32 zu ziehen, um Stabilit√§t zu riskieren? Ich bin mir nicht sicher ... <br><br>  Am schlimmsten ist es, wenn Marketing an das Tauziehen gebunden ist: ‚ÄûStabilit√§t‚Äú &lt;-&gt; ‚ÄûModernisierung‚Äú.  Die Marketingabteilung ben√∂tigt einerseits den Kern der aktualisierten Distribution, um stabil zu sein, gleichzeitig eine bessere Leistung zu erzielen und neue Funktionen zu haben.  Dies f√ºhrt zu seltsamen Kompromissen. <br><br>  Als ich versuchte, ein Modul auf dem 4.4-Kernel von SLES 12 SP3 zu erstellen, war ich √ºberrascht, Funktionen von Vanilla 4.8 darin zu finden.  Meiner Meinung nach √§hnelt die Implementierung von Block-E / A des Kernels 4.4 aus SLES 12 SP3 eher einem 4.8-Kernel als der vorherigen Version des stabilen 4.4-Kernels aus SLES12 SP2.  Ich kann nicht beurteilen, wie viel Prozent des Codes vom 4.8-Kernel auf das SLES 4.4 f√ºr SP3 √ºbertragen wurden, aber ich habe immer noch keine Chance, den Kernel als denselben stabilen 4.4-Kernel zu bezeichnen. <br><br>  Das Unangenehmste daran ist, dass Sie sich beim Schreiben eines Moduls, das auf verschiedenen Kernen gleich gut funktioniert, nicht mehr auf die Kernel-Version verlassen k√∂nnen.  Wir m√ºssen auch die Verteilung ber√ºcksichtigen.  Es ist gut, dass Sie sich manchmal auf eine Definition einlassen k√∂nnen, die zusammen mit neuen Funktionen angezeigt wird. Diese Funktion wird jedoch nicht immer angezeigt. <br><br>  Infolgedessen ist der Code von ausgefallenen Anweisungen zur bedingten Kompilierung umgeben. <br><br>  Es gibt auch Patches, die die dokumentierte Kernel-API √§ndern. <br>  Ich bin auf ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KDE neon</a> 5.16-Distributionskit gesto√üen und war sehr √ºberrascht zu sehen, dass der Aufruf von lookup_bdev in dieser Kernelversion die Liste der Eingabeparameter ge√§ndert hat. <br><br>  Um zusammenzukommen, mussten wir dem Makefile ein Skript hinzuf√ºgen, das pr√ºft, ob die Funktion lookup_bdev einen Maskenparameter hat. <br><br><h2>  Signatur der Kernelmodule </h2><br>  Aber zur√ºck zum Thema Paketverteilung. <br><br>  Einer der Vorteile von stabilem kABI besteht darin, dass Kernelmodule als Bin√§rdatei signiert werden k√∂nnen.  In diesem Fall kann der Entwickler sicher sein, dass das Modul nicht versehentlich besch√§digt oder absichtlich ge√§ndert wurde.  Sie k√∂nnen dies mit dem Befehl modinfo √ºberpr√ºfen. <br><br>  Mit Red Hat- und SUSE-Distributionen k√∂nnen Sie die Signatur eines Moduls √ºberpr√ºfen und nur herunterladen, wenn das entsprechende Zertifikat im System registriert ist.  Das Zertifikat ist der √∂ffentliche Schl√ºssel, mit dem das Modul signiert wird.  Wir vertreiben es als separates Paket. <br><br>  Das Problem hierbei ist, dass Zertifikate entweder in den Kernel integriert werden k√∂nnen (sie werden von Distributoren verwendet) oder mit dem Dienstprogramm <i>mokutil in den</i> nichtfl√ºchtigen EFI-Speicher geschrieben werden <i>m√ºssen</i> .  Bei der Installation des Zertifikats <i>erfordert das</i> Dienstprogramm <i>mokutil</i> einen Neustart des Systems. Noch bevor der Kernel des Betriebssystems geladen wird, bietet es dem Administrator die M√∂glichkeit, das Herunterladen des neuen Zertifikats zuzulassen. <br><br>  Das Hinzuf√ºgen eines Zertifikats erfordert daher physischen Zugriff des Administrators auf das System.  Befindet sich der Computer irgendwo in der Cloud oder nur in einem Remote-Serverraum und der Zugriff erfolgt nur √ºber das Netzwerk (z. B. √ºber ssh), kann kein Zertifikat hinzugef√ºgt werden. <br><br><h2>  EFI auf virtuellen Maschinen </h2><br>  Trotz der Tatsache, dass EFI seit langem von fast allen Entwicklern des Motherboards unterst√ºtzt wird, denkt der Administrator bei der Installation des Systems m√∂glicherweise nicht √ºber die Notwendigkeit von EFI nach und kann deaktiviert werden. <br><br>  Nicht alle Hypervisoren unterst√ºtzen EFI.  VMWare vSphere unterst√ºtzt EFI seit Version 5. <br>  Microsoft Hyper-V erhielt auch EFI-Unterst√ºtzung, beginnend mit Hyper-V f√ºr Windows Server 2012R2. <br><br>  In der Standardkonfiguration ist diese Funktionalit√§t jedoch f√ºr Linux-Computer deaktiviert. Dies bedeutet, dass das Zertifikat nicht installiert werden kann. <br><br>  In vSphere 6.5 k√∂nnen Sie die Option " <b>Sicherer Start</b> " nur in der alten Version der Weboberfl√§che festlegen, die √ºber Flash funktioniert.  Die Web-Benutzeroberfl√§che von HTML-5 liegt weit zur√ºck. <br><br><h2>  Experimentelle Verteilungen </h2><br>  Betrachten Sie schlie√ülich das Thema experimentelle Verteilungen und Verteilungen ohne offizielle Unterst√ºtzung.  Einerseits ist es unwahrscheinlich, dass solche Distributionen auf den Servern seri√∂ser Organisationen gefunden werden.  Es gibt keine offizielle Unterst√ºtzung f√ºr solche Distributionen.  Daher, um diese bereitzustellen.  Produktunterst√ºtzung bei einer solchen Distribution ist nicht m√∂glich. <br><br>  Solche Verteilungen werden jedoch zu einer bequemen Plattform zum Testen neuer experimenteller L√∂sungen.  Zum Beispiel Fedora, OpenSUSE Tumbleweed oder die instabile Version von Debian.  Sie sind ziemlich stabil.  Sie haben immer neue Versionen von Programmen und immer einen neuen Kernel.  Nach einem Jahr kann diese experimentelle Funktionalit√§t im aktualisierten RHEL, SLES oder Ubuntu enthalten sein. <br><br>  Wenn also etwas mit dem experimentellen Verteilungskit nicht funktioniert, ist dies eine Gelegenheit, das Problem zu l√∂sen und es zu l√∂sen.  Sie m√ºssen darauf vorbereitet sein, dass diese Funktionalit√§t bald auf den Produktionsservern der Benutzer angezeigt wird. <br><br>  Die aktuelle Liste der offiziell unterst√ºtzten Distributionen f√ºr Version 3.0 finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Die tats√§chliche Liste der Distributionen, an denen unser Produkt arbeiten kann, ist jedoch viel umfangreicher. <br><br>  Pers√∂nlich war ich an einem Experiment mit dem Elbrus OS interessiert.  Nach der Aktualisierung des veeam-Pakets wurde unser Produkt installiert und verdient.  √úber dieses Experiment habe ich in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> √ºber Habr√© geschrieben. <br><br>  Nun, die Unterst√ºtzung f√ºr neue Distributionen geht weiter.  Wir warten auf die Ver√∂ffentlichung von Version 4.0.  Beta wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bald</a> erscheinen, also <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">seid gespannt auf das Neue</a> ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471226/">https://habr.com/ru/post/de471226/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471210/index.html">Gott ... Ballade √ºber einen Programmierer</a></li>
<li><a href="../de471212/index.html">10 Tipps und Tricks, mit denen Sie der beste Entwickler f√ºr VueJS werden k√∂nnen</a></li>
<li><a href="../de471216/index.html">Die lange Geschichte des Reisef√ºhrers - wie ich 5 Jahre lang einen Dienst f√ºr intelligente Wanderwege geschrieben habe</a></li>
<li><a href="../de471220/index.html">Cockpit - Vereinfachen Sie typische Verwaltungsaufgaben unter Linux √ºber eine praktische Weboberfl√§che</a></li>
<li><a href="../de471222/index.html">Das Verst√§ndnis der Datenschutzrichtlinien f√ºr Anwendungen und Dienste hilft neuronalen Netzen</a></li>
<li><a href="../de471228/index.html">Grokay PyTorch</a></li>
<li><a href="../de471232/index.html">Meine Erfahrung mit der Verbindung von LPS331AP mit Omega Onion2</a></li>
<li><a href="../de471236/index.html">Dosimeter f√ºr Seryozha. Teil III. Nationales Radiometer</a></li>
<li><a href="../de471240/index.html">"Bitchy Betty" und moderne Audio-Interfaces: Warum sprechen sie mit weiblicher Stimme?</a></li>
<li><a href="../de471242/index.html">Einf√ºhrung in Bash Shell</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>