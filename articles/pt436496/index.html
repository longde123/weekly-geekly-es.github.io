<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚¨ÜÔ∏è ü§∂ üë©üèæ‚Äçüè≠ PVS-Studio para Java üçø üí≤ üëßüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na s√©tima vers√£o do analisador est√°tico PVS-Studio, adicionamos suporte √† linguagem Java. √â hora de uma breve hist√≥ria de como come√ßamos a dar suporte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PVS-Studio para Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/436496/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/859/2ca/ccd/8592caccdc92ac430645bd487d7b5284.png" alt="PVS-Studio para Java"></div><br>  Na s√©tima vers√£o do analisador est√°tico PVS-Studio, adicionamos suporte √† linguagem Java.  √â hora de uma breve hist√≥ria de como come√ßamos a dar suporte √† linguagem Java, at√© onde chegamos e o que est√° em nossos planos futuros.  Obviamente, este artigo listar√° as primeiras avalia√ß√µes do analisador em projetos de c√≥digo aberto. <br><a name="habracut"></a><br><h2>  PVS-Studio </h2><br>  Aqui est√° uma breve descri√ß√£o do PVS-Studio para desenvolvedores de Java que nunca ouviram falar dele. <br><br>  Essa ferramenta foi projetada para detectar erros e poss√≠veis vulnerabilidades no c√≥digo fonte dos programas, escritos em C, C ++, C # e Java.  Funciona no ambiente Windows, Linux e macOS. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O PVS-Studio</a> realiza an√°lise de c√≥digo est√°tico e gera um relat√≥rio que ajuda um desenvolvedor a encontrar e eliminar defeitos.  Para aqueles que est√£o interessados ‚Äã‚Äãem saber exatamente como o PVS-Studio procura por erros, sugiro dar uma olhada no artigo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tecnologias usadas no analisador de c√≥digo do PVS-Studio para encontrar bugs e poss√≠veis vulnerabilidades</a> ". <br><br><h2>  Come√ßo </h2><br>  Eu poderia ter apresentado uma hist√≥ria inteligente de como especulamos sobre o pr√≥ximo idioma a ser suportado no PVS-Studio.  Sobre uma escolha sensata de Java, que se baseia em uma alta popularidade dessa linguagem e assim por diante. <br><br>  No entanto, como acontece na vida, a escolha foi feita n√£o por uma an√°lise profunda, mas por um experimento :).  Sim, ponderamos a dire√ß√£o do desenvolvimento do analisador PVS-Studio.  Consideramos linguagens como: Java, PHP, Python, JavaScript, IBM RPG.  Est√°vamos at√© inclinados √† linguagem Java, mas a escolha final n√£o foi feita.  Para aqueles cujo olhar se baseava no IBM RPG desconhecido, gostaria de direcion√°-lo a esta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nota</a> , da qual tudo ficar√° claro. <br><br>  No final de 2017, meu colega Egor Bredikhin analisou bibliotecas dispon√≠veis de c√≥digo de an√°lise (em outras palavras - analisadores) em busca de novas dire√ß√µes de desenvolvimento, interessantes para n√≥s.  Eventualmente, ele se deparou com v√°rios projetos para analisar o c√≥digo Java.  Ele conseguiu criar rapidamente um prot√≥tipo de analisador com alguns diagn√≥sticos baseados no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Spoon</a> .  Al√©m disso, ficou claro que poder√≠amos usar no analisador Java alguns mecanismos do analisador C ++ usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SWIG</a> .  Analisamos o que obtivemos e percebemos que nosso pr√≥ximo analisador seria para Java. <br><br>  Gostar√≠amos de agradecer a Egor por seu trabalho e trabalho duro que ele fez no analisador Java.  O processo de desenvolvimento em si foi descrito por ele no artigo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Desenvolvimento de um novo analisador est√°tico: PVS-Studio Java</a> ". <br><br><h2>  E os concorrentes? </h2><br>  Existem muitos analisadores de c√≥digo est√°tico gratuitos e comerciais para Java em todo o mundo.  N√£o faz sentido list√°-las todas no artigo.  Vou deixar o link para a " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Lista de ferramentas para an√°lise de c√≥digo est√°tico</a> " (consulte a se√ß√£o Java e multil√≠ngue). <br><br>  No entanto, eu sei que, em primeiro lugar, seremos questionados sobre o IntelliJ IDEA, FindBugs e SonarQube (SonarJava). <br><br>  <b>IntelliJ IDEA</b> <br><br>  Um analisador de c√≥digo est√°tico muito poderoso √© constru√≠do no IntelliJ IDEA.  Al√©m disso, o analisador est√° evoluindo, seus autores acompanham de perto nossas atividades.  Portanto, o IntelliJ IDEA √© um cookie dif√≠cil para n√≥s.  N√£o conseguiremos superar o IntelliJ IDEA em habilidades de diagn√≥stico, pelo menos por enquanto.  Portanto, vamos nos concentrar em nossas outras vantagens. <br><br>  A an√°lise est√°tica no IntelliJ IDEA √© principalmente um dos recursos do ambiente, que imp√µe certas limita√ß√µes.  Quanto a n√≥s, temos liberdade no que podemos fazer com nosso analisador.  Por exemplo, podemos adapt√°-lo rapidamente √†s necessidades espec√≠ficas do cliente.  Suporte r√°pido e profundo √© a nossa vantagem competitiva.  Nossos clientes se comunicam diretamente com os desenvolvedores, trabalhando em uma ou outra parte do PVS-Studio. <br><br>  No PVS-Studio, existem muitas oportunidades para integr√°-lo a um ciclo de desenvolvimento de grandes projetos antigos.  Por exemplo, √© a nossa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">integra√ß√£o com o SonarQube</a> .  Ele tamb√©m inclui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a supress√£o em massa</a> de avisos do analisador, o que permite que voc√™ comece a usar imediatamente a ferramenta em um grande projeto para rastrear bugs apenas no c√≥digo novo ou modificado.  O PVS-Studio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pode ser constru√≠do</a> em um processo de integra√ß√£o cont√≠nua.  Acho que esses e outros recursos ajudar√£o nosso analisador a encontrar um lugar sob o sol no mundo Java. <br><br>  <b>Findbugs</b> <br><br>  O projeto FindBugs √© abandonado.  No entanto, devemos mencion√°-lo pelo fato de que talvez seja o analisador est√°tico livre mais famoso do c√≥digo Java. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SpotBugs</a> pode ser chamado de sucessor do FindBugs.  No entanto, √© menos popular e ainda n√£o est√° claro o que acontecer√° com ele. <br><br>  De um modo geral, acreditamos que, embora o FindBugs tenha sido e ainda continue sendo extremamente popular, al√©m de um analisador gratuito, n√£o devemos insistir nele.  Este projeto se tornar√° uma hist√≥ria silenciosamente. <br><br>  PS A prop√≥sito, agora o PVS-Studio tamb√©m pode ser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">usado gratuitamente</a> quando se trabalha com projetos abertos. <br><br>  <b>SonarQube (SonarJava)</b> <br><br>  Acreditamos que n√£o competimos com o SonarQube, mas complementamos.  O PVS-Studio se integra ao SonarQube, que permite que os desenvolvedores encontrem mais bugs e poss√≠veis vulnerabilidades de seguran√ßa em seus projetos.  Contamos regularmente como integrar a ferramenta PVS-Studio e outros analisadores no SonarQube em master classes que realizamos em termos de diferentes confer√™ncias. <br><br><h2>  Como executar o PVS-Studio for Java </h2><br>  Disponibilizamos as formas mais populares de integra√ß√£o do analisador no sistema de compila√ß√£o para os usu√°rios: <br><br><ul><li>  Plugin para Maven; </li><li>  Plugin para Gradle; </li><li>  Plugin para IntelliJ IDEA </li></ul><br>  Durante a fase de teste, conhecemos muitos usu√°rios que possuem sistemas de constru√ß√£o auto-escritos, especialmente na esfera do desenvolvimento m√≥vel.  Eles tiveram a oportunidade de executar o analisador diretamente, listando as fontes e o caminho da classe. <br><br>  Voc√™ pode encontrar informa√ß√µes detalhadas sobre todas as maneiras de executar o analisador na p√°gina de documenta√ß√£o " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como executar o PVS-Studio Java</a> ". <br><br>  N√£o conseguimos evitar a plataforma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SonarQube</a> de controle de qualidade de c√≥digo, que √© t√£o popular entre os desenvolvedores Java, por isso adicionamos suporte √† linguagem Java em nosso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">plug-in para o SonarQube</a> . <br><br><h2>  Planos adicionais </h2><br>  Temos muitas id√©ias que podem exigir uma investiga√ß√£o mais aprofundada, mas alguns planos espec√≠ficos, inerentes a qualquer um de nossos analisadores, s√£o os seguintes: <br><br><ul><li>  Cria√ß√£o de novos diagn√≥sticos e aprimoramento dos existentes; </li><li>  Melhoria da an√°lise de fluxo de dados; </li><li>  Aumento da confiabilidade e usabilidade. </li></ul><br>  Talvez, encontre tempo para adaptar o plugin IntelliJ IDEA ao CLion.  Ol√° aos desenvolvedores de C ++ que leram sobre o analisador de Java :-) <br><br><h2>  Exemplos de erros encontrados em projetos de c√≥digo aberto </h2><br>  Tremer minhas madeiras se n√£o estiver mostrando no artigo alguns erros encontrados no novo analisador!  Bem, poder√≠amos ter pegado um grande projeto Java de c√≥digo aberto e escrever um artigo cl√°ssico revisando erros, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">costumamos fazer</a> . <br><br>  No entanto, eu antecipo imediatamente perguntas sobre o que podemos encontrar em projetos como IntelliJ IDEA, FindBugs e assim por diante.  Portanto, n√£o tenho outra sa√≠da sen√£o come√ßar com esses projetos.  Ent√£o, decidi verificar e escrever rapidamente v√°rios exemplos interessantes de erros dos seguintes projetos: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IntelliJ IDEA Community Edition</a> .  Eu acho que n√£o h√° necessidade de explicar por que esse projeto foi escolhido :). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SpotBugs</a>  Como escrevi anteriormente, o projeto FindBugs n√£o est√° progredindo.  Ent√£o, vamos olhar dentro do projeto SpotBugs, que √© o sucessor do FindBugs.  SpotBugs √© um analisador est√°tico cl√°ssico de c√≥digo Java. </li><li>  Algo dos projetos da empresa SonarSource, que desenvolve software para monitoramento cont√≠nuo da qualidade do c√≥digo.  Agora, vamos examinar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SonarQube</a> e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SonarJava</a> . </li></ul><br>  Escrever sobre bugs desses projetos √© um desafio.  O fato √© que esses projetos s√£o de alta qualidade.  Na verdade, n√£o √© surpreendente.  Nossas observa√ß√µes mostram que os analisadores de c√≥digo est√°tico s√£o sempre bem testados e verificados usando outras ferramentas. <br><br>  Apesar de tudo isso, terei que come√ßar exatamente com esses projetos.  N√£o terei a segunda chance de escrever sobre eles.  Tenho certeza de que, ap√≥s o lan√ßamento do PVS-Studio para Java, os desenvolvedores dos projetos listados levar√£o o PVS-Studio a bordo e come√ßar√£o a us√°-lo para verifica√ß√µes regulares ou, pelo menos, ocasionais de seu c√≥digo.  Por exemplo, eu sei que Tagir Valeev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">lany</a> ), um dos desenvolvedores do JetBrains, trabalhando no analisador de c√≥digo est√°tico IntelliJ IDEA, no momento, quando estou escrevendo, o artigo j√° est√° jogando com a vers√£o beta do PVS-Studio .  Ele nos escreveu cerca de 15 e-mails com relat√≥rios de erros e recomenda√ß√µes.  Obrigado, Tagir! <br><br>  Felizmente, n√£o preciso encontrar tantos bugs em um projeto em particular.  No momento, minha tarefa √© mostrar que o analisador PVS-Studio para Java n√£o apareceu em v√£o e ser√° capaz de preencher uma linha de outras ferramentas projetadas para melhorar a qualidade do c√≥digo.  Apenas examinei os relat√≥rios do analisador e listei alguns erros que pareciam interessantes.  Se poss√≠vel, tentei citar diferentes tipos de erros.  Vamos ver como ficou. <br><br><h3>  IntelliJ IDEA, Divis√£o de n√∫meros inteiros </h3><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkSentenceCapitalization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String value)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;String&gt; words = StringUtil.split(value, <span class="hljs-string"><span class="hljs-string">" "</span></span>); .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> capitalized = <span class="hljs-number"><span class="hljs-number">1</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> capitalized / words.size() &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// allow reasonable amount of // capitalized words }</span></span></code> </pre> <br>  Aviso do PVS-Studio: V6011 [CWE-682] O literal '0.2' do tipo 'double' √© comparado com um valor do tipo 'int'.  TitleCapitalizationInspection.java 169 <br><br>  A quest√£o era que a fun√ß√£o retornaria verdadeira se menos de 20% das palavras come√ßarem com uma letra mai√∫scula.  Na verdade, a verifica√ß√£o n√£o est√° funcionando, porque ocorre uma divis√£o inteira.  Como resultado da divis√£o, podemos obter apenas dois valores: 0 ou 1. <br><br>  A fun√ß√£o retornar√° false, apenas se todas as palavras come√ßarem com uma letra mai√∫scula.  Em todos os outros casos, a opera√ß√£o de divis√£o resultar√° em 0 e a fun√ß√£o retornar√° true. <br><br><h3>  IDEA IntelliJ, loop suspeito </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPreviousIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> current)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = myPainter.getErrorStripeCount(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> foundIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> foundLayer = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= current &amp;&amp; current &lt; count) { current--; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index++) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= int layer = getLayer(index); if (layer &gt; foundLayer) { foundIndex = index; foundLayer = layer; } } .... }</span></span></code> </pre> <br>  Aviso do PVS-Studio: V6007 [CWE-571] A express√£o 'index&gt; = 0' √© sempre verdadeira.  Updater.java 184 <br><br>  Primeiro, observe a condi√ß√£o <i>(0 &lt;= atual &amp;&amp; current &lt;count)</i> .  √â executado apenas no caso de o valor da vari√°vel de <i>contagem</i> ser maior que 0. <br><br>  Agora veja o loop: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index++)</code> </pre> <br>  O <i>√≠ndice da</i> vari√°vel √© inicializado com uma express√£o <i>count - 1</i> .  Como a vari√°vel de <i>contagem</i> √© maior que 0, o valor inicial da vari√°vel de <i>√≠ndice</i> sempre ser√° maior ou igual a 0. Acontece que o loop ser√° executado at√© que ocorra um estouro da vari√°vel de <i>√≠ndice</i> . <br><br>  Provavelmente, √© apenas um erro de digita√ß√£o e um decr√©scimo, n√£o √© necess√°rio executar um incremento de uma vari√°vel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index--)</code> </pre> <br><h3>  IDEA IntelliJ, copiar e colar </h3><br><pre> <code class="cpp hljs">@NonNls <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> final String BEFORE_STR_OLD = <span class="hljs-string"><span class="hljs-string">"before:"</span></span>; @NonNls <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> final String AFTER_STR_OLD = <span class="hljs-string"><span class="hljs-string">"after:"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isBeforeOrAfterKeyword</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str, boolean trimKeyword)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (trimKeyword ? LoadingOrder.BEFORE_STR.trim() : LoadingOrder.BEFORE_STR).equalsIgnoreCase(str) || (trimKeyword ? LoadingOrder.AFTER_STR.trim() : LoadingOrder.AFTER_STR).equalsIgnoreCase(str) || LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase(str) || <span class="hljs-comment"><span class="hljs-comment">// &lt;= LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase(str); // &lt;= }</span></span></code> </pre> <br>  Aviso do PVS-Studio: V6001 [CWE-570] Existem sub-express√µes id√™nticas 'LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase (str)' √† esquerda e √† direita da '||'  operador.  Verifique as linhas: 127, 128. ExtensionOrderConverter.java 127 <br><br>  Bom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">efeito</a> antigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">da √∫ltima linha</a> .  Um desenvolvedor pulou a arma e, multiplicando a linha de c√≥digo, esqueceu de corrigi-la.  Como resultado, uma string <i>str</i> √© comparada com <i>BEFORE_STR_OLD</i> duas vezes.  Provavelmente, uma das compara√ß√µes deve ser com <i>AFTER_STR_OLD</i> . <br><br><h3>  IntelliJ IDEA, Typo </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> synchronized boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String name, final Project project)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!StringUtil.startsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\''</span></span>) &amp;&amp; !StringUtil.startsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\"'</span></span>)) { name = <span class="hljs-string"><span class="hljs-string">"\""</span></span> + name; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!StringUtil.endsWithChar(name,<span class="hljs-string"><span class="hljs-string">'"'</span></span>) &amp;&amp; !StringUtil.endsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\"'</span></span>)) { name += <span class="hljs-string"><span class="hljs-string">"\""</span></span>; } .... }</code> </pre> <br>  Aviso do PVS-Studio: V6001 [CWE-571] Existem sub-express√µes id√™nticas '! StringUtil.endsWithChar (name,' "')' √† esquerda e √† direita do operador '&amp;&amp;'. JsonNamesValidator.java 27 <br><br>  Esse fragmento de c√≥digo verifica se o nome est√° entre aspas simples ou duplas.  Caso contr√°rio, as aspas duplas s√£o adicionadas automaticamente. <br><br>  Devido a um erro de digita√ß√£o, o final do nome √© verificado apenas para a presen√ßa de aspas duplas.  Como resultado, o nome entre aspas simples ser√° processado incorretamente. <br><br>  O nome <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">'Abcd'</span></span></code> </pre> <br>  devido √† adi√ß√£o de aspas duplas extras se transformar√° em: <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">'Abcd'</span></span><span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br><h3>  IntelliJ IDEA, prote√ß√£o incorreta contra satura√ß√£o de matriz </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Context </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = offset; i &lt; endOffset; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = text.charAt(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span> &amp;&amp; i &lt; endOffset &amp;&amp; text.charAt(i + <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; startTag != null &amp;&amp; CharArrayUtil.regionMatches(text, i + <span class="hljs-number"><span class="hljs-number">2</span></span>, endOffset, startTag)) { endTagStartOffset = i; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } .... }</code> </pre> <br>  Aviso do PVS-Studio: V6007 [CWE-571] A express√£o 'i &lt;endOffset' sempre √© verdadeira.  EnterAfterJavadocTagHandler.java 183 <br><br>  A subexpress√£o <i>i &lt;endOffset</i> na condi√ß√£o do operador <i>if</i> n√£o faz sentido.  A vari√°vel <i>i</i> √© sempre menor que <i>endOffset</i> em qualquer caso, que segue a condi√ß√£o da execu√ß√£o do loop. <br><br>  Provavelmente, um desenvolvedor queria proteger-se de uma sobrecarga de string ao chamar fun√ß√µes: <br><br><ul><li>  text.charAt (i + 1) </li><li>  CharArrayUtil.regionMatches (texto, i + 2, endOffset, startTag) </li></ul><br>  Nesse caso, a subexpress√£o para verificar o √≠ndice deve ser: <i>(i) &lt;endOffset-2</i> . <br><br><h3>  IDEA IntelliJ, verifica√ß√£o repetida </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateWarningMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { buffer.append(<span class="hljs-string"><span class="hljs-string">" "</span></span>).append( IdeBundle.message(<span class="hljs-string"><span class="hljs-string">"prompt.delete.and"</span></span>)).append(<span class="hljs-string"><span class="hljs-string">" "</span></span>); } } .... }</code> </pre> <br>  Aviso do PVS-Studio: V6007 [CWE-571] A express√£o 'buffer.length ()&gt; 0' √© sempre verdadeira.  DeleteUtil.java 62 <br><br>  Pode ser um c√≥digo redundante in√≥cuo ou um erro crucial. <br><br>  Se uma verifica√ß√£o duplicada aparecer acidentalmente, por exemplo, durante a refatora√ß√£o, n√£o h√° nada de errado nisso.  Voc√™ pode simplesmente excluir a segunda verifica√ß√£o. <br><br>  Outro cen√°rio tamb√©m √© poss√≠vel.  A segunda verifica√ß√£o deve ser bem diferente e o c√≥digo n√£o se comporta conforme o planejado.  Ent√£o √© um erro real. <br><br>  <b>Nota</b>  A prop√≥sito, existem v√°rias verifica√ß√µes redundantes.  Bem, muitas vezes fica claro que n√£o √© um erro.  No entanto, n√£o podemos considerar os avisos do analisador como falsos positivos.  Para uma explica√ß√£o, gostaria de citar um exemplo, tamb√©m retirado do IntelliJ IDEA: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isMultiline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PsiElement element)</span></span></span><span class="hljs-function"> </span></span>{ String text = element.getText(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.contains(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>) || text.contains(<span class="hljs-string"><span class="hljs-string">"\r"</span></span>) || text.contains(<span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); }</code> </pre> <br>  O analisador diz que a fun√ß√£o <i>text.contains ("\ r \ n")</i> sempre retorna false.  De fato, se o caractere "\ n" e "\ r" n√£o for encontrado, n√£o h√° sentido em procurar "\ r \ n".  N√£o √© um bug, e o c√≥digo √© ruim apenas porque funciona um pouco mais devagar, realizando uma pesquisa sem sentido por uma substring. <br><br>  Como lidar com esse c√≥digo, em cada caso, √© uma pergunta para os desenvolvedores.  Ao escrever artigos, geralmente n√£o presto aten√ß√£o a esse c√≥digo. <br><br><h3>  IntelliJ IDEA, algo est√° errado </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">satisfiedBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull PsiElement element)</span></span></span><span class="hljs-function"> </span></span>{ .... @NonNls final String text = expression.getText().replaceAll(<span class="hljs-string"><span class="hljs-string">"_"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (text == null || text.length() &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"0"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0L"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0l"</span></span>.equals(text)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.charAt(<span class="hljs-number"><span class="hljs-number">0</span></span>) == <span class="hljs-string"><span class="hljs-string">'0'</span></span>; }</code> </pre> <br>  Aviso do PVS-Studio: V6007 [CWE-570] A express√£o '"0" .equals (text)' √© sempre falsa.  ConvertIntegerToDecimalPredicate.java 46 <br><br>  O c√≥digo cont√©m um erro l√≥gico, com certeza.  Acho dif√≠cil dizer o que exatamente o programador queria verificar e como corrigir o defeito.  Ent√£o aqui, vou apontar para uma verifica√ß√£o sem sentido. <br><br>  No in√≠cio, deve-se verificar se a sequ√™ncia cont√©m pelo menos dois s√≠mbolos.  Se n√£o for assim, a fun√ß√£o retornar√° <i>false</i> . <br><br>  Em seguida, vem a verifica√ß√£o <i>"0" .equals (texto)</i> .  N√£o faz sentido, porque nenhuma string pode conter apenas um caractere. <br><br>  Ent√£o, algo est√° errado aqui, e o c√≥digo deve ser corrigido. <br><br><h3>  SpotBugs (sucessor de FindBugs), erro de limita√ß√£o no n√∫mero de itera√ß√µes </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getXMLType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@WillNotClose InputStream in)</span></span></span><span class="hljs-function"> throws IOException </span></span>{ .... String s; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (count &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { s = r.readLine(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s == null) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } Matcher m = tag.matcher(s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m.find()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.group(<span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IOException(<span class="hljs-string"><span class="hljs-string">"Didn't find xml tag"</span></span>); .... }</code> </pre> <br>  Aviso do PVS-Studio: V6007 [CWE-571] A express√£o 'contagem &lt;4' √© sempre verdadeira.  Util.java 394 <br><br>  Em teoria, uma pesquisa da tag xml deve ser realizada apenas nas quatro primeiras linhas do arquivo.  Mas, devido ao fato de que se esqueceu de incrementar a vari√°vel <i>count</i> , o arquivo inteiro ser√° lido. <br><br>  Em primeiro lugar, isso pode ser uma opera√ß√£o muito lenta e, em segundo lugar, em algum lugar no meio do arquivo, pode ser encontrado algo que seria percebido como uma tag xml, n√£o sendo ela. <br><br><h3>  SpotBugs (sucessor de FindBugs), compensa√ß√£o de um valor </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reportBug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = LOW_PRIORITY; String pattern = <span class="hljs-string"><span class="hljs-string">"NS_NON_SHORT_CIRCUIT"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sawDangerOld) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sawNullTestVeryOld) { priority = HIGH_PRIORITY; <span class="hljs-comment"><span class="hljs-comment">// &lt;= } if (sawMethodCallOld || sawNumericTestVeryOld &amp;&amp; sawArrayDangerOld) { priority = HIGH_PRIORITY; // &lt;= pattern = "NS_DANGEROUS_NON_SHORT_CIRCUIT"; } else { priority = NORMAL_PRIORITY; // &lt;= } } bugAccumulator.accumulateBug( new BugInstance(this, pattern, priority).addClassAndMethod(this), this); }</span></span></code> </pre> <br>  Aviso do PVS-Studio: V6021 [CWE-563] O valor √© atribu√≠do √† vari√°vel 'priority', mas n√£o √© usado.  FindNonShortCircuit.java 197 <br><br>  O valor da vari√°vel de <i>prioridade</i> √© definido dependendo do valor da vari√°vel <i>sawNullTestVeryOld</i> .  No entanto, isso n√£o importa.  Depois disso, a vari√°vel de <i>prioridade</i> receber√° outro valor em qualquer caso.  Um erro √≥bvio na l√≥gica da fun√ß√£o. <br><br><h3>  SonarQube, copiar e colar </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RuleDto</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final RuleDefinitionDto definition; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final RuleMetadataDto metadata; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpdatedAtFromDefinition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Long updatedAt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (updatedAt != null &amp;&amp; updatedAt &gt; definition.getUpdatedAt()) { setUpdatedAt(updatedAt); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpdatedAtFromMetadata</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Long updatedAt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (updatedAt != null &amp;&amp; updatedAt &gt; definition.getUpdatedAt()) { setUpdatedAt(updatedAt); } } .... }</code> </pre> <br>  PVS-Studio: V6032 √â estranho que o corpo do m√©todo 'setUpdatedAtFromDefinition' seja totalmente equivalente ao corpo de outro m√©todo 'setUpdatedAtFromMetadata'.  Verifique as linhas: 396, 405. RuleDto.java 396 <br><br>  Um campo de <i>defini√ß√£o</i> √© usado no m√©todo <i>setUpdatedAtFromMetadata</i> .  Provavelmente, o campo de <i>metadados</i> deve ser usado.  Isso √© muito semelhante aos efeitos de uma falha de copiar e colar. <br><br><h3>  SonarJava, duplicatas ao inicializar o mapa </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final Map&lt;JavaPunctuator, Tree.Kind&gt; assignmentOperators = Maps.newEnumMap(JavaPunctuator.class); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">KindMaps</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... assignmentOperators.put(JavaPunctuator.PLUSEQU, Tree.Kind.PLUS_ASSIGNMENT); .... assignmentOperators.put(JavaPunctuator.PLUSEQU, Tree.Kind.PLUS_ASSIGNMENT); .... }</code> </pre> <br>  Aviso do PVS-Studio: V6033 [CWE-462] Um item com a mesma chave 'JavaPunctuator.PLUSEQU' j√° foi adicionado.  Verifique as linhas: 104, 100. KindMaps.java 104 <br><br>  O mesmo par de valores-chave √© definido no mapa duas vezes.  Muito provavelmente, aconteceu inadvertidamente e, na verdade, n√£o h√° erro real.  No entanto, esse c√≥digo deve ser verificado em qualquer caso, porque, talvez, algu√©m tenha esquecido de adicionar qualquer outro par. <br><br><h2>  Conclus√£o </h2><br>  Por que escrever conclus√£o quando √© t√£o √≥bvio ?!  Eu sugiro que todos voc√™s baixem o PVS-Studio agora e tentem verificar seus projetos de trabalho na linguagem Java!  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fa√ßa o download do PVS-Studio</a> . <br><br>  Obrigado a todos pela aten√ß√£o.  Espero que em breve agrademos aos nossos leitores com uma s√©rie de artigos sobre a verifica√ß√£o de v√°rios projetos Java de c√≥digo aberto. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt436496/">https://habr.com/ru/post/pt436496/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt436486/index.html">O que est√° acontecendo no mercado de podcast de √°udio</a></li>
<li><a href="../pt436488/index.html">Caril e aplica√ß√£o parcial em C ++ 14</a></li>
<li><a href="../pt436490/index.html">Motorola planeja introduzir a encarna√ß√£o Razr v3</a></li>
<li><a href="../pt436492/index.html">Estamos √† procura de oradores no 10o DIY Mitap 17 de fevereiro de 2019</a></li>
<li><a href="../pt436494/index.html">Substituindo um disco enquanto mant√©m a numera√ß√£o adequada no CEPH</a></li>
<li><a href="../pt436498/index.html">Software AG: N√£o apenas ARIS</a></li>
<li><a href="../pt436500/index.html">Como o quadro de Rise of the Tomb Raider √© renderizado</a></li>
<li><a href="../pt436502/index.html">Pampers de assinatura ou como vender mais para os mesmos clientes</a></li>
<li><a href="../pt436504/index.html">Sistema no pacote ou O que h√° sob a cobertura do pacote de chips?</a></li>
<li><a href="../pt436506/index.html">Como criar um racista de IA sem muito esfor√ßo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>