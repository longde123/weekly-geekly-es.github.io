<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍⚕️ 🔁 🧒🏽 Führen Sie systemd im Container aus 👩‍👩‍👧 🚹 🧘🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir haben das Thema der Verwendung von systemd in Containern schon lange verfolgt. Bereits 2014 schrieb unser Sicherheitsingenieur Daniel Walsh einen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Führen Sie systemd im Container aus</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/468931/">  Wir haben das Thema der Verwendung von systemd in Containern schon lange verfolgt.  Bereits 2014 schrieb unser Sicherheitsingenieur Daniel Walsh einen Artikel mit dem Titel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Running systemd</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in einem Docker-Container</a> und einige Jahre später einen weiteren Artikel mit dem Titel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Running systemd in einem nicht privilegierten Container</a> , in dem er erklärte, dass dies nicht der Fall sei sehr viel verbessert.  Insbesondere schrieb er: „Leider und zwei Jahre später, wenn Sie das Docker-System googeln, erscheint als erstes derselbe alte Artikel von ihm.  Es ist also Zeit, etwas zu ändern. “  Darüber hinaus haben wir bereits über den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Konflikt zwischen den Entwicklern von Docker und systemd gesprochen</a> . <br><br><img src="https://habrastorage.org/webt/jw/is/oz/jwisoz8445mav6kqiwqr7gwpjns.png" width="100%"><br><br>  In diesem Artikel werden wir zeigen, was sich in der letzten Zeit geändert hat und wie Podman uns in dieser Angelegenheit helfen kann. <br><a name="habracut"></a><br>  Es gibt viele Gründe, systemd in einem Container auszuführen, z. <br><br><ol><li>  <b>Multiservice-Container</b> - Viele <b>Benutzer</b> möchten ihre Multiservice-Anwendungen aus virtuellen Maschinen <b>herausholen</b> und in Containern ausführen.  Es wäre natürlich besser, solche Anwendungen in Microservices zu unterteilen, aber noch kann nicht jeder dies tun, oder es bleibt einfach keine Zeit.  Daher ist das Starten solcher Anwendungen in Form von Diensten, die von systemd aus Einheitendateien gestartet werden, absolut sinnvoll. </li><li>  <b>Systemd-Einheitendateien</b> - Die meisten Anwendungen, die in Containern ausgeführt werden, werden aus Code kompiliert, der zuvor auf virtuellen oder physischen Maschinen ausgeführt wurde.  Diese Anwendungen verfügen über eine Einheitendatei, die für diese Anwendungen geschrieben wurde und deren Ausführung versteht.  Es ist daher besser, die Dienste mit den unterstützten Methoden zu starten, als Ihren eigenen Init-Dienst zu hacken. </li><li>  <b>Systemd ist ein Prozessmanager.</b>  Es verwaltet Dienste (fährt herunter, startet Dienste neu oder crawlt Zombie-Prozesse) besser als jedes andere Tool. </li></ol><br>  Es gibt viele Gründe, systemd nicht in Containern auszuführen.  Das wichtigste ist, dass systemd / journald die Ausgabe von Containern steuert und Tools wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenShift</a> erwarten, dass Container das Protokoll direkt in stdout und stderr schreiben.  Wenn Sie Container über Orchestrierungs-Tools wie die oben genannten verwalten möchten, müssen Sie daher die Verwendung von Containern auf der Basis von systemd ernsthaft in Betracht ziehen.  Darüber hinaus waren die Entwickler von Docker und Moby häufig stark gegen die Verwendung von systemd in Containern. <br><br><h3>  Podman kommt </h3><br>  Wir freuen uns, Ihnen mitteilen zu können, dass sich die Situation endlich geändert hat.  Das Team, das für den Start von Containern bei Red Hat verantwortlich ist, hat beschlossen, eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eigene Containermaschine zu entwickeln</a> .  Er erhielt den Namen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Podman</a> und bietet die gleiche Befehlszeilenschnittstelle (CLI) wie Docker.  Und fast alle Docker-Befehle können in Podman auf dieselbe Weise verwendet werden.  Wir veranstalten häufig Seminare, die jetzt als " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker in Podman ändern" bezeichnet werden. Auf</a> der ersten Folie werden Sie aufgefordert, sich zu registrieren: alias docker = podman. <br><br>  Viele tun dies. <br><br>  Mein Podman und ich sind in keiner Weise gegen systemd-basierte Container.  Schließlich wird Systemd am häufigsten als Linux-Init-Subsystem verwendet. Wenn es in Containern nicht normal funktioniert, muss ignoriert werden, wie Tausende von Menschen es gewohnt sind, Container auszuführen. <br><br>  Podman weiß, was zu tun ist, damit systemd im Container ordnungsgemäß funktioniert.  Sie braucht Dinge wie das Mounten von tmpfs auf / run und / tmp.  Sie mag es, wenn die "Container" -Umgebung aktiviert ist und sie auf Schreibberechtigungen für ihren Teil des cgroup-Verzeichnisses und für den Ordner / var / log / journald wartet. <br><br>  Beim Starten eines Containers, in dem init oder systemd der erste Befehl ist, konfiguriert Podman tmpfs und Cgroups automatisch so, dass systemd problemlos gestartet wird.  Verwenden Sie die Option --systemd = false, um diesen Autostartmodus zu blockieren.  Bitte beachten Sie, dass Podman den systemd-Modus nur verwendet, wenn er sieht, dass der Befehl systemd oder init ausgeführt werden muss. <br><br>  Hier ist ein Auszug aus dem Handbuch: <br><br><blockquote>  Mann Podman laufen <br>  ... <br><br>  –Systemd = true | false <br><br>  Ausführen des Containers im systemd-Modus.  Standardmäßig aktiviert. <br><br>  Wenn ein systemd- oder init-Befehl im Container ausgeführt wird, konfiguriert Podman die tmpfs-Mountpunkte in den folgenden Verzeichnissen: <br><br>  / run, / run / lock, / tmp, / sys / fs / cgroup / systemd, / var / lib / journal <br><br>  Außerdem wird SIGRTMIN + 3 standardmäßig als Stoppsignal verwendet. <br><br>  All dies ermöglicht es systemd, ohne Änderungen in einem geschlossenen Container zu arbeiten. <br><br>  HINWEIS: systemd versucht, in das cgroup-Dateisystem zu schreiben.  Standardmäßig verhindert SELinux jedoch, dass Container dies tun.  Aktivieren Sie zum Aktivieren des Schreibens den Stapelparameter container_manage_cgroup: <br><br>  setsebool -P container_manage_cgroup true <br></blockquote><br>  Schauen Sie sich nun an, wie die Docker-Datei aussieht, um systemd im Container auszuführen, wenn Sie Podman verwenden: <br><br><pre><code class="plaintext hljs"># cat Dockerfile FROM fedora RUN dnf -y install httpd; dnf clean all; systemctl enable httpd EXPOSE 80 CMD [ "/sbin/init" ]</code> </pre> <br>  Das ist alles. <br><br>  Sammeln Sie nun den Behälter: <br><br><pre> <code class="plaintext hljs"># podman build -t systemd .</code> </pre><br>  Wir weisen SELinux an, systemd zu erlauben, die Konfiguration von Cgroups zu ändern: <br><br><pre> <code class="plaintext hljs"># setsebool -P container_manage_cgroup true</code> </pre><br>  Viele vergessen diesen Schritt übrigens.  Glücklicherweise reicht es aus, dies nur einmal zu tun, und die Einstellung wird nach einem Systemneustart gespeichert. <br><br>  Führen Sie jetzt einfach den Container aus: <br><br><pre> <code class="plaintext hljs"># podman run -ti -p 80:80 systemd systemd 239 running in system mode. (+PAM +AUDIT +SELINUX +IMA -APPARMOR +SMACK +SYSVINIT +UTMP +LIBCRYPTSETUP +GCRYPT +GNUTLS +ACL +XZ +LZ4 +SECCOMP +BLKID +ELFUTILS +KMOD +IDN2 -IDN +PCRE2 default-hierarchy=hybrid) Detected virtualization container-other. Detected architecture x86-64. Welcome to Fedora 29 (Container Image)! Set hostname to &lt;1b51b684bc99&gt;. Failed to install release agent, ignoring: Read-only file system File /usr/lib/systemd/system/systemd-journald.service:26 configures an IP firewall (IPAddressDeny=any), but the local system does not support BPF/cgroup based firewalling. Proceeding WITHOUT firewalling in effect! (This warning is only shown for the first loaded unit using IP firewalling.) [ OK ] Listening on initctl Compatibility Named Pipe. [ OK ] Listening on Journal Socket (/dev/log). [ OK ] Started Forward Password Requests to Wall Directory Watch. [ OK ] Started Dispatch Password Requests to Console Directory Watch. [ OK ] Reached target Slices. … [ OK ] Started The Apache HTTP Server.</code> </pre><br>  Alles, der Service hat begonnen und funktioniert: <br><br><pre> <code class="plaintext hljs">$ curl localhost &lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt; … &lt;/html&gt;</code> </pre><br>  HINWEIS: Versuchen Sie nicht, dies auf Docker zu wiederholen!  Dort werden noch Tänze mit einem Tamburin benötigt, um solche Behälter durch einen Dämon zu starten.  (Damit dies in Docker nahtlos funktioniert, sind zusätzliche Felder und Pakete erforderlich, oder es muss in einem privilegierten Container ausgeführt werden. Weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen finden</a> Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> .) <br><br><h3>  Noch ein paar coole Sachen über Podman und systemd </h3><br><h4>  Podman funktioniert in systemd-Unit-Dateien besser als Docker </h4><br>  Wenn die Container beim Systemstart gestartet werden müssen, können Sie einfach die entsprechenden Podman-Befehle in die systemd-Einheitendatei einfügen, um den Dienst zu starten und zu überwachen.  Podman verwendet das Standard-Fork-Exec-Modell.  Mit anderen Worten, Containerprozesse sind mit dem Podman-Prozess verbunden, sodass systemd sie problemlos überwachen kann. <br><br>  Docker verwendet das Client-Server-Modell, und Docker-CLI-Befehle können auch direkt in die Einheitendatei eingefügt werden.  Nachdem der Docker-Client jedoch eine Verbindung zum Docker-Dämon hergestellt hat, wird er (der Client) nur ein weiterer Prozess, der stdin und stdout verarbeitet.  Systemd hat wiederum keine Ahnung von der Verbindung zwischen dem Docker-Client und dem Container, auf dem der Docker-Dämon ausgeführt wird, und daher kann systemd unter diesem Modell den Dienst nicht grundlegend überwachen. <br><br><h4>  Systemd Aktivierung über Socket </h4><br>  Podman führt die Aktivierung über einen Socket korrekt aus.  Da Podman das Fork-Exec-Modell verwendet, kann es einen Socket an seine untergeordneten Containerprozesse weiterleiten.  Docker weiß nicht wie, da es ein Client-Server-Modell verwendet. <br><br>  Der Varlink-Dienst, den Podman verwendet, um mit Remoteclients mit Containern zu interagieren, wird tatsächlich über den Socket aktiviert.  Das in Node.js geschriebene Cockpit-Podman-Paket, das Teil des Cockpit-Projekts ist, ermöglicht die Interaktion mit Podman-Containern über eine Weboberfläche.  Der Web-Daemon, auf dem Cockpit-Podman ausgeführt wird, sendet Nachrichten an den Varlink-Socket, den systemd abhört.  Danach aktiviert systemd das Podman-Programm, um Nachrichten zu empfangen und Container zu verwalten.  Wenn Sie systemd über einen Socket aktivieren, können Sie bei der Implementierung von Remote-APIs auf einen ständig funktionierenden Daemon verzichten. <br><br>  Darüber hinaus entwickeln wir einen weiteren Client für Podman namens podman-remote, der dieselbe Podman-CLI implementiert, jedoch varlink aufruft, um Container zu starten.  Podman-remote kann zusätzlich zu SSH-Sitzungen arbeiten, sodass Sie sicher mit Containern auf verschiedenen Computern interagieren können.  Im Laufe der Zeit planen wir, podman-remote zur Unterstützung von MacOS und Windows zusammen mit Linux zu verwenden, damit Entwickler auf diesen Plattformen die virtuelle Linux-Maschine mit Podman varlink ausführen können und das volle Gefühl haben, dass die Container auf dem lokalen Computer ausgeführt werden. <br><br><h4>  SD_NOTIFY </h4><br>  Mit Systemd können Sie den Start von Zusatzdiensten verzögern, bis der erforderliche Containerdienst gestartet wird.  Podman kann den Socket SD_NOTIFY an den containerisierten Dienst weiterleiten, damit der Dienst systemd über seine Arbeitsbereitschaft informiert.  Und wieder weiß Docker, das das Client-Server-Modell verwendet, nicht wie. <br><br><h3>  In den Plänen </h3><br>  Wir planen, den Befehl podman generate systemd CONTAINERID hinzuzufügen, der die systemd-Einheitendatei generiert, um einen bestimmten Container zu verwalten.  Dies sollte sowohl im Root- als auch im Rootless-Modus für nicht privilegierte Container funktionieren.  Wir haben sogar eine Anfrage zum Erstellen einer OCI-kompatiblen systemd-nspawn-Laufzeit gesehen. <br><br><h3>  Fazit </h3><br>  Das Ausführen von systemd in einem Container ist verständlich.  Und dank Podman haben wir endlich eine Container-Launcher-Umgebung, die nicht systemd feindlich ist, aber einfach zu bedienen ist. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468931/">https://habr.com/ru/post/de468931/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468913/index.html">Amazon Dash Button: Rückblick</a></li>
<li><a href="../de468915/index.html">Wie überwacht Cisco die Informationssicherheit absorbierter Unternehmen und bietet ihnen Zugriff auf ihre Ressourcen?</a></li>
<li><a href="../de468923/index.html">Ich rufe dich zurück</a></li>
<li><a href="../de468927/index.html">Quintett statt Byte - Ansatz zum Speichern und Abrufen von Daten</a></li>
<li><a href="../de468929/index.html">Das Mini-Handbuch zum Einrichten eines Hackintosh ist so einfach und schmerzlos wie möglich</a></li>
<li><a href="../de468933/index.html">Stachelig und scharf, wohin Sie auch schauen: der Mechanismus des Selbstschärfens der Zähne von Seeigeln</a></li>
<li><a href="../de468935/index.html">Die Zusammenfassung der Ereignisse für HR-Experten im Bereich IT im Oktober 2019</a></li>
<li><a href="../de468937/index.html">Kontaktlose Bankkartenangriffe</a></li>
<li><a href="../de468943/index.html">dies und ScopeChain in EcmaScript</a></li>
<li><a href="../de468945/index.html">ITIL und ITSM sind eine Geschichte großer Täuschung. Gibt es einen Vorteil? Wie viel kostet es und wer genau implementiert ITIL NICHT?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>