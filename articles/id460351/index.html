<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🎓 🎅🏾 🧣 werf - alat kami untuk CI / CD di Kubernetes (ulasan dan laporan video) 🔖 🧠 🆘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada tanggal 27 Mei, di aula utama konferensi DevOpsConf 2019, diadakan sebagai bagian dari festival RIT ++ 2019 , sebagai bagian dari bagian Pengirim...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>werf - alat kami untuk CI / CD di Kubernetes (ulasan dan laporan video)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/460351/">  Pada tanggal 27 Mei, di aula utama konferensi DevOpsConf 2019, diadakan sebagai bagian dari festival <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RIT ++ 2019</a> , sebagai bagian dari bagian Pengiriman Berkelanjutan, sebuah laporan dibuat “bukan alat kami untuk CI / CD di Kubernetes”.  Ini berbicara tentang <b>masalah dan tantangan yang dihadapi semua orang ketika menggunakan Kubernetes</b> , serta tentang nuansa yang mungkin tidak segera terlihat.  Menganalisis solusi yang mungkin, kami menunjukkan bagaimana ini diimplementasikan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alat</a> Open Source <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">werf</a> . <br><br>  Sejak pertunjukan, utilitas kami (sebelumnya dikenal sebagai dapp) telah mengatasi batas historis <b>1000 bintang di GitHub</b> - kami berharap bahwa komunitas penggunanya yang berkembang akan menyederhanakan kehidupan banyak insinyur DevOps. <br><br><img src="https://habrastorage.org/webt/lh/k9/x1/lhk9x1wf3gzo6bk1lsjosnvjg1g.jpeg"><br><br>  Jadi, kami menyajikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>video dengan laporan</b></a> (~ 47 menit, jauh lebih informatif daripada artikel) dan ekstrak utama darinya dalam bentuk teks.  Ayo pergi! <a name="habracut"></a><br><br><h2>  Pengiriman Kode dalam Kubernetes </h2><br>  Pembicaraan tidak lagi tentang werf, tetapi tentang CI / CD di Kubernetes, menyiratkan bahwa perangkat lunak kami dikemas dalam wadah Docker <i>(saya berbicara tentang ini dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan 2016</a> )</i> , dan K8 akan digunakan untuk meluncurkannya dalam produksi <i>(tentang ini - tahun <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2017</a> )</i> . <br><br>  Seperti apa bentuk pengiriman Kubernet? <br><br><ul><li>  Ada repositori Git dengan kode dan instruksi untuk membangunnya.  Aplikasi ini dikompilasi ke dalam gambar Docker dan diterbitkan ke Docker Registry. </li><li>  Dalam repositori yang sama ada instruksi tentang cara menggunakan dan menjalankan aplikasi.  Pada tahap penerapan, instruksi ini dikirim ke Kubernetes, yang menerima gambar yang diinginkan dari registri dan memulainya. </li><li>  Plus, biasanya ada tes.  Beberapa di antaranya dapat dilakukan saat menerbitkan gambar.  Anda juga dapat (dengan instruksi yang sama) menggunakan salinan aplikasi (dalam ruang nama K8 yang terpisah atau dalam kelompok yang terpisah) dan menjalankan tes di sana. </li><li>  Akhirnya, kita membutuhkan sistem CI yang menerima acara dari Git (atau klik tombol) dan memanggil semua tahapan yang ditunjukkan: bangun, publikasikan, sebarkan, uji. </li></ul><br><img src="https://habrastorage.org/webt/vd/jh/ks/vdjhksq3874swybast6v7oerqe4.gif"><br><br>  Ada beberapa catatan penting di sini: <br><br><ol><li>  Karena kita memiliki infrastruktur yang tidak dapat diubah, citra aplikasi yang digunakan di semua tahap (pementasan, produksi, dll.) <b>Harus menjadi satu</b> .  <i>Saya berbicara lebih banyak tentang ini dan dengan contoh di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .</i> </li><li>  Karena kita mengikuti pendekatan infrastruktur sebagai kode <i>(IaC)</i> , kode aplikasi dan instruksi untuk membangun dan menjalankannya harus berada <b>dalam satu repositori</b> .  <i>Untuk lebih lanjut tentang ini, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan yang sama</a> .</i> </li><li>  Kami biasanya melihat rantai pengiriman <i>(pengiriman)</i> seperti ini: aplikasi dirakit, diuji, dirilis <i>(tahap rilis)</i> dan itu saja - pengiriman telah terjadi.  Tetapi pada kenyataannya, pengguna menerima apa yang Anda keluarkan, <b>bukan</b> ketika Anda mengirimkannya ke produksi, tetapi ketika ia bisa pergi ke sana dan produksi ini berhasil.  Oleh karena itu, saya percaya bahwa rantai pengiriman berakhir <b>hanya pada tahap operasional</b> <i>(berjalan)</i> , dan lebih tepatnya, bahkan pada saat kode dihapus dari produksi (menggantinya dengan yang baru). </li></ol><br>  Mari kita kembali ke skema pengiriman Kubernet yang ditunjukkan di atas: skema itu diciptakan tidak hanya oleh kita, tetapi juga oleh setiap orang yang menangani masalah ini.  Intinya, pola ini sekarang disebut GitOps <i>(lebih lanjut tentang istilah dan ide-ide di baliknya dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> )</i> .  Mari kita lihat tahapan skema. <br><br><h2>  Membangun panggung </h2><br>  Tampaknya pada 2019 Anda bisa memberi tahu tentang perakitan gambar Docker, ketika semua orang tahu cara menulis Dockerfiles dan menjalankan <code>docker build</code> ? .. Berikut adalah nuansa yang ingin saya perhatikan: <br><br><ol><li>  <b>Bobot</b> masalah <b>gambar</b> , jadi gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">multi-stage</a> untuk hanya menyisakan aplikasi yang benar-benar diperlukan untuk gambar. </li><li>  <b>Jumlah layer</b> harus diminimalkan dengan menggabungkan rantai perintah <code>RUN</code> dalam artinya. </li><li>  Namun, ini menambah masalah <b>debugging</b> , karena ketika perakitan crash, Anda harus menemukan perintah yang diperlukan dari rantai yang menyebabkan masalah. </li><li>  <b>Kecepatan build itu</b> penting karena kami ingin segera melakukan perubahan dan melihat hasilnya.  Misalnya, saya tidak ingin memasang kembali dependensi di perpustakaan bahasa dengan setiap versi aplikasi. </li><li>  Seringkali, <b>banyak gambar</b> diperlukan dari satu repositori Git, yang dapat diselesaikan dengan satu set Dockerfiles (atau tahap bernama dalam satu file) dan skrip Bash dengan rakitan berurutan mereka. </li></ol><br>  Itu hanya puncak gunung es yang semua orang hadapi.  Tetapi ada masalah lain, dan khususnya: <br><br><ol><li>  Seringkali pada tahap perakitan kita perlu <b>me</b> - <b>mount</b> sesuatu (misalnya, cache hasil dari perintah seperti apt ke direktori pihak ketiga). </li><li>  Kami ingin <b>Ansible</b> daripada menulis di shell. </li><li>  Kami ingin <b>membangun tanpa Docker</b> (mengapa kami membutuhkan mesin virtual tambahan di mana Anda perlu mengonfigurasi semuanya untuk ini ketika sudah ada kluster Kubernet di mana Anda dapat menjalankan kontainer?). </li><li>  <b>Perakitan paralel</b> , yang dapat dipahami dengan cara yang berbeda: perintah berbeda dari Dockerfile (jika multi-stage digunakan), beberapa komit dari satu repositori, beberapa Dockerfiles. </li><li>  <b>Perakitan terdistribusi</b> : kami ingin mengumpulkan sesuatu di pod yang “ephemeral”, karena  cache mereka menghilang, yang berarti perlu disimpan di suatu tempat secara terpisah. </li><li>  Akhirnya, saya menyebut puncak dari hasrat otomatis: akan ideal untuk masuk ke dalam repositori, mengetik beberapa tim dan mendapatkan gambar yang sudah jadi, berkumpul dengan pemahaman tentang bagaimana dan apa yang harus dilakukan dengan benar.  Namun, saya pribadi tidak yakin bahwa semua nuansa dapat diramalkan dengan cara ini. </li></ol><br>  Dan inilah proyeknya: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">moby / buildkit</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pembangun</a> dari perusahaan Docker Inc (sudah terintegrasi ke dalam versi Docker saat ini), yang mencoba menyelesaikan semua masalah ini; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kaniko</a> - seorang kolektor dari Google, yang memungkinkan Anda membangun tanpa Docker; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Buildpacks.io</a> - upaya oleh CNCF untuk melakukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">auto-</a> magis dan, khususnya, solusi menarik dengan rebase untuk layer; </li><li>  dan banyak utilitas lain seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buildah</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">genuinetools / img</a> ... </li></ul><br>  ... dan lihat berapa banyak bintang yang mereka miliki di GitHub.  Yaitu, di satu sisi, <code>docker build</code> adalah dan dapat melakukan sesuatu, tetapi dalam kenyataannya, <b>masalah tersebut belum sepenuhnya diselesaikan</b> - ini dibuktikan dengan pengembangan paralel dari pembangun alternatif, yang masing-masing memecahkan beberapa masalah. <br><br><h2>  Bangun di werf </h2><br>  Jadi kita harus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">werf</a> <i>(sebelumnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dikenal</a> sebagai dapp)</i> - utilitas Open Source dari Flant, yang telah kita lakukan selama bertahun-tahun.  Semuanya dimulai sekitar 5 tahun yang lalu dengan skrip Bash yang mengoptimalkan perakitan Dockerfiles, dan 3 tahun terakhir, pengembangan penuh telah berlangsung dalam kerangka satu proyek dengan repositori Git sendiri <i>(pertama di Ruby, dan kemudian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditulis ulang</a> untuk Go, dan pada saat yang sama diganti namanya)</i> .  Apa masalah pembangunan yang diselesaikan di werf? <br><br><img src="https://habrastorage.org/webt/--/1-/ca/--1-cakzswwfhrcrgnees6cvf-a.png"><br><br>  Masalah berbayang biru telah diimplementasikan, perakitan paralel telah dilakukan dalam host yang sama, dan kami berencana untuk menyelesaikan pertanyaan kuning pada akhir musim panas. <br><br><h2>  Tahap publikasi dalam registri (terbitkan) </h2><br>  Kami mengetikkan <code>docker push</code> ... - apa yang bisa sulit dalam mengunggah gambar ke registri?  Dan kemudian muncul pertanyaan: "Tag apa untuk meletakkan gambar?"  Itu muncul karena kami memiliki <b>Gitflow</b> (atau strategi Git lain) dan Kubernetes, dan industri berkomitmen untuk memastikan bahwa apa yang terjadi di Kubernetes mengikuti apa yang sedang dilakukan di Git.  Git adalah satu-satunya sumber kebenaran kami. <br><br>  Apa yang rumit?  <b>Pastikan reproduktifitas</b> : dari komit di Git, yang secara inheren <i>tidak</i> dapat <i>diubah</i> , ke gambar Docker yang harus dijaga tetap sama. <br><br>  Penting juga bagi kita untuk <b>menentukan asal</b> , karena kita ingin memahami dari mana komit aplikasi yang diluncurkan di Kubernetes dibangun (maka kita dapat melakukan hal-hal yang berbeda dan serupa). <br><br><h3>  Strategi penandaan </h3><br>  Yang pertama adalah <b>tag git</b> sederhana.  Kami memiliki registri dengan gambar yang ditandai sebagai <code>1.0</code> .  Kubernetes memiliki tahap dan produksi, tempat gambar ini dipompa.  Di Git, kami membuat komitmen dan pada titik tertentu memasang tag <code>2.0</code> .  Kami mengumpulkannya sesuai dengan instruksi dari repositori dan memasukkannya ke dalam registri dengan tag <code>2.0</code> .  Kami meluncurkannya di atas panggung dan, jika semuanya baik-baik saja, maka pada produksi. <br><br><img src="https://habrastorage.org/webt/4f/ub/u4/4fubu4r-0obh9gkzs4_kftnlqxs.gif"><br><br>  Masalah dengan pendekatan ini adalah bahwa kita pertama-tama mengatur tag, dan baru kemudian menguji dan meluncurkannya.  Mengapa  Pertama, ini sama sekali tidak masuk akal: kami memberikan versi perangkat lunak yang bahkan belum kami uji (kami tidak bisa melakukan sebaliknya, karena untuk mengecek, Anda perlu memberi tag).  Kedua, cara ini tidak kompatibel dengan Gitflow. <br><br>  Opsi kedua adalah <b>git commit + tag</b> .  Ada tag <code>1.0</code> di cabang master;  baginya dalam registri - gambar yang digunakan untuk produksi.  Selain itu, kluster Kubernetes memiliki pratinjau dan pementasan loop.  Selanjutnya kami mengikuti Gitflow: di cabang utama untuk pengembangan kami <code>develop</code> fitur-fitur baru, sebagai akibatnya ada komit dengan pengenal <code>#c1</code> .  Kami mengumpulkannya dan menerbitkannya di registri menggunakan pengenal ini ( <code>#c1</code> ).  Kami meluncurkan pratinjau dengan pengidentifikasi yang sama.  Kami melakukan hal yang sama dengan komit <code>#c2</code> dan <code>#c3</code> . <br><br>  Ketika kami menyadari bahwa ada cukup fitur, kami mulai menstabilkan semuanya.  Di Git, buat cabang <code>release_1.1</code> (berdasarkan <code>#c3</code> dari <code>develop</code> ).  Mengumpulkan rilis ini tidak diperlukan, karena  Ini dilakukan pada langkah sebelumnya.  Karena itu, kita bisa langsung menggelarnya untuk pementasan.  Kami memperbaiki bug di <code>#c4</code> dan juga melakukan pementasan.  Pada saat yang sama, pengembangan sedang berlangsung di <code>develop</code> , di mana perubahan dari <code>release_1.1</code> dilakukan secara berkala.  Pada titik tertentu, kita mendapatkan komitmen dan dorongan untuk melakukan komitmen, yang kita <code>#c25</code> ( <code>#c25</code> ). <br><br>  Lalu kami melakukan penggabungan (dengan fast-forward) dari cabang rilis ( <code>release_1.1</code> ) di master.  Kami memberi tag dengan versi baru ( <code>1.1</code> ) di komit ini.  Tetapi gambar ini sudah dirangkai dalam registri, jadi agar tidak mengumpulkannya lagi, kami hanya menambahkan tag kedua ke gambar yang ada (sekarang memiliki tag <code>#c25</code> dan <code>1.1</code> di registri).  Setelah itu, kami meluncurkannya untuk produksi. <br><br>  Ada kekurangan bahwa satu gambar ( <code>#c25</code> ) <code>#c25</code> saat pementasan, dan yang lain ( <code>1.1</code> ) <code>#c25</code> saat produksi, tetapi kita tahu bahwa "secara fisik" itu adalah gambar yang sama dari registri. <br><br><img src="https://habrastorage.org/webt/mb/pq/iu/mbpqiumzomvrouhp8llx5aishza.gif"><br><br>  Kekurangan sebenarnya adalah bahwa tidak ada dukungan untuk menggabungkan commit'ov, Anda perlu melakukan fast-forward. <br><br>  Anda dapat melangkah lebih jauh dan melakukan trik ... Pertimbangkan contoh Dockerfile sederhana: <br><br><pre> <code class="plaintext hljs">FROM ruby:2.3 as assets RUN mkdir -p /app WORKDIR /app COPY . ./ RUN gem install bundler &amp;&amp; bundle install RUN bundle exec rake assets:precompile CMD bundle exec puma -C config/puma.rb FROM nginx:alpine COPY --from=assets /app/public /usr/share/nginx/www/public</code> </pre> <br>  Kami membuat file darinya sesuai dengan prinsip ini, yang kami ambil: <br><br><ul><li>  SHA256 dari pengidentifikasi gambar yang digunakan ( <code>ruby:2.3</code> dan <code>nginx:alpine</code> ), yang merupakan checksum dari isinya; </li><li>  semua tim ( <code>RUN</code> , <code>CMD</code> , dll.); </li><li>  SHA256 dari file yang ditambahkan. </li></ul><br>  ... dan ambil checksum (lagi SHA256) dari file seperti itu.  Ini adalah <b>tanda tangan dari</b> segala sesuatu yang mendefinisikan konten gambar Docker. <br><br><img src="https://habrastorage.org/webt/zp/w2/ju/zpw2jup54xa66mit1bt9u7amwlk.gif"><br><br>  Mari kita kembali ke skema dan <b>alih-alih melakukan kita akan menggunakan tanda tangan seperti itu</b> , yaitu  beri tag pada gambar dengan tanda tangan. <br><br><img src="https://habrastorage.org/webt/pr/d3/wf/prd3wfn6ctkod9ddqqmgtqnr1ew.gif"><br><br>  Sekarang, ketika Anda perlu, misalnya, untuk menggabungkan perubahan dari rilis menjadi master, kita dapat membuat komit gabungan: ia akan memiliki pengidentifikasi yang berbeda, tetapi tanda tangan yang sama.  Dengan pengidentifikasi yang sama, kami juga akan meluncurkan gambar pada produksi. <br><br>  Kerugiannya adalah bahwa sekarang tidak mungkin untuk menentukan jenis komit apa yang telah dipompa untuk produksi - checksum hanya bekerja dalam satu arah.  Masalah ini diselesaikan oleh lapisan tambahan dengan metadata - saya akan memberi tahu Anda lebih banyak nanti. <br><br><h3>  Menandai di werf </h3><br>  Dalam werf, kami telah melangkah lebih jauh dan bersiap untuk membuat rakitan terdistribusi dengan cache yang tidak disimpan pada mesin yang sama ... Jadi, kami memiliki dua jenis gambar Docker, kami menyebutnya <i>tahap</i> dan <i>gambar</i> . <br><br>  Repositori werf Git menyimpan instruksi pembangunan spesifik yang menjelaskan berbagai tahapan pembangunan ( <i>sebelum</i> <i>menginstal</i> , <i>menginstal</i> , <i>sebelum</i> <i>pemasangan</i> , <i>pengaturan</i> ).  Kami mengumpulkan gambar tahap pertama dengan tanda tangan yang ditetapkan sebagai checksum dari langkah pertama.  Kemudian kami menambahkan kode sumber, untuk gambar panggung baru kami menganggap checksumnya ... Operasi ini diulangi untuk semua tahap, sebagai hasilnya kami mendapatkan satu set gambar panggung.  Kemudian kita membuat gambar-gambar akhir yang mengandung juga metadata tentang asalnya.  Dan kami memberi tag pada gambar ini dengan berbagai cara (detail nanti). <br><br><img src="https://habrastorage.org/webt/4a/uw/am/4auwamdra7bm0xtvht35kpbstye.gif"><br><br>  Biarkan setelah itu komit baru muncul, di mana hanya kode aplikasi yang diubah.  Apa yang akan terjadi  Sebuah tambalan akan dibuat untuk perubahan kode, gambar tahap baru akan disiapkan.  Tanda tangannya akan didefinisikan sebagai checksum dari gambar panggung lama dan tambalan baru.  Dari gambar ini gambar-gambar akhir baru akan terbentuk.  Perilaku serupa akan terjadi dengan perubahan pada tahap lain. <br><br>  Dengan demikian, gambar panggung adalah cache yang dapat didistribusikan didistribusikan, dan gambar gambar yang sudah dibuat darinya dimuat ke dalam Docker Registry. <br><br><img src="https://habrastorage.org/webt/sc/8j/me/sc8jme4f1jfqbrbwt1anf2-rja8.gif"><br><br><h3>  Membersihkan registri </h3><br>  Ini bukan tentang menghapus lapisan yang tetap menggantung setelah tag yang dihapus - ini adalah fitur standar dari Docker Registry itu sendiri.  Ini adalah situasi di mana banyak tag Docker terakumulasi dan kami memahami bahwa kami tidak lagi membutuhkannya, dan tag tersebut menghabiskan ruang (dan / atau kami membayarnya). <br><br>  Apa strategi pembersihannya? <br><br><ol><li>  Anda <b>tidak</b> bisa <b>membersihkan</b> apa pun.  Terkadang lebih mudah untuk membayar sedikit untuk ruang ekstra daripada mengungkap banyak tag.  Tetapi ini hanya bekerja sampai titik tertentu. </li><li>  <b>Reset penuh</b> .  Jika Anda menghapus semua gambar dan hanya membangun kembali yang relevan dalam sistem CI, maka masalah mungkin muncul.  Jika wadah dimulai kembali pada produksi, gambar baru akan dimuat untuk itu - yang belum diuji oleh siapa pun.  Ini membunuh gagasan infrastruktur yang tidak bisa diubah. </li><li>  <b>Biru-hijau</b>  Satu registry mulai meluap - memuat gambar ke yang lain.  Masalah yang sama seperti pada metode sebelumnya: pada titik apa Anda bisa membersihkan registri yang mulai meluap? </li><li>  <b>Waktu</b>  Hapus semua gambar yang lebih dari 1 bulan?  Tapi pasti ada layanan yang belum diperbarui selama sebulan ... </li><li>  Tentukan <b>secara manual</b> apa yang sudah bisa dihapus. </li></ol><br>  Ada dua opsi yang sangat layak: jangan bersihkan atau kombinasi biru-hijau + secara manual.  Dalam kasus yang terakhir, kita berbicara tentang yang berikut: ketika Anda memahami bahwa sudah waktunya untuk membersihkan registri, membuat yang baru dan menambahkan semua gambar baru ke dalamnya untuk, misalnya, sebulan.  Sebulan kemudian, lihat pod mana di Kubernet yang masih menggunakan registry lama, dan transfer juga ke registry baru. <br><br>  <b>Kemana</b> kita <b>pergi</b> ke <b>werf</b> ?  Kami mengumpulkan: <br><br><ol><li>  Git head: semua tag, semua cabang, - dengan asumsi bahwa segala sesuatu yang diuji di Git, kita perlu dalam gambar (dan jika tidak, kita perlu menghapus di Git itu sendiri); </li><li>  semua pod yang sekarang diunduh di Kubernetes; </li><li>  ReplicaSets lama (sesuatu yang baru-baru ini dipompa keluar), serta kami berencana untuk memindai rilis Helm dan memilih gambar terbaru di sana. </li></ol><br>  ... dan kami membuat daftar putih dari set ini - daftar gambar yang tidak akan kami hapus.  Kami membersihkan segala sesuatu yang lain, setelah itu kami menemukan gambar panggung anak yatim dan menghapusnya juga. <br><br><h2>  Tahap penerapan (penerapan) </h2><br><h3>  Deklaratif yang kuat </h3><br>  Poin pertama yang ingin saya perhatikan dalam penyebaran adalah untuk meluncurkan konfigurasi sumber daya yang diperbarui, dideklarasikan secara deklaratif.  Dokumen YAML asli yang menggambarkan sumber daya Kubernetes selalu sangat berbeda dari hasil yang benar-benar berfungsi di cluster.  Karena Kubernetes menambah konfigurasi: <br><br><ol><li>  pengidentifikasi </li><li>  informasi layanan; </li><li>  banyak nilai default; </li><li>  bagian dengan status saat ini; </li><li>  perubahan yang dilakukan sebagai bagian dari webhook masuk; </li><li>  hasil kerja berbagai pengontrol (dan penjadwal). </li></ol><br>  Oleh karena itu, ketika konfigurasi baru sumber daya ( <i>baru</i> ) muncul, kita tidak bisa hanya mengambil dan menimpa dengan itu konfigurasi "hidup" saat ini ( <i>hidup</i> ).  Untuk melakukan ini, kita harus membandingkan yang <i>baru</i> dengan konfigurasi yang diterapkan <i>terakhir</i> (yang diterapkan <i>terakhir</i> ) dan roll tambalan yang dihasilkan ke <i>live</i> . <br><br>  Pendekatan ini disebut <b>penggabungan 2 arah</b> .  Ini digunakan, misalnya, di Helm. <br><br>  Ada juga <b>penggabungan 3 arah</b> , yang berbeda karena: <br><br><ul><li>  membandingkan yang <i>terakhir diterapkan</i> dan <i>baru</i> , kami melihat apa yang telah dihapus; </li><li>  membandingkan yang <i>baru</i> dan yang <i>hidup</i> , kita melihat apa yang telah ditambahkan atau diubah; </li><li>  terapkan tambalan yang diringkas untuk <i>hidup</i> . </li></ul><br>  Kami menyebarkan 1000+ aplikasi dengan Helm, jadi kami benar-benar hidup dengan penggabungan 2 arah.  Namun, ia memiliki sejumlah masalah yang kami selesaikan dengan tambalan kami yang membantu Helm bekerja secara normal. <br><br><h3>  Status peluncuran aktual </h3><br>  Setelah acara berikutnya, sistem CI kami menghasilkan konfigurasi baru untuk Kubernetes, mengirimkannya untuk <i>diterapkan</i> ke cluster menggunakan Helm atau <code>kubectl apply</code> .  Selanjutnya, penggabungan N-way yang sudah dijelaskan terjadi, yang disetujui API Kubernetes sistem CI, dan yang terakhir merespons pengguna. <br><br><img src="https://habrastorage.org/webt/sk/vh/-u/skvh-uifcwg6_d5mgxhehh39q9i.png"><br><br>  Namun, ada masalah besar: lagipula, <b>aplikasi yang sukses tidak berarti peluncuran yang sukses</b> .  Jika Kubernetes memahami perubahan apa yang akan diterapkan, terapkan - kami masih tidak tahu apa hasilnya.  Misalnya, memperbarui dan memulai ulang pod di frontend dapat berhasil, tetapi tidak di backend, dan kami akan mendapatkan versi berbeda dari gambar aplikasi yang sedang berjalan. <br><br>  Untuk melakukan semuanya dengan benar, tautan tambahan muncul dalam skema ini - pelacak khusus yang akan menerima informasi status dari Kubernetes API dan mengirimkannya untuk analisis lebih lanjut tentang keadaan sebenarnya.  Kami membuat pustaka Open Source di Go - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><b>kubedog</b></a> <i>(lihat pengumumannya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> )</i> - yang memecahkan masalah ini dan dibangun menjadi werf. <br><br>  Perilaku pelacak ini di tingkat werf dikonfigurasikan menggunakan anotasi yang diletakkan di Deployment atau StatefulSets.  Anotasi utama, <code>fail-mode</code> , memahami arti berikut: <br><br><ul><li>  <code>IgnoreAndContinueDeployProcess</code> - abaikan masalah <code>IgnoreAndContinueDeployProcess</code> komponen ini dan lanjutkan penerapan; </li><li>  <code>FailWholeDeployProcessImmediately</code> - kesalahan dalam komponen ini menghentikan proses penyebaran; </li><li>  <code>HopeUntilEndOfDeployProcess</code> - kami berharap bahwa komponen ini akan bekerja pada akhir penyebaran. </li></ul><br>  Misalnya, kombinasi sumber daya dan nilai anotasi <code>fail-mode</code> : <br><br><img src="https://habrastorage.org/webt/ja/qf/ot/jaqfotxaxoxwznieu2lvnnyhih0.png"><br><br>  Saat menggunakan untuk pertama kalinya, basis data (MongoDB) mungkin belum siap - Penyebaran akan macet.  Tapi Anda bisa menunggu sampai saat itu dimulai, dan penyebaran masih akan berlalu. <br><br>  Ada dua penjelasan lagi untuk kubedog di werf: <br><br><ul><li>  <code>failures-allowed-per-replica</code> - jumlah tetes yang diizinkan per replika; </li><li>  <code>show-logs-until</code> till - menyesuaikan momen hingga saat werf menampilkan (dalam stdout) log dari semua pod yang sedang digulirkan.  Secara default, ini adalah <code>PodIsReady</code> (untuk mengabaikan pesan yang hampir tidak kita perlukan ketika lalu lintas mulai tiba di pod), namun, nilai <code>ControllerIsReady</code> dan <code>EndOfDeploy</code> juga <code>EndOfDeploy</code> . </li></ul><br><h3>  Apa lagi yang kita inginkan dari penyebaran? </h3><br>  Selain dua poin yang sudah dijelaskan, kami ingin: <br><br><ul><li>  untuk melihat <b>log</b> - dan hanya diperlukan, tetapi tidak semuanya; </li><li>  melacak <b>kemajuan</b> , karena jika pekerjaan "diam-diam" hang selama beberapa menit, penting untuk memahami apa yang terjadi di sana; </li><li>  memiliki <b>kemunduran otomatis</b> jika terjadi kesalahan (dan oleh karena itu sangat penting untuk mengetahui status penyebaran yang sebenarnya).  Peluncuran harus berupa atom: baik itu menuju akhir, atau semuanya kembali ke keadaan sebelumnya. </li></ul><br><h2>  Ringkasan </h2><br>  Sebagai perusahaan, bagi kami, untuk mengimplementasikan semua nuansa yang dijelaskan pada berbagai tahap pengiriman (build, publish, deploy), sistem CI dan utilitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">werf</a> sudah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cukup</a> . <br><br>  Alih-alih kesimpulan: <br><br><img src="https://habrastorage.org/webt/ja/1y/tc/ja1ytcqobpkbw5rtf78ykb4clnm.png"><br><br>  Dengan bantuan werf, kami telah membuat kemajuan yang baik dalam memecahkan sejumlah besar masalah insinyur DevOps dan akan senang jika masyarakat luas setidaknya mencoba utilitas ini dalam praktiknya.  Mencapai hasil yang baik bersama akan lebih mudah. <br><br><h2>  Video dan slide </h2><br>  Video dari kinerja (~ 47 menit): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/cK3ackGUTLw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Penyajian laporan: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  PS </h2><br>  Laporan Kubernet lainnya di blog kami: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penskalaan otomatis dan manajemen sumber daya di Kubernetes</a> " <i>(Dmitry Stolyarov; 27 April 2019 di "Strike")</i> ; </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memperluas dan melengkapi Kubernetes</a> ” <i>(Andrey Polov; 8 April 2019 di Saint HighLoad ++)</i> ; </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Databases and Kubernetes</a> ” <i>(Dmitry Stolyarov; 8 November 2018 tentang HighLoad ++)</i> ; </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Monitoring and Kubernetes</a> ” <i>(Dmitry Stolyarov; 28 Mei 2018 di RootConf)</i> ; </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Praktek CI / CD terbaik dengan Kubernetes dan GitLab</a> ” <i>(Dmitry Stolyarov; 7 November 2017 di HighLoad ++)</i> ; </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengalaman kami dengan Kubernetes dalam proyek-proyek kecil</a> ” <i>(Dmitry Stolyarov; 6 Juni 2017 di RootConf)</i> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460351/">https://habr.com/ru/post/id460351/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460341/index.html">Melanjutkan ASO: tren, peringkat, dan sedikit umpan balik</a></li>
<li><a href="../id460343/index.html">Kisah bagaimana pengembangan game telah menjadi bagian dari hidup saya</a></li>
<li><a href="../id460345/index.html">Instal dan konfigurasikan Sonata Admin di Symfony 4</a></li>
<li><a href="../id460347/index.html">Manajemen perangkat seluler dan banyak lagi dengan solusi UEM Sophos</a></li>
<li><a href="../id460349/index.html">Periksa Kartu Akselerasi Point Falcon - Mempercepat Pemrosesan Lalu Lintas</a></li>
<li><a href="../id460353/index.html">Jaringan saraf di gelas. Tidak membutuhkan daya, mengenali angka</a></li>
<li><a href="../id460355/index.html">Menyelamatkan tenggelam adalah urusan kami: bagaimana menghadapi penurunan motivasi tim</a></li>
<li><a href="../id460359/index.html">Kursus 2 Desainer Game Muda: Menyeimbangkan Perkembangan dan Dinamika tanpa Matematika</a></li>
<li><a href="../id460361/index.html">FAQ Hebat tentang keamanan siber sistem informasi medis</a></li>
<li><a href="../id460363/index.html">7 faktor yang hilang dalam pendekatan 12 Factor App</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>