<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏭 👩🏾‍⚖️ 🔩 Server Commento Asli dengan Docker Compose 🤶🏻 🖖🏻 👲🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Catatan: ini adalah terjemahan dari postingan saya (Bahasa Inggris), yang menggambarkan implementasi dari server komentar yang digunakan di situs yang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Server Commento Asli dengan Docker Compose</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464105/"><p>  <em>Catatan: ini adalah terjemahan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">postingan saya</a> (Bahasa Inggris), yang menggambarkan implementasi dari server komentar yang digunakan di situs yang sama di mana dokumen asli berada.</em> </p><br><blockquote>  TL; Versi DR: Saya mengembangkan konfigurasi server Commento, yang mudah dan sederhana digunakan dalam mode semi-otomatis.  Salin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori ini</a> kepada Anda sendiri dari GitHub dan ikuti instruksi di <a href="">README</a> . </blockquote><p>  Beberapa waktu lalu, saya ingin sekali mengubah Disqus - yang mungkin merupakan sistem paling umum untuk menambahkan komentar ke halaman - menjadi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Commento yang</a> gratis dan terbuka. </p><br><h2 id="pochemu-imenno-commento">  Mengapa berkomentar </h2><br><p> Masalah dengan Disqus, seperti banyak produk "gratis" lainnya, adalah bahwa produk dalam hal ini adalah pengguna - yaitu, Anda.  Selain itu, Disqus “memperkaya” setiap halaman yang digunakannya dengan megabita skrip dan lebih dari <em>seratus</em> permintaan HTTP tambahan. </p><br><p>  Plus, versi gratisnya menampilkan iklan dari mana Anda dapat membayar "hanya" sebesar $ 9 per bulan (paket Plus).  Ini saja sudah cukup untuk ingin menemukan sesuatu yang lebih baik. </p><br><p>  Pada titik tertentu, saya menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting ini</a> dan mengetahui tentang keberadaan server komentar gratis bernama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Commento</a> .  Secara kebetulan, Commento baru-baru ini menjadi sangat terbuka - sebelum tersedia dalam dua versi, <em>Komunitas</em> gratis dan <em>Perusahaan</em> komersial.  Terima kasih kepada pengembangnya Adhityaa Chandrasekar. </p><a name="habracut"></a><br><p>  Commento adalah <em>pesanan yang besarnya</em> lebih efisien daripada Disqus, ukuran khas dari beban tambahan dengannya sekitar <strong>11 KB</strong> , ditambah komentar itu sendiri, tentu saja.  Kira-kira situasi yang sama dengan permintaan HTTP yang diperlukan. </p><br><p>  Kelebihan lain dari server Commento adalah sangat cepat, seperti yang tertulis di Go. </p><br><p>  Nah, sebagai ceri pada kue, ia memiliki impor komentar dari Disqus, apa lagi yang bisa ia impikan? </p><br><h2 id="varianty-ispolzovaniya-commento">  Gunakan case untuk Commento </h2><br><p>  Untuk pengguna yang tidak mahir (secara teknis), Commento memiliki layanan cloud yang siap digunakan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">commento.io</a> .  Penulis menawarkan Anda untuk memilih sendiri biaya bulanan, tetapi tidak kurang dari $ 3 "untuk alasan teknis." </p><br><p>  Bpk. Chandrasekar juga dengan murah hati menawarkan akun gratis di Commento.io dengan imbalan “patch non-sepele” untuk produk tersebut. </p><br><p>  Yah, saya memilih opsi ketiga: untuk meningkatkan server Commento sendiri.  Dalam hal ini, Anda tidak bergantung pada siapa pun (selain sang hoster, tentu saja), dan saya suka kemerdekaan. </p><br><h2 id="trudnosti">  Kesulitan </h2><br><p>  Saya penggemar berat wadah Docker dan juga sering menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Docker Compose</a> , alat untuk mengelola grup dari beberapa kontainer terkait.  Commento memiliki gambar Docker yang siap digunakan di registri kontainer GitLab. </p><br><p>  Oleh karena itu, keputusan untuk menggunakan wadah matang dengan sendirinya - tetapi beberapa hal pertama harus diputuskan. </p><br><h3 id="trudnost-1-postgresql">  Kesulitan No. 1: PostgreSQL </h3><br><p>  Commento memerlukan versi terbaru dari server PostgreSQL, sayangnya tidak ada server SQL lain yang didukung. </p><br><p>  Yah, kami masih menjalankan semuanya dalam wadah, jadi ini cukup sederhana. </p><br><h3 id="trudnost-2-net-podderzhki-https">  Kesulitan # 2: Tidak Ada Dukungan HTTPS </h3><br><p>  Commento sendiri adalah server web, tetapi hanya mendukung protokol HTTP yang tidak aman. </p><br><p>  Perlu dicatat bahwa praktik ini cukup umum hari ini: dalam hal ini, server tersembunyi di belakang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proksi terbalik</a> , yang juga melakukan pembongkaran SSL.  Masalahnya adalah bahwa dukungan SSL / HTTPS mutlak diperlukan dalam kasus ini, setelah semua, di halaman 2019 dan melihat upaya untuk mengotorisasi pengguna menggunakan protokol Internet tanpa jaminan akan sangat masam. </p><br><p>  Saya memutuskan untuk menggunakan server <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nginx</a> , pertama, saya punya banyak pengalaman bekerja dengannya, dan kedua, sangat cepat, ekonomis dan stabil.  Dan menerbitkan versi resmi dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gambar Docker</a> . </p><br><p>  Bahan kedua dalam resep HTTPS adalah sertifikat SSL untuk domain tersebut.  Saya senantiasa berterima kasih kepada EFF dan Mozilla karena telah menciptakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Let's Encrypt</a> Certificate <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Authority</a> , yang menerbitkan jutaan sertifikat gratis setiap bulan. </p><br><p>  Let's Encrypt juga menyediakan utilitas baris perintah gratis yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">certbot</a> , yang sangat menyederhanakan proses memperoleh dan memperbarui sertifikat.  Nah, dan - tentu saja - gambar Docker untuknya! </p><br><h3 id="trudnost-3-problema-kuricy-yayca-certbot">  Kesulitan # 3: Masalah Telur Ayam Certbot </h3><br><p>  Tapi trik ini lebih rumit. </p><br><p>  Kami ingin merujuk ke sertifikat SSL dalam konfigurasi proksi terbalik kami di Nginx, yang berarti bahwa tanpa sertifikat itu hanya menolak untuk memulai.  Pada saat yang sama, untuk <em>mendapatkan</em> sertifikat SSL untuk suatu domain, Anda memerlukan server HTTP yang berfungsi, yang Let's Encrypt akan membuktikan kepemilikan Anda atas domain ini. </p><br><p>  Saya berhasil memecahkan masalah ini, dan, menurut saya, cukup elegan: </p><br><ol><li>  Pertama, dummy, sertifikat tidak valid dibuat, yang tujuan utamanya adalah untuk membiarkan Nginx memulai. </li><li>  Nginx dan certbot bersama-sama menerima sertifikat baru yang sekarang valid. </li><li>  Segera setelah sertifikat diterima, certbot masuk ke "mode siaga", bangun setiap 12 jam untuk memeriksa apakah perlu diperbarui - sesuai dengan rekomendasi dari Let's Encrypt. </li><li>  Ketika saatnya tiba dan sertifikat telah diperbarui, certbot akan memberi sinyal Nginx untuk memulai kembali. </li></ol><br><h3 id="trudnost-4-chto-to-dolzhno-sohranyatsya">  Kesulitan No. 4: sesuatu harus dilestarikan </h3><br><p>  Saya sangat curiga bahwa Anda ingin komentar pengguna disimpan setelah reboot atau pembaruan sistem. </p><br><p>  Juga, agar Let's Encrypt tidak mencekal Anda karena terlalu sering meminta, alangkah baiknya untuk menyimpan sertifikat yang diterima untuk seluruh tanggal kedaluwarsa. </p><br><p> Kedua poin diselesaikan dalam konfigurasi yang diusulkan menggunakan volume Docker, secara otomatis dibuat oleh <em>systemd</em> ketika Commento pertama kali diluncurkan.  Volume ditandai sebagai "eksternal," sehingga Docker melompati mereka ketika menghapus wadah menggunakan <code>docker-compose down -v</code> . </p><br><h2 id="svodim-vsyo-voedino">  Satukan semuanya </h2><br><p>  Sekarang Anda bisa melihat bagaimana semuanya bekerja bersama. </p><br><p>  Gambar di bawah ini menunjukkan interaksi dan lalu lintas antara empat kontainer: </p><br><p><img src="https://habrastorage.org/webt/zl/kr/y3/zlkry3l9lxx8mfwzzlsnuvubi6a.png"></p><br><p>  Saya menerapkan opsi Docker Compose <code>depends_on</code> untuk memastikan bahwa wadah mulai dalam urutan yang benar. </p><br><p>  Jika Anda hanya ingin memulai server Commento Anda sendiri, Anda dapat melewati sisa artikel dan langsung menuju ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode di GitHub</a> . </p><br><p>  Baiklah, saya akan berbicara lebih banyak tentang implementasi ini secara lebih rinci nanti. </p><br><h2 id="kak-eto-vsyo-rabotaet">  Bagaimana cara kerjanya? </h2><br><h3 id="fayl-compose">  Tulis File </h3><br><p>  Seperti yang Anda lihat pada gambar di atas, "komposisi" saya terdiri dari empat layanan: </p><br><ol><li>  <code>certbot</code> - utilitas <code>certbot</code> dari EFF </li><li>  <code>nginx</code> - membalikkan proxy yang menerapkan SSL offloading </li><li>  <code>app</code> - server Commento </li><li>  <code>postgres</code> - Database PostgreSQL </li></ol><br><p>  File <a href=""><code>docker-compose.yml</code></a> berisi deklarasi jaringan Docker-nya sendiri, yang disebut <code>commento_network</code> , dan tiga volume, yang dua di antaranya eksternal (yaitu, harus dibuat di luar Compose): </p><br><ul><li>  <code>commento_postgres_volume</code> menyimpan data server PostgreSQL untuk Commento: pengguna, moderator, komentar, dll. </li><li>  <code>certbot_etc_volume</code> berisi sertifikat yang diterima oleh <code>certbot</code> . </li></ul><br><h3 id="nginx">  Nginx </h3><br><p>  Wadah Nginx dibuat berdasarkan gambar resmi ringan berdasarkan Alpine dan menggunakan skrip berikut untuk menjalankan: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh trap exit TERM # Wait for the certificate file to arrive wait_for_certs() { echo 'Waiting for config files from certbot...' i=0 while [[ ! -f /etc/letsencrypt/options-ssl-nginx.conf ]]; do sleep 0.5 [[ $((i++)) -gt 20 ]] &amp;&amp; echo 'No files after 10 seconds, aborting' &amp;&amp; exit 2 done } # Watches for a "reload flag" (planted by certbot container) file and reloads nginx config once it's there watch_restart_flag() { while :; do [[ -f /var/www/certbot/.nginx-reload ]] &amp;&amp; rm -f /var/www/certbot/.nginx-reload &amp;&amp; echo 'Reloading nginx' &amp;&amp; nginx -s reload sleep 10 done } # Wait for certbot wait_for_certs # Start "reload flag" watcher watch_restart_flag &amp; # Run nginx in the foreground echo 'Starting nginx' exec nginx -g 'daemon off;'</span></span></code> </pre> <br><ul><li>  Baris <strong>3</strong> ( <em>ARRGHHH, Habr tidak mendukung tampilan nomor baris dalam kode - kira-kira diterjemahkan.</em> ) Penangan interupsi terdaftar sehingga Nginx dan proses pemantauan latar belakang berhasil menyelesaikan pekerjaan ketika wadah berhenti. </li><li>  Line <strong>27</strong> memanggil fungsi wait, yang menghentikan proses startup Nginx sampai file konfigurasi SSL yang dibuat oleh wadah <code>certbot</code> .  Tanpa ini, Nginx akan menolak untuk memulai. </li><li>  Baris <strong>30</strong> menciptakan proses latar belakang yang secara teratur, setiap sepuluh detik, memeriksa keberadaan file flag dengan nama <code>.nginx-reload</code> , dan segera setelah terdeteksi, memerintahkan Nginx untuk memuat ulang konfigurasi.  File ini juga membuat certbot ketika sertifikat diperbarui. </li><li>  Baris <strong>34</strong> memulai Nginx dalam mode normal.  Dalam hal ini, <code>exec</code> berarti bahwa proses shell saat ini <em>digantikan oleh</em> proses Nginx. </li></ul><br><p>  File penting lainnya dalam gambar ini adalah konfigurasi server virtual Commento, yang memaksa Nginx untuk meneruskan permintaan HTTPS ke wadah <code>commento</code> : </p><br><pre> <code class="nginx hljs"><span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> [::]:<span class="hljs-number"><span class="hljs-number">443</span></span> ssl ipv6only=<span class="hljs-literal"><span class="hljs-literal">on</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">443</span></span> ssl; <span class="hljs-attribute"><span class="hljs-attribute">server_tokens</span></span> <span class="hljs-literal"><span class="hljs-literal">off</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">root</span></span> /var/www/html; <span class="hljs-attribute"><span class="hljs-attribute">index</span></span> index.html index.htm index.nginx-debian.html; <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> __DOMAIN__; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://app:8080/; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$http_host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Real-IP <span class="hljs-variable"><span class="hljs-variable">$remote_addr</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Forwarded-For <span class="hljs-variable"><span class="hljs-variable">$proxy_add_x_forwarded_for</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">ssl_certificate</span></span> /etc/letsencrypt/live/__DOMAIN__/fullchain.pem; <span class="hljs-attribute"><span class="hljs-attribute">ssl_certificate_key</span></span> /etc/letsencrypt/live/__DOMAIN__/privkey.pem; <span class="hljs-attribute"><span class="hljs-attribute">include</span></span> /etc/letsencrypt/options-ssl-nginx.conf; <span class="hljs-attribute"><span class="hljs-attribute">ssl_dhparam</span></span> /etc/letsencrypt/ssl-dhparams.pem; } <span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span> default_server; <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> [::]:<span class="hljs-number"><span class="hljs-number">80</span></span> default_server; <span class="hljs-attribute"><span class="hljs-attribute">server_tokens</span></span> <span class="hljs-literal"><span class="hljs-literal">off</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> __DOMAIN__; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /.well-known/acme-challenge/ { <span class="hljs-attribute"><span class="hljs-attribute">root</span></span> /var/www/certbot; } <span class="hljs-comment"><span class="hljs-comment"># Redirect to HTTPS on port 80 location / { return 301 https://$host$request_uri; } }</span></span></code> </pre> <br><p>  Blok server pertama (baris <strong>1-21</strong> ) menjelaskan cara bekerja dengan HTTPS dan aturan penerusan.  Di sinilah file sertifikat Mari Enkripsi disebutkan (atau bertopik digunakan sebagai gantinya). </p><br><p>  Domain yang dilayani oleh server dilewatkan sebagai argumen saat membangun gambar;  ia menggantikan baris <code>__DOMAIN__</code> pada konfigurasi server. </p><br><p>  Blok kedua (baris <strong>23-38</strong> ) adalah konfigurasi server HTTP, yang digunakan oleh certbot untuk mengkonfirmasi kepemilikan domain (yang disebut "tantangan ACME").  Semua permintaan lain menyebabkan pengalihan ke alamat yang sesuai melalui HTTPS. </p><br><h3 id="certbot">  certbot </h3><br><p>  Gambar certbot kami didasarkan pada bangunan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">resmi</a> dengan skrip berikut: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh trap exit TERM # Wait until nginx is up and running, up to 10 seconds wait_for_nginx() { echo 'Waiting for nginx...' i=0 while ! nc -z nginx 80 &amp;&gt;/dev/null; do sleep 0.5 [[ $((i++)) -gt 20 ]] &amp;&amp; echo "nginx isn't online after 10 seconds, aborting" &amp;&amp; exit 4 done echo 'nginx is up and running' } # Check vars [[ -z "$DOMAIN" ]] &amp;&amp; echo "Environment variable 'DOMAIN' isn't defined" &amp;&amp; exit 2 [[ -z "$EMAIL" ]] &amp;&amp; echo "Environment variable 'EMAIL' isn't defined" &amp;&amp; exit 2 TEST="${TEST:-false}" # Check external mounts data_dir='/etc/letsencrypt' www_dir='/var/www/certbot' [[ ! -d "$data_dir" ]] &amp;&amp; echo "Directory $data_dir must be externally mounted" [[ ! -d "$www_dir" ]] &amp;&amp; echo "Directory $www_dir must be externally mounted" # If the config/certificates haven't been initialised yet if [[ ! -e "$data_dir/options-ssl-nginx.conf" ]]; then # Copy config over from the initial location echo 'Initialising nginx config' cp /conf/options-ssl-nginx.conf /conf/ssl-dhparams.pem "$data_dir/" # Copy dummy certificates mkdir -p "$data_dir/live/$DOMAIN" cp /conf/privkey.pem /conf/fullchain.pem "$data_dir/live/$DOMAIN/" # Wait for nginx wait_for_nginx # Remove dummy certificates rm -rf "$data_dir/live/$DOMAIN/" # Run certbot to validate/renew certificate test_arg= $TEST &amp;&amp; test_arg='--test-cert' certbot certonly --webroot -w /var/www/certbot -n -d "$DOMAIN" $test_arg -m "$EMAIL" --rsa-key-size 4096 --agree-tos --force-renewal # Reload nginx config touch /var/www/certbot/.nginx-reload # nginx config has been already initialised - just give nginx time to come up else wait_for_nginx fi # Run certbot in a loop for renewals while :; do certbot renew # Reload nginx config touch /var/www/certbot/.nginx-reload sleep 12h done</span></span></code> </pre> <br><p>  Tur singkat tentang garis-garisnya: </p><br><ul><li>  Baris <strong>3</strong> , seperti pada skrip sebelumnya, diperlukan untuk melengkapi wadah secara teratur. </li><li>  Baris <strong>17-19</strong> memeriksa variabel yang diperlukan. </li><li>  Dan di baris <strong>22-25</strong> - bahwa direktori yang diperlukan untuk certbot berfungsi sudah terpasang dengan benar. </li><li>  Garpu berikut: <br><ul><li>  Baris <strong>30-50</strong> dieksekusi hanya pada awal pertama wadah: <br><ul><li>  Sertifikat tiruan disalin, memungkinkan Nginx untuk memulai secara normal. </li><li>  Nginx, sementara itu, menunggu akhir dari proses ini, setelah itu terus mengunduh. </li><li>  Setelah Nginx dimulai, certbot memulai proses untuk mendapatkan sertifikat yang valid dari Let's Encrypt. </li><li>  Dan akhirnya, segera setelah sertifikat diterima, file <code>.nginx-reload</code> dibuat, mengisyaratkan kepada Nginx bahwa sudah waktunya untuk memuat ulang konfigurasi. </li></ul></li><li>  Baris <strong>54</strong> menunggu Nginx untuk memulai - dalam kasus ketika sertifikat lengkap sudah tersedia. </li></ul></li><li>  Setelah semua ini (baris <strong>58-63</strong> ), ia terus berputar, setiap 12 jam sekali memeriksa kebutuhan untuk memperbarui sertifikat dan memberi tanda Nginx untuk memulai kembali. </li></ul><br><h3 id="commento-i-postgresql">  Commento dan PostgreSQL </h3><br><p>  <code>app</code> dan wadah <code>postgres</code> menggunakan gambar asli yang disediakan oleh pengembang tanpa perubahan apa pun. </p><br><h3 id="servis-systemd">  Layanan Systemd </h3><br><p>  Bagian terakhir dari teka-teki ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">file unit systemd</a> <code>commento.service</code> , di mana Anda perlu membuat symlink di <code>/etc/systemd/system/commento.service</code> sehingga itu dimulai pada saat yang tepat ketika sistem dimulai: </p><br><pre> <code class="plaintext hljs">[Unit] Description=Commento server [Service] TimeoutStopSec=30 WorkingDirectory=/opt/commento ExecStartPre=-/usr/bin/docker volume create commento_postgres_volume ExecStartPre=-/usr/bin/docker volume create certbot_etc_volume ExecStartPre=-/usr/local/bin/docker-compose -p commento down -v ExecStart=/usr/local/bin/docker-compose -p commento up --abort-on-container-exit ExecStop=/usr/local/bin/docker-compose -p commento down -v [Install] WantedBy=multi-user.target</code> </pre> <br><p>  Baris: </p><br><ul><li>  Baris <strong>6</strong> menyiratkan bahwa kode proyek diklon ke direktori <code>/opt/commento</code> - ini jauh lebih sederhana. </li><li>  Baris <strong>7-8</strong> membuat volume eksternal, jika belum. </li><li>  Pada baris <strong>9</strong> , sisa-sisa yang mungkin dari wadah sebelumnya dihapus.  Volume eksternal dipertahankan. </li><li>  Baris <strong>10</strong> menandai peluncuran Docker Compose yang sebenarnya.  <code>--abort-on-container-exit</code> seluruh kawanan kontainer ketika salah satu dari mereka <code>--abort-on-container-exit</code> .  Berkat ini, systemd setidaknya akan menyadari bahwa layanan dihentikan. </li><li>  Saluran <strong>11</strong> lagi-lagi membersihkan dan menghapus wadah, jaringan, dan volume. </li></ul><br><h2 id="ishodnyy-kod">  Kode sumber </h2><br><p>  Implementasi yang berfungsi penuh, hanya membutuhkan konfigurasi variabel di <code>docker-compose.yml</code> , tersedia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di GitHub</a> .  Anda hanya perlu mengikuti langkah-langkah yang dijelaskan dalam <a href="">README</a> dengan hati-hati. </p><br><p>  Kode ini tunduk pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lisensi MIT</a> . </p><br><p>  Terima kasih sudah membaca ke tempat ini, komentarnya disambut dengan panik! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464105/">https://habr.com/ru/post/id464105/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464093/index.html">Barang digital: apa yang harus dilakukan jika pelanggan datang untuk melakukan pembelian dalam setahun?</a></li>
<li><a href="../id464095/index.html">Getters and Setters di Dart and Flutter</a></li>
<li><a href="../id464097/index.html">Evolusi kecerdasan: mengapa robot membutuhkan emosi</a></li>
<li><a href="../id464099/index.html">Analisis Bahasa VKScript: JavaScript, kan?</a></li>
<li><a href="../id464103/index.html">OpenUNB konsep standar IoT nasional: tinjauan kritis</a></li>
<li><a href="../id464107/index.html">Acara digital di Moskow dari 19 hingga 25 Agustus</a></li>
<li><a href="../id464109/index.html">Ruang Parasut Supersonik</a></li>
<li><a href="../id464111/index.html">Natas Web. Passage dari platform KKP bertujuan untuk mengeksploitasi kerentanan Web</a></li>
<li><a href="../id464113/index.html">"CAD untuk semua orang, gratis, dan jangan biarkan siapa pun pergi ..." atau langkah pertama dalam pemrograman FreeCAD dengan Python</a></li>
<li><a href="../id464115/index.html">Bagaimana menjalin pertemanan sebagai perancang, perancang tata letak, dan "Figma" menggunakan sistem desain, linggis, dan semacam mother ™</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>