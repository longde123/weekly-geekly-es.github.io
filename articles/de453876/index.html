<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçù üå©Ô∏è üåô Wie bei Yandex.Practicum gewann das Front-End-Desync: eine akrobatische Nummer mit Redux-Saga, postMessage und Jupyter üç∞ üë©üèº‚Äçüîß üîü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mein Name ist Artyom Nesmiyanov, ich bin ein Full-Stack-Entwickler bei Yandex.Practicum, ich besch√§ftige mich haupts√§chlich mit dem Frontend. Wir glau...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie bei Yandex.Practicum gewann das Front-End-Desync: eine akrobatische Nummer mit Redux-Saga, postMessage und Jupyter</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/453876/">  Mein Name ist Artyom Nesmiyanov, ich bin ein Full-Stack-Entwickler bei Yandex.Practicum, ich besch√§ftige mich haupts√§chlich mit dem Frontend.  Wir glauben, dass es m√∂glich und notwendig ist, Programmierung, Datenanalyse und anderes digitales Handwerk mit Vergn√ºgen zu studieren.  Und fang an zu lernen und mach weiter.  Jeder Entwickler, der sich selbst nicht aufgegeben hat, ‚Äûmacht weiter‚Äú.  Wir auch.  Daher nehmen wir Arbeitsaufgaben als Lernformat wahr.  Und einer der letzten hat mir und den Jungs geholfen, besser zu verstehen, in welche Richtung wir unseren Frontend-Stack entwickeln sollen. <br><br><img src="https://habrastorage.org/webt/u2/uh/nx/u2uhnxzsc0hv3v7clkqskbzwnc0.png"><br><br><h3>  Aus wem und woraus besteht der Workshop? </h3><br>  Unser Entwicklungsteam ist √§u√üerst kompakt.  Es gibt nur zwei Leute im Backend, im Frontend - vier, wenn man mich f√ºr einen vollen Stack h√§lt.  Von Zeit zu Zeit verst√§rken sich Jungs von Yandex.Tutorial bei uns.  Wir arbeiten mit zweiw√∂chigen Sprints an Scrum. <br><a name="habracut"></a><br>  Unser Frontend basiert auf React.js in Verbindung mit Redux / Redux-Saga. Wir verwenden Express, um mit dem Backend zu kommunizieren.  Der Backend-Teil des Stacks befindet sich in Python (genauer gesagt Django), die Datenbank ist PostgreSQL und f√ºr einige Aufgaben Redis.  Mit Redux speichern wir Informationsspeicher und senden Aktionen, die von Redux und Redux-Saga verarbeitet werden.  Alle Nebenwirkungen wie Serveranforderungen, Aufrufe von Yandex.Metrica und Weiterleitungen werden nur in Redux-Saga verarbeitet.  Alle Daten√§nderungen erfolgen in Redux-Reduzierern. <br><br><h3>  So √ºbersehen Sie ein Protokoll in Ihrem Iframe nicht </h3><br>  Auf unserer Plattform sind Schulungen in drei Berufen m√∂glich: Front-End-Entwickler, Webentwickler und Datenanalyst.  Und wir s√§gen aktiv Werkzeuge f√ºr jeden Kurs. <br><br>  F√ºr den sechsmonatigen Kurs " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Data Analyst</a> " haben wir einen interaktiven Simulator erstellt, in dem wir Benutzern den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Umgang</a> mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem Jupyter-Notizbuch</a> beibringen.  Dies ist eine coole H√ºlle f√ºr interaktives Computing, die von Datenwissenschaftlern zu Recht geliebt wird.  Alle Vorg√§nge in der Umgebung werden im Notebook ausgef√ºhrt, jedoch auf einfache Weise - in einem Notebook (wie ich es sp√§ter nennen werde). <br><br>  Erleben Sie Eingabeaufforderungen, und wir sind sicher: Es ist wichtig, dass die Schulungsaufgaben nahezu real sind.  Einschlie√ülich in Bezug auf das Arbeitsumfeld.  Daher musste sichergestellt werden, dass innerhalb der Lektion der gesamte Code direkt im Notizbuch geschrieben, ausgef√ºhrt und √ºberpr√ºft werden konnte. <br><br>  Bei der grundlegenden Umsetzung der Schwierigkeiten traten keine auf.  Das Notizbuch selbst wurde in einem separaten Iframe abgelegt, die Logik zur √úberpr√ºfung wurde im Backend vorgeschrieben. <br><br><img src="https://habrastorage.org/webt/2z/_9/iy/2z_9iyuj7pmha0ielvj4evuyhic.png"><br>  <i>Das Sch√ºler-Notizbuch selbst (rechts) ist nur ein Iframe, dessen URL zu einem bestimmten Notizbuch in JupyterHub f√ºhrt.</i> <br><br>  In erster N√§herung funktionierte alles reibungslos und reibungslos.  W√§hrend des Testens kamen jedoch Absurdit√§ten heraus.  Beispielsweise wird garantiert, dass Sie die richtige Version des Codes in ein Notizbuch eingeben. Nachdem Sie jedoch auf die Schaltfl√§che "Testaufgabe" geklickt haben, antwortet der Server, dass die Antwort angeblich falsch ist.  Und warum - ein R√§tsel. <br><br>  Nun, was passiert, haben wir am selben Tag festgestellt, als wir einen Fehler gefunden haben: Es stellte sich heraus, dass die L√∂sung, die nicht flog, die aktuelle war. Die L√∂sung wurde nur in das Jupyter-Notizbuch-Formular geschrieben, aber die vorherige wurde bereits gel√∂scht.  Das Notebook selbst hatte keine Zeit zum √úberleben, und wir haben das Backend verlangsamt, damit es die darin enthaltene Aufgabe √ºberpr√ºft.  Was er nat√ºrlich nicht konnte. <br><br>  Wir mussten den Rassinhron zwischen dem Speichern des Notebooks und dem Senden einer Anfrage an den Server zur √úberpr√ºfung loswerden.  Der Haken war, dass es notwendig war, den Iframe des Notizbuchs mit dem √ºbergeordneten Fenster zu kommunizieren, dh mit dem Frontend, auf dem sich die gesamte Lektion drehte.  Nat√ºrlich war es unm√∂glich, ein Ereignis direkt zwischen ihnen weiterzuleiten: Sie leben auf verschiedenen Dom√§nen. <br><br>  Auf der Suche nach einer L√∂sung fand ich heraus, dass Jupyter Notebook die Verbindung seiner Plugins erm√∂glicht.  Es gibt ein Jupiter-Objekt - ein Notizbuch - mit dem Sie arbeiten k√∂nnen.  Die Arbeit damit beinhaltet Ereignisse, einschlie√ülich der Aufbewahrung des Notizbuchs sowie den Aufruf der entsprechenden Aktion.  Nachdem wir das Innere von Jupyter herausgefunden hatten (ich musste: es gibt keine normale Dokumentation daf√ºr), haben die Jungs und ich es getan - wir haben unser eigenes Plug-In daf√ºr erstellt und mithilfe des postMessage-Mechanismus eine koordinierte Arbeit der Elemente erreicht, aus denen die Workshop-Lektion zusammengestellt wurde. <br><br>  Wir haben eine Problemumgehung ausgearbeitet, die die Tatsache ber√ºcksichtigt, dass unser Stack zun√§chst die bereits erw√§hnte Redux-Saga enth√§lt - um es einfach auszudr√ºcken: Middleware √ºber Redux, die es erm√∂glicht, flexibler mit Nebenwirkungen zu arbeiten.  Das Speichern eines Notebooks ist beispielsweise nur ein Nebeneffekt.  Wir schicken etwas an das Backend, warten auf etwas, holen etwas.  All diese Bewegungen werden in Redux-Saga verarbeitet: Sie werfen Ereignisse in das Frontend und diktieren ihm, wie was in der Benutzeroberfl√§che angezeigt werden soll. <br><br>  Was ist das Ergebnis?  PostMessage wird erstellt und mit einem Notizbuch an den Iframe gesendet.  Wenn ein Iframe sieht, dass etwas von au√üen gekommen ist, analysiert er die empfangene Zeichenfolge.  Als er erkennt, dass er das Notizbuch behalten muss, f√ºhrt er diese Aktion aus und sendet seinerseits eine Antwort postMessage √ºber die Ausf√ºhrung der Anforderung. <br><br>  Wenn wir auf die Schaltfl√§che "Testaufgabe" klicken, wird das entsprechende Ereignis an den Redux Store gesendet: "So und so, wir wurden √ºberpr√ºft."  Redux-Saga sieht die Aktion eintreffen und postMessage in einem Iframe ausf√ºhren.  Jetzt wartet sie darauf, dass der Iframe eine Antwort gibt.  In der Zwischenzeit sieht unser Sch√ºler die Download-Anzeige auf der Schaltfl√§che "Aufgabe √ºberpr√ºfen" und versteht, dass der Simulator nicht h√§ngt, sondern "denkt".  Und erst wenn postMessage zur√ºckkommt und mitteilt, dass das Speichern abgeschlossen ist, arbeitet Redux-Saga weiter und sendet eine Anfrage an das Backend.  Die Aufgabe wird auf dem Server √ºberpr√ºft - die richtige L√∂sung oder nicht, wenn Fehler gemacht werden, welche usw., und diese Informationen werden ordentlich im Redux Store gespeichert.  Und von dort zieht das Front-End-Skript es in die Unterrichtsoberfl√§che. <br><br>  Hier ist das Diagramm, das am Ende herauskam: <br><br><img src="https://habrastorage.org/webt/ks/gc/eu/ksgceup6hokoh9jtvqoajegbjfc.png"><br><br>  <i>(1) Wir dr√ºcken die Taste "Aufgabe pr√ºfen" (Pr√ºfung) ‚Üí (2) Wir senden die Aktion CHECK_NOTEBOOK_REQUEST ‚Üí (3) Wir senden die Aktion der Pr√ºfung ‚Üí (2) Wir senden die Aktion SAVE_NOTEBOOK_REQUEST ‚Üí (3) Wir fangen die Aktion ab und senden postMessage im Ereignis iframe ‚Üí save (4) Nachricht empfangen ‚Üí (5) Notizbuch wird gespeichert ‚Üí (4) Empf√§ngt das Ereignis von der Jupyter-API, dass das Notizbuch gespeichert wurde, und sendet postMessage-Notizbuch gespeichert ‚Üí (1) Empfangen des Ereignisses ‚Üí (2) Senden der Aktion SAVE_NOTEBOOK_SUCCESS ‚Üí (3) Wir fangen die Aktion ab und senden Sie eine Anfrage zum √úberpr√ºfen des Notizbuchs ‚Üí (6) ‚Üí (7) √úberpr√ºfen Sie, ob sich dieses Notizbuch in der Datenbank befindet ‚Üí (8) ‚Üí (7) Suchen Sie den Notizbuchcode ‚Üí (5) Geben Sie den Code zur√ºck ‚Üí (7) F√ºhren Sie die Codepr√ºfung aus ‚Üí (9) ) ‚Üí (7) Wir bekommen einen Schnitt</i>  <i>tat pr√ºfen ‚Üí (6) ‚Üí (3) wir Aktion CHECK_NOTEBOOK_SUCCESS ‚Üí senden (2) nach unten Antwort √ºberpr√ºfen ‚Üí sided (1) Zeichnen Ergebnis</i> <br><br>  Mal sehen, wie das alles im Kontext des Codes funktioniert. <br><br>  Wir haben am Frontend manager_type_jupyter.jsx - das Skript der Seite, auf der unser Notizbuch gezeichnet ist. <br><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"trainer__right-column"</span></span></span><span class="hljs-tag">&gt;</span></span> {notebookLinkIsLoading ? ( <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">iframe</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"trainer__jupiter-frame"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ref</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{this.onIframeRef}</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{notebookLink}</span></span></span><span class="hljs-tag"> /&gt;</span></span> ) : ( <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Spin</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">size</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"l"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">mix</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"trainer__jupiter-spin"</span></span></span><span class="hljs-tag"> /&gt;</span></span> )} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Nach dem Klicken auf die Schaltfl√§che "Job pr√ºfen" wird die handleCheckTasks-Methode aufgerufen. <br><br><pre> <code class="xml hljs">handleCheckTasks = () =&gt; { const {checkNotebook, lesson} = this.props; checkNotebook({id: lesson.id, iframe: this.iframeRef}); };</code> </pre> <br>  Tats√§chlich dient handleCheckTasks dazu, die Redux-Aktion mit den √ºbergebenen Parametern aufzurufen. <br><br><pre> <code class="xml hljs">export const checkNotebook = getAsyncActionsFactory(CHECK_NOTEBOOK).request;</code> </pre> <br>  Dies ist eine h√§ufige Aktion f√ºr Redux-Saga und asynchrone Methoden.  Hier generiert getAsyncActionsFactory drei Aktionen: <br><br>  // utils / store-helpers / async.js <br><br><pre> <code class="xml hljs">export function getAsyncActionsFactory(type) { const ASYNC_CONSTANTS = getAsyncConstants(type); return { request: payload =&gt; ({type: ASYNC_CONSTANTS.REQUEST, payload}), error: (response, request) =&gt; ({type: ASYNC_CONSTANTS.ERROR, response, request}), success: (response, request) =&gt; ({type: ASYNC_CONSTANTS.SUCCESS, response, request}), } }</code> </pre> <br>  Dementsprechend generiert getAsyncConstants drei Konstanten der Form * _REQUEST, * _SUCCESS und * _ERROR. <br><br>  Nun wollen wir sehen, wie unsere Redux-Saga mit all dieser Wirtschaft umgehen wird: <br><br>  // Trainer.saga.js <br><br><pre> <code class="xml hljs">function* watchCheckNotebook() { const watcher = createAsyncActionSagaWatcher({ type: CHECK_NOTEBOOK, apiMethod: Api.checkNotebook, preprocessRequestGenerator: function* ({id, iframe}) { yield put(trainerActions.saveNotebook({iframe})); yield take(getAsyncConstants(SAVE_NOTEBOOK).SUCCESS); return {id}; }, successHandlerGenerator: function* ({response}) { const {completed_tests: completedTests} = response; for (let id of completedTests) { yield put(trainerActions.setTaskSolved(id)); } }, errorHandlerGenerator: function* ({response: error}) { yield put(appActions.setNetworkError(error)); } }); yield watcher(); }</code> </pre> <br>  Die Magie?  Nichts au√üergew√∂hnliches.  Wie Sie sehen k√∂nnen, erstellt createAsyncActionSagaWatcher einfach ein Wasserzeichen, mit dem Daten, die in die Aktion eingehen, vorverarbeitet, eine Anforderung unter einer bestimmten URL gestellt, die Aktion * _REQUEST gesendet und * _SUCCESS und * _ERROR nach einer erfolgreichen Antwort vom Server gesendet werden k√∂nnen.  Zus√§tzlich sind f√ºr jede Option nat√ºrlich Handler in der Uhr vorgesehen. <br><br>  Sie haben wahrscheinlich bemerkt, dass wir im Datenpr√§prozessor eine andere Redux-Saga aufrufen, warten, bis sie mit SUCCESS endet, und erst dann weiterarbeiten.  Und nat√ºrlich m√ºssen iframes nicht an den Server gesendet werden, daher geben wir nur die ID an. <br><br>  Schauen Sie sich die Funktion saveNotebook genauer an: <br><br><pre> <code class="xml hljs">function* saveNotebook({payload: {iframe}}) { iframe.contentWindow.postMessage(JSON.stringify({ type: 'save-notebook' }), '*'); yield; }</code> </pre> <br>  Wir haben den wichtigsten Mechanismus in der Interaktion von iframes mit dem Frontend erreicht - postMessage.  Das angegebene Codefragment sendet eine Aktion mit dem Typ "Notizbuch speichern", die im Iframe verarbeitet wird. <br><br>  Ich habe bereits erw√§hnt, dass wir ein Plug-In f√ºr das Jupyter-Notebook schreiben m√ºssen, das in das Notebook geladen wird.  Diese Plugins sehen ungef√§hr so ‚Äã‚Äãaus: <br><br><pre> <code class="xml hljs">define([ 'base/js/namespace', 'base/js/events' ], function( Jupyter, events ) {...});</code> </pre><br>  Um solche Erweiterungen zu erstellen, m√ºssen Sie sich mit der Jupyter Notebook-API selbst befassen.  Leider gibt es keine eindeutige Dokumentation dazu.  Aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellcodes</a> sind verf√ºgbar, und ich habe mich damit befasst.  Es ist gut, dass der Code dort lesbar ist. <br><br>  Dem Plugin muss beigebracht werden, mit dem √ºbergeordneten Fenster im Frontend der Lektion zu kommunizieren: Schlie√ülich ist die Desynchronisierung zwischen ihnen die Ursache f√ºr den Fehler bei der Aufgaben√ºberpr√ºfung.  Zun√§chst abonnieren wir alle Nachrichten, die wir erhalten: <br><br><pre> <code class="xml hljs">window.addEventListener('message', actionListener);</code> </pre> <br>  Jetzt werden wir ihre Verarbeitung bereitstellen: <br><br><pre> <code class="xml hljs">function actionListener({data: eventString}) { let event = ''; try { event = JSON.parse(eventString); } catch(e) { return; } switch (event.type) { case 'save-notebook': Jupyter.actions.call('jupyter-notebook:save-notebook'); Break; ... default: break; } }</code> </pre> <br>  Alle Ereignisse, die nicht zu unserem Format passen, werden mutig ignoriert. <br><br>  Wir sehen, dass das Ereignis zum Speichern des Notizbuchs bei uns eintrifft, und rufen die Aktion zum Speichern des Notizbuchs auf.  Es bleibt nur eine Nachricht zur√ºckzusenden, dass das Notizbuch erhalten geblieben ist: <br><br><pre> <code class="xml hljs">events.on('notebook_saved.Notebook', actionDispatcher); function actionDispatcher(event) { switch (event.type) { case 'select': const selectedCell = Jupyter.notebook.get_selected_cell(); dispatchEvent({ type: event.type, data: {taskId: getCellTaskId(selectedCell)} }); return; case 'notebook_saved': default: dispatchEvent({type: event.type}); } } function dispatchEvent(event) { return window.parent.postMessage( typeof event === 'string' ? event : JSON.stringify(event), '*' ); }</code> </pre><br>  Mit anderen Worten, senden Sie einfach {type: 'notebook_saved'} nach oben.  Dies bedeutet, dass das Notizbuch erhalten geblieben ist. <br><br>  Kehren wir zu unserer Komponente zur√ºck: <br><br>  //trainer_type_jupyter.jsx <br><br><pre> <code class="xml hljs">componentDidMount() { const {getNotebookLink, lesson} = this.props; getNotebookLink({id: lesson.id}); window.addEventListener('message', this.handleWindowMessage); }</code> </pre> <br>  Beim Mounten der Komponente bitten wir den Server um einen Link zum Notebook und abonnieren alle Aktionen, die zu uns fliegen k√∂nnen: <br><br><pre> <code class="xml hljs">handleWindowMessage = ({data: eventString}) =&gt; { const {activeTaskId, history, match: {params}, setNotebookSaved, tasks} = this.props; let event = null; try { event = JSON.parse(eventString); } catch(e) { return; } const {type, data} = event; switch (type) { case 'app_initialized': this.selectTaskCell({taskId: activeTaskId}) return; case 'notebook_saved': setNotebookSaved(); return; case 'select': { const taskId = data &amp;&amp; data.taskId; if (!taskId) { return } const task = tasks.find(({id}) =&gt; taskId === id); if (task &amp;&amp; task.status === TASK_STATUSES.DISABLED) { this.selectTaskCell({taskId: null}) return; } history.push(reversePath(urls.trainerTask, {...params, taskId})); return; } default: break; } };</code> </pre> <br>  Hier wird der Aktionsversand setNotebookSaved aufgerufen, mit dem Redux-Saga weiterarbeiten und das Notizbuch speichern kann. <br><br><h3>  Pannen der Wahl </h3><br>  Wir haben den Fehler bei der Aufbewahrung von Notebooks behoben.  Und sofort auf ein neues Problem umgestellt.  Es musste gelernt werden, Aufgaben zu blockieren, zu denen der Sch√ºler noch nicht gelangt war.  Mit anderen Worten, es war notwendig, die Navigation zwischen unserem interaktiven Simulator und dem Jupyter-Notizbuch zu synchronisieren: In einer Lektion befanden sich ein Notizbuch mit mehreren Aufgaben im Iframe, deren √úberg√§nge mit den √Ñnderungen in der gesamten Benutzeroberfl√§che der Lektion koordiniert werden mussten.  Wenn Sie beispielsweise auf die zweite Aufgabe in der Lektionsoberfl√§che des Notizbuchs klicken, wird in die Zelle gewechselt, die der zweiten Aufgabe entspricht.  Und umgekehrt: Wenn Sie im Jupyter Notebook-Frame eine Zelle ausw√§hlen, die mit der dritten Aufgabe verkn√ºpft ist, sollte sich die URL in der Adressleiste des Browsers sofort √§ndern, und dementsprechend sollte der Begleittext mit der Theorie f√ºr die dritte Aufgabe in der Benutzeroberfl√§che der Lektion angezeigt werden. <br><br>  Es gab eine schwierigere Aufgabe.  Tatsache ist, dass unser Schulungsprogramm auf die konsequente Weitergabe von Lektionen und Aufgaben ausgelegt ist.  W√§hrenddessen hindert standardm√§√üig im Jupiter-Notizbuch nichts den Benutzer daran, eine Zelle zu √∂ffnen.  In unserem Fall ist jede Zelle eine separate Aufgabe.  Es stellte sich heraus, dass Sie die erste und dritte Aufgabe l√∂sen und die zweite √ºberspringen k√∂nnen.  Das Risiko eines nichtlinearen Durchgangs der Lektion musste beseitigt werden. <br><br>  Die L√∂sung basierte auf derselben postMessage.  Nur mussten wir uns weiter mit der Jupyter Notebook-API befassen, insbesondere mit den M√∂glichkeiten des Jupiter-Objekts.  Und entwickeln Sie einen Mechanismus, mit dem Sie √ºberpr√ºfen k√∂nnen, an welche Aufgabe die Zelle angeh√§ngt ist.  In seiner allgemeinsten Form ist es wie folgt.  In der Struktur des Notizbuchs gehen die Zellen nacheinander nacheinander.  Sie k√∂nnen Metadaten haben.  Das Feld "Tags" wird in den Metadaten bereitgestellt, und Tags sind nur Bezeichner von Aufgaben innerhalb der Lektion.  Dar√ºber hinaus k√∂nnen Sie mithilfe von Tagging-Zellen festlegen, ob sie vom Sch√ºler bisher blockiert werden sollen.  Infolgedessen senden wir gem√§√ü dem aktuellen Modell des Simulators durch Klicken auf die Zelle postMessage vom iframe an unser Frontend, das wiederum zum Redux Store geht und anhand der Eigenschaften der Aufgabe pr√ºft, ob es uns jetzt zur Verf√ºgung steht.  Wenn nicht verf√ºgbar, wechseln wir zur vorherigen aktiven Zelle. <br><br>  Wir haben also festgestellt, dass es unm√∂glich ist, eine Zelle in einem Notizbuch auszuw√§hlen, auf die √ºber die Trainingszeitleiste nicht zugegriffen werden kann.  Dies f√ºhrte zwar zu einem unkritischen, aber fehlerhaften Fehler: Sie versuchen, auf eine Zelle mit einer unzug√§nglichen Aufgabe zu klicken, und sie ‚Äûblinkt‚Äú schnell: Es ist klar, dass sie f√ºr einen Moment aktiviert, aber sofort blockiert wurde.  Obwohl wir diese Rauheit nicht beseitigt haben, st√∂rt sie den Unterricht nicht, aber im Hintergrund √ºberlegen wir weiterhin, wie wir damit umgehen sollen (gibt es √ºbrigens irgendwelche Gedanken?). <br><br>  Ein bisschen dar√ºber, wie wir unser Frontend modifiziert haben, um das Problem zu l√∂sen.  Wenden wir uns noch einmal Trainer_type_jupyter.jsx zu - wir konzentrieren uns auf app_initialized und w√§hlen aus. <br><br>  Mit app_initialized ist alles elementar: Das Notebook wurde geladen, und wir m√∂chten etwas tun.  W√§hlen Sie beispielsweise die aktuelle Zelle abh√§ngig von der ausgew√§hlten Aufgabe aus.  Das Plugin wird beschrieben, damit Sie die taskId √ºbergeben und zur ersten Zelle wechseln k√∂nnen, die dieser taskId entspricht. <br><br>  N√§mlich: <br><br>  // Trainer_Typ_Jupyter.jsx <br><br><pre> <code class="xml hljs">selectTaskCell = ({taskId}) =&gt; { const {selectCell} = this.props; if (!this.iframeRef) { return; } selectCell({iframe: this.iframeRef, taskId}); };</code> </pre> <br>  // Trainer.actions.js <br><br><pre> <code class="xml hljs">export const selectCell = ({iframe, taskId}) =&gt; ({ type: SELECT_CELL, iframe, taskId });</code> </pre> <br>  // Trainer.saga.js <br><br><pre> <code class="xml hljs">function* selectCell({iframe, taskId}) { iframe.contentWindow.postMessage(JSON.stringify({ type: 'select-cell', data: {taskId} }), '*'); yield; } function* watchSelectCell() { yield takeEvery(SELECT_CELL, selectCell); }</code> </pre> <br>  // custom.js (Jupyter Plugin) <br><br><pre> <code class="xml hljs">function getCellTaskId(cell) { const notebook = Jupyter.notebook; while (cell) { const tags = cell.metadata.tags; const taskId = tags &amp;&amp; tags[0]; if (taskId) { return taskId; } cell = notebook.get_prev_cell(cell); } return null; } function selectCell({taskId}) { const notebook = Jupyter.notebook; const selectedCell = notebook.get_selected_cell(); if (!taskId) { selectedCell.unselect(); return; } if (selectedCell &amp;&amp; selectedCell.selected &amp;&amp; getCellTaskId(selectedCell) === taskId) { return; } const index = notebook.get_cells() .findIndex(cell =&gt; getCellTaskId(cell) === taskId); if (index <span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0</span></span></span><span class="hljs-tag">) { </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">return</span></span></span><span class="hljs-tag">; } </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">notebook.select</span></span></span><span class="hljs-tag">(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">index</span></span></span><span class="hljs-tag">); </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">const</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">cell</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">notebook.get_cell(index);</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">cell.element</span></span></span><span class="hljs-tag">[</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0</span></span></span><span class="hljs-tag">]</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">.scrollIntoView</span></span></span><span class="hljs-tag">({ </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">behavior:</span></span></span><span class="hljs-tag"> '</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">smooth</span></span></span><span class="hljs-tag">', </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">block:</span></span></span><span class="hljs-tag"> '</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">start</span></span></span><span class="hljs-tag">' }); } </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">function</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">actionListener</span></span></span><span class="hljs-tag">({</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">data:</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">eventString</span></span></span><span class="hljs-tag">}) { </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">case</span></span></span><span class="hljs-tag"> '</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">select-cell</span></span></span><span class="hljs-tag">'</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">selectCell</span></span></span><span class="hljs-tag">(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">event.data</span></span></span><span class="hljs-tag">); </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">break</span></span></span><span class="hljs-tag">;</span></span></code> </pre> <br>  Jetzt k√∂nnen Sie die Zellen wechseln und aus dem Iframe lernen, dass die Zelle gewechselt wurde. <br><br>  Beim Wechseln der Zelle √§ndern wir die URL und fallen in eine andere Aufgabe.  Es bleibt nur das Gegenteil zu tun - wenn Sie eine andere Aufgabe in der Schnittstelle ausw√§hlen, wechseln Sie die Zelle.  Einfach: <br><br><pre> <code class="xml hljs">componentDidUpdate({match: {params: {prevTaskId}}) { const {match: {params: {taskId}}} = this.props; if (taskId !== prevTaskId) { this.selectTaskCell({taskId});</code> </pre> <br><h3>  Separater Kessel f√ºr Perfektionisten </h3><br>  Es w√§re cool, nur damit zu prahlen, wie gut wir gemacht sind.  Die L√∂sung im Endeffekt ist effektiv, obwohl sie etwas chaotisch aussieht: Zusammenfassend haben wir eine Methode, die jede Nachricht verarbeitet, die von au√üen kommt (in unserem Fall von einem Iframe).  Aber in dem System, das wir selbst aufgebaut haben, gibt es Dinge, die ich und meine Kollegen nicht wirklich m√∂gen. <br><br>  ‚Ä¢ Es gibt keine Flexibilit√§t bei der Interaktion von Elementen: Wenn wir neue Funktionen hinzuf√ºgen m√∂chten, m√ºssen wir das Plugin so √§ndern, dass es sowohl das alte als auch das neue Kommunikationsformat unterst√ºtzt.  Es gibt keinen einzigen isolierten Mechanismus f√ºr die Arbeit zwischen dem Iframe und unserer Front-End-Komponente, der das Jupyter-Notizbuch in der Lektionsoberfl√§che rendert und mit unseren Aufgaben arbeitet.  Global - es besteht der Wunsch, ein flexibleres System zu schaffen, damit es in Zukunft einfach ist, neue Aktionen, Ereignisse hinzuzuf√ºgen und zu verarbeiten.  Und das nicht nur beim Jupiter-Notebook, sondern auch bei jedem Iframe in den Simulatoren.  Wir versuchen also, den Plug-In-Code √ºber postMessage zu √ºbergeben und ihn (eval) im Plug-In zu rendern. <br><br>  ‚Ä¢ Codefragmente, die Probleme l√∂sen, sind im gesamten Projekt verteilt.  Die Kommunikation mit iframes erfolgt sowohl √ºber Redux-Saga als auch √ºber die Komponente, was sicherlich nicht optimal ist. <br><br>  ‚Ä¢ Iframe selbst mit Jupyter Notebook-Rendering befindet sich auf einem anderen Dienst.  Die Bearbeitung ist etwas problematisch, insbesondere in √úbereinstimmung mit dem Prinzip der Abw√§rtskompatibilit√§t.  Wenn wir zum Beispiel eine Art Logik am Frontend und im Notebook selbst √§ndern wollen, m√ºssen wir doppelte Arbeit leisten. <br><br>  ‚Ä¢ Viele m√∂chten einfacher implementieren.  Nehmen Sie mindestens Reagieren.  Er hat eine Menge Lebenszyklusmethoden, von denen jede verarbeitet werden muss.  Au√üerdem verwirrt mich die Bindung an React selbst.  Im Idealfall m√∂chte ich mit unseren iframes arbeiten k√∂nnen, unabh√§ngig davon, um welches Front-End-Framework es sich handelt.  Im Allgemeinen unterliegt die √úberschneidung der von uns ausgew√§hlten Technologien Einschr√§nkungen: Dieselbe Redux-Saga erwartet von uns Redux-Aktionen, nicht von postMessage. <br><br>  Wir werden also definitiv nicht aufh√∂ren, was erreicht wurde.  Ein Lehrbuch-Dilemma: Sie k√∂nnen auf die Seite der Sch√∂nheit gehen, aber die Optimalit√§t der Leistung opfern oder umgekehrt.  Wir haben noch nicht die beste L√∂sung gefunden. <br><br>  Vielleicht kommen Ihnen Ideen? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453876/">https://habr.com/ru/post/de453876/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453866/index.html">API-Anfrage mit React Hooks, HOC oder Render Prop</a></li>
<li><a href="../de453868/index.html">Ber√ºhren Sie den Mini-Schalter mit Glasscheibe am nRF52832</a></li>
<li><a href="../de453870/index.html">Wir schreiben Reverse socks5 Proxy auf Powershell. Teil 1</a></li>
<li><a href="../de453872/index.html">Wiederherstellen von Fotos mithilfe neuronaler Netze</a></li>
<li><a href="../de453874/index.html">Vom russischen Roulette zum sicheren LOTO: So sch√ºtzen Sie das Personal des Rechenzentrums</a></li>
<li><a href="../de453882/index.html">Ein guter Leitfaden zum Beruf eines L√∂sungsarchitekten (+ Liste n√ºtzlicher Links)</a></li>
<li><a href="../de453884/index.html">HYIP Kamera oder DSLR Ersatz?</a></li>
<li><a href="../de453886/index.html">Programm funktioniert</a></li>
<li><a href="../de453890/index.html">Sowjetische Zukunftstr√§ume</a></li>
<li><a href="../de453892/index.html">ISTQB-Zertifizierung. Teil 2: Wie bereite ich mich auf die ISTQB-Zertifizierung vor? Geschichten √ºben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>