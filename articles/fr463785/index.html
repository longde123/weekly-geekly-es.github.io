<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐌 👪 ❓ Présentation des émulateurs de terminaux 👨‍👩‍👧‍👦 👩🏾‍🎤 👩‍❤️‍💋‍👩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quelques mots de notre bureau de traduction: généralement tout le monde veut traduire les derniers documents et publications, et nous ne faisons pas e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Présentation des émulateurs de terminaux</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/463785/">  <i>Quelques mots de notre bureau de traduction: généralement tout le monde veut traduire les derniers documents et publications, et nous ne faisons pas exception.</i>  <i>Mais les terminaux ne sont pas mis à jour une fois par semaine.</i>  <i>Par conséquent, nous avons traduit pour vous un article d'Antoine Bopre publié au printemps 2018: malgré le solide «âge» selon les normes modernes, à notre avis, le matériel n'a pas complètement perdu sa pertinence.</i>  <i>De plus, l'original est une série de deux articles, mais nous avons décidé de les combiner en un seul gros post.</i> <br><br><img src="https://habrastorage.org/webt/_4/qm/3j/_4qm3jhmwxnoyxqc6jblinmiuoa.jpeg"><br><br>  Les terminaux occupent une place particulière dans l'histoire de l'ordinateur, mais au cours des dernières décennies, ils ont été "contraints" de survivre littéralement avec la ligne de commande dans le contexte d'interfaces graphiques omniprésentes.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les émulateurs de terminaux ont</a> remplacé leurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">homologues matériels</a> , qui, à leur tour, étaient une modification des systèmes sur les cartes perforées et les interrupteurs à bascule.  Les distributions modernes sont livrées avec une multitude d'émulateurs de terminaux de toutes formes et couleurs.  Et tandis que beaucoup se contentent tranquillement du terminal standard fourni par leur environnement de travail, certains sont fiers d'utiliser un logiciel franchement exotique pour lancer leur shell ou éditeur de texte préféré.  Mais, comme nous le verrons dans cet article, tous les terminaux n'ont pas été créés dans une même image et ressemblance: ils varient considérablement en termes de fonctionnalité, de taille et de performances. <br><a name="habracut"></a><br><br>  Certains terminaux ont des trous de sécurité incroyables, de plus, la plupart ont un ensemble de fonctions complètement différent, de la prise en charge de l'interface à onglets aux scripts.  Bien que nous ayons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">examiné les émulateurs de terminaux dans un passé lointain</a> , cet article est une mise à jour du matériel précédent qui aidera les lecteurs à déterminer le terminal à utiliser en 2018.  La première moitié de l'article compare les fonctions et la seconde moitié évalue les performances. <br><br>  Voici les terminaux que j'ai examinés: <br><br><img src="https://habrastorage.org/webt/c4/3l/gy/c43lgydftmr0spxf35oq3vgyozy.jpeg"><br><br>  Ce ne sont peut-être pas les dernières versions, car je me suis limité aux versions stables au moment de la rédaction, que j'ai pu déployer sur Debian 9 ou Fedora 27. La seule exception est Alacritty.  Il est un descendant de terminaux avec accélération GPU et est écrit dans un langage inhabituel et nouveau pour cette tâche - Rust.  J'ai exclu les terminaux Web de mon examen (y compris sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Electron</a> ), car les tests préliminaires ont montré leurs performances extrêmement médiocres. <br><br><h4>  Prise en charge Unicode </h4><br>  J'ai commencé mes tests avec le support Unicode.  Le premier test terminal était d'afficher une chaîne Unicode à partir d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article Wikipedia</a> : "é, Δ ,,, ק, م, ๗, あ, 叶, 葉 et 말."  Ce test simple montre si le terminal peut fonctionner correctement dans le monde entier.  Le terminal xterm n'affiche pas le symbole <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mem</a> arabe dans la configuration par défaut: <br><br><img src="https://habrastorage.org/webt/gv/no/zm/gvnozm-mh17i-33qam74-r2i8n0.png"><br><br>  Par défaut, xterm utilise la police classique «fixe» qui, selon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wiki</a> , a «une couverture Unicode importante depuis 1997».  Quelque chose se produit dans cette police qui fait apparaître le caractère comme un cadre vide et ce n'est que lorsque la police de texte est augmentée à 20+ points que le caractère commence enfin à s'afficher correctement.  Cependant, une telle «correction» interrompt l'affichage des autres caractères Unicode: <br><br><img src="https://habrastorage.org/webt/ke/lt/oe/keltoepwoz-dt_388rrmzaw7xy0.png"><br><br>  Ces captures d'écran ont été prises dans Fedora 27, car elles donnaient de meilleurs résultats que Debian 9, où certaines anciennes versions de terminaux (en particulier mlterm) ne pouvaient pas fonctionner correctement avec les polices.  Heureusement, cela a été corrigé dans les versions ultérieures. <br><br>  Faites maintenant attention au mappage des chaînes dans xterm.  Il s'avère que le symbole Mem et le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Qoph</a> sémitique <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">suivant</a> appartiennent à des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">scripts</a> RTL (de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">droite à gauche</a> ), donc techniquement, ils doivent être affichés de droite à gauche.  Les navigateurs Web, tels que Firefox 57, gèrent correctement la ligne ci-dessus.  Une version plus simple du texte RTL est le mot " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sarah</a> " en hébreu ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">שרה</a> ).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La page wiki bidirectionnelle</a> dit ce qui suit: <br><blockquote>  «De nombreux programmes informatiques ne peuvent pas afficher correctement le texte bidirectionnel.  Par exemple, le nom hébreu "Sarah" se compose des symboles sin (ש) (qui apparaît à droite), puis resh (ר) et, enfin, heh (ה) (qui devrait apparaître à gauche). " </blockquote><br>  De nombreux terminaux échouent à ce test: Alacritty, les terminaux dérivés de VTE Gnome et XFCE, urxvt, st et xterm affichent «Sarah» dans l'ordre inverse, comme si nous épelions ce nom par «Aras». <br><br><img src="https://habrastorage.org/webt/z4/yw/gi/z4ywgic4drs6yom_j1xxlnvgh5e.png"><br><br>  Un autre problème avec les textes bidirectionnels est qu'ils doivent être alignés d'une manière ou d'une autre, surtout quand il s'agit de mélanger des textes RTL et LTR.  Les scripts RTL doivent s'exécuter sur le côté droit de la fenêtre du terminal, mais que doit-il se passer pour les terminaux utilisant l'anglais LTR par défaut?  La plupart d'entre eux n'ont aucun mécanisme spécial et alignent tout le texte à gauche (y compris Konsole).  Les exceptions sont pterm et mlterm, qui respectent les normes et alignent ces lignes vers la droite. <br><br><img src="https://habrastorage.org/webt/ji/9b/xx/ji9bxx3oy7oqjavtph7zjajxwhq.png"><br><br><h4>  Protection d'insertion </h4><br>  La prochaine caractéristique critique que j'ai déterminée par moi-même est la protection contre l'insertion.  Bien qu'il soit largement connu que des sorts comme: <br><br><pre><code class="plaintext hljs">$ curl http://example.com/ | sh</code> </pre> <br>  sont des commandes d'exécution de code push; peu de gens savent que les commandes cachées peuvent pénétrer la console lors de la copie et du collage à partir d'un navigateur Web, même après une inspection approfondie.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le site de test de Gianna Horne</a> montre avec brio à quel point l'équipe semble inoffensive: <br><br><pre> <code class="plaintext hljs">git clone git: //git.kernel.org/pub/scm/utils/kup/kup.git</code> </pre> <br>  cela se transforme en une telle nuisance lors du collage du site Web Horn dans le terminal: <br><br><pre> <code class="plaintext hljs">git clone /dev/null; clear; echo -n "Hello "; whoami|tr -d '\n'; echo -e '!\nThat was a bad idea. Don'"'"'t copy code from websites you don'"'"'t trust! \ Here'"'"'s the first line of your /etc/passwd: '; head -n1 /etc/passwd git clone git://git.kernel.org/pub/scm/utils/kup/kup.git</code> </pre> <br>  Comment ça marche?  Le code malveillant est placé dans le bloc <b>&lt;span&gt;</b> , qui est déplacé du champ de vision de l'utilisateur à l'aide de CSS. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le mode de collage entre crochets est</a> clairement conçu pour neutraliser de telles attaques.  Dans ce mode, les terminaux enferment le texte inséré dans une paire de séquences d'échappement spéciales pour informer le shell de l'origine de ce texte.  Le shell reçoit donc un signal indiquant qu'il peut ignorer les caractères spéciaux que le texte inséré peut contenir.  Tous les terminaux, jusqu'à la vénérable xterm, prennent en charge cette fonction, mais l'insertion en mode Bracketed nécessite la prise en charge d'un shell ou d'une application s'exécutant sur le terminal.  Par exemple, un logiciel utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GNU Readline</a> (le même Bash) a besoin d'un <b>fichier ~ / .inputrc</b> : <br><br><pre> <code class="plaintext hljs">set enable-bracketed-paste on</code> </pre> <br>  Malheureusement, le site de test Horn montre également comment contourner cette protection en formatant le texte lui-même et en mettant fin prématurément à l'application du mode Bracketing.  Cela fonctionne car certains terminaux ne filtrent pas correctement les séquences d'échappement avant d'ajouter les leurs.  Par exemple, dans le mien, je n'ai pas pu terminer avec succès les tests de Konsole, même en tenant compte de la configuration correcte du fichier <b>.inputrc</b> .  Cela signifie que vous pouvez facilement obtenir des dommages de configuration du système en raison d'une application non prise en charge ou d'un shell mal configuré.  Cela est particulièrement dangereux lors de la saisie de serveurs distants, où une étude minutieuse de la configuration est moins courante, surtout si vous disposez de nombreuses machines distantes de ce type. <br><br>  Une bonne solution à ce problème est le plugin de confirmation de <b>collage</b> pour le terminal <b>urxvt</b> , qui demande simplement l'autorisation de coller tout texte contenant de nouvelles lignes.  Je n'ai pas trouvé d'option plus sûre pour l'attaque de texte décrite par Horn. <br><br><h4>  Onglets et profils </h4><br>  Une fonctionnalité populaire consiste désormais à prendre en charge une interface à onglets, que nous définirons comme une seule fenêtre de terminal contenant quelques autres terminaux.  Pour différents terminaux, cette fonction est différente, et bien que les terminaux traditionnels comme xterm ne prennent pas du tout en charge les onglets, les incarnations de terminaux plus modernes représentées par Xfce Terminal, GNOME Terminal et Konsole ont cette fonction.  Urxvt prend également en charge les onglets, mais uniquement si le plug-in est utilisé.  Mais en termes de prise en charge des onglets en tant que tels, Terminator est le leader incontesté: il prend non seulement en charge les onglets, mais peut également organiser les terminaux dans n'importe quel ordre (voir l'image ci-dessous). <br><br><img src="https://habrastorage.org/webt/eq/2s/_f/eq2s_fad0t8_7v6uymzkg7xndvs.png"><br><br>  Une autre caractéristique de Terminator est la possibilité de «regrouper» ces onglets et d'envoyer les mêmes frappes à plusieurs terminaux en même temps, ce qui fournit un outil grossier pour effectuer des opérations en bloc sur plusieurs serveurs simultanément.  Une fonctionnalité similaire est également implémentée dans Konsole.  Pour utiliser cette fonction dans d'autres terminaux, vous devez utiliser un logiciel tiers tel que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cluster SSH</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">xlax</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tmux</a> . <br><br>  Les onglets fonctionnent particulièrement bien avec les profils: par exemple, vous pouvez avoir un onglet pour le courrier électronique, un autre pour le chat, etc.  Ceci est bien pris en charge par Konsole et GNOME Terminal.  Les deux permettent à chaque onglet de lancer automatiquement son profil.  Terminator prend également en charge les profils, mais je n'ai pas trouvé de moyen de lancer automatiquement certains programmes lorsque j'ouvre un certain onglet.  D'autres terminaux n'ont pas du tout le concept de profil. <br><br><h4>  Ryushechki </h4><br>  La dernière chose que je considérerai dans la première partie de cet article est l'apparence des terminaux.  Par exemple, GNOME, Xfce et urxvt prennent en charge la transparence, mais ont récemment supprimé la prise en charge des images d'arrière-plan, forçant certains utilisateurs à basculer vers le terminal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tilix</a> .  Personnellement, je suis content de <b>Xresources</b> , qui définit l'ensemble de base des couleurs d'arrière-plan pour urxvt.  Cependant, les thèmes de couleurs personnalisés peuvent provoquer des problèmes.  Par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Solarized</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ne fonctionne pas</a> avec les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">applications</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">htop</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IPTraf</a> , car elles utilisent déjà leurs propres couleurs. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le terminal VT100 d'origine</a> ne prend pas en charge les couleurs, et les nouveaux sont souvent limités à une palette de 256 couleurs.  Pour les utilisateurs avancés qui modèlent leurs terminaux, les requêtes shell ou les barres d'état de certaines manières complexes peuvent être une limitation désagréable.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gist</a> garde une trace des terminaux qui prennent en charge True Color.  Mes tests confirment que les terminaux basés sur st, Alacritty et VTE prennent parfaitement en charge True Color.  À cet égard, d'autres terminaux ne se sentent pas très bien et, en fait, n'affichent même pas 256 couleurs.  Ci-dessous, vous pouvez voir la différence entre la prise en charge de True Color dans les terminaux GNOME, st et xterm, qui font un bon travail avec leur palette de 256 couleurs, et urxvt, qui non seulement échoue au test, mais affiche même quelques caractères clignotants à la place eux. <br><br><img src="https://habrastorage.org/webt/3u/go/mq/3ugomq0evrr7ql1h9xsapwjp_om.png"><br><br>  Certains terminaux analysent également le texte pour les modèles d'URL afin de rendre les liens cliquables.  Cela s'applique à tous les terminaux dérivés de VTE, tandis que urxvt nécessite un plug-in spécial qui transforme les URL en un clic ou un raccourci clavier.  D'autres terminaux que j'ai testés affichent d'autres URL. <br><br>  Enfin, une nouvelle tendance pour les terminaux est l'option de tampon de défilement.  Par exemple, dans st, il n'y a pas de tampon de défilement;  il est supposé que l'utilisateur utilisera un multiplexeur de terminal comme tmux et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GNU Screen</a> . <br><br>  Alacritty manque également de tampons de défilement inversés, mais le support <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sera bientôt ajouté en</a> raison des "commentaires approfondis" des utilisateurs sur ce sujet.  En plus de ces nouveaux arrivants, chaque terminal que j'ai testé que je pouvais trouver prend en charge le défilement vers l'arrière. <br><br><h4>  Sous-totaux </h4><br>  Dans la deuxième partie du matériel ( <i>dans l'original, il s'agissait de deux articles différents, - environ Per.</i> ) Nous comparerons les performances, l'utilisation de la mémoire et le délai.  Mais nous constatons déjà que certains des terminaux en question présentent de graves lacunes.  Par exemple, les utilisateurs qui travaillent régulièrement avec des scripts RTL peuvent prêter attention à mlterm et pterm, car ils gèrent mieux ces tâches que d'autres.  Konsole a également bien performé.  Les utilisateurs qui ne travaillent pas avec les scripts RTL peuvent choisir autre chose. <br><br>  Du point de vue de la sécurité contre l'insertion de code malveillant, urxvt se démarque par sa mise en œuvre particulière de protection contre ce type d'attaque, ce qui me semble tout à fait pratique.  Ceux qui recherchent des cloches et des sifflets devraient regarder Konsole.  Enfin, il convient de noter que VTE est une excellente base pour les terminaux, ce qui garantit la prise en charge des couleurs, la reconnaissance des URL, etc.  À première vue, le terminal par défaut fourni avec votre environnement préféré peut répondre à toutes les exigences, mais laissons cette question ouverte jusqu'à ce que nous trouvions les performances. <br><br><h4>  <i>Continuez la conversation</i> </h4><br>  En général, les performances des terminaux en soi peuvent sembler farfelues, cependant, comme il s'est avéré, certains d'entre eux démontrent un retard étonnamment important pour les logiciels de ce type fondamental.  Nous examinerons également plus en détail ce que l’on appelle traditionnellement la «vitesse» (en fait, c’est la vitesse de défilement) et la consommation de mémoire du terminal (étant donné qu’aujourd’hui ce n’est pas aussi critique qu’il y a des décennies). <br><br><h4>  Retard </h4><br>  Après une étude approfondie des performances du terminal, je suis arrivé à la conclusion que le paramètre le plus important à cet égard est la taille du retard (ping).  Dans son article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Nous imprimons avec plaisir»,</a> Pavel Fatin a examiné le retard de divers éditeurs de texte et a laissé entendre que les terminaux à cet égard peuvent fonctionner plus lentement que les éditeurs de texte les plus rapides.  C'est cet indice qui m'a finalement conduit à lancer mes propres tests et à écrire cet article. <br><br>  Mais qu'est-ce qu'un retard et pourquoi est-il si important?  Dans son article, Fatin l'a défini comme «le délai entre la pression d'une touche et la mise à jour d'écran correspondante» et a cité le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Manuel sur l'interaction homme-machine»</a> comme disant: «Le retard dans la rétroaction visuelle sur l'écran de l'ordinateur a un effet important sur le comportement de la dactylo et sa satisfaction ". <br><br>  Fatin explique qu'un tel ping a des conséquences plus profondes que la simple satisfaction: "la frappe devient plus lente, plus d'erreurs se produisent, la tension oculaire et musculaire augmente."  En d'autres termes, un retard important peut entraîner des fautes de frappe, ainsi qu'une diminution de la qualité du code, car il entraîne une charge cognitive supplémentaire sur le cerveau.  Mais pire encore, le ping «augmente la tension des yeux et des muscles», ce qui, apparemment, implique le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">développement de lésions professionnelles</a> à l'avenir ( <i>apparemment, l'auteur signifie des problèmes avec les muscles des yeux, du dos, des bras et, bien sûr, de la vision, - environ Per.</i> ) En raison du stress répétitif. <br><br>  Certains de ces effets sont connus depuis longtemps et les résultats d'une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">étude</a> publiée en 1976 dans la revue Ergonomics indiquent qu'un retard de 100 millisecondes "aggrave considérablement la vitesse de numérotation".  Plus récemment, <a href="">un temps</a> de <a href="">réponse acceptable</a> de 10 millisecondes a été introduit dans le guide de l'utilisateur GNOME, et si nous allons plus loin, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Microsoft Research</a> montre qu'une milliseconde est idéale. <br><br>  Fatin a effectué ses tests sur des éditeurs de texte;  il a créé un outil portable appelé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Typometer</a> , que j'ai utilisé pour tester le ping dans les émulateurs de terminaux.  Gardez à l'esprit que le test a été effectué en mode simulation: en réalité, nous devons également prendre en compte le délai d'entrée (clavier, contrôleur USB, etc.) et la sortie (tampon de carte vidéo, moniteur).  Selon Fatin, dans les configurations typiques, elle est d'environ 20 ms.  Si vous avez un équipement de jeu, vous pouvez atteindre un indicateur de seulement 3 millisecondes.  Étant donné que nous disposons déjà d'un équipement aussi rapide, l'application ne devrait pas également introduire son retard.  L'objectif de Fatin est de retarder l'application jusqu'à 1 milliseconde, ou de réaliser la numérotation sans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">délai mesurable</a> , comme dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IntelliJ IDEA 15</a> . <br><br>  Et voici les résultats de mes mesures, ainsi que quelques résultats de Fatin afin de montrer que mon expérience est cohérente avec ses tests: <br><br><img src="https://habrastorage.org/webt/4s/u-/vn/4su-vnzyvqb35-uwp0ywpq2g76e.jpeg"><br><br>  La première chose qui m'a frappé a été le meilleur temps de réponse pour les programmes plus anciens tels que xterm et mlterm.  Avec la pire latence de registre (2,4 ms), ils ont montré de meilleurs résultats que le terminal moderne le plus rapide (10,6 ms pour st).  Pas un seul terminal moderne ne tombe en dessous d'un seuil de 10 millisecondes.  En particulier, Alacritty ne répond pas aux exigences de «l'émulateur de terminal existant le plus rapide», bien que ses résultats se soient améliorés depuis le premier contrôle en 2017.  En effet, les auteurs du projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sont conscients de la situation</a> et travaillent à l'amélioration de l'affichage.  Il convient également de noter que Vim utilisant GTK3 est un ordre de grandeur plus lent que son homologue GTK2.  De cela, nous pouvons conclure que GTK3 crée un retard supplémentaire, et cela se reflète dans tous les autres terminaux qui l'utilisent (Terminator, Xfce4 Terminal et GNOME Terminal). <br><br>  Cependant, les différences peuvent ne pas être visibles à l'œil nu.  Comme l'explique Fatin: «il n'est pas nécessaire d'être conscient du retard pour qu'il ait un effet sur vous.»  Fatin met également en garde contre un écart-type: "Toute irrégularité dans la durée du retard (gigue) crée une charge supplémentaire en raison de leur imprévisibilité." <br><br><img src="https://habrastorage.org/webt/dq/a4/0v/dqa40vpdfz4k9uctottd6h9j2we.png"><br><br>  Le graphique ci-dessus est pris sur Debian 9 pure (stretch) avec le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gestionnaire de fenêtres i3</a> .  Cet environnement donne les meilleurs résultats dans les tests de retard.  Il s'est avéré que GNOME crée un ping supplémentaire de 20 ms pour toutes les dimensions.  Une explication possible à cela est la présence de programmes avec traitement synchrone des événements d'entrée.  Fatin cite un exemple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Workrave</a> pour ce cas, qui ajoute un délai en traitant tous les événements d'entrée de manière synchrone.  Par défaut, GNOME possède également un gestionnaire de fenêtres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mutter</a> qui crée un niveau supplémentaire de mise en mémoire tampon, ce qui affecte le ping et ajoute un minimum de 8 millisecondes de retard. <br><br><img src="https://habrastorage.org/webt/ec/t9/ap/ect9apxhg0v5l0_q04qujn5xu4k.png"><br><br><h4>  Vitesse de défilement </h4><br>  Le test suivant est le test traditionnel de «vitesse» ou de «bande passante», qui mesure la vitesse à laquelle le terminal peut faire défiler une page, affichant une grande quantité de texte à l'écran.  La mécanique du test varie;  le test d'origine consistait simplement à générer la même chaîne de texte avec la commande seq.  D'autres tests incluent un test de Thomas E. Dickey (le responsable de xterm), qui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">télécharge à</a> plusieurs reprises <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le fichier terminfo.src</a> .  Dans un autre examen des performances du terminal, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Den Luu</a> utilise une chaîne codée en base32 d'octets aléatoires, qui est envoyée au terminal à l'aide de cat.  Luu considère qu'un tel test est «aussi inutile qu'on peut l'imaginer» et suggère d'utiliser à la place la réponse du terminal comme indicateur principal.  Dickey qualifie également son test de trompeur.  Cependant, les deux auteurs reconnaissent que la bande passante de la fenêtre du terminal peut être un problème.  Luu a trouvé Emacs Eshell gelé lors de l'affichage de gros fichiers, et Dickie a optimisé le terminal pour se débarrasser de la lenteur visuelle de xtrerm.  Par conséquent, il existe encore une raison pour ce test, mais comme le processus de rendu est très différent d'un terminal à l'autre, il peut également être utilisé comme composant de test pour vérifier d'autres paramètres. <br><br><img src="https://habrastorage.org/webt/4z/ov/rx/4zovrxmlnbnwpbzhnebcp412yf0.png"><br><br>  Ici, nous voyons que rxvt et st sont en avance sur la concurrence, suivis par le plus récent Alacritty, qui est développé en mettant l'accent sur la vitesse.  Viennent ensuite Xfce (la famille VTE) et Konsole, qui fonctionnent presque deux fois plus vite.  Le dernier est xterm avec un index cinq fois plus lent que rxvt.  Pendant le test, xterm a également ondulé, il était difficile de voir le texte qui passait, même s'il s'agissait de la même ligne.  Konsole s'est avéré être rapide, mais parfois c'était «délicat»: l'affichage pendait de temps en temps, montrant le texte partiellement ou ne l'affichant pas du tout.  D'autres terminaux affichaient clairement les chaînes, notamment st, Alacritty et rxvt. <br><br>  Dickie explique que les différences de performances sont liées à la conception de tampons de défilement dans différents terminaux.  En particulier, il accuse rxvt et d'autres terminaux de «ne pas suivre les règles générales»: <br><blockquote>  «Contrairement à xterm, rxvt n'a pas essayé d'afficher toutes les mises à jour.  S'il prend du retard, il supprimera certaines mises à jour pour rattraper son retard.  Cela a eu un effet plus important sur la vitesse de défilement imaginaire que sur l'organisation de la mémoire interne.  Un inconvénient était que l'animation ASCII était quelque peu inexacte. » </blockquote><br>  Pour corriger cette lenteur apparente de xterm, Dickey suggère d'utiliser la ressource <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fastScroll</a> , qui permet à xterm de supprimer certaines mises à jour d'écran afin de suivre le flux.  Mes tests confirment que fastScroll améliore les performances et amène xterm au même niveau que rxvt.  Ceci, cependant, est une béquille plutôt grossière, comme Dickey l'explique lui-même: "parfois xterm - comme konsole - semble s'arrêter, car il attend un nouvel ensemble de mises à jour d'écran après que certaines d'entre elles ont été supprimées."  Dans cet esprit, il semble que d'autres terminaux aient trouvé le meilleur compromis entre vitesse et intégrité d'affichage. <br><br><h4>  Consommation de ressources </h4><br>  Indépendamment de la pertinence de considérer la vitesse de défilement comme indicateur de performance, ce test vous permet de simuler la charge sur les terminaux, ce qui, à son tour, nous permet de mesurer d'autres paramètres, tels que l'utilisation de la mémoire ou du disque.  Les mesures ont été obtenues en exécutant le test <b>seq</b> spécifié sous la surveillance du processus Python.  Il a collecté les données du compteur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">getrusage ()</a> pour <b>ru_maxrss</b> , la somme de <b>ru_oublock</b> et <b>ru_inblock,</b> et un simple timer. <br><br><img src="https://habrastorage.org/webt/e7/ay/fm/e7ayfmzkluchtlybqvqjwmijobs.png"><br><br>  Dans ce test, ST prend la première place avec la plus petite consommation moyenne de mémoire de 8 Mo, ce qui n'est pas surprenant quand on considère que l'idée principale du projet est la simplicité.  Mlterm, xterm et rxvt consomment un peu plus - environ 12 Mo.  Alacritty a un autre résultat notable, qui nécessite 30 Mo pour fonctionner.  Ensuite, il y a les terminaux de la famille VTE avec des indicateurs de 40 à 60 Mo, ce qui est beaucoup.  Une telle consommation peut s'expliquer par le fait que ces terminaux utilisent des bibliothèques de niveau supérieur, par exemple GTK.  Konsole vient en dernier avec une énorme consommation de 65 Mo de mémoire lors des tests, bien que cela puisse être justifié par sa très large gamme de fonctions. <br><br>  Par rapport aux résultats précédents obtenus il y a dix ans, tous les programmes ont commencé à consommer beaucoup plus de mémoire.  Auparavant, Xterm nécessitait 4 Mo, mais maintenant - 15 Mo juste pour fonctionner.  Rxvt a une augmentation similaire de la consommation, qui nécessite désormais 16 Mo prêts à l'emploi.  Le terminal Xfce occupe 34 Mo, soit trois fois plus qu'auparavant, mais le terminal GNOME ne nécessite que 20 Mo.  Bien entendu, tous les tests précédents ont été effectués sur une architecture 32 bits.  Lors de l'ACV 2012, Rusty Russell a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">déclaré</a> qu'il existe de nombreuses raisons plus subtiles qui peuvent expliquer l'augmentation de la consommation de mémoire.  Avec tout cela, nous vivons maintenant à une époque où nous avons des gigaoctets entiers de mémoire, donc nous pouvons le gérer d'une manière ou d'une autre. <br><br>  Néanmoins, je ne peux m'empêcher de penser qu'allouer plus de mémoire à un logiciel aussi fondamental qu'un terminal est un gaspillage de ressources.        ,       «»,  ,   -   ,      Linux- (  ,     ).                 ,          .   , GNOME Terminal, Konsole, urxvt, Terminator  Xfce Terminal  Daemon-,        ,     . <br><br><img src="https://habrastorage.org/webt/bx/h6/dc/bxh6dcm-ahulyqaioo5vhmuwmea.png"><br><br>              -:       ,  ,         . ,  VTE       (  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">    2010 </a> ,      ).      , ,   ,      AES256 GCM ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  0.39.2</a> ).    ,       VTE,        … <br><br><h4>  Conclusion </h4><br>      ,     VTE    ,    ,          .     ,    VTE-    Daemon-,    .   ,  ,          ,  -      ,       .   VTE         (),             GNOME. ,  VTE   .     ,      Linux    ,          .                         -   .  ,   xterm  mlterm        10 ,    . <br><br>    ,  -    Linux      .        ,       .  ,  Wayland    :  Typometer,   ,    ,  Wayland   —    .  ,   Wayland   ,  X.org,      ,    -        . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr463785/">https://habr.com/ru/post/fr463785/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr463771/index.html">[Peter] Rencontre JUG.ru avec Sebastian Dashner - Rendre les tests d'entreprise plus joyeux</a></li>
<li><a href="../fr463773/index.html">Comment la protection des enfants contre les informations est organisée - et l'histoire enchanteresse sur l'origine de ces informations (18+)</a></li>
<li><a href="../fr463775/index.html">Qui utilise le protocole d'authentification SAML 2.0</a></li>
<li><a href="../fr463777/index.html">Surveillance de la disponibilité des hôtes Powershell</a></li>
<li><a href="../fr463781/index.html">Composants isolés zen dans l'architecture Android</a></li>
<li><a href="../fr463787/index.html">La grande vieille surprise de HP</a></li>
<li><a href="../fr463789/index.html">La puissance des génériques dans Swift. 2e partie</a></li>
<li><a href="../fr463791/index.html">Poignée en fer: cinématique du débarquement des oiseaux en fonction de la géométrie et de la texture de la surface</a></li>
<li><a href="../fr463795/index.html">Nuances de sens en anglais: comment utiliser les verbes conseiller, recommander, suggérer</a></li>
<li><a href="../fr463799/index.html">Ce que je n'aime pas dans Windows 10</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>