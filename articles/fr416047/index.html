<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✨ 🐨 🤔 Cours MIT "Sécurité des systèmes informatiques". Conférence 2: «Contrôle des attaques de pirates», partie 2 ⚗️ 👲🏻 👩🏼‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Institut de technologie du Massachusetts. Cours magistral # 6.858. "Sécurité des systèmes informatiques." Nikolai Zeldovich, James Mickens. 2014 année...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cours MIT "Sécurité des systèmes informatiques". Conférence 2: «Contrôle des attaques de pirates», partie 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/416047/"><h3>  Institut de technologie du Massachusetts.  Cours magistral # 6.858.  "Sécurité des systèmes informatiques."  Nikolai Zeldovich, James Mickens.  2014 année </h3><br>  Computer Systems Security est un cours sur le développement et la mise en œuvre de systèmes informatiques sécurisés.  Les conférences couvrent les modèles de menace, les attaques qui compromettent la sécurité et les techniques de sécurité basées sur des travaux scientifiques récents.  Les sujets incluent la sécurité du système d'exploitation (OS), les fonctionnalités, la gestion du flux d'informations, la sécurité des langues, les protocoles réseau, la sécurité matérielle et la sécurité des applications Web. <br><br>  Cours 1: «Introduction: modèles de menace» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <br>  Conférence 2: «Contrôle des attaques de pirates» <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> <a name="habracut"></a><br><br>  Donc, nous avons un tampon sur lequel nous mettons le «canari».  Au-dessus se trouve la valeur <b>EBP enregistrée du</b> pointeur de point d'arrêt et l'adresse de retour est placée au-dessus.  Si vous vous souvenez, le débordement va de bas en haut, donc avant d'arriver à l'adresse de retour, il détruira d'abord le "canari". <br><br><img src="https://habrastorage.org/webt/va/0q/i_/va0qi_40d-7cknrooq7olqwfbga.jpeg"><br><br>  <b>Public:</b> pourquoi affectera-t-il le "canari"? <br><br>  <b>Professeur:</b> car on suppose que l'attaquant ne sait pas «sauter» arbitrairement en mémoire.  Les attaques de dépassement de mémoire traditionnelles commencent par un pirate qui examine la limite de taille de la mémoire tampon, après quoi le débordement commence à partir de la ligne de fond.  Mais vous avez raison - si un attaquant peut accéder directement à la barre d'adresse de retour, aucun «canari» ne nous aidera.  Cependant, avec une attaque de débordement de tampon traditionnelle, tout devrait se passer exactement de cette façon - de bas en haut. <br><br>  Ainsi, l'idée principale d'utiliser un «canari» est que nous permettons à un exploit malveillant de déborder la mémoire tampon.  Nous avons un code d'exécution qui, lors du retour d'une fonction, vérifie le "canari" pour s'assurer qu'il a la bonne valeur. <br><br>  <b>Public:</b> Un attaquant peut-il réécrire l'adresse de retour et changer le «canari»?  Comment peut-il vérifier qu'elle a été modifiée, mais continue de remplir sa fonction? <br><br>  <b>Professeur:</b> oui, peut-être.  Ainsi, vous devriez avoir un morceau de code qui vérifiera cela avant le retour de la fonction.  Autrement dit, dans ce cas, il est nécessaire d'avoir le support d'un compilateur, qui va réellement étendre la <b>convention d'appel convention d'appel</b> .  Donc, une partie de la séquence de retour se produit avant que nous considérions la validité de cette valeur pour nous assurer que le «canari» n'a pas été détruit.  Ce n'est qu'après cela que nous pouvons penser à autre chose. <br><br>  <b>Public:</b> Un attaquant ne peut-il pas savoir ou deviner ce que signifie «canari»? <br><br>  <b>Professeur:</b> c'est exactement ce dont je vais parler!  Quel est le problème avec ce circuit?  Et si, par exemple, nous mettons la valeur A dans chaque programme?  Ou une branche entière de 4 valeurs de A?  Bien entendu, tout pirate peut connaître la taille du tampon, sa capacité, et ainsi déterminer la position du "canari" dans n'importe quel système.  Par conséquent, nous pouvons utiliser différents types de quantités que nous mettons dans notre «canari» pour éviter cela. <br><br>  Il y a une chose que vous pouvez faire avec notre «canari».  Ce sera un type de "canari" très drôle, qui utilise les fonctions du programme C et traite des caractères spéciaux, le type dit "canari" déterministe. <br><br><img src="https://habrastorage.org/webt/ww/nu/7w/wwnu7wtc-tnfgf7iwtux0guvoli.jpeg"><br><br>  Imaginez que vous avez utilisé le caractère 0 pour le «canari». La valeur binaire de zéro est l'octet zéro, le caractère zéro en ASCII.  Une valeur de -1 signifie un retour à la position précédente et ainsi de suite.  De nombreuses fonctions arrêtent ou changent de fonctionnement lorsqu'elles rencontrent des caractères ou des valeurs telles que 0, CR, LF, -1.  Imaginez que vous, en tant que pirate, utilisiez une fonction de gestion de chaîne pour remonter le tampon, rencontrez le caractère 0 dans le "canari" et le processus s'arrête!  Si vous utilisez la fonction «retour chariot» -1, qui est souvent utilisée comme terminaison de ligne, le processus s'arrête également.  -1 est donc un autre signe magique. <br><br>  Il y a encore une chose qui peut être utilisée dans le «canari» - ce sont des valeurs aléatoires difficiles à deviner pour l'attaquant.  La puissance de la valeur aléatoire est basée sur la difficulté pour un attaquant de la deviner.  Par exemple, si un attaquant se rend compte qu'il n'y a que 3 bits d'entropie dans votre système, il pourra alors utiliser une attaque par force brute.  Par conséquent, les possibilités d'utiliser des nombres aléatoires pour se protéger contre les attaques sont assez limitées. <br><br><img src="https://habrastorage.org/webt/a0/qf/au/a0qfauye6kmbnvhhfifmesgudy0.jpeg"><br><br>  <b>Public: Il</b> arrive généralement que je lis dans un autre tampon et que j'écrive ce que j'ai lu dans ce tampon de cette pile.  Dans cette situation, il semble que la valeur aléatoire du "canari" soit inutile, car je lis les données d'un autre tampon et je sais où se trouve le "canari".  J'ai un autre tampon que je contrôle et que je ne vérifie jamais.  Et dans ce tampon, je peux mettre beaucoup de ce que je veux mettre.  Je n'ai pas besoin d'un «canari» aléatoire, car je peux le réécrire en toute sécurité.  Je ne vois donc pas comment cela fonctionne vraiment - dans le scénario que vous avez proposé, lorsque la fonction s'arrête lors de la lecture des données du tampon. <br><br>  <b>Professeur:</b> Je comprends votre question - vous voulez dire que nous utilisons un "canari" déterministe, mais n'utilisez pas l'une des fonctions de la bibliothèque standard qui peut être "trompée" par nos caractères 0, CR, LF, -1.  Alors oui, dans la situation que vous avez décrite, un «canari» n'est pas nécessaire. <br><br>  L'idée est que vous pouvez remplir ce tampon avec des octets de n'importe où, mais tout ce qui vous permet de deviner ces valeurs ou de les obtenir de manière aléatoire entraînera un échec. <br><br>  <b>Public:</b> Est-il possible d'utiliser quelque chose comme le nombre de secondes ou de millisecondes comme nombres aléatoires et de les utiliser dans un «canari»? <br><br>  <b>Professeur:</b> Les appels de données ne contiennent pas autant d'accidents que vous le pensez.  Parce que le programme a des journaux ou une fonction que vous pouvez appeler pour savoir quand le programme a été téléchargé et d'autres choses similaires.  Mais en général, vous avez raison - dans la pratique, si vous pouvez utiliser un périphérique matériel, généralement de bas niveau, avec de meilleurs temps système, ce type d'approche peut fonctionner. <br><br>  <b>Public:</b> même si nous parvenons à afficher les journaux sur le début du débordement de la mémoire tampon, il est toujours important de savoir à quelle heure nous refusons la demande.  Et si nous ne pouvons pas contrôler le temps que prend la demande d’un ordinateur au serveur, il est douteux que l’heure exacte puisse être déterminée de manière déterministe. <br><br>  <b>Professeur:</b> très bien, j'ai déjà dit que le mal réside dans les détails, c'est juste un tel cas.  En d'autres termes, si vous avez, par exemple, un moyen de déterminer le type de canal de synchronisation, vous constaterez peut-être que la quantité d'entropie ou le nombre d'aléatoire ne remplit pas un horodatage complet, mais beaucoup moins.  Par conséquent, un attaquant peut déterminer l'heure et la minute où vous avez fait cela, mais pas une seconde. <br><br>  <b>Public:</b> pour mémoire, essayer de limiter votre propre caractère aléatoire est une mauvaise idée? <br><br>  <b>Professeur:</b> tout à fait raison! <br><br>  <b>Public:</b> c'est-à-dire que nous devons généralement utiliser tout ce que nos systèmes prennent en charge, non? <br><br>  <b>Professeur:</b> oui, c'est vrai.  C'est comme l'invention de notre propre cryptosystème, qui est une autre chose populaire que nos diplômés veulent parfois faire.  Mais nous ne sommes pas la NSA, nous ne sommes pas des mathématiciens, donc cela échoue généralement.  Vous avez donc tout à fait raison. <br><br>  Mais même si vous utilisez l'aléatoire du système, vous pouvez toujours obtenir moins d'entropie que vous ne le pensez.  Permettez-moi de vous donner un exemple de randomisation de phase des adresses.  C'est sur ce principe que l'approche des <b>canaris de pile fonctionne</b> .  Puisque nous sommes engagés dans la sécurité informatique, vous vous demandez probablement dans quels cas les "canaris" ne peuvent pas faire face à leur tâche et s'il existe des moyens d'échouer le "canari". <br><br>  Une telle manière est une attaque en réécrivant des pointeurs de fonction.  Parce que si un coup est porté sur le pointeur de fonction, le «canari» ne peut rien faire. <br><br>  Supposons que vous ayez un code de la forme <b>int * ptr ... ..</b> , le pointeur initiateur, peu importe comment, alors vous avez le <b>tampon char buf [128]</b> , la fonction <b>gets (buf)</b> , et tout en bas un pointeur auquel est affectée une valeur : <b>* ptr = 5</b> . <br><br>  Je note que nous n'avons pas essayé d'attaquer l'adresse de retour de la fonction contenant ce code.  Comme vous pouvez le voir, lorsque le tampon déborde, l'adresse du pointeur située au-dessus de celui-ci sera endommagée.  Si un attaquant peut endommager ce pointeur, il peut alors attribuer 5 à l'une des adresses qu'il contrôle.  Est-ce que tout le monde peut voir que le «canari» n'aidera pas ici?  Parce que nous n'attaquons pas le chemin par lequel la fonction revient. <br><br><img src="https://habrastorage.org/webt/hz/oq/em/hzoqemqhfljf4w6rzownchcppbc.jpeg"><br><br>  <b>Public:</b> le pointeur peut-il être situé sous le tampon? <br><br>  <b>Professeur: c'est</b> possible, mais l'ordre des variables spécifiques dépend de beaucoup de choses différentes, de la façon dont le compilateur organise le contenu, de la taille de la colonne matérielle, etc.  Mais vous avez raison, si le débordement de la mémoire tampon monte et que le pointeur est situé sous la mémoire tampon, le débordement ne peut pas l'endommager. <br><br>  <b>Public:</b> pourquoi ne pouvez-vous pas associer le «canari» à la fonction «canari», comme vous l'avez fait avec l'adresse de retour? <br><br>  <b>Professeur:</b> c'est un moment intéressant!  Vous pouvez faire de telles choses.  En fait, vous pouvez essayer d'imaginer un compilateur qui chaque fois qu'il a un pointeur, il essaie toujours d'ajouter un module complémentaire pour certaines choses.  Cependant, vérifier toutes ces choses sera trop cher.  Parce que chaque fois que vous voulez utiliser un pointeur ou appeler une fonction, vous devez avoir un code qui vérifiera si ce "canari" est correct.  Fondamentalement, vous pourriez faire quelque chose de similaire, mais cela a-t-il un sens?  Nous voyons que les «canaris» n'aident pas dans cette situation. <br><br>  Et une autre chose dont nous avons discuté plus tôt est que si l'attaquant peut deviner le caractère aléatoire, alors, en principe, les «canaris» aléatoires ne fonctionneront pas.  La création de ressources de sécurité basées sur l'aléatoire est un sujet distinct et très complexe, nous n'y allons donc pas. <br><br><img src="https://habrastorage.org/webt/1v/iw/s5/1viws5-axjes3hud4zigpabrxas.jpeg"><br><br>  <b>Public:</b> Donc, le canari contient moins de bits qu'une adresse de retour?  Parce que sinon, vous ne pourriez pas simplement vous souvenir de cette adresse et vérifier si elle a changé? <br><br>  <b>Professeur:</b> voyons.  Vous parlez de ce schéma lorsque le «canari» est situé au-dessus du tampon, et vous voulez dire que le système ne peut pas être sûr s'il est impossible de regarder l'adresse de retour et de vérifier si elle a été modifiée. <br><br><img src="https://habrastorage.org/webt/xg/nf/1m/xgnf1mj-jvjf1g1lu27xu7di4pm.jpeg"><br><br>  Oui et non.  Veuillez noter que si une attaque de dépassement de tampon se produit, tout ce qui se trouve au-dessus sera écrasé, donc cela peut toujours causer des problèmes.  Mais en gros, si ces choses étaient immuables d'une certaine manière, alors vous pourriez faire quelque chose comme ça.  Mais le problème est que dans de nombreux cas, la manipulation de l'adresse de retour est une chose plutôt compliquée.  Parce que vous pouvez imaginer qu'une fonction spéciale peut être appelée à partir de différents endroits, etc.  Dans ce cas, nous avons un peu d'avance, et s'il reste du temps à la fin de la conférence, nous y reviendrons. <br><br>  Ce sont des situations dans lesquelles un «canari» peut échouer.  Il existe d'autres endroits où l'échec est possible, par exemple, lors de l'attaque du <b>malloc</b> et <b>des</b> fonctions <b>libres</b> .  La fonction malloc alloue un bloc de mémoire d'une certaine taille en octets et renvoie un pointeur au début du bloc.  Le contenu du bloc de mémoire alloué n'est pas initialisé, il reste avec des valeurs non définies.  Et la fonction <b>libre</b> libère de la mémoire précédemment allouée dynamiquement. <br><br>  Il s'agit d'une attaque unique dans le style de C. Voyons ce qui se passe ici.  Imaginez que vous ayez ici deux pointeurs, p et q, pour lesquels nous utilisons <b>malloc pour</b> allouer 1.024 octets de mémoire à chacun de ces pointeurs.  Supposons que nous <b>créons la</b> fonction <b>strcpy</b> pour p à partir d'une sorte d'erreur de tampon contrôlée par un attaquant.  C'est là que le débordement se produit.  Et puis nous exécutons la commande <b>free q</b> et <b>free p</b> .  C'est du code assez simple, non? <br><br><img src="https://habrastorage.org/webt/dt/o7/rt/dto7rtltvhx7lcdnytlifp7cvzw.jpeg"><br><br>  Nous avons 2 pointeurs pour lesquels nous avons alloué de la mémoire, nous utilisons l'un d'eux pour une certaine fonction, un débordement de tampon se produit et nous libérons la mémoire des deux pointeurs. <br><br>  Supposons que les lignes de mémoire de p et q soient situées l'une à côté de l'autre dans l'espace mémoire.  Dans ce cas, de mauvaises choses peuvent arriver, non?  Parce que la fonction <b>strcpy</b> est utilisée pour copier le contenu de <b>str2</b> vers <b>str1</b> .  <b>Str2</b> doit être un pointeur sur une chaîne se terminant par zéro et <b>strcpy</b> renvoie un pointeur sur <b>str1</b> .  Si les lignes <b>str1</b> et <b>str2</b> se chevauchent, le comportement de la fonction <b>strcpy</b> n'est pas défini. <br><br>  Par conséquent, la fonction <b>strycpy</b> qui traite la mémoire <b>p</b> peut en même temps affecter la mémoire allouée à <b>q</b> .  Et cela peut causer des problèmes. <br><br>  Il est possible que vous ayez fait quelque chose comme ça dans votre propre code par inadvertance lorsque vous avez utilisé une sorte de type de pointeurs étranges.  Et tout semble fonctionner, mais lorsque vous devez appeler la fonction <b>gratuite</b> , une telle nuisance se produit.  Et un attaquant peut en profiter, je vais vous expliquer pourquoi cela se produit. <br><br>  Imaginez qu'à l'intérieur de l'implémentation des fonctions <b>free</b> et <b>malloc</b> , le bloc en surbrillance ressemble à ceci. <br><br>  Supposons qu'en haut du bloc, il y a des données d'application visibles, et en dessous, nous avons la taille de la variable.  Cette taille n'est pas celle que voit directement l'application, mais une sorte de «comptabilité» menée par <b>free</b> ou <b>malloc</b> , pour que vous connaissiez la taille du tampon mémoire alloué.  Un bloc libre est situé à côté du bloc en surbrillance.  Supposons qu'un bloc libre ait des métadonnées qui ressemblent à ceci: nous avons la taille du bloc au-dessus, il y a de l'espace libre en dessous, le pointeur arrière et le pointeur avant en dessous.  Et tout en bas du bloc, la taille est à nouveau affichée. <br><br><img src="https://habrastorage.org/webt/vx/q5/-w/vxq5-wfiisbatr5dzny9xaqd7vk.jpeg"><br><br>  Pourquoi avons-nous 2 pointeurs ici?  Parce que le système d'allocation de mémoire dans ce cas utilise une liste doublement liée pour suivre la façon dont les blocs libres sont liés les uns aux autres.  Par conséquent, lorsque vous sélectionnez un bloc libre, vous l'excluez de cette liste doublement liée.  Et puis, lorsque vous le libérez, vous allez faire de l'arithmétique pour le pointeur et mettre ces choses en ordre.  Après cela, vous l'ajoutez à cette liste chaînée, non? <br><br>  Chaque fois que vous entendez parler de l'arithmétique des pointeurs, vous devez penser que c'est votre «canari».  Parce qu'il y aura beaucoup de problèmes.  Permettez-moi de vous rappeler que nous avons eu un débordement de tampon <b>p</b> .  Si nous supposons que <b>p</b> et <b>q</b> sont côte à côte, ou très proches dans l'espace mémoire, il peut finalement arriver que ce débordement de tampon puisse écraser certaines données de taille pour le pointeur alloué <b>q</b> - c'est le bas de notre bloc alloué.  Si vous continuez à suivre ma pensée depuis le tout début, votre imagination vous dira où tout commence à mal tourner.  En effet, en substance, ce qui se passe finalement avec ces opérations est <b>free q</b> et <b>free p</b> - ils regardent ces métadonnées dans le bloc sélectionné pour faire toutes les manipulations nécessaires avec le pointeur. <br><br><img src="https://habrastorage.org/webt/an/mo/ug/anmouglu2dii_itv9qshxsu4qes.jpeg"><br><br>  Autrement dit, à un certain moment de l'exécution, les fonctions <b>libres</b> vont obtenir un certain pointeur basé sur la valeur de taille: <b>p = get.free.block (size)</b> , et la taille est ce que l'attaquant contrôle, car il a effectué un débordement de tampon, correctement ? <br><br>  Il a fait un tas de calculs arithmétiques, a regardé la fonction <b>arrière</b> et les pointeurs de ce bloc et va maintenant faire quelque chose comme mettre à jour les pointeurs «arrière» et «avant» - ce sont les deux dernières lignes. <br><br><img src="https://habrastorage.org/webt/bv/dt/x_/bvdtx_om6lkusoykjinpssiqro8.jpeg"><br><br>  Mais en réalité, cela ne devrait pas vous déranger.  Ceci est juste un exemple du code qui a lieu dans ce cas.  Mais le fait est qu'en raison de la taille réécrite par le pirate, il contrôle maintenant ce pointeur, qui passe par la fonction <b>libre</b> .  Et à cause de cela, les deux états ici dans les lignes de fond sont en fait des mises à jour de pointeur.  Et puisque l'attaquant a pu contrôler ce <b>p</b> , il contrôle en fait ces deux pointeurs.  C'est à cet endroit qu'une attaque peut se produire. <br><br>  Par conséquent, lorsque vous exécutez <b>gratuitement</b> et essayez de faire quelque chose comme combiner ces deux blocs, vous avez une liste doublement liée.  Parce que si vous avez deux blocs qui entrent en collision et que les deux sont gratuits, vous voulez les combiner en un seul gros bloc. <br><br>  Mais si nous contrôlons la taille, cela signifie que nous contrôlons l'ensemble du processus à partir des quatre lignes ci-dessus.  Cela signifie que si nous comprenons comment fonctionne le débordement, nous pouvons écrire des données dans la mémoire de la manière que nous choisissons.  Comme je l'ai dit, de telles choses se produisent souvent avec votre propre code, si vous n'êtes pas intelligent avec un pointeur.  Lorsque vous faites une double erreur libre comme <b>free q</b> et <b>free p</b> ou autre chose, votre fonction se bloque.  Parce que vous avez gâché les métadonnées qui vivent dans chacun de ces blocs sélectionnés, et à un moment donné, ce calcul indiquera une sorte de valeur «poubelle», après quoi vous serez «mort».  Mais si vous êtes un attaquant, vous pouvez choisir cette valeur et l'utiliser à votre avantage. <br><br>  Passons à une autre approche pour empêcher les attaques par débordement de tampon.  Cette approche consiste à vérifier les limites.  Le but de la vérification des limites est de s'assurer que lorsque vous utilisez un pointeur spécifique, il ne fera référence qu'à ce qui est un objet mémoire.  Et ce pointeur se trouve dans les limites autorisées de cet objet mémoire.  C'est l'idée principale de la vérification.       —   .  ,    C,      . ,      : ,         ,    ? <br><br>   ,        –    .      1024    ,         : <b>char  [1024]</b> , <b>char *y = &amp;  [108].</b> <br><br><img src="https://habrastorage.org/webt/ms/_z/bq/ms_zbqzotz_bt7ya9dpcfsuftxq.jpeg"><br><br>    ?    ?  C'est difficile à dire.       ,  ,     .      ,  ,   -    . <br>       - , ,      ,   .         .  ,    ,      ,   .  ,   ,      .     ,     ,    . <br><br>    ,     ,      <b>struct</b>   <b>union</b> . ,     .     :     <b>integer</b> ,   <b>struct</b> ,      <b>int</b> . <br><br>  ,  <b>union</b>  ,           .        ,    <b>integer</b>  ,   <b>struct</b> ,    . <br><br> ,     ,   -  : <b>int  p: &amp; (u,s,k)</b> ,      :  u,   s,  k. <br><br><img src="https://habrastorage.org/webt/rp/5p/ph/rp5pphcqpcdmmzhfs6tfy6yhtvg.jpeg"><br><br>  ,    ,    ,     ,    .     ,  ,  <b>union</b>   <b>integer</b> ,   <b>struct</b> .  ,       ,    ,           .      . <br><br>      <b>p'</b> ,     <b>p</b> ,   <b>p'</b>      ,    . <br><br><img src="https://habrastorage.org/webt/_j/hb/d1/_jhbd1twr0i0fex98ytm7bdzfu8.jpeg"><br><br> ,     ,       .          , ,   <b>union</b> .   ,   -    -        <b>union</b> , ,  ,      .        ,        ,   X. ,   ,      ,  ,    .   ,    ,   .        . <br><br>         ,        .      ,      <b>p</b>  <b>p'</b> ,     .        . <br><br>     ?        Electric fencing –  .    ,    ,     ,    ,      . <br><br><img src="https://habrastorage.org/webt/eg/c5/bp/egc5bpv_lhcf6c6vgy_i5z5_zgo.jpeg"><br><br>       ,    -    ,    .   ,      ,     .    ,   .       ,   ,        ,    . <br><br>   -     C  C++,    ,     ,      .      - ,  ,  -   .      ,    .    ,   «» —  ,          ,   ,     .    ,      ,       . <br><br>       ,         guard page – !  ,   . <br><br> 59:00  <br><br> : <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> MIT «  ».  2: «  »,  2</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/r4KjHEgg9Wg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  La version complète du cours est disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br> ,    .    ?  Vous voulez voir des matériaux plus intéressants?       , <b>30%        entry-level ,      :</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps  $20     ?</a> (   RAID1  RAID10,  24    40GB DDR4). <br><br> <b>Dell R730xd  2  ?</b>    <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2  Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100   $249</a>    !</b>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   .  c   Dell R730xd 5-2650 v4  9000   ?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416047/">https://habr.com/ru/post/fr416047/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416029/index.html">Ordinateur liquide: capture d'ions dans le graphène</a></li>
<li><a href="../fr416035/index.html">Scanner 3D dentaire Shining 3D Autoscan DS EX (Unboxing) by 3Dtool</a></li>
<li><a href="../fr416037/index.html">Démarrage de la journée (avril-juin 2018)</a></li>
<li><a href="../fr416043/index.html">Les pays en développement explorent de plus en plus l'espace.</a></li>
<li><a href="../fr416045/index.html">Onduleur en ligne APC Smart-UPS SRC1KI: la fiabilité avant tout</a></li>
<li><a href="../fr416049/index.html">Codec AV1 nouvelle génération: filtre de correction directionnelle CDEF</a></li>
<li><a href="../fr416051/index.html">Mitap d'été Apache Ignite à Moscou</a></li>
<li><a href="../fr416053/index.html">Modulation d'amplitude d'un signal arbitraire</a></li>
<li><a href="../fr416055/index.html">Affectation et prise en charge du nom de domaine complet du serveur 3QX</a></li>
<li><a href="../fr416059/index.html">Mobio s'entretient avec Daniil Shuleiko (Yandex.Taxi) sur la fusion avec Uber, le marché des taxis et la concurrence</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>