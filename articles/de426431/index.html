<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçüè≠ ‚åõÔ∏è üïµüèª Demontage der Qlie Visual Novel Engine üßñüèº ‚è≠Ô∏è ‚ùáÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eine Amateur√ºbersetzung von visuellen Kurzgeschichten hat im Vergleich zu √úbersetzungen anderer Spiele eine Reihe von Funktionen und beinhaltet die Ar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Demontage der Qlie Visual Novel Engine</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426431/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/bb/sq/zf/bbsqzfse3pqjvnyef8jnfv3lecy.png"></div><br><br>  Eine Amateur√ºbersetzung von visuellen Kurzgeschichten hat im Vergleich zu √úbersetzungen anderer Spiele eine Reihe von Funktionen und beinhaltet die Arbeit mit viel Text.  Vielleicht wurde die √ºberwiegende Mehrheit aller Bildromane auf Japanisch ver√∂ffentlicht, nur wenige wurden ins Englische √ºbersetzt (offiziell oder von Amateuren) und noch weniger wurden in andere Sprachen √ºbersetzt. <br><br>  Wenn Sie mit √úbersetzungen arbeiten, m√ºssen Sie sich daher mit japanischen Engines auseinandersetzen, von denen viele f√ºr Lokalisierer nicht sehr freundlich sind.  Aus diesem Grund wird schnell klar, dass das Vorhandensein von √úbersetzungsf√§higkeiten, Sprachkenntnissen, viel Enthusiasmus und Freizeit keineswegs bedeutet, dass die √ºbersetzte Version des Spiels bald das Licht der Welt erblicken wird. <br><a name="habracut"></a><br>  Sehr grob impliziert der Prozess der √úbersetzung eines Spiels (nicht nur visueller Kurzgeschichten): <br><br><ul><li>  Auspacken von Spielressourcen (falls diese nicht gemeinfrei sind) </li><li>  √úbersetzung der notwendigen Teile </li><li>  R√ºckverpackung √ºbertragen </li></ul><br>  Bei japanischen visuellen Kurzgeschichten sieht dies jedoch normalerweise so aus: <br><br><ul><li>  Spielressourcen auspacken </li><li>  √úbersetzung des Textteils des Spiels (Spieleskript) </li><li>  √úbersetzung des grafischen Teils des Spiels </li><li>  R√ºckverpackung √ºbertragen </li><li>  √Ñnderung der Engine, damit sie mit √ºbersetzten Inhalten funktioniert </li></ul><br>  Ich hoffe, unsere Erfahrung wird jemandem n√ºtzlich sein. <br><br>  Bereits 2013 (und m√∂glicherweise fr√ºher) habe ich mich entschlossen, den Bildroman Bishoujo Mangekyou-Norowareshi Densetsu no Shoujo aus dem Japanischen zu √ºbersetzen.  Ich hatte bereits Erfahrung mit dem √úbersetzen von Spielen, musste aber vorher nur Kurzgeschichten auf relativ einfachen und bekannten Engines wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kirikiri √ºbersetzen</a> . <br><br>  Hier musste unser √úbersetzerteam den Motor dieser Kurzgeschichte √∂ffnen, noch bevor wir zum eigentlichen Text gelangen. <br><br>  Beginnen wir mit einer Beschreibung der EXE-Datei, in der die W√∂rter QLIE und IMOSURUME erw√§hnt werden.  Die Datei selbst enth√§lt die Zeile FastMM Borland Edition 2004, 2005 Pierre le Riche, was bedeutet, dass die Engine h√∂chstwahrscheinlich in Delphi geschrieben ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kx/ss/sg/kxsssg_foyhzeykfu1e4s5pneok.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zo/ge/zc/zogezc8m47t1cflh-yqpzl85fby.png"></div><br>  Ein kurzes Googeln zeigt, dass Qlie der Name der von Warmth Entertainment ver√∂ffentlichten Visual Novel Engine ist.  Anscheinend ist IMOSURUME der interne Name der Skript-Engine und Qlie der kommerzielle Name.  Es gibt eine Website <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">qlie.net</a> , auf der die auf dieser Engine ver√∂ffentlichten Spiele und die offizielle Website von Warmth Entertainment <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufgelistet</a> sind. <br><br>  Nirgendwo im √∂ffentlichen Bereich gibt es jedoch weder offizielle Tools f√ºr die Arbeit mit der Engine noch eine Dokumentation daf√ºr, die erwartet wird. <br><br>  Daher m√ºssen Sie sich selbst mit dem Spiel befassen und sich auf inoffizielle Dienstprogramme verlassen.  Zun√§chst sollten Sie alle Teile des Spiels finden, die √ºbersetzt werden m√ºssen. <br><br>  Spielarchive befinden sich in den Dateien data0.pack, data1.pack und data7.pack im Unterordner \ GameData.  Die Bildschirmschoner befinden sich im Ordner \ GameData \ Movie, k√∂nnen jedoch weiterhin in Ruhe gelassen werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gr/fh/on/grfhont7xq1rascbvzu8v1mhkec.png"></div><br>  Der Hex-Editor zeigt an, dass es keine erkennbaren Header f√ºr Game .pack-Archive gibt, aber am Ende der Datei befindet sich ein Teil √§hnlich dem Inhaltsverzeichnis und der Bezeichnung FilePackVer3.0 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yf/qd/1q/yfqd1qyy7ozx0ygvq_bj_tmkms4.png"></div><br>  Gl√ºcklicherweise gibt es f√ºr dieses Format bereits einen Entpacker und nicht einmal einen.  Wir haben die Konsole exfp3_v3 von asmodean verwendet. <br><br>  Das Auspacken ist nicht so einfach, wie es scheint.  Da die Engine mehrere Archivformate unterst√ºtzt (FilePackVer1.0, FilePackVer1.0, FilePackVer3.0) und in diesem Fall FilePackVer3.0 verwendet wird, ben√∂tigen Sie zum ordnungsgem√§√üen Entpacken auch eine spezielle Schl√ºsseldatei key.fkey, die das Archiv verschl√ºsselt.  Es befindet sich im Unterordner \ Dll <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fa/fq/qe/fafqqeqgfwisqr1ijhg9qpcmsm4.png"></div><br>  Au√üerdem sollte exfp3_v3 das Archiv klarstellen, aus welchem ‚Äã‚ÄãSpiel es entpackt wird. <br>  Daher m√ºssen Sie auch die Spielnummer aus der vom Entpacker vorgeschlagenen Liste angeben (Spiele der Bishoujo Mangekyou-Serie finden Sie unter Nummer 15) oder die ausf√ºhrbare Datei des Spiels als dritten Parameter f√ºr den Entpacker angeben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9r/nr/-z/9rnr-zngqxajz8pysxwv3v8u8gk.png"></div><br>  Bereits nach dem Auspacken der Spieledateien kam ein logischer Gedanke auf: Wie kann man das Spiel in Zukunft mit einer fertigen √úbersetzung zur√ºckpacken?  Schlie√ülich unterst√ºtzt der Entpacker den umgekehrten Vorgang nicht. <br>  Auf unsere Anfrage hin hat w8m (vielen Dank daf√ºr) die M√∂glichkeit hinzugef√ºgt, Spielearchive in sein Programm arc_conv.exe zu packen.  Es reicht aus, alle ge√§nderten Dateien in ein neues Archiv (z. B. data8.pack) zu packen, es in den GameData-Ordner zu legen und sie ziehen sich automatisch ins Spiel. <br><br>  Zur√ºck zu den entpackten Ressourcen.  Spieleskriptdateien aus dem data0.pack-Archiv befinden sich im Unterordner \ Szenario \ ks_01 \ <br><br>  Alle Skriptdateien mit der Erweiterung .s sind weit entfernt von der bequemsten Shift Jis-Codierung codiert, und die Engine unterst√ºtzt keine Unicode-Codierungen.  Die Zeilen f√ºr die √úbersetzung sehen ungef√§hr so ‚Äã‚Äãaus: <br><br><pre><code class="python hljs">„Äê„Ç≠„É™„Ç®„Äë ÔºÖ<span class="hljs-number"><span class="hljs-number">1</span></span>_kiri1478ÔºÖ „Äå„Å∏„Åà‚Ä¶‚Ä¶ÂàÜ„Åã„Å£„Å¶„ÅÑ„Çã„Åò„ÇÉ„Å™„ÅÑ„Äç ÁßÅ„ÅåÁåÆ‰∏ä„Åó„Åü„É≠„Ç∑„Ç¢„É≥„ÉÜ„Ç£„Éº„ÇíË¶ã„Å¶„ÄÅ„Ç≠„É™„Ç®„ÅØÂ¨â„Åó„Åù„ÅÜ„Å´ÁõÆ„ÇíÁ¥∞„ÇÅ„Çã„ÄÇ ^cface,,Ëµ§ÁõÆÂæÆÁ¨ë<span class="hljs-number"><span class="hljs-number">01</span></span> „Äê„Ç≠„É™„Ç®„Äë ÔºÖ<span class="hljs-number"><span class="hljs-number">1</span></span>_kiri1479ÔºÖ „ÄåÊó•Êú¨‰∫∫„ÅØ„ÄÅ„Ç∏„É£„É†„ÇíÁ¥ÖËå∂„Å´ÂÖ•„Çå„Å¶È£≤„ÇÄ„ÅÆ„Åå„ÄÅ„É≠„Ç∑„Ç¢„É≥„ÉÜ„Ç£„Éº„Å†„Å®ÂãòÈÅï„ÅÑ„Åó„Å¶„ÅÑ„Çã‰∫∫„ÅåÂ§ö„ÅÑ„ÅÆ„Å†„Åë„Çå„Å©‚Ä¶‚Ä¶„Äç</code> </pre> <br>  M√∂glicherweise stellen Sie fest, dass vor jeder japanischen Phrase der Name des Helden in japanischen Klammern steht.  („Äê„Äë), Der diese Phrase ausspricht (im Spiel wird sie oben im Fenster mit Text angezeigt).  Wenn dies die W√∂rter des Autors sind, wird der Name nicht hinzugef√ºgt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ws/d_/dz/wsd_dzwzrz-sjk_0shl7zw3ov5k.png"></div><br>  Aber es gibt immer noch Serviceteams. <br><br>  Die Engine-Befehle im Skript erinnern etwas an die TeX-Markup-Sprache, sind jedoch im Vergleich zu den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kirikiri</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RenPy-Befehlen</a> viel intuitiver und unpraktischer. <br><br>  Hier sind einige davon: <br><br>  <code>@@@</code> ist ein dreifacher Hund.  Oft beginnen Skriptdateien mit diesem Befehl.  Anscheinend werden Definitionen aus Dateien von Drittanbietern geladen. <br><br>  Zum Beispiel: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@@@Library\Avg\header.s</span></span></code> </pre> <br>  <code>@@</code> ist ein Doppelhund.  Die Bezeichnung in der Skriptdatei.  Sie k√∂nnen sp√§ter darauf umsteigen. <br><br>  <code>ÔºÖ1_kiri1478ÔºÖ</code> - Spielen Sie die Sprachdatei ab.  Diese Befehle werden zwischen dem Namen des Helden und dem auf dem Bildschirm angezeigten Text eingef√ºgt.  "1_kiri1478" - in diesem Fall der Name der Datei aus dem Ordner \ voice \ der Datei data1.pack Es ist interessant, dass das Team den japanischen Prozentsatz (ÔºÖ) anstelle des √ºblichen verwendet. <br><br>  <code>^savedate, ^saveroute, ^savescene,</code> - drei Teams, die h√∂chstwahrscheinlich im Speichersystem des Spiels verwendet werden und Informationen √ºber den Ort und die Zeit eingeben sollten, zu der der Spieler im Speicherspiel gespeichert wurde. <br><br>  Zum Beispiel: <br><br><pre> <code class="python hljs">^savedate,<span class="hljs-string"><span class="hljs-string">"ÁèæÂú®"</span></span> ^saveroute,<span class="hljs-string"><span class="hljs-string">"ÁæéÂ∞ëÂ•≥‰∏áËèØÈè°ÔºçÔºëÔºç"</span></span> ^savescene,<span class="hljs-string"><span class="hljs-string">"Âë™„Çè„Çå„Åó‰ºùË™¨„ÅÆÂ∞ëÂ•≥ „Ç™„Éº„Éó„Éã„É≥„Ç∞"</span></span></code> </pre> <br>  Das hei√üt, Datum: Gegenwart, Zweig: Bishoujo Mangekyou -1-, Szene: Norowareshi Densetsu no Shoujo Er√∂ffnung.  Diese Daten sollten im Speicherbereich angezeigt werden, aber anscheinend haben die Entwickler beschlossen, sie aufzugeben.  Infolgedessen ist <code>^saveroute</code> in allen Teilen des Skripts gleich, <code>^savedate</code> √Ñnderungen von "dem gegenw√§rtigen Moment" zu "Tr√§umen" und <code>^savescene</code> in <code>^savescene</code> Tage (oder vielmehr N√§chte) im Spiel. <br><br>  <code>^facewindow,</code> - Status des Textfelds mit dem auf dem Bildschirm angezeigten Text.  (Gezeigt - 1 oder nicht - 0) <br><br>  <code>^sload,</code> - Spielen Sie Sounds im Spiel aus dem Ordner \ sound \ auf dem entsprechenden Kanal ab. <br><br><pre> <code class="python hljs">sload,Env1,‚óÜ„Çª„Éü<span class="hljs-number"><span class="hljs-number">01</span></span>„Ç¢„Éñ„É©„Çº„Éü</code> </pre> <br>  Zikaden auf Env1 spielen <br><br>  Das Team hat zwei optionale Parameter, der erste ist f√ºr das Schleifen des Sounds verantwortlich, und der zweite bleibt ein R√§tsel, wird aber im Spiel selten verwendet. <br><br><pre> <code class="python hljs">^sload,SE1,‚ñ†„ÇØ„ÉÅ„É•Èü≥<span class="hljs-number"><span class="hljs-number">01</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Wiedergabe von Loopback-Sound auf Kanal SE1. <br><br>  <code>^eeffect</code> - <code>^eeffect</code> f√ºr eine bestimmte Anzahl von Sekunden einen Spezialeffekt auf dem Bildschirm an.  Anscheinend unterst√ºtzt es die sequentielle Ausgabe mehrerer Effekte. <br><br><pre> <code class="python hljs">^eeffect,WhiteFlash</code> </pre> <br>  Die Wirkung eines wei√üen Blitzes. <br><br>  <code>^ffade</code> - √úbergangseffekt beim √Ñndern des Bildschirms. <br>  Es enth√§lt eine ganze Reihe zus√§tzlicher Parameter, aber nur wenige sind wirklich n√ºtzlich: der Name des √úbergangseffekts, gegebenenfalls ein zus√§tzliches Bild und die Abschlussabschlusszeit. <br><br><pre> <code class="python hljs">^ffade,Overlap,,<span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre> <br>  Ein Bild in einem anderen in 1 Sekunde aufl√∂sen. <br><br>  <code>^iload</code> - l√§dt das Hintergrundbild auf den Bildschirm.  Dem Bild kann eine ID zugewiesen werden, auf die in Zukunft verwiesen werden soll. <br><br><pre> <code class="python hljs">^iload,BG1,<span class="hljs-number"><span class="hljs-number">0</span></span>_black.png</code> </pre> <br>  Ausgabedatei 0_black.png als Hintergrund mit der ID BG1 <br><br>  <code>^we</code> und <code>^wd</code> - schalten das Bild im Fenster ein und aus. <br><br>  <code>^facewindow,1</code> und <code>^facewindow,0</code> das Heldenbild im Dialogfeld ein und aus. <br><br>  <code>^mload</code> - Musik auf einem bestimmten Kanal abspielen. <br><br><pre> <code class="python hljs">^mload,BGM1,nbgm13</code> </pre> <br>  Titel nbgm13 auf Kanal BGM1 abspielen <br><br>  Einige der wichtigsten Teams: <br>  <code>\jmp</code> - Springe zum Label mit dem angegebenen Namen. <br><br>  <code>^select</code> - Zeigt das Auswahlfenster auf dem Bildschirm an, in dem der Spieler eine der Optionen ausw√§hlen muss. <br><br>  Zum Beispiel: <br><br><pre> <code class="python hljs">^select, ,  \jmp,<span class="hljs-string"><span class="hljs-string">"@@route01a"</span></span>+ResultBtnInt[<span class="hljs-number"><span class="hljs-number">0</span></span>] @@route01a0</code> </pre> <br>  Hier wird der √úbergang nach der Antwort auf die Frage durchgef√ºhrt und die Antwortnummer (0 oder 1) von ResultBtnInt [0] zur√ºckgegeben.  Infolgedessen verschiebt <code>\jmp</code> die Story auf das Label @@ route01a + Antwortnummer.  Das hei√üt, @@ route01a0 oder @@ route01a1 <br><br>  Eine unangenehme Eigenschaft ist, dass das √ºbliche Komma in diesen Befehlen als Trennzeichen dient und nicht in den Antwortoptionen selbst verwendet werden kann.  Die Japaner haben kein solches Problem, sie verwenden das japanische Komma („ÄÅ).  In diesem Fall k√∂nnen wir das Komma durch ‚Äöersetzen (U + 201A SINGLE LOW-9 QUOTATION MARK). <br><br>  Zum Beispiel: <br><br><pre> <code class="python hljs">^select, ‚Äö  , ‚Äö </code> </pre> <br>  Die verbleibenden Teams sind in erster N√§herung nicht so wichtig. <br><br>  Bevor Sie das Skript √ºbersetzen, sollten Sie es nat√ºrlich in etwas Bequemeres umcodieren, z. B. in UTF-8, um kyrillische und japanische Zeichen zu kombinieren. <br><br>  Nach dem √Ñndern der Engine (zu diesem n√§chsten Teil) erkennt das Spiel sowohl den russischen als auch den japanischen Text.  Aus Kompatibilit√§tsgr√ºnden m√ºssen Sie jedoch japanische Zeichen in Shift Jis und kyrillische Zeichen in cp1251-Codierung codieren. <br><br>  Wir haben in Python schnell ein Programm zum Transcodieren unter Ber√ºcksichtigung des kyrillischen Alphabets entworfen: <br><br><div class="spoiler">  <b class="spoiler_title">UTF8 bis cp1251 und ShiftJIS</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- # UTF8 to cp1251 and ShiftJIS recoder # by Chtobi and Nazon, 2016 import codecs import argparse from os import path JAPANESE_CODEPAGE = 'shift_jis' UTF_CODEPAGE = 'utf-8' RUS_CODEPAGE = 'cp1251' def nonrus_handler(e): if e.object[e.start:e.end] == 'ÔΩû': # UTF-8: 0xEFBD9E -&gt; SHIFT-JIS: 0x8160 japstr_byte = b'\x81\x60' elif e.object[e.start:e.end] == 'Ôºç': # UTF-8: 0xEFBC8D -&gt; SHIFT-JIS: 0x817C japstr_byte = b'\x81\x7c' else: japstr_byte = (e.object[e.start:e.end]).encode(JAPANESE_CODEPAGE) return japstr_byte, e.end if __name__ == '__main__': arg_parser = argparse.ArgumentParser(prog="Recode to cp1251 and ShiftJIS", description="Program to encode UTF8 text file to " "cp1251 for all cyrillic symbols and ShiftJIS for others. " "Output file will be inputfilename.s", usage="recode_to_cp1251_shiftjis.py file_name") arg_parser.add_argument('file_name', nargs=1, type=argparse.FileType(mode='r', bufsize=-1), help="Input text file name. Only files coded in UTF8 are allowed.\n") codecs.register_error('nonrus_handler', nonrus_handler) input_name = arg_parser.parse_args().file_name[0].name output_name = path.splitext(input_name)[0] + ".s" with open(input_name, 'rt', encoding=UTF_CODEPAGE) as input_file: with open(output_name, 'wb') as output_file: for line in input_file: for char1 in line: bytes_out = bytes(line, UTF_CODEPAGE) output_file.write(char1.encode(RUS_CODEPAGE, "nonrus_handler")) print("Done.")</span></span></code> </pre><br></div></div><br>  Es gab jedoch einige Probleme.  Das Programm hat beim Versuch, das "Tilde" -Symbol ÔΩû (U + FF5E FULLWIDTH TILDE) neu zu codieren, den Fehler "UnicodeEncodeError: 'Shift Jis'-Codec kann das Zeichen' \ uff5e 'in Position 0: unzul√§ssige Multibyte-Sequenz nicht codieren" generiert. <br><br>  Zuerst habe ich auf Python ges√ºndigt, aber am Ende habe ich eine ziemlich ungew√∂hnliche Nuance herausgefunden.  Abh√§ngig von der spezifischen Implementierung besteht eine Unsicherheit zwischen den Korrelationsmethoden f√ºr japanische Unicode- und Nicht-Unicode-Codierungen. <br><br>  Infolgedessen ordnet Windows das Shift Jis-Zeichen dem 0x8160-Code dem Unicode ÔΩû (U + FF5E FULLWIDTH TILDE) zu, und andere Transcoder (z. B. das Dienstprogramm iconv) korrelieren dasselbe Zeichen mit „Äú (U + 301C WAVE DASH) gem√§√ü der offiziellen Unicode-Verh√§ltnis-Tabelle - <a href="">ftp://ftp.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/JIS/SHIFT JIS.TXT</a> <br><br>  Um die Entsprechung zwischen den Zeichen zu bestimmen, hat Microsoft offenbar beschlossen, die Schemata aus ihrer cp932-Codierung zu verwenden, bei der es sich um eine erweiterte Version von Shift Jis handelt. <br><br>  Die gleiche Situation tritt mit dem Zeichencode 0x817C auf, der in UTF8 unter Windows als - (U + FF0D FULLWIDTH HYPHEN-MINUS) oder in iconv als - (U + 2212 MINUS SIGN) codiert ist. <br><br>  Da alle Skriptdateien zuerst mit Notepad ++ von Shift Jis nach UTF8 konvertiert wurden (und er die in Windows verwendete Korrespondenztabelle verwendet), trat beim Zur√ºckkonvertieren von UTF8 nach Shift Jis √ºber unser Python-Programm der ber√ºchtigte Konvertierungsfehler auf. <br><br>  Daher war es notwendig, das Auftreten von ÔΩû und - getrennten Bedingungen zu ber√ºcksichtigen. <br><br>  Es gab andere kleinere M√§ngel - zum Beispiel wurde die Ellipse ... (U + 2026 HORIZONTAL ELLIPSIS) durch die kyrillische Ellipse von cp1251 ersetzt und nicht die Japaner von Shift Jis. <br><br>  Nachdem Sie den Text √ºbersetzt haben, k√∂nnen Sie mit der Spielgrafik fortfahren. <br><br>  Grafikdateien des Spiels befinden sich in denselben Packarchiven, aber nach dem Entpacken m√ºssen sie noch hart arbeiten.  Beispielsweise werden fast alle PNG-Bilder als Dateien vom Typ sample + DPNG000 + x32y0.png entpackt. Mit anderen Worten, PNG-Bilder werden in horizontale Streifen mit einer Dicke von 88 cm geschnitten und jeder Streifen wird in eine separate Datei geschrieben.  Der Dateiname zeigt die Seriennummer des Streifens (DPNG000 ... 009) und die x, y-Koordinaten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gj/ak/x_/gjakx_76ep3syu_gf9qfobolmj8.png"></div><br>  Ich frage mich immer noch, warum das notwendig war.  Wenn es schwierig ist, Ressourcen aus dem Spiel zu entfernen, ist dies eindeutig nicht die beste Methode. <br><br>  Um die geschnittenen PNG-Dateien zu kleben, wurde gleichzeitig ein kleines Skript merge_dpng auf Pearl von asmodeus erstellt, das ImageMagick verwendet.  Leider gab es Probleme mit ihm.  Erstens brauchte ich Pearl, das ich nicht benutzte, und selbst nach der Installation stellte sich heraus, dass das Skript nicht richtig funktionierte. <br><br>  Aus diesem Grund haben wir ein √§hnliches Programm in Python geschrieben: <br><br><div class="spoiler">  <b class="spoiler_title">Qlie Engine dpng Dateien zusammenf√ºhren</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- # Qlie engine dpng files merger # by Chtobi and Nazon, 2016 # Requires ImageMagick magick.exe on the path. import os import glob import re import argparse import subprocess IMGMAGIC = os.path.dirname(os.path.abspath(__file__)) + '\\' + 'magick.exe' IMGMAGIC_PARAMS1 = ['-background', 'rgba(0,0,0,0)'] IMGMAGIC_PARAMS2 = ['-mosaic'] INPUT_FILES_MASK = '*+DPNG[0-9][0-9][0-9]+*.png' SPLIT_MASK = '+DPNG' x_y_ajusts_re = re.compile('(.+)\+DPNG[0-9][0-9][0-9]\+x(\d+)y(\d+)\.') if __name__ == '__main__': arg_parser = argparse.ArgumentParser(prog="DPNG Merger\n" "Program to merge sliced png files from QLIE engine. " "All files with mask *+DPNG[0-9][0-9][0-9]+*.png" "into the input directory will be merged and copied to the" "output directory.\n", usage="connect_png.py input_dir [output_dir]\n") arg_parser.add_argument("input_dir_param", nargs=1, help="Full path to the input directory.\n") arg_parser.add_argument("output_dir_param", nargs='?', default=os.path.dirname(os.path.abspath(__file__)), help="Full path to the output directory. " "It would be a script parent directory if not specified.\n") input_dir = arg_parser.parse_args().input_dir_param[0] output_dir = arg_parser.parse_args().output_dir_param[0] os.chdir(input_dir) all_append_files = glob.glob(INPUT_FILES_MASK) # Select only files with DPNG prep_bunches = [] for file_in_dir in all_append_files: # Check all files and put all splices that should be connected in separate list for num, bunch in enumerate(prep_bunches): name_first_part = bunch[0].partition(SPLIT_MASK)[0] # Part of the filename before +DPNG should be unique if name_first_part == file_in_dir.partition(SPLIT_MASK)[0]: prep_bunches[num].append(file_in_dir) break else: prep_bunches.append([file_in_dir]) os.chdir(os.path.dirname(os.path.abspath(__file__))) # Go to the script parent dir for prepared_bunch in prep_bunches: sorted_bunch = sorted(prepared_bunch) # Prepare -page params for imgmagic png_pages_params = [["(", "-page", "+{0}+{1}".format(*[(x_y_ajusts_re.match(part_file).group(2)), x_y_ajusts_re.match(part_file).group(3)]), input_dir+part_file, ")"] for part_file in sorted_bunch] connect_png_list = \ [imgmagick_page for imgmagick_pages in png_pages_params for imgmagick_page in imgmagick_pages] output_file = output_dir + sorted_bunch[0].partition(SPLIT_MASK)[0] + ".png" subprocess.check_output([IMGMAGIC] + IMGMAGIC_PARAMS1 + connect_png_list + IMGMAGIC_PARAMS2 + [output_file])</span></span></code> </pre> <br></div></div><br>  Es scheint, dass wir jetzt die ganze Reihe von Bildern haben, die im Spiel erscheinen?  √úberhaupt nicht - wenn Sie sich alle verbundenen Bilder aus allen Archiven ansehen, werden Sie immer noch feststellen, dass einige fehlen, obwohl sie im Spiel sind.  Tatsache ist, dass es in der Engine einen anderen Dateityp gibt - mit der Erweiterung .b.  Es ist eine Art Animation mit darin aufgenommenen Bildern und T√∂nen. <br><br>  Es ist ziemlich einfach, die Ressourcen darin zu speichern, aber leider hat in unserem Fall keiner der vorgefertigten .b-Datei-Entpacker so funktioniert, wie es sollte.  Entweder blieben einige Dateien entpackt, oder es gab Fehler aufgrund japanischer Namen, und ich wollte nicht vom japanischen Gebietsschema booten. <br><br>  Hier noch eines war unser Skript n√ºtzlich.  Seitdem waren wir mit so etwas wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kaitai Struct</a> nicht vertraut, wir mussten fast von Grund auf neu handeln. <br><br>  Das Format der .b-Dateien erwies sich als einfach, und au√üerdem musste unser Entpacker nur Ressourcen aus diesem Spiel entpacken k√∂nnen.  In anderen Spielen der Qlie-Engine wurden zus√§tzliche Arten von Ressourcen in .b-Dateien angezeigt, auf die wir jedoch nicht n√§her eingehen werden. <br><br>  √ñffnen Sie also eine beliebige .b-Datei in einem Hex-Editor und schauen Sie zum Anfang.  Beachten Sie vor der Auswertung, dass die Bytereihenfolge aller numerischen Werte Little-Endian ist. <br><br><ul><li>  Abmp12-Dateikopf </li><li>  Zehn Bytes 0x00 </li><li>  Der Titel des ersten Abschnitts abdata12 mit Overhead-Informationen. </li><li>  Acht Bytes 0x00 </li><li>  Abschnittsgr√∂√üe abdata12, 4-Byte-Ganzzahl.  Sie k√∂nnen es sicher √ºberspringen. </li><li>  Abimage10 Abschnitts√ºberschrift </li><li>  Sieben Bytes 0x00 </li><li>  Anzahl der Dateien in einem Abschnitt, Einzelbyte-Ganzzahl.  In diesem Fall befindet sich eine Datei im Abschnitt. </li><li>  Abschnitts√ºberschrift abgimgdat13 </li><li>  Sechs Bytes 0x00 </li><li>  Die L√§nge des Dateinamens innerhalb des Abschnitts, eine Zwei-Byte-Ganzzahl.  In diesem Fall betr√§gt die L√§nge 4 Bytes. </li><li>  Shift Jis codierter Dateiname </li><li>  Datensatzl√§nge der Dateipr√ºfsumme, Doppelbyte-Ganzzahl. </li><li>  Die Pr√ºfsumme der Datei selbst. </li><li>  Das unbekannte Byte scheint immer 0x03 oder 0x02 zu sein </li><li>  Zw√∂lf unbekannte Bytes, m√∂glicherweise im Zusammenhang mit Animation </li><li>  Die Gr√∂√üe der PNG-Datei innerhalb des Abschnitts ist eine 4-Byte-Ganzzahl. </li></ul><br>  Und schlie√ülich die PNG-Datei selbst. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/64/v4/yc/64v4ycd37hyu-pyqsxyb2g1ahqa.png"></div><br>  Der Absoundabschnitt ist in seiner Struktur dem Abimage √§hnlich. <br><br><div class="spoiler">  <b class="spoiler_title">AnimatedBMP-Extraktor</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- # Extract b # AnimatedBMP extractor for Bishoujo Mangekyou game files # by Chtobi and Nazon, 2016 import glob import os import struct import argparse from collections import namedtuple b_hdr = b'abmp12'+bytes(10) signa_len = 16 b_abdata = (b'abdata10'+bytes(8), b'abdata11'+bytes(8), b'abdata12'+bytes(8), b'abdata13'+bytes(8)) b_imgdat = (b'abimgdat10'+bytes(6), b'abimgdat11'+bytes(6), b'abimgdat14'+bytes(6)) b_img = (b'abimage10'+bytes(7), b'abimage11'+bytes(7), b'abimage12'+bytes(7), b'abimage13'+bytes(7), b'abimage14'+bytes(7)) b_sound = (b'absound10'+bytes(7), b'absound11'+bytes(7), b'absound12'+bytes(7)) # not sure about structure of sound11 and sound12 b_snd = (b'absnddat11'+bytes(7), b'absnddat10'+bytes(7), b'absnddat12'+bytes(7)) Abimgdat13_pattern = namedtuple('Abimgdat13', ['signa', 'name_size_len', 'hash_size_len', 'unknown1_len', 'unknown2_len', 'data_size_len']) Abimgdat13 = Abimgdat13_pattern(signa=b'abimgdat13'+bytes(6), name_size_len=2, hash_size_len=2, unknown1_len=1, unknown2_len=12, data_size_len=4) Abimgdat14_pattern = namedtuple('Abimgdat14', ['signa', 'name_size_len', 'hash_size_len', 'unknown1_len', 'data_size_len']) Abimgdat14 = Abimgdat14_pattern(signa=b'abimgdat14'+bytes(6), name_size_len=2, hash_size_len=2, unknown1_len=77, data_size_len=4) Abimgdat_pattern = namedtuple('Abimgdat', ['name_size_len', 'hash_size_len', 'unknown1_len', 'data_size_len']) # probably, abimgdat10,abimgdat11 and others Other_imgdat = Abimgdat_pattern(name_size_len=2, hash_size_len=2, unknown1_len=1, data_size_len=4) Absnddat11_pattern = namedtuple('Absnddat11', ['signa', 'name_size_len', 'hash_size_len', 'unknown1_len', 'data_size_len']) Absnddat11 = Absnddat11_pattern(signa=b'absnddat11'+bytes(7), name_size_len=2, hash_size_len=2, unknown1_len=1, data_size_len=4) def create_parser(): arg_parser = argparse.ArgumentParser(prog='AnimatedBMP extractor\n', usage='extract_b input_file_name output_dir\n', description='AnimatedBMP extractor for QLIE engine *.b files.\n') arg_parser.add_argument('input_file_name', nargs='+', help="Input file with full path(wildcards are supported).\n") arg_parser.add_argument('output_dir', nargs=1, help="Output directory.\n") return arg_parser def check_type(file_buf): if file_buf.startswith(b'\x89' + b'PNG'): return '.png' elif file_buf.startswith(b'BM'): return '.bmp' elif file_buf.startswith(b'JFIF', 6): return '.jpg' elif file_buf.startswith(b'IMOAVI'): return '.imoavi' elif file_buf.startswith(b'OggS'): return '.ogg' elif file_buf.startswith(b'RIFF'): return '.wav' else: return '' def bytes_shiftjis_to_utf8(shiftjis_bytes): shiftjis_str = shiftjis_bytes.decode('shift_jis', 'strict') utf_str = shiftjis_str.encode('utf-8', 'strict').decode('utf-8', 'strict') return utf_str def check_signa(f_buffer): if f_buffer.endswith(b_abdata): return 'abdata' elif f_buffer.endswith(b_img): return 'abimgdat' elif f_buffer.endswith(b_sound): return 'absound' def prepare_filename(out_file_name, out_dir, postfix=''): ready_name = out_dir + os.path.basename(out_file_name) + postfix return ready_name def create_file(file_name_hndl, out_buffer): if len(out_buffer) != 0: with open(file_name_hndl, 'wb') as ext_file: ext_file.write(out_buffer) else: print("Zero file. Skipped.") def check_file_header(file_handle, bytes_num): file_handle.seek(0) readed_bytes = file_handle.read(bytes_num) if readed_bytes == b_hdr: print("File is valid abmp") return True else: print("Can't read header. Probably, wrong file...") return False if __name__ == '__main__': parser = create_parser() arguments = parser.parse_args() all_b_files = glob.glob(arguments.input_file_name[0]) output_dir = arguments.output_dir[0] for b_file in all_b_files: file_buffer = bytearray(b'') with open(b_file, 'rb') as bfile_h: check_file_header(bfile_h, len(b_hdr)) read_byte = bfile_h.read(1) file_buffer.extend(read_byte) while read_byte: read_byte = bfile_h.read(1) file_buffer.extend(read_byte) # Finding content sections signature check_result = check_signa(file_buffer) if check_result: if check_result == 'abdata': file_buffer = bytearray(b'') read_length = bfile_h.read(4) size = struct.unpack('&lt;L', read_length)[0] file_buffer.extend(bfile_h.read(size)) # Adding _abdata to separate from other parts outfile_name = prepare_filename(b_file, output_dir, '_abdata') create_file(outfile_name, file_buffer) elif check_result == 'abimgdat': images_number = struct.unpack('B', bfile_h.read(1))[0] # Number of pictures in section for i1 in range(images_number): file_buffer = bytearray(b'') file_name = '' imgsec_hdr = bfile_h.read(signa_len) if imgsec_hdr == Abimgdat13.signa: file_name_size = struct.unpack('&lt;H', bfile_h.read(Abimgdat13.name_size_len))[0] # Decode filename to utf8 file_name = bytes_shiftjis_to_utf8(bfile_h.read(file_name_size)) # CRC size hash_size = struct.unpack('&lt;H', bfile_h.read(Abimgdat13.hash_size_len))[0] # Picture CRC (don't need it) pic_hash = bfile_h.read(hash_size) unknown1 = bfile_h.read(Abimgdat13.unknown1_len) unknown2 = bfile_h.read(Abimgdat13.unknown2_len) pic_size = struct.unpack('&lt;L', bfile_h.read(Abimgdat13.data_size_len))[0] print("pic_size:", pic_size) file_buffer.extend(bfile_h.read(pic_size)) elif imgsec_hdr == Abimgdat14.signa: file_name_size = struct.unpack('&lt;H', bfile_h.read(Abimgdat14.name_size_len))[0] file_name = bytes_shiftjis_to_utf8(bfile_h.read(file_name_size)) hash_size = struct.unpack('&lt;H', bfile_h.read(Abimgdat14.hash_size_len))[0] pic_hash = bfile_h.read(hash_size) bfile_h.seek(Abimgdat14.unknown1_len, os.SEEK_CUR) pic_size = struct.unpack('&lt;L', bfile_h.read(Abimgdat14.data_size_len))[0] file_buffer.extend(bfile_h.read(pic_size)) else: # probably abimgdat10, abimgdat11... file_name_size = struct.unpack('&lt;H', bfile_h.read(Other_imgdat.name_size_len))[0] file_name = bytes_shiftjis_to_utf8(bfile_h.read(file_name_size)) hash_size = struct.unpack('&lt;H', bfile_h.read(Other_imgdat.hash_size_len))[0] pic_hash = bfile_h.read(hash_size) bfile_h.seek(Other_imgdat.unknown1_len, os.SEEK_CUR) pic_size = struct.unpack('&lt;L', bfile_h.read(Other_imgdat.data_size_len))[0] file_buffer.extend(bfile_h.read(pic_size)) for i, letter in enumerate(file_name): # Replace any unusable symbols from filename with _ if letter == '&lt;' or letter == '&gt;' or letter == '*' or letter == '/': file_name = file_name.replace(letter, "_") # Checking file signature and adding proper extension outfile_name = prepare_filename(b_file, output_dir, '_' + file_name + check_type(file_buffer)) create_file(outfile_name, file_buffer) file_buffer = bytearray(b'') elif check_result == 'absound': sound_files_number = struct.unpack('B', bfile_h.read(1))[0] for i2 in range(sound_files_number): file_buffer = bytearray(b'') file_name = '' sndsec_hdr = bfile_h.read(signa_len) if sndsec_hdr == Absnddat11.signa: file_name_size = struct.unpack('&lt;H', bfile_h.read(Absnddat11.name_size_len))[0] file_name = bytes_shiftjis_to_utf8(bfile_h.read(file_name_size)) hash_size = struct.unpack('&lt;H', bfile_h.read(Absnddat11.hash_size_len))[0] snd_hash = bfile_h.read(hash_size) unknown1 = bfile_h.read(Absnddat11.unknown1_len) snd_size = struct.unpack('&lt;L', bfile_h.read(Absnddat11.data_size_len))[0] file_buffer.extend(bfile_h.read(snd_size)) else: file_name_size = struct.unpack('&lt;H', bfile_h.read(Absnddat11.name_size_len))[0] file_name = bytes_shiftjis_to_utf8(bfile_h.read(file_name_size)) hash_size = struct.unpack('&lt;H', bfile_h.read(Absnddat11.hash_size_len))[0] snd_hash = bfile_h.read(hash_size) unknown1 = bfile_h.read(Absnddat11.unknown1_len) snd_size = struct.unpack('&lt;L', bfile_h.read(Absnddat11.data_size_len))[0] file_buffer.extend(bfile_h.read(snd_size)) for i, letter in enumerate(file_name): if letter == '&lt;' or letter == '&gt;' or letter == '*' or letter == '/': file_name[i] = '_' outfile_name = prepare_filename(b_file, output_dir, '_' + file_name + check_type(file_buffer)) print("create absound") create_file(outfile_name, file_buffer) file_buffer = bytearray(b'')</span></span></code> </pre><br></div></div><br>  Das Skript sollte die gefundenen PNG-, JPG-, BMP-, Ogg- und WAV-Dateien automatisch entpacken.  Daneben befinden sich aber auch unbekannte Imoavi-Dateien im Inneren. <br><br>  Das Fazit ist, dass im Spiel alle Animationen entweder als vollwertiges Video im ogv-Format oder als motoranimierte Bilder, die in .b-Dateien aufgezeichnet werden, oder als animierte Sequenzen von jpg-Dateien im imoavi-Format erstellt werden. <br><br>  In diesem Fall waren wir auch an JPG-Bildern interessiert, also mussten wir uns auch damit befassen. <br><br>  Es gibt zwei Abschnitte in imoavi: SOUND und MOVIE.  Im Abschnitt FILM, 47 Bytes nach dem Header, befinden sich vier Bytes der JPG-Dateigr√∂√üe.  Dateien werden nacheinander in ihrer urspr√ºnglichen Form geschrieben, getrennt durch eine Folge von 19 Bytes, wobei die Gr√∂√üe der n√§chsten Datei aufgezeichnet wird. <br><br>  Das stimmhafte Imoavi im Spiel ist nicht aufgetaucht, daher ist der SOUND-Bereich immer leer. <br><br>  Nun, da wir angefangen haben, alle Ressourcen des Spiels herauszuholen, wurde gleichzeitig ein kleines Skript geschrieben, um jpg aus imoavi herauszuholen. <br><br><div class="spoiler">  <b class="spoiler_title">Imoavi Extraktor</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- # Extract imoavi # Imoavi extractor for Bishoujo Mangekyou game files # by Chtobi and Nazon, 2016 import glob import os import struct import argparse imoavi_hdr = b'IMOAVI' hdr_len = len(imoavi_hdr) def create_file(file_name, out_buffer, wr_mode='wb'): if len(out_buffer) != 0: with open(file_name, wr_mode) as ext_file: ext_file.write(out_buffer) else: print("Zero file. Skipped.") def prepare_filename(file_name, out_dir, postfix=''): ready_name = out_dir + os.path.basename(file_name) + postfix return ready_name def create_parser(): arg_parser = argparse.ArgumentParser(prog='Imoavi extractor\n', usage='extract_imoavi input_file_name output_dir\n', description='Imoavi extractor for QLIE engine *.imoavi files.\n') arg_parser.add_argument('input_file_name', nargs='+', help="Input file with full path(wildcards are supported).\n") arg_parser.add_argument('output_dir', nargs='+', help="Output directory.\n") return arg_parser if __name__ == '__main__': parser = create_parser() arguments = parser.parse_args() all_imoavi = glob.glob(arguments.input_file_name[0]) output_dir = arguments.output_dir[0] for imoavi_f in all_imoavi: file_buffer = bytearray(b'') with open(imoavi_f, 'rb') as imoavi_h: # Read imoavi file header imoavi_h.read(hdr_len) imoavi_h.seek(2, os.SEEK_CUR) # 0x00 imoavi_h.seek(1, os.SEEK_CUR) # 0x64 imoavi_h.seek(3, os.SEEK_CUR) # 0x00 imoavi_h.seek(5, os.SEEK_CUR) # SOUND imoavi_h.seek(3, os.SEEK_CUR) # 0x00 imoavi_h.seek(1, os.SEEK_CUR) # 0x64 imoavi_h.seek(11, os.SEEK_CUR) imoavi_h.seek(5, os.SEEK_CUR) # Movie imoavi_h.seek(3, os.SEEK_CUR) # 00 ?? imoavi_h.seek(1, os.SEEK_CUR) # 0x64 imoavi_h.seek(3, os.SEEK_CUR) # 0x00 ?? imoavi_h.seek(4, os.SEEK_CUR) # ?? imoavi_h.seek(1, os.SEEK_CUR) # Number of jpg files in section imoavi_h.seek(4, os.SEEK_CUR) # 0x00 imoavi_h.seek(1, os.SEEK_CUR) # 0x05 ??? imoavi_h.seek(2, os.SEEK_CUR) # 0x00 ?? imoavi_h.seek(4, os.SEEK_CUR) # 720 ?? imoavi_h.seek(4, os.SEEK_CUR) # Full size without header? to_next_size = struct.unpack('&lt;L', imoavi_h.read(4))[0] # Bytes till next header imoavi_h.seek(16, os.SEEK_CUR) # 0x00 jpg_size = struct.unpack('&lt;L', imoavi_h.read(4))[0] imoavi_h.seek(4, os.SEEK_CUR) # 0x00 file_num = 0 file_buffer.extend(imoavi_h.read(jpg_size)) outfile_name = prepare_filename(imoavi_f, output_dir, '_' + (str(file_num)).zfill(3) + '.jpg') create_file(outfile_name, file_buffer) while to_next_size != 0: file_buffer = bytearray(b'') to_next_size = struct.unpack('&lt;L', imoavi_h.read(4))[0] if to_next_size == 24: # 0x1C header for index part file_buffer.extend(imoavi_h.read(to_next_size)) outfile_name = prepare_filename(imoavi_f, output_dir, '_' + '.index') create_file(outfile_name, file_buffer, 'ab') # concatenate with index file else: imoavi_h.seek(2, os.SEEK_CUR) # unknown imoavi_h.seek(2, os.SEEK_CUR) # Unknown, almost always FF FF or FF FE file_num = struct.unpack('B', imoavi_h.read(1))[0] # File number imoavi_h.seek(11, os.SEEK_CUR) # 0x00 jpg_size = struct.unpack('&lt;L', imoavi_h.read(4))[0] imoavi_h.seek(4, os.SEEK_CUR) # 0x00 file_buffer.extend(imoavi_h.read(jpg_size)) outfile_name = prepare_filename(imoavi_f, output_dir, '_' + (str(file_num)).zfill(3) + '.jpg') create_file(outfile_name, file_buffer)</span></span></code> </pre><br></div></div><br>  ,  ,            1_„Çø„Ç§„Éà„É´ÁîªÈù¢„É†„Éº„Éì„Éº.b   imoavi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/81/_r/lo81_rlqvf55nia7relrkbsckey.png"></div><br>      . <br><br>  ,        ,      . ,    ,    . ,        .                  . <br><br>  -  (, ,         ) :  ,      ,      Renpy,    ? <br> ,  ,   - ,        ,    . <br><br>         ? <br>     . <br><br>  Referenzen: <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   bitbucket</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  Qlie  </a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  Shift Jis</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">     Shift Jis  UTF-8</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> exfp3_v3  asmodean</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426431/">https://habr.com/ru/post/de426431/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426421/index.html">EHCI menschlich auf Russisch</a></li>
<li><a href="../de426423/index.html">mmWave auf Smartphones: Wie Qualcomm das Unm√∂gliche m√∂glich gemacht hat</a></li>
<li><a href="../de426425/index.html">Die ganze Wahrheit √ºber RTOS. Artikel # 14. Speicherbereiche: Einf√ºhrung und Grundversorgung</a></li>
<li><a href="../de426427/index.html">N√ºtzliches Zeug zum "Zeug": eine kleine Auswahl mit niedrigen Preisen</a></li>
<li><a href="../de426429/index.html">Installation von FreeSWITCH 1.8 unter Debian 9 (Raspbian Stretch, das Grundimage des Smart Home-Systems von MajorDoMo auf Rasbperri Pi)</a></li>
<li><a href="../de426433/index.html">Leckeres SMM f√ºr das Restaurant</a></li>
<li><a href="../de426435/index.html">Die besten Spezialisten sind diejenigen, die ich selbst vorbereitet habe: ein Spieletestkurs von Experten der Mail.Ru Group</a></li>
<li><a href="../de426437/index.html">Wie die Gesichtserkennung Ihnen hilft, Testtelefone zu finden</a></li>
<li><a href="../de426439/index.html">F√§lschung von Charts, Ersetzung von Quotes und Preismanipulation: Wie man Anwendungen f√ºr den Handel an der B√∂rse knackt</a></li>
<li><a href="../de426441/index.html">Mail.Ru Group 20 Jahre: Code- und Technologie-Checkpoints</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>