<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôèÔ∏è üî® ü§∞üèΩ Kann ich Haz? Von generischer Typprogrammierung getroffen ü•å üéè üéâ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr. 


 Letztes Mal haben wir Has pattern beschrieben, die Probleme beschrieben, die es l√∂st, und einige spezifische Instanzen geschrieben: 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kann ich Haz? Von generischer Typprogrammierung getroffen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471052/"><p>  Hallo Habr. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Letztes Mal haben</a> wir <code>Has</code> pattern beschrieben, die Probleme beschrieben, die es l√∂st, und einige spezifische Instanzen geschrieben: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HasDbConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> getDbConfig = dbConfig <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">HasWebServerConfig</span></span> <span class="hljs-type"><span class="hljs-type">AppConfig</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> getWebServerConfig = webServerConfig <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">HasCronConfig</span></span> <span class="hljs-type"><span class="hljs-type">AppConfig</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> getCronConfig = cronConfig</code> </pre> <br><p>  Es sieht gut aus.  Welche Schwierigkeiten k√∂nnen hier auftreten? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/821/f4f/397/821f4f397a69ccd020b677098f5ecaf7.jpg" alt="Bild"></p><br><p>  √úberlegen wir uns, welche anderen Instanzen wir m√∂glicherweise ben√∂tigen.  Erstens sind konkrete Typen mit einer Konfiguration f√ºr sich genommen gute Kandidaten f√ºr die (triviale) Implementierung dieser Typklassen, was uns drei weitere F√§lle gibt, in denen jede Methode beispielsweise √ºber <code>id</code> implementiert wird </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HasDbConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> getDbConfig = id</code> </pre> <br><p>  Sie erm√∂glichen es uns, auf einfache Weise einzelne Tests oder Hilfsprogramme zu schreiben, die von der gesamten <code>AppConfig</code> unabh√§ngig sind. </p><br><p>  Das ist schon langweilig, geht aber trotzdem weiter.  Es ist leicht vorstellbar, dass einige Integrationstests die Interaktion eines Modulpaares √ºberpr√ºfen, und wir m√∂chten immer noch nicht von der Konfiguration der gesamten Anwendung abh√§ngen. <code>fst</code> m√ºssen wir jetzt sechs Instanzen (zwei pro Typ) schreiben, von denen jede auf <code>fst</code> reduziert <code>fst</code> oder <code>snd</code> .  Zum Beispiel f√ºr <code>DbConfig</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HasDbConfig</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> getDbConfig = fst <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">HasDbConfig</span></span> (a, <span class="hljs-type"><span class="hljs-type">DbConfig</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> getDbConfig = snd</code> </pre> <br><p>  Horror  Es ist zu hoffen, dass wir niemals den Betrieb von drei Modulen gleichzeitig testen m√ºssen - andernfalls m√ºssen Sie neun langweilige Instanzen schreiben.  Auf jeden Fall f√ºhle ich mich pers√∂nlich schon sehr unwohl und w√ºrde lieber mehrere Stunden damit verbringen, diese Angelegenheit zu automatisieren, als ein paar Minuten, um ein Dutzend zus√§tzliche Codezeilen zu schreiben. </p><br><p>  Wenn Sie daran interessiert sind, wie Sie dieses Problem allgemein l√∂sen k√∂nnen, sind es au√üerdem abh√§ngige Typen und wie alles wie eine Haskell-Welkom-Katze aussehen wird. </p><a name="habracut"></a><br><h1 id="obobschaem-has-klass">  Zusammenfassung der <code>Has</code> Klasse </h1><br><p>  Beachten Sie zun√§chst, dass wir unterschiedliche Klassen f√ºr unterschiedliche Umgebungen haben.  Dies kann die Erstellung einer universellen L√∂sung beeintr√§chtigen. Daher wird die Umgebung in einem separaten Parameter herausgenommen: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> part record </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> extract :: record -&gt; part</code> </pre> <br><p>  Wir k√∂nnen sagen, dass ein <code>Has part record</code> , dass ein Wert des Typtyps aus dem Wert des Typdatensatzes extrahiert werden kann.  In diesen Begriffen wird unsere gute alte <code>HasDbConfig</code> zu <code>Has DbConfig</code> , und √§hnlich f√ºr andere Typklassen, die wir zuvor geschrieben haben.  Es stellt sich fast eine rein syntaktische √Ñnderung heraus, und zum Beispiel wird der Typ einer der Funktionen aus unserem vorherigen Beitrag ge√§ndert </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">doSmthWithDbAndCron</span></span> :: (<span class="hljs-type"><span class="hljs-type">MonadReader</span></span> rm, <span class="hljs-type"><span class="hljs-type">HasDbConfig</span></span> r, <span class="hljs-type"><span class="hljs-type">HasCronConfig</span></span> r) =&gt; ...</code> </pre> <br><p>  in </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">doSmthWithDbAndCron</span></span> :: (<span class="hljs-type"><span class="hljs-type">MonadReader</span></span> rm, <span class="hljs-type"><span class="hljs-type">Has</span></span> <span class="hljs-type"><span class="hljs-type">DbConfig</span></span> r, <span class="hljs-type"><span class="hljs-type">Has</span></span> <span class="hljs-type"><span class="hljs-type">CronConfig</span></span> r) =&gt; ...</code> </pre> <br><p>  Die einzige √Ñnderung sind ein paar Leerzeichen an den richtigen Stellen. </p><br><p>  Dar√ºber hinaus haben wir bei der Typinferenz nicht viel verloren: Ein Timer kann in den allermeisten F√§llen, die in der Praxis auftreten, immer noch den erforderlichen R√ºckgabewert des <code>extract</code> im umgebenden Kontext ausgeben. </p><br><p>  Nachdem wir uns nicht um den spezifischen Umgebungstyp k√ºmmern, wollen wir sehen, welche Datens√§tze die <code>Has part record</code> f√ºr das feste <code>part</code> implementieren k√∂nnen.  Diese Aufgabe hat eine gute induktive Struktur: </p><br><ol><li>  Jeder Typ hat seine eigenen: <code>Has record record</code> ist auf triviale Weise implementiert ( <code>extract = id</code> ). </li><li>  Wenn <code>record</code> ein Produkt der Typen <code>rec1</code> und <code>rec2</code> , wird <code>Has part record</code> genau dann implementiert, wenn entweder <code>Has part rec1</code> oder <code>Has part rec2</code> . </li><li>  Wenn <code>record</code> die Summe der Typen <code>rec1</code> und <code>rec2</code> , wird <code>Has part record</code> genau dann implementiert, wenn <code>Has part rec1</code> und <code>Has part rec2</code> .  Obwohl die praktische Verbreitung dieses Falles in diesem Zusammenhang nicht offensichtlich ist, ist es der Vollst√§ndigkeit halber noch erw√§hnenswert. </li></ol><br><p>  Es sieht also so aus, als h√§tten wir eine Skizze eines Algorithmus formuliert, um automatisch zu bestimmen, ob ein <code>Has part record</code> f√ºr <code>part</code> und <code>record</code> implementiert ist! </p><br><p>  Gl√ºcklicherweise passt eine solche induktive Argumentation zu Typen sehr gut zum Haskell <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Generics-</a> Mechanismus.  Kurz und vereinfacht ausgedr√ºckt, ist Generics eine der Methoden der verallgemeinerten Metaprogrammierung in Haskell, die sich aus der Beobachtung ergibt, dass jeder Typ entweder ein Summentyp, ein Produkttyp oder ein Basistyp mit einem Konstrukt und einem Feld ist. </p><br><p>  Ich werde kein <em>weiteres</em> Tutorial √ºber Generika schreiben, also fahren Sie einfach mit dem Code fort. </p><br><h1 id="pervaya-popytka">  Erster Versuch </h1><br><p>  Wir werden die klassische Methode der <code>Generic</code> Implementierung unseres <code>Has</code> durch die Hilfsklasse <code>GHas</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GHas</span></span></span><span class="hljs-class"> part grecord </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> gextract :: grecord p -&gt; part</code> </pre> <br><p>  Hier ist <code>grecord</code> eine <code>Generic</code> Darstellung unseres <code>record</code> . </p><br><p>  <code>GHas</code> Implementierungen folgen der oben angegebenen induktiven Struktur: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GHas</span></span></span><span class="hljs-class"> record (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">K1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">record</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> gextract (<span class="hljs-type"><span class="hljs-type">K1</span></span> x) = x <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">GHas</span></span> part record =&gt; <span class="hljs-type"><span class="hljs-type">GHas</span></span> part (<span class="hljs-type"><span class="hljs-type">M1</span></span> it record) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> gextract (<span class="hljs-type"><span class="hljs-type">M1</span></span> x) = gextract x <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">GHas</span></span> part l =&gt; <span class="hljs-type"><span class="hljs-type">GHas</span></span> part (l :*: r) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> gextract (l :*: _) = gextract l <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">GHas</span></span> part r =&gt; <span class="hljs-type"><span class="hljs-type">GHas</span></span> part (l :*: r) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> gextract (_ :*: r) = gextract r</code> </pre> <br><ol><li>  <code>K1</code> entspricht dem Basisfall. </li><li>  <code>M1</code> - Generika-spezifische Metadaten, die wir f√ºr unsere Aufgabe nicht ben√∂tigen. Wir ignorieren sie einfach und gehen sie durch. </li><li>  Die erste Instanz f√ºr den Produkttyp <code>l :*: r</code> entspricht dem Fall, dass der "linke" Teil des Produkts den Wert des Typs hat, den wir ben√∂tigen (m√∂glicherweise rekursiv). </li><li>  In √§hnlicher Weise entspricht die zweite Instanz f√ºr den Produkttyp <code>l :*: r</code> dem Fall, in dem der "richtige" Teil des Produkts den Wert des Typs hat, den wir ben√∂tigen (nat√ºrlich auch m√∂glicherweise rekursiv). </li></ol><br><p>  Wir unterst√ºtzen hier nur Produkttypen.  Mein subjektiver Eindruck ist, dass Betr√§ge in Kontexten f√ºr <code>MonadReader</code> und √§hnliche Klassen nicht so h√§ufig verwendet werden, sodass sie zur Vereinfachung der Betrachtung vernachl√§ssigt werden k√∂nnen. </p><br><p>  Dar√ºber hinaus ist es n√ºtzlich zu beachten, dass jeder <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/471052/&amp;usg=ALkJrhiH4EOUwDMSAmiDmWuy7ta1bbIqAA#MJMATHI-6E" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> n </script>  -ary Typ-Produkt <code>(a1, ..., an)</code> kann als Zusammensetzung dargestellt werden <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>&amp;#x2212;</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.398ex" height="2.057ex" viewBox="0 -728.2 2323.9 885.9" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/471052/&amp;usg=ALkJrhiH4EOUwDMSAmiDmWuy7ta1bbIqAA#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/471052/&amp;usg=ALkJrhiH4EOUwDMSAmiDmWuy7ta1bbIqAA#MJMAIN-2212" x="822" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/471052/&amp;usg=ALkJrhiH4EOUwDMSAmiDmWuy7ta1bbIqAA#MJMAIN-31" x="1823" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>‚àí</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-2"> n-1 </script>  Paare <code>(a1, (a2, (a3, (..., an))))</code> , daher erlaube ich mir, Produkttypen mit Paaren zu verkn√ºpfen. </p><br><p>  Mit unseren <code>GHas</code> k√∂nnen Sie eine Standardimplementierung f√ºr <code>Has</code> schreiben, die Generika verwendet: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> part record </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> extract :: record -&gt; part <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> extract :: <span class="hljs-type"><span class="hljs-type">Generic</span></span> record =&gt; record -&gt; part extract = gextract . from</code> </pre> <br><p>  Fertig. </p><br><p>  Oder nicht? </p><br><h1 id="problema">  Das Problem </h1><br><p>  Wenn wir versuchen, diesen Code zu kompilieren, werden wir feststellen, dass er auch ohne den Versuch, diese Implementierung standardm√§√üig zu verwenden, nicht taypechaetsya ausf√ºhrt und dort einige √ºberlappende Instanzen meldet.  Schlimmer noch, diese Instanzen sind in gewisser Hinsicht gleich.  Es scheint an der Zeit zu sein, herauszufinden, wie der Mechanismus zum Aufl√∂sen von Instanzen in Haskell funktioniert. </p><br><p>  M√∂gen wir haben </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> context =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Foo</span></span></span><span class="hljs-class"> barPattern bazPattern </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> ...</code> </pre> <br><p>  (√úbrigens hei√üt dieses Ding nach <code>=&gt;</code> Instanzkopf.) </p><br><p>  Es scheint nat√ºrlich, dies als zu lesen </p><br><blockquote>  Lassen Sie uns eine Instanz f√ºr <code>Foo bar baz</code> ausw√§hlen.  <em>Wenn der</em> <code>context</code> erf√ºllt ist, k√∂nnen Sie diese Instanz ausw√§hlen, sofern <code>bar</code> und <code>baz</code> <code>barPattern</code> und <code>bazPattern</code> . </blockquote><p>  Dies ist jedoch eine Fehlinterpretation und genau das Gegenteil: </p><br><blockquote>  Lassen Sie uns eine Instanz f√ºr <code>Foo bar baz</code> ausw√§hlen.  <em>Wenn</em> <code>bar</code> und <code>baz</code> <code>barPattern</code> und <code>bazPattern</code> , w√§hlen wir diese Instanz aus und f√ºgen der Liste der Konstanten, die aufgel√∂st werden m√ºssen, <code>context</code> hinzu. </blockquote><p>  Jetzt ist es offensichtlich, wo das Problem liegt.  Schauen wir uns die folgenden Instanzen genauer an: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GHas</span></span></span><span class="hljs-class"> part l =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GHas</span></span></span><span class="hljs-class"> part (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l</span></span></span><span class="hljs-class"> :*: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> gextract (l :*: _) = gextract l <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">GHas</span></span> part r =&gt; <span class="hljs-type"><span class="hljs-type">GHas</span></span> part (l :*: r) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> gextract (_ :*: r) = gextract r</code> </pre> <br><p>  Sie haben die gleichen Instanzk√∂pfe, also kein Wunder, dass sie sich schneiden!  Dar√ºber hinaus ist keiner von ihnen spezifischer als der andere. </p><br><p>  Dar√ºber hinaus gibt es keine M√∂glichkeit, diese Instanzen so zu verfeinern, dass sie sich nicht mehr √ºberschneiden.  Nun, neben dem Hinzuf√ºgen weiterer <code>GHas</code> Parameter. </p><br><h1 id="vyrazitelnye-tipy-speshat-na-pomosch">  Ausdrucksstarke Typen eilen zur Rettung! </h1><br><p>  Die L√∂sung des Problems besteht darin, den "Pfad" zu dem f√ºr uns interessanten Wert vorab zu berechnen und diesen Pfad zu verwenden, um die Auswahl der Instanzen zu steuern. </p><br><p>  Da wir uns darauf geeinigt haben, Summentypen nicht zu unterst√ºtzen, ist ein Pfad im w√∂rtlichen Sinne eine Folge von Links- oder Rechtskurven in Produkttypen (dh Auswahl der ersten oder zweiten Komponente eines Paares), die mit einem gro√üen HIER-Zeiger endet, sobald wir den gew√ºnschten Typ gefunden haben .  Wir schreiben dies: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Path</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">L</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Path</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">R</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Path</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Here</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Zum Beispiel</b> <div class="spoiler_text"><p>  Betrachten Sie die folgenden Typen: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbAddress</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbAddress</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbUsername</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Username</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbPassword</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Password</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">webServerConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WebServerConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cronConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CronConfig</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  Was sind einige Beispiele f√ºr Pfade von <code>AppConfig</code> ? </p><br><ol><li>  Zu <code>DbConfig</code> ‚ü∂ <code>L Here</code> . </li><li>  Zu <code>WebServerConfig</code> ‚ü∂ <code>R (L Here)</code> . </li><li>  Zu <code>CronConfig</code> ‚ü∂ <code>R (R Here)</code> . </li><li>  Zu <code>DbAddress</code> ‚ü∂ <code>L (L Here)</code> . </li></ol></div></div><br><p>  Was k√∂nnte das Ergebnis einer Suche nach einem Wert des gew√ºnschten Typs sein?  Zwei Optionen liegen auf der Hand: Wir k√∂nnen es entweder finden oder nicht.  Tats√§chlich ist jedoch alles etwas komplizierter: Wir k√∂nnen mehr als einen Wert dieses Typs finden.  Anscheinend w√§re das vern√ºnftigste Verhalten in diesem kontroversen Fall auch eine Fehlermeldung.  Jede Wahl eines bestimmten Wertes hat eine gewisse Zuf√§lligkeit. </p><br><p>  Betrachten Sie in der Tat unser Standard-Webdienstbeispiel.  Wenn jemand einen Wert vom Typ <code>(Host, Port)</code> m√∂chte, sollte dies die Adresse des Datenbankservers oder die Adresse des Webservers sein?  Es ist besser, es nicht zu riskieren. </p><br><p>  Lassen Sie uns dies auf jeden Fall im Code ausdr√ºcken: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MaybePath</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NotFound</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Conflict</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Found</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Path</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Wir trennen <code>NotFound</code> und <code>Conflict</code> , da die Behandlung dieser F√§lle grundlegend anders ist: Wenn wir <code>NotFound</code> in einem der Zweige unseres Produkttyps erhalten, schadet es nicht, den gew√ºnschten Wert in einem anderen Zweig zu finden, w√§hrend <code>Conflict</code> in einem Zweig sofort voll bedeutet ein Fehler. </p><br><p>  Nun betrachten wir einen Sonderfall von Produkttypen (die wir, wie vereinbart, paarweise betrachten).  Wie finde ich den Wert des gew√ºnschten Typs in ihnen?  Sie k√∂nnen eine Suche rekursiv in jeder Komponente eines Paares ausf√ºhren, die Ergebnisse <code>p1</code> bzw. <code>p2</code> <code>p1</code> und sie dann irgendwie kombinieren. </p><br><p>  Da es sich um die Auswahl von Instanzen von Zeitklassen handelt, die w√§hrend der Kompilierung auftreten, ben√∂tigen wir tats√§chlich Kompilierungsberechnungen, die im Haskell durch Berechnungen von Typen ausgedr√ºckt werden (selbst wenn Typen durch Begriffe dargestellt werden, die mit <code>DataKinds</code> im Universum <code>DataKinds</code> ).  Dementsprechend wird eine solche Funktion f√ºr Typen als Typenfamilie dargestellt: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">family</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Combine</span></span></span><span class="hljs-class"> p1 p2 where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Combine</span></span></span><span class="hljs-class"> ('</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Found</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">path</span></span></span><span class="hljs-class">) '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NotFound</span></span></span><span class="hljs-class"> = '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Found</span></span></span><span class="hljs-class"> ('</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">L</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">path</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Combine</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NotFound</span></span></span><span class="hljs-class"> ('</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Found</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">path</span></span></span><span class="hljs-class">) = '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Found</span></span></span><span class="hljs-class"> ('</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">R</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">path</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Combine</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NotFound</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NotFound</span></span></span><span class="hljs-class"> = '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NotFound</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Combine</span></span></span><span class="hljs-class"> _ _ = '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Conflict</span></span></span></span></code> </pre> <br><p>  Diese Funktion repr√§sentiert mehrere F√§lle: </p><br><ol><li>  Wenn eine der rekursiven Suchen erfolgreich ist und die andere zu <code>NotFound</code> , <code>NotFound</code> wir den Pfad von der erfolgreichen Suche und h√§ngen die Kurve in die richtige Richtung an. </li><li>  Wenn beide rekursiven Suchen mit <code>NotFound</code> , endet die gesamte Suche offensichtlich mit <code>NotFound</code> . </li><li>  In jedem anderen Fall kommt es zu <code>Conflict</code> . </li></ol><br><p>  Jetzt schreiben wir eine Funktion auf Tipe-Ebene, die das zu findende Teil verwendet, und eine <code>Generic</code> Darstellung des Typs, in dem das <code>part</code> , und suchen: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">family</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> part (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">grecord</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class"> -&gt; *) :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MaybePath</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> part (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">K1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">part</span></span></span><span class="hljs-class">) = '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Found</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Here</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> part (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">K1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">other</span></span></span><span class="hljs-class">) = '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NotFound</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> part (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> part x </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> part (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l</span></span></span><span class="hljs-class"> :*: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Combine</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">part</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">part</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> _ _ = '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NotFound</span></span></span></span></code> </pre> <br><p>  Beachten Sie, dass wir eine sehr √§hnliche Bedeutung haben wie unser vorheriger Versuch mit <code>GHas</code> .  Dies ist zu erwarten, da wir tats√§chlich den Algorithmus reproduzieren, den wir versucht haben, durch die Zeitklassen auszudr√ºcken. </p><br><p>  <code>GHas</code> : Wir m√ºssen dieser Klasse nur noch einen zus√§tzlichen Parameter hinzuf√ºgen, der f√ºr den zuvor gefundenen Pfad verantwortlich ist und zur Auswahl bestimmter Instanzen dient: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GHas</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">path</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Path</span></span></span><span class="hljs-class">) part grecord </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> gextract :: <span class="hljs-type"><span class="hljs-type">Proxy</span></span> path -&gt; grecord p -&gt; part</code> </pre> <br><p>  Wir haben auch ein zus√§tzliches Argument f√ºr <code>gextract</code> damit der Compiler die richtige Instanz f√ºr den angegebenen Pfad ausw√§hlen kann (dies muss in der Funktionssignatur angegeben werden). </p><br><p>  Das Schreiben von Instanzen ist jetzt ziemlich einfach: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GHas</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Here</span></span></span><span class="hljs-class"> record (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">K1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">record</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> gextract _ (<span class="hljs-type"><span class="hljs-type">K1</span></span> x) = x <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">GHas</span></span> path part record =&gt; <span class="hljs-type"><span class="hljs-type">GHas</span></span> path part (<span class="hljs-type"><span class="hljs-type">M1</span></span> it record) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> gextract proxy (<span class="hljs-type"><span class="hljs-type">M1</span></span> x) = gextract proxy x <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">GHas</span></span> path part l =&gt; <span class="hljs-type"><span class="hljs-type">GHas</span></span> ('<span class="hljs-type"><span class="hljs-type">L</span></span> path) part (l :*: r) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> gextract _ (l :*: _) = gextract (<span class="hljs-type"><span class="hljs-type">Proxy</span></span> :: <span class="hljs-type"><span class="hljs-type">Proxy</span></span> path) l <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">GHas</span></span> path part r =&gt; <span class="hljs-type"><span class="hljs-type">GHas</span></span> ('<span class="hljs-type"><span class="hljs-type">R</span></span> path) part (l :*: r) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> gextract _ (_ :*: r) = gextract (<span class="hljs-type"><span class="hljs-type">Proxy</span></span> :: <span class="hljs-type"><span class="hljs-type">Proxy</span></span> path) r</code> </pre> <br><p>  In der Tat w√§hlen wir einfach die gew√ºnschte Instanz basierend auf dem Pfad in dem <code>path</code> , den wir zuvor berechnet haben. </p><br><p>  Wie schreibe ich jetzt unsere <code>default</code> der Funktion <code>extract :: record -&gt; part</code> in die Klasse <code>Has</code> ?  Wir haben mehrere Bedingungen: </p><br><ol><li>  <code>record</code> muss <code>Generic</code> implementieren, damit der generische Mechanismus angewendet werden kann, damit wir einen <code>Generic record</code> . </li><li>  Die <code>Search</code> sollte einen <code>part</code> im <code>record</code> (oder besser gesagt in der <code>Generic</code> Darstellung des <code>record</code> , die als <code>Rep record</code> ausgedr√ºckt wird).  Im Code sieht dies etwas ungew√∂hnlicher aus: <code>Search part (Rep record) ~ 'Found path</code> .  Dieser Datensatz bedeutet die Einschr√§nkung, dass das Ergebnis des <code>Search part (Rep record)</code> gleich dem <code>'Found path</code> f√ºr einen <code>path</code> (was f√ºr uns tats√§chlich interessant ist). </li><li>  Wir sollten in der Lage sein, <code>GHas</code> zusammen mit <code>part</code> , der generischen Darstellung von <code>record</code> und <code>path</code> aus dem letzten Schritt, der sich in einen <code>GHas path part (Rep record)</code> verwandelt. </li></ol><br><p>  Wir werden die letzten beiden Konstanten noch mehrmals treffen, daher ist es n√ºtzlich, sie in ein separates Konstanten-Synonym zu setzen: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SuccessfulSearch</span></span></span><span class="hljs-class"> part record path = (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">part</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Rep</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">record</span></span></span><span class="hljs-class">) ~ '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Found</span></span></span><span class="hljs-class"> path, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GHas</span></span></span><span class="hljs-class"> path part (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Rep</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">record</span></span></span><span class="hljs-class">))</span></span></code> </pre> <br><p>  Mit diesem Synonym bekommen wir </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> part record </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> extract :: record -&gt; part <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> extract :: forall path. (<span class="hljs-type"><span class="hljs-type">Generic</span></span> <span class="hljs-title"><span class="hljs-title">record</span></span>, <span class="hljs-type"><span class="hljs-type">SuccessfulSearch</span></span> <span class="hljs-title"><span class="hljs-title">part</span></span> <span class="hljs-title"><span class="hljs-title">record</span></span> <span class="hljs-title"><span class="hljs-title">path</span></span>) =&gt; record -&gt; part extract = gextract (<span class="hljs-type"><span class="hljs-type">Proxy</span></span> :: <span class="hljs-type"><span class="hljs-type">Proxy</span></span> <span class="hljs-title"><span class="hljs-title">path</span></span>) . from</code> </pre> <br><p>  Jetzt alles! </p><br><h1 id="ispolzovanie-obobschyonnogo-has">  Verwenden von generischen <code>Has</code> </h1><br><p>  Um all dies in Aktion zu betrachten, werden wir einige allgemeine Instanzen f√ºr Dummies schreiben: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SuccessfulSearch</span></span></span><span class="hljs-class"> a (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a0</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">) path =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> a (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a0</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SuccessfulSearch</span></span></span><span class="hljs-class"> a (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a0</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a2</span></span></span><span class="hljs-class">) path =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> a (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a0</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a2</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SuccessfulSearch</span></span></span><span class="hljs-class"> a (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a0</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a3</span></span></span><span class="hljs-class">) path =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> a (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a0</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a3</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Hier ist <code>SuccessfulSearch a (a0, ..., an) path</code> daf√ºr verantwortlich, dass <code>a</code> unter <code>a0, ..., an</code> genau einmal vorkommt. </p><br><p>  M√∂gen wir jetzt unser gutes altes haben </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">webServerConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WebServerConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cronConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CronConfig</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  und wir wollen <code>Has DbConfig</code> , <code>Has WebServerConfig</code> und <code>Has CronConfig</code> .  Es reicht aus, die <code>DeriveAnyClass</code> <code>DeriveGeneric</code> und <code>DeriveAnyClass</code> und die richtige <code>deriving</code> hinzuzuf√ºgen: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">webServerConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WebServerConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cronConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CronConfig</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Generic</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WebServerConfig</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CronConfig</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Wir haben das Gl√ºck (oder wir waren aufschlussreich genug), die Argumente f√ºr <code>Has</code> so anzuordnen, dass der Name des verschachtelten Typs an erster Stelle steht, sodass wir uns auf den <code>DeriveAnyClass</code> Mechanismus verlassen k√∂nnen, um das <code>DeriveAnyClass</code> zu minimieren. </p><br><h2 id="bezopasnost-prevyshe-vsego">  Sicherheit steht an erster Stelle </h2><br><p>  Was ist, wenn wir keinen Typ haben? </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">webServerConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WebServerConfig</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Generic</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CronConfig</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Nein, wir bekommen einen Fehler direkt an der Stelle der Typdefinition: </p><br><pre> <code class="plaintext hljs">Spec.hs:35:24: error: ‚Ä¢ Couldn't match type ''NotFound' with ''Found path0' arising from the 'deriving' clause of a data type declaration ‚Ä¢ When deriving the instance for (Has CronConfig AppConfig) | 35 | } deriving (Generic, Has CronConfig) | ^^^^^^^^^^^^^^</code> </pre> <br><p>  Nicht die freundlichste Fehlermeldung, aber selbst daraus k√∂nnen Sie immer noch verstehen, wo das Problem liegt: die ungerade Frequenz <code>NotFound</code> ungerade Frequenz <code>CronConfig</code> . </p><br><p>  Was ist, wenn wir mehrere Felder mit demselben Typ haben? </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prodDbConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">qaDbConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">webServerConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WebServerConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cronConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CronConfig</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Generic</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Nein, wie erwartet: </p><br><pre> <code class="plaintext hljs">Spec.hs:37:24: error: ‚Ä¢ Couldn't match type ''Conflict' with ''Found path0' arising from the 'deriving' clause of a data type declaration ‚Ä¢ When deriving the instance for (Has DbConfig AppConfig) | 37 | } deriving (Generic, Has DbConfig) | ^^^^^^^^^^^^</code> </pre> <br><p>  Alles scheint wirklich gut zu sein. </p><br><h1 id="podytozhivaya">  Zusammenfassend </h1><br><p>  Wir werden also versuchen, die vorgeschlagene Methode kurz zu formulieren. </p><br><p>  Angenommen, wir haben eine Art Typklass und m√∂chten seine Instanzen automatisch nach einigen rekursiven Regeln anzeigen.  Dann k√∂nnen wir die Mehrdeutigkeiten wie folgt vermeiden (und diese Regeln im Allgemeinen ausdr√ºcken, wenn sie nicht trivial sind und nicht in den Standardmechanismus zum Aufl√∂sen von Instanzen passen): </p><br><ol><li>  Wir codieren rekursive Regeln in Form eines induktiven Datentyps <code>T</code> </li><li>  Wir werden eine Funktion f√ºr Typen (in Form einer Typenfamilie) zur vorl√§ufigen Berechnung des Werts <code>v</code> dieses Typs <code>T</code> (oder in Bezug auf Haskell Typ <code>v</code> Typs <code>T</code> - wo sind meine abh√§ngigen Typen) schreiben, die die spezifische Abfolge der Schritte beschreibt, die ausgef√ºhrt werden m√ºssen. </li><li>  Verwenden Sie dieses <code>v</code> als zus√§tzliches Argument f√ºr den <code>Generic</code> Helfer, um die spezifische Folge von Instanzen zu bestimmen, die jetzt mit den Werten von <code>v</code> √ºbereinstimmen. </li></ol><br><p>  Nun, das ist es! </p><br><p>  In den folgenden Beitr√§gen werden wir einige elegante Erweiterungen (sowie elegante Einschr√§nkungen) dieses Ansatzes betrachten. </p><br><p>  Oh und ja.  Es ist interessant, die Abfolge unserer Verallgemeinerungen zu verfolgen. </p><br><ol><li>  Begonnen mit <code>Env -&gt; Foo</code> . </li><li>  Nicht allgemein genug, wickeln Sie sich in die <code>Reader Env</code> Monade ein. </li><li>  Nicht allgemein genug, schreiben Sie mit dem <code>MonadReader Env m</code> . </li><li>  Nicht allgemein genug, schreiben Sie <code>MonadReader rm, HasEnv r</code> . </li><li>  Nicht allgemein genug, schreiben <code>MonadReader rm, Has Env r</code> und f√ºgen Generika hinzu, damit der Compiler dort alles macht. </li><li>  Nun die Norm. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471052/">https://habr.com/ru/post/de471052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471042/index.html">Probleml√∂sung mit pwnable.kr 25 - otp. Gr√∂√üenbeschr√§nkung f√ºr Linux-Dateien</a></li>
<li><a href="../de471044/index.html">Sass MediaScreen - Definieren von CSS-Ger√§ten</a></li>
<li><a href="../de471046/index.html">Stilvolle Avalonia</a></li>
<li><a href="../de471048/index.html">Reagieren + Mobx: Was ist der Sinn?</a></li>
<li><a href="../de471050/index.html">D Finanzierung des Sprachentwicklungsfonds: Neue Plattformen und neue Zusch√ºsse ...</a></li>
<li><a href="../de471054/index.html">Longrid √ºber den Realismus der Quantenbedrohung f√ºr Kryptow√§hrungen und die Probleme der ‚ÄûProphezeiung 2027‚Äú</a></li>
<li><a href="../de471062/index.html">Wie Sie Alice beibringen, Ihr Smart Home zu verwalten. Yandex-Bericht</a></li>
<li><a href="../de471066/index.html">Wie sieht das Zip-Archiv aus und was k√∂nnen wir dagegen tun?</a></li>
<li><a href="../de471070/index.html">Welche Serversprache soll man w√§hlen ... f√ºr einen mobilen Entwickler</a></li>
<li><a href="../de471072/index.html">Wie viel Gramm im Telegramm?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>