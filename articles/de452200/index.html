<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¿â€ğŸ« ğŸ˜¿ ğŸ‰ GOSTIM: P2P F2F E2EE IM an einem Abend mit GOST-Kryptographie ğŸ™ŒğŸ» â™»ï¸ ğŸ¥¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Als Entwickler der PyGOST- Bibliothek (kryptografische GOST- Grundelemente in reinem Python) bekomme ich hÃ¤ufig Fragen zur Implementierung des einfach...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GOSTIM: P2P F2F E2EE IM an einem Abend mit GOST-Kryptographie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452200/">  Als Entwickler der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PyGOST-</a> Bibliothek (kryptografische GOST- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grundelemente</a> in reinem Python) bekomme ich hÃ¤ufig Fragen zur Implementierung des einfachsten sicheren Messaging auf meinem Knie.  Viele halten angewandte Kryptografie fÃ¼r eine ziemlich einfache Sache, und ein Aufruf von .encrypt () an eine BlockverschlÃ¼sselung reicht aus, um sicher Ã¼ber einen Kommunikationskanal zu senden.  Andere glauben, dass angewandte Kryptographie das Schicksal einiger weniger ist, und es ist akzeptabel, dass wohlhabende Unternehmen wie Telegramm mit Mathematikolympiaden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kein</a> sicheres Protokoll implementieren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kÃ¶nnen</a> . <br><br>  All dies veranlasste mich, diesen Artikel zu schreiben, um zu zeigen, dass die Implementierung kryptografischer Protokolle und sicherer IM keine so schwierige Aufgabe ist.  Es lohnt sich jedoch nicht, eigene Authentifizierungs- und SchlÃ¼sselvereinbarungsprotokolle zu erfinden. <br><br><div style="text-align:center;"><img alt="Heearing" src="https://habrastorage.org/getpro/habr/post_images/4e2/2bb/f04/4e22bbf0480a8181bcbb2054c6f95815.jpg"></div><br>  Der Artikel wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Peer-to-Peer-</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Friend-to-Friend-</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">End-to-End-verschlÃ¼sselter</a> Instant Messenger mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SIGMA-I-</a> Authentifizierung und SchlÃ¼sselvereinbarungsprotokoll (basierend auf der Implementierung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IPsec IKE</a> ) unter Verwendung ausschlieÃŸlich von GOG-Kryptografiealgorithmen PyGOST-Bibliotheken und geschrieben ASN.1-Codierung von Nachrichten mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PyDERASN-</a> Bibliothek (Ã¼ber die ich bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zuvor geschrieben habe</a> ).  Voraussetzung: Es muss so einfach sein, dass es an einem Abend (oder Arbeitstag) von Grund auf neu geschrieben werden kann, sonst ist es kein einfaches Programm mehr.  Es hat wahrscheinlich Fehler, unnÃ¶tige Schwierigkeiten, MÃ¤ngel und dies ist mein erstes Programm, das die Asyncio-Bibliothek verwendet. <br><a name="habracut"></a><br><h2>  Design IM </h2><br>  Um loszulegen, mÃ¼ssen Sie verstehen, wie unser IM aussehen wird.  Lassen Sie es der Einfachheit halber ein Peer-to-Peer-Netzwerk sein, ohne dass Teilnehmer entdeckt werden.  Wir werden persÃ¶nlich angeben, an welche Adresse: den Port, an den eine Verbindung hergestellt werden soll, um mit dem GesprÃ¤chspartner zu kommunizieren. <br><br>  Ich verstehe, dass die Annahme der VerfÃ¼gbarkeit einer direkten Kommunikation zwischen zwei beliebigen Computern derzeit eine erhebliche EinschrÃ¤nkung der Anwendbarkeit von IM in der Praxis darstellt.  Aber je mehr Entwickler alle Arten von NAT-Traversal-KrÃ¼cken implementieren, desto lÃ¤nger bleiben wir im IPv4-Internet, wobei die Wahrscheinlichkeit einer Kommunikation zwischen beliebigen Computern abnimmt.  Wie viel kÃ¶nnen Sie den Mangel an IPv6 zu Hause und bei der Arbeit ertragen? <br><br>  Wir werden ein Freund-zu-Freund-Netzwerk haben: Alle mÃ¶glichen GesprÃ¤chspartner sollten im Voraus bekannt sein.  Erstens vereinfacht es alles erheblich: sich vorstellen, einen Namen / SchlÃ¼ssel finden oder nicht finden, die Verbindung trennen oder weiterarbeiten, den GesprÃ¤chspartner kennen.  Zweitens ist es im allgemeinen Fall sicher und schlieÃŸt viele Angriffe aus. <br><br>  Die IM-OberflÃ¤che wird den klassischen LÃ¶sungen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">saugfreien Projekten nahe kommen</a> , die ich wegen ihres Minimalismus und ihrer Unix-Way-Philosophie sehr mag.  Ein IM-Programm fÃ¼r jeden GesprÃ¤chspartner erstellt ein Verzeichnis mit drei Unix-Domain-Sockets: <br><br><ul><li>  In - Nachrichten, die an den GesprÃ¤chspartner gesendet werden, werden darin aufgezeichnet. </li><li>  vom GesprÃ¤chspartner empfangene Nachrichten werden von ihm gelesen; </li><li>  Wenn wir den Status daraus lesen, werden wir herausfinden, ob der GesprÃ¤chspartner jetzt verbunden ist, die Verbindungsadresse / den Anschluss. </li></ul><br>  AuÃŸerdem wird ein Conn-Socket erstellt, der schreibt, an welchen Host-Port wir eine Verbindung zu einem Remote-GesprÃ¤chspartner herstellen. <br><br><pre> | - Alice
 |  | - in
 |  | - raus
 |  `- Zustand
 | - bob
 |  | - in
 |  | - raus
 |  `- Zustand
 `- conn
</pre><br>  Dieser Ansatz ermÃ¶glicht es Ihnen, unabhÃ¤ngige Implementierungen des IM-Transports und der BenutzeroberflÃ¤che vorzunehmen, da es keinen Freund fÃ¼r den Geschmack und die Farbe gibt, werden Sie nicht jedem gefallen.  Mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tmux</a> und / oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Multitail</a> kÃ¶nnen Sie eine Multi-Window-OberflÃ¤che mit Syntaxhervorhebung erhalten.  Und mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">rlwrap kÃ¶nnen</a> Sie eine GNU Readline-kompatible Zeichenfolge fÃ¼r die Eingabe von Nachrichten erhalten. <br><br>  TatsÃ¤chlich verwenden saugfreie Projekte FIFO-Dateien.  PersÃ¶nlich konnte ich nicht verstehen, wie man in Asyncio mit Dateien konkurrenzfÃ¤hig arbeitet, ohne ein handgemachtes Substrat aus ausgewÃ¤hlten Threads (ich benutze <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Go-</a> Sprache fÃ¼r solche Dinge seit langer Zeit).  Deshalb habe ich mich entschlossen, mit den Unix-Domain-Sockets auszukommen.  Dies macht es leider unmÃ¶glich, Echo 2001: 470: dead :: babe 6666&gt; conn zu machen.  Ich habe dieses Problem mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">socat</a> : echo 2001: 470: dead :: babe 6666 | gelÃ¶st  socat - UNIX-CONNECT: conn, socat READLINE UNIX-CONNECT: alice / in. <br><br><h2>  AnfÃ¤ngliches unsicheres Protokoll </h2><br>  TCP wird als Transportmittel verwendet: Es garantiert die Lieferung und die Bestellung.  UDP garantiert weder das eine noch das andere (was nÃ¼tzlich wÃ¤re, wenn Kryptografie angewendet wird), und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SCTP-</a> UnterstÃ¼tzung in Python ist sofort <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einsatzbereit</a> . <br><br>  Leider hat TCP kein Konzept einer Nachricht, sondern nur einen Bytestrom.  Daher ist es erforderlich, ein Format fÃ¼r Nachrichten zu erstellen, damit diese in diesem Stream untereinander geteilt werden kÃ¶nnen.  Wir kÃ¶nnen uns darauf einigen, das Zeilenvorschubzeichen zu verwenden.  FÃ¼r den Anfang ist es jedoch geeignet, wenn wir beginnen, unsere Nachrichten zu verschlÃ¼sseln. Dieses Symbol kann an einer beliebigen Stelle im Chiffretext erscheinen.  Daher sind Protokolle in Netzwerken beliebt, die zuerst die LÃ¤nge der Nachricht in Bytes senden.  In Python gibt es beispielsweise standardmÃ¤ÃŸig xdrlib, mit dem Sie mit einem Ã¤hnlichen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">XDR-</a> Format arbeiten kÃ¶nnen. <br><br>  Wir werden beim TCP-Lesen nicht richtig und effizient arbeiten - wir vereinfachen den Code.  Wir lesen die Daten aus dem Socket in einer Endlosschleife, bis wir die vollstÃ¤ndige Nachricht dekodieren.  Sie kÃ¶nnen JSON auch mit XML als Format fÃ¼r diesen Ansatz verwenden.  Wenn jedoch Kryptografie hinzugefÃ¼gt wird, mÃ¼ssen die Daten signiert und authentifiziert werden - und dies erfordert eine byteweise identische Darstellung von Objekten, die JSON / XML nicht bereitstellt (Dumps kÃ¶nnen variieren). <br><br>  XDR ist fÃ¼r eine solche Aufgabe geeignet. Ich wÃ¤hle jedoch ASN.1 mit DER-Codierung und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PyDERASN-</a> Bibliothek, da wir Objekte auf hoher Ebene zur Hand haben, die oft angenehmer und bequemer zu bearbeiten sind.  Im Gegensatz zu schemenlosem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bencode</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MessagePack</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CBOR Ã¼berprÃ¼ft</a> ASN.1 Daten automatisch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anhand</a> eines fest codierten Schemas. <br><br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Msg ::= CHOICE { # text MsgText, # handshake [0] EXPLICIT MsgHandshake } class Msg(Choice): schema = (( ("text", MsgText()), ("handshake", MsgHandshake(expl=tag_ctxc(0))), )) # MsgText ::= SEQUENCE { # text UTF8String (SIZE(1..MaxTextLen))} class MsgText(Sequence): schema = (( ("text", UTF8String(bounds=(1, MaxTextLen))), )) # MsgHandshake ::= SEQUENCE { # peerName UTF8String (SIZE(1..256)) } class MsgHandshake(Sequence): schema = (( ("peerName", UTF8String(bounds=(1, 256))), ))</span></span></code> </pre> <br>  Die empfangene Nachricht ist Msg: entweder ein Text MsgText (mit bisher einem Textfeld) oder eine Handshake-Nachricht MsgHandshake (in der der Name des GesprÃ¤chspartners Ã¼bertragen wird).  Jetzt sieht es Ã¼berkompliziert aus, aber es hat die Zukunft berÃ¼hrt. <br><br><pre>      â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”
      EPeerAâ”‚ â”‚PeerBâ”‚
      â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜
         â”‚MsgHandshake (IdA) â”‚
         â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ &gt;&gt; â”‚
         â”‚ â”‚
         â”‚MsgHandshake (IdB) â”‚
         â”‚ &lt;â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
         â”‚ â”‚
         â”‚ MsgText () â”‚
         â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ &gt;&gt; â”‚
         â”‚ â”‚
         â”‚ MsgText () â”‚
         â”‚ &lt;â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
         â”‚ â”‚
</pre><br><br><h2>  IM ohne Kryptographie </h2><br>  Wie gesagt, fÃ¼r alle Operationen mit Sockets wird die Asyncio-Bibliothek verwendet.  ErklÃ¤ren Sie, was wir beim Start erwarten: <br><br><pre> <code class="python hljs">parser = argparse.ArgumentParser(description=<span class="hljs-string"><span class="hljs-string">"GOSTIM"</span></span>) parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--our-name"</span></span>, required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Our peer name"</span></span>, ) parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--their-names"</span></span>, required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Their peer names, comma-separated"</span></span>, ) parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--bind"</span></span>, default=<span class="hljs-string"><span class="hljs-string">"::1"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Address to listen on"</span></span>, ) parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--port"</span></span>, type=int, default=<span class="hljs-number"><span class="hljs-number">6666</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Port to listen on"</span></span>, ) args = parser.parse_args() OUR_NAME = UTF8String(args.our_name) THEIR_NAMES = set(args.their_names.split(<span class="hljs-string"><span class="hljs-string">","</span></span>))</code> </pre><br>  Stellen Sie Ihren eigenen Namen ein (--our-name alice).  Ein Komma listet alle erwarteten GesprÃ¤chspartner auf (- ihre Namen bob, eve).  FÃ¼r jeden der GesprÃ¤chspartner wird ein Verzeichnis mit Unix-Sockets sowie eine Coroutine fÃ¼r jeden In-, Out- und Status erstellt: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> peer_name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> THEIR_NAMES: makedirs(peer_name, mode=<span class="hljs-number"><span class="hljs-number">0o700</span></span>, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) out_queue = asyncio.Queue() OUT_QUEUES[peer_name] = out_queue asyncio.ensure_future(asyncio.start_unix_server( partial(unixsock_out_processor, out_queue=out_queue), path.join(peer_name, <span class="hljs-string"><span class="hljs-string">"out"</span></span>), )) in_queue = asyncio.Queue() IN_QUEUES[peer_name] = in_queue asyncio.ensure_future(asyncio.start_unix_server( partial(unixsock_in_processor, in_queue=in_queue), path.join(peer_name, <span class="hljs-string"><span class="hljs-string">"in"</span></span>), )) asyncio.ensure_future(asyncio.start_unix_server( partial(unixsock_state_processor, peer_name=peer_name), path.join(peer_name, <span class="hljs-string"><span class="hljs-string">"state"</span></span>), )) asyncio.ensure_future(asyncio.start_unix_server(unixsock_conn_processor, <span class="hljs-string"><span class="hljs-string">"conn"</span></span>))</code> </pre><br>  Nachrichten vom Benutzer vom Eingangssocket werden an die Warteschlange IN_QUEUES gesendet: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unixsock_in_processor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader, writer, in_queue: asyncio.Queue)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> reader.read(MaxTextLen) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> text == <span class="hljs-string"><span class="hljs-string">b""</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> in_queue.put(text.decode(<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>))</code> </pre><br>  Nachrichten von GesprÃ¤chspartnern werden an die Warteschlange OUT_QUEUES gesendet, von der Daten in den Out-Socket geschrieben werden: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unixsock_out_processor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader, writer, out_queue: asyncio.Queue)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> out_queue.get() writer.write((<span class="hljs-string"><span class="hljs-string">"[%s] %s"</span></span> % (datetime.now(), text)).encode(<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> writer.drain()</code> </pre><br>  Beim Lesen aus dem Status-Socket sucht das Programm im PEER_ALIVE-WÃ¶rterbuch nach der Adresse des GesprÃ¤chspartners.  Wenn noch keine Verbindung zum GesprÃ¤chspartner besteht, wird eine leere Zeile geschrieben. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unixsock_state_processor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader, writer, peer_name: str)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> peer_writer = PEER_ALIVES.get(peer_name) writer.write( <span class="hljs-string"><span class="hljs-string">b""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> peer_writer <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> (<span class="hljs-string"><span class="hljs-string">" "</span></span>.join([ str(i) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> peer_writer.get_extra_info(<span class="hljs-string"><span class="hljs-string">"peername"</span></span>)[:<span class="hljs-number"><span class="hljs-number">2</span></span>] ]).encode(<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>) + <span class="hljs-string"><span class="hljs-string">b"\n"</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> writer.drain() writer.close()</code> </pre><br>  Wenn eine Adresse in den Conn-Socket geschrieben wird, wird die "Initiator" -Funktion der Verbindung gestartet: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unixsock_conn_processor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader, writer)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> reader.read(<span class="hljs-number"><span class="hljs-number">256</span></span>) writer.close() host, port = data.decode(<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>).split(<span class="hljs-string"><span class="hljs-string">" "</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> initiator(host=host, port=int(port))</code> </pre><br>  Betrachten Sie den Initiator.  ZunÃ¤chst Ã¶ffnet er offensichtlich eine Verbindung zum angegebenen Host / Port und sendet eine Handshake-Nachricht mit seinem Namen: <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">130</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initiator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(host, port)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-number"><span class="hljs-number">131</span></span> _id = repr((host, port)) <span class="hljs-number"><span class="hljs-number">132</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">"%s: dialing"</span></span>, _id) <span class="hljs-number"><span class="hljs-number">133</span></span> reader, writer = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.open_connection(host, port) <span class="hljs-number"><span class="hljs-number">134</span></span> <span class="hljs-comment"><span class="hljs-comment"># Handshake message {{{ 135 writer.write(Msg(("handshake", MsgHandshake(( 136 ("peerName", OUR_NAME), 137 )))).encode()) 138 # }}} 139 await writer.drain()</span></span></code> </pre><br>  Dann wartet es auf eine Antwort von der entfernten Seite.  Versuche, die empfangene Antwort gemÃ¤ÃŸ dem Msg ASN.1-Schema zu dekodieren.  Wir gehen davon aus, dass die gesamte Nachricht von einem TCP-Segment gesendet wird und wir sie atomar empfangen, wenn .read () aufgerufen wird.  Wir Ã¼berprÃ¼fen, ob wir genau die Handshake-Nachricht erhalten haben. <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">141</span></span> <span class="hljs-comment"><span class="hljs-comment"># Wait for Handshake message {{{ 142 data = await reader.read(256) 143 if data == b"": 144 logging.warning("%s: no answer, disconnecting", _id) 145 writer.close() 146 return 147 try: 148 msg, _ = Msg().decode(data) 149 except ASN1Error: 150 logging.warning("%s: undecodable answer, disconnecting", _id) 151 writer.close() 152 return 153 logging.info("%s: got %s message", _id, msg.choice) 154 if msg.choice != "handshake": 155 logging.warning("%s: unexpected message, disconnecting", _id) 156 writer.close() 157 return 158 # }}}</span></span></code> </pre><br>  Wir Ã¼berprÃ¼fen, ob der Name der Person, mit der wir sprechen, uns bekannt ist.  Wenn nicht, trennen Sie die Verbindung.  Wir prÃ¼fen, ob wir bereits eine Verbindung zu ihm hergestellt haben (der GesprÃ¤chspartner gab erneut den Befehl, sich mit uns zu verbinden) und schlieÃŸen sie.  Python-Zeichenfolgen mit Nachrichtentext werden in die IN_QUEUES-Warteschlange gestellt, es gibt jedoch einen speziellen Wert None, der der Coroutine signalisiert, dass msg_sender nicht mehr funktioniert, damit sie ihren Writer im Zusammenhang mit der veralteten TCP-Verbindung vergisst. <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">159</span></span> msg_handshake = msg.value <span class="hljs-number"><span class="hljs-number">160</span></span> peer_name = str(msg_handshake[<span class="hljs-string"><span class="hljs-string">"peerName"</span></span>]) <span class="hljs-number"><span class="hljs-number">161</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> peer_name <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> THEIR_NAMES: <span class="hljs-number"><span class="hljs-number">162</span></span> logging.warning(<span class="hljs-string"><span class="hljs-string">"unknown peer name: %s"</span></span>, peer_name) <span class="hljs-number"><span class="hljs-number">163</span></span> writer.close() <span class="hljs-number"><span class="hljs-number">164</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">165</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">"%s: session established: %s"</span></span>, _id, peer_name) <span class="hljs-number"><span class="hljs-number">166</span></span> <span class="hljs-comment"><span class="hljs-comment"># Run text message sender, initialize transport decoder {{{ 167 peer_alive = PEER_ALIVES.pop(peer_name, None) 168 if peer_alive is not None: 169 peer_alive.close() 170 await IN_QUEUES[peer_name].put(None) 171 PEER_ALIVES[peer_name] = writer 172 asyncio.ensure_future(msg_sender(peer_name, writer)) 173 # }}}</span></span></code> </pre><br>  msg_sender akzeptiert ausgehende Nachrichten (von einem In-Socket in die Warteschlange gestellt), serialisiert sie in eine MsgText-Nachricht und sendet sie Ã¼ber eine TCP-Verbindung.  Es kann jederzeit abbrechen - wir fangen es eindeutig ab. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">msg_sender</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(peer_name: str, writer)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> in_queue = IN_QUEUES[peer_name] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> in_queue.get() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> text <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> writer.write(Msg((<span class="hljs-string"><span class="hljs-string">"text"</span></span>, MsgText(( (<span class="hljs-string"><span class="hljs-string">"text"</span></span>, UTF8String(text)), )))).encode()) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> writer.drain() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ConnectionResetError: <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> PEER_ALIVES[peer_name] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">"%s: sent %d characters message"</span></span>, peer_name, len(text))</code> </pre><br>  Am Ende tritt der Initiator in einen endlosen Zyklus des Lesens von Nachrichten aus dem Socket ein.  ÃœberprÃ¼ft, ob es sich um eine Textnachricht handelt, und stellt in die OUT_QUEUES die Warteschlange, aus der sie an den Out-Socket des entsprechenden GesprÃ¤chspartners gesendet werden.  Warum kÃ¶nnen Sie nicht einfach .read () ausfÃ¼hren und die Nachricht dekodieren?  Weil es mÃ¶glich ist, dass mehrere Nachrichten des Benutzers im Puffer des Betriebssystems zusammengefasst und von einem TCP-Segment gesendet werden.  Wir kÃ¶nnen den ersten dekodieren, und dann kann ein Teil des nachfolgenden im Puffer verbleiben.  In jedem Notfall schlieÃŸen wir die TCP-Verbindung und stoppen die msg_sender-Coroutine (indem wir None an die OUT_QUEUES-Warteschlange senden). <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">174</span></span> buf = <span class="hljs-string"><span class="hljs-string">b""</span></span> <span class="hljs-number"><span class="hljs-number">175</span></span> <span class="hljs-comment"><span class="hljs-comment"># Wait for test messages {{{ 176 while True: 177 data = await reader.read(MaxMsgLen) 178 if data == b"": 179 break 180 buf += data 181 if len(buf) &gt; MaxMsgLen: 182 logging.warning("%s: max buffer size exceeded", _id) 183 break 184 try: 185 msg, tail = Msg().decode(buf) 186 except ASN1Error: 187 continue 188 buf = tail 189 if msg.choice != "text": 190 logging.warning("%s: unexpected %s message", _id, msg.choice) 191 break 192 try: 193 await msg_receiver(msg.value, peer_name) 194 except ValueError as err: 195 logging.warning("%s: %s", err) 196 break 197 # }}} 198 logging.info("%s: disconnecting: %s", _id, peer_name) 199 IN_QUEUES[peer_name].put(None) 200 writer.close() 66 async def msg_receiver(msg_text: MsgText, peer_name: str) -&gt; None: 67 text = str(msg_text["text"]) 68 logging.info("%s: received %d characters message", peer_name, len(text)) 69 await OUT_QUEUES[peer_name].put(text)</span></span></code> </pre><br>  Kehren wir zum Hauptcode zurÃ¼ck.  Nachdem wir alle Coroutinen erstellt haben, starten wir zum Zeitpunkt des Starts des Programms den TCP-Server.  FÃ¼r jede hergestellte Verbindung erstellt er eine Responder-Coroutine. <br><br><pre> <code class="python hljs">logging.basicConfig( level=logging.INFO, format=<span class="hljs-string"><span class="hljs-string">"%(levelname)s %(asctime)s: %(funcName)s: %(message)s"</span></span>, ) loop = asyncio.get_event_loop() server = loop.run_until_complete(asyncio.start_server(responder, args.bind, args.port)) logging.info(<span class="hljs-string"><span class="hljs-string">"Listening on: %s"</span></span>, server.sockets[<span class="hljs-number"><span class="hljs-number">0</span></span>].getsockname()) loop.run_forever()</code> </pre><br>  Der Responder Ã¤hnelt dem Initiator und spiegelt dieselben Aktionen wider. Der Einfachheit halber beginnt jedoch sofort eine endlose Schleife zum Lesen von Nachrichten.  Jetzt sendet das Handshake-Protokoll eine Nachricht von jeder Seite, aber in Zukunft wird es zwei vom Initiator der Verbindung geben, wonach Textnachrichten sofort gesendet werden kÃ¶nnen. <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">72</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">responder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader, writer)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-number"><span class="hljs-number">73</span></span> _id = writer.get_extra_info(<span class="hljs-string"><span class="hljs-string">"peername"</span></span>) <span class="hljs-number"><span class="hljs-number">74</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">"%s: connected"</span></span>, _id) <span class="hljs-number"><span class="hljs-number">75</span></span> buf = <span class="hljs-string"><span class="hljs-string">b""</span></span> <span class="hljs-number"><span class="hljs-number">76</span></span> msg_expected = <span class="hljs-string"><span class="hljs-string">"handshake"</span></span> <span class="hljs-number"><span class="hljs-number">77</span></span> peer_name = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-number"><span class="hljs-number">78</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-number"><span class="hljs-number">79</span></span> <span class="hljs-comment"><span class="hljs-comment"># Read until we get Msg message {{{ 80 data = await reader.read(MaxMsgLen) 81 if data == b"": 82 logging.info("%s: closed connection", _id) 83 break 84 buf += data 85 if len(buf) &gt; MaxMsgLen: 86 logging.warning("%s: max buffer size exceeded", _id) 87 break 88 try: 89 msg, tail = Msg().decode(buf) 90 except ASN1Error: 91 continue 92 buf = tail 93 # }}} 94 if msg.choice != msg_expected: 95 logging.warning("%s: unexpected %s message", _id, msg.choice) 96 break 97 if msg_expected == "text": 98 try: 99 await msg_receiver(msg.value, peer_name) 100 except ValueError as err: 101 logging.warning("%s: %s", err) 102 break 103 # Process Handshake message {{{ 104 elif msg_expected == "handshake": 105 logging.info("%s: got %s message", _id, msg_expected) 106 msg_handshake = msg.value 107 peer_name = str(msg_handshake["peerName"]) 108 if peer_name not in THEIR_NAMES: 109 logging.warning("unknown peer name: %s", peer_name) 110 break 111 writer.write(Msg(("handshake", MsgHandshake(( 112 ("peerName", OUR_NAME), 113 )))).encode()) 114 await writer.drain() 115 logging.info("%s: session established: %s", _id, peer_name) 116 peer_alive = PEER_ALIVES.pop(peer_name, None) 117 if peer_alive is not None: 118 peer_alive.close() 119 await IN_QUEUES[peer_name].put(None) 120 PEER_ALIVES[peer_name] = writer 121 asyncio.ensure_future(msg_sender(peer_name, writer)) 122 msg_expected = "text" 123 # }}} 124 logging.info("%s: disconnecting", _id) 125 if msg_expected == "text": 126 IN_QUEUES[peer_name].put(None) 127 writer.close()</span></span></code> </pre><br><h2>  Sicheres Protokoll </h2><br>  Es ist an der Zeit, unsere Kommunikation zu sichern.  Was verstehen wir unter Sicherheit und was wollen wir: <br><br><ul><li>  Vertraulichkeit Ã¼bermittelter Nachrichten; </li><li>  AuthentizitÃ¤t und IntegritÃ¤t der Ã¼bertragenen Nachrichten - ihre Ã„nderung muss erkannt werden; </li><li>  Schutz vor Wiederholungsangriffen - Die Tatsache, dass Nachrichten verloren gegangen sind oder erneut versucht wurden, sollte erkannt werden (und wir beschlieÃŸen, die Verbindung zu trennen). </li><li>  Identifizierung und Authentifizierung von GesprÃ¤chspartnern durch vorgesteuerte Ã¶ffentliche SchlÃ¼ssel - wir haben bereits frÃ¼her entschieden, dass wir ein Freund-zu-Freund-Netzwerk aufbauen.  Erst nach der Authentifizierung werden wir verstehen, mit wem wir kommunizieren. </li><li>  Das Vorhandensein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">perfekter Forward Secrecy</a> Properties (PFS) - der Kompromiss unseres langlebigen SignaturschlÃ¼ssels sollte nicht dazu fÃ¼hren, dass die gesamte vorherige Korrespondenz gelesen werden kann.  Das Aufzeichnen von abgefangenem Verkehr wird unbrauchbar. </li><li>  GÃ¼ltigkeit / GÃ¼ltigkeit von Nachrichten (Transport und Handshakes) nur innerhalb derselben TCP-Sitzung.  Das EinfÃ¼gen korrekt signierter / authentifizierter Nachrichten aus einer anderen Sitzung (auch mit demselben GesprÃ¤chspartner) sollte nicht mÃ¶glich sein. </li><li>  Der passive Beobachter sollte keine Benutzerkennungen, langlebigen Ã¶ffentlichen SchlÃ¼ssel oder Hashes von diesen sehen.  Eine Art AnonymitÃ¤t von einem passiven Beobachter. </li></ul><br>  Ãœberraschenderweise mÃ¶chte fast jeder dieses Minimum in jedem Handshake-Protokoll haben, und nur sehr wenige der oben genannten werden letztendlich fÃ¼r selbst entwickelte Protokolle ausgefÃ¼hrt.  Jetzt werden wir also keine neuen Dinge erfinden.  Ich wÃ¼rde definitiv empfehlen, das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Noise-Framework</a> zum Erstellen von Protokollen zu verwenden, aber lassen Sie uns etwas Einfacheres wÃ¤hlen. <br><br>  Am beliebtesten sind zwei Protokolle: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TLS</a> ist ein komplexes Protokoll mit einer langen Geschichte von Fehlern, Schulen, Schwachstellen, schlechtem Durchdenken, KomplexitÃ¤t und MÃ¤ngeln (dies gilt jedoch nicht viel fÃ¼r TLS 1.3).  Aber wir betrachten es wegen der KomplexitÃ¤t nicht. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IPSec</a> mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IKE</a> - haben keine ernsthaften kryptografischen Probleme, obwohl sie auch nicht einfach sind.  Wenn Sie Ã¼ber IKEv1 und IKEv2 lesen, sind die Protokolle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STS</a> , ISO / IEC IS 9798-3 und SIGMA (SIGn-and-MAc) - einfach genug, um an einem Abend implementiert zu werden. </li></ul><br>  Wie ist SIGMA als letztes Glied bei der Entwicklung von STS / ISO-Protokollen gut?  Es erfÃ¼llt alle unsere Anforderungen (einschlieÃŸlich des â€Versteckensâ€œ der Kennungen von GesprÃ¤chspartnern) und weist keine bekannten kryptografischen Probleme auf.  Es ist minimalistisch - das Entfernen mindestens eines Elements aus der Protokollnachricht fÃ¼hrt zu seiner Unsicherheit. <br><br>  Gehen wir vom einfachsten hausgemachten Protokoll zu SIGMA.  Die grundlegendste Operation, an der wir interessiert sind, ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tastenanpassung</a> : Eine Funktion, an deren Ausgabe beide Teilnehmer denselben Wert erhalten, der als symmetrischer SchlÃ¼ssel verwendet werden kann.  Ohne auf Details einzugehen: Jede der Parteien generiert ein kurzlebiges SchlÃ¼sselpaar (nur innerhalb derselben Sitzung verwendet) (Ã¶ffentliche und private SchlÃ¼ssel), tauscht Ã¶ffentliche SchlÃ¼ssel aus, ruft die Abstimmungsfunktion auf, an deren Eingabe sie ihren privaten SchlÃ¼ssel und den Ã¶ffentlichen SchlÃ¼ssel des GesprÃ¤chspartners senden. <br><br><pre> â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”
 EPeerAâ”‚ â”‚PeerBâ”‚
 â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜
    â”‚ IdA, PubA â”‚ â”‚
    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ &gt;&gt; â”‚ rPrvA, PubA = DHgen () â•‘
    â”‚ â”‚ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    B IdB, PubB â”‚ â•” â• â• â•” â•” â•” â•” â•” â•” â•”
    â”‚ &lt;â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ â•‘â•‘rrrrrrrrrPrvB, PubB = DHgen () â•‘
    â”‚ â”‚ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    â”€â”€â”€â”€â” â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
        Ey â•‘ SchlÃ¼ssel = DH (PrvA, PubB) â•‘
    &lt;â”€â”€â”€â”˜ â•šâ•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•
    â”‚ â”‚
    â”‚ â”‚
</pre><br><br>  Jeder kann in die Mitte eingreifen und die Ã¶ffentlichen SchlÃ¼ssel durch eigene ersetzen - in diesem Protokoll gibt es keine Authentifizierung der GesprÃ¤chspartner.  FÃ¼gen Sie eine Signatur mit langlebigen SchlÃ¼sseln hinzu. <br><br><pre> â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”
 EPeerAâ”‚ â”‚PeerBâ”‚
 â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜
    â”‚IdA, PubA, Zeichen (SignPrvA, (PubA)) â”‚ â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    P â”€ â”€ â”€ â”€ ign ign ign ign ign ign ign ign ign ign ign ign ign ign ,,,,,,, SignPubA = load () â•‘
    â”‚ â”‚ â•‘PrvA, PubA = DHgen () â•‘
    â”‚ â”‚ â•šâ•â• â• â• â• â• â• â• â• â• â• â• â• â• â•
    â”‚IdB, PubB, Zeichen (SignPrvB, (PubB)) â”‚ â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â”‚ &lt;â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ignSignPrvB, SignPubB = load () â•‘
    â”‚ â”‚ â•‘PrvB, PubB = DHgen () â•‘
    â”‚ â”‚ â•šâ•â• â• â• â• â• â• â• â• â• â• â• â• â• â•
    â”€â”€â”€â”€â” â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â”‚ â”‚
        â”‚ â•‘verify (SignPubB, ...) â•‘ â”‚
    &lt;â”€â”€â”€â”˜ â•‘Key = DH (PrvA, PubB) â•‘ â”‚
    â”‚ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• â”‚
    â”‚ â”‚
</pre><br><br>  Eine solche Signatur funktioniert nicht, da sie nicht an eine bestimmte Sitzung gebunden ist.  Solche Nachrichten eignen sich auch fÃ¼r Sitzungen mit anderen Teilnehmern.  Der gesamte Kontext sollte abonniert werden.  Dies erzwingt auch das HinzufÃ¼gen einer weiteren Nachricht von A. <br><br>  DarÃ¼ber hinaus ist es wichtig, Ihre eigene Kennung als Signatur hinzuzufÃ¼gen, da wir andernfalls IdXXX ersetzen und die Nachricht mit dem SchlÃ¼ssel eines anderen bekannten GesprÃ¤chspartners neu signieren kÃ¶nnen.  Um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reflexionsangriffe</a> zu verhindern, mÃ¼ssen sich die Elemente unter der Signatur in ihrer Bedeutung an klar definierten Stellen befinden: Wenn A signiert (PubA, PubB), muss B signieren (PubB, PubA).  Dies zeigt auch, wie wichtig es ist, die Struktur und das Format der serialisierten Daten zu wÃ¤hlen.  Beispielsweise werden SÃ¤tze in der ASN.1 DER-Codierung sortiert: SET OF (PubA, PubB) ist identisch mit SET OF (PubB, PubA). <br><br><pre> â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”
 EPeerAâ”‚ â”‚PeerBâ”‚
 â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜
    â”‚ IdA, PubA â”‚ â”‚
    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€&gt; â”‚ â•‘SignPrvA, SignPubA = load () â•‘
    â”‚ â”‚ â•‘PrvA, PubA = DHgen () â•‘
    â”‚ â”‚ â•šâ•â• â• â• â• â• â• â• â• â• â• â• â• â• â•
    â”‚IdB, PubB, Zeichen (SignPrvB, (IdB, PubA, PubB)) â”‚ â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â€ SignPubB = load () â•‘
    â”‚ â”‚ â•‘PrvB, PubB = DHgen () â•‘
    â”‚ â”‚ â•šâ•â• â• â• â• â• â• â• â• â• â• â• â• â• â•
    â”‚ Zeichen (SignPrvA, (IdA, PubB, PubA)) â”‚ â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    If â”€ â”€ â”€ â”€&gt; ify ify ify ify ify ify ify ify ify ify ify ify ify ify ify ify ify ify ify ify ify ify ify ify ify ify SignPubB, ...) â•‘
    Ey â”‚ ey SchlÃ¼ssel = DH (PrvA, PubB) â•‘
    â”‚ â”‚ â•šâ•â• â• â• â• â• â• â• â• â• â• â•
    â”‚ â”‚
</pre><br><br>  Wir haben jedoch immer noch nicht â€bewiesenâ€œ, dass wir denselben gemeinsamen SchlÃ¼ssel fÃ¼r diese Sitzung entwickelt haben.  GrundsÃ¤tzlich kÃ¶nnen Sie auf diesen Schritt verzichten - die erste Transportverbindung ist ungÃ¼ltig, aber wir mÃ¶chten, dass wir nach Abschluss des Handshakes sicher sind, dass wirklich alles vereinbart ist.  Derzeit haben wir das ISO / IEC IS 9798-3-Protokoll in unseren HÃ¤nden. <br><br>  Wir kÃ¶nnten den SchlÃ¼ssel selbst unterschreiben.  Dies ist gefÃ¤hrlich, da es mÃ¶glich ist, dass der verwendete Signaturalgorithmus undicht ist (lassen Sie Bits pro Signatur, aber immer noch Lecks).  Sie kÃ¶nnen einen Hash vom generierten SchlÃ¼ssel signieren, aber selbst ein Hash-Leck vom generierten SchlÃ¼ssel kann bei einem Brute-Force-Angriff auf die Generierungsfunktion von Wert sein.  SIGMA verwendet eine MAC-Funktion, die die Absender-ID authentifiziert. <br><br><pre> â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”
 EPeerAâ”‚ â”‚PeerBâ”‚
 â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜
    â”‚ IdA, PubA â”‚ â”‚
    â”‚ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ &gt; â”‚ â•‘SignPrvA, SignPubA = load () â•‘
    â”‚ â”‚ â•‘PrvA, PubA = DHgen () â•‘
    â”‚ â”‚ â•šâ•â• â• â• â• â• â• â• â• â• â• â• â• â• â•
    â”‚IdB, PubB, Zeichen (SignPrvB, (PubA, PubB)), MAC (IdB) â”‚ â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â”‚ &lt;â”€â”€â”€â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€â”‚ â•‘SignPrvB, SignPubB = load () â•‘
    â”‚ â”‚ â•‘PrvB, PubB = DHgen () â•‘
    â”‚ â”‚ â•šâ•â• â• â• â• â• â• â• â• â• â• â• â• â• â•
    â”‚ â”‚ â•”â•â• â• â• â• â•— â•— â•— â• â•— â•— â•—
    â”‚ Zeichen (SignPrvA, (PubB, PubA)), MAC (IdA) â”‚ SchlÃ¼ssel = DH (PrvA, PubB) â•‘
    â”‚ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ &gt; â”‚ â•‘ Ã¼berprÃ¼fen (SchlÃ¼ssel, IdB) â•‘
    â”‚ â”‚ â•‘verify (SignPubB, ...) â•‘
    â”‚ â”‚ â•šâ•â• â• â• â• â• â• â• â• â• â• â•
    â”‚ â”‚
</pre><br><br>  Als Optimierung mÃ¶chten einige mÃ¶glicherweise ihre kurzlebigen SchlÃ¼ssel wiederverwenden (was fÃ¼r PFS natÃ¼rlich bedauerlich ist).  Zum Beispiel haben wir ein SchlÃ¼sselpaar generiert, versucht, eine Verbindung herzustellen, aber TCP war nicht verfÃ¼gbar oder wurde irgendwo in der Mitte des Protokolls abgebrochen.  Es ist schade, die Entropie- und Prozessorressourcen fÃ¼r ein neues Paar auszugeben.  Aus diesem Grund fÃ¼hren wir das sogenannte Cookie ein - einen Pseudozufallswert, der vor mÃ¶glichen versehentlichen Wiederholungsangriffen schÃ¼tzt, wenn kurzlebige Ã¶ffentliche SchlÃ¼ssel wiederverwendet werden.  Aufgrund der Bindung zwischen dem Cookie und dem kurzlebigen Ã¶ffentlichen SchlÃ¼ssel kann der Ã¶ffentliche SchlÃ¼ssel der Gegenpartei als unnÃ¶tig aus der Signatur entfernt werden. <br><br><pre> â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”
 EPeerAâ”‚ â”‚PeerBâ”‚
 â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜
    â”‚ IdA, PubA, CookieA â”‚ â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    â”‚ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ &gt;&gt; â”‚ â”‚ SignPrvA, SignPubA = load () â•‘
    â”‚ â”‚ â•‘PrvA, PubA = DHgen () â•‘
    â”‚ â”‚ â•šâ•â• â• â• â• â• â• â• â• â• â• â• â• â• â•
    â”‚IdB, PubB, CookieB, Zeichen (SignPrvB, (CookieA, CookieB, PubB)), MAC (IdB) â”‚ â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• â•â•â•â•—
    â”‚ &lt;â”€â”€â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ â•‘â•‘ignignignignignignignâ”‚ign SignPrvB, SignPubB = load () â•‘
    â”‚ â”‚ â•‘PrvB, PubB = DHgen () â•‘
    â”‚ â”‚ â•šâ•â• â• â• â• â• â• â• â• â• â• â• â• â• â•
    â”‚ â”‚ â•”â•â• â• â• â• â•— â•— â•— â• â•— â•— â•—
    â”‚ Zeichen (SignPrvA, (CookieB, CookieA, PubA)), MAC (IdA) â”‚ SchlÃ¼ssel = DH (PrvA, PubB) â•‘
    â”‚ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ ify ify ify ify ify ify ify ify ify ify ify ify Verify (SchlÃ¼ssel, IdB) â•‘
    â”‚ â”‚ â•‘verify (SignPubB, ...) â•‘
    â”‚ â”‚ â•šâ•â• â• â• â• â• â• â• â• â• â• â•
    â”‚ â”‚
</pre><br><br>  SchlieÃŸlich mÃ¶chten wir die PrivatsphÃ¤re unserer GesprÃ¤chspartner-IDs von einem passiven Beobachter erhalten.  Zu diesem Zweck schlÃ¤gt SIGMA vor, zunÃ¤chst kurzlebige SchlÃ¼ssel auszutauschen und einen gemeinsamen SchlÃ¼ssel fÃ¼r die Authentifizierung von Authentifizierungsnachrichten auszuarbeiten.  SIGMA beschreibt zwei Optionen: <br><br><ul><li>  SIGMA-I - schÃ¼tzt den Initiator vor aktiven Angriffen, den Responder vor passiven: Der Initiator authentifiziert den Responder und wenn etwas nicht passt, gibt er seine Identifikation nicht heraus.  Der Angeklagte gibt seinen Ausweis, wenn Sie mit ihm ein aktives Protokoll beginnen.  Der passive Beobachter wird nichts wissen; <br>  SIGMA-R - schÃ¼tzt den Responder vor aktiven Angriffen, den Initiator vor passiven.  Alles ist genau das Gegenteil, aber in diesem Protokoll werden bereits vier Handshake-Nachrichten Ã¼bertragen. <br><br><br>  Wir wÃ¤hlen SIGMA-I als Ã¤hnlicher als das, was wir von den Ã¼blichen Server-Client-Dingen erwarten: Nur ein authentifizierter Server erkennt den Client, und jeder kennt den Server trotzdem.  AuÃŸerdem ist die Implementierung aufgrund weniger Handshake-Nachrichten einfacher.  Alles, was wir dem Protokoll hinzufÃ¼gen, ist die VerschlÃ¼sselung des Nachrichtenteils und die Ãœbertragung der Kennung A an den verschlÃ¼sselten Teil der letzten Nachricht: <br><br><pre> â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”
 EPeerAâ”‚ â”‚PeerBâ”‚
 â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”¬â”€â”€â”˜
    â”‚ PubA, CookieA â”‚ â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â”‚ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ ign ign ign ign ign ign ign ign ign ign ign ign ,,,,,,, Vorzeichen Vorzeichen Vorzeichen Vorzeichen Last Last Last Last Last Last ((((((((()))))
    â”‚ â”‚ â•‘PrvA, PubA = DHgen () â•‘<font></font>
   â”‚ â”‚ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•<font></font>
   â”‚PubB, CookieB, Enc((IdB, sign(SignPrvB, (CookieA, CookieB, PubB)), MAC(IdB))) â”‚ â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—<font></font>
   â”‚&lt;â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ â•‘SignPrvB, SignPubB = load()â•‘<font></font>
   â”‚ â”‚ â•‘PrvB, PubB = DHgen() â•‘<font></font>
   â”‚ â”‚ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•<font></font>
   â”‚ â”‚ â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—<font></font>
   â”‚ Enc((IdA, sign(SignPrvA, (CookieB, CookieA, PubA)), MAC(IdA))) â”‚ â•‘Key = DH(PrvA, PubB) â•‘<font></font>
   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€&gt;â”‚ â•‘verify(Key, IdB) â•‘<font></font>
   â”‚ â”‚ â•‘verify(SignPubB, ...)â•‘<font></font>
   â”‚ â”‚ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•<font></font>
   â”‚ â”‚<font></font>
</pre><br><br><ul><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">34.10-2012</a>   256- . </li><li>      34.10-2012 VKO. </li><li>   MAC  CMAC.       ,     34.13-2015.        â€” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> (34.12-2015). </li><li>          .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">-256</a> (34.11-2012 256 ). </li></ul><br><br>        .         .         :   ,  ,  (MAC)   , .         ,    , .     , ,  ?          .   ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KDF</a> (key derivation function).  ,     - : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HKDF</a>  ,       .  ,    Python   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hkdf</a> . HKDF   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HMAC</a> , ,   ,  -.    Python   Wikipedia    .      34.10-2012,   -   -256.         ,      : <br><br><pre> <code class="python hljs">kdf = Hkdf(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, key_session, hash=GOST34112012256) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"handshake1-mac-identity"</span></span>) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"handshake1-enc"</span></span>) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"handshake1-mac"</span></span>) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"handshake2-mac-identity"</span></span>) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"handshake2-enc"</span></span>) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"handshake2-mac"</span></span>) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"transport-initiator-enc"</span></span>) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"transport-initiator-mac"</span></span>) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"transport-responder-enc"</span></span>) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"transport-responder-mac"</span></span>)</code> </pre><br><h2> / </h2><br>     ASN.1         : <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Msg</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Choice)</span></span></span><span class="hljs-class">:</span></span> schema = (( (<span class="hljs-string"><span class="hljs-string">"text"</span></span>, MsgText()), (<span class="hljs-string"><span class="hljs-string">"handshake0"</span></span>, MsgHandshake0(expl=tag_ctxc(<span class="hljs-number"><span class="hljs-number">0</span></span>))), (<span class="hljs-string"><span class="hljs-string">"handshake1"</span></span>, MsgHandshake1(expl=tag_ctxc(<span class="hljs-number"><span class="hljs-number">1</span></span>))), (<span class="hljs-string"><span class="hljs-string">"handshake2"</span></span>, MsgHandshake2(expl=tag_ctxc(<span class="hljs-number"><span class="hljs-number">2</span></span>))), )) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MsgText</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Sequence)</span></span></span><span class="hljs-class">:</span></span> schema = (( (<span class="hljs-string"><span class="hljs-string">"payload"</span></span>, MsgTextPayload()), (<span class="hljs-string"><span class="hljs-string">"payloadMac"</span></span>, MAC()), )) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MsgTextPayload</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Sequence)</span></span></span><span class="hljs-class">:</span></span> schema = (( (<span class="hljs-string"><span class="hljs-string">"nonce"</span></span>, Integer(bounds=(<span class="hljs-number"><span class="hljs-number">0</span></span>, float(<span class="hljs-string"><span class="hljs-string">"+inf"</span></span>)))), (<span class="hljs-string"><span class="hljs-string">"ciphertext"</span></span>, OctetString(bounds=(<span class="hljs-number"><span class="hljs-number">1</span></span>, MaxTextLen))), )) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MsgHandshake0</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Sequence)</span></span></span><span class="hljs-class">:</span></span> schema = (( (<span class="hljs-string"><span class="hljs-string">"cookieInitiator"</span></span>, Cookie()), (<span class="hljs-string"><span class="hljs-string">"pubKeyInitiator"</span></span>, PubKey()), )) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MsgHandshake1</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Sequence)</span></span></span><span class="hljs-class">:</span></span> schema = (( (<span class="hljs-string"><span class="hljs-string">"cookieResponder"</span></span>, Cookie()), (<span class="hljs-string"><span class="hljs-string">"pubKeyResponder"</span></span>, PubKey()), (<span class="hljs-string"><span class="hljs-string">"ukm"</span></span>, OctetString(bounds=(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>))), (<span class="hljs-string"><span class="hljs-string">"ciphertext"</span></span>, OctetString()), (<span class="hljs-string"><span class="hljs-string">"ciphertextMac"</span></span>, MAC()), )) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MsgHandshake2</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Sequence)</span></span></span><span class="hljs-class">:</span></span> schema = (( (<span class="hljs-string"><span class="hljs-string">"ciphertext"</span></span>, OctetString()), (<span class="hljs-string"><span class="hljs-string">"ciphertextMac"</span></span>, MAC()), )) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandshakeTBE</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Sequence)</span></span></span><span class="hljs-class">:</span></span> schema = (( (<span class="hljs-string"><span class="hljs-string">"identity"</span></span>, OctetString(bounds=(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>))), (<span class="hljs-string"><span class="hljs-string">"signature"</span></span>, OctetString(bounds=(<span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>))), (<span class="hljs-string"><span class="hljs-string">"identityMac"</span></span>, MAC()), )) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandshakeTBS</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Sequence)</span></span></span><span class="hljs-class">:</span></span> schema = (( (<span class="hljs-string"><span class="hljs-string">"cookieTheir"</span></span>, Cookie()), (<span class="hljs-string"><span class="hljs-string">"cookieOur"</span></span>, Cookie()), (<span class="hljs-string"><span class="hljs-string">"pubKeyOur"</span></span>, PubKey()), )) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cookie</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(OctetString)</span></span></span><span class="hljs-class">:</span></span> bounds = (<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PubKey</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(OctetString)</span></span></span><span class="hljs-class">:</span></span> bounds = (<span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MAC</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(OctetString)</span></span></span><span class="hljs-class">:</span></span> bounds = (<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>)</code> </pre><br> HandshakeTBS â€” ,    (to be signed). HandshakeTBE â€” ,    (to be encrypted).     ukm  MsgHandshake1. 34.10 VKO,      ,   UKM (user keying material) â€”   . <br><br><h2>     </h2><br>        ,      (  ,     ,       ). <br><br>           ,     -  .    JSON  : <br><br><pre> <code class="python hljs">{ <span class="hljs-string"><span class="hljs-string">"our"</span></span>: { <span class="hljs-string"><span class="hljs-string">"prv"</span></span>: <span class="hljs-string"><span class="hljs-string">"21254cf66c15e0226ef2669ceee46c87b575f37f9000272f408d0c9283355f98"</span></span>, <span class="hljs-string"><span class="hljs-string">"pub"</span></span>: <span class="hljs-string"><span class="hljs-string">"938c87da5c55b27b7f332d91b202dbef2540979d6ceaa4c35f1b5bfca6df47df0bdae0d3d82beac83cec3e353939489d9981b7eb7a3c58b71df2212d556312a1"</span></span> }, <span class="hljs-string"><span class="hljs-string">"their"</span></span>: { <span class="hljs-string"><span class="hljs-string">"alice"</span></span>: <span class="hljs-string"><span class="hljs-string">"d361a59c25d2ca5a05d21f31168609deeec100570ac98f540416778c93b2c7402fd92640731a707ec67b5410a0feae5b78aeec93c4a455a17570a84f2bc21fce"</span></span>, <span class="hljs-string"><span class="hljs-string">"bob"</span></span>: <span class="hljs-string"><span class="hljs-string">"aade1207dd85ecd283272e7b69c078d5fae75b6e141f7649ad21962042d643512c28a2dbdc12c7ba40eb704af920919511180c18f4d17e07d7f5acd49787224a"</span></span> } }</code> </pre><br> our â€”   ,     . their â€”      .        JSON : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pygost <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gost3410 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pygost.gost34112012256 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> GOST34112012256 CURVE = gost3410.GOST3410Curve( *gost3410.CURVE_PARAMS[<span class="hljs-string"><span class="hljs-string">"GostR3410_2001_CryptoPro_A_ParamSet"</span></span>] ) parser = argparse.ArgumentParser(description=<span class="hljs-string"><span class="hljs-string">"GOSTIM"</span></span>) parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--keys-gen"</span></span>, action=<span class="hljs-string"><span class="hljs-string">"store_true"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Generate JSON with our new keypair"</span></span>, ) parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--keys"</span></span>, default=<span class="hljs-string"><span class="hljs-string">"keys.json"</span></span>, required=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, help=<span class="hljs-string"><span class="hljs-string">"JSON with our and their keys"</span></span>, ) parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--bind"</span></span>, default=<span class="hljs-string"><span class="hljs-string">"::1"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Address to listen on"</span></span>, ) parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--port"</span></span>, type=int, default=<span class="hljs-number"><span class="hljs-number">6666</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Port to listen on"</span></span>, ) args = parser.parse_args() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> args.keys_gen: prv_raw = urandom(<span class="hljs-number"><span class="hljs-number">32</span></span>) pub = gost3410.public_key(CURVE, gost3410.prv_unmarshal(prv_raw)) pub_raw = gost3410.pub_marshal(pub) print(json.dumps({ <span class="hljs-string"><span class="hljs-string">"our"</span></span>: {<span class="hljs-string"><span class="hljs-string">"prv"</span></span>: hexenc(prv_raw), <span class="hljs-string"><span class="hljs-string">"pub"</span></span>: hexenc(pub_raw)}, <span class="hljs-string"><span class="hljs-string">"their"</span></span>: {}, })) exit(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Parse and unmarshal our and their keys {{{ with open(args.keys, "rb") as fd: _keys = json.loads(fd.read().decode("utf-8")) KEY_OUR_SIGN_PRV = gost3410.prv_unmarshal(hexdec(_keys["our"]["prv"])) _pub = hexdec(_keys["our"]["pub"]) KEY_OUR_SIGN_PUB = gost3410.pub_unmarshal(_pub) KEY_OUR_SIGN_PUB_HASH = OctetString(GOST34112012256(_pub).digest()) for peer_name, pub_raw in _keys["their"].items(): _pub = hexdec(pub_raw) KEYS[GOST34112012256(_pub).digest()] = { "name": peer_name, "pub": gost3410.pub_unmarshal(_pub), } # }}}</span></span></code> </pre><br>   34.10  â€”  .  256-  256-  . PyGOST     ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ,     (urandom(32))    ,  gost3410.prv_unmarshal().      ,  gost3410.public_key().   34.10 â€”   ,            ,  gost3410.pub_marshal(). <br><br>   JSON ,  , ,   ,  gost3410.pub_unmarshal().             ,              . -256   gost34112012256.GOST34112012256(),   hashlib  -. <br><br>    ? ,    :  cookie (128-  ),    34.10,     VKO   . <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">395</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initiator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(host, port)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-number"><span class="hljs-number">396</span></span> _id = repr((host, port)) <span class="hljs-number"><span class="hljs-number">397</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">"%s: dialing"</span></span>, _id) <span class="hljs-number"><span class="hljs-number">398</span></span> reader, writer = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.open_connection(host, port) <span class="hljs-number"><span class="hljs-number">399</span></span> <span class="hljs-comment"><span class="hljs-comment"># Generate our ephemeral public key and cookie, send Handshake 0 message {{{ 400 cookie_our = Cookie(urandom(16)) 401 prv = gost3410.prv_unmarshal(urandom(32)) 402 pub_our = gost3410.public_key(CURVE, prv) 403 pub_our_raw = PubKey(gost3410.pub_marshal(pub_our)) 404 writer.write(Msg(("handshake0", MsgHandshake0(( 405 ("cookieInitiator", cookie_our), 406 ("pubKeyInitiator", pub_our_raw), 407 )))).encode()) 408 # }}} 409 await writer.drain()</span></span></code> </pre><br><ul><li>      Msg ; </li><li>    handshake1; </li><li>          ; </li><li>       TBE  . </li></ul><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">423</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">"%s: got %s message"</span></span>, _id, msg.choice) <span class="hljs-number"><span class="hljs-number">424</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> msg.choice != <span class="hljs-string"><span class="hljs-string">"handshake1"</span></span>: <span class="hljs-number"><span class="hljs-number">425</span></span> logging.warning(<span class="hljs-string"><span class="hljs-string">"%s: unexpected message, disconnecting"</span></span>, _id) <span class="hljs-number"><span class="hljs-number">426</span></span> writer.close() <span class="hljs-number"><span class="hljs-number">427</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">428</span></span> <span class="hljs-comment"><span class="hljs-comment"># }}} 429 msg_handshake1 = msg.value 430 # Validate Handshake message {{{ 431 cookie_their = msg_handshake1["cookieResponder"] 432 pub_their_raw = msg_handshake1["pubKeyResponder"] 433 pub_their = gost3410.pub_unmarshal(bytes(pub_their_raw)) 434 ukm_raw = bytes(msg_handshake1["ukm"]) 435 ukm = ukm_unmarshal(ukm_raw) 436 key_session = kek_34102012256(CURVE, prv, pub_their, ukm, mode=2001) 437 kdf = Hkdf(None, key_session, hash=GOST34112012256) 438 key_handshake1_mac_identity = kdf.expand(b"handshake1-mac-identity") 439 key_handshake1_enc = kdf.expand(b"handshake1-enc") 440 key_handshake1_mac = kdf.expand(b"handshake1-mac")</span></span></code> </pre><br> UKM  64-  (urandom(8)),       ,  gost3410_vko.ukm_unmarshal(). VKO   34.10-2012 256-  gost3410_vko.kek_34102012256() (KEK â€” key encryption key). <br><br>      256-   .        HKDF .   GOST34112012256  hashlib ,        Hkdf .  (  Hkdf)   ,     -               . kdf.expand()       256-,     . <br><br>   TBE  TBS   : <br><br><ul><li>    MAC   ; </li><li>  ; </li><li>  TBE ; </li><li>            ; </li><li>    MAC   ; </li><li>    TBS ,    cookie        .      . </li></ul><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">441</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-number"><span class="hljs-number">442</span></span> peer_name = validate_tbe( <span class="hljs-number"><span class="hljs-number">443</span></span> msg_handshake1, <span class="hljs-number"><span class="hljs-number">444</span></span> key_handshake1_mac_identity, <span class="hljs-number"><span class="hljs-number">445</span></span> key_handshake1_enc, <span class="hljs-number"><span class="hljs-number">446</span></span> key_handshake1_mac, <span class="hljs-number"><span class="hljs-number">447</span></span> cookie_our, <span class="hljs-number"><span class="hljs-number">448</span></span> cookie_their, <span class="hljs-number"><span class="hljs-number">449</span></span> pub_their_raw, <span class="hljs-number"><span class="hljs-number">450</span></span> ) <span class="hljs-number"><span class="hljs-number">451</span></span> <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> err: <span class="hljs-number"><span class="hljs-number">452</span></span> logging.warning(<span class="hljs-string"><span class="hljs-string">"%s: %s, disconnecting"</span></span>, _id, err) <span class="hljs-number"><span class="hljs-number">453</span></span> writer.close() <span class="hljs-number"><span class="hljs-number">454</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">455</span></span> <span class="hljs-comment"><span class="hljs-comment"># }}} 128 def validate_tbe( 129 msg_handshake: Union[MsgHandshake1, MsgHandshake2], 130 key_mac_identity: bytes, 131 key_enc: bytes, 132 key_mac: bytes, 133 cookie_their: Cookie, 134 cookie_our: Cookie, 135 pub_key_our: PubKey, 136 ) -&gt; str: 137 ciphertext = bytes(msg_handshake["ciphertext"]) 138 mac_tag = mac(GOST3412Kuznechik(key_mac).encrypt, KUZNECHIK_BLOCKSIZE, ciphertext) 139 if not compare_digest(mac_tag, bytes(msg_handshake["ciphertextMac"])): 140 raise ValueError("invalid MAC") 141 plaintext = ctr( 142 GOST3412Kuznechik(key_enc).encrypt, 143 KUZNECHIK_BLOCKSIZE, 144 ciphertext, 145 8 * b"\x00", 146 ) 147 try: 148 tbe, _ = HandshakeTBE().decode(plaintext) 149 except ASN1Error: 150 raise ValueError("can not decode TBE") 151 key_sign_pub_hash = bytes(tbe["identity"]) 152 peer = KEYS.get(key_sign_pub_hash) 153 if peer is None: 154 raise ValueError("unknown identity") 155 mac_tag = mac( 156 GOST3412Kuznechik(key_mac_identity).encrypt, 157 KUZNECHIK_BLOCKSIZE, 158 key_sign_pub_hash, 159 ) 160 if not compare_digest(mac_tag, bytes(tbe["identityMac"])): 161 raise ValueError("invalid identity MAC") 162 tbs = HandshakeTBS(( 163 ("cookieTheir", cookie_their), 164 ("cookieOur", cookie_our), 165 ("pubKeyOur", pub_key_our), 166 )) 167 if not gost3410.verify( 168 CURVE, 169 peer["pub"], 170 GOST34112012256(tbs.encode()).digest(), 171 bytes(tbe["signature"]), 172 ): 173 raise ValueError("invalid signature") 174 return peer["name"]</span></span></code> </pre><br>    , 34.13-2015   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   </a>  34.12-2015.      ,  MAC-.  PyGOST  gost3413.mac().       (     ),   , ,  .   hardcode-  ? 34.12-2015    128-  ,    64- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> â€”    28147-89,               . <br><br>   gost.3412.GOST3412Kuznechik(key)      .encrypt()/.decrypt() ,     34.13 . MAC   : gost3413.mac(GOST3412Kuznechik(key).encrypt, KUZNECHIK_BLOCKSIZE, ciphertext).      MAC-     (==)  ,        , ,   ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BEAST</a>   TLS.  Python   hmac.compare_digest   . <br><br>         .   ,      ,    .  34.13-2015  : ECB, CTR, OFB, CBC, CFB.        .   ,        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a> ( CCM, OCB, GCM  ) â€”       MAC.   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> (CTR):       ,  ,    ,          (   CBC,      ). <br><br>   .mac(), .ctr()     : ciphertext = gost3413.ctr(GOST3412Kuznechik(key).encrypt, KUZNECHIK_BLOCKSIZE, plaintext, iv).    ,     .           (    ),      .   handshake        . <br><br>   gost3410.verify() :        (      GOSTIM ),    ( ,         ,    ), 34.11-2012     . <br><br> ,       handshake2  ,           ,  :      ,  .â€¦ <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">456</span></span> <span class="hljs-comment"><span class="hljs-comment"># Prepare and send Handshake 2 message {{{ 457 tbs = HandshakeTBS(( 458 ("cookieTheir", cookie_their), 459 ("cookieOur", cookie_our), 460 ("pubKeyOur", pub_our_raw), 461 )) 462 signature = gost3410.sign( 463 CURVE, 464 KEY_OUR_SIGN_PRV, 465 GOST34112012256(tbs.encode()).digest(), 466 ) 467 key_handshake2_mac_identity = kdf.expand(b"handshake2-mac-identity") 468 mac_tag = mac( 469 GOST3412Kuznechik(key_handshake2_mac_identity).encrypt, 470 KUZNECHIK_BLOCKSIZE, 471 bytes(KEY_OUR_SIGN_PUB_HASH), 472 ) 473 tbe = HandshakeTBE(( 474 ("identity", KEY_OUR_SIGN_PUB_HASH), 475 ("signature", OctetString(signature)), 476 ("identityMac", MAC(mac_tag)), 477 )) 478 tbe_raw = tbe.encode() 479 key_handshake2_enc = kdf.expand(b"handshake2-enc") 480 key_handshake2_mac = kdf.expand(b"handshake2-mac") 481 ciphertext = ctr( 482 GOST3412Kuznechik(key_handshake2_enc).encrypt, 483 KUZNECHIK_BLOCKSIZE, 484 tbe_raw, 485 8 * b"\x00", 486 ) 487 mac_tag = mac( 488 GOST3412Kuznechik(key_handshake2_mac).encrypt, 489 KUZNECHIK_BLOCKSIZE, 490 ciphertext, 491 ) 492 writer.write(Msg(("handshake2", MsgHandshake2(( 493 ("ciphertext", OctetString(ciphertext)), 494 ("ciphertextMac", MAC(mac_tag)), 495 )))).encode()) 496 # }}} 497 await writer.drain() 498 logging.info("%s: session established: %s", _id, peer_name)</span></span></code> </pre><br>   ,     (   ,  ,    ),       MAC-: <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">499</span></span> <span class="hljs-comment"><span class="hljs-comment"># Run text message sender, initialize transport decoder {{{ 500 key_initiator_enc = kdf.expand(b"transport-initiator-enc") 501 key_initiator_mac = kdf.expand(b"transport-initiator-mac") 502 key_responder_enc = kdf.expand(b"transport-responder-enc") 503 key_responder_mac = kdf.expand(b"transport-responder-mac") ... 509 asyncio.ensure_future(msg_sender( 510 peer_name, 511 key_initiator_enc, 512 key_initiator_mac, 513 writer, 514 )) 515 encrypter = GOST3412Kuznechik(key_responder_enc).encrypt 516 macer = GOST3412Kuznechik(key_responder_mac).encrypt 517 # }}} 519 nonce_expected = 0 520 # Wait for test messages {{{ 521 while True: 522 data = await reader.read(MaxMsgLen) ... 530 msg, tail = Msg().decode(buf) ... 537 try: 538 await msg_receiver( 539 msg.value, 540 nonce_expected, 541 macer, 542 encrypter, 543 peer_name, 544 ) 545 except ValueError as err: 546 logging.warning("%s: %s", err) 547 break 548 nonce_expected += 1 549 # }}}</span></span></code> </pre><br> msg_sender    ,    TCP-.      nonce,          .           . <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">msg_sender</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(peer_name: str, key_enc: bytes, key_mac: bytes, writer)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> nonce = <span class="hljs-number"><span class="hljs-number">0</span></span> encrypter = GOST3412Kuznechik(key_enc).encrypt macer = GOST3412Kuznechik(key_mac).encrypt in_queue = IN_QUEUES[peer_name] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> in_queue.get() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> text <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> ciphertext = ctr( encrypter, KUZNECHIK_BLOCKSIZE, text.encode(<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>), long2bytes(nonce, <span class="hljs-number"><span class="hljs-number">8</span></span>), ) payload = MsgTextPayload(( (<span class="hljs-string"><span class="hljs-string">"nonce"</span></span>, Integer(nonce)), (<span class="hljs-string"><span class="hljs-string">"ciphertext"</span></span>, OctetString(ciphertext)), )) mac_tag = mac(macer, KUZNECHIK_BLOCKSIZE, payload.encode()) writer.write(Msg((<span class="hljs-string"><span class="hljs-string">"text"</span></span>, MsgText(( (<span class="hljs-string"><span class="hljs-string">"payload"</span></span>, payload), (<span class="hljs-string"><span class="hljs-string">"payloadMac"</span></span>, MAC(mac_tag)), )))).encode()) nonce += <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>     msg_receiver,    : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">msg_receiver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( msg_text: MsgText, nonce_expected: int, macer, encrypter, peer_name: str, )</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> payload = msg_text[<span class="hljs-string"><span class="hljs-string">"payload"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> int(payload[<span class="hljs-string"><span class="hljs-string">"nonce"</span></span>]) != nonce_expected: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-string"><span class="hljs-string">"unexpected nonce value"</span></span>) mac_tag = mac(macer, KUZNECHIK_BLOCKSIZE, payload.encode()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> compare_digest(mac_tag, bytes(msg_text[<span class="hljs-string"><span class="hljs-string">"payloadMac"</span></span>])): <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-string"><span class="hljs-string">"invalid MAC"</span></span>) plaintext = ctr( encrypter, KUZNECHIK_BLOCKSIZE, bytes(payload[<span class="hljs-string"><span class="hljs-string">"ciphertext"</span></span>]), long2bytes(nonce_expected, <span class="hljs-number"><span class="hljs-number">8</span></span>), ) text = plaintext.decode(<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> OUT_QUEUES[peer_name].put(text)</code> </pre><br><h2>  Fazit </h2><br> GOSTIM       (    ,  )!      <a href=""></a> (-256 : 995bbd368c04e50a481d138c5fa2e43ec7c89bc77743ba8dbabee1fde45de120).     ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GoGOST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PyDERASN</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NNCP</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GoVPN</a> , GOSTIM   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GPLv3+</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> , Python/Go-,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> Â« â€â€œ</a> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452200/">https://habr.com/ru/post/de452200/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452186/index.html">Die seltensten und teuersten Programmiersprachen</a></li>
<li><a href="../de452188/index.html">Testen der Json-Serialisierungseinheit in Spring Boot</a></li>
<li><a href="../de452190/index.html">Verwenden von WebAssembly 20x Web Application Accelerated</a></li>
<li><a href="../de452192/index.html">Was ist das hier? Innere Operation von JavaScript-Objekten</a></li>
<li><a href="../de452198/index.html">Was sollte jeder QS-Ingenieur Ã¼ber Selen 4 wissen?</a></li>
<li><a href="../de452202/index.html">Sprint Review: Unten - Unten</a></li>
<li><a href="../de452204/index.html">Als ich meine erste KI schrieb</a></li>
<li><a href="../de452206/index.html">E - Experiment. Oder wie Wissenschaft beim Entwerfen von Schnittstellen hilft</a></li>
<li><a href="../de452210/index.html">Bot fÃ¼r VK auf Python mit MySQL in einer Stunde, Teil 2</a></li>
<li><a href="../de452212/index.html">So ziehen Sie mit Ihrem Startup in die USA: 3 echte Visumoptionen, deren Funktionen und Statistiken</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>