<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💜 🔻 🥇 Introduction aux tests unitaires dans Unity 🧓🏻 🚾 🦇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Êtes-vous curieux de savoir comment les tests unitaires fonctionnent dans Unity? Vous ne savez pas ce que sont les tests unitaires en général? Si vous...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introduction aux tests unitaires dans Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456090/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b63/9d9/71f/b639d971f3e2a10105d91bb3c94fdbb1.jpg" alt="image"></div><br>  Êtes-vous curieux de savoir comment les tests unitaires fonctionnent dans Unity?  Vous ne savez pas ce que sont les tests unitaires en général?  Si vous avez répondu positivement à ces questions, ce tutoriel vous sera utile.  De là, vous apprendrez ce qui suit sur les tests unitaires: <br><br><ul><li>  Qu'est ce que c'est </li><li>  Son avantage </li><li>  Avantages et inconvénients </li><li>  Fonctionnement dans Unity à l'aide de Test Runner </li><li>  Comment écrire et exécuter des tests unitaires qui seront testés </li></ul><br><blockquote>  <em>Remarque</em> : ce didacticiel suppose que vous connaissez le langage C # et les bases du développement dans Unity.  Si vous débutez avec Unity, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">consultez d'abord les autres didacticiels sur ce moteur</a> . </blockquote><h2>  Qu'est-ce qu'un test unitaire? </h2><br>  Avant de plonger dans le code, il est important de bien comprendre ce qu'est le test unitaire.  Autrement dit, les tests unitaires testent ... les unités. <br><br>  <em>Le test unitaire</em> (idéalement) est conçu pour tester une unité de code distincte.  La composition d'une «unité» peut varier, mais il est important de se rappeler que les tests unitaires doivent tester exactement un «élément» à la fois. <br><a name="habracut"></a><br>  Des tests unitaires doivent être créés pour vérifier qu'un petit morceau logique de code dans un scénario particulier s'exécute exactement comme prévu.  Cela peut être difficile à comprendre avant de commencer à écrire vos propres tests unitaires, alors regardons un exemple: <br><br>  Vous avez écrit une méthode qui permet à l'utilisateur d'entrer un nom.  La méthode est écrite de manière à ce que les nombres ne soient pas autorisés dans le nom, et le nom lui-même ne peut contenir que dix caractères ou moins.  Votre méthode intercepte la frappe de chaque touche et ajoute le caractère correspondant au champ de <code>name</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> name = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateNameWithCharacter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">: character</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 if (!Char.IsLetter(char)) { return; } // 2 if (name.Length &gt; 10) { return; } // 3 name += character; }</span></span></code> </pre> <br>  Que se passe-t-il ici: <br><br><ol><li>  Si le caractère n'est pas une lettre, le code pré-quitte la fonction et n'ajoute pas le caractère à la chaîne. </li><li>  Si le nom comporte dix caractères ou plus, le code ne permet pas à l'utilisateur d'ajouter un autre caractère. </li><li>  Si ces deux vérifications sont réussies, le code ajoute un caractère à la fin du nom. </li></ol><br>  Cette unité peut être testée, car il s'agit d'un "module" du travail effectué.  Les tests unitaires <i>appliquent la</i> logique des méthodes. <br><br><h2>  Exemple de test unitaire </h2><br>  Comment écrire des tests unitaires pour la méthode <code>UpdateNameWithCharacter</code> ? <br><br>  Avant de commencer à implémenter ces tests unitaires, nous devons examiner attentivement ce que font ces tests et trouver des noms pour eux. <br><br>  Jetez un œil aux exemples de nom de test unitaire ci-dessous.  D'après les noms, il doit être clair qu'ils vérifient: <br><br> <code>UpdateNameDoesntAllowCharacterAddingToNameIfNameIsTenOrMoreCharactersInLength</code> <br> <br> <code>UpdateNameAllowsLettersToBeAddedToName</code> <br> <br> <code>UpdateNameDoesntAllowNonLettersToBeAddedToName</code> <br> <br>  À partir de ces noms de méthodes de test, nous voyons que nous vérifions vraiment si «l'unité» de travail est <code>UpdateNameWithCharacter</code> par la méthode <code>UpdateNameWithCharacter</code> .  Ces noms de test peuvent sembler trop longs et trop détaillés, mais c'est bon pour nous. <br><br>  Chaque test unitaire que vous écrivez fait partie d'une suite de tests.  <em>La suite de tests</em> contient tous les tests unitaires liés au groupe logique fonctionnel (par exemple, «tests unitaires de combat»).  Si un test du kit échoue, la suite de tests entière échoue. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20d/1e7/0ed/20d1e70ed7231be0c0cfd5f6f082751c.png"></div><br><h2>  Lancement du jeu </h2><br>  Ouvrez le <em>projet Crashteroids Starter</em> (vous pouvez le télécharger à <a href="">partir d'ici</a> ), puis ouvrez la scène de <em>jeu</em> depuis le dossier <em>Assets / RW / Scenes</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/029/6fd/316/0296fd31696c7e75eeea4ec626709277.jpg"></div><br>  Cliquez sur <em>Play</em> pour lancer Crashteroids, puis cliquez sur le bouton <em>Start Game</em> .  Déplacez le vaisseau spatial avec les flèches <em>gauche</em> et <em>droite</em> du clavier. <br><br>  Pour tirer un faisceau laser, appuyez sur la <em>barre d'espace</em> .  Si le faisceau frappe l'astéroïde, alors le score augmentera de un.  Si un astéroïde entre en collision avec un navire, le navire explose et le jeu se termine (avec la possibilité de recommencer). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/cea/c40/c2fceac408455035e41f3c9c268ff448.jpg"></div><br>  Essayez de jouer un peu et assurez-vous qu'après la collision de l'astéroïde avec le navire apparaît l'inscription Game Over. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b5/55f/fa6/0b555ffa69f33fb09fb17204197af889.jpg"></div><br><h2>  Premiers pas avec Unity Test Runner </h2><br>  Maintenant que nous savons comment fonctionne le jeu, il est temps d'écrire des tests unitaires pour vérifier que tout fonctionne comme il se doit.  Ainsi, si vous (ou quelqu'un d'autre) décide de mettre à jour le jeu, vous serez sûr que la mise à jour ne cassera rien qui ait fonctionné auparavant. <br><br>  Pour écrire des tests, vous devez d'abord vous renseigner sur le lanceur de tests Unity.  <em>Test Runner</em> vous permet d'exécuter des tests et de vérifier s'ils réussissent.  Pour ouvrir le Runner de test Unity, sélectionnez <em>Fenêtre ▸ Général ▸ Runner de test</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f48/f31/aa4/f48f31aa4fc16c486b2161c75ba772af.jpg"></div><br>  Une fois le Test Runner ouvert dans une nouvelle fenêtre, vous pouvez vous simplifier la vie en cliquant sur la fenêtre du Test Runner et en le <em>faisant glisser</em> à l'endroit à côté de la fenêtre Scene. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e10/25b/408/e1025b408f785453827a962ce33aff67.gif"></div><br><h2>  Préparation de NUnit et des dossiers de test </h2><br>  Test Runner est une fonctionnalité de test unitaire fournie par Unity, mais elle utilise le framework <em>NUnit</em> .  Lorsque vous commencez à travailler avec des tests unitaires plus sérieusement, je vous recommande d'étudier le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wiki sur NUnit</a> pour en savoir plus.  Tout ce dont vous avez besoin pour la première fois sera abordé dans cet article. <br><br>  Pour exécuter les tests, nous devons d'abord créer un dossier de test dans lequel les classes de test seront stockées. <br><br>  Dans la fenêtre <em>Projet,</em> sélectionnez le dossier <em>RW</em> .  Jetez un œil à la fenêtre <em>Test Runner</em> et assurez-vous que <em>PlayMode est</em> sélectionné. <br><br>  Cliquez sur le bouton intitulé <em>Créer un dossier d'assemblage de test PlayMode</em> .  Vous verrez un nouveau dossier apparaître dans le dossier RW.  Nous sommes satisfaits du nom standard <em>Tests</em> , vous pouvez donc simplement appuyer sur <em>Entrée</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f5/be4/df3/5f5be4df386c8f262c4a3c257b55319f.gif"></div><br>  Vous vous demandez peut-être quels sont ces deux onglets différents dans Test Runner. <br><br>  L'onglet <em>PlayMode est</em> utilisé pour les tests effectués en mode Play (lorsque le jeu s'exécute en temps réel).  Les tests de l'onglet <em>EditMode sont</em> exécutés en dehors du mode Lecture, ce qui est pratique pour tester des choses comme les comportements personnalisés dans l'inspecteur. <br><br>  Dans ce tutoriel, nous couvrirons les tests PlayMode.  Mais lorsque vous vous sentez à l'aise, vous pouvez essayer d'expérimenter les tests dans EditMode.  <em>Lorsque vous travaillez avec Test Runner dans ce didacticiel, assurez-vous toujours que l'onglet PlayMode est sélectionné</em> . <br><br><h2>  Que contient la suite de tests? </h2><br>  Comme nous l'avons appris ci-dessus, un test unitaire est une fonction qui teste le comportement d'un petit morceau de code spécifique.  Le test unitaire étant une méthode, pour l'exécuter, il doit être dans le fichier de classe. <br><br>  Test Runner contourne tous les fichiers de classe de test et effectue des tests unitaires à partir d'eux.  Un fichier de classe contenant des tests unitaires est appelé une suite de tests. <br><br>  Dans la suite de tests, nous subdivisons logiquement nos tests.  Nous devons séparer le code de test en ensembles logiques distincts (par exemple, un ensemble de tests pour la physique et un ensemble distinct pour la bataille).  Dans ce tutoriel, nous n'avons besoin que d'un seul ensemble de tests, et il est temps d'en créer un. <br><br><h2>  Préparation d'un ensemble de tests et d'une suite de tests </h2><br>  Sélectionnez le dossier <em>Tests</em> et dans la fenêtre <em>Test Runner</em> cliquez sur le bouton <em>Créer un script de test dans le dossier actuel</em> .  Nommez le nouveau fichier <em>TestSuite</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/0ab/968/c640ab968dfd79a3c72e2a99bc5daa2c.gif"></div><br>  En plus du nouveau fichier C #, le moteur Unity crée également un autre fichier appelé <em>Tests.asmdef</em> .  Il s'agit du <em>fichier de définition d'assembly</em> , qui est utilisé pour montrer à Unity où se trouvent les dépendances du fichier de test.  Cela est nécessaire car le code d'application fini est contenu séparément du code de test. <br><br>  Si vous avez une situation où Unity ne peut pas trouver de fichiers de test ou de tests, assurez-vous qu'il existe un fichier de définition d'assembly qui inclut votre suite de tests.  L'étape suivante consiste à le configurer. <br><br>  Pour que le code de test ait accès aux classes de jeu, nous allons créer un assemblage du code de classe et définir le lien dans l'assemblage de tests.  Cliquez sur le dossier <em>Scripts</em> pour le sélectionner.  Cliquez avec le bouton droit sur ce dossier et sélectionnez <em>Créer Definition Définition d'assemblage</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b8/24c/84a/5b824c84ad6686493c41951751030b8d.jpg"></div><br>  Nommez le fichier <em>GameAssembly</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21b/bd6/c96/21bbd6c968426c23ea7839dd9f747355.png"></div><br>  Cliquez sur le dossier <em>Tests</em> , puis sur le fichier de définition de génération de <em>tests</em> .  Dans l' <em>inspecteur,</em> cliquez sur le bouton <em>plus</em> sous l'en-tête <em>Références de définition d'assemblage</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4be/fc3/d13/4befc3d13ea67e5ec94b707d04582a3d.png"></div><br>  Vous verrez le champ <em>Référence manquante</em> .  Cliquez sur le <em>point à</em> côté de ce champ pour ouvrir la fenêtre de sélection.  Sélectionnez le fichier <em>GameAssembly</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/727/990/57f/72799057fe5ff62ba5c997d5ec2a7563.jpg"></div><br>  Vous devriez voir le fichier d'assemblage GameAssembly dans la section des liens.  Cliquez sur le bouton <em>Appliquer</em> pour enregistrer ces modifications. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a16/bf5/259/a16bf525984f2f23b819d9b2d0e37a2b.png"></div><br>  Si vous ne suivez pas ces étapes, vous ne pourrez pas référencer les fichiers de classe du jeu dans les fichiers de test unitaire.  Après avoir traité cela, vous pouvez passer au code. <br><br><h2>  Nous écrivons le premier test unitaire </h2><br>  Double-cliquez sur le script <em>TestSuite</em> pour l'ouvrir dans l'éditeur de code.  Remplacez tout le code par ceci: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.TestTools; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> NUnit.Framework; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TestSuite</span></span> { }</code> </pre> <br>  Quels tests devons-nous passer?  Honnêtement, même dans un petit jeu comme Crashteroids, vous pouvez écrire pas mal de tests pour vérifier que tout fonctionne comme il se doit.  Dans ce didacticiel, nous nous limitons à des domaines clés: la reconnaissance des collisions et les mécanismes de jeu de base. <br><br><blockquote>  <em>Remarque</em> : lorsqu'il s'agit d'écrire des tests unitaires d'un produit à un niveau de production, vous devez payer suffisamment de temps pour prendre en compte tous les cas limites qui doivent être testés dans tous les domaines du code. </blockquote><br>  Comme premier test, il est agréable de vérifier si les astéroïdes descendent vraiment.  Il leur sera difficile d'entrer en collision avec le navire s'ils s'en éloignent!  Ajoutez la méthode et la variable privée <em>suivantes au</em> script <em>TestSuite</em> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Game game; <span class="hljs-comment"><span class="hljs-comment">// 1 [UnityTest] public IEnumerator AsteroidsMoveDown() { // 2 GameObject gameGameObject = MonoBehaviour.Instantiate(Resources.Load&lt;GameObject&gt;("Prefabs/Game")); game = gameGameObject.GetComponent&lt;Game&gt;(); // 3 GameObject asteroid = game.GetSpawner().SpawnAsteroid(); // 4 float initialYPos = asteroid.transform.position.y; // 5 yield return new WaitForSeconds(0.1f); // 6 Assert.Less(asteroid.transform.position.y, initialYPos); // 7 Object.Destroy(game.gameObject); }</span></span></code> </pre> <br>  Il n'y a que quelques lignes de code, mais elles font beaucoup de choses.  Alors arrêtons-nous et traitons chaque partie: <br><br><ol><li>  Ceci est <em>un attribut</em> .  Les attributs définissent des comportements spécifiques du compilateur.  Cet attribut indique au compilateur Unity que le code est un test unitaire.  Pour cette raison, il apparaîtra dans le Test Runner lors du démarrage des tests. </li><li>  Créez une instance de Game.  Tout le reste est intégré dans le jeu, donc lorsque nous le créerons, il contiendra tout ce qui doit être testé.  Dans un environnement de production, il est fort probable que tous les éléments ne se trouvent pas dans le même préfabriqué.  Par conséquent, vous devrez recréer tous les objets nécessaires dans la scène. </li><li>  Ici, nous créons un astéroïde afin de pouvoir surveiller s'il bouge.  La méthode <code>SpawnAsteroid</code> renvoie une instance de l'astéroïde créé.  Le composant Asteroid a une méthode <code>Move</code> (si vous êtes curieux de savoir comment fonctionne le mouvement, vous pouvez jeter un œil au script <em>Asteroid</em> dans <em>RW / Scripts</em> ). </li><li>  Le suivi de la position de départ est nécessaire pour s'assurer que l'astéroïde est descendu. </li><li>  Tous les tests unitaires Unity sont des coroutines, vous devez donc ajouter un retour progressif.  Nous ajoutons également un pas de temps de 0,1 seconde pour simuler le passage du temps pendant lequel l'astéroïde était censé descendre.  Si vous n'avez pas besoin de simuler un pas de temps, vous pouvez retourner null. </li><li>  Il s'agit de l'étape d' <em>affirmation</em> , dans laquelle nous affirmons que la position de l'astéroïde est inférieure à la position initiale (c'est-à-dire qu'elle a baissé).  La compréhension des assertions est une partie importante des tests unitaires, et NUnit propose diverses méthodes d'assertion.  La réussite ou l'échec du test est déterminé par cette ligne. </li><li>  Bien sûr, personne ne vous réprimandera pour le gâchis qui reste après la fin des tests, mais d'autres tests peuvent échouer à cause de cela.  Il est toujours important de nettoyer (supprimer ou réinitialiser) le code après le test unitaire, de sorte que lorsque vous exécutez le prochain test unitaire, il ne reste aucun artefact susceptible d'affecter ce test.  Il nous suffit de supprimer simplement l'objet du jeu, car pour chaque test, nous créons une toute nouvelle instance du jeu. </li></ol><br><h2>  Réussite des tests </h2><br>  Eh bien, vous avez écrit votre premier test unitaire, mais comment savoir si cela fonctionne?  Bien sûr, avec Test Runner!  Dans la fenêtre Test Runner, développez toutes les lignes avec des flèches.  Vous devriez voir le test <code>AsteroidsMoveDown</code> dans la liste avec des cercles gris: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4c/5d4/05a/d4c5d405a1aa5aded204806790a07233.jpg"></div><br>  Un cercle gris indique que le test n'est pas encore terminé.  Si le test a été démarré et réussi, une flèche verte s'affiche à côté.  Si le test a échoué, un X rouge s'affiche à côté de lui. Exécutez le test en cliquant sur le bouton <em>RunAll</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d45/da5/8c9/d45da58c99e0db679578aabab6e5601b.jpg"></div><br>  Cela créera une scène temporaire et exécutera le test.  Une fois terminé, vous devriez voir que le test a réussi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/640/16b/19e/64016b19e01a68544a1644b61ffb5c57.jpg"></div><br>  Vous avez réussi votre premier test unitaire indiquant que les astéroïdes créés se déplacent vers le bas. <br><br><blockquote>  <em>Remarque</em> : avant de commencer à écrire vos propres tests unitaires, vous devez comprendre l'implémentation que vous testez.  Si vous êtes curieux de savoir comment fonctionne la logique que vous testez, étudiez le code dans le dossier <em>RW / Scripts</em> . </blockquote><br><h2>  Utilisation de tests d'intégration </h2><br>  Avant d'aller plus loin dans le lapin des tests unitaires, il est temps de dire ce que sont les tests d'intégration et en quoi ils diffèrent des tests unitaires. <br><br>  <em>Les tests d'intégration</em> sont des tests qui vérifient comment les "modules" du code fonctionnent ensemble.  «Module» est un autre terme flou.  Une différence importante est que les tests d'intégration doivent tester le fonctionnement du logiciel en production réelle (c'est-à-dire quand un joueur joue vraiment à un jeu). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f01/824/6f3/f018246f3658664a77104a1fa1dc045b.png"></div><br>  Disons que vous avez créé un jeu de bataille où un joueur tue des monstres.  Vous pouvez créer un test d'intégration pour vous assurer que lorsqu'un joueur tue 100 ennemis, un succès est ouvert («Succès»). <br><br>  Ce test affectera plusieurs modules de code.  Très probablement, il concernera le moteur physique (reconnaissance des collisions), les répartiteurs ennemis (surveillance de la santé de l'ennemi et traitement des dégâts, ainsi que le passage à d'autres événements connexes) et un tracker d'événements qui suit tous les événements déclenchés (par exemple, «le monstre est tué»).  Puis, quand il est temps de débloquer la réussite, il peut appeler le gestionnaire de réussite. <br><br>  Le test d'intégration simulera le joueur tuant 100 monstres et vérifiera si le succès est débloqué.  Il est très différent du test unitaire car il teste de gros composants de code qui fonctionnent ensemble. <br><br>  Dans ce tutoriel, nous n'étudierons pas les tests d'intégration, mais cela devrait montrer la différence entre l'unité de travail (et pourquoi il est testé unitairement) et le module du code (et pourquoi il est testé d'intégration). <br><br><h2>  Ajout d'un test à une suite de tests </h2><br>  Le prochain test testera la fin du jeu lorsque le vaisseau entre en collision avec un astéroïde.  Avec <em>TestSuite</em> ouvert dans l' <em>éditeur de</em> code, ajoutez le test ci-dessous sous le premier test unitaire et enregistrez le fichier: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">UnityTest</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameOverOccursOnAsteroidCollision</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameObject gameGameObject = MonoBehaviour.Instantiate(Resources.Load&lt;GameObject&gt;(<span class="hljs-string"><span class="hljs-string">"Prefabs/Game"</span></span>)); Game game = gameGameObject.GetComponent&lt;Game&gt;(); GameObject asteroid = game.GetSpawner().SpawnAsteroid(); <span class="hljs-comment"><span class="hljs-comment">//1 asteroid.transform.position = game.GetShip().transform.position; //2 yield return new WaitForSeconds(0.1f); //3 Assert.True(game.isGameOver); Object.Destroy(game.gameObject); }</span></span></code> </pre> <br>  Nous avons déjà vu la plupart de ce code dans le test précédent, mais il existe quelques différences: <br><br><ol><li>  Nous forçons l'astéroïde et le vaisseau à entrer en collision, donnant clairement à l'astéroïde la même position que le vaisseau.  Cela créera une collision de leurs hitbox et conduira à la fin du jeu.  Si vous êtes curieux de savoir comment ce code fonctionne, jetez un œil aux fichiers <em>Ship</em> , <em>Game</em> et <em>Asteroid</em> dans le dossier Scripts. </li><li>  Un pas de temps est nécessaire pour que l'événement Collision du moteur physique se déclenche, un délai de 0,1 seconde est donc renvoyé. </li><li>  Cette déclaration est vraie et vérifie que l'indicateur <code>gameOver</code> du script Game est vrai.  Le drapeau devient vrai pendant le jeu, lorsque le navire est détruit, c'est-à-dire que nous testons pour nous assurer qu'il est réglé sur vrai après la destruction du navire. </li></ol><br>  Revenez à la fenêtre Test Runner et vous verrez qu'un nouveau test unitaire y est apparu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a8/f52/b28/4a8f52b2875ca90a37b74348435e3da5.jpg"></div><br>  Cette fois, nous exécuterons celui-ci au lieu de l'ensemble de la suite de tests.  Cliquez sur <em>GameOverOccursOnAsteroidCollision</em> , puis sur le bouton <em>Exécuter la sélection</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e2/0f5/fbd/7e20f5fbd8b4a8a6ff849fea66c90ed1.jpg"></div><br>  Et voila, nous avons passé un autre test. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/966/02f/869/96602f869c59d8218407a7ce2e57df7d.jpg"></div><br><h2>  Étapes de réglage et de destruction </h2><br>  Vous avez peut-être remarqué que dans nos deux tests, il y a du code répétitif: où l'objet Game est créé et où un lien vers le script Game est défini: <br><br><pre> <code class="cs hljs">GameObject gameGameObject = MonoBehaviour.Instantiate(Resources.Load&lt;GameObject&gt;(<span class="hljs-string"><span class="hljs-string">"Prefabs/Game"</span></span>)); game = gameGameObject.GetComponent&lt;Game&gt;();</code> </pre> <br>  Vous remarquerez également qu'il y a une répétition dans la destruction de l'objet Game: <br><br><pre> <code class="cs hljs">Object.Destroy(game.gameObject);</code> </pre> <br>  Lors des tests, cela se produit très souvent.  Lorsqu'il s'agit d'exécuter des tests unitaires, il y a en fait deux phases: la phase de <em>configuration</em> et la phase de <em>démontage</em> . <br><br>  Tout le code à l'intérieur de la méthode de configuration sera exécuté avant le test unitaire (dans cet ensemble), et tout le code à l'intérieur de la méthode Tear Down sera exécuté après le test unitaire (dans cet ensemble). <br><br>  Il est temps de simplifier nos vies en déplaçant le code de configuration et de suppression vers des méthodes spéciales.  Ouvrez l'éditeur de code et ajoutez le code suivant au début du fichier <em>TestSuite</em> , juste avant le premier attribut [UnityTest]: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">SetUp</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Setup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameObject gameGameObject = MonoBehaviour.Instantiate(Resources.Load&lt;GameObject&gt;(<span class="hljs-string"><span class="hljs-string">"Prefabs/Game"</span></span>)); game = gameGameObject.GetComponent&lt;Game&gt;(); }</code> </pre> <br>  L'attribut <code>SetUp</code> indique que cette méthode est appelée avant chaque <code>SetUp</code> test. <br><br>  Ajoutez ensuite la méthode suivante et enregistrez le fichier: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">TearDown</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Teardown</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Object.Destroy(game.gameObject); }</code> </pre> <br>  L'attribut <code>TearDown</code> indique que cette méthode est appelée après chaque <code>TearDown</code> test. <br><br>  Après avoir préparé le code de configuration et de destruction, supprimez les lignes de code présentes dans ces méthodes et remplacez-les par des appels aux méthodes correspondantes.  Après cela, le code ressemblera à ceci: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TestSuite</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Game game; [SetUp] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Setup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameObject gameGameObject = MonoBehaviour.Instantiate(Resources.Load&lt;GameObject&gt;(<span class="hljs-string"><span class="hljs-string">"Prefabs/Game"</span></span>)); game = gameGameObject.GetComponent&lt;Game&gt;(); } [TearDown] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Teardown</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Object.Destroy(game.gameObject); } [UnityTest] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsteroidsMoveDown</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameObject asteroid = game.GetSpawner().SpawnAsteroid(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> initialYPos = asteroid.transform.position.y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return new </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForSeconds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.1f</span></span></span></span></span><span class="hljs-function">)</span></span>; Assert.Less(asteroid.transform.position.y, initialYPos); } [UnityTest] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameOverOccursOnAsteroidCollision</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameObject asteroid = game.GetSpawner().SpawnAsteroid(); asteroid.transform.position = game.GetShip().transform.position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return new </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForSeconds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.1f</span></span></span></span></span><span class="hljs-function">)</span></span>; Assert.True(game.isGameOver); } }</code> </pre> <br><h2>  Test du Game Over et du tir laser </h2><br>  Après avoir préparé les méthodes de réglage et de destruction qui simplifient nos vies, nous pouvons commencer à ajouter de nouveaux tests dans lesquels ils sont utilisés.  Le test suivant consiste à vérifier que lorsqu'un joueur clique sur <em>New Game</em> , la valeur de <em>gameOver bool n'est</em> pas vraie.  Ajoutez un tel test à la fin du fichier et enregistrez-le: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">UnityTest</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewGameRestartsGame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//1 game.isGameOver = true; game.NewGame(); //2 Assert.False(game.isGameOver); yield return null; }</span></span></code> </pre> <br>  Cela devrait déjà vous sembler familier, mais il convient de mentionner ce qui suit: <br><br><ol><li>  Ce morceau de code prépare ce test pour que le drapeau booléen <code>gameOver</code> soit vrai.  Lors de l'appel de la méthode <code>NewGame</code> , il doit à nouveau définir l'indicateur sur <code>false</code> . </li><li>  Ici, nous soutenons que bool <code>isGameOver</code> est <code>false</code> , ce qui devrait être vrai lors de l'appel d'un nouveau jeu. </li></ol><br>  Revenez à Test Runner et vous devriez voir qu'il y a un nouveau test <em>NewGameRestartsGame</em> .  Exécutez ce test, comme nous l'avons fait auparavant, et vous verrez qu'il s'exécute avec succès: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b63/9d9/71f/b639d971f3e2a10105d91bb3c94fdbb1.jpg"></div><br><h2>  Déclaration du faisceau laser </h2><br>  Le prochain test consiste à ajouter le test selon lequel le faisceau laser tiré par le navire vole (semblable au premier test unitaire que nous avons écrit).  Ouvrez le fichier <em>TestSuite</em> dans l'éditeur.  Ajoutez la méthode suivante et enregistrez le fichier: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">UnityTest</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LaserMovesUp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 GameObject laser = game.GetShip().SpawnLaser(); // 2 float initialYPos = laser.transform.position.y; yield return new WaitForSeconds(0.1f); // 3 Assert.Greater(laser.transform.position.y, initialYPos); }</span></span></code> </pre> <br>  Voici ce que fait ce code: <br><br><ol><li>  Obtient un lien vers le faisceau laser généré émis par le navire. </li><li>  La position de départ est enregistrée afin que nous puissions vérifier qu'elle monte. </li><li>  Cette déclaration est cohérente avec la déclaration du test unitaire <code>AsteroidsMoveDown</code> , seulement maintenant nous affirmons que la valeur est supérieure (c'est-à-dire que le laser monte). </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enregistrez le fichier et revenez à Test Runner. </font><font style="vertical-align: inherit;">Exécutez le test </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LaserMovesUp</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et observez </font><em><font style="vertical-align: inherit;">comment</font></em><font style="vertical-align: inherit;"> il passe:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ce/a15/242/2cea152426f82ea491345ead3f0eaa94.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant, vous devriez déjà commencer à comprendre comment tout fonctionne, il est donc temps d'ajouter les deux derniers tests et de terminer le didacticiel. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vérifier que le laser détruit les astéroïdes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous nous assurerons que lorsqu'il est touché, le laser détruit l'astéroïde. </font><font style="vertical-align: inherit;">Ouvrez l'éditeur et ajoutez le </font><font style="vertical-align: inherit;">test suivant </font><font style="vertical-align: inherit;">à la fin de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TestSuite</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , puis enregistrez le fichier:</font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">UnityTest</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LaserDestroysAsteroid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 GameObject asteroid = game.GetSpawner().SpawnAsteroid(); asteroid.transform.position = Vector3.zero; GameObject laser = game.GetShip().SpawnLaser(); laser.transform.position = Vector3.zero; yield return new WaitForSeconds(0.1f); // 2 UnityEngine.Assertions.Assert.IsNull(asteroid); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voici comment cela fonctionne: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous créons un astéroïde et un faisceau laser, et leur attribuons la même position pour déclencher une collision. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'agit d'un test spécial avec une distinction importante. </font><font style="vertical-align: inherit;">Vous voyez que nous utilisons explicitement </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UnityEngine.Assertions</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour ce test </font><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">En effet, Unity a une classe </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Null</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> spéciale </font><font style="vertical-align: inherit;">qui est différente de la classe Null «régulière». </font><font style="vertical-align: inherit;">Une instruction d'infrastructure NUnit </font></font><code>Assert.IsNull()</code> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne fonctionnera pas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans les contrôles Unity pour null. </font><font style="vertical-align: inherit;">Lors de la vérification de null dans Unity, vous devez utiliser explicitement UnityEngine.Assertions.Assert, et non Assert à partir de NUnit.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Revenez à Test Runner et exécutez un nouveau test. </font><font style="vertical-align: inherit;">Vous verrez une icône verte nous plaire.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/275/80f/1b2/27580f1b206647e0a2fd09c43577ee8f.jpg"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tester ou ne pas tester - telle est la question </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La décision de s'en tenir aux tests unitaires n'est pas une décision facile et ne doit pas être prise à la légère. Cependant, les avantages des tests valent la peine. Il y a même une méthodologie de développement, appelé le </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">développement piloté par les </font><font style="vertical-align: inherit;">tests</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Test Driven Development, TDD). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En travaillant dans le cadre de TDD, vous écrivez des tests avant d'écrire la logique d'application elle-même. Tout d'abord, vous créez des tests, assurez-vous que le programme ne les réussit pas, puis écrivez uniquement du code conçu pour passer les tests. Cela peut être une approche très différente du codage, mais cela garantit que vous écrivez le code d'une manière adaptée aux tests. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gardez cela à l'esprit lorsque vous commencez à travailler sur votre prochain projet. Mais pour l'instant, il est temps d'écrire vos propres tests unitaires, pour lesquels vous avez besoin d'un jeu que nous vous avons fourni.</font></font><br><br><blockquote> <em></em> :    —    ,    .   ,           .    «» ,   ,      .   ,             .        ,        .       ,     ,            . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les tests peuvent être un gros investissement, alors considérez les avantages et les inconvénients de l'ajout de tests unitaires à votre projet: </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Avantages des tests unitaires </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les tests unitaires présentent de nombreux avantages importants, notamment: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cela donne confiance que la méthode se comporte comme prévu. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sert de documentation pour les nouvelles personnes étudiant la base de code (les tests unitaires sont parfaits pour l'enseignement). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vous fait écrire du code d'une manière testable. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Permet d'isoler et de corriger les erreurs plus rapidement. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il ne permet pas aux futures mises à jour d'ajouter de nouveaux bogues à l'ancien code de travail (ils sont appelés erreurs de régression). </font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inconvénients des tests unitaires </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, vous pouvez ne pas avoir le temps ni le budget pour les tests unitaires. </font><font style="vertical-align: inherit;">Voici ses inconvénients à considérer:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'écriture de tests peut prendre plus de temps que le code lui-même. </font></font></li><li>       . </li><li>      . </li><li> ,        . </li><li>         ,    -. </li><li>     (       ),       . </li><li> -    . </li><li> UI  . </li><li>           . </li><li>              . </li></ul><br><h2>  ,       </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est temps d'écrire le dernier test. </font><font style="vertical-align: inherit;">Ouvrez l'éditeur de code, ajoutez le code ci-dessous à la fin du fichier </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TestSuite</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et enregistrez-le:</font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">UnityTest</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyedAsteroidRaisesScore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 GameObject asteroid = game.GetSpawner().SpawnAsteroid(); asteroid.transform.position = Vector3.zero; GameObject laser = game.GetShip().SpawnLaser(); laser.transform.position = Vector3.zero; yield return new WaitForSeconds(0.1f); // 2 Assert.AreEqual(game.score, 1); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'agit d'un test important, qui vérifie que lorsqu'un joueur détruit un astéroïde, le score augmente. </font><font style="vertical-align: inherit;">Voici en quoi il consiste:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous créons un astéroïde et un faisceau laser, et les mettons dans une position. </font><font style="vertical-align: inherit;">Pour cette raison, une collision survient qui déclenche une augmentation du score.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La déclaration selon laquelle game.score est désormais de 1 (et non de 0, comme c'était le cas au début). </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enregistrez le code et revenez à Test Runner pour exécuter ce dernier test et voir s'il exécute le jeu: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5d/d4c/0ee/e5dd4c0ee4ad72e21a180621c65c11ba.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Génial! </font><font style="vertical-align: inherit;">Tous les tests ont réussi.</font></font><br><br><h2>  Où aller ensuite? </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans l'article, nous avons examiné une grande quantité d'informations. </font><font style="vertical-align: inherit;">Si vous souhaitez comparer votre travail avec le projet final, regardez-le dans les </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">archives</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dont un lien est également indiqué au début de l'article. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ce didacticiel, vous avez appris ce que sont les tests unitaires et comment les écrire dans Unity. </font><font style="vertical-align: inherit;">En outre, vous avez écrit six tests unitaires qui ont réussi le code et vous êtes familiarisé avec certains des avantages et des inconvénients des tests unitaires. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous vous sentez confiant? </font><font style="vertical-align: inherit;">Ensuite, vous pouvez écrire de nombreux autres tests. </font><font style="vertical-align: inherit;">Examinez les fichiers de classe du jeu et essayez d'écrire des tests unitaires pour d'autres parties du code. </font><font style="vertical-align: inherit;">Pensez à ajouter des tests pour les scénarios suivants:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chaque type d'astéroïde lorsque vous touchez le vaisseau mène à la fin de la partie. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Commencer une nouvelle partie réinitialise le score. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le mouvement à gauche et à droite du navire fonctionne correctement. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous souhaitez approfondir vos connaissances sur les tests unitaires, il vaut la peine d'explorer la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mise en œuvre de dépendances</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cadres pour travailler avec des objets fictifs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cela peut grandement simplifier la configuration du test. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lisez également la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentation NUnit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour en savoir plus sur le cadre NUnit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et n'hésitez pas à partager vos réflexions et vos questions sur les forums. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test réussi!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr456090/">https://habr.com/ru/post/fr456090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr456078/index.html">Projection de conflit d'entreprise sur la connectivité réseau</a></li>
<li><a href="../fr456082/index.html">Comment nous développons des recommandations de produits personnalisées</a></li>
<li><a href="../fr456084/index.html">Kubernetes 1.15: Aperçu des faits saillants</a></li>
<li><a href="../fr456086/index.html">Storyboards iOS: analyse des avantages et des inconvénients, meilleures pratiques</a></li>
<li><a href="../fr456088/index.html">Problèmes d'analyse du Big Data</a></li>
<li><a href="../fr456092/index.html">Sept signes troublants que vous dépendez des conditions météorologiques, même si vous ne le pensez pas</a></li>
<li><a href="../fr456094/index.html">Nous lisons les fiches techniques 2: SPI sur STM32; Temporisateurs et interruptions PWM sur le STM8</a></li>
<li><a href="../fr456096/index.html">Ce que fait le lecteur de geektimes moyen en planant dans les nuages</a></li>
<li><a href="../fr456100/index.html">Maintenant dans le nouvel emballage - Kingston A400 au format M.2 se précipite sur le marché</a></li>
<li><a href="../fr456102/index.html">Rapports faciles en C / C ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>