<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌎 ☢️ 👲🏽 事件处理程序缓存和React应用程序性能改进 🤯 🏮 ⤵️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今天，我们发布了该材料的译文，其作者在分析了JavaScript中使用对象的功能之后，为React开发人员提供了一种加速应用程序的方法。 特别是，我们谈论的是这样一个事实，即变量，正如他们所说的那样，是“分配了一个对象”，并且通常简称为“对象”，实际上并不存储对象本身，而是存储对象的链接。 Java...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>事件处理程序缓存和React应用程序性能改进</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/426053/"> 今天，我们发布了该材料的译文，其作者在分析了JavaScript中使用对象的功能之后，为React开发人员提供了一种加速应用程序的方法。 特别是，我们谈论的是这样一个事实，即变量，正如他们所说的那样，是“分配了一个对象”，并且通常简称为“对象”，实际上并不存储对象本身，而是存储对象的链接。  JavaScript中的函数也是对象，因此上面的内容对它们适用。 牢记这一点，设计React组件并严格分析其代码可以改善其内部机制并提高应用程序性能。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54f/6b5/80a/54f6b580affe2d9741da8207f93b4746.png"></div><br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">使用JavaScript处理对象的功能</font> </h2><br> 如果您创建了两个看起来完全相同的函数并尝试进行比较，那么从系统的角度来看，它们是不同的。 为了验证这一点，您可以执行以下代码： <br><br><pre><code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> functionOne = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> functionTwo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>); }; functionOne === functionTwo; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br> 现在，让我们尝试将一个变量分配给已经分配给另一个变量的现有函数，并比较这两个变量： <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> functionThree = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> functionFour = functionThree; functionThree === functionFour; <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br> 如您所见，使用这种方法，严格相等运算符返回<code>true</code> 。 <br> 对象自然具有相同的行为： <br><br><pre> <code class="hljs julia"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object3 = object1; object1 === object2; // <span class="hljs-literal"><span class="hljs-literal">false</span></span> object1 === object3; // <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br> 这里我们谈论的是JavaScript，但是如果您有使用其他语言进行开发的经验，那么您可能会熟悉指针的概念。 在上面的代码中，每次创建对象时，都会为其分配一部分系统内存。 当我们使用形式为<code>object1 = {}</code>的命令时，这将导致为某些数据填充专门为<code>object1</code>分配的内存。 <br><br> 很有可能将<code>object1</code>想象为与对象相关的数据结构位于内存中的地址。 命令<code>object2 = {}</code>的执行导致分配另一个专门为<code>object2</code>设计的存储区。  <code>obect1</code>和<code>object2</code>是否<code>object2</code>同一存储区中？ 不，他们每个人都有自己的情节。 这就是为什么当我们尝试比较<code>object1</code>和<code>object2</code>会得到<code>false</code> 。 这些对象可能具有相同的结构，但是它们所在的内存中的地址不同，并且在比较过程中将检查这些地址。 <br><br> 通过执行命令<code>object3 = object1</code> ，我们将<code>object1</code>的地址写入<code>object3</code>常量。 这不是一个新对象。 为该常数分配现有对象的地址。 您可以通过以下方式对此进行验证： <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = { x: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object3 = object1; object3.x = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; object1.x; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br> 在此示例中，将在内存中创建一个对象，并将其地址写入常量<code>object1</code> 。 然后，将相同的地址写入常量<code>object3</code> 。 更改<code>object3</code>更改内存中的对象。 这意味着当使用对象的任何其他引用（例如，存储在<code>object1</code>的对象）访问对象时，我们已经可以使用其修改版本。 <br><br><h2>  <font color="#3AC1EF">函数，对象和React</font> </h2><br> 新手开发人员对上述机制的误解通常会导致错误，并且也许值得一提的是，考虑使用对象的功能。 但是，今天我们的主题是React应用程序的性能。 在这个领域中，即使是经验丰富的开发人员也可能会犯错误，他们根本不会关注JavaScript变量和常量不存储在对象本身中，而只是链接到它们的事实，从而影响React应用程序。 <br><br> 这与React有什么关系？  React具有节省系统资源的智能机制，旨在改善应用程序性能：如果组件的属性和状态不变，则<code>render</code>功能不变。 显然，如果组件保持不变，则无需再次渲染。 如果没有任何变化，则<code>render</code>函数将返回与以前相同的值，因此无需执行它。 这种机制使React快速。 仅在必要时显示某些内容。 <br><br>  React使用标准的JavaScript功能检查组件的属性和状态是否相等，也就是说，它仅使用<code>==</code>运算符比较它们。  React不会对对象执行“浅”或“深”比较以确定它们的相等性。  “浅比较”是一种概念，用于描述对象的每个键值对的比较，而不是只比较内存中对象的地址（对它们的引用）的比较。 对象的“深度”比较甚至进一步进行，并且如果对象的比较属性的值也是对象，则它们还将比较这些对象的键值对。 对嵌套在其他对象中的所有对象重复此过程。  React不会做任何事情，只是检查链接是否相等。 <br><br> 例如，如果您将由<code>{ x: 1 }</code>形式的对象表示的组件的属性更改为看上去完全相同的另一个对象，React将重新渲染该组件，因为这些对象位于不同的内存区域中。 如果您还记得上面的示例，则在将组件的属性从<code>object1</code>更改为<code>object3</code> ，React不会重新渲染该组件，因为常量<code>object1</code>和<code>object3</code>引用相同的对象。 <br><br> 使用JavaScript中的函数的工作方式完全相同。 如果React遇到地址不同的相同功能，它将重新渲染。 如果“新功能”只是指向已使用功能的链接，则不会重新渲染。 <br><br><h2>  <font color="#3AC1EF">使用组件时的典型问题</font> </h2><br> 这是使用组件的一种情况，不幸的是，在检查其他人的代码时会不断遇到我： <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ get instructions() {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.do) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Click</span></span> the button: ';   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Do</span></span> <span class="hljs-type"><span class="hljs-type">NOT</span></span> click the button: '; } render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;div&gt;       {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.instructions}       &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span> onClick={() =&gt; alert('!')} /&gt;     &lt;/div&gt;   ); } }</code> </pre> <br> 在我们面前是一个非常简单的组成部分。 它是一个按钮，单击后将显示通知。 在按钮旁边显示使用说明，告知用户是否应按下该按钮。 通过设置<code>SomeComponent</code>的<code>do</code> （ <code>do={true}</code>或<code>do={false}</code> ） <code>SomeComponent</code> 。 <br><br> 每次重新渲染<code>SomeComponent</code>组件时（当<code>do</code>属性的值从<code>true</code>更改为<code>false</code> ，反之亦然），还将渲染<code>Button</code>元素。 尽管<code>onClick</code>处理程序始终是相同的，但每次调用<code>render</code>函数时都会重新创建。 结果，事实证明，每次在内存中显示该组件时，都会创建一个新函数，因为它的创建是在<code>render</code>函数中执行的，因此指向内存中新地址的链接会传递给<code>&lt;Button /&gt;</code> ，并且即使在一切都没有改变。 <br><br> 让我们来谈谈如何解决它。 <br><br><h2>  <font color="#3AC1EF">解决问题</font> </h2><br> 如果函数独立于组件（在<code>this</code>上下文中），则可以在组件外部定义它。 该组件的所有实例将使用相同的函数引用，因为在所有情况下，它将是相同的函数。 看起来是这样的： <br><br><pre> <code class="hljs scala">const createAlertBox = () =&gt; alert('!'); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ get instructions() {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.do) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Click</span></span> the button: ';   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Do</span></span> <span class="hljs-type"><span class="hljs-type">NOT</span></span> click the button: '; } render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;div&gt;       {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.instructions}       &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span> onClick={createAlertBox} /&gt;     &lt;/div&gt;   ); } }</code> </pre> <br> 与前面的示例不同，每次调用<code>render</code> <code>createAlertBox</code>都将包含指向内存中相同区域的相同链接。 结果，将不会执行<code>Button</code>重复输出。 <br><br> 尽管<code>Button</code>组件很小并且可以快速呈现，但是与函数内部声明相关的上述问题也可以在大型，复杂的组件中发现，这些组件需要花费很多时间来呈现。 这会大大降低React应用程序的速度。 在这方面，遵循建议是有意义的，根据该建议，切勿在<code>render</code>方法内声明此类函数。 <br><br> 如果函数依赖于组件，即无法在组件外部定义，则可以将组件方法作为事件处理程序传递： <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ createAlertBox = () =&gt; {   alert(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.message); }; get instructions() {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.do) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Click</span></span> the button: ';   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Do</span></span> <span class="hljs-type"><span class="hljs-type">NOT</span></span> click the button: '; } render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;div&gt;       {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.instructions}       &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span> onClick={<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createAlertBox} /&gt;     &lt;/div&gt;   ); } }</code> </pre> <br> 在这种情况下，在<code>SomeComponent</code>每个实例中<code>SomeComponent</code>当您单击按钮时，将显示各种消息。  <code>Button</code>元素的事件处理程序对于<code>SomeComponent</code>必须是唯一的。 传递<code>cteateAlertBox</code>方法时， <code>SomeComponent</code>重新渲染<code>SomeComponent</code> 。  <code>message</code>属性是否已更改都没有关系。  <code>createAlertBox</code>函数的地址不会更改，这意味着不应再次呈现<code>Button</code>元素。 因此，您可以节省系统资源并提高应用程序的渲染速度。 <br><br> 这一切都很好。 但是，如果函数是动态的呢？ <br><br><h2>  <font color="#3AC1EF">解决更复杂的问题</font> </h2><br>  <i>本材料的作者要求您注意以下事实：他准备了本节中的示例，并想到了第一件事，它适合于说明功能的重用。</i>  <i>这些示例旨在帮助读者理解该思想的实质。</i>  <i>尽管建议阅读本部分以了解正在发生的事情的本质，但作者建议您注意对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原始文章的</a>评论，因为一些读者建议了此处讨论的机制的更好版本，其中考虑了React内置的缓存失效和内存管理机制的功能。</i> <br><br> 因此，在一个组件中有很多独特的动态事件处理程序是非常普遍的，例如，在代码中可以看到类似的东西，其中在<code>render</code>方法中使用<code>map</code>数组方法： <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;ul&gt;       {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.list.map(listItem =&gt;         &lt;li key={listItem.text}&gt;           &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span> onClick={() =&gt; alert(listItem.text)} /&gt;         &lt;/li&gt;       )}     &lt;/ul&gt;   ); } }</code> </pre> <br> 在这里，将显示不同数量的按钮，并且将创建不同数量的事件处理程序，每个事件处理程序都由一个唯一的函数表示，并且预先创建<code>SomeComponent</code> ，尚不清楚这些函数将是什么。 如何解决这个难题？ <br><br> 在这里，备忘录将帮助我们，或更简单地说，是缓存。 对于每个唯一值，创建一个函数并将其放入缓存中。 如果此唯一值再次出现，则足以从缓存中获取之前已放置在缓存中的与其对应的功能。 <br><br> 这是该想法的实现形式： <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    SomeComponent        //   . clickHandlers = {}; //       //    . getClickHandler(key) {   //       ,  .   if (!Object.prototype.hasOwnProperty.call(this.clickHandlers, key)) {     this.clickHandlers[key] = () =&gt; alert(key);   }   return this.clickHandlers[key]; } render() {   return (     &lt;ul&gt;       {this.props.list.map(listItem =&gt;         &lt;li key={listItem.text}&gt;           &lt;Button onClick={this.getClickHandler(listItem.text)} /&gt;         &lt;/li&gt;       )}     &lt;/ul&gt;   ); } }</span></span></code> </pre> <br> 数组的每个元素都由<code>getClickHandler</code>方法处理。 第一次使用某个值调用此方法时，它将创建一个对该值唯一的函数，将其放入缓存中并返回。 对该方法的所有后续调用，将相同的值传递给它，将导致该方法仅从缓存返回指向该函数的链接。 <br><br> 结果，重新渲染<code>SomeComponent</code>不会重新渲染<code>Button</code> 。 同样，将元素添加到<code>list</code>属性将为每个按钮动态创建事件处理程序。 <br><br> 如果处理程序是由多个变量定义的，则需要为处理程序创建唯一标识符，但要比通过<code>map</code>方法获得的每个JSX对象通常创建唯一<code>key</code>属性的过程复杂得多。 <br><br> 在这里，我想警告您使用数组索引作为标识符的可能问题。 事实是，使用这种方法，如果数组中元素的顺序更改或删除了其中某些元素，则可能会遇到错误。 因此，例如，如果起初类似的数组看起来像<code>[ 'soda', 'pizza' ]</code> ，然后变成<code>[ 'pizza' ]</code> ，并且您使用<code>listeners[0] = () =&gt; alert('soda')</code>形式的命令来缓存事件处理程序<code>listeners[0] = () =&gt; alert('soda')</code> ，您将发现，当用户单击分配了标识符为0的处理程序且该按钮根据<code>[ 'pizza' ]</code>数组的内容应显示<code>pizza</code>消息的按钮时，将显示一个<code>soda</code>消息。 由于相同的原因，不建议将数组索引用作键属性。 <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 在本文中，我们研究了内部JavaScript机制的功能，并考虑了可以加快React应用程序渲染的速度。 我们希望这里提出的想法会派上用场。 <br><br>  <b>亲爱的读者们！</b> 如果您知道优化React应用程序的任何有趣方式，请分享它们。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN426053/">https://habr.com/ru/post/zh-CN426053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN426039/index.html">紧急发射“联盟MS-10”（船员获救，广播结束）</a></li>
<li><a href="../zh-CN426041/index.html">使用SymPy的Laplace变换方法对线性微分方程和系统的符号解</a></li>
<li><a href="../zh-CN426045/index.html">.NET中的特殊异常以及如何准备它们</a></li>
<li><a href="../zh-CN426047/index.html">英语初学者的10本好书</a></li>
<li><a href="../zh-CN426051/index.html">改善软件调试技能-一些技巧</a></li>
<li><a href="../zh-CN426055/index.html">TensorFlow.js和clmtrackr.js：在浏览器中跟踪用户凝视的方向</a></li>
<li><a href="../zh-CN426059/index.html">Tutu PHP聚会＃2：演讲视频</a></li>
<li><a href="../zh-CN426061/index.html">微软加入开放发明网络并授予60,000个许可</a></li>
<li><a href="../zh-CN426063/index.html">HPE MSA入门级阵列创新：更实惠的闪存阵列和丰富的解决方案集成</a></li>
<li><a href="../zh-CN426065/index.html">智能电视本身决定了最有趣的频道，还是一种独特的视频内容数独解决方案</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>