<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍓 🦇 👡 GPU Bound. Deuxième partie Forêt sans fin 🌋 💻 🙋🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans presque tous les jeux, il est nécessaire de remplir les niveaux de jeu avec des objets qui créent la richesse visuelle, la beauté et la variabili...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GPU Bound. Deuxième partie Forêt sans fin</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483946/"><img src="https://habrastorage.org/webt/x6/xa/8p/x6xa8poqxhxsecsbqeolxi1cwfg.jpeg"><br><br>  Dans presque tous les jeux, il est nécessaire de remplir les niveaux de jeu avec des objets qui créent la richesse visuelle, la beauté et la variabilité du monde virtuel.  Prenez n'importe quel jeu en monde ouvert.  Là, les arbres, l'herbe, la terre et l'eau sont les principaux «espaces réservés» de l'image.  Aujourd'hui, il y aura très peu de GPGPU, mais je vais essayer de vous dire comment dessiner beaucoup d'arbres et de pierres dans le cadre quand vous ne pouvez pas, mais que vous le voulez vraiment. <br><a name="habracut"></a><br>  Il convient de noter immédiatement que nous avons un petit studio indépendant, et nous n'avons souvent pas les ressources pour dessiner et modéliser chaque petite chose.  D'où la nécessité pour les différents sous-systèmes d'être une «superstructure» sur la fonctionnalité prête à l'emploi du moteur.  C'était donc dans le premier article du cycle sur les animations (là, nous avons utilisé et accéléré le système d'animation Unity terminé), donc ce sera ici.  Cela simplifie considérablement l'introduction de nouvelles fonctionnalités dans le jeu (moins à apprendre, moins de bugs, etc.). <br><br>  Donc, la tâche: vous devez dessiner beaucoup de forêt.  Le jeu, nous avons une stratégie en temps réel (RTS) avec de grands niveaux (30x30 km), et cela définit les exigences de base pour le système de rendu: <br><br><ul><li>  Avec l'aide de la minicarte, nous pouvons transférer instantanément à n'importe quel point du niveau.  Et les données sur les objets pour la nouvelle position devraient être prêtes.  Nous ne pouvons pas compter sur le chargement des ressources après un certain temps dans les jeux FPS ou TPS. </li><li>  Les objets à de si grands niveaux ont besoin d'un très grand nombre.  Des centaines de milliers, sinon des millions. </li><li>  Encore une fois, les niveaux élevés rendent très longue et difficile la configuration manuelle de "forêts".  La génération procédurale de forêt, de pierres et d'arbustes est nécessaire, mais avec la possibilité d'un ajustement et d'un agencement manuels aux endroits clés du niveau de jeu. </li></ul><br>  Comment résoudre ce problème?  Un tel nombre d'objets arrangés ordinaires de l'unité ne tirera toujours pas.  Nous mourrons dans l'abattage et la mise en lots.  Le rendu est possible en utilisant l'instanciation.  Il est nécessaire d'écrire un système de contrôle.  Les arbres doivent être modélisés.  Un système d'animation d'arbre doit être fait.  Ooh  Je le veux magnifiquement et immédiatement.  Il y a SpeedTree, mais il n'y a pas d'api pour les animations, la vue de dessus des panneaux d'affichage est terrible, car il n'y a pas de "panneau horizontal" et la documentation est pauvre.  Mais quand cela nous a-t-il arrêtés?  Nous optimiserons le rendu SpeedTree. <br><br><h4>  Rendu </h4><br>  Voyons voir si tout va si mal avec des objets Speedtree ordinaires: <br><br><img src="https://habrastorage.org/webt/im/au/qo/imauqoekeiqu1icyn-rrw82qjbg.jpeg"><br><br>  Voici environ 2 000 arbres sur scène.  Tout est en ordre avec le rendu, instanciant là les arbres en lots, mais avec le CPU tout va mal.  La moitié du temps de rendu de la caméra refroidit.  Et nous avons besoin de centaines de milliers.  Nous refusons définitivement les GameObjects, mais maintenant nous devons découvrir la structure du modèle SpeedTree, le mécanisme de commutation LOD et tout faire avec les poignées. <br><br>  L'arbre SpeedTree se compose de plusieurs niveaux de détail (généralement 4), dont le dernier est un panneau d'affichage, et tout le reste est une géométrie de divers degrés de détail.  Chacun d'eux se compose de plusieurs sabmesh, avec son propre matériau: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/FvjIYnvQARE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Ce n'est pas la spécificité de SpeedTree.  Toute structure peut avoir une telle structure.  La commutation LOD est implémentée dans deux modes disponibles: <br><br><ol><li>  Fondu croisé: <br><iframe width="560" height="315" src="https://www.youtube.com/embed/S4r4R2d0cBo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></li><li>  Arbre de vitesse: <br><iframe width="560" height="315" src="https://www.youtube.com/embed/UBspjqdvizc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></li></ol><br>  <b>CrossFade</b> (en termes de shaders Unity, il est défini par le préprocesseur LOD_FADE_CROSSFADE define) est la principale méthode de commutation LOD pour tous les objets de scène avec plusieurs niveaux de détail.  Il consiste en ce que lorsque le LOD est modifié, le maillage qui doit disparaître ne disparaît pas simplement (le saut de qualité du modèle sera clairement visible), mais «se dissout» sur l'écran à l'aide du <a href="https://digitalrune.github.io/DigitalRune-Documentation/html/fa431d48-b457-4c70-a590-d44b0840ab1e.htm" rel="nofollow">tramage</a> .  Un effet simple, et évite l'utilisation d'une véritable transparence (mélange alpha).  Le modèle qui doit apparaître exactement de la même manière "apparaît" à l'écran. <br><br>  <b>SpeedTree</b> (LOD_FADE_PERCENTAGE) est spécialement conçu pour les arbres.  En plus des coordonnées principales, les coordonnées supplémentaires de la position des sommets juniors par rapport au niveau LOD actuel sont enregistrées dans la géométrie des feuilles, des branches et du tronc.  Le degré de transition d'un niveau à un autre est la valeur de poids pour l'interpolation linéaire de ces deux positions.  Le déplacement vers / depuis le panneau d'affichage se fait à l'aide de la méthode CrossFade. <br><br>  En principe, c'est tout ce que vous devez savoir pour mettre en œuvre votre propre système de commutation LOD.  Le rendu lui-même est simple.  Nous parcourons tous les types d'arbres, à travers tous les LOD et à travers tous les sabmesh de chaque LOD.  Nous installons le matériel approprié et dessinons toutes les instances de cet objet d'un seul coup en utilisant l'instanciation.  Ainsi, le nombre de DrawCalls est égal au nombre d'objets uniques dans la scène.  Comment savons-nous quoi dessiner?  Cela nous aidera <br><br><h4>  Générateur de forêt </h4><br>  L'atterrissage lui-même est simple et sans prétention.  Pour chaque type d'arbre, nous divisons le monde en quads afin que chaque arbre corresponde à un arbre.  Nous passons en revue tous les quads et vérifions le masque du formulaire: <br><br><img src="https://habrastorage.org/webt/pk/gz/6p/pkgz6p6ehe5iqzr5xf4mt5gc7ig.jpeg"><br><br>  à un point donné du niveau, est-il possible de planter un arbre ici?  Le masque, aux endroits "boisés", est dessiné par le level designer.  Au début, tout était sur le CPU et le C #.  Le générateur fonctionnait lentement et la taille des niveaux augmentait de sorte que l'attente de la régénération pendant plusieurs dizaines de minutes devenait stressante.  Il a été décidé de transférer le générateur vers le GPU et le shader de calcul.  Ici aussi, tout est simple.  Nous avons besoin de la carte de la hauteur du terrain, du masque de plantation d'arbres et d'AppendStructuredBuffer, où nous ajoutons les arbres générés (position et ID, ce sont toutes les données). <br><br>  Disposé par des arbres à main à des points clés, un script spécial s'inscrit dans des tableaux communs et supprime l'objet d'origine de la scène. <br><br><h4>  Élimination et commutation LOD </h4><br>  Connaître la position et le type d'arbre ne suffit pas pour faire un rendu efficace.  Il est nécessaire de déterminer à chaque image quels objets sont visibles et quel LOD (compte tenu de la logique de transition) envoyer au rendu. <br><br>  Un shader de calcul spécial fera également cela.  Pour chaque objet, Frustum Culling est d'abord effectué: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_yJMYxnUTwI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Si l'objet est visible, la logique de commutation LOD est exécutée.  En fonction de la taille à l'écran, nous déterminons le niveau de LOD souhaité.  Si le mode CrossFade est défini pour le LOD du groupe, nous incrémentons le temps de transition pour le tramage.  Si SpeedTree Percentage, alors nous considérons la valeur de transition normalisée entre les LOD. <br><br>  Les API graphiques modernes ont de merveilleuses fonctions qui permettent de transmettre des informations de soumission de dessin à l'appel de dessin dans le tampon de calcul (par exemple, ID3D11DeviceContext :: DrawIndexedInstancedIndirect pour D3D11).  Cela signifie que vous pouvez également remplir ce tampon de calcul sur le GPU.  Ainsi, il s'avère que le système est entièrement indépendant du processeur (enfin, il suffit d'appeler Graphics.DrawMeshInstancedIndirect).  Dans notre cas, il suffit d'enregistrer le nombre d'instances de chaque sabmesh.  Le reste des informations (le nombre d'indices dans le maillage et les décalages) est statique. <br><br>  Le tampon de calcul, avec des arguments pour l'appel de dessin, est divisé en sections, chacune étant chargée d'appeler le rendu de son sous-maillage.  Dans le shader de calcul du maillage à dessiner dans l'image actuelle, incrémentez la valeur InstanceCount correspondante. <br><br>  Voici à quoi cela ressemble dans le rendu: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1L0ejS9yloU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  L'abattage d'occlusion GPU est la prochaine étape évidente, mais pour RTS avec un tel appareil photo, et pas de très grandes collines, les gains ne sont pas si évidents (et <a href="https://interplayoflight.wordpress.com/2017/11/15/experiments-in-gpu-based-occlusion-culling/" rel="nofollow">ici</a> c'est pour ceux qui sont intéressés).  Je ne l'ai pas encore fait. <br><br>  Pour que tout soit dessiné correctement, vous devez modifier légèrement les shaders SpeedTree pour prendre la position et les valeurs des transitions entre les LOD des tampons de calcul correspondants. <br><br>  Nous dessinons maintenant de beaux arbres statiques.  Et les arbres SpeedTree sont influencés de manière réaliste par le vent, les animant.  Toute la logique de ces animations se trouve dans le fichier SpeedTreeWind.cginc, mais il n'y a pas de documentation ou d'accès aux paramètres internes depuis Unity. <br><br><pre><code class="cpp hljs">CBUFFER_START(SpeedTreeWind) float4 _ST_WindVector; float4 _ST_WindGlobal; float4 _ST_WindBranch; float4 _ST_WindBranchTwitch; float4 _ST_WindBranchWhip; float4 _ST_WindBranchAnchor; float4 _ST_WindBranchAdherences; float4 _ST_WindTurbulences; float4 _ST_WindLeaf1Ripple; float4 _ST_WindLeaf1Tumble; float4 _ST_WindLeaf1Twitch; float4 _ST_WindLeaf2Ripple; float4 _ST_WindLeaf2Tumble; float4 _ST_WindLeaf2Twitch; float4 _ST_WindFrondRipple; float4 _ST_WindAnimation; CBUFFER_END</code> </pre> <br>  Comment pourrions-nous les choisir?  Pour ce faire, pour chaque type d'arbre, nous rendrons l'objet SpeedTree d'origine quelque part dans un endroit invisible (ou plutôt, visible dans Unity, mais pas visible dans la caméra, sinon les paramètres ne seront pas mis à jour).  Ceci peut être réalisé en augmentant considérablement le cadre de sélection et en plaçant l'objet derrière la caméra).  Chaque cadre est supprimé du jeu de valeurs souhaité à l'aide de material.GetVector (...). <br><br>  Ainsi, les arbres flottent au vent, mais la vue de dessus des panneaux d'affichage est déprimante: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/bH88-YYaHZI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Avec l'option shader BILLBOARD_FACE_CAMERA_POS encore pire: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Rl_nGbAK-Dc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Nous avons besoin de panneaux d'affichage horizontaux (de haut en bas).  Il s'agit d'une fonctionnalité SpeedTree standard depuis l'époque de King Pea, mais à en juger par les forums, elle n'est toujours pas implémentée dans Unity.  Message du <a href="https://forum.speedtree.com/forum/speedtree-modeler/using-the-speedtree-modeler/3942-horizontal-billoard-absent-in-unity" rel="nofollow">forum</a> officiel de SpeedTree: "L'intégration Unity n'a jamais utilisé le panneau d'affichage horizontal."  Nous allons attacher nos mains.  La géométrie elle-même est facile à réaliser.  Comment trouver les coordonnées UV d'un sprite dans un atlas pour elle? <br><br><img src="https://habrastorage.org/webt/wn/62/xc/wn62xcv03ojj_aub0eybezsfmi8.png"><br>  Nous obtenons l'ancien SDK SpeedTreeRT, et nous trouvons la structure dans la documentation: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SBillboard</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_bIsActive; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>* m_pTexCoords; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>* m_pCoords; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m_fAlphaTestValue; };</code> </pre><br>  "M_pTexCoords pointe vers un ensemble de 4 (s, t) coordonnées de texture qui définissent les images utilisées sur le panneau d'affichage.  m_pTexCoords contient 8 entrées. », indique-t-il dans une langue étrangère.  Eh bien, nous allons chercher une séquence de 4 valeurs à virgule flottante dans un fichier spm binaire, chacune se situant dans la plage [0..1].  Par la méthode de piquer scientifique, nous découvrons que la séquence souhaitée est devant un bloc de 12 flotteurs avec des signes correspondant au motif: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> signs[] = { <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> };</code> </pre><br>  Nous écrivons un petit utilitaire de console sur les pros, qui itère sur tous les fichiers spm et recherche des coordonnées uv pour les panneaux d'affichage horizontaux.  La sortie est une telle étiquette CSV: <br><br><pre> <code class="cpp hljs">Azalea_Desktop.spm: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.333333</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.333333</span></span>, <span class="hljs-number"><span class="hljs-number">0.666667</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.666667</span></span>, Azalea_Desktop_Flowers_1.spm: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.333333</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.333333</span></span>, <span class="hljs-number"><span class="hljs-number">0.666667</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.666667</span></span>, Azalea_Desktop_Flowers_2.spm: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.333333</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.333333</span></span>, <span class="hljs-number"><span class="hljs-number">0.666667</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.666667</span></span>, Leaf_Map_Maker_Desktop_1_Modeler_Use_Only.spm: Pattern <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found! Leaf_Map_Maker_Desktop_2_Modeler_Use_Only.spm: Pattern <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found! BarrelCactus_Cluster_Desktop_1.spm: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.592376</span></span>, <span class="hljs-number"><span class="hljs-number">0.407624</span></span>, <span class="hljs-number"><span class="hljs-number">0.592376</span></span>, <span class="hljs-number"><span class="hljs-number">0.407624</span></span>, <span class="hljs-number"><span class="hljs-number">0.184752</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.184752</span></span>, BarrelCactus_Cluster_Desktop_2.spm: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.499988</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.499988</span></span>, <span class="hljs-number"><span class="hljs-number">0.500012</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.500012</span></span>, BarrelCactus_Desktop_1.spm: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.2208</span></span>, <span class="hljs-number"><span class="hljs-number">0.220748</span></span>, <span class="hljs-number"><span class="hljs-number">0.2208</span></span>, <span class="hljs-number"><span class="hljs-number">0.220748</span></span>, <span class="hljs-number"><span class="hljs-number">5.29885e-05</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">5.29885e-05</span></span>, BarrelCactus_Desktop_2.spm: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.301392</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0.301392</span></span>, <span class="hljs-number"><span class="hljs-number">0.698608</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.698608</span></span>,</code> </pre><br>  Pour affecter des coordonnées de texture à la géométrie du panneau d'affichage horizontal, nous trouvons l'enregistrement souhaité et l'analysons. <br><br>  Maintenant, c'est comme ça: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/JICYI1PAV2E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Toujours pas très.  En utilisant le seuil de test alpha, nous atténuerons le panneau d'affichage vertical, dans les enregistrements de l'angle à la caméra: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/wxiwziYSnaA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  <b>Résumé</b> <br><br>  Profileur affichant des statistiques dynamiques (combien de choses sont rendues) et statiques (combien d'objets et leurs paramètres sont sur la scène): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/sOe8zQDbKC4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Eh bien, la belle vidéo finale (la seconde moitié montre la commutation des niveaux de qualité): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/VJMHpkiEGtY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Ce que nous avons finalement: <br><br><ul><li>  Le système est entièrement indépendant du CPU. </li><li>  Ça marche vite. </li><li>  Il utilise des actifs SpeedTree prêts à l'emploi, que vous pouvez acheter sur Internet. </li><li>  Bien sûr, je me suis fait des amis avec n'importe quel LODGroup, pas seulement avec SpeedTree.  Tant de galets sont désormais également possibles. </li></ul><br>  Parmi les lacunes, on peut noter le manque d'élimination des occlusions et des panneaux d'affichage encore peu expressifs. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr483946/">https://habr.com/ru/post/fr483946/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr483934/index.html">Autorisations de fichiers Linux</a></li>
<li><a href="../fr483936/index.html">Conférence sur le développement de jeux</a></li>
<li><a href="../fr483938/index.html">Nakamichi: à propos des dieux de l'ère de la cassette et des temps où le soleil levant brillait plus fort</a></li>
<li><a href="../fr483940/index.html">70 ans de stéréotypes: comment vaincre la méfiance à l'égard de l'Office du logement à l'aide des technologies informatiques et améliorer la qualité de service</a></li>
<li><a href="../fr483944/index.html">Comment et pourquoi faire la queue sur deux piles</a></li>
<li><a href="../fr483954/index.html">[Annonce] Global Game Jam 2020 fin janvier</a></li>
<li><a href="../fr483956/index.html">[Annonce] Global Game Jam 2020</a></li>
<li><a href="../fr483958/index.html">15 méthodes JavaScript pour travailler avec des tableaux que vous devez connaître en 2020</a></li>
<li><a href="../fr483964/index.html">N'ayez pas peur de JSON ou de votre première application API</a></li>
<li><a href="../fr483972/index.html">Comment utiliser Quora pour promouvoir votre entreprise</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>