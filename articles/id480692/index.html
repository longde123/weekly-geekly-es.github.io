<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👷🏻 👐🏽 🛸 MobX atau Redux: Mana yang Lebih Baik Untuk Bereaksi Manajemen Negara? 🚵 🐴 🍔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam JavaScript, manajemen negara adalah diskusi yang hangat akhir-akhir ini. Ketika datang untuk menerapkan manajemen negara, pengembang sering mera...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MobX atau Redux: Mana yang Lebih Baik Untuk Bereaksi Manajemen Negara?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480692/"><img src="https://habrastorage.org/webt/ih/84/tp/ih84tp1bk6iwfgmeg5khccc2qrm.jpeg"><br><br>  Dalam JavaScript, manajemen negara adalah diskusi yang hangat akhir-akhir ini.  Ketika datang untuk menerapkan manajemen negara, pengembang sering merasa kesulitan berurusan dengan kode boilerplate di Redux.  Oleh karena itu, MobX telah terbukti menjadi alternatif yang baik untuk Redux yang memberikan fungsi yang sama dengan lebih sedikit kode untuk ditulis.  Namun, kedua alat manajemen negara berfungsi baik dengan React. <br><br>  <b>Pertama mari kita lihat hal-hal umum di antara keduanya:</b> <br><br>  1) Keduanya mendukung debugging perjalanan waktu <br>  2) Keduanya berisi perpustakaan open-source <br>  3) Keduanya menyediakan manajemen negara sisi klien <br>  4) Keduanya memberikan dukungan besar untuk Bereaksi kerangka kerja asli <br><br>  Di blog ini, kami telah membuat daftar semua pro dan kontra dari kedua solusi manajemen negara.  Ini akan membantu <a href="https://www.valuecoders.com/hire-developers/hire-web-app-developers" rel="nofollow">pengembang web</a> untuk memilih yang terbaik untuk proyek mereka berikutnya.  Sebelum membahas hal ini, kami telah membandingkan Redux dan Mobx berdasarkan beberapa parameter seperti yang diberikan di bawah ini: <br><a name="habracut"></a><br>  -&gt; Pemeliharaan &amp; Scalable <br><br>  Karena adanya fungsi murni &amp; paradigma pemrograman fungsional, Redux lebih terukur &amp; terpelihara.  Oleh karena itu, hal-hal taksi mudah dikontrol dengan Redux. <br><br>  -&gt; Proses debug <br><br>  Debugging di Redux adalah pengalaman yang baik dibandingkan dengan MobX karena menyediakan alat pengembang yang mengagumkan dan hadir dengan abstraksi yang lebih sedikit.  Dengan paradigma fluks, Redux menjadi lebih mudah diprediksi.  Di sisi lain, karena lebih banyak abstraksi dan alat pengembang rata-rata, debugging di MobX jauh lebih sulit. <br><br>  -&gt; Kurva belajar <br><br>  Untuk belajar MobX itu mudah karena dilengkapi dengan kurva belajar yang mantap.  Kehadiran abstraksi maksimum membuatnya mudah dipelajari dan pengembang JavaScript yang akrab dengan konsep OOP memiliki basis di MobX.  Di sisi lain, Redux menggunakan paradigma pemrograman fungsional yang membuatnya sulit untuk dipahami secara langsung. <br><br>  -&gt; Komunitas <br><br>  Redux memiliki basis komunitas yang besar dibandingkan dengan MobX.  Karenanya, Redux memberikan dukungan komunitas yang hebat kepada pengembang kapan saja di mana saja. <br><br>  -&gt; Najis vs murni <br><br>  MobX tidak murni karena negara dapat ditimpa.  Di sini, Anda dapat dengan mudah memperbarui status dengan nilai-nilai baru.  Namun, Redux murni karena menggunakan fungsi murni.  Di sini, negara-negara hanya-baca dan tidak bisa ditimpa langsung.  Status sebelumnya diganti dengan status baru. <br><br>  -&gt; Dapat diamati vs data biasa <br><br>  MobX menggunakan observable untuk menyimpan sementara Redux menggunakan data Javascript normal untuk menyimpan nilai.  Di Redux, semua pembaruan dilacak secara manual. <br><br>  -&gt; Toko <br><br>  Toko adalah sesuatu tempat data ditempatkan.  MobX memiliki lebih dari satu toko di mana toko-toko ini dipisahkan secara logis.  Di sisi lain, Redux memiliki satu toko besar di mana semua negara disimpan.  Data biasanya dinormalisasi di Redux dan data disimpan dinormalisasi di MobX. <br><br>  <b>Redux vs MobX: Perbandingan Kode</b> <br><br>  <b><u>Alat peraga injeksi</u></b> <br><br>  Fungsi react-redux's connect () digunakan untuk melewati status dan tindakan untuk mendukung di Redux.  Itu ditunjukkan di bawah ini: <br><br>  // mengakses alat peraga <br><br><pre><code class="markdown hljs"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ContactForm</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">contact</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.props.contact}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">loading</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.props.loading}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onSubmit</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.submit}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span></span></code> </pre> <br><br>  // berfungsi untuk menyuntikkan status ke alat peraga <br><br><pre> <code class="markdown hljs">function mapStateToProps(state) { return { contact: state.contactStore.contact, errors: state.contactStore.errors } }</code> </pre> <br><br>  // menyuntikkan status dan tindakan ke dalam alat peraga <br><br><pre> <code class="markdown hljs">export default connect(mapStateToProps, { newContact, saveContact, fetchContact, updateContact })(ContactFormPage);</code> </pre> <br><br>  Di MobX, <a href="https://habr.com/en/users/inject/" class="user_link">inject</a> digunakan untuk menyuntikkan koleksi toko.  Ini akan membuat toko tersedia dalam alat peraga.  Di sini, status dan tindakan diakses melalui properti di objek toko sehingga tidak perlu melewatinya secara terpisah. <br><br><pre> <code class="markdown hljs">@inject("stores") @observer // injecting store into props class ContactFormPage extends Component { … // accessing store via props const { contactStore:store } = this.props.stores; return ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ContactForm</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">store</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{store}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">form</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.form}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">contact</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{store.entity}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span></span> ) … }</code> </pre> <br><br>  Oleh karena itu, kami menggunakan redux-connect-decorators untuk menyederhanakan kode Redux dan versi MobX selalu mudah dibaca.  Makanya, tidak ada pemenang yang jelas. <br><br>  <b><u>Bootstrap</u></b> <br><br>  Di Redux, pertama, tentukan store dan App diteruskan melalui Penyedia.  Untuk menangani fungsi asinkron, Anda juga perlu mendefinisikan redux-thunk dan redux-janji-middleware.  Setelah ini, ekstensi redux-devtools memungkinkan penyimpanan debugging dalam mode perjalanan waktu. <br><br><pre> <code class="markdown hljs">import { applyMiddleware, createStore } from "redux"; import thunk from "redux-thunk"; import promise from "redux-promise-middleware"; import { composeWithDevTools } from 'redux-devtools-extension'; import rootReducer from "./reducers"; const middleware = composeWithDevTools(applyMiddleware(promise(), thunk)); export default createStore(rootReducer, middleware);</code> </pre> <br><br>  // src / index.js <br><br><pre> <code class="markdown hljs">ReactDOM.render( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">BrowserRouter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">store</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{store}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">BrowserRouter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>, document.getElementById('root') );</code> </pre> <br><br>  Di MobX, beberapa toko disiapkan.  Tidak perlu pustaka eksternal untuk menangani tindakan async tetapi hanya beberapa baris kode.  Anda memerlukan mobx-remotedev untuk menghubungkan alat debugging redux-devtools-extension. <br><br><br><br><pre> <code class="markdown hljs">import remotedev from 'mobx-remotedev'; import Store from './store'; const contactConfig = { name:'Contact Store', global: true, onlyActions:true, filters: { whitelist: /fetch|update|create|Event|entity|entities|handleErrors/ } }; const contactStore = new Store('api/contacts'); const allStores = { contactStore: remotedev(contactStore, contactConfig) }; export default allStores;</code> </pre> <br><br>  // src / index.js <br><br><pre> <code class="markdown hljs">ReactDOM.render( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">BrowserRouter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">stores</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{allStores}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Provider</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">BrowserRouter</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>, document.getElementById('root') );</code> </pre> <br><br>  Namun jumlah kode yang digunakan keduanya sama.  Tapi, MobX mengandung lebih sedikit pernyataan impor. <br><br>  <b><u>Menentukan tindakan &amp; reduksi</u></b> <br><br>  Tindakan &amp; reduksi didefinisikan di Redux dengan kode berikut: <br><br>  // tindakan <br><br><pre> <code class="markdown hljs">export function fetchContacts(){ return dispatch =&gt; { dispatch({ type: 'FETCH_CONTACTS', payload: client.get(url) }) } }</code> </pre> <br><br>  // reduksi <br><br><pre> <code class="markdown hljs">switch (action.type) { case 'FETCH<span class="hljs-emphasis"><span class="hljs-emphasis">_CONTACTS_</span></span>FULFILLED': { return { ...state, contacts: action.payload.data.data || action.payload.data, loading: false, errors: {} } } case 'FETCH<span class="hljs-emphasis"><span class="hljs-emphasis">_CONTACTS_</span></span>PENDING': { return { ...state, loading: true, errors: {} } } case 'FETCH<span class="hljs-emphasis"><span class="hljs-emphasis">_CONTACTS_</span></span>REJECTED': { return { ...state, loading: false, errors: { global: action.payload.message } } } }</code> </pre> <br><br>  Logika untuk aksi &amp; peredam dilakukan dalam satu kelas di MobX.  Ia menggunakan OOP yang dengannya kelas Store dire-refactored untuk membuat beberapa toko menggunakan konstruktor kelas.  Kode masing-masing ditunjukkan di bawah ini: <br><br><pre> <code class="markdown hljs">@action fetchAll = async() =&gt; { this.loading = true; this.errors = {}; try { const response = await this.service.find({}) runInAction('entities fetched', () =&gt; { this.entities = response.data; this.loading = false; }); } catch(err) { this.handleErrors(err); } }</code> </pre> <br><br>  Jadi, kita telah melihat bahwa logika yang didefinisikan dalam kedua solusi manajemen negara melakukan pekerjaan yang sama.  Satu-satunya perbedaan adalah bahwa kami telah menggunakan 33 baris kode di Redux dan 14 baris kode di MobX untuk mencapai hasil.  Karenanya, Anda dapat membangun aplikasi lebih cepat dengan MobX. <br><br>  <b>Mengapa menggunakan MobX untuk Bereaksi aplikasi?</b> <br><br>  MobX adalah pustaka teruji yang membuat manajemen negara menjadi sederhana &amp; dapat diskalakan dengan menerapkan pemrograman reaktif fungsional (TFRP) secara transparan.  Bereaksi dan MobX adalah kombinasi yang kuat bersama. <br><br><ul><li>  Lebih sedikit kode untuk ditulis </li><li>  Mudah dipelajari </li><li>  Data bersarang mudah </li><li>  Dukungan untuk pemrograman berorientasi objek </li></ul><br><br>  <b>Mengapa tidak menggunakan MobX?</b> <br><br><ul><li>  Sulit di-debug </li><li>  Alternatif yang lebih baik hadir </li><li>  Memberikan terlalu banyak kebebasan </li></ul><br><br>  <b>Mengapa menggunakan Redux untuk Bereaksi aplikasi?</b> <br><br>  Redux adalah perpustakaan mandiri yang dapat digunakan dengan kerangka kerja UI termasuk Angular, Vue, Ember, React &amp; vanilla JS. <br><br><ul><li>  Ekstensibilitas melalui middlewares </li><li>  Popularitas &amp; komunitas </li><li>  Dukungan perkakas </li><li>  Prediktabilitas &amp; kesederhanaan </li><li>  Aliran data searah &amp; kekekalan </li><li>  Pemisahan data &amp; presentasi </li></ul><br><br>  <b>Mengapa tidak menggunakan Redux?</b> <br><br><ul><li>  Pelat boiler (pengecil, penyeleksi, tampilan, jenis tindakan, pembuat tindakan, ...) </li><li>  Tindakan terputus dari efeknya (sebagaimana didefinisikan dalam peredam) </li><li>  Tidak ada solusi out-of-the-box untuk menangani efek samping (tersedia melalui middlewares seperti redux-thunk atau redux-saga) </li></ul><br><br>  <b>Catatan Akhir:</b> <br><br>  Sekarang, Anda dapat melihat bahwa basis kode MobX jauh lebih gesit.  Menggunakan gaya OOP dan praktik pengembangan yang baik, Anda dapat dengan cepat membuat aplikasi Bereaksi.  Kerugian utama adalah sangat mudah untuk menulis kode yang buruk dan tidak mungkin untuk mempertahankannya. <br><br>  Di sisi lain, Redux populer dan cocok untuk membangun proyek besar &amp; kompleks.  Ini adalah kerangka kerja yang ketat dengan perlindungan yang memastikan bahwa setiap pengembang menulis kode yang mudah diuji dan dipelihara.  Namun, ini tidak cocok untuk proyek kecil. <br><br>  Saya harap saya telah memberikan informasi yang cukup untuk mengklarifikasi apakah akan bermigrasi ke MobX atau melanjutkan dengan Redux.  Pada akhirnya, keputusan tergantung pada jenis proyek yang sedang Anda kerjakan dan sumber daya yang tersedia untuk Anda. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480692/">https://habr.com/ru/post/id480692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480682/index.html">Intel RealSense LiDAR L515 - RealSense Baru Lainnya</a></li>
<li><a href="../id480684/index.html">Kepingan Salju StarWars DIY (pembaruan 2019)</a></li>
<li><a href="../id480686/index.html">Mengapa saya menolak solusi lintas platform dalam pengembangan ponsel</a></li>
<li><a href="../id480688/index.html">Dari mana datangnya Mojibakes? Esensi penyandian</a></li>
<li><a href="../id480690/index.html">Kami mengelola blind inch dengan murah</a></li>
<li><a href="../id480694/index.html">Bisakah kita berhenti memanggil aksesibilitas dan kegunaan UX?</a></li>
<li><a href="../id480700/index.html">Kami menggunakan console.log () di Chrome hingga penuh</a></li>
<li><a href="../id480702/index.html">SDM dan talenta, pakar dan kreatif: bagaimana Habraseminar yang kedelapan</a></li>
<li><a href="../id480704/index.html">Membuat konten responsif dimuat di situs</a></li>
<li><a href="../id480708/index.html">Dekade akan segera berakhir. Aplikasi apa di Google Play yang paling banyak diunduh dalam 10 tahun terakhir?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>