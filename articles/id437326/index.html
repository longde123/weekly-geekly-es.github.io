<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ… ğŸ¤½ğŸ½ ğŸ˜³ Pada masalah multiplikasi, ekstraksi akar kuadrat, substitusi impor dan Milander perusahaan ğŸ“– ğŸ•´ğŸ» ğŸ“¤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Entropi, sumber ergodik, ruang pesan multidimensi, bit, polisemi, proses Markov - semua kata-kata ini terdengar sangat mengesankan, dalam urutan apa ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pada masalah multiplikasi, ekstraksi akar kuadrat, substitusi impor dan Milander perusahaan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437326/"><h4>  "Entropi, sumber ergodik, ruang pesan multidimensi, bit, polisemi, proses Markov - semua kata-kata ini terdengar sangat mengesankan, dalam urutan apa pun mereka ditempatkan.  Jika Anda mengaturnya dalam urutan yang benar, mereka memperoleh konten teoretis tertentu.  Dan seorang spesialis sejati terkadang dapat menemukan solusi untuk masalah praktis sehari-hari dengan bantuan mereka. " <br><br>  John PIRS "I See No Evil" <br></h4><br>  Posting ini penuh dengan diskusi tentang optimalisasi operasi matematika pada MK dengan sumber daya terbatas, serta penilaian subyektif dari berbagai aspek pengembangan perangkat lunak tertanam. <br><br>  Orang-orang yang peringatan ini tidak menakutkan, saya bertanya di bawah kucing. <br><a name="habracut"></a><br>  Sebelum kita menjelaskan prosedur untuk mengekstrak akar kuadrat dari bilangan bulat, operasi terbalik menjadi kuadrat dan, karenanya, mengalikan, mari kita bicara tentang yang terakhir. <br><br>  Misalkan kita memiliki kesempatan untuk mengalikan angka 8-bit dengan angka 8-bit, mendapatkan hasil 16-bit (8 * 8 = 16), bagaimana kita bisa mendapatkan implementasi operasi 16 * 16 = 32 berdasarkan operasi ini.  Cara yang jelas adalah mewakili 16 sebagai jumlah dari dua 8, lalu kita dapatkan <br><br> <code>(16)*(16)=(1(8)*256+2(8))*1(8)*256+2(8)) =1*1*256*256+1*2*256+2*1*256+2*2</code> <br> <br>  Jika dalam ekspresi yang dihasilkan kami mengganti perkalian dengan 256 dengan shift kiri dengan 8 digit, maka kami mendapatkan algoritma yang sepenuhnya berfungsi.  Mari kita perkirakan waktu yang dihabiskan untuk implementasi - kita perlu 4 perkalian 8 * 8 = 16 dan 4 tambahan dari angka 4 byte 32 + 32 = 32.  Untuk tipe MK AVR, kami mendapatkan 4 * 2 + 4 * 4 = 24 siklus, tapi ini untuk solusi "dahi".  Mari kita coba tingkatkan hasilnya.  Fakta bahwa kita tidak perlu 4, tetapi 3 penambahan dan satu penugasan agak menyederhanakan situasi, karena penomoran awal hasil tidak diperlukan, tetapi kami masih tidak memperhitungkannya, meskipun itu perlu dan total waktu harus 24 + 4 = 28 siklus.  Tetapi, jika kita memperhitungkan adanya pergeseran dalam tiga istilah pertama (masing-masing, kita memiliki bahwa rendah (dua byte rendah) adalah nol dan tidak ada gunanya menambahkannya ke hasil), maka kita harus menambahkan bukan 4 byte, tetapi tiga dan dua, yang akan mengurangi waktu eksekusi untuk 1 * 2 + 2 = 4 langkah dan dapatkan 20 langkah.  Selanjutnya, kita dapat memperhatikan fakta bahwa istilah pertama dan terakhir tidak berpotongan sama sekali, yang memungkinkan kita untuk mengganti penomoran dari bagian tertinggi dari hasil dengan penugasan istilah pertama dan mengurangi waktu eksekusi oleh siklus 2 jam ke 18. Selanjutnya, dengan menggunakan fitur arsitektur, yaitu kehadiran perintah transfer register berpasangan, simpan dua ukuran lebih dan hasil akhir - 16 ukuran bukannya 28 asli - agak, tapi bagus. <br><br>  Metode optimasi serupa bekerja untuk operasi 32 * 32 = 32, di mana Anda dapat mengurangi waktu eksekusi dari yang diharapkan 4 * 4 * (2 + 4) + 4 = 100 siklus clock menjadi (3 + 5 + 4 + 3) + (5 + 3 +3) + (4 + 3) + 3 = 36 tindakan, yang tidak buruk sama sekali.  Nah, pada akhir pertimbangan berbagai opsi untuk perkalian, kami mencatat bahwa 16 * 16 = 16 dapat diperoleh dalam 3 + 3 + 3 = 9 siklus.  Perhatikan bahwa semua pertimbangan ini hanya valid dengan asumsi bahwa ada operasi 8 * 8 = 16 untuk 2 langkah, dan jika tidak pada target MK, waktu pelaksanaan semua versi operasi yang lain pasti tidak akan menjadi lebih cepat. <br><br>  Mari kita meringkas waktu yang diperlukan untuk melakukan perkalian (8 * 8 = 8 2, 8 * 8 = 16 9, 16 * 16 = 16 16, 16 * 16 = 32 36) dan sekarang mempertimbangkan masalah aslinya. <br><br>  Kita perlu mengekstrak akar integer kuadrat dari angka 32 bit H, yaitu, menemukan angka 16 bit terbesar sehingga n * n &lt;= H.  Kita semua dari kursus sekolah menengah tahu metode perkiraan berturut-turut ke akar kuadrat (n = (N / n '+ n) / 2), tetapi ketika menggunakannya kita harus membagi bilangan bulat, dan ini adalah operasi yang sangat memakan waktu. <br><br>  Oleh karena itu, skema perhitungan lainnya dikembangkan, salah satunya adalah metode pendekatan bitwise, yang dalam pseudo-code terlihat sebagai berikut: <br><br><ul><li>  nilai awal -&gt; n = 0;  b = 0x8000; </li><li>  lakukan 16 kali -&gt; jika ((n + b) * (n + b)&gt; = H) n = n + b;  b = b &gt;&gt; 1; </li></ul><br>  Anda dapat segera memperkirakan waktu yang dihabiskan untuk opsi ini 16 (jumlah bit hasil) * (2 (organisasi siklus) +2 (penambahan) + X (penggandaan) +5 (perbandingan dan solusi) +2 (modifikasi hasil) / 2 (rata-rata hasil) setengah waktu) +2 (bit shift)) = 16 * (12 + X).  Anda bertanya mengapa dalam rumus X bukan angka 16, dan ternyata penyergapan menunggu kami, karena kami menulis dalam C, dan bukan dalam assembler.  Faktanya adalah bahwa di perpustakaan standar tidak ada operasi perkalian dengan perubahan kedalaman bit dan kami tidak dapat menerapkan 16 * 16 = 32, tetapi dipaksa untuk menggunakan 32 * 32 = 32, yang mengarah ke X = 36 bukannya X = 16 dan angka terakhir adalah 16 * 48 = 768 siklus clock untuk mengekstraksi nilai integer dari akar kuadrat dari angka 32-bit. <br><br>  Tentu saja, ini jauh lebih baik daripada metode Newton, tetapi sedikit banyak, mari kita lihat apa yang bisa dilakukan. <br>  Jadi, jelas bahwa sebagian besar waktu dihabiskan untuk menghitung hasil perkalian berikutnya.  Tentu saja, Anda dapat menulis ulang dalam assembler dan menggunakan versi perkalian yang lebih murah, mendapatkan 16 * (12 + 16) = 448 kutu, tetapi kami akan meninggalkan cara ini sebagai pilihan terakhir.  Pertimbangkan prosesnya dengan lebih hati-hati dan lihat bahwa kita tidak menghitung perkalian dari angka acak dengan sendirinya, tetapi perkalian dari nilai sebelumnya dengan beberapa peningkatan, dan kuadrat dari nilai sebelumnya diketahui.  Oleh karena itu, kita dapat menggunakan skema perbedaan berdasarkan rumus (n + b) * (n + b) = n * n + 2 * n * b + b * b.  Pada pandangan pertama, ini terlihat seperti ejekan - alih-alih satu perkalian, kita perlu melakukan empat bagian dan bahkan dua penambahan angka panjang (32-bit).  Tapi mari kita mulai mengerti: kita sudah memiliki n * n, b * b dengan mempertimbangkan bahwa b = b '/ 2 mudah diperoleh, seperti b' * b '/ 4, dan juga 2 * n * b = 2 * n * b '/ 2. <br><br>  Skema perhitungan berikut muncul: <br><br><ol><li>  nilai awal -&gt; nn = 0;  n = 0;  b = 0x8000;  bb = b * b; </li><li>  ulangi 16 kali -&gt; jika (nn + n + bb&gt; = H) {n = n + b;  nn = nn + bb + n};  bb &gt;&gt; 2;  b&gt; 1; </li></ol><br>  Kami memperkirakan biaya implementasi 16 * (2 (organisasi siklus) +12 (penugasan dan dua tambahan) +5 (perbandingan dan solusi) + (2 (penambahan) +8 (dua tambahan)) / 2 (rata-rata setengah waktu) +8 (bergeser ke kanan dengan 2) +2 (bergeser ke kanan) = 16 * 34 = 544 siklus clock. Lebih baik daripada dengan perkalian yang salah dari 32 * 32, tapi kami masih memiliki cadangan. <br><br>  Apa yang mereka - mari kita perhatikan operasi yang paling mahal - menambah dan membandingkan total 17 siklus clock dan mengulang kembali loop utama dari algoritma: <br>  2. ulangi 16 kali -&gt; T = H-bb-n;  if (T&gt; = 0) {H = T;  n = n + b);};  bb &gt;&gt; 2;  b&gt; 1; <br>  Maka waktu pelaksanaan siklus akan 16 * (2 (organisasi siklus) +12 (perhitungan perbedaan baru) +1 (perbandingan dan solusi) + ((4 (tugas) +2 (penambahan)) / 2 (rata-rata setengah waktu) +8 +2) = 16 * 28 = 448 siklus, jika Anda memperhitungkan kekhasan arsitektur, Anda dapat menyimpan 2 + 2 = 4 * 16 = 64 siklus yang lain dan menyimpannya dalam waktu kurang dari 400 siklus. <br><br>  Kami mendapatkan hasil yang sedikit lebih baik, seperti ketika menggunakan perkalian yang benar 16 * 16 = 32, tetapi tanpa assembler, "dalam C murni".  Namun, ada minus yang signifikan - jika semuanya intuitif dalam versi dengan perkalian, maka varian dengan skema perbedaan tanpa komentar memberikan kesan sesi sihir hitam, Anda harus memilih.  Perhatikan juga bahwa kami menukar jumlah pengukuran untuk memori tambahan untuk variabel perantara, yang biasanya terjadi. <br><br>  Catatan yang diperlukan - kami tidak mendapatkan keuntungan (kadang-kadang) yang signifikan dibandingkan dengan multiplikasi, karena kami memiliki implementasi cepat 8 * 8 = 16.  Jika tidak ada dalam MK (dan ini terjadi) atau tidak begitu cepat (dan ini juga terjadi), maka skema perbedaan menjadi beberapa kali lebih cepat, karena hanya menggunakan operasi penambahan dan pengalihan standar, yang dijamin berada dalam MK mana pun. <br><br>  Tampaknya itu tidak akan bekerja lebih baik, tetapi, ternyata, masih ada cadangan untuk meningkatkan kinerja algoritma.  Mari kita coba menggunakan metode percepatan klasik lain - bagilah dan taklukkan.  Bagaimana jika Anda pertama kali mengekstrak akar kuadrat dari bagian argumen yang lebih lama, dan kemudian memperbaikinya?  Pertama-tama, kami menunjukkan bahwa ini pada dasarnya mungkin.  Memang, kami menyajikan argumen dalam bentuk H = H '&lt;&lt; 16 + H' 'dan hasilnya dalam bentuk n = n' &lt;&lt; 8 + n ''.  Karena n '' &lt;256, maka kuadratnya jelas akan kurang dari kuadrat dari angka n = n '&lt;&lt; 8 + 256 = (n' + 1) &lt;&lt; 8.  Oleh karena itu, bagian tertinggi dari hasil tidak melebihi akar kuadrat dari bagian tertinggi dari argumen. <br><br>  Implementasi pendekatan ini diserahkan kepada pembaca yang ingin tahu. <br>  Apa yang akan diberikan pendekatan ini kepada kita, karena jumlah total iterasi akan tetap tidak berubah - kita dapat melakukan paruh pertama iterasi dengan jumlah panjang yang lebih pendek, dan ini mengarah pada penurunan biaya waktu.  Pendekatan ini dapat diterapkan pada varian dengan multiplikasi dan varian perbedaan, total keuntungan akan mencapai seperempat dari total waktu eksekusi. <br><br>  Catatan yang diperlukan - penerapan pendekatan ini sama sekali tidak jelas, ketika menerapkan untuk MK seperti AVR, akselerasi eksekusi memang terjadi, tetapi untuk beberapa arsitektur, misalnya untuk x86, perlambatan operasi muncul secara tak terduga.  Rupanya, bekerja dengan data non-asli (16 bit) dalam arsitektur ini secara signifikan lebih mahal dalam waktu daripada dengan asli (32 bit).  Saya tidak melakukan penelitian mendalam, tetapi fakta itu terjadi dan saya harus melaporkannya untuk menghindari kesalahpahaman. <br><br>  Tapi itu belum semuanya.  Karena kita telah memulai jalan pemisahan dan penguasaan, maka mengapa tidak melangkah lebih jauh - ekstrak akar dari bit langkah demi langkah, dimulai dengan yang tertua (dimulai dengan yang lebih muda kontraproduktif dalam kasus kami).  Skema algoritma adalah sama - kami menambahkan bagian bit berikutnya dalam hasil saat ini dan mencoba menambahkan bit berikutnya ke hasilnya, memeriksa apakah kami telah melampaui nilai root.  Keunikannya adalah kita hanya dapat memeriksa bit argumen yang tinggi, sampai kita mendapatkan bit yang rendah. <br><br>  Saat menerapkan, kami menggunakan satu trik lagi - alih-alih memindahkan angka yang kami kurangi ke kanan, kami akan memindahkan argumen yang dikurangi ke kiri, artinya tidak berubah, dan kecepatan bertambah.  Ini meningkat karena dua faktor - 1) cukup bagi kita untuk mengurangi hanya 16 bit (ada satu kekhasan, dan itu harus diperhitungkan, tetapi kita sedang mempertimbangkan studi kasus, vout) dan 2) kita tidak perlu menggeser kuadrat dari bit berikutnya, karena akan selalu ada sama dengan satu.  Tetapi Anda harus membayar semua yang ada di dunia ini dan kami akan memiliki pergeseran perbedaan yang diperluas (6 byte) ke kiri, dan 2 bit per jam.  Kami melihat kode semu <br><br><ol><li>  nilai awal -&gt; n = 0;  H1 = 0; </li><li>  ulangi 16 kali -&gt; (H1, H) &lt;&lt; 2;  T = H1-n-1;  if (T&gt; 0) {H1 = T;  n = n + 2};  n &lt;&lt; 1; </li></ol><br>  dan evaluasi waktu eksekusi, dapatkan 16 * (12 (shift diperpanjang) +4 (menghitung perbedaan) +1 (solusi) +2 (tugas) +1 (meningkat) +2 (shift)) = 16 * 22 = 352 langkah, mungkin , hasilnya hampir sempurna.  Ketika menerapkan opsi ini, ada jebakan kecil, saya menyerahkan ini lagi kepada pembaca yang ingin tahu (well, dia mendapatkan pekerjaan). <br><br>  Nah, pada kesimpulan bagian yang mendorong saya untuk menulis posting ini.  Ada perpustakaan McuCpp yang benar-benar luar biasa, yang ditulis oleh Anton Chizhov, di mana, berdasarkan pada kelas lokus kepenulisan, Andriescu sangat luar biasa elegan (well, sejauh keanggunan dapat diterapkan ke templat C ++), bekerja dengan pin &lt;a Â« <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/KonstantinChizhov/ Mcucpp</a> Â»Saya sangat menghormati penulis yang disebutkan (keduanya) dan baru-baru ini, sehubungan dengan keadaan, yang akan saya bahas nanti, saya melihat sumber perpustakaan ini dan sekali lagi mengagumi. <br><br>  Namun, di antara file-file lain saya melihat template_utils.h, di mana beberapa rutin tambahan diimplementasikan, dan di antara mereka sebuah akar integer dari nomor 32-bit.  Fakta bahwa ia menggunakan algoritma pendekatan sekuensial paling sederhana dengan perkalian tidak menakutkan, karena algoritma ini tidak kehilangan begitu banyak dalam kecepatan, tetapi dalam pemahaman itu memberikan banyak poin di depan dan masih menang.  Tetapi saya tidak terlalu suka fakta bahwa itu dilaksanakan agak tidak akurat (dalam hal kinerja), karena "anak-anak dapat melihatnya."  Ketidaktepatan terdiri dari mewakili angka yang dipilih dengan 32 bit, karena kita tahu dengan pasti bahwa akar dari angka 32 bit tidak akan melampaui 16 bit, jadi mengapa kita perlu menggeser nol byte.  Dan inilah yang terjadi ketika kompiler itu sendiri tidak akan pernah menebak untuk melakukan optimasi dan harus membantunya. <br><br>  Konversi fungsi yang jelas <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqrt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> add = <span class="hljs-number"><span class="hljs-number">0x8000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> i = <span class="hljs-number"><span class="hljs-number">16</span></span>; i !=<span class="hljs-number"><span class="hljs-number">0</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> rootGuess = result | add; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> guess = rootGuess * rootGuess; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= guess) { result = rootGuess; } add &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  memungkinkan kita untuk menyimpan 2 siklus pada sedikit pergeseran dan 2 siklus menciptakan faktor berikutnya pada setiap siklus, dan mengatur siklus dalam bentuk yang ditentukan adalah 4 siklus lainnya (saya tahu bahwa kompiler dapat melakukan optimasi ini untuk kita, tetapi mengapa tidak membantu secara eksplisit ), yang cukup baik untuk perubahan kode kosmetik murni yang tidak memengaruhi kelengkapannya sedikit pun. <br><br>  Catatan kemudian - satu komentar membuat saya berpikir bahwa itu akan lebih benar <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint_fast8_t</span></span> i= ...)</code> </pre> <br>  Terima kasih Oleg atas bantuannya. <br><br>  Ceri pada kue adalah fungsi mengekstraksi seluruh akar kuadrat dari nomor tanda yang terletak tepat di bawah, yang mengklaim sebagai âˆš-1 = 65635 = -1. Di sisi lain, mengapa tidak, apa yang lebih buruk daripada hasil lainnya, ini tidak terkecuali bagi kami Penyebab di MK, dan seluruh akar kuadrat dari angka negatif tidak ada. <br><br>  Nah, kesimpulan tentang mengapa saya menoleh ke perpustakaan Anton Chizhov.  Saya diminta oleh sebuah pos baru-baru ini mengenai RTOS domestik untuk MK dengan nama MAX (MultiAgent Coherent System) - lihat epigraf ke pos yang diiklankan oleh pembuatnya dan diangkut ke MK yang diproduksi oleh Milander.  Catatan - posting ini sama sekali bukan materi promosi dan akan segera menjadi jelas bagi pembaca.  Dari mcucpp yang disebutkan di atas, penulis OS menggunakan implementasi buffer cincin (sama sekali tidak meremehkan kelebihan perpustakaan Anton, saya harus mengatakan bahwa bagian ini bukan referensi, dan ini masih merupakan perumusan yang lembut, yang saya tulis di pos lain yang saya tidak akan posting sama sekali).  Karena saya bekerja erat dengan fasilitas produksi Milander, materi tersebut menarik minat saya dan saya mengikuti tautan ke situs web pengembang. <br><br>  Di sinilah tangisan Yaroslavna selanjutnya. <br><br>  Tahun lalu, ketika pembuatan RTOS domestik pertama kali diumumkan, saya mengunduh deskripsi produk perangkat lunak dari situs ini, tetapi entah bagaimana tangan saya tidak mencapai studi.  Dengan sifat aktivitas saya, saya harus berurusan dengan komponen domestik (saya cukup mengerti ...), jadi akan menyenangkan untuk memiliki perangkat lunak yang sesuai.  Mengingat bagaimana dalam rilis tahun lalu, direktur perusahaan berbicara tentang jutaan rubel yang dihabiskan untuk pengembangan dan tim besar yang bekerja pada pembuatan produk perangkat lunak ini, saya memutuskan untuk melihat versi uji coba yang tersedia untuk diunduh secara gratis, dan di sini saya membagikan hasilnya. <br><br>  Pertama-tama, deskripsi selama setengah tahun hampir setengahnya dalam volume (dari 115 menjadi 55 halaman), dan jika hilangnya aplikasi dengan tangkapan layar yang menjelaskan proses peluncuran produk ketiga dari "Deskripsi Program" disambut, maka bukan tampilan dari bahan-bahan ini (untuk pembuatan yang Saya menghabiskan, meskipun tidak terlalu signifikan, tetapi masih waktu dan uang) dalam dokumen seperti "Panduan Operator" Saya pribadi bingung.  Lebih jauh, dalam frasa pertama dokumen tersebut, kita melihat penyimpangan yang jujur â€‹â€‹dari kebenaran, karena RTOS sendiri tidak dimaksudkan untuk "membuat program" dengan cara apa pun, untuk beberapa alasan penulis tidak membiarkan diri mereka pernyataan seperti itu dalam versi dokumen sebelumnya, pengaruh layanan pemasaran dirasakan.  Ini juga memberikan bahwa jika deskripsi dulu berada di folder / docs dari direktori root, dan ini logis, sekarang tersembunyi di / toolchain / macs / docs, well, seperti yang mereka katakan di masa muda saya, "semua orang marah dengan caranya sendiri," kita melanjutkan. <br><br>  Saya mulai melihat uraiannya, melihat kode sumbernya (termasuk dalam versi uji coba) dan dalam kebingungan saya menemukan tidak adanya driver perangkat periferal yang diadaptasi untuk bekerja dengan OS ini.  Pertama saya menyarankan bahwa ini adalah fitur percobaan, kemudian pada forum di informasi dari pengembang saya menemukan bahwa sebenarnya tidak ada driver, tetapi mereka sedang mengusahakannya.  Lebih dari enam bulan (enam bulan, Carl, sebenarnya hampir satu tahun) dari saat OS dirilis untuk MK, dan mereka bekerja pada driver.  Secara alami, atau seperti yang mereka katakan, tak perlu dikatakan bahwa tidak ada pembicaraan tentang produk ketiga (sistem file, tumpukan jaringan, tumpukan USB).  Sebuah ide lucu dari penulis tentang persyaratan untuk pengembangan perangkat lunak untuk MK, oke, melaju lagi. <br><br>  Yaitu, OS yang dideklarasikan, fitur yang disorot di antaranya adalah organisasi interaksi dalam sistem multi-controller, tidak memiliki cara asli untuk mengatur interaksi ini.  Apa yang kami miliki di garis bawah - dan kami memiliki manajemen tugas, sebenarnya sheduler, layanan waktu minimal dan sarana sinkronisasi tugas, dan itu saja - lucu, untuk sedikitnya.  Oke, kita akan melihat lebih jauh, bahkan dalam serangkaian komponen solusi yang menarik dimungkinkan, terutama ketika Anda mempertimbangkan bahwa di satu situs (bukan perusahaan pabrikan) saya melihat "pemeriksaan" kode sumber OS ini dengan referensi.  Dokumen ini mengatakan bahwa produk perangkat lunak tidak menggunakan komponen pihak ketiga (impor) dan asli, perlu untuk dipastikan. <br><br>  Pengamatan pertama adalah bahwa jika Anda menggunakan file ARM asli yang termasuk dalam paket kode sumber untuk port ke arsitektur Cortex-M0 tertentu (1986 BE1T), maka ini sangat mirip dengan menggunakan fragmen teks pihak ketiga (yang diimpor) - Saya pribadi berpikir bahwa ini adalah penggunaannya, tetapi Saya mungkin tidak tahu segalanya.  Nah, dan kedua, kode sumber sheduler dan komponen manajemen tugas terkait benar-benar asli dan tidak memiliki analog (setidaknya saya tidak tahu), tetapi ini adalah jenis orisinalitas ketika saya mengingat ungkapan dukun lama dari film "The Evil Spirit of Yambuya" tentang pemburu ulung: "Potong telinganya, masak dan makan - apakah kamu bisa menebak?" <br><br>  Saya akan mencoba menjelaskan - dalam desain OS secara umum dan dalam RTOS khususnya, salah satu masalah kompleks adalah masalah memastikan akses semua proses dalam sistem ke sumber daya bersama - runtime prosesor.   ,     (   )        ,    .           (            ,     ,       MPU),        . <br><br>    ,     ,      ,  ,          .           (1) , ,  FREE-RTOS     20        ,       ( ,       ,        ). <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oleh karena itu, saya sedikit terkejut menemukan bahwa OS yang dimaksud memungkinkan Anda memiliki hingga 60 prioritas (dan bahkan lebih). </font><font style="vertical-align: inherit;">Kejutan itu tersebar ketika saya melihat melalui sumber. </font><font style="vertical-align: inherit;">Alih-alih memisahkan antrian tugas dengan prioritas yang sama, penulis menggunakan satu antrian (ada juga antrian kedua dari tugas yang diblokir) yang siap untuk pelaksanaan tugas, yang membantu menghemat memori (mungkin ini adalah tujuan dari solusi semacam itu) karena fakta bahwa</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operasi menambahkan tugas ke antrian menjadi O (n) dan </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini membuat penggunaan sheduler yang dimodifikasi menjadi tidak mungkin - menurut saya, sedikit mahal untuk 20 * (3 * 4) = 240 byte RAM. </font><font style="vertical-align: inherit;">Solusinya luar biasa orisinal, tetapi, dari sudut pandang saya, ini adalah satu-satunya keuntungan.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara umum, saya masih tidak mengerti mengapa penulis akan mengambil uang (tetapi mereka masih belum memutuskan apakah akan melakukan ini, dilihat dari forum) dan solusi serta fitur tertentu yang memungkinkan untuk memberikan perangkat lunak dengan nama yang luar biasa. Terutama mengingat berapa banyak perangkat lunak yang disediakan secara gratis oleh banyak pemasok MK (tentu saja, yang diimpor). Saat menelusuri forum perusahaan dalam upaya untuk menemukan jawaban, saya melihat referensi ke produk perangkat lunak mcucpp yang disebutkan sebelumnya (penulis MAKS diduga terinspirasi oleh ide-ide Chizhov - tiga kali ha), di mana saya menemukan cacat kecil yang dijelaskan di atas.</font></font><br><br>     â€”      -            ,           . <br><br>        (,   ,          ) -     â€” .     (  ,     ,   ), ,    ( 2013) 1       ,    2019          . <br><br> ,       : <br><br><ol><li>  (  ,   )  ( ,   ,    ,  ,  ), </li><li>      (   ), </li><li>      ()      2, </li><li>       HAL, CMSIS (- ), </li><li>       , </li><li>        , </li><li>      (3rd part),  , </li><li>       , </li><li>       , </li><li>    ,     (,   ,     ..)     Â« Â», </li><li>  ,   ,         (    , , MIT   ,  Â«      Â»),        ,    (?). </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentu saja, semua ini tidak muncul dengan sendirinya dan membutuhkan biaya, tetapi bagi saya tampaknya perusahaan tingkat Anda mampu membayar pekerjaan 5 orang selama enam bulan untuk membuat semua hal di atas (dengan pengecualian klausa, mungkin klausul 10, meskipun sekarang semua signifikan dan banyak produsen MK kecil mendapat IDE sendiri). </font><font style="vertical-align: inherit;">Jika ini disadari, maka tanah akan hilang untuk penampilan kerajinan seperti OS yang dijelaskan dalam posting ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun mungkin saya tidak tahu sesuatu, dan sebenarnya semuanya tidak sesederhana itu, sangat disayangkan jika ini benar-benar terjadi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya minta maaf sebelumnya jika catatan saya tampak terlalu keras, itu Anda (Milander) yang saya tidak ingin menyinggung.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437326/">https://habr.com/ru/post/id437326/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437316/index.html">Institut Pengembangan Internet telah menyebutkan situs-situs yang mungkin terputus di RuNet sejak 1 Februari</a></li>
<li><a href="../id437318/index.html">Migrasi yang mulus (hampir) antara rilis PostgreSQL besar menggunakan replikasi logis</a></li>
<li><a href="../id437320/index.html">Indeks Pengembangan Sphere Media 2018: stagnasi televisi, peningkatan kepercayaan terhadap media informal</a></li>
<li><a href="../id437322/index.html">Negara terlibat dalam BigDate</a></li>
<li><a href="../id437324/index.html">Ciuman berdarah: sifat vasorelaksasi pada air liur kelelawar vampir</a></li>
<li><a href="../id437330/index.html">devleads - bicarakan burnout</a></li>
<li><a href="../id437332/index.html">Dua persen dari "kucing" atau yang memotret Master Yoda?</a></li>
<li><a href="../id437334/index.html">Apa yang akan terjadi pada 1 Februari?</a></li>
<li><a href="../id437336/index.html">Dari Penza ke Berlin: Sejarah Uji Automator Pindah</a></li>
<li><a href="../id437342/index.html">Cara memilih platform untuk pengawasan video: Cloud vs. DVR / NVR / VMS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>