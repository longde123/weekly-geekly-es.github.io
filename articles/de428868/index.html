<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ó üë©‚Äçüè≠ üòå Multi-Release-JARs - schlecht oder gut? üë≤üèø üïî üçï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Von einem √úbersetzer: Wir arbeiten aktiv an der √úbertragung der Plattform auf Java 11-Rails und √ºberlegen, wie Java-Bibliotheken (wie YARG ) unter Ber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Multi-Release-JARs - schlecht oder gut?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/428868/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cm/cn/ee/cmcnee4gyidm3xbo-0fl1fatdme.png"></div><br><p>  <em>Von einem √úbersetzer: Wir arbeiten aktiv an der √úbertragung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plattform</a> auf Java 11-Rails und √ºberlegen, wie Java-Bibliotheken (wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">YARG</a> ) unter Ber√ºcksichtigung der Funktionen von Java <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8/11</a> effizient entwickelt werden k√∂nnen, damit Sie keine separaten Zweige und Releases <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstellen</a> m√ºssen.</em>  <em>Eine m√∂gliche L√∂sung ist eine Multi-Release-JAR, aber nicht alles ist reibungslos.</em> </p><br><p>  Java 9 enth√§lt eine neue Java-Laufzeitoption namens Multi-Release-JARs.  Dies ist m√∂glicherweise eine der umstrittensten Innovationen auf der Plattform.  <em>TL; DR: Wir finden, dass dies eine krumme L√∂sung f√ºr ein ernstes Problem ist</em> .  In diesem Beitrag erkl√§ren wir, warum wir so denken, und erkl√§ren Ihnen auch, wie Sie eine solche JAR erstellen, wenn Sie dies wirklich m√∂chten. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Multi-Release-JARs</a> oder MR-JARs sind eine neue Funktion der in JDK 9 eingef√ºhrten Java-Plattform. Im Folgenden werden die mit der Verwendung dieser Technologie verbundenen erheblichen Risiken und das Erstellen von Multi-Release-JARs mit Gradle ausf√ºhrlich erl√§utert. wenn du noch willst </p><br><p>  Tats√§chlich ist eine JAR mit mehreren Versionen ein Java-Archiv, das mehrere Varianten derselben Klasse f√ºr die Arbeit mit verschiedenen Versionen der Laufzeit enth√§lt.  Wenn Sie beispielsweise in JDK 8 arbeiten, verwendet die Java-Umgebung die Klassenversion f√ºr JDK 8, und wenn in Java 9 die Version f√ºr Java 9 verwendet wird. Wenn die Version f√ºr eine zuk√ºnftige Version von Java 10 erstellt wurde, verwendet die Laufzeit diese Version anstelle der Version f√ºr Java 9 oder die Standardversion (Java 8). </p><br><p>  Unter der Katze verstehen wir das Ger√§t des neuen JAR-Formats und finden heraus, ob dies alles ist. </p><a name="habracut"></a><br><h2 id="kogda-ispolzovat-multi-release-jars">  Wann werden JARs mit mehreren Versionen verwendet? </h2><br><ul><li>  Optimierte Laufzeit.  Dies ist eine L√∂sung f√ºr das Problem, mit dem viele Entwickler konfrontiert sind: Bei der Entwicklung einer Anwendung ist nicht bekannt, in welcher Umgebung sie ausgef√ºhrt wird.  F√ºr einige Versionen der Laufzeit k√∂nnen Sie jedoch generische Versionen derselben Klasse einbetten.  Angenommen, Sie m√∂chten die Versionsnummer von Java anzeigen, in der die Anwendung ausgef√ºhrt wird.  F√ºr Java 9 k√∂nnen Sie die Runtime.getVersion-Methode verwenden.  Dies ist jedoch eine neue Methode, die nur in Java 9+ verf√ºgbar ist.  Wenn Sie andere Laufzeiten ben√∂tigen, z. B. Java 8, m√ºssen Sie die Eigenschaft java.version analysieren.  Als Ergebnis haben Sie 2 verschiedene Implementierungen einer Funktion. </li><li><p>  Widerspr√ºchliche APIs: Die Konfliktl√∂sung zwischen APIs ist ebenfalls ein h√§ufiges Problem.  Beispielsweise m√ºssen Sie zwei Laufzeiten unterst√ºtzen, aber in einer davon ist die API veraltet.  Es gibt zwei g√§ngige L√∂sungen f√ºr dieses Problem: </p><br><ol><li>  Das erste ist Reflexion.  Sie k√∂nnen beispielsweise die VersionProvider-Schnittstelle angeben, dann 2 bestimmte Klassen Java8VersionProvider und Java9VersionProvider und die entsprechende Klasse in die Laufzeit laden (es ist lustig, dass Sie die Versionsnummer analysieren m√ºssen, um zwischen zwei Klassen zu w√§hlen!).  Eine der Optionen f√ºr diese L√∂sung besteht darin, eine einzelne Klasse mit verschiedenen Methoden zu erstellen, die mithilfe der Reflexion aufgerufen werden. </li><li>  Eine fortgeschrittenere L√∂sung besteht darin, wenn m√∂glich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Methodenhandles</a> zu verwenden.  H√∂chstwahrscheinlich wird Ihnen die Reflexion hemmend und unangenehm erscheinen und im Allgemeinen so, wie sie ist. </li></ol><br></li></ul><br><h2 id="izvestnye-alternativy-podhodu-multi-release-jars">  Bekannte Alternativen zu Multi-Release-JARs </h2><br><p> Der zweite Weg, einfacher und verst√§ndlicher, besteht darin, zwei verschiedene Archive f√ºr verschiedene Laufzeiten zu erstellen.  Theoretisch erstellen Sie zwei Implementierungen derselben Klasse in der IDE, und das Kompilieren, Testen und korrekte Packen in zwei verschiedene Artefakte ist Aufgabe des Build-Systems.  Dies ist ein Ansatz, der seit vielen Jahren in Guave oder Spock verwendet wird.  Es wird aber auch f√ºr Sprachen wie Scala ben√∂tigt.  Und das alles, weil es so viele Optionen f√ºr den Compiler und die Laufzeit gibt, dass die Bin√§rkompatibilit√§t fast unerreichbar wird. </p><br><p>  Es gibt jedoch noch viele andere Gr√ºnde, separate JAR-Archive zu verwenden: </p><br><ul><li>  JAR ist nur eine Art zu packen. </li></ul><br><p>  Es ist ein Assembly-Artefakt, das Klassen enth√§lt, aber das ist noch nicht alles: Ressourcen sind in der Regel auch im Archiv enthalten.  Verpackung hat wie Ressourcenhandhabung einen Preis.  Das Gradle-Team m√∂chte die Build-Qualit√§t verbessern und die Wartezeit f√ºr den Entwickler reduzieren, um Ergebnisse, Tests und den Build-Prozess im Allgemeinen zusammenzustellen.  Wenn das Archiv zu fr√ºh im Prozess erscheint, wird ein unn√∂tiger Synchronisationspunkt erstellt.  Zum Kompilieren von API-abh√§ngigen Klassen werden beispielsweise nur .class-Dateien ben√∂tigt.  Weder JAR-Archive noch Ressourcen im JAR werden ben√∂tigt.  Ebenso werden nur Grade-Dateien und -Ressourcen ben√∂tigt, um Gradle-Tests auszuf√ºhren.  Zum Testen muss kein Glas erstellt werden.  Es wird nur von einem externen Benutzer ben√∂tigt (d. H. Beim Ver√∂ffentlichen).  Wenn die Erstellung eines Artefakts jedoch obligatorisch wird, k√∂nnen einige Aufgaben nicht parallel ausgef√ºhrt werden, und der gesamte Montageprozess wird gesperrt.  Wenn dies f√ºr kleine Projekte nicht kritisch ist, ist dies f√ºr gro√üe Unternehmensprojekte der Hauptverlangsamungsfaktor. </p><br><ul><li>  Es ist viel wichtiger, dass ein JAR-Archiv als Artefakt keine Informationen √ºber Abh√§ngigkeiten enthalten kann. </li></ul><br><p>  Es ist unwahrscheinlich, dass die Abh√§ngigkeiten der einzelnen Klassen in der Java 9- und Java 8-Laufzeit gleich sind.  Ja, in unserem einfachen Beispiel ist dies der Fall, aber bei gr√∂√üeren Projekten ist dies nicht der Fall: Normalerweise importiert der Benutzer den Backport der Bibliothek f√ºr Java 9-Funktionen und verwendet ihn zum Implementieren der Version der Java 8-Klasse. Wenn Sie jedoch beide Versionen in einem Archiv in einem Artefakt packen Es wird Elemente mit unterschiedlichen Abh√§ngigkeitsb√§umen geben.  Dies bedeutet, dass Sie bei der Arbeit mit Java 9 Abh√§ngigkeiten haben, die niemals ben√∂tigt werden.  Dar√ºber hinaus wird der Klassenpfad verschmutzt, was zu wahrscheinlichen Konflikten f√ºr Bibliotheksbenutzer f√ºhrt. </p><br><p>  Und schlie√ülich k√∂nnen Sie in einem Projekt JARs f√ºr verschiedene Zwecke erstellen: </p><br><ul><li>  f√ºr API </li><li>  f√ºr Java 8 </li><li>  f√ºr Java 9 </li><li>  mit nativer Bindung </li><li>  usw. </li></ul><br><p>  Die falsche Verwendung des Abh√§ngigkeitsklassifikators f√ºhrt zu Konflikten im Zusammenhang mit der gemeinsamen Nutzung desselben Mechanismus.  Normalerweise werden <em>Quellen</em> oder <em>Javadocs</em> als Klassifizierer installiert, aber in Wirklichkeit haben sie keine Abh√§ngigkeiten. </p><br><ul><li>  Wir m√∂chten keine Inkonsistenzen erzeugen, der Erstellungsprozess sollte nicht davon abh√§ngen, wie Sie die Klassen erhalten.  Mit anderen Worten, die Verwendung von Multi-Release-Jars hat einen Nebeneffekt: Das Aufrufen aus dem JAR-Archiv und das Aufrufen aus dem Klassenverzeichnis sind jetzt v√∂llig verschiedene Dinge.  Sie haben einen gro√üen Unterschied in der Semantik! </li><li>  Abh√§ngig davon, mit welchem ‚Äã‚ÄãTool Sie die JAR erstellen, kann es zu inkompatiblen JAR-Archiven kommen!  Das einzige Tool, das garantiert, dass beim Packen von zwei Klassenoptionen in einem Archiv eine einzige offene API vorhanden ist - das <em>JAR-</em> Dienstprogramm selbst.  Dies erfordert nicht unbedingt Montagewerkzeuge oder sogar Benutzer.  JAR ist im Wesentlichen ein ‚ÄûUmschlag‚Äú, der einem ZIP-Archiv √§hnelt.  Je nachdem, wie Sie es sammeln, erhalten Sie unterschiedliche Verhaltensweisen oder Sie sammeln m√∂glicherweise ein falsches Artefakt (und Sie werden es nicht bemerken). </li></ul><br><h2 id="bolee-effektivnye-sposoby-upravleniya-otdelnymi-jar-arhivami">  Effizientere M√∂glichkeiten zur Verwaltung einzelner JAR-Archive </h2><br><p>  Der Hauptgrund daf√ºr, dass Entwickler keine separaten Archive verwenden, ist, dass das Sammeln und Verwenden unpraktisch ist.  Schuld daran sind die Build-Tools, die vor Gradle damit √ºberhaupt nicht fertig wurden.  Insbesondere diejenigen, die diese Methode in Maven verwendeten, konnten sich nur auf die schwache <em>Klassifikatorfunktion verlassen</em> , um zus√§tzliche Artefakte zu ver√∂ffentlichen.  Der <em>Klassifikator</em> hilft jedoch in dieser schwierigen Situation nicht.  Sie werden f√ºr verschiedene Zwecke verwendet, von der Ver√∂ffentlichung von Quellcodes, Dokumentation, Javadocs bis zur Implementierung von Bibliotheksoptionen (guava-jdk5, guava-jdk7, ...) oder verschiedenen Anwendungsf√§llen (api, fat jar, ...).  In der Praxis kann nicht gezeigt werden, dass sich der <em>Klassifizierer-</em> Abh√§ngigkeitsbaum vom Abh√§ngigkeitsbaum des Hauptprojekts unterscheidet.  Mit anderen Worten, das POM-Format ist grunds√§tzlich kaputt, weil  Es zeigt, wie die Komponente zusammengesetzt ist und welche Artefakte sie liefert.  Angenommen, Sie m√ºssen zwei verschiedene JAR-Archive implementieren: Classic und Fat JAR, die alle Abh√§ngigkeiten enthalten.  Maven entscheidet, dass 2 Artefakte identische Abh√§ngigkeitsb√§ume haben, auch wenn dies offensichtlich falsch ist!  In diesem Fall ist dies mehr als offensichtlich, aber die Situation ist dieselbe wie bei JARs mit mehreren Versionen! </p><br><p>  Die L√∂sung besteht darin, die Optionen korrekt zu behandeln.  Gradle kann dies tun, indem Abh√§ngigkeiten basierend auf Optionen verwaltet werden.  Diese Funktion ist derzeit f√ºr die Entwicklung unter Android verf√ºgbar, wir arbeiten jedoch auch an der Version f√ºr Java und native Anwendungen! </p><br><p>  Das variantenbasierte Abh√§ngigkeitsmanagement basiert auf der Tatsache, dass Module und Artefakte v√∂llig unterschiedliche Dinge sind.  Der gleiche Code kann zu unterschiedlichen Laufzeiten unter Ber√ºcksichtigung unterschiedlicher Anforderungen einwandfrei funktionieren.  F√ºr diejenigen, die mit nativer Kompilierung arbeiten, ist dies seit langem offensichtlich: Wir kompilieren f√ºr <em>i386</em> und <em>amd64</em> und k√∂nnen in keiner Weise die Abh√§ngigkeiten der <em>i386-</em> Bibliothek mit <em>arm64 beeintr√§chtigen</em> !  Im Kontext von Java bedeutet dies, dass Sie f√ºr Java 8 eine Version des JAR-Archivs ‚ÄûJava 8‚Äú erstellen m√ºssen, in der das Klassenformat Java 8 entspricht. Dieses Artefakt enth√§lt Metadaten mit Informationen zu den zu verwendenden Abh√§ngigkeiten.  F√ºr Java 8 oder 9 werden Abh√§ngigkeiten ausgew√§hlt, die der Version entsprechen.  So einfach ist das (der Grund ist nicht, dass die Laufzeit nur ein Optionsfeld ist, Sie k√∂nnen mehrere kombinieren). </p><br><p>  Nat√ºrlich hatte dies aufgrund der √ºberm√§√üigen Komplexit√§t noch niemand getan: Maven w√ºrde offenbar niemals zulassen, dass eine so komplizierte Operation durchgef√ºhrt wird.  Aber mit Gradle ist das m√∂glich.  Das Gradle-Team arbeitet derzeit an einem neuen Metadatenformat, das den Benutzern mitteilt, welche Option verwendet werden soll.  Einfach ausgedr√ºckt muss ein Build-Tool das Kompilieren, Testen, Verpacken und Verarbeiten solcher Module √ºbernehmen.  Das Projekt sollte beispielsweise in Java 8- und Java 9-Laufzeiten funktionieren. Idealerweise m√ºssen Sie zwei Versionen der Bibliothek implementieren.  Dies bedeutet, dass es 2 verschiedene Compiler gibt (um die Verwendung der Java 9-API bei der Arbeit in Java 8 zu vermeiden), 2 Klassenverzeichnisse und letztendlich 2 verschiedene JAR-Archive.  Und h√∂chstwahrscheinlich m√ºssen auch zwei Laufzeiten getestet werden.  Oder Sie implementieren 2 Archive, entscheiden sich jedoch daf√ºr, das Verhalten der Java 8-Version in der Java 9-Laufzeit zu testen (da dies beim Start passieren kann!). </p><br><p>  Dieses Schema wurde noch nicht umgesetzt, aber das Gradle-Team <a href="">hat erhebliche Fortschritte</a> in dieser Richtung erzielt. </p><br><h2 id="kak-sozdat-multi-release-jar-s-pomoschyu-gradle">  So erstellen Sie mit Gradle JAR mit mehreren Versionen </h2><br><p>  Aber was soll ich tun, wenn diese Funktion noch nicht bereit ist?  Entspannen Sie sich, korrekte Artefakte werden auf die gleiche Weise erstellt.  Bevor die obige Funktion im Java-√ñkosystem angezeigt wird, gibt es zwei M√∂glichkeiten: </p><br><ul><li>  guter alter Weg mit Reflection oder verschiedenen JAR-Archiven; </li><li>  Verwenden Sie Multi-Release-JARs (beachten Sie, dass dies eine schlechte L√∂sung sein kann, selbst wenn es gute Anwendungsf√§lle gibt). </li></ul><br><p>  Was auch immer Sie w√§hlen, verschiedene Archive oder JARs mit mehreren Versionen, das Schema ist das gleiche.  Multi-Release-JARs sind im Wesentlichen die falsche Verpackung: Sie sollten eine Option sein, aber nicht das Ziel.  Technisch gesehen ist das Quelllayout f√ºr einzelne und externe JARs gleich.  In diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository wird</a> beschrieben, wie Sie mit Gradle eine JAR mit mehreren Versionen erstellen.  Das Wesentliche des Prozesses wird nachstehend kurz beschrieben. </p><br><p>  Zun√§chst sollten Sie sich immer an eine schlechte Angewohnheit der Entwickler erinnern: Sie f√ºhren Gradle (oder Maven) mit derselben Java-Version aus, auf der Artefakte gestartet werden sollen.  Dar√ºber hinaus wird manchmal eine sp√§tere Version verwendet, um Gradle zu starten, und die Kompilierung erfolgt mit einer fr√ºheren API-Ebene.  Es gibt jedoch keinen besonderen Grund daf√ºr.  In Gradle ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ross-Kompilierung</a> m√∂glich.  Sie k√∂nnen die Position des JDK beschreiben und die Kompilierung als separaten Prozess ausf√ºhren, um die Komponente mit diesem JDK zu kompilieren.  Der beste Weg, um verschiedene JDKs zu konfigurieren, besteht darin, den Pfad zum JDK √ºber Umgebungsvariablen zu konfigurieren, wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in dieser Datei beschrieben</a> .  Dann m√ºssen Sie Gradle nur so konfigurieren, dass das richtige JDK verwendet wird, basierend auf der Kompatibilit√§t <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mit der Quell- / Zielplattform</a> .  Es ist anzumerken, dass ab JDK 9 fr√ºhere Versionen von JDK nicht f√ºr die Cross-Kompilierung ben√∂tigt werden.  Dies macht eine neue Funktion, -release.  Gradle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verwendet diese Funktion und konfiguriert den Compiler</a> nach Bedarf. </p><br><p>  Ein weiterer wichtiger Punkt ist der Bezeichnungsquellensatz.  Quellensatz ist ein Satz von Quelldateien, die zusammen kompiliert werden m√ºssen.  Eine JAR wird durch Kompilieren eines oder mehrerer Quellens√§tze erhalten.  F√ºr jeden Satz erstellt Gradle automatisch eine entsprechende benutzerdefinierte Kompilierungsaufgabe.  Dies bedeutet, dass sich Quellen f√ºr Java 8 und Java 9 in verschiedenen Gruppen befinden.  Genau so funktioniert es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Quellensatz f√ºr Java 9</a> , in dem es eine Version unserer Klasse geben wird.  Dies funktioniert wirklich und Sie m√ºssen kein separates Projekt erstellen, wie in Maven.  Am wichtigsten ist jedoch, dass Sie mit dieser Methode die Zusammenstellung des Sets optimieren k√∂nnen. </p><br><p>  Eine der Schwierigkeiten bei unterschiedlichen Versionen einer Klasse besteht darin, dass der Klassencode selten unabh√§ngig vom Rest des Codes ist (er hat Abh√§ngigkeiten von Klassen, die nicht im Hauptsatz enthalten sind).  Beispielsweise kann die API Klassen verwenden, die keine speziellen Quellen zur Unterst√ºtzung von Java 9 ben√∂tigen. Gleichzeitig m√∂chte ich nicht alle diese allgemeinen Klassen neu kompilieren und ihre Versionen f√ºr Java 9 packen. Sie sind allgemeine Klassen, daher m√ºssen sie getrennt von existieren Klassen f√ºr ein bestimmtes JDK.  Wir richten es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier ein</a> : F√ºgen Sie eine Abh√§ngigkeit zwischen dem Quellensatz f√ºr Java 9 und dem Hauptsatz hinzu, damit beim Kompilieren der Version f√ºr Java 9 alle allgemeinen Klassen im Kompilierungsklassenpfad verbleiben. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der n√§chste Schritt ist einfach</a> : Sie m√ºssen Gradle erkl√§ren, dass der Hauptquellensatz mit der Java 8-API-Ebene und der Satz f√ºr Java 9 mit der Java 9-Ebene kompiliert wird. </p><br><p>  All dies hilft Ihnen bei der Verwendung der beiden zuvor genannten Ans√§tze: Implementierung separater JAR-Archive oder JARs mit mehreren Versionen.  Da der Beitrag zu diesem Thema verfasst ist, sehen wir uns ein Beispiel an, wie Gradle dazu gebracht wird, eine JAR mit mehreren Versionen zu erstellen: </p><br><pre><code class="java hljs">jar { into(<span class="hljs-string"><span class="hljs-string">'META-INF/versions/9'</span></span>) { from sourceSets.java9.output } manifest.attributes( <span class="hljs-string"><span class="hljs-string">'Multi-Release'</span></span>: <span class="hljs-string"><span class="hljs-string">'true'</span></span> ) }</code> </pre> <br><p>  Dieser Block beschreibt: Packen von Klassen f√ºr Java 9 im Verzeichnis <em>META-INF /</em> version <em>/ 9</em> , das f√ºr MR-JARs verwendet wird, und Festlegen des Multi-Release-Labels im Manifest. </p><br><p>  Und fertig, Ihr erstes MR JAR ist fertig! </p><br><p>  Leider ist die Arbeit daran noch nicht abgeschlossen.  Wenn Sie mit Gradle gearbeitet haben, wissen Sie, dass Sie die Anwendung bei Verwendung des Anwendungs-Plugins direkt √ºber die <em>Ausf√ºhrungsaufgabe ausf√ºhren k√∂nnen</em> .  Aufgrund der Tatsache, dass Gradle normalerweise versucht, den Arbeitsaufwand zu minimieren, muss die <em>Ausf√ºhrungsaufgabe</em> sowohl die Klassenverzeichnisse als auch die Verzeichnisse der verarbeiteten Ressourcen verwenden.  Bei Multi-Release-JARs ist dies ein Problem, da JARs sofort ben√∂tigt werden!  Anstatt das Plugin zu verwenden, m√ºssen Sie daher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ihre eigene Aufgabe erstellen.</a> Dies ist ein Argument gegen die Verwendung von JARs mit mehreren Versionen. </p><br><p>  Und zu guter Letzt haben wir erw√§hnt, dass wir 2 Versionen der Klasse testen m√ºssen.  Zu diesem <em>Zweck</em> k√∂nnen Sie nur VM in einem separaten Prozess verwenden, da es f√ºr die Java-Laufzeit kein √Ñquivalent zum Marker <em>-release gibt</em> .  Die Idee ist, dass nur ein Test geschrieben werden muss, der jedoch zweimal ausgef√ºhrt wird: in Java 8 und Java 9. Nur so kann sichergestellt werden, dass die laufzeitspezifischen Klassen ordnungsgem√§√ü funktionieren.  Standardm√§√üig erstellt Gradle eine Testaufgabe und verwendet Klassenverzeichnisse auf dieselbe Weise anstelle der JAR.  Daher werden wir zwei Dinge tun: Erstellen Sie eine Testaufgabe f√ºr Java 9 und konfigurieren Sie beide Aufgaben so, dass sie die JAR und die angegebenen Java-Laufzeiten verwenden.  Die Implementierung sieht folgenderma√üen aus: </p><br><pre> <code class="java hljs">test { dependsOn jar def jdkHome = System.getenv(<span class="hljs-string"><span class="hljs-string">"JAVA_8"</span></span>) classpath = files(jar.archivePath, classpath) - sourceSets.main.output executable = file(<span class="hljs-string"><span class="hljs-string">"$jdkHome/bin/java"</span></span>) doFirst { println <span class="hljs-string"><span class="hljs-string">"$name runs test using JDK 8"</span></span> } } <span class="hljs-function"><span class="hljs-function">task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testJava9</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(type: Test)</span></span></span><span class="hljs-function"> </span></span>{ dependsOn jar def jdkHome = System.getenv(<span class="hljs-string"><span class="hljs-string">"JAVA_9"</span></span>) classpath = files(jar.archivePath, classpath) - sourceSets.main.output executable = file(<span class="hljs-string"><span class="hljs-string">"$jdkHome/bin/java"</span></span>) doFirst { println classpath.asPath println <span class="hljs-string"><span class="hljs-string">"$name runs test using JDK 9"</span></span> } } check.dependsOn(testJava9)</code> </pre> <br><p>  Wenn die Aufgabe gestartet wird, <em>√ºberpr√ºfen Sie</em> , <em>ob</em> Gradle jeden Quellensatz mit dem gew√ºnschten JDK kompiliert, eine JAR mit mehreren Versionen erstellt und die Tests mit dieser JAR auf beiden JDKs ausf√ºhrt.  Zuk√ºnftige Versionen von Gradle werden Ihnen dabei helfen, dies deklarativer zu tun. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Zusammenfassend.  Sie haben gelernt, dass Multi-Release-JARs ein Versuch sind, das eigentliche Problem zu l√∂sen, mit dem viele Bibliotheksentwickler konfrontiert sind.  Diese L√∂sung des Problems scheint jedoch falsch zu sein.  Richtiges Abh√§ngigkeitsmanagement, Verkn√ºpfung von Artefakten und Optionen, Sorge um die Leistung (die F√§higkeit, so viele Aufgaben wie m√∂glich parallel auszuf√ºhren) - all dies macht MR JAR zu einer L√∂sung f√ºr die Armen.  Dieses Problem kann mithilfe von Optionen korrekt gel√∂st werden.  W√§hrend sich das Abh√§ngigkeitsmanagement mit Optionen von Gradle in der Entwicklung befindet, sind JARs mit mehreren Releases in einfachen F√§llen recht praktisch.  In diesem Fall hilft Ihnen dieser Beitrag zu verstehen, wie dies zu tun ist und wie sich die Philosophie von Gradle von Maven unterscheidet (Quellensatz vs. Projekt). </p><br><p>  Schlie√ülich bestreiten wir nicht, dass es F√§lle gibt, in denen JARs mit mehreren Releases sinnvoll sind: Wenn beispielsweise nicht bekannt ist, in welcher Umgebung die Anwendung ausgef√ºhrt wird (keine Bibliothek), ist dies eher eine Ausnahme.  In diesem Beitrag haben wir die Hauptprobleme beschrieben, mit denen Bibliotheksentwickler konfrontiert sind, und wie JARs mit mehreren Versionen versuchen, sie zu l√∂sen.  Die korrekte Modellierung von Abh√§ngigkeiten als Optionen verbessert die Leistung (durch fein abgestimmte Parallelit√§t) und reduziert die Wartungskosten (Vermeidung unvorhergesehener Komplexit√§t) im Vergleich zu JARs mit mehreren Versionen.  In Ihrer Situation werden m√∂glicherweise auch MR-JARs ben√∂tigt, daher hat Gradle dies bereits erledigt.  Schauen Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Beispielprojekt an</a> und probieren Sie es selbst aus. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428868/">https://habr.com/ru/post/de428868/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428856/index.html">Ein wunderbarer Trick, um Open Source-Projektbetreuer zu einem Tag zu machen</a></li>
<li><a href="../de428858/index.html">DEFCON-Konferenz 17. Lachen Sie √ºber Ihre Viren! Teil 1</a></li>
<li><a href="../de428860/index.html">DEFCON-Konferenz 17. Lachen Sie √ºber Ihre Viren! Teil 2</a></li>
<li><a href="../de428864/index.html">Lassen Sie uns das Web wieder gro√üartig machen</a></li>
<li><a href="../de428866/index.html">7 Designprinzipien, Einstellung zu Designtrends, UX-Designer-Portfolio, ...</a></li>
<li><a href="../de428870/index.html">Mrr: Gesamt-FRP f√ºr React</a></li>
<li><a href="../de428872/index.html">Die Geschichte von einem Auge und 20 Operationen (nicht lesbar) oder er wollte Pilot werden, aber er durfte nicht in den Himmel</a></li>
<li><a href="../de428876/index.html">Es gibt kein Zur√ºck: die pers√∂nliche Erfahrung des Testers</a></li>
<li><a href="../de428878/index.html">Schweineflug oder Optimierung von Bytecode-Interpreten</a></li>
<li><a href="../de428880/index.html">Neue Authentifizierungsmethoden - eine Bedrohung f√ºr die Privatsph√§re?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>