<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌶️ 🍭 👨🏻‍🌾 Hochpräzise Zeit: Arbeiten mit Sekundenbruchteilen in MySQL und PHP 🙌🏽 🥒 🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Als ich dachte, dass ich bei der Arbeit mit der Zeit in Datenbanken fast immer die sekundengenaue Zeit verwende, nur weil ich daran gewöhnt bin und di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hochpräzise Zeit: Arbeiten mit Sekundenbruchteilen in MySQL und PHP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/469615/"><p><img src="https://habrastorage.org/webt/uu/43/0k/uu430kx8xpmnjcelv7obc41muik.jpeg"></p><br><p>  Als ich dachte, dass ich bei der Arbeit mit der Zeit in Datenbanken fast immer die sekundengenaue Zeit verwende, nur weil ich daran gewöhnt bin und dies die in der Dokumentation und in einer Vielzahl von Beispielen beschriebene Option ist.  Jetzt reicht diese Genauigkeit jedoch bei weitem nicht für alle Aufgaben aus.  Moderne Systeme sind komplex - sie können aus vielen Teilen bestehen, Millionen von Benutzern interagieren mit ihnen - und in vielen Fällen ist es bequemer, eine höhere Genauigkeit zu verwenden, deren Unterstützung seit langem besteht. </p><br><p>  In diesem Artikel werde ich über Möglichkeiten sprechen, Zeit mit Bruchteilen einer Sekunde in MySQL und PHP zu nutzen.  Es wurde als Tutorial konzipiert, daher ist das Material für eine breite Palette von Lesern konzipiert und wiederholt an einigen Stellen die Dokumentation.  Der Hauptwert sollte sein, dass ich in einem Text alles gesammelt habe, was Sie wissen müssen, um mit dieser Zeit in MySQL, PHP und dem Yii-Framework zu arbeiten, und auch Beschreibungen nicht offensichtlicher Probleme hinzugefügt habe, auf die Sie möglicherweise stoßen. </p><br><p>  Ich werde den Begriff "hochpräzise Zeit" verwenden.  In der MySQL-Dokumentation sehen Sie den Begriff "Sekundenbruchteil", aber seine wörtliche Übersetzung klingt seltsam, aber ich habe keine andere etablierte Übersetzung gefunden. </p><a name="habracut"></a><br><h2 id="kogda-stoit-ispolzovat-vremya-vysokoy-tochnosti">  Wann sollte eine hochpräzise Zeit verwendet werden? </h2><br><p>  Für den Anfang zeige ich einen Screenshot des Posteingangs meines Posteingangs, der die Idee gut veranschaulicht: </p><br><p><img src="https://habrastorage.org/webt/bc/tg/gx/bctggxr0qbeetqe9hmmb4zjmbom.png" alt="Zwei Briefe von einem Absender"></p><br><p>  Briefe sind die Reaktion derselben Person auf ein Ereignis.  Ein Mann drückte versehentlich den falschen Knopf, erkannte dies schnell und korrigierte sich.  Infolgedessen haben wir ungefähr zur gleichen Zeit zwei Briefe erhalten, die wichtig sind, um richtig zu sortieren.  Wenn die Sendezeit gleich ist, besteht die Möglichkeit, dass die Briefe in der falschen Reihenfolge angezeigt werden und der Empfänger in Verlegenheit gebracht wird, da er dann das falsche Ergebnis erhält, für das er zählt. </p><br><p>  Ich bin auf folgende Situationen gestoßen, in denen eine Zeit mit hoher Genauigkeit relevant wäre: </p><br><ol><li>  Sie möchten die Zeit zwischen einigen Vorgängen messen.  Hier ist alles sehr einfach: Je höher die Genauigkeit der Zeitstempel an den Grenzen des Intervalls ist, desto höher ist die Genauigkeit des Ergebnisses.  Wenn Sie ganze Sekunden verwenden, können Sie 1 Sekunde lang einen Fehler machen (wenn Sie an die Grenzen von Sekunden fallen).  Wenn Sie sechs Dezimalstellen verwenden, ist der Fehler um sechs Größenordnungen niedriger. </li><li>  Sie haben eine Sammlung, in der es wahrscheinlich mehrere Objekte mit derselben Erstellungszeit gibt.  Ein Beispiel ist ein jedem vertrauter Chat, bei dem die Kontaktliste nach dem Zeitpunkt der letzten Nachricht sortiert ist.  Wenn eine seitenweise Navigation angezeigt wird, besteht sogar die Gefahr, dass Kontakte an den Seitenrändern verloren gehen.  Dieses Problem kann ohne Zeit mit hoher Genauigkeit gelöst werden, da nach einem Feldpaar (Zeit + eindeutige Kennung eines Objekts) sortiert und paginiert wird. Diese Lösung hat jedoch ihre Nachteile (zumindest die Komplexität von SQL-Abfragen, aber nicht nur das).  Durch Erhöhen der Zeitgenauigkeit wird die Wahrscheinlichkeit von Problemen verringert und das System nicht kompliziert. </li><li> Sie müssen einen Änderungsverlauf eines Objekts führen.  Dies ist besonders wichtig in der Servicewelt, in der Änderungen parallel und an völlig unterschiedlichen Orten vorgenommen werden können.  Als Beispiel kann ich mit Fotos unserer Benutzer arbeiten, wobei viele verschiedene Vorgänge parallel ausgeführt werden können (der Benutzer kann das Foto privat machen oder löschen, es kann in einem von mehreren Systemen moderiert, zur Verwendung als Foto im Chat zugeschnitten usw.). ) </li></ol><br><p>  Es muss beachtet werden, dass man den erhaltenen Werten nicht zu 100% vertrauen kann und die tatsächliche Genauigkeit der erhaltenen Werte weniger als sechs Dezimalstellen betragen kann.  Dies liegt an der Tatsache, dass wir einen ungenauen Zeitwert erhalten können (insbesondere wenn wir in einem verteilten System arbeiten, das aus vielen Servern besteht), die Zeit sich unerwartet ändern kann (z. B. beim Synchronisieren über NTP oder beim Ändern der Uhr) usw. Ich werde nicht auf all diese Probleme eingehen, aber ich werde ein paar Artikel geben, in denen Sie mehr darüber lesen können: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Die Fehler der Programmierer in Bezug auf die Zeit"</a> (der Artikel selbst ist sehr minimalistisch, aber zusätzlich zu den Thesen aus dem Text finden sich Erklärungen in den Kommentaren); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Die schwere Last der Zeit</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"</a> </li></ul><br><h2 id="rabota-so-vremenem-vysokoy-tochnosti-v-mysql">  Arbeiten Sie mit hochpräziser Zeit in MySQL </h2><br><p> MySQL unterstützt drei Arten von Spalten, in denen Zeit gespeichert werden kann: <code>TIME</code> , <code>DATETIME</code> und <code>TIMESTAMP</code> .  Anfangs konnten sie nur Werte speichern, die ein Vielfaches einer Sekunde waren (z. B. 2019-08-14 19:20:21).  In der im Dezember 2011 veröffentlichten Version 5.6.4 wurde es möglich, mit dem Bruchteil einer Sekunde zu arbeiten.  Dazu müssen Sie beim Erstellen der Spalte die Anzahl der Dezimalstellen angeben, die im Bruchteil des Zeitstempels gespeichert werden müssen.  Die maximale Anzahl unterstützter Zeichen beträgt sechs, sodass Sie die Zeit auf die Mikrosekunde genau speichern können.  Wenn Sie versuchen, mehr Zeichen zu verwenden, wird eine Fehlermeldung angezeigt. </p><br><p>  Ein Beispiel: </p><br><pre> <code class="sql hljs">Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">`ChatContactsList`</span></span> ( <span class="hljs-string"><span class="hljs-string">`chat_id`</span></span> <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> AUTO_INCREMENT PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>, <span class="hljs-string"><span class="hljs-string">`title`</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">`last_message_send_time`</span></span> <span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ENGINE</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">InnoDB</span></span>; Query OK, 0 rows affected (0.02 sec) Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">`ChatContactsList`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MODIFY</span></span> last_message_send_time <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; ERROR 1426 (42000): Too-big precision 9 specified for 'last_message_send_time'. Maximum is 6. Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">`ChatContactsList`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MODIFY</span></span> last_message_send_time <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; Query OK, 0 rows affected (0.09 sec) Records: 0 Duplicates: 0 Warnings: 0 Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> ChatContactsList (title, last_message_send_time) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'Chat #1'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NOW</span></span>()); Query OK, 1 row affected (0.03 sec) Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ChatContactsList; +<span class="hljs-comment"><span class="hljs-comment">---------+---------+-------------------------+ | chat_id | title | last_message_send_time | +---------+---------+-------------------------+ | 1 | Chat #1 | 2019-09-22 22:23:15.000 | +---------+---------+-------------------------+ 1 row in set (0.00 sec)</span></span></code> </pre> <br><p>  In diesem Beispiel hat der Zeitstempel des eingefügten Datensatzes einen Nullbruch.  Dies geschah, weil der Eingabewert auf die nächste Sekunde genau angezeigt wurde.  Um das Problem zu lösen, muss die Genauigkeit des Eingabewerts mit dem Wert in der Datenbank übereinstimmen.  Der Rat scheint offensichtlich, ist aber relevant, da in realen Anwendungen ein ähnliches Problem auftreten kann: Wir waren mit einer Situation konfrontiert, in der der Eingabewert drei Dezimalstellen hatte und sechs in der Datenbank gespeichert waren. </p><br><p>  Der einfachste Weg, um dieses Problem zu verhindern, besteht darin, die Eingabewerte mit maximaler Genauigkeit (bis zu Mikrosekunden) zu verwenden.  In diesem Fall wird beim Schreiben von Daten in die Tabelle die Zeit auf die erforderliche Genauigkeit gerundet.  Dies ist eine absolut normale Situation, die keine Warnung (en) hervorruft: </p><br><pre> <code class="sql hljs">Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> ChatContactsList <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> last_message_send_time=<span class="hljs-string"><span class="hljs-string">"2019-09-22 22:23:15.2345"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> chat_id=<span class="hljs-number"><span class="hljs-number">1</span></span>; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ChatContactsList; +<span class="hljs-comment"><span class="hljs-comment">---------+---------+-------------------------+ | chat_id | title | last_message_send_time | +---------+---------+-------------------------+ | 1 | Chat #1 | 2019-09-22 22:23:15.235 | +---------+---------+-------------------------+ 1 row in set (0.00 sec)</span></span></code> </pre> <br><p>  Bei Verwendung der automatischen Initialisierung und automatischen Aktualisierung von TIMESTAMP-Spalten unter Verwendung einer Struktur der Form <code>DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</code> es wichtig, dass die Werte dieselbe Genauigkeit wie die Spalte selbst haben: </p><br><pre> <code class="sql hljs">Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> ChatContactsList <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">updated</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_TIMESTAMP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_TIMESTAMP</span></span>; ERROR 1067 (42000): Invalid default value for 'updated' Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> ChatContactsList <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">updated</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>); ERROR 1067 (42000): Invalid default value for 'updated' Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> ChatContactsList <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">updated</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>); Query OK, 0 rows affected (0.07 sec) Records: 0 Duplicates: 0 Warnings: 0 Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> ChatContactsList <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> last_message_send_time=<span class="hljs-string"><span class="hljs-string">'2019-09-22 22:22:22'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> chat_id=<span class="hljs-number"><span class="hljs-number">1</span></span>; Query OK, 0 rows affected (0.00 sec) Rows matched: 1 Changed: 0 Warnings: 0 Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ChatContactsList; +<span class="hljs-comment"><span class="hljs-comment">---------+---------+-------------------------+-------------------------+ | chat_id | title | last_message_send_time | updated | +---------+---------+-------------------------+-------------------------+ | 1 | Chat #1 | 2019-09-22 22:22:22.000 | 2019-09-22 22:26:39.968 | +---------+---------+-------------------------+-------------------------+ 1 row in set (0.00 sec)</span></span></code> </pre> <br><p>  MySQL-Funktionen für das Arbeiten im Laufe der Zeit unterstützen das Arbeiten mit dem Bruchteil der Maßeinheiten.  Ich werde sie nicht alle auflisten (ich schlage vor, in der Dokumentation nachzuschauen), aber ich werde einige Beispiele geben: </p><br><pre> <code class="sql hljs">Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOW</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">NOW</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">NOW</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">INTERVAL</span></span> <span class="hljs-number"><span class="hljs-number">7.5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SECOND</span></span>; +<span class="hljs-comment"><span class="hljs-comment">------------------------+--------------------------+------------------------------+ | NOW(2) | NOW(4) | NOW(4) + INTERVAL 7.5 SECOND | +------------------------+--------------------------+------------------------------+ | 2019-09-22 21:12:23.31 | 2019-09-22 21:12:23.3194 | 2019-09-22 21:12:30.8194 | +------------------------+--------------------------+------------------------------+ 1 row in set (0.00 sec) Test&gt; SELECT SUBTIME(CURRENT_TIME(6), CURRENT_TIME(3)), CURRENT_TIME(6), CURRENT_TIME(3); +-------------------------------------------+-----------------+-----------------+ | SUBTIME(CURRENT_TIME(6), CURRENT_TIME(3)) | CURRENT_TIME(6) | CURRENT_TIME(3) | +-------------------------------------------+-----------------+-----------------+ | 00:00:00.000712 | 21:12:50.793712 | 21:12:50.793 | +-------------------------------------------+-----------------+-----------------+ 1 row in set (0.00 sec)</span></span></code> </pre> <br><p>  Das Hauptproblem bei der Verwendung des Bruchteils von Sekunden in SQL-Abfragen ist die Inkonsistenz der Genauigkeit bei Vergleichen ( <code>&gt;</code> , <code>&lt;</code> , <code>BETWEEN</code> ).  Sie können darauf stoßen, wenn die Daten in der Datenbank eine Genauigkeit und in den Abfragen eine andere haben.  Hier ist ein kleines Beispiel, das dieses Problem veranschaulicht: </p><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">#         Test&gt; INSERT INTO ChatContactsList (title, last_message_send_time) VALUES ('Chat #2', '2019-09-22 21:16:39.123456'); Query OK, 0 row affected (0.00 sec) Test&gt; SELECT chat_id, title, last_message_send_time FROM ChatContactsList WHERE title='Chat #2'; +---------+---------+-------------------------+ | chat_id | title | last_message_send_time | +---------+---------+-------------------------+ | 2 | Chat #2 | 2019-09-22 21:16:39.123 | &lt;-     - ,    +---------+---------+-------------------------+ 1 row in set (0.00 sec) Test&gt; SELECT title, last_message_send_time FROM ChatContactsList WHERE last_message_send_time &gt;= '2019-09-22 21:16:39.123456'; &lt;-    ,    INSERT- +---------+-------------------------+ | title | last_message_send_time | +---------+-------------------------+ | Chat #1 | 2019-09-22 22:22:22.000 | +---------+-------------------------+ 1 row in set (0.00 sec) &lt;- Chat #2   - ,     ,    </span></span></code> </pre> <br><p>  In diesem Beispiel ist die Genauigkeit der Werte in der Abfrage höher als die Genauigkeit der Werte in der Datenbank, und das Problem tritt "an der Grenze von oben" auf.  In der umgekehrten Situation (wenn der Eingabewert eine Genauigkeit aufweist, die niedriger als der Wert in der Datenbank ist) gibt es kein Problem - MySQL bringt den Wert sowohl in INSERT als auch in SELECT auf die gewünschte Genauigkeit: </p><br><pre> <code class="sql hljs">Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> ChatContactsList (title, last_message_send_time) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'Chat #3'</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-09-03 21:20:19.1'</span></span>); Query OK, 1 row affected (0.00 sec) Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> title, last_message_send_time <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ChatContactsList <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> last_message_send_time &lt;= <span class="hljs-string"><span class="hljs-string">'2019-09-03 21:20:19.1'</span></span>; +<span class="hljs-comment"><span class="hljs-comment">---------+-------------------------+ | title | last_message_send_time | +---------+-------------------------+ | Chat #3 | 2019-09-03 21:20:19.100 | +---------+-------------------------+ 1 row in set (0.00 sec)</span></span></code> </pre> <br><p>  Die Konsistenz der Genauigkeit von Werten sollte immer beachtet werden, wenn mit hochpräziser Zeit gearbeitet wird.  Wenn solche Grenzprobleme für Sie kritisch sind, müssen Sie sicherstellen, dass der Code und die Datenbank mit der gleichen Anzahl von Dezimalstellen funktionieren. </p><br><div class="spoiler">  <b class="spoiler_title">Gedanken zur Auswahl der Genauigkeit in Spalten mit Bruchteilen von Sekunden</b> <div class="spoiler_text"><p>  Die Menge an Platz, die der Bruchteil einer Zeiteinheit einnimmt, hängt von der Anzahl der Zeichen in der Spalte ab.  Es erscheint natürlich, bekannte Bedeutungen zu wählen: drei oder sechs Dezimalstellen.  Bei drei Zeichen ist dies jedoch nicht so einfach.  Tatsächlich verwendet MySQL ein Byte, um zwei Dezimalstellen zu speichern: </p><br><blockquote><div class="scrollable-table"><table><thead><tr><th>  Sekundenbruchteilpräzision </th><th>  Speicheranforderungen </th></tr></thead><tbody><tr><td>  0 </td><td>  0 Bytes </td></tr><tr><td>  1, 2 </td><td>  1 Byte </td></tr><tr><td>  3, 4 </td><td>  2 Bytes </td></tr><tr><td>  5, 6 </td><td>  3 Bytes </td></tr></tbody></table></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicheranforderungen für Datum und Uhrzeit</a> </blockquote><p>  Es stellt sich heraus, dass Sie bei Auswahl von drei Dezimalstellen den belegten Platz nicht voll ausnutzen und für denselben Overhead vier Zeichen verwenden können.  Im Allgemeinen empfehle ich, dass Sie bei der Ausgabe immer eine gerade Anzahl von Zeichen verwenden und gegebenenfalls unnötige Zeichen „zuschneiden“.  Die ideale Option ist, nicht gierig zu sein und sechs Dezimalstellen zu nehmen.  Im schlimmsten Fall (mit dem Typ DATETIME) belegt diese Spalte 8 Bytes, dh dieselbe Ganzzahl wie die Ganzzahl in der Spalte BIGINT. </p></div></div><br><p>  Siehe auch: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Bruchsekunden in Zeitwerten"</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Automatische Initialisierung und Aktualisierung für TIMESTAMP und DATETIME"</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Datums- und Zeitfunktionen"</a> . </li></ul><br><h2 id="rabota-so-vremenem-vysokoy-tochnosti-v-php">  Arbeiten Sie mit hochpräziser Zeit in PHP </h2><br><p>  Es reicht nicht aus, eine hochpräzise Zeit in der Datenbank zu haben - Sie müssen in der Lage sein, im Code Ihrer Programme damit zu arbeiten.  In diesem Abschnitt werde ich über drei Hauptpunkte sprechen: </p><br><ol><li>  Empfangs- und Formatierungszeit: Ich werde erklären, wie der Zeitstempel abgerufen wird, bevor er in die Datenbank gestellt, von dort abgerufen und manipuliert wird. </li><li>  Arbeiten mit der Zeit in PDO: Ich zeige Ihnen ein Beispiel dafür, wie PHP die Formatierungszeit in einer Datenbankbibliothek unterstützt. </li><li>  Arbeiten mit der Zeit in Frameworks: Ich werde über die Verwendung von Zeit in Migrationen sprechen, um die Struktur der Datenbank zu ändern. </li></ol><br><h3 id="poluchenie-i-formatirovanie-vremeni">  Zeit abrufen und formatieren </h3><br><p>  Wenn Sie mit der Zeit arbeiten, müssen Sie einige grundlegende Vorgänge ausführen können: </p><br><ul><li>  den aktuellen Zeitpunkt abrufen; </li><li>  einen Moment in der Zeit von einer formatierten Zeichenfolge bekommen; </li><li>  Hinzufügen einer Periode zu einem Zeitpunkt (oder Subtrahieren einer Periode); </li><li>  Abrufen einer formatierten Zeichenfolge für einen bestimmten Zeitpunkt. </li></ul><br><p>  In diesem Teil werde ich Ihnen sagen, welche Möglichkeiten zur Ausführung dieser Operationen in PHP bestehen. </p><br><p>  Die erste Möglichkeit besteht darin, mit <strong>einem Zeitstempel als Zahl zu arbeiten</strong> .  In diesem Fall arbeiten wir im PHP-Code mit numerischen Variablen, die wir über Funktionen wie <code>time</code> , <code>date</code> und <code>strtotime</code> .  Diese Methode kann nicht verwendet werden, um mit hochpräziser Zeit zu arbeiten, da in all diesen Funktionen die Zeitstempel eine Ganzzahl sind (was bedeutet, dass der Bruchteil in ihnen verloren geht). </p><br><p>  Hier sind die Unterschriften der wichtigsten derartigen Funktionen aus der offiziellen Dokumentation: </p><br><blockquote> <code>time ( void ) : int</code> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.php.net/manual/ru/function.time.php</a> <br><br> <code>strtotime ( string $time [, int $now = time() ] ) : int</code> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://php.net/manual/ru/function.strtotime.php</a> <br><br> <code>date ( string $format [, int $timestamp = time() ] ) : string</code> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://php.net/manual/ru/function.date.php</a> <br><br> <code>strftime ( string $format [, int $timestamp = time() ] ) : string</code> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.php.net/manual/ru/function.strftime.php</a> </blockquote><br><div class="spoiler">  <b class="spoiler_title">Ein interessanter Punkt zur Datumsfunktion</b> <div class="spoiler_text"><p>  Obwohl es unmöglich ist, den Bruchteil einer Sekunde an die Eingabe dieser Funktionen zu übergeben, können Sie in der Zeile der Formatierungsvorlage, die an die Eingabe der <code>date</code> wird, Zeichen so einstellen, dass Millisekunden und Mikrosekunden angezeigt werden.  Bei der Formatierung werden Nullen immer an ihrer Stelle zurückgegeben. </p><br><div class="scrollable-table"><table><thead><tr><th>  Zeichen im Zeichenfolgenformat </th><th>  Beschreibung </th><th>  Beispiel für einen Rückgabewert </th></tr></thead><tbody><tr><td>  u </td><td>  Mikrosekunden (hinzugefügt in PHP 5.2.2).  Beachten Sie, dass date () immer 000000 als zurückgibt  Es wird ein ganzzahliger Parameter verwendet, während DateTime :: format () Mikrosekunden unterstützt, wenn DateTime mit ihnen erstellt wird. </td><td>  Zum Beispiel: 654321 </td></tr><tr><td>  v </td><td>  Millisekunden (hinzugefügt in PHP 7.0.0).  Die Bemerkung ist die gleiche wie für u. </td><td>  Zum Beispiel: 654 </td></tr></tbody></table></div><br><p>  Ein Beispiel: </p><br><pre> <code class="php hljs">$now = time(); <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> date(<span class="hljs-string"><span class="hljs-string">'Ymd H:i:s.u'</span></span>, $now); <span class="hljs-comment"><span class="hljs-comment">// 2019-09-11 21:27:18.000000 print date('Ymd H:i:s.v', $now); // 2019-09-11 21:27:18.000</span></span></code> </pre> </div></div><br><p>  Zu dieser Methode gehören auch <code>microtime</code> und <code>hrtime</code> , mit denen Sie einen <code>hrtime</code> mit einem Bruchteil für den aktuellen Moment erhalten können.  Das Problem ist, dass es keine vorgefertigte Möglichkeit gibt, ein solches Etikett zu formatieren und es aus einer Zeichenfolge eines bestimmten Formats abzurufen.  Dies kann durch unabhängige Implementierung dieser Funktionen gelöst werden, aber ich werde eine solche Option nicht in Betracht ziehen. </p><br><blockquote>  Wenn Sie nur mit Timern arbeiten müssen, ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HRTime-</a> Bibliothek eine gute Option, auf die ich aufgrund der Einschränkungen ihrer Verwendung nicht näher eingehen werde.  Ich kann nur sagen, dass Sie damit mit der Zeit bis zur Nanosekunde arbeiten können und die Monotonie der Timer garantieren, wodurch einige der Probleme beseitigt werden, die bei der Arbeit mit anderen Bibliotheken auftreten können. </blockquote><p>  Um mit Bruchteilen einer Sekunde vollständig arbeiten zu können, müssen Sie das <strong>DateTime-</strong> Modul verwenden.  Mit bestimmten Vorbehalten können Sie alle oben aufgeführten Vorgänge ausführen: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//    : $time = new \DateTimeImmutable(); //      : $time = new \DateTimeImmutable('2019-09-12 21:32:43.908502'); $time = \DateTimeImmutable::createFromFormat('Ymd H:i:s.u', '2019-09-12 21:32:43.9085'); // / : $period = \DateInterval::createFromDateString('5 seconds'); $timeBefore = $time-&gt;add($period); $timeAfter = $time-&gt;sub($period); //      : print $time-&gt;format('Ymd H:i:s.v'); // '2019-09-12 21:32:43.908' print $time-&gt;format("Ymd H:i:su"); // '2019-09-12 21:32:43.908502'</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Der nicht offensichtliche Punkt bei der Verwendung von "DateTimeImmutable :: createFromFormat"</b> <div class="spoiler_text"><p>  Der Buchstabe <code>u</code> in der Formatzeichenfolge bedeutet Mikrosekunden, funktioniert aber auch bei Bruchteilen mit geringerer Genauigkeit korrekt.  Darüber hinaus ist dies die einzige Möglichkeit, Bruchteile einer Sekunde in einer Formatzeichenfolge anzugeben.  Ein Beispiel: </p><br><pre> <code class="php hljs">$time = \DateTimeImmutable::createFromFormat(<span class="hljs-string"><span class="hljs-string">'Ymd H:i:s.u'</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-09-12 21:32:43.9085'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// =&gt;   DateTimeImmutable    2019-09-12 21:32:43.908500 $time = \DateTimeImmutable::createFromFormat('Ymd H:i:s.u', '2019-09-12 21:32:43.90'); // =&gt;   DateTimeImmutable    2019-09-12 21:32:43.900000 $time = \DateTimeImmutable::createFromFormat('Ymd H:i:s.u', '2019-09-12 21:32:43'); // =&gt;  false</span></span></code> </pre> </div></div><br><p>  Das Hauptproblem dieses Moduls ist die Unannehmlichkeit beim Arbeiten mit Intervallen, die Sekundenbruchteile enthalten (oder sogar die Unmöglichkeit einer solchen Arbeit).  Die <code>\DateInterval</code> enthält den Bruchteil einer Sekunde, der auf die gleichen sechs Dezimalstellen genau ist. Sie können diesen Bruchteil jedoch nur über <code>DateTime::diff</code> initialisieren.  Der Konstruktor der DateInterval-Klasse und die Factory-Methode <code>\DateInterval::createFromDateString</code> können nur mit ganzen Sekunden arbeiten und erlauben nicht, den Bruchteil anzugeben: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//     -   $buggyPeriod1 = new \DateInterval('PT7.500S'); //       ,    $buggyPeriod2 = \DateInterval::createFromDateString('2 minutes 7.5 seconds'); print $buggyPeriod2-&gt;format('%R%H:%I:%S.%F') . PHP_EOL; //  "+00:02:00.000000"</span></span></code> </pre> <br><p>  Ein weiteres Problem kann auftreten, wenn die Differenz zwischen zwei Zeitpunkten mit der Methode <code>\DateTimeImmutable::diff</code> berechnet wird.  In PHP vor Version 7.2.12 gab es einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehler,</a> aufgrund dessen die Bruchteile einer Sekunde getrennt von anderen Ziffern existierten und ein eigenes Vorzeichen erhalten konnten: </p><br><pre> <code class="php hljs">$timeBefore = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \DateTimeImmutable(<span class="hljs-string"><span class="hljs-string">'2019-09-12 21:20:19.987654'</span></span>); $timeAfter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \DateTimeImmutable(<span class="hljs-string"><span class="hljs-string">'2019-09-14 12:13:14.123456'</span></span>); $diff = $timeBefore-&gt;diff($timeAfter); <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $diff-&gt;format(<span class="hljs-string"><span class="hljs-string">'%R%a days %H:%I:%S.%F'</span></span>) . PHP_EOL; <span class="hljs-comment"><span class="hljs-comment">//  PHP  7.2.12+   "+1 days 14:52:54.135802" //       "+1 days 14:52:55.-864198"</span></span></code> </pre> <br><p>  Im Allgemeinen rate ich Ihnen, beim Arbeiten mit Intervallen vorsichtig zu sein und diesen Code sorgfältig mit Tests abzudecken. </p><br><p>  Siehe auch: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Datum und Uhrzeit"</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Stundenfunktion."</a> </li></ul><br><h3 id="rabota-so-vremenem-vysokoy-tochnosti-v-pdo">  Arbeiten Sie mit hoher Präzision in PDO </h3><br><p>  PDO und mysqli sind die beiden Hauptschnittstellen zum Abfragen von MySQL-Datenbanken aus PHP-Code.  Im Zusammenhang mit einem Gespräch über die Zeit sind sie einander ähnlich, daher werde ich nur über einen von ihnen sprechen - PDO. </p><br><p>  Bei der Arbeit mit Datenbanken in PDO wird die Zeit an zwei Stellen angezeigt: </p><br><ul><li>  als Parameter, der an ausgeführte Abfragen übergeben wird; </li><li>  als Wert, der als Antwort auf SELECT-Abfragen kommt. </li></ul><br><p>  Es wird empfohlen, Platzhalter zu übergeben, wenn Parameter an die Anforderung übergeben werden.  Platzhalter können Werte aus einer sehr kleinen Gruppe von Typen übertragen: Boolesche Werte, Zeichenfolgen und Ganzzahlen.  Es gibt keinen geeigneten Typ für Datum und Uhrzeit, daher müssen Sie den Wert von einem Objekt der DateTime / DateTimeImmutable-Klasse manuell in eine Zeichenfolge konvertieren. </p><br><pre> <code class="php hljs">$now = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \DateTimeImmutable(); $db = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \PDO(<span class="hljs-string"><span class="hljs-string">'mysql:...'</span></span>, <span class="hljs-string"><span class="hljs-string">'user'</span></span>, <span class="hljs-string"><span class="hljs-string">'password'</span></span>, [\PDO::ATTR_ERRMODE =&gt; \PDO::ERRMODE_EXCEPTION]); $stmt = $db-&gt;prepare(<span class="hljs-string"><span class="hljs-string">'INSERT INTO Test.ChatContactsList (title, last_message_send_time) VALUES (:title, :date)'</span></span>); $result = $stmt-&gt;execute([<span class="hljs-string"><span class="hljs-string">':title'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"Test #1"</span></span>, <span class="hljs-string"><span class="hljs-string">':date'</span></span> =&gt; $now-&gt;format(<span class="hljs-string"><span class="hljs-string">'Ymd H:i:s.u'</span></span>)]);</code> </pre> <br><p>  Die Verwendung eines solchen Codes ist nicht sehr praktisch, da Sie den übertragenen Wert jedes Mal formatieren müssen.  Daher haben wir in der Badoo-Codebasis die Unterstützung für typisierte Platzhalter in unserem Wrapper für die Arbeit mit der Datenbank implementiert.  Bei Datumsangaben ist dies sehr praktisch, da Sie damit einen Wert in verschiedenen Formaten übertragen können (ein Objekt, das DateTimeInterface implementiert, eine formatierte Zeichenfolge oder eine Zahl mit einem Zeitstempel) und alle erforderlichen Transformationen und Überprüfungen der Richtigkeit der übertragenen Werte bereits im Inneren durchgeführt werden.  Als Bonus erfahren wir beim Übertragen eines falschen Werts sofort von dem Fehler und nicht, nachdem wir beim Ausführen der Abfrage einen Fehler von MySQL erhalten haben. </p><br><p>  Das Abrufen von Daten aus Abfrageergebnissen sieht ziemlich einfach aus.  Bei der Ausführung dieser Operation gibt PDO die Daten in Form von Zeichenfolgen zurück, und im Code müssen wir die Ergebnisse weiterverarbeiten, wenn wir mit Zeitobjekten arbeiten möchten (und hier benötigen wir die Funktionalität, um die Zeit aus der formatierten Zeichenfolge abzurufen, über die ich im vorherigen Abschnitt gesprochen habe). </p><br><pre> <code class="php hljs">$stmt = $db-&gt;prepare(<span class="hljs-string"><span class="hljs-string">'SELECT * FROM Test.ChatContactsList ORDER BY last_message_send_time DESC, chat_id DESC LIMIT 5'</span></span>); $stmt-&gt;execute(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($row = $stmt-&gt;fetch(PDO::FETCH_ASSOC)) { $row[<span class="hljs-string"><span class="hljs-string">'last_message_send_time'</span></span>] = is_null($row[<span class="hljs-string"><span class="hljs-string">'last_message_send_time'</span></span>]) ? <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \DateTimeImmutable($row[<span class="hljs-string"><span class="hljs-string">'last_message_send_time'</span></span>]); <span class="hljs-comment"><span class="hljs-comment">//  -  }</span></span></code> </pre> <br><blockquote>  Hinweis <br><br>  Die Tatsache, dass PDO Daten als Zeichenfolgen zurückgibt, ist nicht ganz richtig.  Beim Empfang von Werten kann der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>PDOStatement::bindColumn</code></a> für die Spalte mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>PDOStatement::bindColumn</code></a> .  Ich habe nicht darüber gesprochen, weil es die gleiche begrenzte Anzahl von Typen gibt, die bei Datumsangaben nicht hilfreich sind. </blockquote><p>  Leider gibt es ein Problem zu beachten.  In PHP vor Version 7.3 gibt es einen Fehler, aufgrund dessen PDO, wenn das Attribut <code>PDO::ATTR_EMULATE_PREPARES</code> den Bruchteil einer Sekunde "abschneidet", wenn es von der Datenbank empfangen wird.  Details und ein Beispiel finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehlerbeschreibung auf php.net</a> .  In PHP 7.3 wurde dieser Fehler behoben und gewarnt, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese Änderung die Abwärtskompatibilität beeinträchtigt</a> . </p><br><p>  Wenn Sie PHP Version 7.2 oder älter verwenden und es nicht aktualisieren oder <code>PDO::ATTR_EMULATE_PREPARES</code> , können Sie diesen Fehler <code>PDO::ATTR_EMULATE_PREPARES</code> , indem Sie SQL-Abfragen korrigieren, die die Zeit mit einem Bruchteil zurückgeben, sodass diese Spalte einen Zeichenfolgentyp hat.  Dies kann zum Beispiel folgendermaßen geschehen: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> *, <span class="hljs-keyword"><span class="hljs-keyword">CAST</span></span>(last_message_send_time <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHAR</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> last_message_send_time_fixed <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ChatContactsList <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> last_message_send_time <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><p>  Dieses Problem kann auch bei der Arbeit mit dem <code>mysqli</code> Modul auftreten: Wenn Sie vorbereitete Abfragen über einen Aufruf der <code>mysqli::prepare</code> Methode verwenden, wird in PHP vor Version 7.3 der Bruchteil einer Sekunde nicht zurückgegeben.  Wie bei PDO können Sie dies beheben, indem Sie PHP aktualisieren oder die Zeitkonvertierung in einen Zeichenfolgentyp umgehen. </p><br><p>  Siehe auch: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Vorbereitete Abfragen und gespeicherte Prozeduren in PDO"</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Vorbereitete Abfragen in mysqli"</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation zur Methode mysqli_stmt :: bind_param</a> (hier werden die in mysqli unterstützten Platzhaltertypen beschrieben); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Poolanforderung an PHP, in der die "Kürzung" des Bruchteils von Sekunden behoben wurde</a> . </li></ul><br><h3 id="rabota-so-vremenem-vysokoy-tochnosti-v-yii-2">  Arbeiten Sie in Yii 2 mit hoher Präzision </h3><br><p>  Die meisten modernen Frameworks bieten Migrationsfunktionen, mit denen Sie den Verlauf von Datenbankschemaänderungen im Code speichern und schrittweise ändern können.  Wenn Sie Migrationen verwenden und hochpräzise Zeit verwenden möchten, sollte Ihr Framework dies unterstützen.  Glücklicherweise funktioniert dies in allen wichtigen Frameworks sofort. </p><br><p>  In diesem Abschnitt werde ich zeigen, wie diese Unterstützung in Yii implementiert ist (in den Beispielen, in denen ich Version 2.0.26 verwendet habe).  Über Laravel, Symfony und andere werde ich nicht schreiben, um den Artikel nicht endlos zu machen, aber ich würde mich freuen, wenn Sie Details in den Kommentaren oder neuen Artikeln zu diesem Thema hinzufügen. </p><br><p>  Bei der Migration schreiben wir Code, der Änderungen am Datenschema beschreibt.  Beim Erstellen einer neuen Tabelle beschreiben wir alle Spalten mit speziellen Methoden aus der Klasse \ yii \ db \ Migration (sie werden in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Taskleiste SchemaBuilderTrait</a> deklariert).  Die Methoden <code>time</code> , <code>timestamp</code> und <code>datetime</code> , die einen Eingabewert für die Genauigkeit <code>datetime</code> können, sind für die Beschreibung von Spalten verantwortlich, die Datum und Uhrzeit enthalten. </p><br><p>  Ein Beispiel für eine Migration, bei der eine neue Tabelle mit einer hochpräzisen Zeitspalte erstellt wird: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">yii</span></span>\<span class="hljs-title"><span class="hljs-title">db</span></span>\<span class="hljs-title"><span class="hljs-title">Migration</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m190914_141123_create_news_table</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Migration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">up</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;createTable(<span class="hljs-string"><span class="hljs-string">'news'</span></span>, [ <span class="hljs-string"><span class="hljs-string">'id'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;primaryKey(), <span class="hljs-string"><span class="hljs-string">'title'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;string()-&gt;notNull(), <span class="hljs-string"><span class="hljs-string">'content'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;text(), <span class="hljs-string"><span class="hljs-string">'published'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;timestamp(<span class="hljs-number"><span class="hljs-number">6</span></span>), <span class="hljs-comment"><span class="hljs-comment">//     ]); } public function down() { $this-&gt;dropTable('news'); } }</span></span></code> </pre> <br><p>  Dies ist ein Beispiel für eine Migration, bei der sich die Genauigkeit in einer vorhandenen Spalte ändert: </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m190916_045702_change_news_time_precision</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Migration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">up</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;alterColumn( <span class="hljs-string"><span class="hljs-string">'news'</span></span>, <span class="hljs-string"><span class="hljs-string">'published'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;timestamp(<span class="hljs-number"><span class="hljs-number">6</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">down</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;alterColumn( <span class="hljs-string"><span class="hljs-string">'news'</span></span>, <span class="hljs-string"><span class="hljs-string">'published'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;timestamp(<span class="hljs-number"><span class="hljs-number">3</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } }</code> </pre> <br><p>       ActiveRecord     -  :          ,         DateTime-.  ,     —    «»      <code>PDO::ATTR_EMULATE_PREPARES</code> .   Yii    ,        .   ,       ,        PDO. </p><br><p> . : </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    Yii 2</a> ; </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  SchemaBuilderTrait</a> . </li></ul><br><h2 id="zaklyuchenie">  Fazit </h2><br><p> ,   ,     —  ,     .                 ,    ,    . ,    ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469615/">https://habr.com/ru/post/de469615/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469599/index.html">Nachbesprechung Entwicklung 2D-Engine auf WinForms</a></li>
<li><a href="../de469605/index.html">Die Zukunft von Li-Fi: Polaritonen, Exzitonen, Photonen und etwas Wolframdisulfid</a></li>
<li><a href="../de469607/index.html">Menschliches Bewusstsein. Kopie kann nicht übertragen werden?</a></li>
<li><a href="../de469609/index.html">Bitte sei online</a></li>
<li><a href="../de469613/index.html">Über das nationale Datenmanagementsystem</a></li>
<li><a href="../de469617/index.html">Zerstören Sie Amerikas Monopol in der EDA. Innopolis macht den ersten Schritt</a></li>
<li><a href="../de469619/index.html">Recherche: Wenn der Käufer versteht, dass er mit dem Chat-Bot spricht, findet der Kauf überhaupt nicht statt</a></li>
<li><a href="../de469623/index.html">GitLab 12.3 mit Webanwendungs-Firewall und Leistungsanalyse</a></li>
<li><a href="../de469625/index.html">Wie wir Daten zu Werbekampagnen von Online-Plattformen gesammelt haben (der dornige Weg zum Produkt)</a></li>
<li><a href="../de469629/index.html">Friedliches Atom ist nicht in jedem Haus: unerwartete Optionen für Radionuklid-Energiequellen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>