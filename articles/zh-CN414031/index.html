<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤔 🤲 💖 聚会之后的“ PostgreSQL 11新功能” ⛏️ 👵🏻 😓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今天，我们将讨论PostgreSQL 11的最重要的功能。为什么只关注它们-因为不是每个人都需要某些功能，所以我们选择了最受欢迎的功能。 

 目录内容 



- Jit编译 
- 分区 
- 指标 
- 覆盖指数 
- SP GiST 
- 性能表现 
- 沃尔 
- 备份与复制 
- 对于db...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>聚会之后的“ PostgreSQL 11新功能”</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raiffeisenbank/blog/414031/"> 今天，我们将讨论PostgreSQL 11的最重要的功能。为什么只关注它们-因为不是每个人都需要某些功能，所以我们选择了最受欢迎的功能。 <br><br><h3> 目录内容 </h3><br><img src="https://habrastorage.org/webt/3l/ef/wk/3lefwko0funvsqwyvgcaqtf7ory.png" align="right" width="300"><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Jit编译</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分区</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">指标</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">覆盖指数</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SP GiST</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">性能表现</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">沃尔</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">备份与复制</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对于dba</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">并行执行</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">优化器</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">视窗功能</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">全文搜索更改</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">杰森（b）和全文</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PL / *程序</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pgbench</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PSQL增强</a> </li></ul><a name="habracut"></a><br><a name="1"></a><h3>  Jit编译 </h3><br>  PostgreSQL终于引入了JIT编译，即将查询编译为二进制代码。 为此，请编译支持JIT编译的PostgreSQL <code>(Compile time 1 (--with-llvm))</code> 。 同时，计算机必须具有不低于3.9的LLVM版本。 <br><br> 什么可以加快JIT？ <br><br><ul><li> 使用WHERE子句查询，即此关键字之后的所有内容。 这并非总是必要的，但是机会是有用的。 </li><li> 目标列表的计算：在PostgreSQL术语中，这就是select和from之间的所有内容。 </li><li> 聚集体。 </li><li> 将记录从一个视图转换到另一个视图（投影）。 例如，将联接应用于两个表时，结果是一个新的元组，其中包含两个表中的字段。 </li><li> 元组变形。 任何数据库（至少是小写的）都是关系数据库的问题之一是如何从磁盘上的记录中获取字段。 毕竟，可能为空，它们具有不同的记录，通常，这不是最便宜的操作。 </li></ul><br>  <code>Compile time 2</code>表示不使用JIT。 在PostgreSQL中，有一瞬间的查询计划，由系统决定哪些值得JIT，哪些不值得。 在这一点上，它是JIT，然后执行程序按原样执行。 <br><br>  JIT可插拔。 默认情况下，它与LLVM一起使用，但是您可以连接任何其他JIT。 <br><br><img src="https://habrastorage.org/webt/hm/pk/lk/hmpklkbpxsi1qzqyvyx3drcl6_y.png" width="600"><br><br> 如果您在没有JIT支持的情况下编译了PostgreSQL，则第一个设置将无法正常工作。 为开发人员实现的选项，有一些针对单个JIT功能的设置。 <br><br> 下一个微妙之处与jit_above_cost有关。  JIT本身不是免费的。 因此，如果查询的成本超过10万条条件鹦鹉，则PostgreSQL默认使用JIT优化，在条件鹦鹉中进行解释，分析等工作。 该值是随机选择的，因此请注意它。 <br><br> 但是并非总是在启用JIT后一切都可以立即工作。 通常，每个人都开始使用select * from表（id = 600查询）来尝试JIT，但他们失败了。 可能有必要以某种方式使请求复杂化，然后每个人都将生成一个庞大的数据库来组合该请求。 结果，PostgreSQL依靠磁盘的功能；它缺乏共享缓冲区和缓存的能力。 <br><br> 这是一个完全抽象的示例。 有9个具有不同频率的空字段，因此您可以注意到元组变形的影响。 <br><br> <code>select i as x1, <br> case when i % 2 = 0 then i else null end as x2, <br> case when i % 3 = 0 then i else null end as x3, <br> case when i % 4 = 0 then i else null end as x4, <br> case when i % 5 = 0 then i else null end as x5, <br> case when i % 6 = 0 then i else null end as x6, <br> case when i % 7 = 0 then i else null end as x7, <br> case when i % 8 = 0 then i else null end as x8, <br> case when i % 9 = 0 then i else null end as x9 <br> into t <br> from generate_series(0, 10000000) i; <br> <br> vacuum t; <br> analyze t;</code> <br> <br>  PostgreSQL有很多可能性，并且要了解JIT的优势，请禁用前两行以免产生干扰，并重置阈值。 <br><br> <code>set max_parallel_workers=0; <br> set max_parallel_workers_per_gather=0; <br> set jit_above_cost=0; <br> set jit_inline_above_cost=0; <br> set jit_optimize_above_cost=0;</code> <br> <br> 这是请求本身： <br><br> <code>set jit=off; <br> explain analyze <br> select count(*) from t where <br> sqrt(pow(x9, 2) + pow(x8,2)) &lt; 10000; <br> <br> set jit=on; <br> explain analyze <br> select count(*) from t where <br> sqrt(pow(x9, 2) + pow(x8,2)) &lt; 10000;</code> <br> <br> 结果如下： <br><br> <code>Planning Time: 0.71 ms <br> Execution Time: <b>1986.323</b> ms <br> <br> VS <br> <br> Planning Time: 0.060 ms <br> JIT: <br> Functions: 4 <br> Generation Time: 0.911 ms <br> Inlining: true <br> Inlining Time: 23.876 ms <br> Optimization: true <br> Optimization Time: 41.399 ms <br> Emission Time: 21.856 ms <br> Execution Time: <b>949.112</b> ms</code> <br> <br>  JIT帮助将请求加快了一半。 计划时间是差不多的事情，但这很可能是PostgreSQL缓存某些内容的结果，因此请忽略它。 <br><br> 如果总结一下，JIT编译大约需要80毫秒。 为什么JIT不免费？ 在执行请求之前，您需要对其进行编译，这也需要时间。 而且比计划多了三个数量级。 这不是一种昂贵的享受，但是由于执行时间长，它有回报。 <br><br> 尽管并非总是如此，但您可以通过这种方式使用JIT。 <br><br><a name="2"></a><h3> 分区 </h3><br> 如果您关注PostgreSQL中的分区，您可能会注意到它是在那里展示的。 在第10版中，当出现了分区（节）的声明式声明时，情况略有改善。 另一方面，所有内容在内部保持相同，并且工作与以前的版本大致相同，这很糟糕。 <br> 在许多方面，此问题都由pg_pathman模块解决，该模块允许使用节并在运行时的最佳时间切断它们。 <br><br> 在版本11中，分区得到了极大改进： <br><br><ul><li> 首先，分区表可以具有主键，该主键必须包括分区键。 实际上，这可以是半主键，也可以是主半键。 不幸的是，您不能在其上创建外键。 我希望以后会解决此问题。 </li><li> 现在，不仅可以按范围进行分区，还可以按列表和哈希进行分区。 哈希是非常原始的，表达式的其余部分用于哈希。 </li><li> 更新时，该行在各节之间移动。 以前，您必须编写触发器，但是现在它是自动完成的。 </li></ul><br> 最大的问题是：我可以有多少节？ 坦白地说，该功能包含大量部分（成千上万），因此无法正常工作。  Pg_pathman做得更好。 <br><br> 默认情况下也设置了部分。 同样，在pg_pathman中，您可以自动创建节，这更加方便。 在这里，所有不能推到某处的东西都落在该部分中。 如果在实际系统中默认情况下会执行此操作，那么一段时间后，您会陷入困境，这很痛苦。 <br><br> 如果两个表通过一个分区键连接，并且分区方案匹配，则PostgreSQL 11现在能够优化分区。 这由一个特殊参数控制，该参数默认情况下处于关闭状态。 <br><br> 您可以分别计算每个部分的汇总，然后相加。 最后，您可以在父分区表上创建索引，然后将在与其连接的所有表上创建本地索引。 <br><br> 在“新增功能”部分中，提到了一件很棒的事情-在执行请求时可以丢弃部分的功能。 让我们检查一下它是如何工作的。 结果是这样一个表： <br><br><img src="https://habrastorage.org/webt/pd/yq/og/pdyqogkeovn-af_egj5u8wlszne.png" width="500"><br><br> 我们创建一个类型和一个由两列组成的表，这些表具有一个主键，一个bigserial列，用于插入数据。 我们创建第二个表，该表将被分区并将是第一个表的副本。 将主键添加到分区表。 <br><br><img src="https://habrastorage.org/webt/in/5h/gr/in5hgrummalku8i2gfizbjbt3hm.png" width="500"><br><br> 该表将包含两种类型的条目：“女保姆”和“男司机”。 将会有一位女司机。 我们分为两部分，按列表划分，添加主键，并插入生成所有表的表中的所有数据。 结果完全没有意思： <br><br><img src="https://habrastorage.org/webt/r5/st/ax/r5staxao_opewadzu9wavch_w6w.png"><br><br> 注意请求。 我们从非分区表中选择所有内容，然后连接到分区表。 我们只花一小部分，只选择一种，它们会通过一种。 我们指示oss列应具有一个值。 事实证明，选择了可靠的驱动程序。 <br><br> 在执行时，我们特别禁用并行化，因为默认情况下PostgreSQL 11非常主动地并行化或多或少的复杂查询。 如果我们查看执行计划（解释分析），那么可以看出系统在两个部分中都添加了数据：保姆和驱动程序中，尽管保姆不在那儿。 没有对缓冲区的调用。 尽管PostgreSQL可以解决所有问题，但是花费的时间和使用的条件。 也就是说，消除分区声明无法立即生效。 也许在以后的版本中将对此进行纠正。 在这种情况下，pg_pathman模块在这种情况下可以正常工作。 <br><br><a name="3"></a><h3> 指标 </h3><br><ul><li> 以单调方式（即B树）进行出价优化。 大家都知道，当您插入单调增长的数据时，结果并不是很快。 现在PostgreSQL能够以一种特殊的方式缓存结束页面，而不是从根到插入一直进行。 这大大加快了工作速度。 </li><li>  PostgreSQL 10使得可以使用哈希索引，因为它开始使用WAL（预写日志）。 以前，我们获取了值，解锁了页面，返回了值。 对于下一个值，您必须再次阻止页面，返回，解锁等等。 现在，哈希变得更快了。 它允许您一次阻止页面以从哈希索引检索记录，从那里返回所有值并对其进行解锁。 现在，它已针对HASH，GiST和GIN实施。 将来，这可能会在SP-GiST中实现。 但是对于具有最小/最大逻辑的BRIN，原则上无法做到。 </li><li> 如果您过去用于构建功能索引，则将有效禁用HOT更新（仅堆元组）。 在PostgreSQL中更新记录时，实际上会创建一个新副本，这需要粘贴到表中的所有索引中，以便新值指向新元组。 这种优化已经实施了很长时间：如果更新不更改索引中未包含的字段并且同一页上有可用空间，则索引不会更新，并且在元组的旧版本中会放置指向新版本的指针。 这使您可以稍微减少更新的问题。 但是，如果您具有功能索引，则这种优化根本不起作用。 在PostgreSQL 11中，它开始工作。 如果您构建了功能索引并更新了不更改功能索引依赖项的元组，则HOT更新将起作用。 </li></ul><br><a name="4"></a><h3> 覆盖指数 </h3><br> 该功能是三年前由PostgresPro实现的，而PostgreSQL一直都在尝试添加它。 覆盖索引意味着您可以直接在索引元组中向唯一索引添加额外的列。 <br><br> 怎么了 每个人都喜欢仅索引扫描，因为它们的工作迅速。 为此，构造了有条件的“覆盖”索引： <br><br><img src="https://habrastorage.org/webt/ep/s7/vf/eps7vfc5hddmnsu6occowc250kw.png" width="600"><br><br> 但是同时，您需要保持唯一性。 因此，正在建立两个指标，即窄和宽。 <br> 缺点是在应用真空，插入或更新表时，必须更新两个索引。 因此，插入索引是一项缓慢的操作。 覆盖索引将仅允许管理一个索引。 <br><br> 是的，他有一些限制。 更确切地说，可能无法立即理解其好处。 第一个创建索引中的列c和d不必是为其定义b树索引的标量类型。 也就是说，它们不一定具有更少的比较。 它可以是点或多边形。 唯一的是，该元组应小于2.7 Kb，因为索引中没有烘烤，但是您可以适应无法比较的值。 <br><br> 但是，在具有这些保证覆盖列的索引内，搜索时不会进行任何计算。 这应该通过位于索引上方的过滤器来完成。 一方面，为什么不在索引内计算它，另一方面，这是一个额外的函数调用。 但是，一切并没有看起来那么可怕。 <br><br> 好吧，此外，您可以将这些涵盖的列添加到主键中。 <br><br><a name="5"></a><h3>  SP GiST </h3><br> 很少有人使用此索引，因为它非常具体。 尽管如此，仍然有可能不完全插入其中。 这是指有损-索引，压缩。 以多边形为例。 而是在索引中放置一个边界框，即包含所需多边形的最小矩形。 在这种情况下，我们将矩形表示为四维空间中的一个点，然后在四维空间中使用经典的quad3。 <br><br> 同样为SP-GiST引入了“前缀搜索”操作。 如果一行是另一行的前缀，则返回true。 他们不仅这样介绍了它，而且为了支持SP-GiST提出了这样的要求。 <br><br> <code>SELECT * FROM table WHERE c ^@ „abc“</code> <br> <br> 在b树中，每行限制为2.7 Kb，但SP-GiST没有限制。 的确，PostgreSQL有一个限制：单个值不能超过1 GB。 <br><br><a name="6"></a><h3> 性能表现 </h3><br><ul><li>  <b>位图索引仅扫描已出现</b> 。 它与经典索引仅扫描相同，但不能保证任何顺序。 因此，它仅适用于诸如count（*）之类的某些聚合，因为位图无法将字段从索引传输到执行程序。 他只能报告满足条件的记录的事实。 </li><li> 下一个创新是<b>在应用真空过程中更新自由空间贴图</b> 。 不幸的是，没有一个使用PostgreSQL的系统开发人员认为有必要在表末尾删除，否则会出现漏洞和未分配的空间。 为了跟踪这一点，我们实现了FSM，它允许我们不扩大表格，而是将元组插入空隙。 以前，这是在真空下完成的，但是最后。 现在，真空能够在此过程中做到这一点，在负载很重的系统中，它有助于使工作台尺寸保持受控。 </li><li>  <b>在真空执行过程中可以跳过索引扫描</b> 。 实际上，根据数据库理论，所有PostgreSQL索引都称为二级索引。 这意味着索引存储在表之外；指针从表指向表。 仅索引扫描允许您不要在指针上执行此跳转，而是直接从索引中获取。 但是，删除记录的真空不能仅仅因为索引中没有这样的数据而在索引中查看它们并决定是否删除它们。 因此，真空总是分两次进行。 首先，他浏览表格并找出需要删除的内容。 然后转到该表所附的索引，删除引用找到的记录，返回到表并删除它要去的内容。 并且不一定总是需要进入索引的阶段。 <br><br> 如果自上次清理以来没有删除或更新，则您没有失效记录，则不需要删除它们。 在这种情况下，您无法转到索引。 还有其他一些细微之处，b树不会立即删除其页面，而是要分两次删除。 因此，如果您删除了表中的许多数据，则需要进行清理。 但是，如果要释放索引中的空间，请抽真空两次。 <br><br> 会有人感到惊讶，该表中没有删除或更新的内容是什么？ 其实很多处理这个，只是不考虑。 这些是仅追加表，例如在其中添加了日志。 在它们中，去除非常罕见。 从而大大节省了真空/自动真空的时间，减少了磁盘上的负载，缓存的使用等。 </li><li>  <b>同时进行竞争性交易</b> 。 这不是创新，而是进步。 现在PostgreSQL检测到它将立即提交，并延迟了当前事务的提交，等待其余的提交。 请注意，如果您使用的是带有2至4个核心的小型服务器，则此功能几乎没有作用。 </li><li>  <b>postgres_fdw（外部数据包装器）</b> 。  FDW是一种连接外部数据源的方式，使它看起来像真正的会议后。  postgres_fdw允许您将一个表从相邻实例连接到您的实例，它看起来几乎像一个真正的实例。 现在，更新和删除的限制之一已被删除。  PostgreSQL通常会猜测您需要发送原始数据。 执行联接请求的方法非常简单：我们在计算机上执行它，我们使用FDW从实例中拉出表，找出需要删除的id主键，然后应用更新和/或删除，即来回传递的数据。 现在可以做。 当然，如果表位于不同的计算机上，这并不是那么容易，但是FDW允许您让远程计算机执行操作，而我们只是在等待。 </li><li>  <b>toast_tuple_target</b> 。 在某些情况下，数据略微超出了限制，在此之后有必要进行烘烤，但是同时烘烤这些值并不总是令人愉快的。 假设您有90个字节的限制，并且需要容纳100个字节。您必须开始10个字节的toast，分别添加它们，然后在选择此字段时，您需要转到toast索引，找出所需的数据在哪里，转到toast表，收集并给予。 </li></ul><br> 现在，借助微调，您可以更改整个数据库或单独表的此行为，以使这样小的出口无需使用Toast。 但是，您必须了解自己在做什么，否则，将无法正常工作。 <br><br><a name="7"></a><h3> 沃尔 </h3><br><ul><li>  WAL（预写日志）是一个预写日志。 现在在initdb中设置WAL段的大小。 谢天谢地，不是在编译时。 </li><li> 逻辑也发生了变化。 以前，WAL段的集合是从倒数第二个检查点开始保存的，而现在是从最后一个检查点保存的。 这样可以大大减少所存储的数据量。 但是，如果您有一个1 TB的数据库，并且TPS = 1，即每秒一个请求，那么您将看不到差异。 </li></ul><br><a name="8"></a><h3> 备份与复制 </h3><br><ul><li>  <b>截断出现在逻辑复制中</b> 。 这是DML操作的最后一个，未在逻辑复制中反映出来。 现在反映出来。 </li><li>  <b>有关准备的消息出现在逻辑复制中</b> 。 现在您可以捕获准备事务，这是逻辑复制中的两阶段提交。 这是为群集的构建而实现的-异构，均质，分片且未着色的，多主群集等。 </li><li>  <b>pg_basebackup临时表和未记录表的异常</b> 。 许多人抱怨pg_basebackup包含列出的表。 排除它们之外，我们减小了备份的大小。 但前提是您使用临时表和未记录的表，否则此选项对您将无用。 </li><li>  <b>流复制中的校验和控制（用于表）</b> 。 这使您可以了解副本所发生的情况。 到目前为止，该功能仅针对表实现。 </li><li>  <b>复制插槽的位置得到了提升</b> 。 与往常一样，只有在有WAL的情况下，您才可以向前回退。 此外，您需要非常了解自己在做什么以及为什么这么做。 在我看来，这更多是一种开发选项，但是将逻辑复制用于某些奇异应用程序的用户可以享受它。 </li></ul><br><a name="9"></a><h3> 对于dba </h3><br><ul><li>  <b>更改表，添加列，默认X不为null</b> ，写入整个表。 为此需要支付少量费用：默认值单独存储。 如果选择元组并需要此列，则PostgreSQL被迫遵循其他编码路径以提取临时值，将其替换为元组并提供给您。 但是，可以忍受它。 </li><li>  <b>真空/分析</b> 。 以前，您只能对整个数据库或单个表应用真空或分析。 现在可以使用一个命令对多个表执行此操作。 </li></ul><br><a name="10"></a><h3> 并行执行 </h3><br><ul><li>  <b>b树索引的并行构造</b> 。 在版本11中，可以将b树索引嵌入到多个工作程序中。 如果您有一台非常好的机器，许多磁盘和许多内核，那么您可以并行构建索引，这将保证性能显着提高。 </li><li>  <b>使用共享的哈希表对执行程序进行哈希并行连接</b> 。    ,           -.   ,     .   - ,     .     . </li><li>  , <b>      union, create table as, select  create materialized view!</b> </li><li> - <b>   (limit)   </b> .    . </li></ul><br>    : <br><br> <code>alter table usr reset (parallel_workers) <br> create index on usr(lower((so).occ)) — 2  <br> alter table usr set (parallel_workers=2) <br> create index on usr(upper((so).occ)) — 1.8 </code> <br> <br>     parallel worker.        .     16    4  (    )      2 .,    — 1,8 .     ,   ,     .  ,         . <br><br>     : <br><br> <code>explain analyze <br> select u1.* from usr u, usr1 u1 where <br> u.id=u1.id+0</code> <br> <br>     ,      . , user —   ,    .     .    ,      ,   . <br><br>     ,   PostgreSQL 11           . <br><br><img src="https://habrastorage.org/webt/a4/si/tw/a4sitw7cyqsulcovvmv--yueczs.png"><br><br>    1425 ,  1,5 .    1,4 .  2  .  ,   9.6   : 1      —  1 .,   2   1 .    ,    10    tuple.    11    .       :      user,   batch,    x-scan      append   . <br><br>    : <br><br><img src="https://habrastorage.org/webt/7f/rx/2h/7frx2hwdbaxaq4asujz7aembelq.png"><br><br>   .         211 ,   702 .   ,    510     1473.    ,      2  . <br><br>     parallel hash join.       .     — 4.     ,     . <br><br>   parallel index scan    .     batch  .   ?        hash join,         .  user    .        ,  parallel hash,   . <br><br>     1 .  ,       OLAP-,  OLTP  .    OLTP  ,      . <br><br><a name="11"></a><h3>  </h3><br>      . <br><br><ul><li>       .   ,            .      ,    «»   «»,     index scan,     .    (highly skewed data),         ,    .      .    ,    ,    . </li><li>       «»,   . </li></ul><br><a name="12"></a><h3> Window- </h3><br>     SQL:2011,      . <br><br><a name="13"></a><h3>     </h3><br>   ,      ,    . ,   ,    ,  ,    ,    . <br><br>   websearch,     .      ,     .        ,   . <br><br> <code># select websearch_to_tsquery('dog or cat'); <br> ---------------------- <br> 'dor' | 'cat' <br> # select websearch_to_tsquery('dog -cat'); <br> ---------------------- <br> 'dor' &amp; !'cat' <br> # select websearch_to_tsquery('or cat'); <br> ---------------------- <br> 'cat'</code> <br> <br>   — dog or cat —   . Websearch      .     |  ,       .    “or cat”.   ,   .    websearch  “or”  .  ,    -,    . <br><br> Websearch —     .       :        ,   .     ,   . <br><br><a name="14"></a><h3> Json(b)   </h3><br>  10-     ,   11-     .    json  json(b),   tsvector.   ( json(b))  -  .      ,    ,   ,  bull, numeric, string, .     . <br><br> <code># select jsonb_to_tsvector <br> ('{"a":"texts", "b":12}', '"string"'); <br> ------------------- <br> 'text':1 <br> # select jsonb_to_tsvector <br> ('{"a":"texts", "b":12}', '["string", "numeric"]'); <br> ------------------- <br> '12':3 'text':1</code> <br> <br>     json(b),        .      ,   ,   ,   . <br><br><a name="15"></a><h3> PL/*  </h3><br>     . <br><br> <code>CREATE PROCEDURE transaction_test1() <br> LANGUAGE plpgsql <br> AS $$ <br> BEGIN <br> FOR i IN 0..9 LOOP <br> INSERT INTO test1 (a) VALUES (i); <br> IF i % 2 = 0 THEN <br> COMMIT; <br> ELSE <br> ROLLBACK; <br> END IF; <br> END LOOP; <br> END <br> $$; <br> CALL transaction_test1();</code> <br> <br>      call,       ,         .        .     .      select, insert   . <br><br>    ,    ,   PostgreSQL    .    Perl, Python, TL  PL/pgSQL.    Perl    sp begin,         . <br><br> PL/pgSQL    :    ,    . <br><br><a name="16"></a><h3> pgbench </h3><br>     pgbench  ICSB bench — ,   ,       .    if,     ,     .  case,       - .   <code>--init-steps</code> ,    ,   . <br><br>         random-seed.   zipfian- .    / —   ,      .   -    ,      ,  - ,  . <br><br> ,  ,    - . <br><br><a name="17"></a><h3>  PSQL </h3><br>  ,    PSQL,        .    exit  quit. <br><br><ul><li>   —    copy,      2 <sup>32</sup> .  copy      :      2 <sup>32</sup> - . ,     2 <sup>31</sup>  2 <sup>32</sup> copy     .    64-  ,      2 <sup>64</sup> . </li><li>  POSIX  :   NaN <sup>0</sup> = 1  1 <sup>NaN</sup> = 1. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN414031/">https://habr.com/ru/post/zh-CN414031/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN414019/index.html">UITableViewRowAction和UIContextualAction的通用解决方案</a></li>
<li><a href="../zh-CN414023/index.html">问伊森：生命在宇宙中出现的速度有多快？</a></li>
<li><a href="../zh-CN414025/index.html">雇主跟踪计算机，上厕所，现在也跟踪情绪。 你的老板会跟着你吗？</a></li>
<li><a href="../zh-CN414027/index.html">我的朋友可以被视为真正的朋友吗？</a></li>
<li><a href="../zh-CN414029/index.html">新形成的恒星周围的神秘光以及天文学家对此的看法</a></li>
<li><a href="../zh-CN414037/index.html">曾经在HFT公司...</a></li>
<li><a href="../zh-CN414039/index.html">童话故事</a></li>
<li><a href="../zh-CN414041/index.html">在冬季和夏季使用一种颜色？ 搜索数据的季节性</a></li>
<li><a href="../zh-CN414043/index.html">路由表分析，或者为什么还要Python网络工程师</a></li>
<li><a href="../zh-CN414045/index.html">规定：在美国，公司必须在30天内通知PD泄漏</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>