<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐔 💺 🚧 编译Kotlin：JetBrains VS ANTLR VS JavaCC 🛌🏾 👩🏽‍🎓 🍲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kotlin解析速度有多快，这有什么关系？ JavaCC还是ANTLR？ JetBrains源代码适合吗？ 

 比较，幻想和怀疑。 

 tl;博士 
 JetBrains太难拖动了，ANTLR大肆宣传，但出乎意料的慢了，JavaCC还为时过早。 

 解析具有三个不同实现的简单Kotlin文件：...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>编译Kotlin：JetBrains VS ANTLR VS JavaCC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433000/"><img src="https://habrastorage.org/webt/cv/to/y3/cvtoy3lpibs4fm_1asygxcsdgse.jpeg" width="300" align="left"><br>  Kotlin解析速度有多快，这有什么关系？  JavaCC还是ANTLR？  JetBrains源代码适合吗？ <br><br> 比较，幻想和怀疑。 <br><a name="habracut"></a><br><h1>  tl;博士 </h1><br>  <i>JetBrains太难拖动了，ANTLR大肆宣传，但出乎意料的慢了，JavaCC还为时过早。</i> <br><br> 解析具有三个不同实现的简单Kotlin文件： <br><table><tbody><tr><th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr></tbody></table><br><h4> 晴间多云... </h4><br> 我决定从某种方便的语言中使用GLSL构建翻译器。 想法是直接在想法中对着色器进行编程，并获得“免费” IDE支持-语法，调试和单元测试。 原来<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">真的很方便</a> 。 <br><br> 从那时起，使用Kotlin的想法一直存在-您可以在其中使用名称vec3，它在IDE中更加严格并且更方便。 另外，是炒作。 尽管从内部经理的角度来看，这些都不是足够的原因，但是这个想法回来了很多次，以至于我决定通过实施它来摆脱它。 <br><br>  <em>为什么不使用Java？</em>  <em>没有运算符重载，因此矢量算术的语法将与您在游戏开发人员中经常看到的完全不同</em> <br><br><h4> 捷脑 </h4><br> 来自JetBrains的家伙将他们的编译器代码上传<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">到github</a> 。 如何使用它，您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>窥视。 <br><br> 最初，我将其解析器与分析器一起使用，因为要转换为另一种语言，您需要知道变量的类型，而无需显式指定<code>val x = vec3()</code> 。 在这里，阅读器的类型很明显，但是在AST中，很难获得此信息，特别是在右边有另一个变量或函数调用时。 <br><br> 在这里，我很失望。 解析器在原始文件上的首次启动需要3秒（三秒钟）。 <br><br> <code><b>Kotlin JetBrains parser</b> <br> first call elapsed : 3254.482ms <br> min time in next 10 calls: 70.071ms <br> min time in next 100 calls: 29.973ms <br> min time in next 1000 calls: 16.655ms <br> Whole time for 1111 calls: 40.888756 seconds <br></code> <br> 这样的时间有以下明显的不便之处： <br><br><ol><li> 因为启动游戏或应用程序需要三秒钟的时间。 </li><li> 在开发过程中，我使用了热着色器重载，并在更改代码后立即看到了结果。 </li><li> 我经常重新启动该应用程序，并很高兴它启动足够快（一两秒钟）。 </li></ol><br> 再加上三秒钟来预热解析器-这是不可接受的。 当然，立即清楚的是，在随后的调用中，解析时间降至50ms甚至20ms，这（几乎）消除了表达式中的第二个不便之处。 但是其他两个没有去任何地方。 此外，每个文件50毫秒加上每50个文件2500毫秒（一个着色器为1-2个文件）。 如果是Android怎么办？  （这里我们只是在谈论时间。） <br><br>  <i>值得注意的是JIT的疯狂工作。</i>  <i>一个简单文件的解析时间从70ms减少到16ms。</i>  <i>这意味着，首先，JIT本身会消耗资源，其次，在不同的JVM上的结果可能会非常不同。</i> <br><br> 为了找出这些数字的来源，有一个选项-在没有分析器的情况下使用其解析器。 毕竟，我只需要安排类型，这可以相对轻松地完成，而JetBrains分析器的功能要复杂得多，并且可以收集更多信息。 然后，启动时间减少了一半（但仍然差不多是一个半秒），并且随后的调用时间已经变得非常有趣-从前十个时间的8ms到上千个位置的0.9ms。 <br><br>  <code><b>Kotlin JetBrains parser (without analyzer)</b></code> <code><a href="">() <br> first call elapsed : 1423.731ms <br> min time in next 10 calls: 8.275ms <br> min time in next 100 calls: 2.323ms <br> min time in next 1000 calls: 0.974ms <br> Whole time for 1111 calls: 3.6884801 seconds <br></a></code> <code><a href="">()</a> <br> first call elapsed : 1423.731ms <br> min time in next 10 calls: 8.275ms <br> min time in next 100 calls: 2.323ms <br> min time in next 1000 calls: 0.974ms <br> Whole time for 1111 calls: 3.6884801 seconds <br></code> <br>  <em>我只需要收集这样的数字。</em>  <em>加载第一个着色器时，第一个启动时间很重要。</em>  <em>这很重要，因为在这里，您无法在着色器加载到后台的同时分散用户的注意力，他只是在等待。</em>  <em>减少运行时对于查看动态本身，JIT的工作方式以及在温暖的应用程序上加载着色器的效率非常重要。</em> <em><br></em> <br> 主要看一下JetBrains解析器的主要原因是希望使用其分词器。 但是由于拒绝它成为讨论的选项，因此您可以尝试使用其他解析器。 此外，非JetBrain最有可能变得更小，对环境的要求更低，在项目中支持和包含代码会更容易。 <br><br><h4>  ANTLR </h4><br> 正如预期的那样，JavaCC上没有解析器，但是在炒作ANTLR上有（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">二</a> ）。 <br><br> 但是出乎意料的是速度。 相同的3s载入时间（首次通话）和140ms的后续通话时间。 在这里，不仅第一次发射持续了不愉快的长时间，而且这种情况也没有得到纠正。 显然，JetBrains的家伙通过让JIT以这种方式优化代码来做一些魔术。 因为ANTLR并未随时间进行优化。 <br><br>  <code><b>Kotlin ANTLR parser</b></code> <code><a href="">() <br> first call elapsed : 3705.101ms <br> min time in next 10 calls: 139.596ms <br> min time in next 100 calls: 138.279ms <br> min time in next 1000 calls: 137.20099ms <br> Whole time for 1111 calls: 161.90619 seconds <br></a></code> <code><a href="">()</a> <br> first call elapsed : 3705.101ms <br> min time in next 10 calls: 139.596ms <br> min time in next 100 calls: 138.279ms <br> min time in next 1000 calls: 137.20099ms <br> Whole time for 1111 calls: 161.90619 seconds <br></code> <br><h4>  Javacc </h4><br> 通常，我们很惊讶地拒绝ANTLR的服务。 解析时间不必那么长！  Kotlin的语法没有宇宙模棱两可的地方，我检查了几乎是空的文件。 因此，是时候揭开旧的JavaCC，收起袖子了，仍然“自己动手做”。 <br><br> 这次，虽然与替代方案相比，结果还是令人期待，但令人意外。 <br><br>  <code><b>Kotlin JavaCC parser</b></code> <code><a href="">() <br> first call elapsed : 19.024ms <br> min time in next 10 calls: 1.952ms <br> min time in next 100 calls: 0.379ms <br> min time in next 1000 calls: 0.114ms <br> Whole time for 1111 calls: 0.38707677 seconds <br></a></code> <code><a href="">()</a> <br> first call elapsed : 19.024ms <br> min time in next 10 calls: 1.952ms <br> min time in next 100 calls: 0.379ms <br> min time in next 1000 calls: 0.114ms <br> Whole time for 1111 calls: 0.38707677 seconds <br></code> <br>  <i>JavaCC解析器的突然优点</i> <br> 当然，我想使用现成的解决方案，而不是编写自己的解析器。 但是现有的方法有很多缺点： <br><br>  -性能（读取新着色器时的暂停是不可接受的，并且在开始时需要三秒钟的预热） <br>  -巨大的Kotlin运行时，我什至不确定是否可以将解析器打包到最终产品中 <br>  -顺便说一下，在使用Groovy的当前解决方案中，同样的麻烦-运行时延 <br><br> 虽然生成的JavaCC解析器是 <br><br>  +在开始和过程中均具有出色的速度 <br>  +解析器本身仅几类 <br><br><h4> 结论 </h4><br>  JetBrains太难拖动了，ANTLR大肆宣传，但出乎意料的慢了，JavaCC还为时过早。 <br><br> 解析具有三个不同实现的简单Kotlin文件： <br><br><table><tbody><tr><th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr></tbody></table><br> 在某个时候，我决定考虑所有依赖项的jar大小。  JetBrains非常出色， <strike>但是ANTLR运行时的大小令人惊讶</strike> 。 <br>  <i>更新：最初，我写了15MB，但是正如注释中所建议的那样，如果连接antlr4-runtime而不是antlr4，则大小会下降到预期值。</i>  <i>尽管JavaCC解析器本身比ANTLR小10倍（如果您完全删除所有代码，则解析器本身除外）。</i> <br> 这样的罐子的大小对于手机当然很重要。 但这对台式机也很重要，因为实际上，这意味着可能包含bug的其他代码量，IDE应该对其进行索引，而这些代码确实会影响首次加载的速度和预热的速度。 另外，对于复杂的代码，几乎没有希望翻译成另一种语言。 <br> 我不敦促您数以千计，我感谢程序员的时间和便利，但是仍然值得考虑节省费用，因为这会使项目变得笨拙且难以维护。 <br><br>  <i>关于ANTLR和JavaCC的几句话</i> <br><br>  ANTLR的一个重要特征是语法和代码的分离。 如果不必付那么高的钱，那会很好。 是的，这仅对“语法的串行开发者”重要，对于最终产品而言，它并不那么重要，因为即使是现有的语法，编写代码也必须完成。 另外，如果我们省钱并采用“第三方”语法-可能只是不方便，但仍需要对其进行彻底的理解并将其自身转变为一棵树。 通常，JavaCC当然会混合苍蝇和炸肉排，但这真的很重要吗，那么糟糕吗？ <br><br>  ANTLR的另一个功能是许多目标平台。 但是在这里您可以从另一侧看-JavaCC下的代码非常简单。 它非常简单...广播！ 使用您的自定义代码-至少在C＃中，至少在JS中。 <br><br><h4> 聚苯乙烯 </h4><br> 所有代码都在这里<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github.com/kravchik/yast</a> <br><br> 解析的结果是在YastNode上构建的树（实际上，这是一个非常简单的类-具有便利方法和标识符的映射）。 但是YastNode并不是真正的“真空中的球形节点”。 我积极使用的是该类，在此基础上，我收集了一些工具-打字机，几个翻译器和一个优化器/内联器。 <br><br>  JavaCC解析器尚未包含所有语法，只剩下10％的语法，但是似乎它们不会影响性能-我检查了添加规则的速度，并且它没有明显变化。 另外，我已经做的事情远远超出我的需要，只是尝试分享该过程中发现的意外结果。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN433000/">https://habr.com/ru/post/zh-CN433000/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN432990/index.html">爱迪生声控木灯。 发行价$ 5</a></li>
<li><a href="../zh-CN432992/index.html">他戴上耳机死了：我们处理了林堡一个男生的奇怪死亡</a></li>
<li><a href="../zh-CN432994/index.html">Vivaldi 2.2-数量转换为质量</a></li>
<li><a href="../zh-CN432996/index.html">CPython（和PyPy）的一些字典内部知识</a></li>
<li><a href="../zh-CN432998/index.html">圣诞故事</a></li>
<li><a href="../zh-CN433002/index.html">快点吧...或者团队中的交流规则</a></li>
<li><a href="../zh-CN433004/index.html">2019年强大的云迁移策略：7个技巧</a></li>
<li><a href="../zh-CN433008/index.html">USB设备是“突然的”威胁</a></li>
<li><a href="../zh-CN433010/index.html">有一个想法：npm软件包的权限系统</a></li>
<li><a href="../zh-CN433012/index.html">也许我只是因为她而活着：为什么呼吸暂停患者要依靠黑客编写的程序</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>