<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆒 🖱️ 〰️ Jam tangan akurat dan cantik dari smartphone lama 🌓 👰🏽 🐀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini akan fokus pada cara membuat kembali ponsel lama yang tidak perlu dalam jam dinding yang sangat baik dengan jumlah besar, waktu yang selal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jam tangan akurat dan cantik dari smartphone lama</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443052/"><img src="https://habrastorage.org/webt/v3/zb/xe/v3zbxe4oreekk9jb1bdtkraqdcu.jpeg"><br><br>  Artikel ini akan fokus pada cara membuat kembali ponsel lama yang tidak perlu dalam jam dinding yang sangat baik dengan jumlah besar, waktu yang selalu akurat dan daya cadangan. <br><br>  Saya akan berbicara tentang beberapa fitur sinkronisasi waktu yang dijelaskan dalam OS Android, serta tentang berbagai trik kelistrikan di sistem daya ponsel cerdas.  Saya akan menjelaskan contoh rangkaian komponen analog sederhana yang menyediakan daya cadangan otomatis.  Dan tentu saja kita akan berbicara tentang bagian perangkat lunak Android - bagaimana dan dengan bantuan apa Anda dapat membuat jam tangan yang indah untuk setiap selera dari smartphone Anda. <br><a name="habracut"></a><br>  ( <i>penafian tradisional - merek, merek dagang, dll. apa pun bukan iklan, saya harap ini jelas.</i> ) <br><br><h4>  Kehidupan kedua dari sebuah smartphone lama </h4><br>  Philips Xenium W732 lama saya tidak digunakan untuk waktu yang lama.  Sepenuhnya berfungsi, dengan layar penuh.  Saya memutuskan untuk memberinya kehidupan kedua - berubah menjadi jam dinding.  Jam rumah saya yang lama, masih Soviet, dengan angka-angka kecil yang berkedip-kedip sangat sulit dilihat dari jarak beberapa meter.  Selain itu, mereka sangat tertinggal, mereka harus dikecewakan setiap saat, dengan kehilangan listrik di rumah, mereka sepenuhnya ditiadakan dan memerlukan prosedur yang membosankan untuk menekan tombol dan mengatur waktu lagi.  Semua ini sudah lama saya bosan, dan saya memutuskan untuk membuat arloji “pintar” yang bagus, tanpa semua kekurangan ini, dari ponsel lama. <br><br><h4>  Apa yang saya butuhkan </h4><br><ol><li>  Angka besar yang jelas dari warna, font, dan kecerahan yang diinginkan. </li><li>  Akurasi dan stabilitas maksimum tanpa ada intervensi dari luar dari saya. </li><li>  Non-volatilitas, mis.  Jam tangan harus terus beroperasi selama pemadaman listrik sementara. </li><li>  Pekerjaan yang sepenuhnya otonom, dalam arti - tanpa menggunakan jaringan data berbayar, kartu SIM, operator, dll. </li><li>  Kepatuhan maksimum dengan prinsip "dibuat, dihidupkan dan dilupakan".  Artinya, perangkat seharusnya tidak memerlukan perawatan atau interaksi apa pun lainnya. </li></ol><br><h4>  Kami menyediakan Android dengan waktu yang akurat. </h4><br>  Hal pertama yang harus dilakukan adalah mendapatkan waktu dunia yang akurat secara konstan pada ponsel cerdas Anda.  Konsep "tepat" bagi saya cocok menjadi 1 ... 2 detik penyimpangan dari dunia. <br><br>  Jelas bahwa pengatur waktu sistem ponsel itu sendiri tidak akan memberikan stabilitas seperti itu, itu tidak diperlukan darinya.  Oleh karena itu, kepatuhan yang dijamin dengan waktu dunia hanya dapat diperoleh dengan sinkronisasi eksternal biasa. <br><br>  Dalam kasus paling sederhana di android, ini dapat dikonfigurasi menggunakan metode "jaringan".  Selain itu, bahkan jaringan seluler dengan kartu SIM yang tak terhindarkan dan pembayaran tarif tidak akan diperlukan.  Cukup untuk mendistribusikan Wi-Fi rumah ke telepon pintar, dan mengkonfigurasi router untuk menyinkronkan waktu dari penyedia Internet atau server ntp. <br><br>  Namun, ada metode sinkronisasi kedua - untuk satelit GPS, yang menurut saya pribadi lebih baik. <br><br>  Dari pro - Anda dapat melakukan sinkronisasi di mana saja di dunia di mana langit terlihat.  Keakuratan mutlak waktu, karena GPS itu sendiri didasarkan pada ini.  Kurangnya saluran radio tambahan dan emisi. <br><br>  Dari kekurangan GPS - perangkat harus melihat setidaknya langit terbuka sedikit.  Kemungkinan besar, tidak ada yang akan terperangkap di tempat sewenang-wenang di bagian belakang ruangan, terutama jika perangkat memiliki chip yang lama dan tidak sensitif.  Dan karena arloji saya terletak persis jauh dari jendela, saya membutuhkan antena GPS jarak jauh ... <br><br><h4>  Antena eksternal paling sederhana untuk penerimaan GPS </h4><br>  Di Internet, semuanya ternyata agak ketat pada topik ini.  Saya segera menyadari bahwa saya sendiri tidak dapat membuat antena seperti itu - desain yang rumit dan besar dengan beberapa perhitungan rumit yang rumit ditawarkan di mana-mana.  Saya mencoba mencari pembelian - saya juga tidak suka semuanya.  Beberapa di antaranya besar, canggung, membutuhkan daya eksternal, dengan banyak fungsi yang tidak perlu dan pada saat yang sama tidak cukup mahal. <br><br>  Solusinya ditemukan secara kebetulan - entah bagaimana saya melihat deskripsi antena jenis "setengah gelombang dipol".  Dalam desainnya yang paling sederhana, itu hanya sepotong kawat lurus dengan panjang sama dengan setengah panjang gelombang dari sinyal yang diinginkan.  "Kompleksitas" konstruksi ini cukup cocok untuk saya, jadi saya hanya mengambil koaksial pertama dengan impedansi gelombang arbitrer dan dengan lembut menyoldernya ke telepon pintar ke kontak yang sesuai dari antena patch GPS. <br><br><div class="spoiler">  <b class="spoiler_title">Foto kontak antena GPS pada papan W732</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/nn/em/ci/nnemci1spx4laynkv4kd_fe_syy.jpeg"><br>  <i>Jalinan dan inti pusat koaksial disolder ke kontak ini</i> <br></div></div><br>  Saya baru saja membebaskan ujung kabel yang lain dari jalinan layar sehingga inti sentral dengan panjang 95 mm tetap ada - ini setengah panjang gelombang pada frekuensi L1 dari sinyal GPS standar (1575,42 MHz). <br><br><div class="spoiler">  <b class="spoiler_title">Antena GPS paling sederhana.</b>  <b class="spoiler_title">Dipol setengah gelombang</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/as/a2/yk/asa2yk0mwvmd034n7maxcwsexkq.jpeg"><br>  <i>Antena ini harus ditempatkan sedekat mungkin ke jendela.</i> <i><br></i>  <i>Saya menempelkannya ke gelas dengan selotip.</i> <i><br></i> </div></div><br>  Telepon mengambilnya dari jendela, dan di sisi lain, ujung kawat bergaris 95 mm membawanya ke jendela sehingga bisa melihat lebih banyak langit. <br><br>  Maka - Philips segera menangkap 5 ... 7 satelitnya yang jujur ​​dan diperbaiki!  Antena berfungsi! <br><br>  Dan saya masih khawatir tentang koordinasi impedansi gelombang kabel, antena dan penerima, yang seharusnya diperlukan dalam kasus-kasus seperti itu, yang dengannya saya ditaburi oleh otak di Internet di forum antena.  Kemudian, saya menemukan bahwa koordinasi resistensi diperlukan untuk sekadar mendapatkan efisiensi maksimum dari saluran transmisi (kurangnya pantulan ujung dan pelemahan berlebihan).  Dan jika salurannya hanya 2 ... 3 meter, seperti milik saya, dan tugasnya adalah hanya mengirimkan setidaknya beberapa bagian dari sinyal ke penerima, maka Anda tidak boleh memikirkan koordinasi ini sama sekali - semuanya akan bekerja dengan koaksial apa pun. <br><br><h4>  Fitur dari proses sinkronisasi GPS </h4><br>  Setelah menerima GPS yang berfungsi, tentu saja saya segera mengatur metode sinkronisasi waktu "pada satelit GPS" di pengaturan android dan meninggalkan ponsel dalam keadaan itu untuk verifikasi.  Apa yang mengejutkan saya ketika beberapa jam kemudian waktu di telepon secara signifikan "berpisah" dengan jam kontrol di komputer (di mana windows disinkronkan ntp).  Saya mulai mencari tahu alasannya ... Ternyata android, yang dikonfigurasi untuk menyinkronkan waktu melalui GPS, sebenarnya melakukan sinkronisasi ini hanya <i>sekali - pada saat memperbaiki koordinat</i> . <br>  Dan kemudian, meskipun smartphone terus memonitor satelit, waktu sistemnya masih ditentukan hanya oleh generator internal, yaitu, tidak ada sinkronisasi sama sekali!  Setidaknya di Philips Android 4.0.3 saya, semuanya terjadi seperti itu. <br><br>  Bagi saya itu adalah kejutan yang tidak menyenangkan.  Saya tidak akan terus menarik GPS secara manual untuk memperbarui waktu yang tepat ... <br><br>  Solusinya ditemukan perangkat lunak.  Saya menggunakan program Locus perangkat lunak Asamm untuk navigasi, di mana dimungkinkan untuk mengkonfigurasi pemeliharaan GPS yang tidak konstan dalam keadaan aktif, tetapi perbaikan koordinat satu kali secara berkala pada interval yang diberikan, itulah yang saya butuhkan.  Saya mengatur interval ke 15 menit, dan masalahnya hilang dengan aman - waktu di ponsel sejak saat itu selalu jelas bertepatan dengan dunia!  Selama 15 menit, timer sistem dari semua smartphone normal tidak akan mengakumulasi kesalahan waktu lebih dari 1 ... 2 detik, yang sangat cocok untuk saya.  Jika mau, Anda dapat memperbaiki dalam cuaca panas setidaknya setiap sepuluh detik. <br><br><h4>  Katering untuk smartphone yang tidak bergerak </h4><br>  Setelah waktu yang tepat diberikan, giliran untuk membuat diet yang kompeten untuk arloji saya. <br><br>  Seperti yang telah saya sebutkan, saya membutuhkan jam untuk tidak mematikan dan tidak pergi ke nol selama pemadaman listrik jangka pendek di rumah, yang, meskipun jarang, bisa terjadi. <br><br>  Solusi pertama, yang paling ceroboh di sini adalah dengan mencolokkan smartphone ke stopkontak dan membiarkannya seperti itu.  Memang, pada saat yang sama, masalah pemadaman listrik diselesaikan dengan sempurna - ponsel hanya akan beralih ke baterai, yang akan selalu terisi penuh dan siap untuk digunakan.  Tidak lebih cepat dikatakan daripada dilakukan.  Terhubung ... Seminggu berlalu, yang kedua - aku sudah mulai bersukacita ... Dan pada hari ketiga, ada hari yang baik, dan baterai dengan gembira terbang keluar dari telepon ke tengah ruangan, dipompa oleh tekanan internal ke keadaan bola. <br><br><div class="spoiler">  <b class="spoiler_title">Baterai standar Phillips</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/p7/e6/oj/p7e6ojfzrl_xu9egovxblz_l6mi.jpeg"><br>  <i>Ini adalah kondisinya yang normal.</i>  <i>Datar dan keras ...</i> <i><br></i> </div></div><br>  Seperti yang Anda tahu, saya bahkan beruntung bahwa pelipis dari baterai tidak dapat bertahan dan tidak akan dibuka, jika tidak saya akan dapat menghindari api lithium, asap, bau busuk dan linoleum manja. <br><br>  Hanya ada satu kesimpulan - Anda tidak bisa hanya <i>menggunakan smartphone selama berbulan-bulan dan bertahun-tahun dengan biaya konstan</i> .  Telepon tidak mengasah skenario seperti itu.  Tugas utamanya adalah mengisi baterai dengan benar secara maksimal, tidak membiarkan tegangan dan suhu melebihi.  Dan kemudian debit masih seharusnya.  Jika perangkat tidak pernah terputus dari stopkontak, controller biasanya mulai mempertahankan jadwal pengisian gigi gergaji - pertama-tama menyetel hingga 100%, kemudian mematikan arus dan menunggu debit ke suatu tempat di sekitar 90 persen. Dan pengisian bahan bakar hingga 100% lagi.  Dan ini adalah pendekatan yang lebih atau kurang peduli.  Dan banyak telepon lama bisa dengan bodohnya selalu menjaga voltase maksimum pada baterai. <br><br>  Diketahui bahwa semakin tinggi tegangan pada sel lithium-ion, semakin cepat penuaan dan degradasinya.  Beberapa smartphone umumnya mengisi baterai mereka bahkan di atas 4.2V untuk memaksimalkan masa pakai baterai.  Tetapi hanya ada satu hasil - terus-menerus berada pada tegangan maksimum, baterai menurun jauh lebih cepat.  Jika juga sudah tua, maka itu tidak jauh dari pengembangan bertahap dari sirkuit internal mikroskopis, percepatan termal dan ledakan, seperti yang terjadi pada saya. <br><br>  Setelah kejadian dengan baterai meledak, saya berpikir - bagaimana saya bisa memiliki daya cadangan pada saat yang sama dan mencegah baterai dari terus-menerus di bawah tegangan penuh? <br><br>  Saya telah melalui banyak skenario yang berbeda, akhirnya memutuskan yang berikut. <br><br>  Dalam mode normal, ponsel akan selalu ditenagai oleh outlet, yaitu, 5V melalui konektor USB. <br><br>  Dengan menggunakan rangkaian tambahan sederhana, baterai cadangan secara otomatis dan bersamaan terisi daya maksimum 4.2V, setelah itu <i>benar</i> - <i>benar terputus dari muatan</i> .  Lebih lanjut, baterai hanya diam-diam habis dengan self-discharge, tidak terhubung di mana pun.  Dalam hal ini, sirkuit secara konstan memonitor tegangannya dan sekali lagi menyalakan muatan tunggal hingga 4,2 hanya ketika tegangan sel turun di bawah minimum yang telah ditentukan sebelumnya (saya mengambil 3,6V).  Dan seterusnya, semuanya sepenuhnya otomatis.  Waktu nyata antara pengisian ulang ini adalah bertahun-tahun, di mana baterai secara perlahan melakukan pengisian sendiri, namun tetap cukup mampu memasok beban setiap saat, bahkan jika tidak dari kapasitas penuhnya. <br><br>  Dalam hal terjadi kegagalan daya dari stopkontak, baterai harus segera terhubung secara otomatis ke smartphone (seperti pada catu daya yang tidak terputus), setelah itu sistem akan terus bekerja darinya secara mandiri sampai daya listrik dipulihkan, atau sampai baterai benar-benar habis (dan dimatikan). <br><br>  Dengan pendekatan ini, sel lithium dioperasikan dalam mode yang lebih hemat daripada ketika tegangan maksimum terus dipertahankan di sana.  Dan itu pasti tidak akan meledak! <br><br><h4>  Trik Listrik Smartphone </h4><br>  Sekarang tentang bagaimana menerapkan semua sirkuit ini. <br><br>  Masalahnya di sini diperumit oleh fakta bahwa di dalam smartphone itu tidak begitu mudah untuk diatur dalam sistem tenaga. <br><br>  Misalnya, tanpa baterai, telepon tidak akan hidup walaupun ada 5V melalui USB. <br><br>  Jika Anda melepas baterai saat menggunakan USB, semuanya juga langsung kosong.  Meskipun daya pada saat yang sama jelas hanya berasal dari konektor USB! <br><br>  Pada awalnya, ada masalah dengan kontak baterai ketiga.  Saya tidak ingin terikat dengan baterai Philips biasa dan memutuskan untuk mencari tahu - apa yang akan terjadi jika saya membiarkan terminal kontak ketiga tidak terhubung sama sekali?  Ternyata smartphone itu tidak mau menyala pada saat yang sama ... Saya bahkan mulai takut bahwa beberapa jenis bus digital canggih, seperti i2c, akan melewati kontak tengah, yang akan mentransmisikan ke telepon tidak hanya berbagai telemetri teknis, tetapi juga semua jenis kode pabrik dalam gaya "teman atau musuh".  Ini berarti saya selamanya terikat dengan baterai asli Philips saya, karena saya jelas tidak bermaksud memasang antarmuka digital yang menipu di sini (saya ingat bahwa saya memiliki kejutan yang sama ketika bekerja dengan baterai camcorder dari perusahaan Jepang yang terkenal dan dihormati di dunia). <br><br>  Saya melihat osiloskop tentang apa yang terjadi pada kontak ketiga.  Untungnya bagi saya, Philips W732 ternyata sangat sederhana!  Ini menampilkan tegangan konstan yang biasa dari sensor suhu baterai internal.  Input dari kontak ketiga di smartphone adalah impedansi tinggi. <br><br>  Saya memasang pembagi tala sederhana, dan menerapkan tegangan yang berbeda untuk kontak tengah, saya mengambil beberapa titik dari ketergantungan suhu baterai yang ditampilkan oleh android pada tegangan pada kontak ketiga. <br><br><div class="spoiler">  <b class="spoiler_title">Grafik suhu baterai yang ditampilkan pada tegangan kontak ke-3</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/dc/-g/gd/dc-ggdncroj-gfw1mrxyiltj530.png"><br></div></div><br>  Ternyata jika yang ketiga kurang dari 153mV, peringatan layar penuh tentang overheating baterai akan mulai dan setelah beberapa detik telepon akan mati secara normal.  Pada tegangan di atas 630mV, android mulai percaya bahwa baterainya beku ke suhu minus, tetapi akan terus bekerja (dan bahkan diam-diam!).  Saya tidak perlu bereksperimen lagi - saya baru menyadari bahwa penting untuk menipu kontak ketiga - cukup terapkan potensi apa pun antara 155 dan 600 mV di sana. <br><br>  Akibatnya, saya mengambil kriteria bentuk 2, yang tanpanya ponsel cerdas tidak akan berfungsi sama sekali: <br><br>  <b>1.</b> Tegangan wajib pada terminal positif baterai (terlepas dari kenyataan bahwa sistem ini didukung oleh konektor USB) <br><br>  Dan ini seharusnya tidak menjadi semacam penipuan potensial palsu, hanya agar ponsel berpikir bahwa baterai dimasukkan ke dalamnya.  Ini membutuhkan <i>sumber</i> tegangan <i>rendah-impedansi penuh</i> dengan arus setidaknya saat operasi smartphone. <br><br>  <b>2.</b> Adanya tegangan konstan pada kontak ketiga paket baterai di kisaran 155 ... 600mV.  Sudah ada cukup potensi blende-potensi tinggi. <br><br><hr><br>  Ngomong-ngomong, saya masih tidak mengerti mengapa android memiliki ambang batas mati yang tinggi (3.4V), sedangkan sel lithium standar dapat dengan mudah mengeluarkan hingga 3 dan bahkan 2.8V!  Satu-satunya hal yang terlintas dalam pikiran adalah kehadiran di smartphone konsumen internal di 3.3V, yang membutuhkan pasokan daya untuk konverter uang mereka.  Tetapi Anda dapat menempatkan SEPIC dan menggunakan baterai lebih penuh!  Atau di zaman modern tidak ada yang memikirkan hal ini? <br><hr><br>  Selanjutnya, perlu untuk membuat skema tambahan sederhana yang akan memonitor semua ini dan secara otomatis mengendalikannya.  Saya segera memutuskan bahwa saya tidak akan menggunakan mikrokontroler, meskipun saya dapat bekerja dengan mereka.  Dalam hal ini, Anda hanya perlu berpikir sedikit, mengoptimalkan semuanya secara menyeluruh, dan semua fungsi diimplementasikan pada komponen analog sederhana.  Semuanya berfungsi dan tidak pernah membeku. <br><br>  Baterai jam cadangan perlu diisi secara berkala dari sesuatu.  Pada awalnya, saya memutuskan untuk melakukannya langsung dari baterai plus smartphone, karena saya secara naif percaya bahwa itu 4.2V jujur ​​dan tidak berubah.  Dengan bantuan osiloskop, saya melihat apa yang sebenarnya terjadi di sana.  Ternyata itu tidak berbau tingkat konstan! .. <br><br>  Pertama, jika tidak ada yang terhubung ke terminal positif baterai, pengontrol pengisian daya masih tidak tidur dan secara berkala “memeriksa” dengan pemeriksaan. <br><br><div class="spoiler">  <b class="spoiler_title">Gelombang tegangan pada terminal positif baterai</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/bi/hc/kq/bihckq8fd_wy5kabjuultdy7oai.png"><br>  ( <i>rekonstruksi bentuk gelombang nyata</i> ) <br></div></div><br>  Anda lihat - setelah setiap 45 milidetik telepon memberikan tangga dari "penyelidikan" berturut-turut - apakah tegangan eksternal muncul pada kontak baterai?  Dan di antara pemeriksaan ini, level konstan tertentu 4.05V dipertahankan. <br><br>  Jika Anda menghubungkan baterai, sistem mengenalinya dan secara teratur mulai mengisi arus di sana.  Tapi, sekali lagi, tidak terus-menerus, tetapi dalam periode 10 detik.  Setelah masing-masing pengisian 10 detik ini, smartphone selama 2 detik mencakup <i>arus balik</i> penuh, mis.  dibutuhkan arus dari baterai, dan dengan daya yang layak (saya tidak mengukur nilai numerik yang tepat dari semua parameter ini, saya tertarik pada prinsip).  Selama pengambilan sampel arus jangka pendek ini, smartphone mengukur pengisian daya baterai di bawah beban, sehingga memperoleh angka persentase dan tegangan yang jujur.  Itu terlihat jelas bagaimana tepatnya setelah ini terbalik di android nilai dari semua parameter baterai diperbarui. <br><br>  Semua mekanisme pengisian daya yang rumit ini tidak cocok untuk saya sama sekali, dan bahkan mengganggu, karena saya bermaksud membangun logika sirkuit pengisian daya berdasarkan kontrol tegangan analog kontinu pada shunt pengukur.  Dan secara otomatis mematikan muatan ketika penurunan pada pirau akan berkurang ke minimum yang telah ditentukan, menunjukkan bahwa arus pengisian mencapai tahap akhir pengisian.  Dan kemudian pembalikan ini benar-benar merusak segalanya ... Awalnya saya mencoba untuk mengelak atau menipu, tetapi sebagai hasilnya saya menyadari bahwa lebih mudah untuk menggunakan sumber eksternal dari tegangan pengisian referensi.  Ini akan menjadi lebih dapat diandalkan dan lebih transparan untuk pemahaman lebih lanjut. <br><br>  Saya memasang stabilizer integral eksternal (normal, linier), yang dengannya saya menerima 4.2V akurat dan <i>suhu stabil</i> dari charger USB 5 ... 6V yang tidak stabil.  Dengan mereka, pertama-tama, saya memberi terminal smartphone baterai positif, sehingga ia selalu berpikir bahwa ia memiliki baterai yang terisi 100% dan tidak pernah menyiarkan apa pun di layar ini secara penuh.  Dan kedua, sistem pengisian baterai cadangan bekerja dari bus ini. <br><br>  Sepanjang jalan, saya menemukan pengamatan yang aneh.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ternyata jika Anda mematikan daya melalui USB dan menerapkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tegangan konstan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari sumber yang distabilkan yang tidak akan pernah berubah ke </font><font style="vertical-align: inherit;">terminal baterai ponsel cerdas </font><font style="vertical-align: inherit;">, android akan terus-menerus menggambar grafik persentase persentase pengisian yang cenderung menurun! </font><font style="vertical-align: inherit;">Rupanya, beberapa jenis persamaan untuk menghitung persentase ini tertanam dalam program pemantauan baterai android, yang memperhitungkan tidak hanya tegangan sel aktual, tetapi juga konsumsi perangkat saat ini. </font><font style="vertical-align: inherit;">Saya secara khusus melakukan eksperimen, menyalakan dan mematikan lampu layar, sebagai salah satu konsumen saat ini yang paling rakus. </font><font style="vertical-align: inherit;">Berikut adalah statistik yang dikumpulkan per hari:</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi android menggambar grafik "pengosongan baterai"</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/m-/_j/dc/m-_jdcx_h9vkganwg0-nuci6fdc.jpeg"><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/b7/y_/vv/b7y_vvrfjlfd_5teazjmiksc8bi.jpeg"></div><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda lihat, ketika layar bekerja dan arus dari terminal baterai menjadi jelas, android menarik kemiringan yang baik, sekitar 5% penurunan per jam. Lalu saya mematikan lampu latar dan smartphone tertidur, arus turun ke beberapa nilai siaga kecil, dan grafik hampir horizontal. Dia menyalakan layar lagi - dan lagi jalan. Perhatikan bahwa tegangan pada terminal positif baterai selalu benar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> benar </font><i><font style="vertical-align: inherit;">konstan</font></i><font style="vertical-align: inherit;"> . Jadi android menghitung persentase biaya hanya berdasarkan arus yang diukur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, segera setelah daya mencapai 15% (di sini telepon memberi peringatan tentang baterai kosong), grafik berhenti berkurang dan kemudian berjalan terus dan secara horizontal sebesar 15% ... Inilah triknya (atau kesalahan).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada fitur lain. Ternyata jika Anda secara bersamaan memasok daya USB dan menstabilkan daya eksternal ke terminal baterai, tetapi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kurang dari 4.2V</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , maka smartphone akan terlebih dahulu dan untuk waktu yang lama secara jujur ​​menunjukkan persentase pengisian yang tidak lengkap, dan kemudian tiba-tiba mulai memarahi, dengan gaya " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah Anda sesuatu dengan baterai! Pengisian terlalu lama!</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " Dan tentu saja, semua ini lagi di layar penuh dan di atas arloji saya! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nah, jika Anda menerapkan lebih dari 4.2V, maka di sekitar 4.3V ia akan mulai bersumpah tentang kelebihan berbahaya dari tegangan baterai, ini bisa dimengerti. Oleh karena itu, "kisaran ketenangan" di sini cukup sempit - hanya 0,1V.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan hanya jika dia diberikan daya USB 5V dan emulasi penuh 4.2V yang tepat melalui terminal baterai - hanya kemudian android dengan senang hati mati, percaya bahwa dia dengan jujur ​​mengisi baterai dengan maksimal. </font><font style="vertical-align: inherit;">Dan lebih lagi dia, terima kasih Tuhan, tidak pernah mengeluh tentang apa pun!</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya akan segera meyakinkan mereka yang mungkin berpikir bahwa saya melakukannya dengan sangat buruk dengan memuat dua sumber tegangan rendah tidak konsisten di atas satu sama lain (yaitu, penstabil 4.2V eksternal dan terminal baterai positif, yang dengan sendirinya juga "memberi makan") . </font><font style="vertical-align: inherit;">Faktanya adalah stabilizer eksternal saya adalah LDO linier biasa dan, dengan sirkuitnya, tidak dapat </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengalihkan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> arus. </font><font style="vertical-align: inherit;">Hanya gagal. </font><font style="vertical-align: inherit;">Oleh karena itu, tidak ada konflik listrik yang muncul di sini, karena ini dapat terjadi, misalnya, ketika beberapa baterai berbeda dihubungkan secara paralel.</font></font><hr><br><br><h4>  Skema </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika TK akhirnya ditentukan sepenuhnya, adalah mungkin untuk mulai mengembangkan skema tertentu. </font><font style="vertical-align: inherit;">Terlepas dari kesederhanaan tugas itu, saya mengutak-atiknya! </font><font style="vertical-align: inherit;">Saya harus menemukan dan kemudian menolak lebih dari selusin pilihan yang berbeda, dari yang tidak sederhana sampai yang besar.</font></font> Inilah hasilnya: <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rencana daya</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/5p/av/_r/5pav_ru8mahbacmdyz4xxr6covo.png"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun tampak redundansi, skema ini sederhana. </font><font style="vertical-align: inherit;">Berkat SMD, selendang berukuran 35x22 mm pas dengan mudah di dalam kompartemen baterai biasa yang dilepas. </font><font style="vertical-align: inherit;">Sebagai baterai cadangan, saya menggunakan lithium-ion 18650 biasa yang dipasang di dudukan jam tangan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sirkuit menyediakan fungsi-fungsi berikut:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Catu daya konstan 5V utama dari outlet melalui konektor USB. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Secara otomatis mentransfer smartphone ke baterai cadangan jika terjadi kegagalan daya dari USB. </font></font></li><li>   4,2     (    ). </li><li>       (   ). </li><li>            . </li><li>     ,   . </li><li>         . </li><li>        . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang, secara singkat, bagaimana sirkuit bekerja. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mendapatkan 4.2V yang stabil dan tidak tergantung suhu, saya menggunakan LDO ADM7172 terintegrasi yang luar biasa dari Perangkat Analog. Ini memberi saya tegangan yang diinginkan dan bahkan sempurna 4.22V hingga 2A beban. Saya memasukkannya ke dalam smartphone saya di atas plus konektor baterai (VBAT), dan juga menggunakannya untuk mengisi baterai cadangan sistem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sirkuit emulasi tegangan untuk kontak baterai ketiga (TEMP) dibuat pada dioda D2 sederhana, ditenagai oleh arus latar belakang yang sedikit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MOSFET P-channel Q4 menghubungkan baterai cadangan ke smartphone segera, segera setelah tegangan menghilang pada bus suplai + 5V USB utama. LED2 telah ditetapkan di sini hanya dengan tujuan menggeser level untuk sedikit mempercepat pembukaan Q4 dalam proses tenggelamnya ban. Inframerah dan tidak bersinar di mana pun.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sisa detailnya membuat rangkaian muatan. Baterai cadangan BT1 diisi melalui MOSFET Q3 dan resistor pembatas R9R10. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pekerjaan YOU U2 menarik di sini. Hal ini termasuk di sini sehingga memberikan kontrol baik tingkat pembuangan dan tingkat pengisian. Op-amp di sini beroperasi dalam mode komparator, dan OS positif untuknya diperoleh dengan sendirinya karena proses di sirkuit yang dikontrolnya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Begini caranya: ketika semuanya baik-baik saja - ada + 5V daya USB dan baterai cadangan diisi hingga tegangan lebih tinggi dari yang ditetapkan oleh titik pembagi R4R5R6 - maka op-amp mengeluarkan potensi bus 4.2-volt (dari mana ia ditenagai), dan pengisian daya Mosfet Q3 ditutup. Ketika baterai, karena satu dan lain alasan, habis di bawah titik ini (+3,63V dalam diagram), output op-amp secara bertahap akan "lepas" dari plus dan dengan demikian membuka MOSFET pengisian Q3. Arus akan mengalir ke baterai, tegangan pada sel akan segera tumbuh setidaknya beberapa milivolt (karena hambatan internal yang tidak nol) dan ini akan berfungsi sebagai POS yang andal untuk op-amp. Di sini Anda dapat menerapkan komparator nyata dengan histeresisnya sendiri, tetapi pada kenyataannya, mengganti amplifier dapat diandalkan dan cepat, tidak ada driatt berderak.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daya baterai melewati resistor R9R10 (itu adalah komposit untuk meningkatkan daya disipasi). Pertama, itu membatasi arus pengisian, yang benar-benar diperlukan di sini, jika tidak pengisi daya 2-amp tidak akan mengatasi dan melorot. Kedua, sesuai dengan penurunan tegangan pada resistor ini, rangkaian menentukan saat ketika muatan harus dimatikan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini terjadi sebagai berikut: segera setelah muatan dinyalakan, MOSFET tambahan Q2 terbuka pada saat yang sama, yang membangun kembali pembagi kontrol R4R5R6 untuk input pembalik op-amp, dan dengan demikian op-amp mulai memantau tegangan yang dilepaskan pada resistor pengisian. Di awal pengisian, ketika baterai benar-benar habis, sekitar 0,5V turun pada R9R10, yang membuat op-amp andal tidak seimbang dalam mode pengisian daya. Dan hanya ketika baterai secara bertahap terisi penuh, arus melalui resistor kontrol melemah ke nilai tertentu (sekitar 20 mA), maka potensi input op-amp disamakan, setelah itu ditransfer ke keadaan berlawanan dengan mekanisme POS eksternal yang sama (plus pada output), mematikan MOSFET Q2 dan Q3 dan menghentikan biaya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adapun skema yang dihasilkan seperti itu</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">profil pengisian</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> baterai lithium-ion, resistor R9R10 di sini secara otomatis menerapkan fungsi pengisian sederhana dengan arus awal maksimum, penurunan bertahap secara otomatis dan mendekati nol.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengisi grafik fungsi</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/yx/6o/cx/yx6ocxkusa2pis2406l_y9jqvrq.png"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Produsen baterai, pada gilirannya, merekomendasikan profil pengisian daya berikut yang terkenal dengan bagian stabilisasi arus dan tegangan: </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Profil Biaya yang Disarankan untuk Li-ion</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/rt/o0/ab/rto0abfgdgab_tlfpkkwdhx2cdu.jpeg"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam kasus saya, baik tegangan maupun arus pada sel tidak pernah secara khusus distabilkan, tetapi tegangan di atasnya tidak akan pernah melebihi batas aman. Oleh karena itu, saya menganggap metode pengisian yang disederhanakan seperti ini cukup bisa dilakukan dan efektif. Dalam praktiknya, ini bekerja dengan baik, dan pada saat yang sama hanya membutuhkan satu resistor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mosfet Q1 digunakan sehingga ketika bekerja hanya dengan baterai cadangan, tidak perlu membuang arusnya untuk memberi daya pada sisa rangkaian. Ketika daya hilang dari stopkontak, Q1 menutup dan memotong semua bagian sirkuit yang tidak digunakan dari kabel biasa. Berkat ini, konsumsi sendiri dari seluruh struktur turun menjadi 3 ... 5 mikrogram yang dapat diabaikan, dan ini secara otomatis mencegah pengosongan baterai yang dalam seandainya Anda lupa sistem de-energi untuk waktu yang lama.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schottky diode D1 pada input ke stabilizer U1 melakukan fungsi ganda - menghalangi arus balik melalui U1 (tidak ada pemblokiran seperti itu di dalam ADM7172) dan membongkar microcircuit stabilizer kecil dari disipasi daya yang berlebihan. </font><font style="vertical-align: inherit;">Pada awal pengisian baterai, arus pengisian mencapai 1A, dan jika seluruh volt 1 volt turun dari bus USB + 5V diletakkan pada ADM7172 3x3 mm yang kecil, itu akan menjadi sangat panas, meskipun pad termal telah disolder ke papan. </font><font style="vertical-align: inherit;">Oleh karena itu, bagian dari tegangan input berhasil dipadamkan pada dioda pemblokiran D1, dan sebagai hasilnya kedua bagian ini dipanaskan lebih merata dan tidak terlalu banyak.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tentang komponen bekas </font></font></h4><br>  Sebagai stabilisator input, saya menggunakan LDO yang sangat baik dengan drop pass-through minimum yang sangat rendah, meskipun di tempat ini tegangan tidak akan turun di bawah 0.4V.  Hanya saya sangat suka ADM7172 untuk banyak spesifikasinya.  Jadi di sini Anda dapat menempatkan hampir semua mikrosirkuit stabilizer linier, yang utama adalah memberikan voltase andal yang tidak mengambang pada suhu, dan setidaknya 1,5A arus. <br><br>  Dari MOSFET saya membutuhkan resistensi saluran terbuka minimal (RdsON) di sini.  Ini terutama berlaku untuk kunci P-channel bit Q4.  Di sana saya menempatkan sampel TPH1R712MD Toshibov yang luar biasa - yang terbaik yang ditemukan oleh resistansi saluran dalam kasing datar kecil.  Dalam keadaan terbuka, ia memiliki 1.3mOhm nyata, yang dengan arus kerja smartphone 200 ... 300mA memberikan hilangnya transit tegangan baterai yang berharga pada 0,4mV yang dapat diabaikan! <br><br>  Hal ini juga diinginkan untuk memiliki RdsON rendah untuk Q1 agar lebih akurat melampirkan potensi kawat bersama.  MOSFET FDMC8010 Fairchild juga baik-baik saja dengan ini.  Ada lebih banyak spesimen impedansi rendah, tetapi dalam desain ini dimensi kecil dari bagian-bagian juga penting bagi saya. <br><br>  Sisa dari MOSFET dapat berupa apa saja, hanya diinginkan bahwa mereka memiliki tegangan pembukaan yang lebih rendah. <br><br>  Sebagai pembanding U2, saya menggunakan micropower Microchip MCP6V11 IOW, yang saya suka dengan efisiensi yang sangat baik - hanya 7 microamps di latar belakang.  Benar, dibandingkan dengan YOW konvensional, kura-kura ini pasti lambat (GBW 80 kHz dan laju perubahan tegangan hanya 0,03 V / μs).  Tapi itu bekerja dengan baik di sini.  Ngomong-ngomong, saya mencoba menempatkan di sini pembanding nyata dengan histeresis bawaan.  Saya menemukan sampel MCP6541 yang sangat baik, yang hanya mengkonsumsi 600 nanoamps (!) Di latar belakang, dan ketika dipicu dapat menarik output dengan kekuatan hingga 30 mA ... Tapi, dengan meletakkannya secara langsung, bukan MCP6V11 (pinout mereka bertepatan), tiba-tiba saya mengalami kegagalan sirkuit.  Ternyata MCP6541 beralih begitu cepat sehingga bagian depan pulsa kecepatan tinggi dengan mudah menembus kapasitansi gerbang elektrik Q2 ke dalam rangkaian pembagi kontrol R4R5R6 dan mendapatkan input pembalik sendiri.  Ternyata umpan balik dinamis seperti itu, dan pembanding tidak beralih, tetapi mulai menghasilkan. <br>  Masalahnya akan diperbaiki dengan hanya menambahkan resistor resistansi tinggi antara output komparator dan gerbang Q2, tapi saya sudah memiliki papan di mana sama sekali tidak ada tempat untuk bahkan satu resistor SMD kecil tambahan, jadi saya baru saja meninggalkan MCP6V11 di sini. <br><br>  LED1 hanya diperlukan untuk menunjukkan kapan muatan masuk ke baterai.  Dalam cara yang baik, ini harus terjadi setiap beberapa tahun ... Anda dapat menggunakan warna apa saja, warna apa pun, atau Anda tidak dapat menggunakannya sama sekali. <br><br>  Resistor dan kapasitor adalah SMD yang paling umum, tidak ada persyaratan untuk mereka, kecuali untuk ukuran kecil.  Saya menggunakan kapasitor tantalum, lowESR, dalam kasus 7343H, tetapi ada yang cocok, hanya untuk masuk ke dalam kompartemen baterai dengan papan (untuk W732 Philips ukurannya 55x60x8 mm). <br><br>  Dalam proses pengisian baterai, seluruh papan memanas dengan baik selama beberapa jam pertama, hingga 60 derajat. Karena masih ada ruang yang cukup di kompartemen, saya sengaja meningkatkan area papan dan memperlebar bagian pemanas di atasnya sehingga mereka tidak akan terlalu panas satu sama lain dan tetangga lainnya dengan sia-sia. <br><br><div class="spoiler">  <b class="spoiler_title">Papan manajemen daya di kompartemen baterai</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/bt/bf/jy/btbfjybybqxy0ope5aikbng-efw.jpeg"><br></div></div><br>  Dibuat dengan tangan, photoresist.  Metode FR membuatnya mudah untuk mendapatkan "proses" 0,15mm, tetapi untuk beberapa alasan saya memiliki semua textolite dengan kualitas buruk sehingga jalan tipis mencoba jatuh ketika timah ... Jika ada yang tahu di mana Anda dapat membeli textolite berkualitas baik dengan jaminan - tulis di komentar ! <br><br>  Jadi, smartphone ini pada akhirnya ditenagai dengan benar, dan bekerja “seperti sebuah jam” dalam segala hal!  Menyalakan keduanya secara stabil dengan daya dari stopkontak, dan dari baterai, bekerja secara diam-diam.  Ketika pengisi daya terhubung, selalu menunjukkan biaya 100%.  Jika Anda mengeluarkannya dari stopkontak, ia terus bekerja dengan tenang dari baterai cadangan, dan segera mulai menampilkan tegangan aktual di dalamnya.  Saat memulihkan pasokan listrik, sekali lagi dengan tenang dan tenang menunjukkan biaya 100%.  Semuanya sebagaimana mestinya! <br><br>  Pada prinsipnya, melalui sirkuit yang sama, Anda dapat memberi daya pada ponsel yang menerima tegangan konstan sederhana melalui kontak ketiga baterai. <br><br><h4>  Jam digital untuk Android </h4><br>  Tentang ini, masalah itu selesai dengan besi.  Waktunya telah tiba untuk topping perangkat lunak.  Yaitu, itu perlu untuk mendapatkan jam digital besar di layar smartphone. <br><br>  Inilah yang saya butuhkan: <br><br><ol><li>  Angka terbesar mungkin!  Saya tidak suka menyipitkan mata dan melihat hal-hal kecil dari jauh. </li><li>  Kemampuan untuk menempatkan font apa pun warna apa pun.  Keterbacaan juga tergantung pada ini. </li><li>  Eksklusivitas menampilkan jam di layar - tidak ada apa pun kecuali digit waktu tidak boleh ada.  Tidak ada ramalan cuaca, peringatan, pesan, bilah status dan omong kosong lainnya - <i>tidak akan pernah</i> muncul. </li><li>  Jelas bahwa layar smartphone tidak boleh menjadi hitam dengan sendirinya. </li><li>  Fungsi kecerahan otomatis yang berfungsi dengan benar pada layar. </li><li>  Keandalan maksimum (saya masih menonton ini).  Tergantung, jalur - semua ini dikecualikan. </li></ol><br>  Saya mulai dengan menghubungkan telepon dan tanpa ampun mencabut semua sampah yang bisa saya jangkau.  Segala macam gapps, blotware, dan segala sesuatu yang tidak diperlukan untuk memuat normal terbang ke keranjang.  Termasuk banyak aplikasi sistem, berbagai utilitas untuk bekerja dengan kartu SIM, dialer, SMS, browser, kalender, wallpaper, dan omong kosong lainnya.  Saya bahkan melangkah terlalu jauh beberapa kali - telepon diulangi oleh kesalahan.  Tetapi saya mengembalikan semuanya dan membersihkannya kembali. <br><br>  Kemudian untuk waktu yang lama saya mencari di internet untuk program normal jam digital layar penuh untuk android.  Meskipun ada banyak program serupa, hampir tidak ada yang cocok untuk saya!  Semua pengembang, tanpa kecuali, mencoba menjejalkan banyak hal yang tidak perlu ke dalam produk mereka - mulai dari semacam latar belakang lucu (tidak dapat dilepaskan), dan berakhir dengan prakiraan cuaca, berita, kalender, dan sampah serupa lainnya.  Saya biasanya diam tentang iklan munculan yang telah menjangkau semua orang ... Saya hanya butuh waktu sejak jam! <br><br>  Dan fitur universal dari program menonton dan widget adalah penggunaan area layar yang sepenuhnya tidak ekonomis.  Jumlahnya kecil di mana-mana, dan margin dari tepi layar sangat besar.  Philips saya, dan layar bukan yang terbesar - hanya 4,3 ". <br><br>  Singkatnya, saya menemukan hampir satu-satunya program yang cocok - Jam Digital Besar 1.1.1. <br><br><div class="spoiler">  <b class="spoiler_title">Tangkapan layar Jam Digital Besar</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/i7/lw/eq/i7lweqe_tgvvqwiqqzdmjo_sk9q.png"><br></div></div><br>  Dia memiliki angka terbesar.  Dan masih, mereka masih jauh dari penggunaan penuh area matriks.  Dari kelebihan program - kemampuan untuk menghapus semuanya dari layar, kecuali waktu, kemampuan untuk memilih warna, format 24 jam, titik dua yang tidak berkedip, orientasi layar apa pun, dan pemeliharaan otomatis lampu latar yang tidak pudar.  Dari kekurangan - font dijahit ketat yang meniru tujuh segmen khas. <br><br>  Disampaikan dan mulai digunakan setiap hari.  Pada awalnya semuanya baik-baik saja - jumlahnya tampaknya besar, mereka terlihat normal, dan setelah jam-jam tua saya - umumnya surga dan bumi!  Tetapi sekarang, setelah sekitar satu bulan bekerja terus-menerus, saya tiba-tiba menyadari bahwa waktu <i>membeku</i> pada mereka <i>dan tidak berubah!</i>  Omong kosong apa !?  Saya memutuskan untuk memeriksa - ini adalah kesalahan satu kali atau "fitur" dari program ini. <br><br>  Nyalakan kembali jam, dan setelah beberapa minggu dekorasi diulang.  Waktu hanya berhenti memperbarui.  Alih-alih, program ini secara acak melorot setiap 7 ... 10 menit, memperbarui jam dan sekali lagi jatuh pingsan.  Jelas bahwa "keandalan" seperti itu tidak cocok untuk saya. <br><br><h4>  Android Automators dan "chips" mereka </h4><br>  Karena ini praktis satu-satunya program yang cocok, saya harus mulai menciptakan tongkat ketiak untuk itu.  Saya memutuskan bahwa saya perlu menginstal beberapa jenis alat otomatisasi android sehingga secara berkala me-restart program jam kereta sebelum bahkan sempat membeku.  Masukan Tasker.  Dia sibuk, menyelesaikannya - tetapi sesuatu yang tidak saya sukai ... Saya mengubahnya menjadi Automagic.  Siapa yang tidak tahu - alat otomasi ini menggunakan scripting berdasarkan diagram alur visual.  Dan fitur dirinya ini benar-benar membuat saya tertarik! <br><br><div class="spoiler">  <b class="spoiler_title">Merupakan Skenario Otomasi Automagic</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/dl/pr/ki/dlprki-84b4sgbvlax3ao2wm9kw.jpeg"><br></div></div><br>  Fungsi memulai kembali program menonton kereta saya secara berkala yang saya terapkan segera.  Dan kemudian dia meletakkan Automagic pada smartphone utamanya yang berfungsi dan bertahan selama seminggu dalam eksperimen yang menarik dengannya.  Hasilnya, saya membuat banyak kegunaan untuk kehidupan sehari-hari di ponsel saya. <br><br>  Tapi itu bukan yang utama.  Saya menemukan properti Automagic pada chip seperti Widget Kustom.  Dan ternyata dengan bantuannya Anda dapat menggambar dan "menghidupkan kembali" <i>setiap widget buatan sendiri</i> yang hanya memiliki imajinasi dan fungsionalitas program!  Kemudian saya menyadari bahwa saya dapat menggambar jam tangan seperti itu, yang hanya diinginkan oleh hati saya!  Selain itu, bantuan program hanya menggambarkan contoh membuat widget jam. <br><br>  Setelah beberapa hari, semuanya sudah siap dengan cara terbaik!  Berkat lancer Nova, saya memiliki kemampuan untuk meregangkan widget bahkan hingga ke tepi matriks.  Saya juga menyembunyikan bilah dok dan bilah status, membebaskan layar dari semua elemen antarmuka.  Dan inilah hasilnya - angka yang sangat besar mengenai batas layar ... Akhirnya, senang !!! <br><br><div class="spoiler">  <b class="spoiler_title">Akhirnya, angka menempati seluruh lebar layar!</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/5k/xv/9s/5kxv9sdud2mssdnn7xm1iuo8k5m.jpeg"><br></div></div><br>  Penggunaan Automagic memungkinkan saya untuk memenuhi semua persyaratan saya.  Anda dapat meletakkan font .ttf atau .otf.  Anda dapat menggambar dan meregangkan karakter dalam proporsi apa pun agar pas dengan mereka di layar.  Akhirnya, Anda hanya dapat memiliki apa yang Anda butuhkan!  Saya bahkan tidak menggambar tanda titik dua di arloji - dengan ruang yang sederhana, semuanya dapat dibaca dengan sempurna.  Dalam penerapan program eksternal dan kruk segera tidak lagi diperlukan. <br><br>  Selain itu, sekarang saya bahkan tidak perlu Locus untuk secara berkala memperbaiki koordinat GPS untuk sinkronisasi waktu.  Semua ini dapat dilakukan dengan sempurna oleh alat otomasi apa pun.  Dalam skenario kontrol, Anda dapat menerapkan hampir semua yang Anda butuhkan.  Misalnya, mempertahankan layar dalam kondisi non-fading. <br><br>  Lebih jauh lagi biasanya pergi masalah dengan poles penampilan yang berbeda.  Dan mengapa tidak, jika semua ini dapat dengan mudah diimplementasikan? <br><br>  Misalnya, ketika memilih ukuran dan faktor font, Anda harus mulai dari format waktu 4 karakter (XX: XX).  Tetapi dalam periode dari 0:00 hingga 9:59, hanya ada tiga digit di layar, mereka menempati lebar lebih kecil dari empat, dan dengan demikian tidak sepenuhnya menggunakan matriks.  Agak, tapi jelek.  Dengan Automagic, kasing ini mudah diselesaikan dengan beberapa perintah tambahan.  Ini memiliki fungsi yang memungkinkan Anda untuk mengubah hampir semua parameter widget khusus <i>dengan cepat</i> .  Dalam hal ini, ini adalah faktor lebar (perataan) karakter font, yang saya atur untuk berubah oleh pemicu interval waktu di atas.  Itu berhasil! <br><br><div class="spoiler">  <b class="spoiler_title">Tiga dan empat karakter sesuai dengan ukuran layar yang sama</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/9t/ns/5r/9tns5rg_kbtelwl0fixwluearic.jpeg"><br>  <i>Faktor lebar font berubah "on the fly" dengan transisi dari 9:59 hingga 10:00</i> <i><br></i>  <i>dan kembali dari 23:59 hingga 0:00</i> <br></div></div><br>  Pada awalnya, saya pertama kali ragu tentang waktu pembacaan jam <i>diperbarui</i> setiap menit.  Saya takut bahwa Automagic akan memperbaruinya tidak secara serempak dengan perubahan menit dari sistem jam dari smartphone, tetapi secara sewenang-wenang, sehingga memperkenalkan kesalahan acak selama satu menit.  Saya mulai memeriksa ... <br><br>  Dalam Automagic, ada dua cara berbeda untuk mengimplementasikan waktu dalam widget khusus.  Anda dapat mengirim nilai numerik ke bidang teks biasa dari widget dengan peristiwa aksi eksternal.  Untuk setiap peristiwa seperti itu, hanya ada opsi khusus "Pada waktu yang tetap", yang berarti bahwa Anda harus mengirimkannya tepat secara sinkron dengan saat waktu sistem berubah. <br><br>  Dan metode kedua lebih sederhana - tidak menggunakan skrip eksternal dan terdiri dari penulisan fungsi pemanggilan sistem tipe langsung ke bidang teks yang diinginkan dari widget <br><br><pre><code class="plaintext hljs">{getDate(),dateFormat,HH:mm}</code> </pre> <br>  Tetapi tidak ada opsi seperti "Pada waktu yang tetap".  Widget cukup dicentang "Secara otomatis menyegarkan" dan diatur ke "Refresh interval" tepat satu menit.  Dan di sini ketakutan saya tepatnya bahwa interval pembaruan mandiri widget ini dalam satu menit dapat dihitung secara sewenang-wenang relatif terhadap waktu "kisi-kisi" dari perubahan menit dari waktu sistem.  Saya melakukan beberapa percobaan, tetapi yang membuat saya senang ternyata semuanya beres.  Widget memperbarui sendiri dengan segera, segera setelah menit dari jam sistem berubah! <br><br>  Tidak masalah pada titik kapan widget mulai bekerja. <br><br><h4>  Layar kecerahan otomatis </h4><br>  Hal berikutnya yang ingin saya lakukan adalah kecerahan otomatis layar yang bagus.  Kecerahan otomatis bawaan pada Philips saya yang lama bekerja sangat buruk.  Berkedut, tidak memadai dan dengan jarak yang sangat sempit.  Di sini saya tidak repot-repot dan menempatkan salah satu dari banyak program kecerahan otomatis.  Saya mencoba Lux pada awalnya, tetapi saya tidak menyukai beberapa tincture dan profil rumit yang tidak intuitif.  Berubah menjadi Velis, dan ini ternyata yang kita butuhkan.  Apa yang saya sukai - Velis memungkinkan untuk menggambar kurva nyata dari ketergantungan kecerahan pada pembacaan luxometer dan secara real time menunjukkan pada grafik ini bagaimana smartphone menyesuaikan kecerahan sesuai dengan itu.  Anda dapat mengonfigurasikan hukum perubahan kecerahan yang sangat halus dan tentu saja nilainya, hingga 1%, saat layar hampir tidak terlihat.  Sangat nyaman di malam hari, ketika angkanya hampir tidak bersinar. <br><br>  Ketika saya sedang berlari di sekitar jam tangan baru, saya perhatikan bahwa matriks smartphone, bahkan dengan latar belakang layar yang sepenuhnya hitam, masih lumayan bersinar dengan cahaya latar menembusnya.  Ini terutama terlihat dalam kegelapan total - persegi panjang layar terlihat jelas dalam bentuk latar belakang abu-abu, sesuatu seperti efek cahaya.  Saya memutuskan untuk memperbaikinya dengan filter eksternal.  Warna nomor jam yang saya pilih merah, karena  warna merah yang saya lihat paling jelas dari jauh. <br><br>  Saya membuat filter pertama secara manual - saya mencetak isian merah solid pada printer inkjet pada film transparan dan melipat dua cetakan mentah dengan tinta satu sama lain.  Film-film tersebut melekat dengan kuat dan diperoleh “gelas” transparan berwarna merah tebal.  Ngomong-ngomong, sekarang hack kehidupan seperti itu tidak akan berfungsi lagi, itu klise karena pada pekerjaan saya benar-benar semua printer inkjet diganti dengan laser MFP modis.  Mereka mencetak dengan sempurna di atas kertas, tetapi tidak mungkin mendapatkan warna transparan pada film dengan bantuan mereka - akan ada lapisan matte yang berisik di mana tidak ada yang terlihat. <br><br>  Tetapi di sini saya entah bagaimana pergi ke Komus untuk mengambil pensil, dan tanpa sengaja melihat hal semacam ini: <br><br><div class="spoiler">  <b class="spoiler_title">Foto</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/of/e8/pw/ofe8pwoxfgo5hvkmvhul5evpync.jpeg"><br></div></div><br>  Ini adalah baki kertas kantor biasa, tetapi lihat apa itu terbuat dari baki.  Baik plexiglass, atau plastik transparan, tetapi warnanya sama dan transmisi cahaya yang saya butuhkan untuk filter.  Saya membelinya, dengan hati-hati memotong piring agar sesuai dengan layar dan menyesuaikannya.  Cantik! <br><br><div class="spoiler">  <b class="spoiler_title">Dengan filter merah</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/oq/oh/dr/oqohdrcoghynsiygiugq_egez_0.jpeg"><br></div></div><br><h4>  Sentuhan akhir </h4><br>  Pada prinsipnya, dalam hal ini, transformasi ponsel lama yang tidak perlu menjadi jam tangan cantik yang hebat dapat dianggap lengkap. <br><br>  Benar, bahkan sebelum tumpukan, saya menjadi bingung oleh fakta bahwa di editor font saya mengubah font .otf sedikit sehingga karakter seperti yang saya inginkan, sampai ke tikungan sedikit pun.  Agak, tapi bagus!  Itu juga perlu untuk membuat font monospace, sehingga ketika mengubah karakter, garis tidak bergerak keluar dan merangkak melampaui batas tampilan.  Digunakan salah satu editor font sumber terbuka, Glyphr Studio. <br><br>  Nah, pada akhirnya, tetap hanya memperbaiki seluruh struktur di rak di sudut ruangan.  Ada ruang besar untuk kreativitas.  Saya hanya membengkokkan lajur aluminium berbentuk L dan dengan lembut memasang tutup belakang smartphone dengan sekrup.  Memotong ujung yang lain ke rak.  Anda dapat memutar dengan mengatur sudut tampilan apa pun.  Dan sedikit bengkok-bengkokkan aluminium, menyesuaikan sudutnya secara vertikal.  Bahkan, saya biasanya menginstal semuanya, jadi saya tidak menyentuhnya lagi. <br><br>  Baterai cadangan telah disesuaikan di tikungan strip pemasangan.  Di sini saya melakukannya tanpa desain yang indah, tidak ada yang bisa dilihat dari belakang.  Saya juga tidak repot-repot dengan wadah terminal untuk baterai, tetapi hanya dengan hati-hati disolder langsung ke wadah logam 18650 di tempat-tempat yang tidak berdampingan dengan isi internal baterai sehingga tidak terlalu panas dengan besi solder. <br><br>  Semua koneksi dibuat dengan kabel biasa, dilemparkan melalui lubang yang dibor di sampul belakang smartphone.  Dan di dalam, saya melihat langsung ke detail dan trek papan smartphone. <br><br>  Secara total, dua kabel eksternal berasal dari desain: daya 5V dari pengisi daya listrik dan kabel antena GPS yang masuk ke jendela dan dilekatkan ke kaca dengan pita. <br><br>  Selama hampir satu tahun sekarang, jam tangan telah membuat saya senang dengan jumlah yang besar, cantik, operasi yang presisi, dan operasi yang dapat diandalkan. <br><br>  Dan untuk bersenang-senang, saya menggambar widget jam kedua - untuk lokasi vertikal smartphone. <br><br><div class="spoiler">  <b class="spoiler_title">Jam horisontal dan vertikal pada skala yang sama</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/hr/_b/o6/hr_bo6oelso-e2dyzglvbvnf9qa.jpeg"><br></div></div><br>  Saya mulai menciptakannya dengan alasan bahwa angka-angka dengan pengaturan yang tidak konvensional seperti itu dapat dibuat lebih besar, yaitu, penggunaan yang bermanfaat dari area layar ternyata menjadi semaksimal mungkin.  Selain itu, dalam hal ini, kebutuhan untuk mengubah faktor lebar karakter setiap kali beralih dari format waktu X: XX ke XX: XX dan sebaliknya menghilang, karena semuanya selalu masuk secara otomatis. <br><br>  Benar, hampir semua orang yang saya tunjukkan jam tangan vertikal non-standar berkata "fuu, horizontal lebih baik!".  Nah, ini masalah amatir, saya pribadi suka keduanya. <br><br>  Itu saja.  Terima kasih untuk semua orang yang membaca! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443052/">https://habr.com/ru/post/id443052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443038/index.html">Jika superglue masuk ke mata</a></li>
<li><a href="../id443040/index.html">7 alasan utama mengapa aplikasi diblokir di Google Play dan AppStore</a></li>
<li><a href="../id443042/index.html">Peluncuran 619 ribu tetris di GLSL, rendering dan bot sederhana</a></li>
<li><a href="../id443046/index.html">Bagaimana Peneliti Keamanan Mengakses Situs yang Dilindungi Kode iOS</a></li>
<li><a href="../id443050/index.html">Penjelasan paling sederhana tentang bagaimana algoritma enkripsi simetris bekerja hari ini</a></li>
<li><a href="../id443054/index.html">Pilihan utilitas untuk programmer di Linux</a></li>
<li><a href="../id443056/index.html">Pasien HIV kedua mencapai remisi</a></li>
<li><a href="../id443058/index.html">Arsitektur bersih. Bagian I - Pendahuluan</a></li>
<li><a href="../id443060/index.html">Akankah Starship mencapai Mars?</a></li>
<li><a href="../id443062/index.html">Bagaimana saya membuat Daur Ulang! VR</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>