<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏄 📤 🕑 Algunas veces se necesitan algunos trucos cuando se trabaja con git 💙 🏆 🚣🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quiero compartir recetas para resolver un par de tareas que a veces surgen cuando se trabaja con git y que no son "directamente obvias". 


 Al princi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algunas veces se necesitan algunos trucos cuando se trabaja con git</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424045/"><p>  Quiero compartir recetas para resolver un par de tareas que a veces surgen cuando se trabaja con git y que no son "directamente obvias". </p><br><p>  Al principio pensé en acumular más recetas, pero todo tiene su tiempo.  Creo que si hay algún beneficio, entonces es posible y poco a poco ... </p><br><p>  Entonces ... </p><a name="habracut"></a><br><h1>  Combinar ramas viejas con un dolor mínimo </h1><br><p> Preámbulo  Hay una rama principal ( <code>master</code> ), que compromete activamente nuevas características y correcciones;  hay una rama de <code>feature</code> paralelas, en la que los desarrolladores navegaron durante un tiempo hasta su propio nirvana, y de repente descubrieron que no habían caído durante un mes con el maestro, y la fusión "en la frente" (cabeza a cabeza) ya no era trivial. </p><br><p>  (Sí, no se trata de un mundo ideal donde todo es correcto, el crimen está ausente, los niños siempre son obedientes e incluso cruzan el camino estrictamente de la mano con su madre, mirando cuidadosamente a su alrededor). </p><br><p>  Propósito: frenar.  Al mismo tiempo, por lo que fue una fusión "pura", sin características.  Es decir  de modo que en el repositorio público en el gráfico de rama, dos hilos están conectados en un solo punto con el mensaje "rama fusionada 'maestro' en función".  Y todo el dolor de cabeza "este" sobre cuánto tiempo y esfuerzo tomó, cuántos conflictos se resolvieron y cuánto cabello quedó innecesariamente manchado. </p><br><p>  La trama  El hecho de que en el git puede editar la última confirmación con la clave, <code>--amend</code> saben.  El truco es que este "último compromiso" puede ubicarse en cualquier lugar y contener cualquier cosa.  Por ejemplo, puede ser no solo el "último compromiso con la rama lineal", donde se olvidaron de corregir el error tipográfico, sino también el compromiso de fusión de la fusión habitual o de "pulpo".  <code>--amend</code> simplemente <code>--amend</code> sobre los cambios propuestos y "incrustará" la confirmación modificada en el árbol, como si realmente apareciera como resultado de una fusión honesta y la resolución de conflictos.  En esencia, <code>git merge</code> y <code>git commit --amend</code> permite separar completamente el "lugar de replanteo" ("este commit en el árbol estará AQUÍ") y el contenido del commit en sí. </p><br><p>  La idea básica de un compromiso de fusión complejo con un historial limpio es simple: primero "hacemos un lugar" creando un compromiso de fusión limpio (independientemente del contenido), luego lo reescribimos con <code>--amend</code> , haciendo que el contenido sea "correcto". </p><br><ol><li><p>  "Píldorame un lugar".  Esto es fácil de hacer estableciendo una estrategia de fusión que no haga preguntas innecesarias sobre la resolución de conflictos. </p><br><pre> <code class="plaintext hljs">git checkout feature git merge master -s ours</code> </pre> <br></li><li><p>  Oh si  Antes de la fusión, era necesario crear una rama de "copia de seguridad" desde el encabezado de la característica.  Después de todo, nada se fusionó realmente ... Pero que sea el segundo párrafo, y no el 0.  En general, cambiamos a la función no fusionada y ahora nos fusionamos honestamente.  De cualquier manera posible, a pesar de cualquier "truco sucio".  Mi manera personal es mirar la rama maestra desde el momento de la última fusión y evaluar posibles confirmaciones de problemas (por ejemplo: corregir un error tipográfico en un lugar, no uno problemático. Masivamente (muchos archivos) cambiaron el nombre de una entidad, una problemática, etc.).  A partir de confirmaciones de problemas, creamos nuevas ramas (lo hago de manera ingeniosa: master1, master2, master3, etc.).  Y luego fusionamos rama por rama, pasando de viejos a nuevos y corrigiendo conflictos (que generalmente son evidentes con este enfoque).  Sugiera otros métodos (no soy un mago; solo estoy aprendiendo; ¡me complacerá hacer comentarios constructivos!).  En última instancia, al pasar (tal vez) unas horas en operaciones puramente rutinarias (que se pueden confiar al junior, porque simplemente no hay conflictos complicados con este enfoque), obtenemos el estado final del código: todas las innovaciones / correcciones del asistente se transfirieron con éxito a la rama de características, todas las pruebas relevantes pisó este código, etc.  Se debe confirmar un código exitoso. </p><br></li><li><p>  Reescribiendo la "historia de éxito".  Estando en el commit, donde "todo está hecho", ejecuta lo siguiente: </p><br></li></ol><br><pre> <code class="plaintext hljs">git tag mp git checkout mp git reset feature git checkout feature git tag -d mp</code> </pre> <br><p>  (Descifro: usando la etiqueta (mp - merge point), cambiamos al estado HEAD separado, y desde allí lo reiniciamos a la cabecera de nuestra rama, donde al principio se hizo un "replanteo" por un compromiso de fusión fraudulento. La etiqueta ya no es necesaria, así que la eliminamos).  Ahora estamos en el commit de fusión "puro" original;  Al mismo tiempo, en la copia de trabajo tenemos los archivos "correctos", donde se encuentra todo lo que necesita.  Ahora debe agregar todos los archivos modificados al índice y, especialmente, mirar cuidadosamente los archivos no montados (habrá todos los archivos nuevos que aparecieron en la rama principal).  Agregamos todo lo que necesitamos desde allí, también. </p><br><p>  Finalmente, cuando todo esté listo, ingresamos nuestra confirmación correcta en el lugar reservado: </p><br><pre> <code class="plaintext hljs">git commit --amend</code> </pre> <br><p>  ¡Hurra!  ¡Todo salió bien!  Puede insertar una rama de forma casual en un repositorio público, y nadie sabrá que realmente pasó medio día de trabajo en esta fusión. </p><br><p>  Upd: forma más concisa </p><br><p>  Tres meses después de esta publicación, el artículo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cómo y por qué robar árboles en git</a> " por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">capslocky</a> </p><br><p>  En función de sus motivos, es posible lograr exactamente el mismo objetivo de una manera más corta y sin mecanismos auxiliares: no es necesario "publicar espacio", considerar los archivos sin clasificar después de restablecer y realizar modificaciones;  Puede crear una confirmación de fusión directa con el contenido deseado en un solo paso. </p><br><p>  Comenzamos de inmediato con la fusión utilizando cualquier método disponible (como en el párrafo 2 anterior).  La historia intermedia y los hacks aún son irrelevantes.  Y luego, en lugar de la reivindicación 3, con la sustitución del compromiso de fusión, hacemos una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fusión artificial</a> , como en el artículo: </p><br><pre> <code class="plaintext hljs">git tag mp git checkout feature git merge --ff $(git commit-tree mp^{tree} -m "merged branch 'master' into 'feature'" -p feature -p master) git tag -d mp</code> </pre> <br><p>  Toda la magia aquí se realiza en un solo paso mediante el tercer comando (git commit-tree). </p><br><h1>  Seleccione parte del archivo, manteniendo el historial </h1><br><p>  Preámbulo: el archivo fue codificado-codificado, y finalmente codificado, de modo que incluso el estudio visual comenzó a disminuir la velocidad, digiriéndolo (sin mencionar JetBrains).  (Sí, estamos de vuelta en el mundo "imperfecto". Como siempre). </p><br><p>  Los cerebros inteligentes pensaron, pensaron y seleccionaron varias entidades que se pueden representar en un archivo separado.  Pero!  Si solo lo toma, copie y pegue una parte del archivo y péguelo en otro; este será un archivo completamente nuevo desde el punto de vista de git.  En caso de algún problema, una búsqueda en el historial indicará inequívocamente solo “¿dónde está esta persona discapacitada?” Quién compartió el archivo.  Y puede ser necesario encontrar la fuente original para nada "para represiones", sino puramente constructiva, para descubrir por qué se cambió esta línea;  qué error solucionó (o no solucionó).  ¡Quiero que el archivo sea nuevo, pero al mismo tiempo toda la historia de cambios aún permanece! </p><br><p>  La trama  Con algunos efectos de borde ligeramente molestos, esto se puede hacer.  Para mayor claridad, hay un archivo <code>file.txt</code> , del que quiero resaltar una parte en <code>file2.txt</code> .  (y aún mantengo la historia, sí).  Ejecute este fragmento: </p><br><pre> <code class="plaintext hljs">f=file.txt; f1=file1.txt; f2=file2.txt cp $f $f2 git add $f2 git mv $f $f1 git commit -m"split $f step 1, converted to $f1 and $f2"</code> </pre> <br><p>  Como resultado, obtenemos los archivos <code>file1.txt</code> y <code>file2.txt</code> .  Ambos tienen exactamente la misma historia (real; como el archivo original).  Sí, el <code>file.txt</code> original.txt tuvo que ser renombrado;  Este es el efecto de borde "ligeramente molesto".  Desafortunadamente, no pude encontrar una manera de guardar la historia, pero para NO renombrar el archivo fuente (si alguien puede, ¡dímelo!).  Sin embargo, el git lo soportará todo;  ahora nadie se molesta en cambiar el nombre del archivo en una confirmación por separado: </p><br><pre> <code class="plaintext hljs">git mv $f1 $f git commit -m"split finish, rename $f1 to $f"</code> </pre> <br><p>  Ahora <code>file2.txt</code> dorado mostrará el mismo historial de línea que el archivo original.  Lo principal es no fusionar estos dos commits juntos (de lo contrario, toda la magia desaparecerá; ¡lo intenté!).  Pero al mismo tiempo, nadie se molesta en editar archivos directamente en el proceso de separación;  no es necesario hacer esto más tarde con confirmaciones separadas.  Y sí, ¡puedes seleccionar muchos archivos a la vez! </p><br><p>  El punto clave de la receta: cambiar el nombre del archivo fuente a otro en el mismo commit, donde se hace (y posiblemente edita) una copia (copias).  Y deje que esta confirmación viva en el futuro (nunca se equivocará con el cambio de nombre inverso). </p><br><p>  Upd: un par de recetas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Lissov</a> </p><br><h1>  Separe la parte del repositorio de historia </h1><br><p>  Estás en la última versión del repositorio inicial.  La tarea es separar una carpeta.  (Vi opciones para varias carpetas, pero es más fácil y más comprensible ya sea doblar todo primero en uno o repetir lo siguiente varias veces). </p><br><p>  Importante!  Todos los movimientos deben hacerse con el <code>git mv</code> , de lo contrario, el git puede perder el historial. </p><br><p>  Realizamos: </p><br><pre> <code class="plaintext hljs">git filter-branch --prune-empty --subdirectory-filter "{directory}" [branch]</code> </pre> <br><p>  {directorio} es la carpeta que se separará.  Como resultado, obtenemos la carpeta junto con el historial completo de confirmaciones solo, es decir, en cada confirmación, solo se muestran los archivos de esta carpeta.  Naturalmente, parte de los commits estarán vacíos, --prune-empty los elimina. <br>  Ahora cambia el origen: </p><br><pre> <code class="plaintext hljs">git remote set-url origin {another_repository_url}` git checkout move_from_Repo_1</code> </pre> <br><p>  Si el segundo repositorio está limpio, puede ir directamente al maestro.  Bueno, empuja: </p><br><pre> <code class="plaintext hljs">git push -u move_from_Repo_1</code> </pre> <br><p>  Fragmento completo (para copiar y pegar fácilmente): </p><br><pre> <code class="plaintext hljs">directory="directory_to_extract"; newurl="another_repository_url" git filter-branch --prune-empty --subdirectory-filter "$directory" git remote set-url origin "$newurl" git checkout move_from_Repo_1 git push -u move_from_Repo_1</code> </pre> <br><h1>  Fusiona dos repositorios juntos </h1><br><p>  Suponga que hizo algo 2 veces más alto y obtuvo brunches <code>move_from_Repo_1</code> y <code>move_from_Repo_2</code> , y en cada uno transfirió archivos usando <code>git mv</code> a donde deberían estar después de la fusión.  Ahora queda por controlar: </p><br><pre> <code class="plaintext hljs">br1="move_from_Repo_1"; br2="move_from_Repo_2" git checkout master git merge origin/$br1 --allow-unrelated-histories git merge origin/$br2 --allow-unrelated-histories git push</code> </pre> <br><p>  Todo el truco está en --permitir historias no relacionadas.  Como resultado, obtenemos un repositorio con un historial completo de todos los cambios. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es424045/">https://habr.com/ru/post/es424045/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es424035/index.html">2019 es el año en que Intel se detuvo</a></li>
<li><a href="../es424037/index.html">Un breve recorrido por GraphQL</a></li>
<li><a href="../es424039/index.html">Criptografía después de aterrizar alienígenas</a></li>
<li><a href="../es424041/index.html">Una breve introducción a la biología celular</a></li>
<li><a href="../es424043/index.html">Sunny hat trick. Hay tres pueblos de Dobrovlyany en Ucrania. Y los tres tienen poderosas plantas de energía solar.</a></li>
<li><a href="../es424049/index.html">Presentamos el libro "Harry Potter y los métodos del pensamiento racional" a la Olimpiada</a></li>
<li><a href="../es424051/index.html">El Manifiesto del Programador Limpio o el Resumen del Libro de Código Corto de Robert Martin</a></li>
<li><a href="../es424053/index.html">Serie MicroSD hecha de un lienzo en blanco</a></li>
<li><a href="../es424057/index.html">Integración de aplicaciones web con Spring Cloud Contract</a></li>
<li><a href="../es424059/index.html">Highlights #GitLabLive del 20 de septiembre de 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>