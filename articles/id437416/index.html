<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦕 🖥️ 👩‍🎤 Manajemen Kapasitas: Menemukan Keseimbangan Sempurna 👨🏼‍🎤 👼🏼 🍉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo Nama saya Ivan Davydov, saya terlibat dalam riset kinerja di Yandex.Money. 


 Bayangkan Anda memiliki server yang kuat, yang masing-masing menam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Manajemen Kapasitas: Menemukan Keseimbangan Sempurna</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yamoney/blog/437416/"><p>  Halo  Nama saya Ivan Davydov, saya terlibat dalam riset kinerja di Yandex.Money. </p><br><p>  Bayangkan Anda memiliki server yang kuat, yang masing-masing menampung sejumlah aplikasi.  Jika tidak banyak, mereka tidak saling mengganggu pekerjaan masing-masing - mereka nyaman dan nyaman.  Setelah Anda datang ke layanan microser dan mengambil bagian dari fungsi "berat" dalam aplikasi terpisah. </p><br><p>  Di sini Anda dapat terbawa, dan akan ada terlalu banyak layanan mikro, yang karenanya akan menjadi sulit untuk mengelolanya dan memastikan toleransi kesalahan mereka.  Akibatnya, selusin aplikasi yang memperjuangkan sumber daya bersama akan "dibundel" di setiap server.  Ini akan berubah menjadi "keluarga besar", tetapi dalam keluarga besar jangan klik dengan paruh Anda! </p><br><p>  Pernah kami juga menghadapi ini.  Kisah saya adalah tentang malam yang berat dan tanpa tidur, ketika saya duduk di bawah lampu di malam hari dan menembaki prod.  Semuanya dimulai dengan fakta bahwa kami mulai memperhatikan masalah jaringan di server pertempuran. </p><br><p><img src="https://habrastorage.org/webt/oy/x6/zl/oyx6zly8ejckx_cr0devc65tdb0.png"></p><a name="habracut"></a><br><p>  Mereka sangat memengaruhi kinerja dan membuat drawdown yang signifikan.  Pada saat yang sama, ternyata kesalahan yang sama terjadi dengan aliran pengguna biasa, tetapi pada tingkat yang jauh lebih kecil. </p><br><p>  Masalahnya terletak pada pemanfaatan soket TCP lebih dari 100%.  Ini terjadi ketika semua soket pada server terus-menerus membuka dan menutup.  Karena itu, ada masalah jaringan interaksi antara aplikasi dan berbagai jenis kesalahan muncul - host jarak jauh tidak tersedia, koneksi HTTP / HTTPS (koneksi / batas waktu baca, peer SSL dimatikan secara salah) rusak dan lainnya. </p><br><p>  Bahkan jika Anda tidak memiliki layanan pembayaran elektronik sendiri, tidak terlalu sulit untuk menilai tingkat rasa sakit selama penjualan reguler - lalu lintas meningkat beberapa kali, dan penurunan kinerja dapat menyebabkan kerugian yang signifikan.  Jadi kami sampai pada dua kesimpulan - kita perlu mengevaluasi bagaimana kapasitas saat ini digunakan, dan mengisolasi aplikasi dari satu sama lain. </p><br><p>  Untuk mengisolasi aplikasi, kami memutuskan untuk menggunakan kontainerisasi.  Untuk melakukan ini, kami menggunakan hypervisor yang berisi banyak wadah terpisah dengan aplikasi.  Ini memungkinkan Anda untuk mengisolasi sumber daya prosesor, memori, perangkat input / output, jaringan, serta pohon proses, pengguna, sistem file, dan sebagainya. </p><br><p>  Dengan pendekatan ini, setiap aplikasi memiliki lingkungannya sendiri, yang menyediakan fleksibilitas, isolasi, keandalan, dan meningkatkan kinerja sistem secara keseluruhan.  Ini adalah solusi yang cantik dan elegan, tetapi sebelum itu Anda perlu menjawab sejumlah pertanyaan: </p><br><ul><li>  Berapa margin kinerja yang dimiliki oleh satu instance aplikasi saat ini? </li><li> Bagaimana aplikasi diskalakan dan apakah ada redundansi sumber daya dalam konfigurasi saat ini? </li><li>  Apakah mungkin untuk meningkatkan kinerja satu contoh dan apa hambatannya? </li></ul><br><p>  Dengan pertanyaan seperti itu, rekan-rekan mendatangi kami - tim peneliti kinerja. </p><br><h2 id="chem-my-zanimaemsya">  Apa yang kita lakukan </h2><br><p>  Kami melakukan segalanya untuk memastikan kinerja layanan kami dan, pertama-tama, kami meneliti dan memperbaikinya untuk proses bisnis produksi kami.  Setiap proses bisnis, baik itu membayar barang di toko dengan dompet atau mentransfer uang antar pengguna, pada dasarnya, mewakili bagi kami rantai permintaan dalam sistem. </p><br><p>  Kami melakukan eksperimen dan menyiapkan laporan untuk mengevaluasi kinerja sistem pada intensitas tinggi permintaan yang masuk.  Laporan tersebut berisi metrik kinerja dan uraian terperinci tentang masalah dan kemacetan yang teridentifikasi.  Dengan bantuan informasi ini, kami meningkatkan dan mengoptimalkan sistem kami. </p><br><p>  Menilai potensi setiap aplikasi diperumit oleh fakta bahwa beberapa layanan microser yang menggunakan kekuatan semua instans yang terlibat berpartisipasi dalam organisasi dari urutan permintaan proses bisnis. </p><br><p>  Secara metaforis, kita tahu kekuatan pasukan kita, tetapi tidak tahu potensi masing-masing pejuang.  Oleh karena itu, selain penelitian yang sedang berlangsung, perlu untuk menilai sumber daya yang digunakan sebagai bagian dari proses manajemen kapasitas.  Proses ini disebut Manajemen Kapasitas. </p><br><p>  Penelitian kami membantu mengidentifikasi dan mencegah kurangnya sumber daya, memperkirakan pembelian besi dan memiliki data akurat tentang kemampuan saat ini dan potensi sistem.  Sebagai bagian dari proses ini, kinerja aplikasi aktual (median dan maksimum) dimonitor dan data pada stok saat ini disediakan. </p><br><p>  <strong>Inti dari manajemen kapasitas adalah untuk menemukan keseimbangan antara sumber daya yang dikonsumsi dan produktivitas.</strong> </p><br><p>  Pro: </p><br><ul><li>  Setiap saat diketahui apa yang terjadi dengan kinerja setiap aplikasi. </li><li>  Lebih sedikit risiko saat menambahkan layanan microser baru. </li><li>  Biaya lebih rendah untuk pembelian peralatan baru. </li><li>  Kapasitas yang sudah ada digunakan dengan lebih cerdas. </li></ul><br><h1 id="kak-rabotaet-upravlenie-moschnostyami">  Bagaimana manajemen kapasitas bekerja </h1><br><p>  Mari kita kembali ke situasi kita dengan banyak aplikasi.  Kami melakukan penelitian yang tujuannya adalah untuk mengevaluasi bagaimana kapasitas digunakan pada server produksi. </p><br><p>  Singkatnya, rencana tindakan adalah sebagai berikut: </p><br><ol><li>  Tentukan intensitas pengguna pada aplikasi tertentu. </li><li>  Buat profil pemotretan. </li><li>  Mengevaluasi kinerja setiap instance aplikasi. </li><li>  Tingkat skalabilitas. </li><li>  Kompilasi laporan dan kesimpulan tentang jumlah instance minimum yang diperlukan untuk setiap aplikasi dalam lingkungan pertempuran. </li></ol><br><p>  <em>Dan sekarang lebih terinci.</em> </p><br><h2 id="instrumenty">  Alat-alatnya </h2><br><p>  Kami menggunakan Heka dan Zabbix untuk mengumpulkan metrik intensitas khusus.  Grafana digunakan untuk memvisualisasikan metrik yang dikumpulkan. </p><br><p>  <strong>Zabbix</strong> diperlukan untuk memonitor sumber daya server, seperti: CPU, Memori, koneksi jaringan, DB dan lainnya.  <strong>Heka</strong> menyediakan data tentang jumlah dan waktu pelaksanaan permintaan masuk / keluar, pengumpulan metrik pada antrian aplikasi internal dan jumlah data lainnya yang tak ada habisnya.  <strong>Grafana</strong> adalah alat visualisasi yang fleksibel yang digunakan oleh tim Yandex.Money yang berbeda.  Kami tidak terkecuali. </p><br><p><img src="https://habrastorage.org/webt/5q/ru/bu/5qrubu5iblepg4sostjygegfp58.png"><br>  <em>Grafana dapat menunjukkan, misalnya, hal-hal seperti itu</em> </p><br><p>  <strong>Apache JMeter</strong> digunakan sebagai generator lalu lintas.  Dengan bantuannya, skenario pemotretan dikompilasi, yang mencakup implementasi permintaan, pemantauan validitas respons, kontrol fleksibel dari aliran umpan, dan banyak lagi.  Alat ini memiliki pro dan kontra, tetapi untuk lebih dalam "mengapa produk ini?"  Saya tidak akan. </p><br><p>  Selain JMeter, kerangka <strong>yandex-tank</strong> digunakan - alat untuk pengujian stres dan analisis kinerja layanan web dan aplikasi.  Ini memungkinkan Anda untuk menyambungkan modul Anda untuk mendapatkan fungsi yang diinginkan dan menampilkan hasilnya di konsol atau dalam bentuk grafik.  Hasil penembakan kami ditampilkan di Lunapark (analog dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://overload.yandex.net</a> ), di mana kami dapat mengamatinya secara rinci dalam waktu nyata, hingga puncak kedua, memberikan kelonggaran yang diperlukan dan cukup, dan dengan demikian merespons dengan lebih cepat terhadap semburan, timbul dari pemotretan.  Dalam graphane, seseorang juga dapat menyesuaikan diskresi, tetapi solusi ini lebih mahal dalam hal sumber daya fisik dan logis.  Dan kadang-kadang kita bahkan mengunggah data mentah dan memvisualisasikannya melalui GUI Jmeter.  Tapi hanya - sst! </p><br><p>  Berbicara tentang degradasi.  Hampir semua gangguan yang terjadi dalam aplikasi di bawah arus lalu lintas yang besar dengan cepat dianalisis menggunakan <strong>Kibana</strong> .  Tapi ini juga bukan obat mujarab - beberapa masalah jaringan hanya dapat dianalisis dengan menghapus dan menganalisis lalu lintas. </p><br><p>  Menggunakan Grafana, kami menganalisis intensitas pengguna dalam aplikasi selama beberapa bulan.  Kami memutuskan untuk mengambil total waktu prosesor untuk mengeksekusi permintaan sebagai unit pengukuran, yaitu jumlah permintaan dan waktu eksekusi mereka diperhitungkan.  Jadi kami menyusun daftar permintaan yang paling "berat", yang merupakan sebagian besar aliran ke aplikasi.  Daftar inilah yang menjadi dasar profil penembakan. </p><br><p><img src="https://habrastorage.org/webt/5r/kc/5n/5rkc5nqnllvdoxoeqs4wlgstxfs.png"><br>  <em>Intensitas pengguna per aplikasi selama beberapa bulan</em> </p><br><h2 id="profil-strelby-i-pristrelka">  Membidik dan melihat profil </h2><br><p>  Kami menyebut meluncurkan skrip sebagai bagian dari percobaan.  Profil ini terdiri dari dua bagian. </p><br><p>  Bagian pertama adalah menulis skrip permintaan.  Selama implementasi, perlu untuk menganalisis intensitas pengguna untuk setiap permintaan aplikasi yang masuk dan membuat rasio persentase di antara mereka untuk mengidentifikasi yang paling dipanggil dan yang sudah berjalan lama.  Bagian kedua adalah pemilihan parameter pertumbuhan aliran: dengan intensitas apa dan untuk berapa lama memuat. </p><br><p>  Untuk kejelasan yang lebih besar, metodologi untuk menyusun profil paling baik ditunjukkan dengan contoh. </p><br><p>  Grafana membuat grafik yang mencerminkan intensitas pengguna dan bagian dari setiap permintaan dalam aliran total.  Berdasarkan distribusi dan waktu respons ini untuk setiap permintaan, grup dibuat di JMeter, yang masing-masing merupakan generator traffic independen.  Skenario hanya didasarkan pada permintaan yang paling "berat", karena sulit untuk mengimplementasikan semuanya (dalam beberapa aplikasi ada lebih dari seratus), dan ini tidak selalu diperlukan karena intensitasnya yang relatif rendah. </p><br><p><img src="https://habrastorage.org/webt/so/r-/lh/sor-lhmdrw0z5egoxcjye2z1htk.png"><br>  <em>Persentase Pertanyaan</em> </p><br><p>  Studi ini menguji intensitas pengguna dalam aliran konstan, dan "ledakan" yang terjadi secara berkala paling sering dianggap secara pribadi. </p><br><p>  Dalam contoh kita, dua kelompok dipertimbangkan.  Grup pertama termasuk "permintaan 1" dan "permintaan 2" dalam rasio 1 ke 2. Demikian pula, kelompok kedua termasuk permintaan 3 dan 4. Permintaan yang tersisa untuk komponen jauh kurang intens, jadi kami tidak memasukkannya dalam skrip. </p><br><p><img src="https://habrastorage.org/webt/fe/oo/mv/feoomv8l4vvhd7oab7ia8sdm_iq.png"><br>  <em>Kueri pengelompokan di Jmeter</em> </p><br><p>  Berdasarkan waktu respons rata-rata untuk masing-masing kelompok, kinerja diperkirakan dengan rumus: </p><br><p>  x = 1000 / t, di mana t adalah median waktu, ms </p><br><p>  Kami mendapatkan hasil perhitungan dan memperkirakan intensitas perkiraan dengan meningkatnya jumlah utas: </p><br><p>  TPS = x * p, di mana p adalah jumlah utas, TPS adalah transaksi per detik, dan x adalah hasil dari perhitungan sebelumnya. </p><br><p>  Jika permintaan diproses dalam 500 ms, maka dengan satu aliran kami memiliki 2 Tps, dan dengan 100 utas sebaiknya memiliki 200 Tps.  Berdasarkan hasil yang diperoleh, parameter pertumbuhan awal dapat dipilih.  Setelah iterasi pertama penelitian, parameter ini biasanya disesuaikan. </p><br><p>  Saat skenario pemotretan siap, kami memulai pemotretan - pemotretan selama satu menit dalam satu aliran.  Ini dilakukan untuk memeriksa operabilitas skrip dengan aliran konstan, untuk mengevaluasi waktu respons terhadap permintaan di setiap grup dan untuk mendapatkan persentase rasio permintaan. </p><br><p>  Saat menjalankan profil ini, kami menemukan bahwa pada intensitas yang sama, persentase permintaan dipertahankan, karena waktu respons rata-rata di grup kedua lebih panjang daripada di yang pertama.  Oleh karena itu, kami menetapkan laju aliran yang sama untuk kedua kelompok.  Dalam kasus lain, perlu untuk secara eksperimental memilih parameter untuk masing-masing kelompok secara terpisah. </p><br><p>  Dalam contoh ini, intensitas diterapkan secara bertahap, yaitu sejumlah aliran ditambahkan pada interval tertentu. </p><br><p><img src="https://habrastorage.org/webt/6u/th/hw/6uthhwf_o2ehsuukwdc2ko_4emi.png"><br>  <em>Opsi Pertumbuhan Intensitas</em> </p><br><p>  Parameter pertumbuhan intensitas adalah sebagai berikut: </p><br><ul><li>  Jumlah target utas adalah 100 (ditentukan saat melihat). </li><li>  Pertumbuhan selama 1000 detik (~ 16 menit). </li><li>  100 langkah. </li></ul><br><p>  Jadi, setiap 10 detik kami menambahkan satu aliran.  Interval antara menambahkan utas dan jumlah utas yang ditambahkan bervariasi tergantung pada perilaku sistem pada langkah tertentu.  Seringkali, intensitas disuplai dengan pertumbuhan yang halus, sehingga Anda dapat melacak status sistem di setiap tahap. </p><br><h2 id="boevye-strelby">  Menembak </h2><br><p>  Biasanya, penembakan dimulai pada malam hari dari server jarak jauh.  Pada saat ini, lalu lintas pengguna minimal - ini berarti bahwa pemotretan tidak akan memengaruhi pengguna, dan kesalahan dalam hasilnya akan lebih sedikit. </p><br><p>  Menurut hasil penembakan pertama dalam satu contoh, kami menyesuaikan jumlah utas dan waktu pertumbuhan, menganalisis perilaku sistem secara keseluruhan dan menemukan penyimpangan dalam pekerjaan.  Setelah semua penyesuaian, pemotretan berulang menjadi satu instance dimulai.  Pada tahap ini, kami menentukan kinerja maksimum dan memantau penggunaan sumber daya perangkat keras dari kedua server dengan aplikasi dan semua yang ada di belakangnya. </p><br><p>  Menurut hasil pemotretan, kinerja satu instance aplikasi kami adalah sekitar 1000 Tps.  Pada saat yang sama, peningkatan waktu respons untuk semua permintaan dicatat tanpa meningkatkan produktivitas, yaitu, kami mencapai saturasi, tetapi bukan degradasi. </p><br><p>  Pada tahap selanjutnya, kami membandingkan hasil yang diperoleh dari contoh lain.  Ini penting, karena perangkat keras dapat berbeda, yang berarti bahwa instance yang berbeda dapat memberikan indikator yang sangat berbeda.  Begitu juga dengan kami - beberapa server ternyata menjadi urutan besarnya lebih produktif karena generasi dan karakteristik.  Oleh karena itu, kami mengidentifikasi sekelompok server dengan hasil terbaik dan menyelidiki skalabilitasnya. </p><br><p><img src="https://habrastorage.org/webt/cm/kt/qc/cmktqc3ytdxz24bkphym7ozyrjg.png"><br>  <em>Perbandingan kinerja server</em> </p><br><h2 id="masshtabiruemost-i-poisk-uzkih-mest">  Skalabilitas dan bottlenecking </h2><br><p>  Langkah selanjutnya adalah menyelidiki kinerja pada instance 2, 3, dan 4.  Secara teori, kinerja harus tumbuh secara linear dengan meningkatnya jumlah instance.  Dalam praktiknya, ini biasanya tidak demikian. </p><br><p>  Dalam contoh kita, itu ternyata menjadi pilihan yang hampir sempurna. </p><br><p><img src="https://habrastorage.org/webt/0s/2z/na/0s2znafo_1qtkiiyqj29t2-xhws.png"></p><br><p>  Alasan untuk pertumbuhan produktivitas jenuh adalah kelelahan kolam konektor sebelum backend berikutnya.  Ini diselesaikan dengan mengontrol ukuran kumpulan pada sisi keluar dan masuk dan mengarah pada peningkatan kinerja aplikasi. </p><br><p>  Dalam penelitian lain, kami menemukan lebih banyak hal menarik.  Eksperimen telah menunjukkan bahwa seiring dengan kinerja, pemanfaatan CPU dan koneksi basis data berkembang pesat.  Dalam kasus kami, ini terjadi karena dalam konfigurasi dengan satu instance kami berlari ke pengaturan kami sendiri untuk kumpulan aplikasi, dan dengan dua contoh kami menggandakan nomor ini, sehingga menggandakan aliran keluar.  Basis data tidak siap untuk volume seperti itu.  Karena itu, kumpulan ke database mulai menjadi tersumbat, persentase CPU yang dikonsumsi mencapai tanda kritis 99%, dan waktu pemrosesan permintaan meningkat, dan sebagian lalu lintas jatuh sama sekali.  Dan kami sudah mendapatkan hasil seperti itu di dua contoh! </p><br><p>  Untuk akhirnya meyakinkan diri kita sendiri akan ketakutan kita, kita menembak 3 kali.  Hasilnya kira-kira sama seperti pada dua yang pertama, kecuali bahwa mereka dengan cepat mengalami gangguan. </p><br><p>  Ada contoh lain dari "colokan", yang, menurut pendapat saya, adalah yang paling menyakitkan - ini adalah kode yang ditulis dengan buruk.  Mungkin ada apa pun yang Anda inginkan, mulai dari kueri basis data yang berjalan dalam hitungan menit, diakhiri dengan kode yang salah mengalokasikan memori mesin Java. </p><br><h2 id="itogi">  Ringkasan </h2><br><p>  Akibatnya, margin aplikasi yang diselidiki dalam aplikasi contoh kami memiliki margin kinerja lebih dari 5 kali. </p><br><p>  Untuk meningkatkan produktivitas, perlu untuk menghitung jumlah kumpulan prosesor yang cukup dalam pengaturan aplikasi.  Dua contoh untuk aplikasi tertentu sudah cukup, dan penggunaan semua 15 yang tersedia berlebihan. </p><br><p>  Setelah penelitian, hasil berikut diperoleh: </p><br><ul><li>  Intensitas pengguna selama 1 bulan ditentukan dan dipantau. </li><li>  Margin kinerja satu contoh aplikasi telah diidentifikasi. </li><li>  Hasilnya diperoleh tentang kesalahan yang terjadi di bawah aliran besar. </li><li>  Kemacetan untuk pekerjaan lebih lanjut tentang peningkatan produktivitas telah diidentifikasi. </li><li>  Jumlah minimum contoh yang cukup untuk operasi aplikasi yang benar telah diidentifikasi.  Dan, akibatnya, penggunaan kapasitas yang berlebihan terungkap. </li></ul><br><p>  Hasil penelitian membentuk dasar proyek untuk transfer komponen ke dalam wadah, yang akan kita bahas dalam artikel berikut.  Sekarang kita dapat mengatakan dengan pasti berapa banyak kontainer dan dengan karakteristik apa yang perlu dimiliki, bagaimana menggunakan kapasitasnya secara rasional dan apa yang harus dikerjakan untuk memastikan kinerja yang tepat. </p><br><p>  Datanglah ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ruang obrolan telegram</a> kami yang nyaman di mana Anda selalu dapat meminta saran, membantu kolega, dan hanya berbicara tentang penelitian produktivitas. </p><br><hr><br><p>  Itu saja untuk hari ini.  Ajukan pertanyaan di komentar dan berlangganan blog Yandex.Money - segera kita akan berbicara tentang phishing dan cara menghindarinya. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437416/">https://habr.com/ru/post/id437416/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437402/index.html">Bagaimana saya mengajar robot untuk berjalan di video YouTube</a></li>
<li><a href="../id437406/index.html">Microkernel seL4. Verifikasi formal program di dunia nyata</a></li>
<li><a href="../id437408/index.html">802.1x, EX2200, NPS, dan semuanya ...</a></li>
<li><a href="../id437410/index.html">Pengantar Spring Boot dengan Spring Data Mongo</a></li>
<li><a href="../id437414/index.html">Di mana lebih dari 20 juta kartu transportasi rentan di Rusia: kami membongkar dan mengembangkan MIFARE Classic</a></li>
<li><a href="../id437418/index.html">Tentang Entitas, DTO, ORM, dan Lazy Load</a></li>
<li><a href="../id437420/index.html">Ingin LED yang kekal? Temukan besi solder dan file. Atau pencahayaan buatan rumah sendiri</a></li>
<li><a href="../id437422/index.html">Titik awal</a></li>
<li><a href="../id437424/index.html">Lakukan Mimpi Kecerdasan Buatan dari Zerglings</a></li>
<li><a href="../id437426/index.html">Siswa, siswa abadi dan haus akan pengetahuan baru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>