<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤚🏼 🍲 👳 Beschreibung des Ansatzes zum Organisieren und Testen von Code mit Redux Thunk 😙 👨🏾‍⚖️ 😙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! 


 In diesem Beitrag möchte ich meinen Ansatz zum Organisieren und Testen von Code mit Redux Thunk in einem React- Projekt erläuter...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Beschreibung des Ansatzes zum Organisieren und Testen von Code mit Redux Thunk</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/epam_systems/blog/469371/"><p>  Hallo allerseits! </p><br><p>  In diesem Beitrag möchte ich meinen Ansatz zum Organisieren und Testen von Code mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Redux Thunk</a> in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">React-</a> Projekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erläutern</a> . </p><br><p>  Der Weg dorthin war lang und dornig, daher werde ich versuchen, den Gedankengang und die Motivation zu demonstrieren, die zur endgültigen Entscheidung geführt haben. </p><a name="habracut"></a><br><h2 id="opisanie-prilozheniya-i-postanovka-problemy">  Beschreibung der Anwendung und Problemstellung </h2><br><p>  Zunächst ein kleiner Kontext. </p><br><p>  Die folgende Abbildung zeigt das Layout einer typischen Seite in unserem Projekt. </p><br><p><img src="https://habrastorage.org/webt/rk/je/ac/rkjeacwa1f4shulpc5ge5y4oi6q.jpeg"></p><br><p>  In der Reihenfolge: </p><br><ul><li>  Die Tabelle (Nr. 1) enthält Daten, die sehr unterschiedlich sein können (Klartext, Links, Bilder usw.). </li><li>  Das Sortierfeld (Nr. 2) legt die Datensortierungseinstellungen in der Tabelle nach Spalten fest. </li><li>  Das Filterfeld (Nr. 3) stellt verschiedene Filter gemäß den Spalten der Tabelle ein. </li><li>  Über das Spaltenfenster (Nr. 4) können Sie die Anzeige von Tabellenspalten einstellen (ein- / ausblenden). </li><li>  Im Vorlagenfenster (Nr. 5) können Sie zuvor erstellte Einstellungsvorlagen auswählen.  Vorlagen enthalten Daten aus den Bedienfeldern Nr. 2, Nr. 3, Nr. 4 sowie einige andere Daten, z. B. die Position der Spalten, ihre Größe usw. </li></ul><br><p>  Die Panels werden durch Klicken auf die entsprechenden Schaltflächen geöffnet. </p><br><p>  Daten darüber, welche Spalten in einer Tabelle im Allgemeinen enthalten sein können, welche Daten darin enthalten sein können, wie sie angezeigt werden sollen, welche Werte Filter enthalten können und andere Informationen sind in den Metadaten der Tabelle enthalten, die zu Beginn des Seitenladens getrennt von den Daten selbst angefordert werden. </p><br><p>  Es stellt sich heraus, dass der aktuelle Status der Tabelle und der darin enthaltenen Daten von drei Faktoren abhängt: </p><br><ul><li>  Daten aus den Metadaten der Tabelle. </li><li>  Einstellungen für die aktuell ausgewählte Vorlage. </li><li>  Benutzereinstellungen (alle Änderungen an der ausgewählten Vorlage werden in einer Art „Entwurf“ gespeichert, der entweder in eine neue Vorlage umgewandelt oder die aktuelle mit neuen Einstellungen aktualisiert oder gelöscht und die Vorlage in den ursprünglichen Zustand zurückversetzt werden kann). </li></ul><br><p>  Wie oben erwähnt, ist eine solche Seite typisch.  Für jede dieser Seiten (oder genauer für die darin enthaltene Tabelle) wird im Redux-Repository eine separate Entität erstellt, um die Arbeit mit ihren Daten und Parametern zu vereinfachen. </p><br><p>  Um homogene Gruppen von Thunk- und Action-Erstellern festlegen und Daten für eine bestimmte Entität aktualisieren zu können, wird der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">folgende Ansatz verwendet</a> (eine Art Factory): </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actionsCreator = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prefix, getCurrentStore, entityModel</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* --- ACTIONS BLOCK --- */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchTotalCounterStart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${prefix}</span></span></span><span class="hljs-string">FETCH_TOTAL_COUNTER_START`</span></span> }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchTotalCounterSuccess</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">payload</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${prefix}</span></span></span><span class="hljs-string">FETCH_TOTAL_COUNTER_SUCCESS`</span></span>, payload }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchTotalCounterError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${prefix}</span></span></span><span class="hljs-string">FETCH_TOTAL_COUNTER_ERROR`</span></span>, error }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applyFilterSuccess</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">payload</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${prefix}</span></span></span><span class="hljs-string">APPLY_FILTER_SUCCESS`</span></span>, payload }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applyFilterError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${prefix}</span></span></span><span class="hljs-string">APPLY_FILTER_ERROR`</span></span>, error }; } <span class="hljs-comment"><span class="hljs-comment">/* --- THUNKS BLOCK --- */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchTotalCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filter</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> dispatch =&gt; { dispatch(fetchTotalCounterStart()); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { payload } } = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> entityModel.fetchTotalCounter(filter); dispatch(fetchTotalCounterSuccess(payload)); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { dispatch(fetchTotalCounterError(error)); } }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filter, dispatch</span></span></span><span class="hljs-function">) </span></span>{ dispatch(fetchTotalCounter(filter)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entityModel.fetchData(filter); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applyFilter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">newFilter</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (dispatch, getStore) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = getStore(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> currentStore = getCurrentStore(store); <span class="hljs-comment"><span class="hljs-comment">// 'getFilter' comes from selectors. const filter = newFilter || getFilter(currentStore); const { data: { payload } } = await fetchData(filter, dispatch); dispatch(applyFilterSuccess(payload)); } catch (error) { dispatch(applyFilterError(error)); } }; } return { fetchTotalCounterStart, fetchTotalCounterSuccess, fetchTotalCounterError, applyFilterSuccess, applyFilterError, fetchTotalCounter, fetchData, applyFilter, }; };</span></span></code> </pre> <br><p>  Wo: </p><br><ul><li>  <code>prefix</code> - Entitätspräfix im Redux-Repository.  Es ist eine Zeichenfolge der Form "CATS_", "MICE_" usw. </li><li>  <code>getCurrentStore</code> - Ein Selektor, der die aktuellen Daten der Entität aus dem Redux-Repository zurückgibt. </li><li>  <code>entityModel</code> - Eine Instanz der Entitätsmodellklasse.  Einerseits wird über das Modell auf eine API zugegriffen, um eine Anforderung an den Server zu erstellen, andererseits wird eine komplexe (oder nicht so) Datenverarbeitungslogik beschrieben. </li></ul><br><p>  Auf diese Weise können Sie die Verwaltung von Daten und Parametern einer bestimmten Entität im Redux-Repository flexibel beschreiben und diese der dieser Entität entsprechenden Tabelle zuordnen. </p><br><p>  Da das Management dieses Systems viele Nuancen aufweist, kann Thunk komplex, umfangreich, verwirrend sein und sich wiederholende Teile aufweisen.  Um sie zu vereinfachen und den Code wiederzuverwenden, werden komplexe Thunks in einfachere unterteilt und zu einer Komposition kombiniert.  Infolgedessen kann sich nun herausstellen, dass ein Thunk einen anderen aufruft, der bereits normale <code>applyFilter</code> kann (wie das <code>applyFilter</code> Bundle - <code>fetchTotalCounter</code> aus dem obigen Beispiel).  Und wenn alle Hauptpunkte berücksichtigt und alle erforderlichen Thunk- und Action-Ersteller beschrieben wurden, hatte die Datei mit der <code>actionsCreator</code> Funktion ~ 1200 Codezeilen und wurde mit großem Quietschen getestet.  Die Testdatei hatte auch ungefähr 1200 Zeilen, aber die Abdeckung betrug bestenfalls 40-50%. </p><br><p>  Hier ist das Beispiel natürlich stark vereinfacht, sowohl in Bezug auf die Anzahl der Thunk als auch in Bezug auf ihre interne Logik, aber dies wird ausreichen, um das Problem zu demonstrieren. </p><br><p>  Achten Sie im obigen Beispiel auf zwei Arten von Thunk: </p><br><ul><li>  <code>fetchTotalCounter</code> - <code>fetchTotalCounter</code> Versand- <code>fetchTotalCounter</code> . </li><li>  <code>applyFilter</code> - Neben dem Versand seiner <code>applyFilterSuccess</code> ( <code>applyFilterSuccess</code> , <code>applyFilterError</code> ) wird auch ein weiterer Thunk ( <code>fetchTotalCounter</code> ) <code>fetchTotalCounter</code> . <br>  Wir werden etwas später darauf zurückkommen. </li></ul><br><p>  All dies wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie folgt</a> getestet (das Framework wurde zum Testen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jest verwendet</a> ): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> configureMockStore <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux-mock-store'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> thunk <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux-thunk'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { actionsCreator } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../actions'</span></span>; describe(<span class="hljs-string"><span class="hljs-string">'actionsCreator'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> defaultState = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> middlewares = [thunk]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mockStore = configureMockStore(middlewares); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prefix = <span class="hljs-string"><span class="hljs-string">'TEST_'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getCurrentStore = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> defaultState; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> entityModel = { <span class="hljs-attr"><span class="hljs-attr">fetchTotalCounter</span></span>: jest.fn(), <span class="hljs-attr"><span class="hljs-attr">fetchData</span></span>: jest.fn(), }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> actions; beforeEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { actions = actionsCreator(prefix, getCurrentStore, entityModel); }); describe(<span class="hljs-string"><span class="hljs-string">'fetchTotalCounter'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'should dispatch correct actions on success'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> filter = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> payload = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = mockStore(defaultState); entityModel.fetchTotalCounter.mockResolvedValueOnce({ <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { payload }, }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> expectedActions = [ { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${prefix}</span></span></span><span class="hljs-string">FETCH_TOTAL_COUNTER_START`</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${prefix}</span></span></span><span class="hljs-string">FETCH_TOTAL_COUNTER_SUCCESS`</span></span>, payload, } ]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> store.dispatch(actions.fetchTotalCounter(filter)).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { expect(store.getActions()).toEqual(expectedActions); }); }); it(<span class="hljs-string"><span class="hljs-string">'should dispatch correct actions on error'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> filter = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = mockStore(defaultState); entityModel.fetchTotalCounter.mockRejectedValueOnce(error); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> expectedActions = [ { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${prefix}</span></span></span><span class="hljs-string">FETCH_TOTAL_COUNTER_START`</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${prefix}</span></span></span><span class="hljs-string">FETCH_TOTAL_COUNTER_ERROR`</span></span>, error, } ]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> store.dispatch(actions.fetchTotalCounter(filter)).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { expect(store.getActions()).toEqual(expectedActions); }); }); }); describe(<span class="hljs-string"><span class="hljs-string">'applyFilter'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'should dispatch correct actions on success'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> payload = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newFilter = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = mockStore(defaultState); entityModel.fetchData.mockResolvedValueOnce({ <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { payload } }); entityModel.fetchTotalCounter.mockResolvedValueOnce({ <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: counter }, }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> expectedActions = [ <span class="hljs-comment"><span class="hljs-comment">// fetchTotalCounter actions { type: `${prefix}FETCH_TOTAL_COUNTER_START` }, { type: `${prefix}FETCH_TOTAL_COUNTER_SUCCESS`, payload: counter, }, // applyFilter actions { type: `${prefix}APPLY_FILTER_SUCCESS`, payload, } ]; return store.dispatch(actions.applyFilter(newFilter)).then(() =&gt; { expect(store.getActions()).toEqual(expectedActions); }); }); it('should dispatch correct actions on error', () =&gt; { const error = {}; const counter = 0; const newFilter = {}; const store = mockStore(defaultState); entityModel.fetchData.mockRejectedValueOnce(error); entityModel.fetchTotalCounter.mockResolvedValueOnce({ data: { payload: counter }, }); const expectedActions = [ // fetchTotalCounter actions { type: `${prefix}FETCH_TOTAL_COUNTER_START` }, { type: `${prefix}FETCH_TOTAL_COUNTER_SUCCESS`, payload: counter, }, // applyFilter actions { type: `${prefix}APPLY_FILTER_ERROR`, error, } ]; return store.dispatch(actions.applyFilter(newFilter)).then(() =&gt; { expect(store.getActions()).toEqual(expectedActions); }); }); }); });</span></span></code> </pre> <br><p>  Wie Sie sehen, gibt es keine Probleme beim Testen des ersten Thunk-Typs - Sie müssen nur die entityModel-Modellmethode einbinden, der zweite Typ ist jedoch komplizierter - Sie müssen die Daten für die gesamte Kette des aufgerufenen Thunk und die entsprechenden Modellmethoden löschen.  Andernfalls wird der Test auf die Störung der Daten ( <strong>{data: {payload}}</strong> ) fallen, und dies kann entweder explizit oder implizit geschehen (es war so, dass der Test erfolgreich bestanden wurde, aber bei sorgfältiger Recherche wurde festgestellt, dass im zweiten / dritten Glied dieser Kette gab es einen Rückgang im Test aufgrund des Fehlens gesperrter Daten).  Es ist auch schlecht, dass Unit-Tests einzelner Funktionen zu einer Art Integration werden und eng miteinander verbunden werden. </p><br><p>  Es stellt sich die Frage: Warum überprüfen Sie in der Funktion <code>applyFilter</code> , wie sich die Funktion <code>fetchTotalCounter</code> wenn bereits separate detaillierte Tests <strong>dafür</strong> geschrieben wurden?  Wie kann ich das Testen des zweiten Thunk-Typs unabhängiger machen?  Es wäre großartig, die Gelegenheit zu bekommen, zu testen, dass <strong>Thunk</strong> (in diesem Fall <code>fetchTotalCounter</code> ) <strong>nur mit den richtigen Parametern aufgerufen wird</strong> , und es wäre nicht erforderlich, sich um die Moks zu kümmern, damit es richtig funktioniert. </p><br><p>  Aber wie geht das?  Die offensichtliche Entscheidung fällt mir ein: die in applyFilter aufgerufene Funktion fetchData zu <code>applyFilter</code> oder den <code>fetchTotalCounter</code> zu sperren (da häufig ein anderer Thunk direkt aufgerufen wird und nicht über eine andere Funktion wie <code>fetchData</code> ). </p><br><p>  Lass es uns versuchen.  Zum Beispiel werden wir nur ein erfolgreiches Skript ändern. </p><br><ul><li>  Option Nummer 1.  Mock <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>fetchData</code></a> Funktion: </li></ul><br><pre> <code class="diff hljs">describe('applyFilter', () =&gt; { it('should dispatch correct actions on success', () =&gt; { const payload = {}; - const counter = 0; const newFilter = {}; const store = mockStore(defaultState); - entityModel.fetchData.mockResolvedValueOnce({ data: { payload } }); - entityModel.fetchTotalCounter.mockResolvedValueOnce({ - data: { payload: counter }, - }); + const fetchData = jest.spyOn(actions, 'fetchData'); + // or fetchData.mockImplementationOnce(Promise.resolve({ data: { payload } })); + fetchData.mockResolvedValueOnce({ data: { payload } }); const expectedActions = [ - // Total counter actions - { type: `${prefix}FETCH_TOTAL_COUNTER_START` }, - { - type: `${prefix}FETCH_TOTAL_COUNTER_SUCCESS`, - payload: counter, - }, - // apply filter actions { type: `${prefix}APPLY_FILTER_SUCCESS`, payload, } ]; return store.dispatch(actions.applyFilter(newFilter)).then(() =&gt; { expect(store.getActions()).toEqual(expectedActions); + expect(actions.fetchTotalCounter).toBeCalledWith(newFilter); }); }); });</code> </pre> <br><p>  Hier ersetzt die Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>jest.spyOn</code></a> ungefähr (und möglicherweise genau) die folgende Implementierung: </p><br><pre> <code class="javascript hljs">actions.fetchData = jest.fn(actions.fetchData);</code> </pre> <br><p>  Dies ermöglicht es uns, die Funktion zu "überwachen" und zu verstehen, ob und mit welchen Parametern sie aufgerufen wurde. </p><br><p>  Wir erhalten folgenden Fehler: </p><br><pre> <code class="diff hljs">Difference: - Expected + Received Array [ Object { - "payload": Object {}, - "type": "TEST_APPLY_FILTER_SUCCESS", + "type": "TEST_FETCH_TOTAL_COUNTER_START", }, + Object { + "error": [TypeError: Cannot read property 'data' of undefined], + "type": "TEST_FETCH_TOTAL_COUNTER_ERROR", + }, + Object { + "error": [TypeError: Cannot read property 'data' of undefined], + "type": "TEST_APPLY_FILTER_ERROR", + }, ]</code> </pre> <br><p>  Seltsamerweise haben wir die Funktion fetchData versteckt und unsere Implementierung eingeschlossen </p><br><pre> <code class="javascript hljs">fetchData.mockResolvedValueOnce({ <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { payload } })</code> </pre> <br><p>  aber die Funktion funktioniert genauso wie zuvor, das heißt, der Mock hat nicht funktioniert!  Lass es uns anders versuchen. </p><br><ul><li>  Option Nummer 2.  Mock <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>fetchTotalCounter</code></a> Funktion: </li></ul><br><pre> <code class="diff hljs">describe('applyFilter', () =&gt; { it('should dispatch correct actions on success', () =&gt; { const payload = {}; - const counter = 0; const newFilter = {}; const store = mockStore(defaultState); entityModel.fetchData.mockResolvedValueOnce({ data: { payload } }); - entityModel.fetchTotalCounter.mockResolvedValueOnce({ - data: { payload: counter }, - }); + const fetchTotalCounter = jest.spyOn(actions, 'fetchTotalCounter'; + fetchTotalCounter.mockImplementation(() =&gt; {}); const expectedActions = [ - // Total counter actions - { type: `${prefix}FETCH_TOTAL_COUNTER_START` }, - { - type: `${prefix}FETCH_TOTAL_COUNTER_SUCCESS`, - payload: counter, - }, - // apply filter actions { type: `${prefix}APPLY_FILTER_SUCCESS`, payload, } ]; return store.dispatch(actions.applyFilter(newFilter)).then(() =&gt; { expect(store.getActions()).toEqual(expectedActions); + expect(actions.fetchTotalCounter).toBeCalledWith(newFilter); }); }); });</code> </pre> <br><p>  Wir bekommen genau den gleichen Fehler.  Aus irgendeinem Grund ersetzen unsere Mokas nicht die ursprüngliche Implementierung von Funktionen. </p><br><p>  Nachdem ich dieses Problem selbst untersucht und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einige</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen</a> im Internet gefunden hatte, stellte ich fest, dass dieses Problem nicht nur bei mir besteht und (meiner Meinung nach) ziemlich kritisch gelöst ist.  Darüber hinaus sind die in diesen Quellen beschriebenen Beispiele gut, bis sie Teil von etwas werden, das sie zu einem einzigen System verbindet (in unserem Fall handelt es sich um eine Fabrik mit Parametern). </p><br><p>  Bei unserem Projekt in Jenkins Pipline gibt es eine Codeprüfung von SonarQube, bei der geänderte Dateien (die sich in der Merge / Pull-Anforderung befinden) <code>&gt; 60%</code> abgedeckt werden müssen.  Da die Abdeckung dieser Fabrik, wie bereits erwähnt, unbefriedigend war und die Notwendigkeit, eine solche Datei abzudecken, nur zu Depressionen führte, musste etwas damit unternommen werden, da sich sonst die Bereitstellung neuer Funktionen mit der Zeit verlangsamen könnte.  Es wurde nur die Testabdeckung anderer Dateien (Komponenten, Funktionen) in derselben Zusammenführungs- / Pull-Anforderung gespeichert, um die prozentuale Abdeckung bis zur gewünschten Marke zu erreichen. Tatsächlich war dies jedoch eine Problemumgehung und keine Lösung für das Problem.  Und einen schönen Moment, nachdem ich ein wenig Zeit im Sprint eingeplant hatte, begann ich zu überlegen, wie dieses Problem gelöst werden kann. </p><br><h2 id="popytka-resheniya-problemy-1-ya-chto-to-slyshal-pro-redux-saga">  Ein Versuch, das Problem Nummer 1 zu lösen.  Ich habe etwas über Redux-Saga gehört ... </h2><br><p>  ... und sie sagten mir, dass das Testen bei Verwendung dieser Middleware erheblich vereinfacht wird. </p><br><p>  Wenn Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sich die Dokumentation ansehen</a> , werden Sie überrascht sein, wie einfach der Code getestet wird.  Der Saft selbst liegt in der Tatsache, dass es bei diesem Ansatz überhaupt kein Problem gibt, dass eine Saga eine andere Saga aufrufen kann - wir können nass werden und die Funktionen der Middleware ( <code>put</code> , <code>take</code> usw.) „hören“ und Stellen Sie sicher, dass sie aufgerufen wurden (und mit den richtigen Parametern aufgerufen wurden).  Das heißt, in diesem Fall greift die Funktion nicht direkt auf eine andere Funktion zu, sondern verweist auf eine Funktion aus der Bibliothek, die dann andere erforderliche Funktionen / Sagen aufruft. </p><br><p>  "Warum nicht diese Middleware ausprobieren?"  Dachte ich und machte mich an die Arbeit.  Er begann eine technische Geschichte in Jira, erstellte darin mehrere Aufgaben (von der Recherche bis zur Implementierung und Beschreibung der Architektur dieses gesamten Systems), erhielt die Genehmigung und begann, eine minimale Kopie des aktuellen Systems mit einem neuen Ansatz zu erstellen. </p><br><p>  Am Anfang lief alles gut.  Auf Anraten eines Entwicklers war es sogar möglich, eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">globale Saga zum Laden von Daten und zur Fehlerbehandlung</a> nach einem neuen Ansatz zu erstellen.  Irgendwann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gab es jedoch Probleme beim Testen</a> (die übrigens bisher noch nicht gelöst wurden).  Ich dachte, dass dies alle derzeit verfügbaren Tests zerstören und eine Reihe von Fehlern hervorrufen könnte. Deshalb habe ich beschlossen, die Arbeit an dieser Aufgabe zu verschieben, bis eine Lösung für das Problem gefunden ist, und mich den Produktaufgaben zuzuwenden. </p><br><p>  Ein oder zwei Monate vergingen, es wurde keine Lösung gefunden, und irgendwann wurde mit ihnen diskutiert.  Sie führten (fehlende) Fortschritte bei dieser Aufgabe und beschlossen, die Implementierung von Redux-Saga im Projekt abzubrechen, da es zu diesem Zeitpunkt im Hinblick auf die Arbeitskosten und die mögliche Anzahl von Fehlern zu teuer geworden war.  Also haben wir uns endlich für Redux Thunk entschieden. </p><br><h2 id="popytka-resheniya-problemy-2-thunk-moduli">  Ein Versuch, das Problem Nummer 2 zu lösen.  Thunk-Module </h2><br><p>  Sie können alle Thunks in verschiedene Dateien sortieren und in den Dateien, in denen ein Thunk einen anderen aufruft (importiert), diesen Import entweder mit der Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>jest.mock</code></a> oder mit derselben <code>jest.spyOn</code> .  Somit werden wir die obige Aufgabe erfüllen, zu überprüfen, ob ein externer Thunk mit den erforderlichen Parametern <strong>aufgerufen wurde</strong> , ohne uns um Moks zu kümmern.  Außerdem wäre es besser, alle Thunk entsprechend ihrem funktionalen Zweck zu zerbrechen, um sie nicht alle auf einem Haufen zu halten.  So wurden drei solcher Arten unterschieden: </p><br><ul><li>  Bezogen auf die Arbeit mit Vorlagen - <code>templates</code> . </li><li>  Bezogen auf die Arbeit mit dem Filter (Sortieren, Anzeigen von Spalten) - <code>filter</code> . </li><li>  Bezogen auf die Arbeit mit der Tabelle (Laden neuer Daten beim Scrollen, da die Tabelle einen virtuellen Bildlauf hat, Laden von Metadaten, Laden von Daten über den Zähler der Datensätze in der Tabelle usw.) - <code>table</code> . </li></ul><br><p>  Die folgende Ordner- und Dateistruktur wurde vorgeschlagen: </p><br><pre> <code class="bash hljs">src/ |-- store/ | |-- filter/ | | |-- actions/ | | | |-- thunks/ | | | | |-- __tests__/ | | | | | |-- applyFilter.test.js | | | | |-- applyFilter.js | | | |-- actionCreators.js | | | |-- index.js | |-- table/ | | |-- actions/ | | | |-- thunks/ | | | | |-- __tests__/ | | | | | |-- fetchData.test.js | | | | | |-- fetchTotalCounter.test.js | | | | |-- fetchData.js | | | | |-- fetchTotalCounter.js | | | |-- actionCreators.js | | | |-- index.js (main file with actionsCreator)</code> </pre> <br><p>  Ein Beispiel für diese Architektur finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p>  In der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testdatei für applyFilter können</a> Sie sehen, dass wir das angestrebte Ziel erreicht haben - Sie können keine Mokas schreiben, um den korrekten Betrieb von <code>fetchData</code> / <code>fetchTotalCounter</code> .  Aber zu welchem ​​Preis ... </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>applyFilter.js</code></a> : </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { applyFilterSuccess, applyFilterError } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { fetchData } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../../table/actions'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// selector const getFilter = store =&gt; store.filter; export function applyFilter(prefix, getCurrentStore, entityModel) { return newFilter =&gt; { return async (dispatch, getStore) =&gt; { try { const store = getStore(); const currentStore = getCurrentStore(store); const filter = newFilter || getFilter(currentStore); const { data: { payload } } = await fetchData(prefix, entityModel)(filter, dispatch); dispatch(applyFilterSuccess(prefix)(payload)); } catch (error) { dispatch(applyFilterError(prefix)(error)); } }; }; }</span></span></code> </pre> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>actionsCreator</code></a> : </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> filterActions <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./filter/actions'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> tableActions <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./table/actions'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actionsCreator = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prefix, getCurrentStore, entityModel</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">fetchTotalCounterStart</span></span>: tableActions.fetchTotalCounterStart(prefix), <span class="hljs-attr"><span class="hljs-attr">fetchTotalCounterSuccess</span></span>: tableActions.fetchTotalCounterSuccess(prefix), <span class="hljs-attr"><span class="hljs-attr">fetchTotalCounterError</span></span>: tableActions.fetchTotalCounterError(prefix), <span class="hljs-attr"><span class="hljs-attr">applyFilterSuccess</span></span>: filterActions.applyFilterSuccess(prefix), <span class="hljs-attr"><span class="hljs-attr">applyFilterError</span></span>: filterActions.applyFilterError(prefix), <span class="hljs-attr"><span class="hljs-attr">fetchTotalCounter</span></span>: tableActions.fetchTotalCounter(prefix, entityModel), <span class="hljs-attr"><span class="hljs-attr">fetchData</span></span>: tableActions.fetchData(prefix, entityModel), <span class="hljs-attr"><span class="hljs-attr">applyFilter</span></span>: filterActions.applyFilter(prefix, getCurrentStore, entityModel) }; };</code> </pre> <br><p>  Wir mussten für die Modularität der Tests mit doppelter Codierung und einer sehr starken Abhängigkeit von Thunk voneinander bezahlen.  Die geringste Änderung in der Anrufkette führt zu einem starken Refactoring. </p><br><p>  Im obigen Beispiel wurde das Beispiel für <code>table</code> und <code>filter</code> demonstriert, um die Konsistenz der angegebenen Beispiele aufrechtzuerhalten.  Tatsächlich wurde das Refactoring mit <code>templates</code> gestartet (da es sich als einfacher herausstellte), und zusätzlich zum obigen Refactoring wurde das Konzept der Arbeit mit Vorlagen geringfügig geändert.  Als Annahme wurde angenommen, dass es auf einer Seite (wie einer Tabelle) nur ein Vorlagenfenster geben kann.  Zu dieser Zeit war es genau das und das <del>  Auslassung </del>  Die Annahme erlaubte es uns, den Code ein wenig zu vereinfachen, indem wir das <code>prefix</code> eliminierten. <br>  Nachdem die Änderungen in den Hauptentwicklungszweig eingegossen und getestet wurden, machte ich mit ruhiger Seele Urlaub, um den Rest des Codes nach meiner Rückkehr auf einen neuen Ansatz zu übertragen. </p><br><p>  Nach meiner Rückkehr aus dem Urlaub stellte ich überrascht fest, dass meine Änderungen rückgängig gemacht wurden.  Es stellte sich heraus, dass eine Seite erschien, auf der sich möglicherweise mehrere unabhängige Tabellen befinden, dh die zuvor getroffene Annahme hat alles gebrochen.  Die ganze Arbeit wurde also vergebens erledigt ... </p><br><p>  Na ja, fast.  Tatsächlich wäre es möglich, dieselben Aktionen erneut auszuführen (der Vorteil der Zusammenführungs- / Pull-Anforderung verschwand nirgendwo, sondern blieb in der Historie), wobei der Ansatz für die Vorlagenarchitektur unverändert blieb und nur der Ansatz für die Organisation von Thunk-s geändert wurde.  Dieser Ansatz hat jedoch aufgrund seiner Kohärenz und Komplexität immer noch kein Vertrauen geweckt.  Es bestand kein Wunsch, darauf zurückzukommen, obwohl dies das angegebene Problem beim Testen löste.  Es war notwendig, sich etwas anderes auszudenken, das einfacher und zuverlässiger war. </p><br><h2 id="popytka-resheniya-problemy-3-kto-ischet-tot-naydyot">  Ein Versuch, das Problem Nummer 3 zu lösen.  Wer sucht, wird finden </h2><br><p>  Als ich global betrachtete, wie Tests für Thunk geschrieben werden, bemerkte ich, wie einfach und ohne Probleme Methoden (in der Tat Objektfelder) von <code>entityModel</code> . </p><br><p>  Dann kam die Idee: Warum nicht eine Klasse erstellen, deren Methoden Thunk- und Action-Ersteller sind?  An die Factory übergebene Parameter werden an den Konstruktor dieser Klasse übergeben und sind über <code>this</code> zugänglich.  Sie können sofort eine kleine Optimierung vornehmen, indem Sie eine separate Klasse für Aktionsersteller und eine separate Klasse für Thunk erstellen und dann eine von einer anderen erben.  Somit funktionieren diese Klassen als eine Klasse (beim Erstellen einer Instanz der Erbenklasse), aber gleichzeitig ist jede Klasse einzeln leichter zu lesen, zu verstehen und zu testen. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> ist ein Code, der diesen Ansatz demonstriert. </p><br><p>  Lassen Sie uns jede der Dateien, die angezeigt und geändert wurden, genauer betrachten. </p><br><ul><li>  In der Datei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>FilterActionCreators.js</code></a> deklarieren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>FilterActionCreators.js</code></a> eine Klasse, in der die Methoden Aktionsersteller sind: </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FilterActionCreators</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(config) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prefix = config.prefix; } applyFilterSuccess = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">payload</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.prefix}</span></span></span><span class="hljs-string">APPLY_FILTER_SUCCESS`</span></span>, payload, }); applyFilterError = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.prefix}</span></span></span><span class="hljs-string">APPLY_FILTER_ERROR`</span></span>, error, }); }</code> </pre> <br><ul><li>  In der Datei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>FilterActions.js</code></a> erben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>FilterActions.js</code></a> von der <code>FilterActionCreators</code> Klasse und definieren <code>applyFilter</code> als Methode dieser Klasse.  In diesem Fall sind die Aktionsersteller <code>applyFilterSuccess</code> und <code>applyFilterError</code> folgendermaßen verfügbar: </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { FilterActionCreators } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'/FilterActionCreators'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// selector const getFilter = store =&gt; store.filter; export class FilterActions extends FilterActionCreators { constructor(config) { super(config); this.getCurrentStore = config.getCurrentStore; this.entityModel = config.entityModel; } applyFilter = ({ fetchData }) =&gt; { return newFilter =&gt; { return async (dispatch, getStore) =&gt; { try { const store = getStore(); const currentStore = this.getCurrentStore(store); const filter = newFilter || getFilter(currentStore); const { data: { payload } } = await fetchData(filter, dispatch); // Comes from FilterActionCreators dispatch(this.applyFilterSuccess(payload)); } catch (error) { // Comes from FilterActionCreators dispatch(this.applyFilterError(error)); } }; }; }; }</span></span></code> </pre> <br><ul><li>  In der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hauptdatei</a> mit allen Thunk- und Aktionserstellern erstellen wir eine Instanz der <code>FilterActions</code> Klasse und übergeben ihr das erforderliche Konfigurationsobjekt.  Vergessen Sie beim Exportieren von Funktionen (ganz am Ende der <code>actionsCreator</code> Funktion) nicht, die <code>applyFilter</code> Methode zu überschreiben, um die <code>fetchData</code> Abhängigkeit an <code>fetchData</code> : </li></ul><br><pre> <code class="diff hljs"><span class="hljs-addition"><span class="hljs-addition">+ import { FilterActions } from './filter/actions/FilterActions'; - // selector - const getFilter = store =&gt; store.filter; export const actionsCreator = (prefix, getCurrentStore, entityModel) =&gt; { + const config = { prefix, getCurrentStore, entityModel }; + const filterActions = new FilterActions(config); /* --- ACTIONS BLOCK --- */ function fetchTotalCounterStart() { return { type: `${prefix}FETCH_TOTAL_COUNTER_START` }; } function fetchTotalCounterSuccess(payload) { return { type: `${prefix}FETCH_TOTAL_COUNTER_SUCCESS`, payload }; } function fetchTotalCounterError(error) { return { type: `${prefix}FETCH_TOTAL_COUNTER_ERROR`, error }; } - function applyFilterSuccess(payload) { - return { type: `${prefix}APPLY_FILTER_SUCCESS`, payload }; - } - - function applyFilterError(error) { - return { type: `${prefix}APPLY_FILTER_ERROR`, error }; - } /* --- THUNKS BLOCK --- */ function fetchTotalCounter(filter) { return async dispatch =&gt; { dispatch(fetchTotalCounterStart()); try { const { data: { payload } } = await entityModel.fetchTotalCounter(filter); dispatch(fetchTotalCounterSuccess(payload)); } catch (error) { dispatch(fetchTotalCounterError(error)); } }; } function fetchData(filter, dispatch) { dispatch(fetchTotalCounter(filter)); return entityModel.fetchData(filter); } - function applyFilter(newFilter) { - return async (dispatch, getStore) =&gt; { - try { - const store = getStore(); - const currentStore = getCurrentStore(store); - // 'getFilter' comes from selectors. - const filter = newFilter || getFilter(currentStore); - const { data: { payload } } = await fetchData(filter, dispatch); - - dispatch(applyFilterSuccess(payload)); - } catch (error) { - dispatch(applyFilterError(error)); - } - }; - } return { fetchTotalCounterStart, fetchTotalCounterSuccess, fetchTotalCounterError, - applyFilterSuccess, - applyFilterError, fetchTotalCounter, fetchData, - applyFilter + ...filterActions, + applyFilter: filterActions.applyFilter({ fetchData }), }; };</span></span></code> </pre> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tests</a> sind sowohl in der Implementierung als auch beim Lesen etwas einfacher geworden: </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { FilterActions } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../FilterActions'</span></span>; describe(<span class="hljs-string"><span class="hljs-string">'FilterActions'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prefix = <span class="hljs-string"><span class="hljs-string">'TEST_'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getCurrentStore = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">store</span></span></span><span class="hljs-function"> =&gt;</span></span> store; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> entityModel = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> config = { prefix, getCurrentStore, entityModel }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FilterActions(config); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dispatch = jest.fn(); beforeEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { dispatch.mockClear(); }); describe(<span class="hljs-string"><span class="hljs-string">'applyFilter'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getStore = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newFilter = {}; it(<span class="hljs-string"><span class="hljs-string">'should dispatch correct actions on success'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> payload = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fetchData = jest.fn().mockResolvedValueOnce({ <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { payload } }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> applyFilterSuccess = jest.spyOn(actions, <span class="hljs-string"><span class="hljs-string">'applyFilterSuccess'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> actions.applyFilter({ fetchData })(newFilter)(dispatch, getStore); expect(fetchData).toBeCalledWith(newFilter, dispatch); expect(applyFilterSuccess).toBeCalledWith(payload); }); it(<span class="hljs-string"><span class="hljs-string">'should dispatch correct actions on error'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fetchData = jest.fn().mockRejectedValueOnce(error); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> applyFilterError = jest.spyOn(actions, <span class="hljs-string"><span class="hljs-string">'applyFilterError'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> actions.applyFilter({ fetchData })(newFilter)(dispatch, getStore); expect(fetchData).toBeCalledWith(newFilter, dispatch); expect(applyFilterError).toBeCalledWith(error); }); }); });</code> </pre><br><p>  Grundsätzlich können Sie in Tests die letzte Prüfung folgendermaßen ersetzen: </p><br><pre> <code class="diff hljs"><span class="hljs-deletion"><span class="hljs-deletion">- expect(applyFilterSuccess).toBeCalledWith(payload); + expect(dispatch).toBeCalledWith(applyFilterSuccess(payload)); - expect(applyFilterError).toBeCalledWith(error); + expect(dispatch).toBeCalledWith(applyFilterError(error));</span></span></code> </pre> <br><p>  Dann wäre es nicht nötig, sie mit <code>jest.spyOn</code> .    ,  ,            .        thunk,       .    ,    ... </p><br><p>    ,  ,    ,     -: ,  thunk-  action creator-      ,    ,   .        ,   .         <code>actionsCreator</code> -   ,   : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { FilterActions } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./filter/actions/FilterActions'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { TemplatesActions } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./templates/actions/TemplatesActions'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { TableActions } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./table/actions/TableActions'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actionsCreator = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prefix, getCurrentStore, entityModel</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> config = { prefix, getCurrentStore, entityModel }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> filterActions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FilterActions(config); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> templatesActions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TemplatesActions(config); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tableActions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TableActions(config); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...filterActions, ...templatesActions, ...tableActions, }; };</code> </pre> <br><p>     .     <code>filterActions</code>          <code>templatesActions</code>  <code>tableActions</code> ,   ,   ,     <code>filterActions</code> ?           ,    .           .         - ,      ,    . </p><br><p>   .      ,     back-end  (  Java),      .   ,  Java/Spring      ,   .         - ? </p><br><p>      : </p><br><ul><li>    thunk-   <code>setDependencies</code> ,        — <code>dependencies</code> : </li></ul><br><pre> <code class="diff hljs">export class FilterActions extends FilterActionCreators { constructor(config) { super(config); this.getCurrentStore = config.getCurrentStore; this.entityModel = config.entityModel; } + setDependencies = dependencies =&gt; { + this.dependencies = dependencies; + };</code> </pre> <br><ul><li>                     : </li></ul><br><pre> <code class="diff hljs">import { FilterActions } from './filter/actions/FilterActions'; import { TemplatesActions } from './templates/actions/TemplatesActions'; import { TableActions } from './table/actions/TableActions'; export const actionsCreator = (prefix, getCurrentStore, entityModel) =&gt; { const config = { prefix, getCurrentStore, entityModel }; const filterActions = new FilterActions(config); const templatesActions = new TemplatesActions(config); const tableActions = new TableActions(config); + const actions = { + ...filterActions, + ...templatesActions, + ...tableActions, + }; + + filterActions.setDependencies(actions); + templatesActions.setDependencies(actions); + tableActions.setDependencies(actions); + return actions; - return { - ...filterActions, - ...templatesActions, - ...tableActions, - }; };</code> </pre> <br><ul><li>     <code>this.dependencies</code> : </li></ul><br><pre> <code class="javascript hljs">applyFilter = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">newFilter</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { fetchData } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dependencies; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (dispatch, getStore) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> store = getStore(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> currentStore = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getCurrentStore(store); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> filter = newFilter || getFilter(currentStore); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { payload } } = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchData(filter, dispatch); <span class="hljs-comment"><span class="hljs-comment">// Comes from FilterActionCreators dispatch(this.applyFilterSuccess(payload)); } catch (error) { // Comes from FilterActionCreators dispatch(this.applyFilterError(error)); } }; };</span></span></code> </pre> <br><p>    ,        <code>applyFilter</code>   ,   -  <code>this.dependencies</code>    .         ,         . </p><br><ul><li>   : </li></ul><br><pre> <code class="diff hljs">import { FilterActions } from '../FilterActions'; describe('FilterActions', () =&gt; { const prefix = 'TEST_'; const getCurrentStore = store =&gt; store; const entityModel = {}; + const dependencies = { + fetchData: jest.fn(), + }; const config = { prefix, getCurrentStore, entityModel }; const actions = new FilterActions(config); + actions.setDependencies(dependencies); const dispatch = jest.fn(); beforeEach(() =&gt; { dispatch.mockClear(); }); describe('applyFilter', () =&gt; { const getStore = () =&gt; ({}); const newFilter = {}; it('should dispatch correct actions on success', async () =&gt; { const payload = {}; - const fetchData = jest.fn().mockResolvedValueOnce({ data: { payload } }); + dependencies.fetchData.mockResolvedValueOnce({ data: { payload } }); const applyFilterSuccess = jest.spyOn(actions, 'applyFilterSuccess'); - await actions.applyFilter({ fetchData })(newFilter)(dispatch, getStore); + await actions.applyFilter(newFilter)(dispatch, getStore); - expect(fetchData).toBeCalledWith(newFilter, dispatch); + expect(dependencies.fetchData).toBeCalledWith(newFilter, dispatch); expect(applyFilterSuccess).toBeCalledWith(payload); }); it('should dispatch correct actions on error', async () =&gt; { const error = {}; - const fetchData = jest.fn().mockRejectedValueOnce(error); + dependencies.fetchData.mockRejectedValueOnce(error); const applyFilterError = jest.spyOn(actions, 'applyFilterError'); - await actions.applyFilter({ fetchData })(newFilter)(dispatch, getStore); + await actions.applyFilter(newFilter)(dispatch, getStore); - expect(fetchData).toBeCalledWith(newFilter, dispatch); + expect(dependencies.fetchData).toBeCalledWith(newFilter, dispatch); expect(applyFilterError).toBeCalledWith(error); }); }); });</code> </pre> <br><p>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> . </p><br><p>       ,   ,            : </p><br><ul><li>   : </li></ul><br><pre> <code class="diff hljs">import { FilterActions } from './filter/actions/FilterActions'; import { TemplatesActions } from './templates/actions/TemplatesActions'; import { TableActions } from './table/actions/TableActions'; - export const actionsCreator = (prefix, getCurrentStore, entityModel) =&gt; { + export const actionsCreator = (prefix, getCurrentStore, entityModel, ExtendedActions) =&gt; { const config = { prefix, getCurrentStore, entityModel }; const filterActions = new FilterActions(config); const templatesActions = new TemplatesActions(config); const tableActions = new TableActions(config); + const extendedActions = ExtendedActions ? new ExtendedActions(config) : undefined; const actions = { ...filterActions, ...templatesActions, ...tableActions, + ...extendedActions, }; filterActions.setDependencies(actions); templatesActions.setDependencies(actions); tableActions.setDependencies(actions); + if (extendedActions) { + extendedActions.setDependencies(actions); + } return actions; };</code> </pre> <br><ul><li>   <code>ExtendedActions</code>    ,     : </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExtendedActions</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(config) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getCurrentStore = config.getCurrentStore; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entityModel = config.entityModel; } setDependencies = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dependencies</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dependencies = dependencies; }; <span class="hljs-comment"><span class="hljs-comment">// methods to re-define }</span></span></code> </pre> <br><p>  ,    ,   : </p><br><ul><li>    ,     . </li><li>      . </li><li>     ,   ,     thunk-         . </li><li>   ,      ,   thunk-/action creator-      99-100%. </li></ul><br><h2 id="bonus">  Bonus </h2><br><p>   action creator-     ( <code>filter</code> , <code>templates</code> , <code>table</code> ),   reducer-   -  ,        ,    <code>actionsCreator</code> - ,         reducer-  ~400-500  . </p><br><p>      : </p><br><ul><li>   reducer-: </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> isNull <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lodash/isNull'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { getDefaultState } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../getDefaultState'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { templatesReducerConfigurator } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'src/store/templates/reducers/templatesReducerConfigurator'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { filterReducerConfigurator } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'src/store/filter/reducers/filterReducerConfigurator'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { tableReducerConfigurator } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'src/store/table/reducers/tableReducerConfigurator'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createTableReducer = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> prefix, initialState = getDefaultState(</span></span></span><span class="hljs-function">), </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">entityModel</span></span></span><span class="hljs-function">, ) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> config = { prefix, initialState, entityModel }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> templatesReducer = templatesReducerConfigurator(config); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> filterReducer = filterReducerConfigurator(config); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tableReducer = tableReducerConfigurator(config); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state = initialState, action</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> templatesState = templatesReducer(state, action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isNull(templatesState)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> templatesState; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> filterState = filterReducer(state, action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isNull(filterState)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> filterState; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tableState = tableReducer(state, action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isNull(tableState)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tableState; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; }; };</code> </pre> <br><ul><li> <code>tableReducerConfigurator</code> ( ): </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tableReducerConfigurator = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ prefix, entityModel }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, action</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${prefix}</span></span></span><span class="hljs-string">FETCH_TOTAL_COUNTER_START`</span></span>: { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, <span class="hljs-attr"><span class="hljs-attr">isLoading</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">error</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, }; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${prefix}</span></span></span><span class="hljs-string">FETCH_TOTAL_COUNTER_SUCCESS`</span></span>: { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, <span class="hljs-attr"><span class="hljs-attr">isLoading</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">counter</span></span>: action.payload, }; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${prefix}</span></span></span><span class="hljs-string">FETCH_TOTAL_COUNTER_ERROR`</span></span>: { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, <span class="hljs-attr"><span class="hljs-attr">isLoading</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">error</span></span>: action.error, }; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }; };</code> </pre> <br><p>  : </p><br><ol><li>   <code>reducerConfigurator</code> -    action type-,   «».  action type      case,    <em>null</em> (). </li><li>   <code>reducerConfigurator</code> -      ,  <em>null</em> ,     <code>reducerConfigurator</code> -  <em>!null</em> .    ,    <code>reducerConfigurator</code> -   case,      <code>reducerConfigurator</code> -. </li><li>   ,      <code>reducerConfigurator</code> -    case-   action type-,     (  reducer-). </li></ol><br><p>    ,    <code>actionsCreator</code> -,     ,      ,  ,  . </p><br><p>   ,   ! <br> ,             Redux Thunk. </p><br><p>   ,    Redux Thunk      .   ,    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469371/">https://habr.com/ru/post/de469371/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469355/index.html">Ein langweiliges NumPy-Tutorial</a></li>
<li><a href="../de469357/index.html">Lauf, Gopher, lauf! - worüber werden wir auf der GolangConf sprechen?</a></li>
<li><a href="../de469361/index.html">Schmerz und Tränen in Svelte 3</a></li>
<li><a href="../de469367/index.html">Führen Sie Unit-Tests lokal in STM32CubeIDE unter Windows aus</a></li>
<li><a href="../de469369/index.html">Digitale Veranstaltungen in Moskau vom 30. September bis 06. Oktober</a></li>
<li><a href="../de469373/index.html">Die Ergebnisse des Projekts zur Schaffung einer neuronalen Schnittstelle für vollständig gelähmte Patienten wurden in Frage gestellt</a></li>
<li><a href="../de469375/index.html">Warum stellen Mozilla, Coil und Creative Commons 100 Millionen US-Dollar für Open Source-Projekte zur Verfügung?</a></li>
<li><a href="../de469379/index.html">Anwendung formaler Modellvalidierungsmethoden für die Benutzeroberfläche</a></li>
<li><a href="../de469381/index.html">Agones, erstellen Sie einen Mehrbenutzer-Spieleserver. Architektur und Installation</a></li>
<li><a href="../de469383/index.html">Hyperkonvergente Lösung AERODISK vAIR. Basis - ARDFS-Dateisystem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>