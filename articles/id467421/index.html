<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐞 👌🏿 🍛 Buat pointer cerdas ekspresif untuk memori jarak jauh di C ++ 🏯 🎟️ 🐋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 

 Hari ini kami menerbitkan terjemahan studi yang menarik tentang bekerja dengan memori dan petunjuk dalam C ++. Materi ini sedikit akade...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buat pointer cerdas ekspresif untuk memori jarak jauh di C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/467421/">  Halo, Habr! <br><br>  Hari ini kami menerbitkan terjemahan studi yang menarik tentang bekerja dengan memori dan petunjuk dalam C ++.  Materi ini sedikit akademis, tetapi jelas akan menarik bagi pembaca buku-buku <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Galowitz</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Williams</a> . <br><br>  Ikuti iklannya! <br><a name="habracut"></a><br>  Di sekolah pascasarjana, saya terlibat dalam pembangunan struktur data terdistribusi.  Oleh karena itu, abstraksi yang mewakili remote pointer sangat penting dalam pekerjaan saya untuk membuat kode yang bersih dan rapi.  Pada artikel ini, saya akan menjelaskan mengapa pointer pintar diperlukan, katakan bagaimana saya menulis objek pointer jarak jauh di C ++ untuk perpustakaan saya, pastikan bahwa mereka bekerja persis seperti pointer C ++ biasa;  ini dilakukan menggunakan objek tautan jauh.  Lebih lanjut saya akan menjelaskan dalam kasus apa abstraksi ini gagal karena alasan sederhana bahwa pointer saya sendiri (sejauh ini) tidak mengatasi tugas-tugas yang dapat dilakukan pointer biasa.  Saya harap artikel ini akan menarik minat pembaca yang terlibat dalam pengembangan abstraksi tingkat tinggi. <br><br><h3>  API Tingkat Rendah </h3><br>  Saat bekerja dengan komputer terdistribusi atau dengan perangkat keras jaringan, Anda sering memiliki akses baca dan tulis ke sepotong memori melalui API C. Salah satu contoh dari jenis ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MPI</a> API untuk komunikasi satu arah.  API ini menggunakan fungsi yang membuka akses langsung untuk membaca dan menulis dari memori node lain yang terletak di cluster terdistribusi.  Begini tampilannya dengan cara yang sedikit disederhanakan. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remote_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> target_node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remote_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> target_node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>;</code> </pre> <br>  Pada <i>offset yang</i> ditunjukkan ke segmen memori bersama dari node target, <code>remote_read</code> sejumlah byte dari itu, dan <code>remote_write</code> menulis sejumlah byte. <br><br>  API ini sangat bagus karena memberi kami akses ke primitif penting yang berguna bagi kami untuk mengimplementasikan program yang berjalan di sekelompok komputer.  Mereka juga sangat baik karena mereka bekerja sangat cepat dan akurat mencerminkan kemampuan yang ditawarkan pada tingkat perangkat keras: akses memori langsung jarak jauh (RDMA).  Jaringan superkomputer modern, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cray Aries</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mellanox EDR</a> , memungkinkan kami menghitung bahwa keterlambatan membaca / menulis tidak akan melebihi 1-2 μs.  Indikator ini dapat dicapai karena kartu jaringan (NIC) dapat membaca dan menulis langsung ke RAM, tanpa menunggu CPU jarak jauh untuk bangun dan menanggapi permintaan jaringan Anda. <br><br>  Namun, API semacam itu tidak begitu baik dalam hal pemrograman aplikasi.  Bahkan dalam kasus API sederhana seperti yang dijelaskan di atas, tidak ada biaya apa pun untuk secara tidak sengaja menghapus data, karena tidak ada nama terpisah untuk setiap objek tertentu yang disimpan dalam memori, hanya satu buffer besar yang berdekatan.  Selain itu, antarmuka tidak diketik, yaitu, Anda kehilangan bantuan nyata lainnya: ketika kompiler bersumpah, jika Anda menuliskan nilai dari jenis yang salah di tempat yang salah.  Kode Anda hanya akan berubah menjadi salah, dan kesalahan akan menjadi yang paling misterius dan bersifat bencana.  Situasinya bahkan lebih rumit karena pada kenyataannya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API</a> ini sedikit lebih rumit, dan ketika bekerja dengan mereka, sangat mungkin untuk secara keliru mengatur ulang dua atau lebih parameter. <br><br><h3>  Pointer yang Dihapus </h3><br>  Pointer adalah level abstraksi yang penting dan perlu saat membuat alat pemrograman tingkat tinggi.  Menggunakan pointer secara langsung kadang-kadang sulit, dan Anda dapat melakukan banyak bug, tetapi pointer adalah blok bangunan mendasar dari kode.  Struktur data dan bahkan tautan C ++ sering menggunakan pointer di bawah tenda. <br><br>  Jika kita berasumsi bahwa kita akan memiliki API yang mirip dengan yang dijelaskan di atas, maka lokasi unik dalam memori akan ditunjukkan oleh dua "koordinat": (1) <i>peringkat</i> atau ID proses dan (2) offset yang dibuat untuk bagian bersama dari memori jauh yang ditempati oleh proses dengan peringkat ini .  Anda tidak dapat berhenti di situ dan membuat struktur yang lengkap. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">remote_ptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> rank_; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset_; };</code> </pre> <br>  Pada tahap ini, sudah dimungkinkan untuk merancang API untuk membaca dan menulis ke remote pointer, dan API ini akan lebih aman daripada yang kami gunakan sebelumnya. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> remote_ptr&lt;T&gt; src)</span></span></span><span class="hljs-function"> </span></span>{ T rv; remote_read(&amp;rv, src.rank_, src.offset_, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rv; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(remote_ptr&lt;T&gt; dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; src)</span></span></span><span class="hljs-function"> </span></span>{ remote_write(&amp;src, dst.rank_, dst.offset_, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T)); }</code> </pre> <br>  Blok transfer terlihat sangat mirip, dan di sini saya menghilangkannya untuk singkatnya.  Sekarang, untuk nilai membaca dan menulis, Anda dapat menulis kode berikut: <br><br><pre> <code class="cpp hljs"> remote_ptr&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; ptr = ...; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rval = rget(ptr); rval++; rput(ptr, rval);</code> </pre> <br>  Ini sudah lebih baik daripada API asli, karena di sini kami bekerja dengan objek yang diketik.  Sekarang tidak mudah untuk menulis atau membaca nilai dari jenis yang salah atau hanya menulis bagian dari suatu objek. <br><br><h3>  Aritmatika Pointer </h3><br>  Aritmetika pointer adalah teknik paling penting yang memungkinkan seorang programmer untuk mengelola koleksi nilai dalam memori;  jika kita menulis sebuah program untuk pekerjaan yang didistribusikan dalam memori, mungkin kita akan beroperasi dengan koleksi nilai yang besar. <br>  Apa artinya menambah atau mengurangi pointer yang dihapus dengan satu maksud?  Opsi paling sederhana adalah dengan mempertimbangkan aritmatika dari pointer yang dihapus sebagai aritmatika dari pointer biasa: p + 1 secara sederhana menunjuk ke <code>sizeof(T)</code> berikutnya <code>sizeof(T)</code> selaraskan memori setelah p dalam segmen bersama dari peringkat asli. <br><br>  Meskipun ini bukan satu-satunya definisi yang mungkin dari aritmatika remote pointer, ini telah paling aktif diadopsi baru-baru ini, dan remote pointer yang digunakan dengan cara ini terkandung dalam perpustakaan seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UPC ++</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DASH</a> dan BCL.  Namun, bahasa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Unified Parallel C</a> (UPC), yang telah meninggalkan warisan yang kaya di komunitas spesialis komputasi kinerja tinggi (HPC), berisi definisi aritmatika pointer yang lebih rumit [1]. <br><br>  Menerapkan aritmatika pointer dengan cara ini sederhana, dan itu hanya melibatkan mengubah offset pointer. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; remote_ptr&lt;T&gt; remote_ptr&lt;T&gt;::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> diff) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> new_offset = offset_ + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T)*diff; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> remote_ptr&lt;T&gt;{rank_, new_offset}; }</code> </pre> <br>  Dalam hal ini, kami memiliki kesempatan untuk mengakses array data dalam memori yang didistribusikan.  Jadi, kita dapat mencapai bahwa setiap proses dalam program SPMD akan melakukan operasi tulis atau baca pada variabelnya dalam array yang diarahkan oleh penunjuk jarak jauh [2]. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(remote_ptr&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (my_rank() &lt; len) { rput(ptr + my_rank(), my_rank()); } }</code> </pre> <br>  Juga mudah untuk mengimplementasikan operator lain, memberikan dukungan untuk set lengkap operasi aritmatika yang dilakukan dalam aritmatika pointer biasa. <br><br><h3>  Pilih nullptr </h3><br>  Untuk pointer reguler, nilai <code>nullptr</code> adalah <code>NULL</code> , yang biasanya berarti mengurangi <code>#define</code> menjadi 0x0, karena bagian ini dalam memori tidak mungkin digunakan.  Dalam skema kami dengan remote pointer, kami dapat memilih nilai pointer tertentu sebagai <code>nullptr</code> , sehingga membuat lokasi ini dalam memori tidak digunakan, atau menyertakan anggota Boolean khusus yang akan menunjukkan apakah pointer tersebut nol.  Terlepas dari kenyataan bahwa membuat lokasi tertentu dalam memori yang tidak terpakai bukanlah jalan keluar terbaik, kami juga akan mempertimbangkan bahwa ketika menambahkan hanya satu nilai Boolean, ukuran penunjuk jarak jauh akan berlipat ganda dari sudut pandang sebagian besar penyusun dan tumbuh dari 128 hingga 256 bit untuk mempertahankan keselarasan.  Ini terutama tidak diinginkan.  Di perpustakaan saya, saya memilih <code>{0, 0}</code> , yaitu offset 0 dengan pangkat 0, sebagai nilai <code>nullptr</code> . <br><br>  Dimungkinkan untuk mengambil opsi lain untuk <code>nullptr</code> yang juga berfungsi.  Selain itu, dalam beberapa lingkungan pemrograman, seperti UPC, pointer sempit diterapkan yang masing-masing berukuran 64 bit.  Dengan demikian, mereka dapat digunakan dalam operasi perbandingan atom dengan pertukaran.  Ketika bekerja dengan pointer sempit, Anda harus berkompromi: pengidentifikasi offset atau pengidentifikasi peringkat harus sesuai dalam 32 bit atau kurang, dan ini membatasi skalabilitas. <br><br><h3>  Tautan yang Dihapus </h3><br>  Dalam bahasa seperti Python, pernyataan braket berfungsi sebagai gula sintaksis untuk memanggil metode <code>__setitem__</code> dan <code>__getitem__</code> , tergantung pada apakah Anda membaca objek atau menulisnya.  Dalam C ++, <code>operator[]</code> tidak membedakan mana dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kategori nilai</a> yang dimiliki objek dan apakah nilai yang dikembalikan akan langsung jatuh di bawah baca atau tulis.  Untuk mengatasi masalah ini, struktur data C ++ mengembalikan tautan yang menunjuk ke memori yang terkandung dalam wadah, yang dapat ditulis atau dibaca.  Implementasi <code>operator[]</code> untuk <code>std::vector</code> mungkin terlihat seperti ini. <br><br><pre> <code class="cpp hljs"> T&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> idx) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data_[idx]; }</code> </pre><br>  Fakta paling signifikan di sini adalah bahwa kami mengembalikan entitas tipe <code>T&amp;</code> , yang merupakan tautan C ++ mentah yang dapat digunakan untuk menulis, dan bukan entitas tipe <code>T</code> , yang hanya mewakili nilai dari data sumber. <br><br>  Dalam kasus kami, kami tidak dapat mengembalikan tautan C ++ mentah, karena kami merujuk ke memori yang terletak di node lain dan tidak terwakili dalam ruang alamat virtual kami.  Benar, kita dapat membuat objek referensi khusus kita sendiri. <br>  Tautan adalah objek yang berfungsi sebagai pembungkus di sekitar penunjuk, dan melakukan dua fungsi penting: tautan dapat dikonversi ke nilai tipe <code>T</code> , dan Anda juga dapat menetapkannya ke nilai tipe <code>T</code>  Jadi, dalam kasus referensi jarak jauh, kita hanya perlu mengimplementasikan operator konversi implisit yang membaca nilai, dan juga membuat operator penugasan yang menulis ke nilai tersebut. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">remote_ref</span></span></span><span class="hljs-class"> {</span></span> remote_ptr&lt;T&gt; ptr_; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rget(ptr_); } remote_ref&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; value) { rput(ptr_, value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } };</code> </pre><br>  Dengan demikian, kita dapat memperkaya penunjuk jarak jauh kita dengan fitur-fitur canggih yang baru, dengan kehadiran yang dapat disamakan persis seperti petunjuk biasa. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; remote_ref&lt;T&gt; remote_ptr&lt;T&gt;::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> remote_ref&lt;T&gt;{*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; remote_ref&lt;T&gt; remote_ptr&lt;T&gt;::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](<span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> idx) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> remote_ref&lt;T&gt;{*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> + idx}; }</code> </pre> <br>  Jadi sekarang kami telah memulihkan seluruh gambar yang menunjukkan bagaimana Anda dapat menggunakan remote pointer seperti biasa.  Kita dapat menulis ulang program sederhana di atas. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(remote_ptr&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (my_rank() &lt; len) { ptr[my_rank()] = my_rank(); } }</code> </pre> <br>  Tentu saja, API penunjuk baru kami memungkinkan kami untuk menulis program yang lebih kompleks, misalnya, fungsi untuk melakukan pengurangan paralel berdasarkan pohon [3].  Implementasi yang menggunakan kelas pointer jarak jauh kami lebih aman dan lebih bersih daripada yang biasanya diperoleh menggunakan API C yang dijelaskan di atas. <br><br><h3>  Biaya yang timbul saat runtime (atau ketiadaan!) </h3><br>  Namun, berapa biayanya bagi kita untuk menggunakan abstraksi tingkat tinggi seperti itu?  Setiap kali kita mengakses memori, kita memanggil metode dereferencing, mengembalikan objek perantara yang membungkus pointer, lalu kita memanggil operator konversi atau operator penugasan yang mempengaruhi objek perantara.  Berapa biayanya kami pada saat runtime? <br><br>  Ternyata jika Anda dengan hati-hati menunjuk kelas pointer dan referensi, maka tidak akan ada overhead untuk abstraksi ini pada saat runtime - kompiler C ++ modern menangani objek-objek perantara dan pemanggilan metode dengan embedding agresif.  Untuk mengevaluasi berapa biaya abstraksi seperti itu, kita dapat mengkompilasi program contoh sederhana dan memeriksa bagaimana perakitan akan pergi untuk melihat objek dan metode apa yang akan ada saat runtime.  Dalam contoh yang dijelaskan di sini dengan reduksi berbasis pohon yang dikompilasi dengan kelas-kelas dari remote pointer dan referensi, kompiler modern mengurangi reduksi berbasis-pohon menjadi beberapa <code>remote_write</code> dan <code>remote_write</code> [4].  Tidak ada metode kelas yang dipanggil, tidak ada objek referensi saat runtime. <br><br><h3>  Interaksi dengan pustaka struktur data </h3><br>  Pemrogram C ++ yang berpengalaman ingat bahwa pustaka templat C ++ standar menyatakan: Wadah STL harus mendukung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengalokasi C ++ khusus</a> .  Allocator memungkinkan Anda untuk mengalokasikan memori, dan kemudian memori ini dapat dirujuk menggunakan jenis pointer yang dibuat oleh kami.  Apakah ini berarti Anda cukup membuat "pengalokasi jarak jauh" dan menghubungkannya untuk menyimpan data dalam memori jauh menggunakan wadah STL? <br><br>  Sayangnya tidak.  Agaknya, untuk alasan kinerja, standar C ++ tidak lagi membutuhkan dukungan untuk tipe referensi khusus, dan di sebagian besar implementasi pustaka standar C ++ mereka benar-benar tidak didukung.  Jadi, misalnya, jika Anda menggunakan libstdc ++ dari GCC, Anda dapat menggunakan pointer khusus, tetapi hanya tautan C ++ normal yang tersedia untuk Anda, yang tidak memungkinkan Anda untuk menggunakan wadah STL dalam memori jarak jauh.  Beberapa pustaka template C ++ tingkat tinggi, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Agensi</a> , yang menggunakan tipe pointer khusus dan tipe referensi, berisi implementasi sendiri dari beberapa struktur data dari STL yang benar-benar memungkinkan Anda untuk bekerja dengan tipe referensi jarak jauh.  Dalam hal ini, programmer mendapatkan lebih banyak kebebasan dalam pendekatan kreatif untuk menciptakan jenis pengalokasi, pointer dan tautan, dan, di samping itu, mendapatkan koleksi struktur data yang secara otomatis dapat digunakan dengannya. <br><br><h3>  Konteks yang luas </h3><br>  Dalam artikel ini, kami telah membahas sejumlah masalah yang lebih luas dan belum terselesaikan. <br><br><ul><li>  <b>Alokasi memori</b> .  Sekarang kita dapat mereferensikan objek dalam memori jarak jauh, bagaimana cara kita memesan atau mengalokasikan memori jarak jauh seperti itu? </li><li>  <b>Dukungan untuk objek</b> .  Bagaimana dengan penyimpanan dalam memori jauh dari objek-objek semacam itu yang lebih rumit daripada int?  Apakah dukungan rapi untuk tipe kompleks mungkin?  Dapatkah tipe sederhana didukung pada saat yang sama tanpa membuang sumber daya pada serialisasi? </li><li>  <b>Merancang struktur data terdistribusi</b> .  Sekarang setelah Anda memiliki abstraksi ini, struktur data dan aplikasi apa yang dapat Anda buat dengannya?  Abstraksi apa yang harus digunakan untuk distribusi data? </li></ul><br><h3>  Catatan </h3><br>  [1] Di UPC, pointer memiliki fase yang menentukan peringkat apa yang akan diarahkan oleh pointer setelah bertambah satu.  Karena fase, array yang didistribusikan dapat dienkapsulasi dalam pointer, dan pola distribusi di dalamnya bisa sangat berbeda.  Fitur-fitur ini sangat kuat, tetapi mungkin tampak ajaib bagi pengguna pemula.  Meskipun beberapa ace UPC benar-benar lebih suka pendekatan ini, pendekatan berorientasi objek yang lebih masuk akal adalah dengan menulis kelas pointer jarak jauh sederhana terlebih dahulu dan kemudian memastikan bahwa data dialokasikan berdasarkan pada struktur data yang dirancang khusus untuk ini. <br><br>  [2] Sebagian besar aplikasi dalam HPC ditulis dalam gaya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SPMD</a> , nama ini berarti "satu program, data berbeda."  API SPMD menawarkan fungsi atau variabel <code>my_rank()</code> yang memberi tahu proses mengeksekusi program peringkat atau ID unik, berdasarkan yang dapat bercabang dari program utama. <br><br>  [3] Berikut ini adalah pengurangan pohon sederhana yang ditulis dalam gaya SPMD menggunakan kelas pointer jarak jauh.  Kode ini diadaptasi berdasarkan program yang awalnya ditulis oleh rekan saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Andrew Belt</a> . <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parallel_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(remote_ptr&lt;T&gt; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> k = len; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { k = (k + <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (my_rank() &lt; k &amp;&amp; my_rank() + k &lt; len) { a[my_rank()] += a[my_rank() + k]; } len = k; barrier(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (k &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre><br>  [4] Hasil kompilasi dari kode di atas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dapat ditemukan di sini</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467421/">https://habr.com/ru/post/id467421/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467407/index.html">Kami bekerja dengan cobot Dobot M1</a></li>
<li><a href="../id467409/index.html">Untuk melakukan bisnis di Lembah Silikon, Anda harus berperilaku baik</a></li>
<li><a href="../id467413/index.html">Kerangka kerja microservice PHP - `Halo dunia` dari Swoft</a></li>
<li><a href="../id467415/index.html">Pasar valuta asing modern</a></li>
<li><a href="../id467419/index.html">Rilis Final EE 8 Jakarta Dirilis</a></li>
<li><a href="../id467423/index.html">Xamarin.Forms - penggunaan font ikon yang nyaman dalam aplikasi</a></li>
<li><a href="../id467425/index.html">Pendekatan Pembelajaran Intensif STEM</a></li>
<li><a href="../id467427/index.html">BudgetTracker - alat open-source lain untuk akuntansi keuangan pribadi</a></li>
<li><a href="../id467429/index.html">Habrastatistics: menjelajahi bagian situs yang paling banyak dikunjungi dan paling tidak dikunjungi</a></li>
<li><a href="../id467435/index.html">Kami mengirim laporan agen Veeam Linux ke email atau di Telegram</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>